quality_attribute,sentence,source,author,repo,version,id,keyword,matched_word,match_idx,filename,wiki,url,total_similar,target_keywords,target_matched_words
Safety," TTimer.cxx. ◆ Start(). void TTimer::Start ; (; Long_t ; milliSec = -1, . Bool_t ; singleShot = kFALSE . ). virtual . Starts the timer with a milliSec timeout. ; If milliSec is 0 then the timeout will be the minimum timeout (see TSystem::ESysConstants, i.e. 10 ms), if milliSec is -1 then the time interval as previously specified (in ctor or SetTime()) will be used. If singleShot is kTRUE, the timer will be activated only once, otherwise it will continue until it is stopped. See also TurnOn(), Stop(), TurnOff(). ; Definition at line 213 of file TTimer.cxx. ◆ Stop(). virtual void TTimer::Stop ; (; ). inlinevirtual . Reimplemented in TGLRedrawTimer.; Definition at line 94 of file TTimer.h. ◆ Streamer(). void TTimer::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TSysEvtHandler. ◆ StreamerNVirtual(). void TTimer::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 102 of file TTimer.h. ◆ Timeout(). virtual void TTimer::Timeout ; (; ). inlinevirtual . Reimplemented in ROOT::RBrowserTimer, TCefTimer, TQt5Timer, TQt6Timer, TWebCanvasTimer, THttpTimer, and ROOT::RTreeDrawInvokeTimer.; Definition at line 97 of file TTimer.h. ◆ TurnOff(). void TTimer::TurnOff ; (; ). virtual . Remove timer from system timer list. ; This requires that a timer has been placed in the system timer list (using TurnOn()). If a TTimer subclass is placed on another list, override TurnOff() to remove the timer from the correct list. ; Definition at line 231 of file TTimer.cxx. ◆ TurnOn(). void TTimer::TurnOn ; (; ). virtual . Add the timer to the system timer list. ; If a TTimer subclass has to be placed on another list, override TurnOn() to add the timer to the correct list. ; Reimplemented in TSingleShotCleaner.; Definition at line 243 of file TTimer.cxx. Member Data Documentation. ◆ fAbsTime. TTime TTimer::fAbsTime. protected . Definition at line 55 of file TTimer.h. ◆ fCommand. TString TTimer::fComma",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTimer.html:25780,Timeout,Timeout,25780,doc/master/classTTimer.html,https://root.cern,https://root.cern/doc/master/classTTimer.html,1,['Timeout'],['Timeout']
Safety," TTreeReaderArray ;  CTTreeReaderValueAn interface for reading values stored in ROOT columnar datasets ;  CTTreeResultClass defining interface to a TTree query result with the same interface as for SQL databases ;  CTTreeRowClass defining interface to a row of a TTree query result ;  CTTreeSQLImplement TTree for a SQL backend ;  CTTreeTableInterfaceTTreeTableInterface is used to interface to data that is stored in a TTree ;  CTTreeViewA helper class that encapsulates a file and a tree ;  CTTreeViewerA graphic user interface designed to handle ROOT trees and to take advantage of TTree class features ;  CTTUBEA tube ;  CTTUBSA segment of a tube ;  CTTVLVContainerThis class represent the list view container for the ;  CTTVLVEntryThis class represent entries that goes into the TreeViewer listview container ;  CTTVRecordI/O classes for TreeViewer session handling ;  CTTVSessionI/O classes for TreeViewer session handling ;  CTUDPSocket;  CTUnfoldAn algorithm to unfold distributions from detector to truth level ;  CTUnfoldBinningBinning schemes for use with the unfolding algorithm TUnfoldDensity ;  CTUnfoldBinningXMLXML interfate to binning schemes, for use with the unfolding algorithm TUnfoldDensity ;  CTUnfoldDensityAn algorithm to unfold distributions from detector to truth level ;  CTUnfoldSysAn algorithm to unfold distributions from detector to truth level, with background subtraction and propagation of systematic uncertainties ;  CTUnixSystem;  CTUnuranTUnuran class ;  CTUnuranBaseDistTUnuranBaseDist, base class for Unuran distribution classees such as TUnuranContDist (for one-dimension) or TUnuranMultiContDist (multi-dimension) ;  CTUnuranContDistTUnuranContDist class describing one dimensional continuous distribution ;  CTUnuranDiscrDistTUnuranDiscrDist class for one dimensional discrete distribution ;  CTUnuranEmpDistTUnuranEmpDist class for describing empiral distributions ;  CTUnuranMultiContDistTUnuranMultiContDist class describing multi dimensional continuous d",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/annotated.html:218719,detect,detector,218719,doc/v616/annotated.html,https://root.cern,https://root.cern/doc/v616/annotated.html,1,['detect'],['detector']
Safety," TWebSystem(); virtual~TWebSystem(); virtual voidTSystem::Abort(int code = 0); voidTObject::AbstractMethod(const char* method) const; virtual intTSystem::AcceptConnection(int sock); virtual Bool_tAccessPathName(const char* path, EAccessMode mode); virtual voidTSystem::AddDynamicPath(const char* pathname); virtual voidTSystem::AddFileHandler(TFileHandler* fh); virtual voidTSystem::AddIncludePath(const char* includePath); virtual voidTSystem::AddLinkedLibs(const char* linkedLib); virtual voidTSystem::AddSignalHandler(TSignalHandler* sh); virtual voidTSystem::AddStdExceptionHandler(TStdExceptionHandler* eh); virtual voidTSystem::AddTimer(TTimer* t); virtual intTSystem::AnnounceTcpService(int port, Bool_t reuse, int backlog, int tcpwindowsize = -1); virtual intTSystem::AnnounceUdpService(int port, int backlog); virtual intTSystem::AnnounceUnixService(int port, int backlog); virtual intTSystem::AnnounceUnixService(const char* sockpath, int backlog); virtual voidTObject::AppendPad(Option_t* option = """"); virtual const char*TSystem::BaseName(const char* pathname); voidTSystem::Beep(Int_t freq = -1, Int_t duration = -1, Bool_t setDefault = kFALSE); virtual voidTObject::Browse(TBrowser* b); Bool_tTSystem::cd(const char* path); virtual Bool_tTSystem::ChangeDirectory(const char* path); virtual intTSystem::Chmod(const char* file, UInt_t mode); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTSystem::CleanCompiledMacros(); virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TWebSystem.html:500,Abort,Abort,500,root/html532/TWebSystem.html,https://root.cern,https://root.cern/root/html532/TWebSystem.html,2,['Abort'],['Abort']
Safety," TWebSystem(); virtual~TWebSystem(); virtual voidTSystem::Abort(int code = 0); voidTObject::AbstractMethod(const char* method) const; virtual intTSystem::AcceptConnection(int sock); virtual Bool_tAccessPathName(const char* path, EAccessMode mode); virtual voidTSystem::AddDynamicPath(const char* pathname); virtual voidTSystem::AddFileHandler(TFileHandler* fh); virtual voidTSystem::AddIncludePath(const char* includePath); virtual voidTSystem::AddLinkedLibs(const char* linkedLib); virtual voidTSystem::AddSignalHandler(TSignalHandler* sh); virtual voidTSystem::AddStdExceptionHandler(TStdExceptionHandler* eh); virtual voidTSystem::AddTimer(TTimer* t); virtual intTSystem::AnnounceTcpService(int port, Bool_t reuse, int backlog, int tcpwindowsize = -1); virtual intTSystem::AnnounceUnixService(int port, int backlog); virtual intTSystem::AnnounceUnixService(const char* sockpath, int backlog); virtual voidTObject::AppendPad(Option_t* option = """"); virtual const char*TSystem::BaseName(const char* pathname); voidTSystem::Beep(Int_t freq = -1, Int_t duration = -1, Bool_t setDefault = kFALSE); virtual voidTObject::Browse(TBrowser* b); Bool_tTSystem::cd(const char* path); virtual Bool_tTSystem::ChangeDirectory(const char* path); virtual intTSystem::Chmod(const char* file, UInt_t mode); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTSystem::CleanCompiledMacros(); virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidTSystem::CloseConnection(int ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TWebSystem.html:500,Abort,Abort,500,root/html530/TWebSystem.html,https://root.cern,https://root.cern/root/html530/TWebSystem.html,1,['Abort'],['Abort']
Safety," TWebSystem(); virtual~TWebSystem(); virtual voidTSystem::Abort(int code = 0); voidTObject::AbstractMethod(const char* method) const; virtual intTSystem::AcceptConnection(int sock); virtual Bool_tAccessPathName(const char* path, EAccessMode mode); virtual voidTSystem::AddFileHandler(TFileHandler* fh); virtual voidTSystem::AddIncludePath(const char* includePath); virtual voidTSystem::AddLinkedLibs(const char* linkedLib); virtual voidTSystem::AddSignalHandler(TSignalHandler* sh); virtual voidTSystem::AddStdExceptionHandler(TStdExceptionHandler* eh); virtual voidTSystem::AddTimer(TTimer* t); virtual intTSystem::AnnounceTcpService(int port, Bool_t reuse, int backlog, int tcpwindowsize = -1); virtual intTSystem::AnnounceUnixService(int port, int backlog); virtual intTSystem::AnnounceUnixService(const char* sockpath, int backlog); virtual voidTObject::AppendPad(Option_t* option = """"); virtual const char*TSystem::BaseName(const char* pathname); voidTSystem::Beep(Int_t freq = -1, Int_t duration = -1, Bool_t setDefault = kFALSE); virtual voidTObject::Browse(TBrowser* b); Bool_tTSystem::cd(const char* path); virtual Bool_tTSystem::ChangeDirectory(const char* path); virtual intTSystem::Chmod(const char* file, UInt_t mode); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTSystem::CleanCompiledMacros(); virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidTSystem::CloseConnection(int sock, Bool_t force = kFALSE); virtual voidTSystem::Closelog()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TWebSystem.html:498,Abort,Abort,498,root/html528/TWebSystem.html,https://root.cern,https://root.cern/root/html528/TWebSystem.html,1,['Abort'],['Abort']
Safety," TXNetSystem(Bool_t owner = kTRUE); TXNetSystem(const char* url, Bool_t owner = kTRUE); virtual~TXNetSystem(); virtual voidTSystem::Abort(int code = 0); voidTObject::AbstractMethod(const char* method) const; virtual intTSystem::AcceptConnection(int sock); virtual Bool_tAccessPathName(const char* path, EAccessMode mode); virtual voidTSystem::AddDynamicPath(const char* pathname); virtual voidTSystem::AddFileHandler(TFileHandler* fh); virtual voidTSystem::AddIncludePath(const char* includePath); virtual voidTSystem::AddLinkedLibs(const char* linkedLib); virtual voidTSystem::AddSignalHandler(TSignalHandler* sh); virtual voidTSystem::AddStdExceptionHandler(TStdExceptionHandler* eh); virtual voidTSystem::AddTimer(TTimer* t); virtual intTSystem::AnnounceTcpService(int port, Bool_t reuse, int backlog, int tcpwindowsize = -1); virtual intTSystem::AnnounceUdpService(int port, int backlog); virtual intTSystem::AnnounceUnixService(int port, int backlog); virtual intTSystem::AnnounceUnixService(const char* sockpath, int backlog); virtual voidTObject::AppendPad(Option_t* option = """"); virtual const char*TSystem::BaseName(const char* pathname); voidTSystem::Beep(Int_t freq = -1, Int_t duration = -1, Bool_t setDefault = kFALSE); virtual voidTObject::Browse(TBrowser* b); Bool_tTSystem::cd(const char* path); virtual Bool_tTSystem::ChangeDirectory(const char* path); virtual intTSystem::Chmod(const c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TXNetSystem.html:730,Abort,Abort,730,root/html532/TXNetSystem.html,https://root.cern,https://root.cern/root/html532/TXNetSystem.html,2,['Abort'],['Abort']
Safety," TXNetSystem(Bool_t owner = kTRUE); TXNetSystem(const char* url, Bool_t owner = kTRUE); virtual~TXNetSystem(); virtual voidTSystem::Abort(int code = 0); voidTObject::AbstractMethod(const char* method) const; virtual intTSystem::AcceptConnection(int sock); virtual Bool_tAccessPathName(const char* path, EAccessMode mode); virtual voidTSystem::AddDynamicPath(const char* pathname); virtual voidTSystem::AddFileHandler(TFileHandler* fh); virtual voidTSystem::AddIncludePath(const char* includePath); virtual voidTSystem::AddLinkedLibs(const char* linkedLib); virtual voidTSystem::AddSignalHandler(TSignalHandler* sh); virtual voidTSystem::AddStdExceptionHandler(TStdExceptionHandler* eh); virtual voidTSystem::AddTimer(TTimer* t); virtual intTSystem::AnnounceTcpService(int port, Bool_t reuse, int backlog, int tcpwindowsize = -1); virtual intTSystem::AnnounceUnixService(int port, int backlog); virtual intTSystem::AnnounceUnixService(const char* sockpath, int backlog); virtual voidTObject::AppendPad(Option_t* option = """"); virtual const char*TSystem::BaseName(const char* pathname); voidTSystem::Beep(Int_t freq = -1, Int_t duration = -1, Bool_t setDefault = kFALSE); virtual voidTObject::Browse(TBrowser* b); Bool_tTSystem::cd(const char* path); virtual Bool_tTSystem::ChangeDirectory(const char* path); virtual intTSystem::Chmod(const char* file, UInt_t mode); static TClass*Class(); virtual const c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TXNetSystem.html:730,Abort,Abort,730,root/html530/TXNetSystem.html,https://root.cern,https://root.cern/root/html530/TXNetSystem.html,1,['Abort'],['Abort']
Safety," TXNetSystem(Bool_t owner = kTRUE); TXNetSystem(const char* url, Bool_t owner = kTRUE); virtual~TXNetSystem(); virtual voidTSystem::Abort(int code = 0); voidTObject::AbstractMethod(const char* method) const; virtual intTSystem::AcceptConnection(int sock); virtual Bool_tAccessPathName(const char* path, EAccessMode mode); virtual voidTSystem::AddFileHandler(TFileHandler* fh); virtual voidTSystem::AddIncludePath(const char* includePath); virtual voidTSystem::AddLinkedLibs(const char* linkedLib); virtual voidTSystem::AddSignalHandler(TSignalHandler* sh); virtual voidTSystem::AddStdExceptionHandler(TStdExceptionHandler* eh); virtual voidTSystem::AddTimer(TTimer* t); virtual intTSystem::AnnounceTcpService(int port, Bool_t reuse, int backlog, int tcpwindowsize = -1); virtual intTSystem::AnnounceUnixService(int port, int backlog); virtual intTSystem::AnnounceUnixService(const char* sockpath, int backlog); virtual voidTObject::AppendPad(Option_t* option = """"); virtual const char*TSystem::BaseName(const char* pathname); voidTSystem::Beep(Int_t freq = -1, Int_t duration = -1, Bool_t setDefault = kFALSE); virtual voidTObject::Browse(TBrowser* b); Bool_tTSystem::cd(const char* path); virtual Bool_tTSystem::ChangeDirectory(const char* path); virtual intTSystem::Chmod(const char* file, UInt_t mode); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTSystem::CleanC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TXNetSystem.html:730,Abort,Abort,730,root/html528/TXNetSystem.html,https://root.cern,https://root.cern/root/html528/TXNetSystem.html,1,['Abort'],['Abort']
Safety," TXSocket&operator=(const TXSocket& xs); virtual voidTObject::Paint(Option_t* option = """"); Bool_tPing(const char* ord = 0); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual UnsolRespProcResultProcessUnsolicitedMsg(XrdClientUnsolMsgSender* s, XrdClientMessage* msg); virtual Int_tTObject::Read(const char* name); virtual Int_tReconnect(); virtual voidTObject::RecursiveRemove(TObject* obj); virtual Int_tRecv(TMessage*& mess); virtual Int_tRecv(Int_t& status, Int_t& kind); virtual Int_tRecv(char* mess, Int_t max); virtual Int_tRecv(char* mess, Int_t max, Int_t& kind); virtual Int_tRecvRaw(void* buf, Int_t len, ESendRecvOptions opt = kDefault); voidRemoteTouch(); virtual voidRemoveClientID(); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Int_tTSocket::Select(Int_t interest = kRead, Long_t timeout = -1); virtual Int_tSend(const TMessage& mess); virtual Int_tSend(Int_t kind); virtual Int_tSend(Int_t status, Int_t kind); virtual Int_tSend(const char* mess, Int_t kind = kMESS_STRING); TObjString*SendCoordinator(Int_t kind, const char* msg = 0, Int_t int2 = 0, Long64_t l64 = 0, Int_t int3 = 0, const char* opt = 0); Int_tSendInterrupt(Int_t type); virtual Int_tTSocket::SendObject(const TObject* obj, Int_t kind = kMESS_OBJECT); virtual Int_tSendRaw(const void* buf, Int_t len, ESendRecvOptions opt = kDontBlock); voidSendUrgent(Int_t type, Int_t int1, Int_t int2); voidSetAWait(Bool_t w = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetClientID(Int_t); voidTSocket::SetCompressionAlgorithm(Int_t algorithm = 0); voidTSocket::SetCompressionLevel(Int_t level = 1); voidTSocket::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetInterr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TXSocket.html:6440,timeout,timeout,6440,root/html530/TXSocket.html,https://root.cern,https://root.cern/root/html530/TXSocket.html,2,['timeout'],['timeout']
Safety," The Y-axis is drawn on the right side of the plot. |; 244| ""MIN0"" | Set minimum value for the Y axis to 0, equivalent to gStyle->SetHistMinimumZero(). |; 245 ; 246\anchor HP01b; 247#### Options supported for 1D histograms; 248 ; 249| Option | Description |; 250|----------|-------------------------------------------------------------------|; 251| "" "" | Default. |; 252| ""AH"" | Draw histogram without axis. ""A"" can be combined with any drawing option. For instance, ""AC"" draws the histogram as a smooth Curve without axis.|; 253| ""]["" | When this option is selected the first and last vertical lines of the histogram are not drawn.|; 254| ""B"" | Bar chart option.|; 255| ""BAR"" | Like option ""B"", but bars can be drawn with a 3D effect.|; 256| ""HBAR"" | Like option ""BAR"", but bars are drawn horizontally.|; 257| ""C"" | Draw a smooth Curve through the histogram bins.|; 258| ""E0"" | Draw error bars. Markers are drawn for bins with 0 contents. Combined with E1 or E2 it avoids error bars clipping|; 259| ""E1"" | Draw error bars with perpendicular lines at the edges.|; 260| ""E2"" | Draw error bars with rectangles.|; 261| ""E3"" | Draw a fill area through the end points of the vertical error bars.|; 262| ""E4"" | Draw a smoothed filled area through the end points of the error bars.|; 263| ""E5"" | Like E3 but ignore the bins with 0 contents.|; 264| ""E6"" | Like E4 but ignore the bins with 0 contents.|; 265| ""X0"" | When used with one of the ""E"" option, it suppress the error bar along X as `gStyle->SetErrorX(0)` would do.|; 266| ""L"" | Draw a line through the bin contents.|; 267| ""P"" | Draw current marker at each bin except empty bins.|; 268| ""P*"" | Draw a star marker at each bin except empty bins.|; 269| ""P0"" | Draw current marker at each bin including empty bins.|; 270| ""PIE"" | Draw histogram as a Pie Chart.|; 271| ""*H"" | Draw histogram with a * at each bin.|; 272| ""LF2"" | Draw histogram like with option ""L"" but with a fill area. Note that ""L"" draws also a fill area if the hist fill color is set b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THistPainter_8cxx_source.html:11323,avoid,avoids,11323,doc/master/THistPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html,1,['avoid'],['avoids']
Safety," This version has to load the I/O package, hence via Cling.; 358///; 359/// If autoadd is true and if the object class has a; 360/// DirectoryAutoAdd function, it will be called at the end of the; 361/// function with the parameter gDirector. This usually means that; 362/// the object will be appended to the current ROOT directory.; 363 ; 364TObject *TDirectory::CloneObject(const TObject *obj, Bool_t autoadd /* = kTRUE */); 365{; 366 // if no default ctor return immediately (error issued by New()); 367 char *pobj = (char*)obj->IsA()->New();; 368 if (!pobj) {; 369 Fatal(""CloneObject"",""Failed to create new object"");; 370 return nullptr;; 371 }; 372 ; 373 Int_t baseOffset = obj->IsA()->GetBaseClassOffset(TObject::Class());; 374 if (baseOffset==-1) {; 375 // cl does not inherit from TObject.; 376 // Since this is not supported in this function, the only reason we could reach this code; 377 // is because something is screwed up in the ROOT code.; 378 Fatal(""CloneObject"",""Incorrect detection of the inheritance from TObject for class %s.\n"",; 379 obj->IsA()->GetName());; 380 }; 381 TObject *newobj = (TObject*)(pobj+baseOffset);; 382 ; 383 //create a buffer where the object will be streamed; 384 //We are forced to go via the I/O package (ie TBufferFile).; 385 //Invoking TBufferFile via CINT will automatically load the I/O library; 386 TBuffer *buffer = R__CreateBuffer();; 387 if (!buffer) {; 388 Fatal(""CloneObject"",""Not able to create a TBuffer!"");; 389 return nullptr;; 390 }; 391 buffer->MapObject(obj); //register obj in map to handle self reference; 392 const_cast<TObject*>(obj)->Streamer(*buffer);; 393 ; 394 // read new object from buffer; 395 buffer->SetReadMode();; 396 buffer->ResetMap();; 397 buffer->SetBufferOffset(0);; 398 buffer->MapObject(newobj); //register obj in map to handle self reference; 399 newobj->Streamer(*buffer);; 400 newobj->ResetBit(kIsReferenced);; 401 newobj->ResetBit(kCanDelete);; 402 ; 403 delete buffer;; 404 if (autoadd) {; 405 ROOT::DirAutoAdd_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TDirectory_8cxx_source.html:13167,detect,detection,13167,doc/master/TDirectory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TDirectory_8cxx_source.html,1,['detect'],['detection']
Safety," Types |; Public Member Functions |; Static Public Member Functions |; Protected Attributes |; Static Protected Attributes |; Private Member Functions |; List of all members ; TGeoVolume Class ReferenceThe Geometry Package » Shapes. ; TGeoVolume, TGeoVolumeMulti, TGeoVolumeAssembly are the volume classes. ; Volumes are the basic objects used in building the geometrical hierarchy. They represent unpositioned objects but store all information about the placement of the other volumes they may contain. Therefore a volume can be replicated several times in the geometry. In order to create a volume, one has to put together a shape and a medium which are already defined. Volumes have to be named by users at creation time. Every different name may represent a an unique volume object, but may also represent more general a family (class) of volume objects having the same shape type and medium, but possibly different shape parameters. It is the user's task to provide different names for different volume families in order to avoid ambiguities at tracking time. A generic family rather than a single volume is created only in two cases : when a generic shape is provided to the volume constructor or when a division operation is applied. Each volume in the geometry stores an unique ID corresponding to its family. In order to ease-up their creation, the manager class is providing an API that allows making a shape and a volume in a single step.; Volumes are objects that can be visualized, therefore having visibility, colour, line and fill attributes that can be defined or modified any time after the volume creation. It is advisable however to define these properties just after the first creation of a volume namespace, since in case of volume families any new member created by the modeler inherits these properties.; In order to provide navigation features, volumes have to be able to find the proper container of any point defined in the local reference frame. This can be the volume itsel",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoVolume.html:1175,avoid,avoid,1175,doc/master/classTGeoVolume.html,https://root.cern,https://root.cern/doc/master/classTGeoVolume.html,1,['avoid'],['avoid']
Safety," UUID version 1, this is represented by Coordinated Universal Time (UTC/GMT) as a count of 100-nanosecond intervals since 00:00:00.00, 15 October 1582 (the date of Gregorian reform to the Christian calendar).; The version number is multiplexed in the 4 most significant bits of the 'fTimeHiAndVersion' field. There are two defined versions: MSB <---; Version 4-Bit Code Description; ------------------------------------------------------------; | 1 0 0 0 1 DCE version, as specified herein.; | 2 0 0 1 0 DCE Security version, with; | embedded POSIX UIDs.; | 3 0 0 1 1 node id is a random value; ------------------------------------------------------------; a#define a(i)Definition RSha256.hxx:99; valueOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void valueDefinition TGWin32VirtualXProxy.cxx:142. Clock Sequence; The clock sequence value must be changed whenever:; The UUID generator detects that the local value of UTC has gone backward; this may be due to re-syncing of the system clock.; While a node is operational, the UUID service always saves the last UTC used to create a UUID. Each time a new UUID is created, the current UTC is compared to the saved value and if either the current value is less or the saved value was lost, then the clock sequence is incremented modulo 16,384, thus avoiding production of duplicated UUIDs.; The clock sequence must be initialized to a random number to minimize the correlation across system. This provides maximum protection against node identifiers that may move or switch from system to system rapidly. Clock Adjustment; UUIDs may be created at a rate greater than the system clock resolution. Therefore, the system must also maintain an adjustment value to be added to the lower-order bits of the time. Logically, each time the system clock ticks, the adjustment value is cleared. Every time a UUID is generated, the current adjustment value is ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUUID.html:3082,detect,detects,3082,doc/master/classTUUID.html,https://root.cern,https://root.cern/doc/master/classTUUID.html,1,['detect'],['detects']
Safety," Write array of UInt_t to buffer. void WriteFastArray(const Long_t *l, Int_t n); Write array of Long_t to buffer. void WriteFastArray(const ULong_t *l, Int_t n); Write array of ULong_t to buffer. void WriteFastArray(const Long64_t *l, Int_t n); Write array of Long64_t to buffer. void WriteFastArray(const ULong64_t *l, Int_t n); Write array of ULong64_t to buffer. void WriteFastArray(const Float_t *f, Int_t n); Write array of Float_t to buffer. void WriteFastArray(const Double_t *d, Int_t n); Write array of Double_t to buffer. void WriteFastArrayFloat16(const Float_t* d, Int_t n, TStreamerElement* ele = 0); Write array of Float16_t to buffer. void WriteFastArrayDouble32(const Double_t* d, Int_t n, TStreamerElement* ele = 0); Write array of Double32_t to buffer. void WriteFastArray(void* start, const TClass* cl, Int_t n = 1, TMemberStreamer* s = 0); Recall TBuffer function to avoid gcc warning message. Int_t WriteFastArray(void** startp, const TClass* cl, Int_t n = 1, Bool_t isPreAlloc = kFALSE, TMemberStreamer* s = 0); Recall TBuffer function to avoid gcc warning message. void StreamObject(void *obj, const type_info &typeinfo, const TClass* /* onFileClass */ ); steram object to/from buffer. void StreamObject(void *obj, const char *className, const TClass* /* onFileClass */ ); steram object to/from buffer. void StreamObject(TObject* obj); steram object to/from buffer. void StreamObject(void *obj, const TClass *cl, const TClass* /* onfileClass */ ); steram object to/from buffer. void ReadBool(Bool_t& b); Reads Bool_t value from buffer. void ReadChar(Char_t& c); Reads Char_t value from buffer. void ReadUChar(UChar_t& c); Reads UChar_t value from buffer. void ReadShort(Short_t& s); Reads Short_t value from buffer. void ReadUShort(UShort_t& s); Reads UShort_t value from buffer. void ReadInt(Int_t& i); Reads Int_t value from buffer. void ReadUInt(UInt_t& i); Reads UInt_t value from buffer. void ReadLong(Long_t& l); Reads Long_t value from buffer. void ReadULong(ULong_t& l)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TBufferXML.html:38520,avoid,avoid,38520,root/html526/TBufferXML.html,https://root.cern,https://root.cern/root/html526/TBufferXML.html,1,['avoid'],['avoid']
Safety," Write array of UInt_t to buffer. void WriteFastArray(const Long_t* l, Int_t n); Write array of Long_t to buffer. void WriteFastArray(const ULong_t* l, Int_t n); Write array of ULong_t to buffer. void WriteFastArray(const Long64_t* l, Int_t n); Write array of Long64_t to buffer. void WriteFastArray(const ULong64_t* l, Int_t n); Write array of ULong64_t to buffer. void WriteFastArray(const Float_t* f, Int_t n); Write array of Float_t to buffer. void WriteFastArray(const Double_t* d, Int_t n); Write array of Double_t to buffer. void WriteFastArrayFloat16(const Float_t* d, Int_t n, TStreamerElement* ele = 0); Write array of Float16_t to buffer. void WriteFastArrayDouble32(const Double_t* d, Int_t n, TStreamerElement* ele = 0); Write array of Double32_t to buffer. void WriteFastArray(void* start, const TClass* cl, Int_t n = 1, TMemberStreamer* s = 0); Recall TBuffer function to avoid gcc warning message. Int_t WriteFastArray(void** startp, const TClass* cl, Int_t n = 1, Bool_t isPreAlloc = kFALSE, TMemberStreamer* s = 0); Recall TBuffer function to avoid gcc warning message. void StreamObject(void* obj, const type_info& typeinfo, const TClass* onFileClass = 0); steram object to/from buffer. void StreamObject(void* obj, const char* className, const TClass* onFileClass = 0); steram object to/from buffer. void StreamObject(TObject* obj); steram object to/from buffer. void StreamObject(void* obj, const TClass* cl, const TClass* onFileClass = 0); steram object to/from buffer. void ReadBool(Bool_t& b); Reads Bool_t value from buffer. void ReadChar(Char_t& c); Reads Char_t value from buffer. void ReadUChar(UChar_t& c); Reads UChar_t value from buffer. void ReadShort(Short_t& s); Reads Short_t value from buffer. void ReadUShort(UShort_t& s); Reads UShort_t value from buffer. void ReadInt(Int_t& i); Reads Int_t value from buffer. void ReadUInt(UInt_t& i); Reads UInt_t value from buffer. void ReadLong(Long_t& l); Reads Long_t value from buffer. void ReadULong(ULong_t& l); Reads U",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TBufferXML.html:40451,avoid,avoid,40451,root/html528/TBufferXML.html,https://root.cern,https://root.cern/root/html528/TBufferXML.html,6,['avoid'],['avoid']
Safety," Write array of UInt_t to buffer. void WriteFastArray(const Long_t* l, Int_t n); Write array of Long_t to buffer. void WriteFastArray(const ULong_t* l, Int_t n); Write array of ULong_t to buffer. void WriteFastArray(const Long64_t* l, Int_t n); Write array of Long64_t to buffer. void WriteFastArray(const ULong64_t* l, Int_t n); Write array of ULong64_t to buffer. void WriteFastArray(const Float_t* f, Int_t n); Write array of Float_t to buffer. void WriteFastArray(const Double_t* d, Int_t n); Write array of Double_t to buffer. void WriteFastArrayFloat16(const Float_t* d, Int_t n, TStreamerElement* ele = 0); Write array of Float16_t to buffer. void WriteFastArrayDouble32(const Double_t* d, Int_t n, TStreamerElement* ele = 0); Write array of Double32_t to buffer. void WriteFastArray(void* start, const TClass* cl, Int_t n = 1, TMemberStreamer* s = 0); Recall TBuffer function to avoid gcc warning message. Int_t WriteFastArray(void** startp, const TClass* cl, Int_t n = 1, Bool_t isPreAlloc = kFALSE, TMemberStreamer* s = 0); Recall TBuffer function to avoid gcc warning message. void StreamObject(void* obj, const type_info& typeinfo, const TClass* onFileClass = 0); stream object to/from buffer. void StreamObject(void* obj, const char* className, const TClass* onFileClass = 0); stream object to/from buffer. void StreamObject(TObject* obj); stream object to/from buffer. void StreamObject(void* obj, const TClass* cl, const TClass* onFileClass = 0); stream object to/from buffer. void ReadBool(Bool_t& b); Reads Bool_t value from buffer. void ReadChar(Char_t& c); Reads Char_t value from buffer. void ReadUChar(UChar_t& c); Reads UChar_t value from buffer. void ReadShort(Short_t& s); Reads Short_t value from buffer. void ReadUShort(UShort_t& s); Reads UShort_t value from buffer. void ReadInt(Int_t& i); Reads Int_t value from buffer. void ReadUInt(UInt_t& i); Reads UInt_t value from buffer. void ReadLong(Long_t& l); Reads Long_t value from buffer. void ReadULong(ULong_t& l); Reads U",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TBufferJSON.html:35877,avoid,avoid,35877,root/html534/TBufferJSON.html,https://root.cern,https://root.cern/root/html534/TBufferJSON.html,3,['avoid'],['avoid']
Safety," Write new keys record; 2186 TIter next(fKeys);; 2187 TKey *key;; 2188 Int_t nkeys = fKeys->GetSize();; 2189 Int_t nbytes = sizeof nkeys; //*-* Compute size of all keys; 2190 if (f->GetEND() > TFile::kStartBigFile) nbytes += 8;; 2191 while ((key = (TKey*)next())) {; 2192 nbytes += key->Sizeof();; 2193 }; 2194 TKey *headerkey = new TKey(fName,fTitle,IsA(),nbytes,this);; 2195 if (headerkey->GetSeekKey() == 0) {; 2196 delete headerkey;; 2197 return;; 2198 }; 2199 char *buffer = headerkey->GetBuffer();; 2200 next.Reset();; 2201 tobuf(buffer, nkeys);; 2202 while ((key = (TKey*)next())) {; 2203 key->FillBuffer(buffer);; 2204 }; 2205 ; 2206 fSeekKeys = headerkey->GetSeekKey();; 2207 fNbytesKeys = headerkey->GetNbytes();; 2208 headerkey->WriteFile();; 2209 delete headerkey;; 2210}; Bytes.h; frombufvoid frombuf(char *&buf, Bool_t *x)Definition Bytes.h:278; tobufvoid tobuf(char *&buf, Bool_t x)Definition Bytes.h:55; R__likely#define R__likely(expr)Definition RConfig.hxx:587; SafeDelete#define SafeDelete(p)Definition RConfig.hxx:525; b#define b(i)Definition RSha256.hxx:100; f#define f(i)Definition RSha256.hxx:104; Int_tint Int_tDefinition RtypesCore.h:45; Version_tshort Version_tDefinition RtypesCore.h:65; Long_tlong Long_tDefinition RtypesCore.h:54; UInt_tunsigned int UInt_tDefinition RtypesCore.h:46; Short_tshort Short_tDefinition RtypesCore.h:39; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; kNPOSconstexpr Ssiz_t kNPOSDefinition RtypesCore.h:117; Long64_tlong long Long64_tDefinition RtypesCore.h:69; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; Option_tconst char Option_tDefinition RtypesCore.h:66; BIT#define BIT(n)Definition Rtypes.h:90; ClassImp#define ClassImp(name)Definition Rtypes.h:382; Strlen.h; TBrowser.h; TBufferFile.h; TBufferJSON.h; TClassTable.h; TClass.h; kIterBackwardconst Bool_t kIterBackwardDefinition TCollection.h:43; kMaxLenconst Int_t kMaxLenDefinition TDirectoryFile.cxx:52; kIsBigFileconst UInt_t kIsBigFileDefinition TDirectoryFile.cxx",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html:75275,Safe,SafeDelete,75275,doc/master/TDirectoryFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html,2,['Safe'],['SafeDelete']
Safety," [length^3]. Double_t Capacity(Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Computes capacity of the shape in [length^3]. ~TGeoCone(); destructor. void ComputeBBox(); compute bounding box of the sphere. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. void ComputeNormalS(const Double_t* point, const Double_t* dir, Double_t* norm, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; test if point is inside this cone. Double_t DistFromInsideS(const Double_t* point, const Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Compute distance from inside point to surface of the cone (static); Boundary safe algorithm. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the cone; Boundary safe algorithm. Double_t DistFromOutsideS(const Double_t* point, const Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Compute distance from outside point to surface of the tube; Boundary safe algorithm.; compute distance to Z planes. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube; compute safe radius. void DistToCone(const Double_t* point, const Double_t* dir, Double_t dz, Double_t r1, Double_t r2, Double_t& b, Double_t& delta); Static method to compute distance to a conical surface with :; - r1, z1 - radius and Z position of lower base; - r2, z2 - radius and Z position of upper base. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoCone.html:15103,safe,safe,15103,root/html534/TGeoCone.html,https://root.cern,https://root.cern/root/html534/TGeoCone.html,6,['safe'],['safe']
Safety," \]. The distribution of the control variable \(x\) obtained by histogramming the weighted events reproduces, on average, the true distribution \({\hbox{ {M}}}_{\rm n}(x)\); The class TSPlot allows to reconstruct the true distribution \({\hbox{ {M}}}_{\rm n}(x)\); of a control variable \(x\) for each of the \({\rm N}_{\rm s}\) species from the sole knowledge of the PDFs of the discriminating variables \({\rm f}_i(y)\). The plots obtained thanks to the TSPlot class are called \(\hbox {$_s$}{\cal P}lots\). Some properties and checks; Beside reproducing the true distribution, \(\hbox {$_s$}{\cal P}lots\) bear remarkable properties:. Each \(x\) - distribution is properly normalized:. \[; \sum_{e=1}^{N} {_s{\cal P}}_{\rm n}(y_e)~=~N_{\rm n} ~. \tag{4}; \]. For any event:. \[; \sum_{l=1}^{{\rm N}_{\rm s}} {_s{\cal P}}_l(y_e) ~=~1 ~. \tag{5}; \]. That is to say that, summing up the \({\rm N}_{\rm s}\) \(\hbox {$_s$}{\cal P}lots\), one recovers the data sample distribution in \(x\), and summing up the number of events entering in a \(\hbox{$_s$}{\cal P}lot\) for a given species, one recovers the yield of the species, as provided by the fit. The property 4 is implemented in the TSPlot class as a check. the sum of the statistical uncertainties per bin. \[; \sigma[N_{\rm n}\ _s\tilde{\rm M}_{\rm n}(x) {\delta x}]~=~\sqrt{\sum_{e \subset {\delta x}} ({_s{\cal P}}_{\rm n})^2} ~. \tag{6}; \]. reproduces the statistical uncertainty on the yield \(N_{\rm n}\), as provided by the fit: \(\sigma[N_{\rm n}]\equiv\sqrt{\hbox{ V}_{{\rm n}{\rm n}}}\) . Because of that and since the determination of the yields is optimal when obtained using a Likelihood fit, one can conclude that the \(\hbox{$_s$}{\cal P}lot\) technique is itself an optimal method to reconstruct distributions of control variables. Different steps followed by TSPlot. A maximum Likelihood fit is performed to obtain the yields \(N_i\) of the various species.The fit relies on discriminating variables \(y\) uncorrelated with a c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSPlot.html:5055,recover,recovers,5055,doc/master/classTSPlot.html,https://root.cern,https://root.cern/doc/master/classTSPlot.html,2,['recover'],['recovers']
Safety," \param[in] ww is the window size in pixels along X; 386/// (if ww < 0 the menubar is not shown); 387/// \param[in] wh is the window size in pixels along Y; 388 ; 389void TCanvas::Constructor(const char *name, const char *title, Int_t ww, Int_t wh); 390{; 391 if (gThreadXAR) {; 392 void *arr[6];; 393 arr[1] = this; arr[2] = (void*)name; arr[3] = (void*)title; arr[4] =&ww; arr[5] = &wh;; 394 if ((*gThreadXAR)(""CANV"", 6, arr, nullptr)) return;; 395 }; 396 ; 397 Init();; 398 SetBit(kMenuBar,true);; 399 if (ww < 0) {; 400 ww = -ww;; 401 SetBit(kMenuBar,false);; 402 }; 403 if (wh <= 0) {; 404 Error(""Constructor"", ""Invalid canvas height: %d"",wh);; 405 return;; 406 }; 407 fCw = ww;; 408 fCh = wh;; 409 fCanvasID = -1;; 410 TCanvas *old = (TCanvas*)gROOT->GetListOfCanvases()->FindObject(name);; 411 if (old && old->IsOnHeap()) {; 412 Warning(""Constructor"",""Deleting canvas with same name: %s"",name);; 413 delete old;; 414 }; 415 if (gROOT->IsBatch()) { //We are in Batch mode; 416 fWindowTopX = fWindowTopY = 0;; 417 fWindowWidth = ww;; 418 fWindowHeight = wh;; 419 fCw = ww;; 420 fCh = wh;; 421 fCanvasImp = gBatchGuiFactory->CreateCanvasImp(this, name, fCw, fCh);; 422 if (!fCanvasImp) return;; 423 fBatch = kTRUE;; 424 } else {; 425 Float_t cx = gStyle->GetScreenFactor();; 426 auto factory = gROOT->IsWebDisplay() ? gBatchGuiFactory : gGuiFactory;; 427 fCanvasImp = factory->CreateCanvasImp(this, name, UInt_t(cx*ww), UInt_t(cx*wh));; 428 if (!fCanvasImp) return;; 429 ; 430 if (!gROOT->IsBatch() && fCanvasID == -1); 431 fCanvasID = fCanvasImp->InitWindow();; 432 ; 433 fCanvasImp->ShowMenuBar(TestBit(kMenuBar));; 434 fBatch = kFALSE;; 435 }; 436 ; 437 CreatePainter();; 438 ; 439 fName = GetNewCanvasName(name); // avoid Modified() signal from SetName; 440 SetTitle(title); // requires fCanvasImp set; 441 Build();; 442 ; 443 // Popup canvas; 444 fCanvasImp->Show();; 445}; 446 ; 447////////////////////////////////////////////////////////////////////////////////; 448/// Create a new canvas.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCanvas_8cxx_source.html:13684,avoid,avoid,13684,doc/master/TCanvas_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCanvas_8cxx_source.html,1,['avoid'],['avoid']
Safety," _NAME2_(R__readguard,name)(R__COLL_COND_MUTEX(mutex)); 364 ; 365#define R__COLLECTION_WRITE_LOCKGUARD(mutex) ::ROOT::TWriteLockGuard _R__UNIQUE_(R__readguard)(R__COLL_COND_MUTEX(mutex)); 366#define R__COLLECTION_WRITE_LOCKGUARD_NAMED(name,mutex) ::ROOT::TWriteLockGuard _NAME2_(R__readguard,name)(R__COLL_COND_MUTEX(mutex)); 367 ; 368//---- R__FOR_EACH macro -------------------------------------------------------; 369 ; 370// Macro to loop over all elements of a list of type ""type"" while executing; 371// procedure ""proc"" on each element; 372 ; 373#define R__FOR_EACH(type,proc) \; 374 SetCurrentCollection(); \; 375 TIter _NAME3_(nxt_,type,proc)(TCollection::GetCurrentCollection()); \; 376 type *_NAME3_(obj_,type,proc); \; 377 while ((_NAME3_(obj_,type,proc) = (type*) _NAME3_(nxt_,type,proc)())) \; 378 _NAME3_(obj_,type,proc)->proc; 379 ; 380#endif; R__EXTERN#define R__EXTERNDefinition DllImport.h:26; R__ALWAYS_INLINE#define R__ALWAYS_INLINEDefinition RConfig.hxx:552; SafeDelete#define SafeDelete(p)Definition RConfig.hxx:525; RRangeCast.hxx; b#define b(i)Definition RSha256.hxx:100; Bool_tbool Bool_tDefinition RtypesCore.h:63; Int_tint Int_tDefinition RtypesCore.h:45; ULong_tunsigned long ULong_tDefinition RtypesCore.h:55; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; Option_tconst char Option_tDefinition RtypesCore.h:66; ClassDef#define ClassDef(name, id)Definition Rtypes.h:342; BIT#define BIT(n)Definition Rtypes.h:90; ClassDefOverride#define ClassDefOverride(name, id)Definition Rtypes.h:346; kIterBackwardconst Bool_t kIterBackwardDefinition TCollection.h:43; gCollectionMutexR__EXTERN TVirtualMutex * gCollectionMutexDefinition TCollection.h:45; kIterForwardconst Bool_t kIterForwardDefinition TCollection.h:42; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; namechar name[80]Definition TGX11.cxx:110; TIterator.h; TObject.h; TString.h; TVirtualRWMutex.h; ROOT::Detail::TRangeCastDefinition TCollection.h:311; ROOT::Detail::TRangeCast::TRangeCas",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCollection_8h_source.html:15228,Safe,SafeDelete,15228,doc/master/TCollection_8h_source.html,https://root.cern,https://root.cern/doc/master/TCollection_8h_source.html,2,['Safe'],['SafeDelete']
Safety," __LINE__; } /** \endcond */; 352 ; 353#define ClassDefInlineOverride(name,id) \; 354 _ClassDefInline_(name,id,,override) \; 355 /** \cond HIDDEN_SYMBOLS */ static int DeclFileLine() { return __LINE__; } /** \endcond */; 356 ; 357#define ClassDefInlineNV(name,id) \; 358 _ClassDefInline_(name,id,,) \; 359 /** \cond HIDDEN_SYMBOLS */ static int DeclFileLine() { return __LINE__; } /** \endcond */; 360 ; 361//#define _ClassDefInterp_(name,id) ClassDefInline(name,id); 362 ; 363#define R__UseDummy(name) \; 364 class _NAME2_(name,_c) { public: _NAME2_(name,_c)() { if (name) { } } }; 365 ; 366#define ClassImpUnique(name,key) \; 367 namespace ROOT { \; 368 /** \cond HIDDEN_SYMBOLS */ TGenericClassInfo *GenerateInitInstance(const name*); /** \endcond */ \; 369 namespace { \; 370 static int _R__UNIQUE_(_NAME2_(R__dummyint,key)) __attribute__((unused)) = \; 371 GenerateInitInstance((name*)0x0)->SetImplFile(__FILE__, __LINE__); \; 372 R__UseDummy(_R__UNIQUE_(_NAME2_(R__dummyint,key))); \; 373 } \; 374 }; 375 ; 376/// \deprecated; 377#define ClassImp(name) ClassImpUnique(name,default); 378 ; 379/// Macro for Namespace; 380#define NamespaceImpUnique(name,key) \; 381 namespace name { \; 382 namespace ROOTDict { \; 383 /** \cond HIDDEN_SYMBOLS */ \; 384 ::ROOT::TGenericClassInfo *GenerateInitInstance(); /** \endcond */ \; 385 namespace { \; 386 static int _R__UNIQUE_(_NAME2_(R__dummyint,key)) = \; 387 GenerateInitInstance()->SetImplFile(__FILE__, __LINE__); \; 388 R__UseDummy(_R__UNIQUE_(_NAME2_(R__dummyint,key))); \; 389 } \; 390 } \; 391 }; 392 ; 393#define NamespaceImp(name) NamespaceImpUnique(name,default); 394 ; 395//---- ClassDefT macros for templates with one template argument ---------------; 396// ClassDefT corresponds to ClassDef; 397// ClassDefT2 goes in the same header as ClassDefT but must be; 398// outside the class scope; 399// ClassImpT corresponds to ClassImp; 400 ; 401 ; 402/// This ClassDefT is strictly redundant and is kept only for; 403/// backward compatibility.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/Rtypes_8h_source.html:17177,redund,redundant,17177,doc/v632/Rtypes_8h_source.html,https://root.cern,https://root.cern/doc/v632/Rtypes_8h_source.html,1,['redund'],['redundant']
Safety," __LINE__; } /** \endcond */; 357 ; 358#define ClassDefInlineOverride(name,id) \; 359 _ClassDefInline_(name,id,,override) \; 360 /** \cond HIDDEN_SYMBOLS */ static int DeclFileLine() { return __LINE__; } /** \endcond */; 361 ; 362#define ClassDefInlineNV(name,id) \; 363 _ClassDefInline_(name,id,,) \; 364 /** \cond HIDDEN_SYMBOLS */ static int DeclFileLine() { return __LINE__; } /** \endcond */; 365 ; 366//#define _ClassDefInterp_(name,id) ClassDefInline(name,id); 367 ; 368#define R__UseDummy(name) \; 369 class _NAME2_(name,_c) { public: _NAME2_(name,_c)() { if (name) { } } }; 370 ; 371#define ClassImpUnique(name,key) \; 372 namespace ROOT { \; 373 /** \cond HIDDEN_SYMBOLS */ TGenericClassInfo *GenerateInitInstance(const name*); /** \endcond */ \; 374 namespace { \; 375 static int _R__UNIQUE_(_NAME2_(R__dummyint,key)) __attribute__((unused)) = \; 376 GenerateInitInstance((name*)0x0)->SetImplFile(__FILE__, __LINE__); \; 377 R__UseDummy(_R__UNIQUE_(_NAME2_(R__dummyint,key))); \; 378 } \; 379 }; 380 ; 381/// \deprecated; 382#define ClassImp(name) ClassImpUnique(name,default); 383 ; 384/// Macro for Namespace; 385#define NamespaceImpUnique(name,key) \; 386 namespace name { \; 387 namespace ROOTDict { \; 388 /** \cond HIDDEN_SYMBOLS */ \; 389 ::ROOT::TGenericClassInfo *GenerateInitInstance(); /** \endcond */ \; 390 namespace { \; 391 static int _R__UNIQUE_(_NAME2_(R__dummyint,key)) = \; 392 GenerateInitInstance()->SetImplFile(__FILE__, __LINE__); \; 393 R__UseDummy(_R__UNIQUE_(_NAME2_(R__dummyint,key))); \; 394 } \; 395 } \; 396 }; 397 ; 398#define NamespaceImp(name) NamespaceImpUnique(name,default); 399 ; 400//---- ClassDefT macros for templates with one template argument ---------------; 401// ClassDefT corresponds to ClassDef; 402// ClassDefT2 goes in the same header as ClassDefT but must be; 403// outside the class scope; 404// ClassImpT corresponds to ClassImp; 405 ; 406 ; 407/// This ClassDefT is strictly redundant and is kept only for; 408/// backward compatibility.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Rtypes_8h_source.html:17598,redund,redundant,17598,doc/master/Rtypes_8h_source.html,https://root.cern,https://root.cern/doc/master/Rtypes_8h_source.html,1,['redund'],['redundant']
Safety," `TResultProxy` (they are executed one after the other in the; // same order as they were registered). We now request that the partial result is drawn and the TBrowser's TPad is; // updated every 50 events.; h.OnPartialResult(50, [&browserPad](TH1D &hist) {; if (!browserPad); return; // in case root -b was invoked; browserPad->cd();; hist.Draw();; browserPad->Update();; // This call tells ROOT to process all pending GUI events; // It allows users to use the TBrowser as usual while the event-loop is running; gSystem->ProcessEvents();; });; ; // Finally, we would like to print a progress bar on the terminal to show how the event-loop is progressing.; // To take into account _all_ events we use `OnPartialResultSlot`: when Implicit Multi-Threading is enabled, in fact,; // `OnPartialResult` invokes the callback only in one of the worker threads, and always returns that worker threads'; // partial result. This is useful because it means we don't have to worry about concurrent execution and; // thread-safety of the callbacks if we are happy with just one threads' partial result.; // `OnPartialResultSlot`, on the other hand, invokes the callback in each one of the worker threads, every time a; // thread finishes processing a batch of `everyN` events. This is what we want for the progress bar, but we need to; // take care that two threads will not print to terminal at the same time: we need a std::mutex for synchronization.; std::string progressBar;; std::mutex barMutex; // Only one thread at a time can lock a mutex. Let's use this to avoid concurrent printing.; // Magic numbers that yield good progress bars for nSlots = 1,2,4,8; const auto everyN = nSlots == 8 ? 1000 : 100ull * nSlots;; const auto barWidth = nEvents / everyN;; h.OnPartialResultSlot(everyN, [&barWidth, &progressBar, &barMutex](unsigned int /*slot*/, TH1D & /*partialHist*/) {; std::lock_guard<std::mutex> l(barMutex); // lock_guard locks the mutex at construction, releases it at destruction; progressBar.push_b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/df013__InspectAnalysis_8C.html:4573,safe,safety,4573,doc/master/df013__InspectAnalysis_8C.html,https://root.cern,https://root.cern/doc/master/df013__InspectAnalysis_8C.html,1,['safe'],['safety']
Safety," a box of having dx, dy, dz; as half-lengths. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the box.; Boundary safe algorithm. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); Compute distance from inside point to surface of the box.; Boundary safe algorithm. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the box.; Boundary safe algorithm. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); Compute distance from outside point to surface of the box.; Boundary safe algorithm. const char * GetAxisName(Int_t iaxis) const; Returns name of axis IAXIS. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. Double_t GetFacetArea(Int_t index = 0) const; Get area in internal units of the facet with a given index.; Possible index values:; 0 - all facets togeather; 1 to 6 - facet index from bottom to top Z. Bool_t GetPointsOnFacet(Int_t index, Int_t npoints, Double_t* array) const; Fills array with n random points located on the surface of indexed facet.; The output array must be provided with a length of minimum 3*npoints. Returns; true if operation succeeded.; Possible index values:; 0 - all facets togeather; 1 to 6 - facet index from bottom to top Z. Bool_t GetPointsOnSegments(Int_t npoints, Double_t* array) const; Fills array with n ran",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoBBox.html:16708,safe,safe,16708,root/html534/TGeoBBox.html,https://root.cern,https://root.cern/root/html534/TGeoBBox.html,3,['safe'],['safe']
Safety," a maximum of fMaxEntries in memory ;  ; virtual Int_t LoadBaskets ();  Baskets associated to this branch are forced to be in memory. ;  ; void PrintCacheInfo () const;  Print the information we have about which basket is currently cached and whether they have been 'used'/'read' from the cache. ;  ; virtual void ReadBasket (TBuffer &b);  Loop on all leaves of this branch to read Basket buffer. ;  ; virtual void Refresh (TBranch *b);  Refresh this branch using new information in b This function is called by TTree::Refresh. ;  ; virtual void ResetAddress ();  Reset the address of the branch. ;  ; virtual void ResetReadEntry ();  ; virtual void SetAddress (void *add);  Set address of this branch. ;  ; virtual void SetAutoDelete (bool autodel=true);  Set the automatic delete bit. ;  ; virtual void SetBasketSize (Int_t buffsize);  Set the basket size The function makes sure that the basket size is greater than fEntryOffsetlen. ;  ; virtual void SetBufferAddress (TBuffer *entryBuffer);  Set address of this branch directly from a TBuffer to avoid streaming. ;  ; void SetCompressionAlgorithm (Int_t algorithm=ROOT::RCompressionSetting::EAlgorithm::kUseGlobal);  Set compression algorithm. ;  ; void SetCompressionLevel (Int_t level=ROOT::RCompressionSetting::ELevel::kUseMin);  Set compression level. ;  ; void SetCompressionSettings (Int_t settings=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault);  Set compression settings. ;  ; virtual void SetEntries (Long64_t entries);  Set the number of entries in this branch. ;  ; virtual void SetEntryOffsetLen (Int_t len, bool updateSubBranches=false);  Update the default value for the branch's fEntryOffsetLen if and only if it was already non zero (and the new value is not zero) If updateExisting is true, also update all the existing branches. ;  ; virtual void SetFile (const char *filename);  Set file where this branch writes/reads its buffers. ;  ; virtual void SetFile (TFile *file=nullptr);  Set file where this branch writes/",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBranchRef.html:9001,avoid,avoid,9001,doc/master/classTBranchRef.html,https://root.cern,https://root.cern/doc/master/classTBranchRef.html,1,['avoid'],['avoid']
Safety," a shared pointer to the struct holding the actual thread local gDirectory pointer and the atomic_flag for its lock. ;  ;  Static Protected Attributes inherited from TFile; static TList * fgAsyncOpenRequests = nullptr;  ; static std::atomic< Long64_t > fgBytesRead {0};  Number of bytes read by all TFile objects. ;  ; static std::atomic< Long64_t > fgBytesWrite {0};  Number of bytes written by all TFile objects. ;  ; static TString fgCacheFileDir;  Directory where to locally stage files. ;  ; static Bool_t fgCacheFileDisconnected = kTRUE;  Indicates, we trust in the files in the cache dir without stat on the cached file. ;  ; static Bool_t fgCacheFileForce = kFALSE;  Indicates, to force all READ to CACHEREAD. ;  ; static std::atomic< Long64_t > fgFileCounter {0};  Counter for all opened files. ;  ; static Bool_t fgOnlyStaged = kFALSE;  Before the file is opened, it is checked, that the file is staged, if not, the open fails. ;  ; static UInt_t fgOpenTimeout = TFile::kEternalTimeout;  Timeout for open operations in ms - 0 corresponds to blocking i/o. ;  ; static Int_t fgReadaheadSize = 256000;  Readahead buffer size. ;  ; static std::atomic< Int_t > fgReadCalls {0};  Number of bytes read from all TFile objects. ;  ; static Bool_t fgReadInfo = kTRUE;  if true (default) ReadStreamerInfo is called when opening a file ;  ; static ROOT::Internal::RConcurrentHashColl fgTsSIHashes;  !TS Set of hashes built from read streamer infos ;  ;  Static Protected Attributes inherited from TDirectory; static Bool_t fgAddDirectory = kTRUE;  MSVC doesn't support = ATOMIC_FLAG_INIT;. ;  . #include <TNetFile.h>. Inheritance diagram for TNetFile:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TNetFile() [1/4]. TNetFile::TNetFile ; (; const TNetFile & ; ). protected . ◆ TNetFile() [2/4]. TNetFile::TNetFile ; (; const char * ; url, . const char * ; ftitle, . Int_t ; compress, . Bool_t ;  . ). protected ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTNetFile.html:42407,Timeout,Timeout,42407,doc/master/classTNetFile.html,https://root.cern,https://root.cern/doc/master/classTNetFile.html,1,['Timeout'],['Timeout']
Safety," a shared pointer to the struct holding the actual thread local gDirectory pointer and the atomic_flag for its lock. ;  ;  Static Protected Attributes inherited from TFile; static TList * fgAsyncOpenRequests = nullptr;  ; static std::atomic< Long64_t > fgBytesRead {0};  Number of bytes read by all TFile objects. ;  ; static std::atomic< Long64_t > fgBytesWrite {0};  Number of bytes written by all TFile objects. ;  ; static TString fgCacheFileDir;  Directory where to locally stage files. ;  ; static Bool_t fgCacheFileDisconnected = kTRUE;  Indicates, we trust in the files in the cache dir without stat on the cached file. ;  ; static Bool_t fgCacheFileForce = kFALSE;  Indicates, to force all READ to CACHEREAD. ;  ; static std::atomic< Long64_t > fgFileCounter {0};  Counter for all opened files. ;  ; static Bool_t fgOnlyStaged = kFALSE;  Before the file is opened, it is checked, that the file is staged, if not, the open fails. ;  ; static UInt_t fgOpenTimeout = TFile::kEternalTimeout;  Timeout for open operations in ms - 0 corresponds to blocking i/o. ;  ; static Int_t fgReadaheadSize = 256000;  Readahead buffer size. ;  ; static std::atomic< Int_t > fgReadCalls {0};  Number of bytes read from all TFile objects. ;  ; static Bool_t fgReadInfo = kTRUE;  if true (default) ReadStreamerInfo is called when opening a file ;  ; static ROOT::Internal::RConcurrentHashColl fgTsSIHashes;  !TS Set of hashes built from read streamer infos ;  ;  Static Protected Attributes inherited from TDirectory; static Bool_t fgAddDirectory = kTRUE;  MSVC doesn't support = ATOMIC_FLAG_INIT;. ;  . #include <TSQLFile.h>. Inheritance diagram for TSQLFile:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Enumeration Documentation. ◆ EIndexesKinds. enum TSQLFile::EIndexesKinds. EnumeratorkIndexesNone ; kIndexesBasic ; kIndexesClass ; kIndexesAll . Definition at line 177 of file TSQLFile.h. ◆ ELockingKinds. enum TSQLFile::ELockingKinds. protected . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSQLFile.html:58983,Timeout,Timeout,58983,doc/master/classTSQLFile.html,https://root.cern,https://root.cern/doc/master/classTSQLFile.html,1,['Timeout'],['Timeout']
Safety," a static 3D buffer and returns a reference. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; in case shape has some negative parameters, these has to be computed; in order to fit the mother. void GetMeshNumbers(Int_t& nvert, Int_t& nsegs, Int_t& npols) const; Returns numbers of vertices, segments and polygons composing the shape mesh. void InspectShape() const; print shape parameters. Bool_t IsAssembly() const; Returns true if the scaled shape is an assembly. Bool_t IsReflected() const; Check if the scale transformation is a reflection. TBuffer3D * MakeBuffer3D() const; Creates a TBuffer3D describing *this* shape.; Coordinates are in local reference frame. TGeoShape * MakeScaledShape(const char* name, TGeoShape* shape, TGeoScale* scale); Create a scaled shape starting from a non-scaled one. void SetSegsAndPols(TBuffer3D& buffer) const; Fill TBuffer3D structure for segments and polygons. Double_t Safety(const Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape, according; to option. The matching point on the shape is stored in spoint. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetPoints(Double_t* points) const; Mesh points for scaled shapes. void SetPoints(Float_t* points) const; Mesh points for scaled shapes. void Contains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoScaledShape.html:14656,Safe,Safety,14656,root/html534/TGeoScaledShape.html,https://root.cern,https://root.cern/root/html534/TGeoScaledShape.html,3,['Safe'],['Safety']
Safety," a subtraction of two shapes contains a given point. ;  ; Int_t DistanceToPrimitive (Int_t px, Int_t py) override;  Compute minimum distance to shape vertices. ;  ; Double_t DistFromInside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=0, Double_t *safe=nullptr) const override;  Compute distance from a given point inside to the shape boundary. ;  ; Double_t DistFromOutside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=0, Double_t *safe=nullptr) const override;  Compute distance from a given point outside to the shape. ;  ; EGeoBoolType GetBooleanOperator () const override;  ; Int_t GetNpoints () override;  Returns number of vertices for the composite shape described by this subtraction. ;  ; TClass * IsA () const override;  ; TGeoBoolNode * MakeClone () const override;  Make a clone of this. Pointers are preserved. ;  ; void Paint (Option_t *option) override;  Paint method. ;  ; Double_t Safety (const Double_t *point, Bool_t in=kTRUE) const override;  Compute safety distance for a union node;. ;  ; void SavePrimitive (std::ostream &out, Option_t *option="""") override;  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void Sizeof3D () const override;  Register 3D size of this shape. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TGeoBoolNode;  TGeoBoolNode ();  Default constructor. ;  ;  TGeoBoolNode (const char *expr1, const char *expr2);  Constructor called by TGeoCompositeShape providing 2 subexpressions for the 2 branches. ;  ;  TGeoBoolNode (TGeoShape *left, TGeoShape *right, TGeoMatrix *lmat=nullptr, TGeoMatrix *rmat=nullptr);  Constructor providing left and right shapes and matrices (in the Boolean operation). ;  ;  ~TGeoBoolNode () override;  Destructor. ;  ; void ClearThreadData () const;  ; void CreateThreadData (Int_t nthreads);  Create thread data ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoSubtraction.html:2074,Safe,Safety,2074,doc/master/classTGeoSubtraction.html,https://root.cern,https://root.cern/doc/master/classTGeoSubtraction.html,2,"['Safe', 'safe']","['Safety', 'safety']"
Safety," actions on this shape. void Draw(Option_t* option = """"); Draw this shape. void Paint(Option_t* option = """"); Paint this shape. void ClearThreadData() const; {}. void CreateThreadData(Int_t ); {}. void SetOnBoundary(Bool_t ); {;}. Double_t Big(); methods. {return 1.E30;}. Double_t Tolerance(); {return 1.E-10;}. void AfterStreamer(); {}. Double_t Capacity() const. void ComputeBBox(). void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm). void ComputeNormal_v(const Double_t* , const Double_t* , Double_t* , Int_t ); {}. Bool_t Contains(const Double_t* point) const. void Contains_v(const Double_t* , Bool_t* , Int_t ) const; {}. Bool_t CouldBeCrossed(const Double_t* point, const Double_t* dir) const. Int_t DistancetoPrimitive(Int_t px, Int_t py). Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; {}. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; {}. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step). const char * GetAxisName(Int_t iaxis) const. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const. void GetBoundingCylinder(Double_t* param) const. Int_t GetByteCount() const. Bool_t GetPointsOnSegments(Int_t npoints, Double_t* array) const. Int_t GetFittingBox(const TGeoBBox* parambox, TGeoMatrix* mat, Double_t& dx, Double_t& dy, Double_t& dz) const. Int_t GetId() const; {return fShapeId;}. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const. void GetMeshNumbers(Int_t& , Int_t& , Int_t& ) const; {;}. Int_t GetNmeshVertices() const; {return 0;}. Bool_t IsAssembly() const; {return kFALSE;}. Bool_t IsComposite() const; {return kFALSE;}. Bool_t IsCylType() const. Bool_t IsReflected() const; {return kFALSE;}. Bool_t IsRunTimeShape() const; {return TestShapeBit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoShape.html:21329,safe,safe,21329,root/html534/TGeoShape.html,https://root.cern,https://root.cern/root/html534/TGeoShape.html,1,['safe'],['safe']
Safety," add it there.; If interest=kRead then we want to monitor the socket for read readiness,; if interest=kWrite then we monitor the socket for write readiness,; if interest=kRead|kWrite then we monitor both read and write readiness. void Remove(TSocket* sock); Remove a socket from the monitor. void RemoveAll(); Remove all sockets from the monitor. void Activate(TSocket* sock); Activate a de-activated socket. void ActivateAll(); Activate all de-activated sockets. void DeActivate(TSocket* sock); De-activate a socket. void DeActivateAll(); De-activate all activated sockets. TSocket * Select(); Return pointer to socket for which an event is waiting.; Select can be interrupt by a call to Interrupt() (e.g. connected with a; Ctrl-C handler); a call to ResetInterrupt() before Select() is advisable; in such a case.; Return 0 in case of error. TSocket * Select(Long_t timeout); Return pointer to socket for which an event is waiting.; Wait a maximum of timeout milliseconds.; If return is due to timeout it returns (TSocket *)-1.; Select() can be interrupt by a call to Interrupt() (e.g. connected with a; Ctrl-C handler); a call to ResetInterrupt() before Select() is advisable; in such a case.; Return 0 in case of any other error situation. Int_t Select(TList* rdready, TList* wrready, Long_t timeout); Return numbers of sockets that are ready for reading or writing.; Wait a maximum of timeout milliseconds.; Return 0 if timed-out. Return < 0 in case of error.; If rdready and/or wrready are not 0, the lists of sockets with; something to read and/or write are also returned. void SetReady(TSocket* sock); Called by TSocketHandler::Notify() to signal which socket is ready; to be read or written. User should not call this routine. The ready; socket will be returned via the Select() user function.; The Ready(TSocket *sock) signal is emitted. Int_t GetActive(Long_t timeout = -1) const; Return number of sockets in the active list. If timeout > 0, remove from; the list those sockets which did not",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMonitor.html:11757,timeout,timeout,11757,root/html528/TMonitor.html,https://root.cern,https://root.cern/root/html528/TMonitor.html,6,['timeout'],['timeout']
Safety," against the shape of the other. This sort of check cannot identify all possible overlapping topologies, but it works for more than 95% and is much faster than the usual shape-to-shape comparison. For a 100% reliability, one can perform the check at the level of a single volume by using option=“d” or option=“d<number>” to perform overlap checking by sampling the volume with <number> random points (default 1 million). This produces also a picture showing in red the overlapping region and estimates the volume of the overlaps.; An extrusion A) is declared in any of the following cases:. At least one of the vertices of the daughter mesh representation is outside the mother volume (in fact its shape) and having a safety distance to the mother greater than the desired value;; At least one of the mother vertices is contained also by one of its daughters, in the same conditions. An overlap B) is declared if:. At least one vertex of a positioned volume mesh is contained (having a safety bigger than the accepted maximum value) by other positioned volume inside the same container. The check is performed also by inverting the candidates. The code is highly optimized to avoid checking candidates that are far away in space by performing a fast check on their bounding boxes. Once the checking tool is fired-up inside a volume or at top level, the list of overlaps (visible as Illegal overlaps inside a TBrowser) held by the manager class will be filled with TGeoOverlap objects containing a full description of the detected overlaps. The list is sorted in the decreasing order of the overlapping distance, extrusions coming first. An overlap object name represents the full description of the overlap, containing both candidate node names and a letter (x-extrusion, o-overlap) representing the type. Double-clicking an overlap item in a TBrowser produces a picture of the overlap containing only the two overlapping nodes (one in blue and one in green) and having the critical vertices represen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1002171,safe,safety,1002171,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['safe'],['safety']
Safety," all members |; Public Member Functions |; Static Public Member Functions |; Protected Member Functions |; Protected Attributes |; Private Types |; Private Member Functions |; List of all members ; TKey Class ReferenceInput/Output Library. ; Book space in a file, create I/O buffers, to fill them, (un)compress them. ; The TKey class includes functions to book space in a file, to create I/O buffers, to fill these buffers, to compress/uncompress data buffers. Before saving (making persistent) an object in a file, a key must be created. The key structure contains all the information to uniquely identify a persistent object in a file. . Data Member Explanation . fNbytes Number of bytes for the compressed object and key. . fObjlen Length of uncompressed object. . fDatime Date/Time when the object was written. . fKeylen Number of bytes for the key structure. . fCycle Cycle number of the object. . fSeekKey Address of the object on file (points to fNbytes). This is a redundant information used to cross-check the data base integrity. . fSeekPdir Pointer to the directory supporting this object. . fClassName Object class name. . fName Name of the object. . fTitle Title of the object. . In the 16 highest bits of fSeekPdir is encoded a pid offset. This offset is to be added to the pid index stored in the TRef object and the referenced TObject.; The TKey class is used by ROOT to:; Write an object in the current directory; Write a new ntuple buffer. The structure of a file is shown in TFile::TFile. The structure of a directory is shown in TDirectoryFile::TDirectoryFile. The TKey class is used by the TBasket class. See also TTree. ; Definition at line 28 of file TKey.h. Public Member Functions;  TKey ();  TKey default constructor. ;  ;  TKey (const char *name, const char *title, const TClass *cl, Int_t nbytes, TDirectory *motherDir);  Create a TKey object with the specified name, title for the given class. ;  ;  TKey (const TObject *obj, const char *name, Int_t bufsize, TDirectory *m",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTKey.html:1091,redund,redundant,1091,doc/master/classTKey.html,https://root.cern,https://root.cern/doc/master/classTKey.html,1,['redund'],['redundant']
Safety," alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2); Constructor. TGeoGtra(const char* name, Double_t dz, Double_t theta, Double_t phi, Double_t twist, Double_t h1, Double_t bl1, Double_t tl1, Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2); Constructor providing the name of the shape. ~TGeoGtra(); Destructor. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the shape. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the shape. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; In case shape has some negative parameters, these has to be computed; in order to fit the mother. Double_t Safety(const Double_t* point, Bool_t in = kTRUE) const; Computes the closest distance from given point to this shape. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetDimensions(Double_t* param); Set all arb8 params in one step.; param[0] = dz; param[1] = theta; param[2] = phi; param[3] = h1; param[4] = bl1; param[5] = tl1; param[6] = alpha1; param[7] = h2; param[8] = bl2; param[9] = tl2; param[10] = alpha2; param[11] = twist. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoGtra.html:16488,Safe,Safety,16488,root/html534/TGeoGtra.html,https://root.cern,https://root.cern/root/html534/TGeoGtra.html,3,['Safe'],['Safety']
Safety," and memory; growth and improving by orders of magnitude the performance. Every time the; memory of the TClonesArray has to be reused, the Clear() method is employed.; To provide its benefits, each TClonesArray must be allocated *once* per process; and disposed of (deleted) *only when not needed any more*.; So a job should see *only one* deletion for each TClonesArray, which should be; ""Cleared()"" in between several times. Keep deleting a TClonesArray is a double; waste. Not only you do not avoid memory fragmentation, but you worsen it because; the TClonesArray itself is a rather heavy structure, and there is quite some; code in the destructor, so you have more memory fragmentation and slower code. NOTE 2. When investigating misuse of TClonesArray, please make sure of the following:. * Use Clear() or Clear(""C"") instead of Delete(). This will improve program; execution time.; * TClonesArray object classes containing pointers allocate memory.; To avoid causing memory leaks, special Clear(""C"") must be used for; clearing TClonesArray. When option ""C"" is specified, ROOT automatically; executes the Clear() method (by default it is empty contained in TObject).; This method must be overridden in the relevant TClonesArray object class,; implementing the reset procedure for pointer objects.; * To reduce memory fragmentation, please make sure that the TClonesArrays; are not destroyed and created on every event.; They must only be constructed/destructed at the beginning/end of the run. Function Members (Methods); public:. TClonesArray(); TClonesArray(const TClonesArray& tc); TClonesArray(const char* classname, Int_t size = 1000, Bool_t call_dtor = kFALSE); TClonesArray(const TClass* cl, Int_t size = 1000, Bool_t call_dtor = kFALSE); virtual~TClonesArray(); voidAbsorbObjects(TClonesArray* tc); voidAbsorbObjects(TClonesArray* tc, Int_t idx1, Int_t idx2); voidTObject::AbstractMethod(const char* method) const; virtual voidTObjArray::Add(TObject* obj); virtual voidAddAfter(const TOb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TClonesArray.html:3320,avoid,avoid,3320,root/html530/TClonesArray.html,https://root.cern,https://root.cern/root/html530/TClonesArray.html,1,['avoid'],['avoid']
Safety," and memory; growth and improving by orders of magnitude the performance. Every time the; memory of the TClonesArray has to be reused, the Clear() method is employed.; To provide its benefits, each TClonesArray must be allocated *once* per process; and disposed of (deleted) *only when not needed any more*.; So a job should see *only one* deletion for each TClonesArray, which should be; ""Cleared()"" in between several times. Keep deleting a TClonesArray is a double; waste. Not only you do not avoid memory fragmentation, but you worsen it because; the TClonesArray itself is a rather heavy structure, and there is quite some; code in the destructor, so you have more memory fragmentation and slower code. NOTE 2. When investigating misuse of TClonesArray, please make sure of the following:. * Use Clear() or Clear(""C"") instead of Delete(). This will improve program; execution time.; * TClonesArray object classes containing pointers allocate memory.; To avoid causing memory leaks, special Clear(""C"") must be used for; clearing TClonesArray. When option ""C"" is specified, ROOT automatically; executes the Clear() method (by default it is empty contained in TObject).; This method must be overridden in the relevant TClonesArray object class,; implementing the reset procedure for pointer objects.; * To reduce memory fragmentation, please make sure that the TClonesArrays; are not destroyed and created on every event.; They must only be constructed/destructed at the beginning/end of the run. Function Members (Methods); public:. TClonesArray(); TClonesArray(const TClonesArray& tc); TClonesArray(const char* classname, Int_t size = 1000, Bool_t call_dtor = kFALSE); TClonesArray(const TClass* cl, Int_t size = 1000, Bool_t call_dtor = kFALSE); virtual~TClonesArray(); voidAbsorbObjects(TClonesArray* tc); voidTObject::AbstractMethod(const char* method) const; virtual voidTObjArray::Add(TObject* obj); virtual voidAddAfter(const TObject*, TObject*); virtual voidTCollection::AddAll(const TColl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TClonesArray.html:3320,avoid,avoid,3320,root/html528/TClonesArray.html,https://root.cern,https://root.cern/root/html528/TClonesArray.html,1,['avoid'],['avoid']
Safety," and rotation classes in conjunction with linear algebra operations. We prefer to avoid any direct dependency to any linear algebra package. However, we provide some hooks to convert to and from linear algebra classes. The vector and the transformation classes have methods which allow to get and set their data members (like SetCoordinates and GetCoordinates) passing either a generic iterator or a pointer to a contiguous set of data, like a C array. This allows an easy connection with the linear algebra package, which in turn, allows creation of matrices using C arrays (like the ROOT TMatrix classes) or iterators (SMatrix classes). Multiplication between linear algebra matrices and GenVector vectors is possible by using the template free functions ROOT::Math::VectorUtil::Mult. This function works for any linear algebra matrix, which implements the operator (i,j) and with first matrix element at i=j=0.; 13.12.2 Example: 3D Vector Classes; To avoid exposing template parameter to the users, typedef’s are defined for all types of vectors based on double’s and float’s. To use them, one must include the header file Math/Vector3D.h. The following typedef’s, defined in the header file Math/Vector3Dfwd.h, are available for the different instantiations of the template class ROOT::Math::DisplacementVector3D:. ROOT::Math::XYZVector vector based on x,y,z coordinates (Cartesian) in double precision; ROOT::Math::XYZVectorF vector based on x,y,z coordinates (Cartesian) in float precision; ROOT::Math::Polar3DVector vector based on r,theta,phi coordinates (polar) in double precision; ROOT::Math::Polar3DVectorF vector based on r,theta,phi coordinates (polar) in float precision; ROOT::Math::RhoZPhiVector vector based on rho,z,phi coordinates (cylindrical) in double precision; ROOT::Math::RhoZPhiVectorF vector based on rho,z,phi coordinates (cylindrical) in float precision; ROOT::Math::RhoEtaPhiVector vector based on rho,eta,phi coordinates (cylindrical using eta instead of z) in double ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:727810,avoid,avoid,727810,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['avoid'],['avoid']
Safety," angles ; Double_tTGeoArb8::fXY[8][2]list of vertices. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTrap(); Default ctor. TGeoTrap(Double_t dz, Double_t theta, Double_t phi); Constructor providing just a range in Z, theta and phi. TGeoTrap(Double_t dz, Double_t theta, Double_t phi, Double_t h1, Double_t bl1, Double_t tl1, Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2); Normal constructor. TGeoTrap(const char* name, Double_t dz, Double_t theta, Double_t phi, Double_t h1, Double_t bl1, Double_t tl1, Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2); Constructor with name. ~TGeoTrap(); destructor. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the trapezoid. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the trapezoid. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this trapezoid shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. Only Z divisions; are supported. For Z divisions just return the pointer to the volume to be; divided. In case a wrong division axis is supplied, returns pointer to; volume that was divided. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; In case shape has some negative parameters, these have to be computed; in order to fit the mother. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; Computes the closest distance from given point to this shape. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetDimensions(Double_t* param); Se",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoTrap.html:14810,safe,safe,14810,root/html528/TGeoTrap.html,https://root.cern,https://root.cern/root/html528/TGeoTrap.html,3,['safe'],['safe']
Safety," are defined by a number of bins N and by (N+1) bin borders. In addition to the N bins inside there may be an underflow and an overflow bin . Each bin has a ""global"" bin number, which can be found using the GetGlobalBinNumber() methods. The global bin number 0 is reserved and corresponds to the case where no bin is found in the TUnfoldBinning tree.; Use in the analysis; Booking histograms: . Define binning schemes on detector level and on truth level. This can be done using the XML language, use the class TUnfoldBinningXML to read the binning scheme. The TUnfoldBinning objects can be written to a root file, preferentially together with the corresponding histograms. . For Monte Carlo, book histograms for the response matrix (detector vs truth level) using the method CreateHistogramOfMigrations() . For data and background, book histograms using the ""detector level"" binning scheme and the method CreateHistogram() . (if required) for the data covarianve matrix, book a histogram using the ""detector level"" binning scheme and the method CreateErrorMatrixHistogram() . For truth histograms, book histograms using the ""truth level"" binning scheme and the method CreateHistogram() . The histograms which are booked have all analysis bins arranged on one axis (global bin number). TUnfoldBinning provides methods to locate the global bin number: . Use the method FindNode() to locate a group of bins (e.g. signal, control distribution, etc) by their name, then: . Use the method GetGlobalBinNumber() to locate a bin in a distribution, then: . Use the TH1::Fill() method and the bin number to fill the appropriate bin in one of the histograms booked above. . Unfolding: Specify the response matrix and the binning schemes when constructing a TUnfoldDensity object. Tell TUnfoldDensity about the data, bakcground, systematic error histograms using the corresponding methods of class TUnfoldDensity. Then run the unfolding. Use the GetXXX() methods to retreive the unfolding results into properly bi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnfoldBinning.html:2308,detect,detector,2308,doc/master/classTUnfoldBinning.html,https://root.cern,https://root.cern/doc/master/classTUnfoldBinning.html,1,['detect'],['detector']
Safety," are not allowed. Considering that a new/delete costs about 70 mus on a 300 MHz HP,; O(10^9) new/deletes will save about 19 hours. NOTE 1. C/C++ offer the possibility to allocate and delete memory.; Forgetting to delete allocated memory is a programming error that originate ""leaks"",; i.e. the memory of your process grows and eventually your program crashes.; Even if you *always* delete the allocated memory, the recovered space may not be; efficiently reused. The process knows that there are portions of free memory,; but when you allocate it again, a fresh piece of memory is grabbed.; Your program is free from semantic errors, but the total memory of your process; still grows. Moreover your program's memory is full of ""holes"" which reduce the; efficiency of memory access, this is called ""memory fragmentation"".; Moreover new / delete are expensive operations in terms of CPU time. Without entering into technical details, the TClonesArray allow to ""reuse"" the; same portion of memory for new/delete avoiding memory fragmentation and memory; growth and improving by orders of magnitude the performance. Every time the; memory of the TClonesArray has to be reused, the Clear() method is employed.; To provide its benefits, each TClonesArray must be allocated *once* per process; and disposed of (deleted) *only when not needed any more*.; So a job should see *only one* deletion for each TClonesArray, which should be; ""Cleared()"" in between several times. Keep deleting a TClonesArray is a double; waste. Not only you do not avoid memory fragmentation, but you worsen it because; the TClonesArray itself is a rather heavy structure, and there is quite some; code in the destructor, so you have more memory fragmentation and slower code. NOTE 2. When investigating misuse of TClonesArray, please make sure of the following:. * Use Clear() or Clear(""C"") instead of Delete(). This will improve program; execution time.; * TClonesArray object classes containing pointers allocate memory.; To avoi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TClonesArray.html:2332,avoid,avoiding,2332,root/html528/TClonesArray.html,https://root.cern,https://root.cern/root/html528/TClonesArray.html,2,['avoid'],['avoiding']
Safety," are waiting for more input either because the collected; 4542/// input contains unbalanced braces or last seen token was a `\` (backslash-newline); 4543 ; 4544Int_t TCling::GetMore() const; 4545{; 4546 return fMetaProcessor->awaitingMoreInput();; 4547}; 4548 ; 4549////////////////////////////////////////////////////////////////////////////////; 4550/// Generate a TClass for the given class.; 4551/// Since the caller has already check the ClassInfo, let it give use the; 4552/// result (via the value of emulation) rather than recalculate it.; 4553 ; 4554TClass *TCling::GenerateTClass(const char *classname, Bool_t emulation, Bool_t silent /* = kFALSE */); 4555{; 4556// For now the following line would lead to the (unwanted) instantiation; 4557// of class template. This could/would need to be resurrected only if; 4558// we re-introduce so sort of automatic instantiation. However this would; 4559// have to include carefull look at the template parameter to avoid; 4560// creating instance we can not really use (if the parameter are only forward; 4561// declaration or do not have all the necessary interfaces).; 4562 ; 4563 // TClingClassInfo tci(fInterpreter, classname);; 4564 // if (1 || !tci.IsValid()) {; 4565 ; 4566 Version_t version = 1;; 4567 if (TClassEdit::IsSTLCont(classname)) {; 4568 version = TClass::GetClass(""TVirtualStreamerInfo"")->GetClassVersion();; 4569 }; 4570 R__LOCKGUARD(gInterpreterMutex);; 4571 TClass *cl = new TClass(classname, version, silent);; 4572 if (!emulation) {; 4573 // Set the class version if the class is versioned.; 4574 // Note that we cannot just call CLASS::Class_Version() as we might not have; 4575 // an execution engine (when invoked from rootcling).; 4576 ; 4577 // Do not call cl->GetClassVersion(), it has side effects!; 4578 Version_t oldvers = cl->fClassVersion;; 4579 if (oldvers == version && cl->GetClassInfo()) {; 4580 // We have a version and it might need an update.; 4581 TClingClassInfo* cli = (TClingClassInfo*)cl->GetClassInfo(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:177379,avoid,avoid,177379,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['avoid'],['avoid']
Safety," argsa standard vector, a ROOT::TSeq of integer type or an initializer list for the second signature. An integer only for the first. Note: in cases where the function to be executed takes more than zero/one argument but all are fixed except zero/one, the function can be wrapped in a lambda or via std::bind to give it the right signature.; Return value:; An std::vector. The elements in the container will be the objects returned by func. ROOT::Internal::TExecutor::MapReduce; This set of methods behaves exactly like Map, but takes an additional function as a third argument. This function is applied to the set of objects returned by the corresponding Map execution to ""squash"" them into a single object. The signature of the reduce function should be (const std::vector<T>) -> T; An integer can be passed as the fourth argument indicating the number of chunks we want to divide our work in. (Note: Please be aware that chunking is only available when the policy is kMultiThread, ignoring this argument in other cases) This may be useful to avoid the overhead introduced when running really short tasks. In this case, the reduction function should be independent of the size of the vector returned by Map due to optimization of the number of chunks.; Examples:; root[] ROOT::Internal::TExecutor pool; auto ten = pool.MapReduce([]() { return 1; }, 10, [](const std::vector<int>; &v) { return std::accumulate(v.begin(), v.end(), 0); }); root[] ROOT::Internal::TExecutor; pool(ROOT::EExecutionPolicy::kMultiProcess); auto hist = pool.MapReduce(CreateAndFillHists, 10,; PoolUtils::ReduceObjects);; ROOT::ExecutorUtils::ReduceObjectsMerge collection of TObjects.Definition PoolUtils.h:35; ROOT::Internal::TExecutorThis class implements the interface to execute the same task multiple times, sequentially or in paral...Definition TExecutor.hxx:37; ROOT::Internal::TExecutor::MapReduceauto MapReduce(F func, unsigned nTimes, R redfunc, unsigned nChunks) -> InvokeResult_t< F >Execute a function nTimes (M",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1Internal_1_1TExecutor.html:2474,avoid,avoid,2474,doc/v632/classROOT_1_1Internal_1_1TExecutor.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1Internal_1_1TExecutor.html,2,['avoid'],['avoid']
Safety," asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoSphere&operator=(const TGeoSphere&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); voidSetDimensions(Double_t* param, Int_t nparam); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); virtual voidSetNumberOfDivisions(Int_t p); static voidTObject::SetObjectS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoSphere.html:9139,Safe,SafetyPhi,9139,root/html534/TGeoSphere.html,https://root.cern,https://root.cern/root/html534/TGeoSphere.html,1,['Safe'],['SafetyPhi']
Safety," asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTGeoShape::Paint(Option_t* option = """"); Double_t&Phi1(); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); Double_t&Rmax(Int_t ipl); Double_t&Rmin(Int_t ipl); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); Double_tSafetyToSegment(const Double_t* point, Int_t ipl, Bool_t in = kTRUE, Double_t safmin = TGeoShape::Big()) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); sta",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoPcon.html:8701,Safe,SafetyPhi,8701,root/html602/TGeoPcon.html,https://root.cern,https://root.cern/root/html602/TGeoPcon.html,2,['Safe'],['SafetyPhi']
Safety," at line 984 of file TF1.cxx. ◆ AddParameter(). virtual void TF1::AddParameter ; (; const TString & ; name, . Double_t ; value . ). inlinevirtual . Definition at line 435 of file TF1.h. ◆ AddToGlobalList(). Bool_t TF1::AddToGlobalList ; (; Bool_t ; on = kTRUE). virtual . Add to global list of functions (gROOT->GetListOfFunctions() ) return previous status (true if the function was already in the list false if not) ; Definition at line 847 of file TF1.cxx. ◆ Browse(). void TF1::Browse ; (; TBrowser * ; b). overridevirtual . Browse. ; Reimplemented from TObject.; Definition at line 993 of file TF1.cxx. ◆ CalcGaussLegendreSamplingPoints(). void TF1::CalcGaussLegendreSamplingPoints ; (; Int_t ; num, . Double_t * ; x, . Double_t * ; w, . Double_t ; eps = 3.0e-11 . ). static . Type safe interface (static method) The number of sampling points are taken from the TGraph. ; Type: unsafe but fast interface filling the arrays x and w (static method); Given the number of sampling points this routine fills the arrays x and w of length num, containing the abscissa and weight of the Gauss-Legendre n-point quadrature formula.; Gauss-Legendre: ; \[; W(x)=1 -1<x<1 \\; (j+1)P_{j+1} = (2j+1)xP_j-jP_{j-1}; \]. num is the number of sampling points (>0) x and w are arrays of size num eps is the relative precision; If num<=0 or eps<=0 no action is done.; Reference: Numerical Recipes in C, Second Edition ; Definition at line 3826 of file TF1.cxx. ◆ CentralMoment(). Double_t TF1::CentralMoment ; (; Double_t ; n, . Double_t ; a, . Double_t ; b, . const Double_t * ; params = nullptr, . Double_t ; epsilon = 0.000001 . ). virtual . Return nth central moment of function between a and b (i.e the n-th moment around the mean value) ; See TF1::Integral() for parameter definitions; AuthorGene Van Buren gene@.nosp@m.bnl..nosp@m.gov ; Definition at line 3739 of file TF1.cxx. ◆ Class(). static TClass * TF1::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TF",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTF1.html:58487,unsafe,unsafe,58487,doc/master/classTF1.html,https://root.cern,https://root.cern/doc/master/classTF1.html,1,['unsafe'],['unsafe']
Safety," automatically called when; 2018/// opening a file.; 2019/// If the file is open in read only mode, the file is not modified.; 2020/// If open in update mode and the function finds something to recover,; 2021/// a new directory header is written to the file. When opening the file gain; 2022/// no message from Recover will be reported.; 2023/// If keys have been recovered, the file is usable and you can safely; 2024/// read the corresponding objects.; 2025/// If the file is not usable (a zombie), you can test for this case; 2026/// with code like:; 2027///; 2028/// ~~~{.cpp}; 2029/// TFile f(""myfile.root"");; 2030/// if (f.IsZombie()) {<actions to take if file is unusable>}; 2031/// ~~~; 2032///; 2033/// If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; 2034/// You can test if the file has been recovered with; 2035///; 2036/// if (f.TestBit(TFile::kRecovered)) {... the file has been recovered}; 2037///; 2038/// When writing TTrees to a file, it is important to save the Tree header; 2039/// at regular intervals (see TTree::AutoSave). If a file containing a Tree; 2040/// is recovered, the last Tree header written to the file will be used.; 2041/// In this case all the entries in all the branches written before writing; 2042/// the header are valid entries.; 2043/// One can disable the automatic recovery procedure by setting; 2044///; 2045/// TFile.Recover 0; 2046///; 2047/// in the <em>system.rootrc</em> file.; 2048 ; 2049Int_t TFile::Recover(); 2050{; 2051 Short_t keylen,cycle;; 2052 UInt_t datime;; 2053 Int_t nbytes,date,time,objlen,nwheader;; 2054 Long64_t seekkey,seekpdir;; 2055 char header[1024];; 2056 char *buffer, *bufread;; 2057 char nwhc;; 2058 Long64_t idcur = fBEGIN;; 2059 ; 2060 Long64_t size;; 2061 if ((size = GetSize()) == -1) { // NOLINT: silence clang-tidy warnings; 2062 Error(""Recover"", ""cannot stat the file %s"", GetName());; 2063 return 0;; 2064 }; 2065 ; 2066 fEND = Long64_t(size);; 2067 ; 2068 if (fWritable && !",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:72835,recover,recovered,72835,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['recover'],['recovered']
Safety," b); virtual Double_tTGeoArb8::Capacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTGeoArb8::ComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidTGeoArb8::ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); voidTGeoArb8::ComputeTwist(); virtual Bool_tTGeoArb8::Contains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoBBox::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tTGeoArb8::DistToPlane(Double_t* point, Double_t* dir, Int_t ipl, Bool_t in) const; virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoTrap.html:3012,safe,safe,3012,root/html530/TGeoTrap.html,https://root.cern,https://root.cern/root/html530/TGeoTrap.html,1,['safe'],['safe']
Safety," b); virtual Double_tTGeoArb8::Capacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTGeoArb8::ComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidTGeoArb8::ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); voidTGeoArb8::ComputeTwist(); virtual Bool_tTGeoArb8::Contains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoBBox::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tTGeoArb8::DistToPlane(Double_t* point, Double_t* dir, Int_t ipl, Bool_t in) const; virtual TGeoVolume*TGeoTrap::Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* met",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoGtra.html:2991,safe,safe,2991,root/html530/TGeoGtra.html,https://root.cern,https://root.cern/root/html530/TGeoGtra.html,1,['safe'],['safe']
Safety," bin is true it is a binary file, other wise it is an ASCII; file and we need to check for Windows \r tokens. Returns -1 in; case of error, 0 otherwise. void SendLogFile(Int_t status = 0, Int_t start = -1, Int_t end = -1); Send log file to master.; If start > -1 send only bytes in the range from start to end,; if end <= start send everything from start. Int_t SendCanvases(); Send any created canvas to client. Int_t BrowseDirectory(const char* dirname); Browse directory and send back its content to client. Int_t BrowseFile(const char* fname); Browse root file and send back its content;; if fname is null, send the full list of files. Int_t BrowseKey(const char* keyname); Read key object and send it back to client. void Terminate(Int_t status); Terminate the proof server. void HandleCheckFile(TMessage* mess); Handle file checking request. void ErrorHandler(Int_t level, Bool_t abort, const char* location, const char* msg); The error handler function. It prints the message on stderr and; if abort is set it aborts the application. Long_t ProcessLine(const char* line, Bool_t = kFALSE, Int_t* err = 0); Parse a command line received from the client, making sure that the files; needed for the execution, if any, are available. The line is either a C++; statement or an interpreter command starting with a ""."".; Return the return value of the command casted to a long. void ExecLogon(); Execute logon macro's. There are three levels of logon macros that; will be executed: the system logon etc/system.rootlogon.C, the global; user logon ~/.rootlogon.C and the local ./.rootlogon.C. For backward; compatibility also the logon macro as specified by the Rint.Logon; environment setting, by default ./rootlogon.C, will be executed.; No logon macros will be executed when the system is started with; the -n option. Int_t GetProtocol() const; { return fProtocol; }. Int_t GetPort() const; { return fUrl.GetPort(); }. const char * GetUser() const; { return fUrl.GetUser(); }. const char * GetHost() ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TApplicationServer.html:15160,abort,abort,15160,root/html526/TApplicationServer.html,https://root.cern,https://root.cern/root/html526/TApplicationServer.html,10,['abort'],"['abort', 'aborts']"
Safety," bin is true it is a binary file, other wise it is an ASCII; file and we need to check for Windows \r tokens. Returns -1 in; case of error, 0 otherwise. void SendLogFile(Int_t status = 0, Int_t start = -1, Int_t end = -1); Send log file to master.; If start > -1 send only bytes in the range from start to end,; if end <= start send everything from start. Int_t SendCanvases(); Send any created canvas to client. Int_t BrowseDirectory(const char* dirname); Browse directory and send back its content to client. Int_t BrowseFile(const char* fname); Browse root file and send back its content;; if fname is null, send the full list of files. Int_t BrowseKey(const char* keyname); Read key object and send it back to client. void Terminate(Int_t status); Terminate the proof server. void HandleCheckFile(TMessage* mess); Handle file checking request. void ErrorHandler(Int_t level, Bool_t abort, const char* location, const char* msg); The error handler function. It prints the message on stderr and; if abort is set it aborts the application. Long_t ProcessLine(const char* line, Bool_t = kFALSE, Int_t* err = 0); Parse a command line received from the client, making sure that the files; needed for the execution, if any, are available. The line is either a C++; statement or an interpreter command starting with a ""."".; Return the return value of the command casted to a long. void ExecLogon(); Execute logon macro's. There are three levels of logon macros that; will be executed: the system logon etc/system.rootlogon.C, the global; user logon ~/.rootlogon.C and the local ./.rootlogon.C. For backward; compatibility also the logon macro as specified by the Rint.Logon; environment setting, by default ./rootlogon.C, will be executed.; No logon macros will be executed when the system is started with; the -n option. TApplicationServer(Int_t* argc, char** argv, FILE* flog, const char* logfile). Int_t GetProtocol() const; { return fProtocol; }. Int_t GetPort() const; { return fUrl.GetPort(); }. co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TApplicationServer.html:16255,abort,abort,16255,root/html602/TApplicationServer.html,https://root.cern,https://root.cern/root/html602/TApplicationServer.html,4,['abort'],"['abort', 'aborts']"
Safety," bkgfrac = ROOT.RooRealVar(""bkgfrac"", ""fraction of background"", 0.5, 0.0, 1.0); model = ROOT.RooAddPdf(""model"", ""g1+g2+a"", [bkg, sig], [bkgfrac]); ; # Generate a data sample of 1000 events in x from model; data = model.generate({x}, 1000); ; # Create workspace, import data and model; # -----------------------------------------------------------------------------; ; # Create a empty workspace; w = ROOT.RooWorkspace(""w"", ""workspace""); ; # Import model and all its components into the workspace; w.Import(model); ; # Import data into the workspace; w.Import(data); ; # Print workspace contents; w.Print(); ; # Save workspace in file; # -------------------------------------------; ; # Save the workspace into a ROOT file; w.writeToFile(""rf502_workspace_py.root""); [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooAddPdf::model; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooChebychev::bkg; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::x; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::a0; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::a1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::bkgfrac; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooAddPdf::sig; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooGaussian::sig1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::mean; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sigma1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sig1frac; [#1] INFO:ObjectHan",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf502__wspacewrite_8py.html:2404,safe,safe,2404,doc/master/rf502__wspacewrite_8py.html,https://root.cern,https://root.cern/doc/master/rf502__wspacewrite_8py.html,1,['safe'],['safe']
Safety," bool ; subbranches = false . ). overridevirtual . Add a branch to the list of branches to be stored in the cache this function is called by TBranch::GetBasket Returns: . 0 branch added or already included; -1 on error . Reimplemented from TTreeCache.; Definition at line 248 of file TTreeCacheUnzip.cxx. ◆ Class(). static TClass * TTreeCacheUnzip::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TTreeCacheUnzip::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TTreeCacheUnzip::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 159 of file TTreeCacheUnzip.h. ◆ CreateTasks(). Int_t TTreeCacheUnzip::CreateTasks ; (; ). We create a TTaskGroup and asynchronously maps each group of baskets(> 100 kB in total) to a task. ; In TTaskGroup, we use TThreadExecutor to do the actually work of unzipping a group of basket. The purpose of creating TTaskGroup is to avoid competing with main thread. ; Definition at line 613 of file TTreeCacheUnzip.cxx. ◆ DeclFileName(). static const char * TTreeCacheUnzip::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 159 of file TTreeCacheUnzip.h. ◆ FillBuffer(). bool TTreeCacheUnzip::FillBuffer ; (; ). overridevirtual . Fill the cache buffer with the branches in the cache. ; Reimplemented from TTreeCache.; Definition at line 267 of file TTreeCacheUnzip.cxx. ◆ GetNFound(). Int_t TTreeCacheUnzip::GetNFound ; (; ). inline . Definition at line 154 of file TTreeCacheUnzip.h. ◆ GetNMissed(). Int_t TTreeCacheUnzip::GetNMissed ; (; ). inline . Definition at line 153 of file TTreeCacheUnzip.h. ◆ GetNUnzip(). Int_t TTreeCacheUnzip::GetNUnzip ; (; ). inline . Definition at line 152 of file TTreeCacheUnzip.h. ◆ GetParallelUnzip(). TTreeCacheUnzip::EParUnzipMode TTreeCacheUnzip::GetParallelUnzip ; (; ). static . Static function that returns the parallel ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCacheUnzip.html:28676,avoid,avoid,28676,doc/v632/classTTreeCacheUnzip.html,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html,1,['avoid'],['avoid']
Safety," bool ; subbranches = false . ). overridevirtual . Add a branch to the list of branches to be stored in the cache this function is called by TBranch::GetBasket Returns: . 0 branch added or already included; -1 on error . Reimplemented from TTreeCache.; Definition at line 248 of file TTreeCacheUnzip.cxx. ◆ Class(). static TClass * TTreeCacheUnzip::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TTreeCacheUnzip::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TTreeCacheUnzip::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 159 of file TTreeCacheUnzip.h. ◆ CreateTasks(). Int_t TTreeCacheUnzip::CreateTasks ; (; ). We create a TTaskGroup and asynchronously maps each group of baskets(> 100 kB in total) to a task. ; In TTaskGroup, we use TThreadExecutor to do the actually work of unzipping a group of basket. The purpose of creating TTaskGroup is to avoid competing with main thread. ; Definition at line 614 of file TTreeCacheUnzip.cxx. ◆ DeclFileName(). static const char * TTreeCacheUnzip::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 159 of file TTreeCacheUnzip.h. ◆ FillBuffer(). bool TTreeCacheUnzip::FillBuffer ; (; ). overridevirtual . Fill the cache buffer with the branches in the cache. ; Reimplemented from TTreeCache.; Definition at line 267 of file TTreeCacheUnzip.cxx. ◆ GetNFound(). Int_t TTreeCacheUnzip::GetNFound ; (; ). inline . Definition at line 154 of file TTreeCacheUnzip.h. ◆ GetNMissed(). Int_t TTreeCacheUnzip::GetNMissed ; (; ). inline . Definition at line 153 of file TTreeCacheUnzip.h. ◆ GetNUnzip(). Int_t TTreeCacheUnzip::GetNUnzip ; (; ). inline . Definition at line 152 of file TTreeCacheUnzip.h. ◆ GetParallelUnzip(). TTreeCacheUnzip::EParUnzipMode TTreeCacheUnzip::GetParallelUnzip ; (; ). static . Static function that returns the parallel ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeCacheUnzip.html:28680,avoid,avoid,28680,doc/master/classTTreeCacheUnzip.html,https://root.cern,https://root.cern/doc/master/classTTreeCacheUnzip.html,1,['avoid'],['avoid']
Safety," boundaries: [10,600] --> [0,600]; [#0] PROGRESS:Caching -- creating cache from getCache function for 0x5559dfeef700; [#0] PROGRESS:Caching -- current storage has size 10; [#0] PROGRESS:ObjectHandling -- observable: pTV; [#0] PROGRESS:ObjectHandling -- binWidth: binWidth_pTV; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(wrap_pdf_over_wrap_pdf_Int[pTV]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_wrap_pdf_over_wrap_pdf_Int[pTV]_pseudo_dh) Summation contains a RooNLLVar, using its error level; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=0 cHl3=0 cHq3=-0.0202918; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.0376648, denominator=wrap_pdf_Int[pTV]=10358.6; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.0376648, denominator=wrap_pdf_Int[pTV]=10358.6; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=0.0376648, denominator=wrap_pdf_Int[pTV]=10358.6; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=0.0376648, denominator=wrap_pdf_Int[pTV]=10358.6; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=0.213672 cHl3=1.97898 cHq3=0.00773174; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.0882577, denominator=wrap_pdf_Int[pTV]=4536.67; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.0882577, denominator=wrap_pdf_Int[pTV]=4536.67; getLo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf712__lagrangianmorphfit_8C.html:8620,recover,recover,8620,doc/master/rf712__lagrangianmorphfit_8C.html,https://root.cern,https://root.cern/doc/master/rf712__lagrangianmorphfit_8C.html,1,['recover'],['recover']
Safety," boundary crossing only up to a distance equal to this value. If a boundary is found, a pointer to the object (node) having it is returned; otherwise the method returns NULL.; The computed value for the computed distance can be subsequently retrieved from the manager class:; Double_t snext = gGeoManager->GetStep();; Double_t safety = gGeoManager->GetSafeDistance();; According the step value, two use cases are possible:. step = TGeoShape::kBig(default behavior; kBig = 1030). In this case, there is no limitation on the search algorithm, the first crossed node is returned and the corresponding distance computed. If the current point is outside geometry and the top node is not crossed, the corresponding distance will be set to kBig and a NULL pointer returned. No additional quantity will be computed.; step < kBig. In this case, the progressive search starting from the current point will be stopped after a distance equal with the supplied step. In addition to the distance to the first crossed boundary, the safety radius is also computed. Whenever the information regarding the maximum required step is known it is recommended to be provided as input parameter in order to speed-up the search. In addition to the distance computation, the method sets an additional flag telling if the current track will enter inside some daughter of the current volume or it will exit inside its container:; Bool_t TGeoManager::IsStepEntering() const;; A combined task is to first find the distance to the next boundary and then extrapolate the current point/direction with this distance making sure that the boundary was crossed. Finally the goal would be to find the next state after crossing the boundary. The problem can be solved in principle using FindNextBoundary, but the boundary crossing can give unpredictable results due to numerical roundings. The manager class provides a method that allows this combined task and ensures boundary crossing. This should be used instead of the method FindNextBo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:986301,safe,safety,986301,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['safe'],['safety']
Safety," boundary is also computed. This can be retrieved for masterlocal point or vector conversions: TGeoManager::GetNextMatrix(); In case the computation of the normal vector to the next crossed surface is required, using a negative stepmax value is recommended. In this case one can subsequently call a method for fast normal computation:; Double_t *TGeoManager::FindNormalFast(); TGeoManager::FindNormalFastDouble_t * FindNormalFast()Computes fast normal to next crossed boundary, assuming that the current point is close enough to the...Definition TGeoManager.cxx:2799; path 0; In case a path to a given physical object is specified, the distance to its boundary is computed ignoring the rest of the geometry; Output Values; TGeoManager::GetStep(): distance to next boundary.; TGeoManager::GetSafeDistance(): safe distance (in case it was computed).; TGeoManager::IsOnBoundary(): the initial point (x,y,z) was (or was not) on a boundary within TGeoShape::Tolerance().; The algorithm checks first if the computation of safety was required. If this is the case and the global point coordinates did not change from the last query, the last computed safety is taken. Otherwise, the method TGeoManager::Safety () is invoked. A safety value less than TGeoShape::Tolerance() will set the flag IsOnBoundary to true. On the other hand, a safety value bigger than the proposed step will stop the computation of the distance to next boundary, returning the current geometry location with the meaning that the proposed step is safe.; The next stage is to check if computation of the distance to a give physical object specified by a path was required. If this is the case, the modeller changes the state to point to the required object, converts the current point and direction coordinates to the local frame of this object and computes the distance to its shape. The node returned is the one pointed by the input path in case the shape is crossed; otherwise the returned value is NULL. In case the distance to next",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:132360,safe,safety,132360,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['safe'],['safety']
Safety," boundary is found,; propagate current point along current direction with fStep=STEPMAX. Otherwise; propagate with fStep=SNEXT (distance to boundary) and locate/return the next; node. TGeoNode * FindNextBoundary(Double_t stepmax = TGeoShape::Big(), const char* path = """", Bool_t frombdr = kFALSE); Find distance to next boundary and store it in fStep. Returns node to which this; boundary belongs. If PATH is specified, compute only distance to the node to which; PATH points. If STEPMAX is specified, compute distance only in case fSafety is smaller; than this value. STEPMAX represent the step to be made imposed by other reasons than; geometry (usually physics processes). Therefore in this case this method provides the; answer to the question : ""Is STEPMAX a safe step ?"" returning a NULL node and filling; fStep with a big number.; In case frombdr=kTRUE, the isotropic safety is set to zero.; Note : safety distance for the current point is computed ONLY in case STEPMAX is; specified, otherwise users have to call explicitly TGeoManager::Safety() if; they want this computed for the current point. TGeoNode * FindNextDaughterBoundary(Double_t* point, Double_t* dir, Int_t& idaughter, Bool_t compmatrix = kFALSE); Computes as fStep the distance to next daughter of the current volume.; The point and direction must be converted in the coordinate system of the current volume.; The proposed step limit is fStep. void ResetState(); Reset current state flags. TGeoNode * FindNode(Bool_t safe_start = kTRUE); Returns deepest node containing current point. TGeoNode * FindNode(Double_t x, Double_t y, Double_t z); Returns deepest node containing current point. Double_t * FindNormalFast(); Computes fast normal to next crossed boundary, assuming that the current point; is close enough to the boundary. Works only after calling FindNextBoundary. Double_t * FindNormal(Bool_t forward = kTRUE); Computes normal vector to the next surface that will be or was already; crossed when propagating on a strai",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoManager.html:51703,safe,safety,51703,root/html528/TGeoManager.html,https://root.cern,https://root.cern/root/html528/TGeoManager.html,12,"['Safe', 'safe']","['Safety', 'safety']"
Safety," buffer size of the cache. ; The buffersize might be clamped, see TFileCacheRead::SetBufferSize Returns:; 0 if the buffer content is still available; 1 if some or all of the buffer content has been made unavailable; -1 on error . Reimplemented from TTreeCache.; Definition at line 360 of file TTreeCacheUnzip.cxx. ◆ SetEntryRange(). void TTreeCacheUnzip::SetEntryRange ; (; Long64_t ; emin, . Long64_t ; emax . ). overridevirtual . Set the minimum and maximum entry number to be processed this information helps to optimize the number of baskets to read when prefetching the branch buffers. ; Reimplemented from TTreeCache.; Definition at line 376 of file TTreeCacheUnzip.cxx. ◆ SetParallelUnzip(). Int_t TTreeCacheUnzip::SetParallelUnzip ; (; TTreeCacheUnzip::EParUnzipMode ; option = TTreeCacheUnzip::kEnable). static . Static function that (de)activates multithreading unzipping. ; The possible options are:; kEnable Enable it, which causes an automatic detection and launches the additional thread if the number of cores in the machine is greater than one; kDisable Disable will not activate the additional thread.; kForce Force will start the additional thread even if there is only one core. the default will be taken as kEnable. Returns 0 if there was an error, 1 otherwise. ; Definition at line 437 of file TTreeCacheUnzip.cxx. ◆ SetUnzipBufferSize(). void TTreeCacheUnzip::SetUnzipBufferSize ; (; Long64_t ; bufferSize). Sets the size for the unzipping cache... by default it should be two times the size of the prefetching cache. ; Definition at line 840 of file TTreeCacheUnzip.cxx. ◆ SetUnzipGroupSize(). void TTreeCacheUnzip::SetUnzipGroupSize ; (; Int_t ; groupSize). inline . Definition at line 146 of file TTreeCacheUnzip.h. ◆ SetUnzipRelBufferSize(). void TTreeCacheUnzip::SetUnzipRelBufferSize ; (; Float_t ; relbufferSize). static . static function: Sets the unzip relative buffer size ; Definition at line 831 of file TTreeCacheUnzip.cxx. ◆ StopLearningPhase(). void TTreeCacheUnz",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeCacheUnzip.html:35772,detect,detection,35772,doc/master/classTTreeCacheUnzip.html,https://root.cern,https://root.cern/doc/master/classTTreeCacheUnzip.html,1,['detect'],['detection']
Safety," buffers holding many entries.; 1426/// If fAutoSave is negative, AutoSave is automatically called by; 1427/// TTree::Fill when the number of bytes generated since the previous; 1428/// AutoSave is greater than -fAutoSave bytes.; 1429/// If fAutoSave is positive, AutoSave is automatically called by; 1430/// TTree::Fill every N entries.; 1431/// This function may also be invoked by the user.; 1432/// Each AutoSave generates a new key on the file.; 1433/// Once the key with the tree header has been written, the previous cycle; 1434/// (if any) is deleted.; 1435///; 1436/// Note that calling TTree::AutoSave too frequently (or similarly calling; 1437/// TTree::SetAutoSave with a small value) is an expensive operation.; 1438/// You should make tests for your own application to find a compromise; 1439/// between speed and the quantity of information you may loose in case of; 1440/// a job crash.; 1441///; 1442/// In case your program crashes before closing the file holding this tree,; 1443/// the file will be automatically recovered when you will connect the file; 1444/// in UPDATE mode.; 1445/// The Tree will be recovered at the status corresponding to the last AutoSave.; 1446///; 1447/// if option contains ""SaveSelf"", gDirectory->SaveSelf() is called.; 1448/// This allows another process to analyze the Tree while the Tree is being filled.; 1449///; 1450/// if option contains ""FlushBaskets"", TTree::FlushBaskets is called and all; 1451/// the current basket are closed-out and written to disk individually.; 1452///; 1453/// By default the previous header is deleted after having written the new header.; 1454/// if option contains ""Overwrite"", the previous Tree header is deleted; 1455/// before written the new header. This option is slightly faster, but; 1456/// the default option is safer in case of a problem (disk quota exceeded); 1457/// when writing the new header.; 1458///; 1459/// The function returns the number of bytes written to the file.; 1460/// if the number of b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:53361,recover,recovered,53361,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['recover'],['recovered']
Safety," bufsize); static Bool_tSetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); virtual voidSetCacheRead(TFileCacheRead* cache); virtual voidSetCacheWrite(TFileCacheWrite* cache); virtual voidSetCompressionLevel(Int_t level = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetEND(Long64_t last); static voidSetFileBytesRead(Long64_t bytes = 0); static voidSetFileBytesWritten(Long64_t bytes = 0); static voidSetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); static Bool_tSetOnlyStaged(Bool_t onlystaged); static UInt_tSetOpenTimeout(UInt_t timeout); virtual voidSetOption(Option_t* option = "">""); static voidSetReadaheadSize(Int_t bufsize = 256000); virtual voidSetReadCalls(Int_t readcalls = 0); static voidSetReadStreamerInfo(Bool_t readinfo = kTRUE); virtual voidTDirectoryFile::SetSeekDir(Long64_t v); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTDirectoryFile::SetTRefAction(TObject* ref, TObject* parent); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTDirectoryFile::SetWritable(Bool_t writable = kTRUE); virtual voidShowMembers(TMemberInspector& insp); virtual voidShowStreamerInfo(); static Bool_tShrinkCacheFileDir(Long64_t shrinkSize, Long_t cleanupInteval = 0); virtual Int_tSizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidSumBuffer(Int_t bufsize); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidUseCache(Int_t maxCacheSize = 10, I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFile.html:13659,timeout,timeout,13659,root/html528/TFile.html,https://root.cern,https://root.cern/root/html528/TFile.html,1,['timeout'],['timeout']
Safety," bytes generated since the previous; 1428/// AutoSave is greater than -fAutoSave bytes.; 1429/// If fAutoSave is positive, AutoSave is automatically called by; 1430/// TTree::Fill every N entries.; 1431/// This function may also be invoked by the user.; 1432/// Each AutoSave generates a new key on the file.; 1433/// Once the key with the tree header has been written, the previous cycle; 1434/// (if any) is deleted.; 1435///; 1436/// Note that calling TTree::AutoSave too frequently (or similarly calling; 1437/// TTree::SetAutoSave with a small value) is an expensive operation.; 1438/// You should make tests for your own application to find a compromise; 1439/// between speed and the quantity of information you may loose in case of; 1440/// a job crash.; 1441///; 1442/// In case your program crashes before closing the file holding this tree,; 1443/// the file will be automatically recovered when you will connect the file; 1444/// in UPDATE mode.; 1445/// The Tree will be recovered at the status corresponding to the last AutoSave.; 1446///; 1447/// if option contains ""SaveSelf"", gDirectory->SaveSelf() is called.; 1448/// This allows another process to analyze the Tree while the Tree is being filled.; 1449///; 1450/// if option contains ""FlushBaskets"", TTree::FlushBaskets is called and all; 1451/// the current basket are closed-out and written to disk individually.; 1452///; 1453/// By default the previous header is deleted after having written the new header.; 1454/// if option contains ""Overwrite"", the previous Tree header is deleted; 1455/// before written the new header. This option is slightly faster, but; 1456/// the default option is safer in case of a problem (disk quota exceeded); 1457/// when writing the new header.; 1458///; 1459/// The function returns the number of bytes written to the file.; 1460/// if the number of bytes is null, an error has occurred while writing; 1461/// the header to the file.; 1462///; 1463/// ## How to write a Tree in one process an",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:53453,recover,recovered,53453,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['recover'],['recovered']
Safety," bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti)SIGNAL ; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); virtual Int_tReinitSelector(TQueryResult* qr); virtual voidRemoveQueryResult(const char* ref); voidTObject::ResetBit(UInt_t f); virtual voidRestorePreviousQuery(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetCurrentQuery(TQueryResult* q); virtual voidSetDispatchTimer(Bool_t on = kTRUE); virtual voidSetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetInitTime(); virtual voidSetMaxDrawQueries(Int_t max); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStopProcess(Bool_t abort, Int_t timeout = -1); virtual voidStoreFeedback(TObject* slave, TList* out); virtual voidStoreOutput(TList* out); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidUpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualProofPlayer.html:9623,abort,abort,9623,root/html528/TVirtualProofPlayer.html,https://root.cern,https://root.cern/root/html528/TVirtualProofPlayer.html,4,"['abort', 'timeout']","['abort', 'timeout']"
Safety," c2, Double_t s2); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoHalfSpace&operator=(const TGeoHalfSpace&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(Double_t* point, Bool_t in = kTRUE) const; static Double_tTGeoShape::SafetyPhi(Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetPoints(Double_t*) const; virtual voidSetPoints(Float_t*) const; voidTGeoShape::SetRuntime(Bool_t flag = kTRUE); virtual voidTGeoBBox::SetSegsAndPols(TBuffer3D& buffer) const; voidTGeoShape::Set",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoHalfSpace.html:7715,Safe,SafetyPhi,7715,root/html530/TGeoHalfSpace.html,https://root.cern,https://root.cern/root/html530/TGeoHalfSpace.html,2,['Safe'],['SafetyPhi']
Safety," cache.; if subbranches is true all the branches of the subbranches are; also removed from the cache.; Returns 0 branch dropped or not in cache; -1 on error. void AddClone(TTree* ); Add a cloned tree to our list of trees to be notified whenever we change; our branch addresses or when we are deleted. TFriendElement* AddFriend(const char* treename, const char* filename = """"); Add a TFriendElement to the list of friends. This function:; -opens a file if filename is specified; -reads a Tree with name treename from the file (current directory); -adds the Tree to the list of friends; see other AddFriend functions. A TFriendElement TF describes a TTree object TF in a file.; When a TFriendElement TF is added to the the list of friends of an; existing TTree T, any variable from TF can be referenced in a query; to T. A tree keeps a list of friends. In the context of a tree (or a chain),; friendship means unrestricted access to the friends data. In this way; it is much like adding another branch to the tree without taking the risk; of damaging it. To add a friend to the list, you can use the TTree::AddFriend; method. The tree in the diagram below has two friends (friend_tree1 and; friend_tree2) and now has access to the variables a,b,c,i,j,k,l and m. /*; ; */. The AddFriend method has two parameters, the first is the tree name and the; second is the name of the ROOT file where the friend tree is saved.; AddFriend automatically opens the friend file. If no file name is given,; the tree called ft1 is assumed to be in the same file as the original tree. tree.AddFriend(""ft1"",""friendfile1.root"");; If the friend tree has the same name as the original tree, you can give it; an alias in the context of the friendship:. tree.AddFriend(""tree1 = tree"",""friendfile1.root"");; Once the tree has friends, we can use TTree::Draw as if the friend's; variables were in the original tree. To specify which tree to use in; the Draw method, use the syntax:. <treeName>.<branchname>.<varname>; If the var",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TTree.html:39614,risk,risk,39614,root/html604/TTree.html,https://root.cern,https://root.cern/root/html604/TTree.html,1,['risk'],['risk']
Safety," called on the top master only. Int_t RegisterDataSets(TList* in, TList* out, TDataSetManager* dsm, TString& e); Register TFileCollections in 'out' as datasets according to the rules in 'in'. void HandleQueryList(TMessage* mess); Handle request for list of queries. void HandleRemove(TMessage* mess, TString* slb = 0); Handle remove request. void HandleRetrieve(TMessage* mess, TString* slb = 0); Handle retrieve request. Int_t HandleLibIncPath(TMessage* mess); Handle lib, inc search paths modification request. void HandleCheckFile(TMessage* mess, TString* slb = 0); Handle file checking request. Int_t HandleCache(TMessage* mess, TString* slb = 0); Handle here all cache and package requests. Int_t HandleWorkerLists(TMessage* mess); Handle here all requests to modify worker lists. FILE * SetErrorHandlerFile(FILE* ferr); Set the file stream where to log (default stderr).; If ferr == 0 the default is restored.; Returns current setting. void ErrorHandler(Int_t level, Bool_t abort, const char* location, const char* msg); The PROOF error handler function. It prints the message on fgErrorHandlerFile and; if abort is set it aborts the application. Int_t CopyFromCache(const char* name, Bool_t cpbin); Retrieve any files related to 'macro' from the cache directory.; If 'cpbin' is true, the associated binaries are retrieved as well.; Returns 0 on success, -1 otherwise. Int_t CopyToCache(const char* name, Int_t opt = 0); Copy files related to 'macro' to the cache directory.; Action depends on 'opt':. opt = 0 copy 'macro' to cache and delete from cache any binary; related to name; e.g. if macro = bla.C, the binaries are; bla_C.so, bla_C.rootmap, ...; opt = 1 copy the binaries related to macro to the cache. Returns 0 on success, -1 otherwise. void MakePlayer(); Make player instance. void DeletePlayer(); Delete player instance. Int_t GetPriority(); Get the processing priority for the group the user belongs too. This; priority is a number (0 - 100) determined by a scheduler (third; party ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofServ.html:27827,abort,abort,27827,root/html534/TProofServ.html,https://root.cern,https://root.cern/root/html534/TProofServ.html,2,['abort'],['abort']
Safety," can access a file using the specified access mode.; NB: for the time being mode is ignored for XROOTD (just checks existence; of the file or directory).; Mode is the same as for the Unix access(2) function.; Attention, bizarre convention of return value!!. int Unlink(const char* path); Unlink 'path' on the remote server system.; Returns 0 on success, -1 otherwise. Bool_t IsOnline(const char* path); Check if the file defined by 'path' is ready to be used. Bool_t Prepare(const char* path, UChar_t opt = 8, UChar_t prio = 0); Issue a prepare request for file defined by 'path'. Int_t Prepare(TCollection* paths, UChar_t opt = 8, UChar_t prio = 0, TString* buf = 0); Issue a prepare request for a list of files defined by 'paths', which must; be of one of the following types: TFileInfo, TUrl, TObjString.; On output, bufout, if defined, points to a buffer form that can be used; with GetPathsInfo.; Return the number of paths found or -1 if any error occured. Bool_t GetPathsInfo(const char* paths, UChar_t* info); Retrieve status of a '\n'-separated list of files in 'paths'.; The information is returned as one UChar_t per file in 'info';; 'info' must be allocated by the caller. Bool_t IsPathLocal(const char* path); Returns TRUE if the url in 'path' points to the local file system.; This is used to avoid going through the NIC card for local operations. Int_t Locate(const char* path, TString& endurl); Get end-point url of a file. Info is returned in eurl.; The function returns 0 in case of success and 1 if the file could; not be stat'ed. void * GetDirPtr() const; { return fDirp; }. virtual ~TXNetSystem(); { }. » Author: Frank Winklmeier, Fabrizio Furano » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/netx:$Id: TXNetSystem.h 41574 2011-10-25 13:42:03Z ganis $ » Last generated: 2011-12-02 14:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TXNetSystem.html:22933,avoid,avoid,22933,root/html532/TXNetSystem.html,https://root.cern,https://root.cern/root/html532/TXNetSystem.html,1,['avoid'],['avoid']
Safety," can be chosen here.; # Higher values mean more aggressive recovery.; PrintEvalErrors=-1, # We are still expecting a few evaluation errors.; PrintLevel=0,; ); ; pdf.plotOn(frame, LineColor=""b"", Name=""recovery""); ; ; # Collect results and plot.; # --------------------------------; # We print the two fit results, and plot the fitted curves.; # The curve of the fit without recovery cannot be plotted, because the PDF is undefined if a2 < 0.; fitWithoutRecovery.Print(); print(; ""Without recovery, the fitter encountered {}"".format(fitWithoutRecovery.numInvalidNLL()); + "" invalid function values. The parameters are unchanged.\n""; ); ; fitWithRecovery.Print(); print(; ""With recovery, the fitter encountered {}"".format(fitWithoutRecovery.numInvalidNLL()); + "" invalid function values, but the parameters are fitted.\n""; ); ; legend = ROOT.TLegend(0.5, 0.7, 0.9, 0.9); legend.SetBorderSize(0); legend.SetFillStyle(0); legend.AddEntry(""data"", ""Data"", ""P""); legend.AddEntry(""noRecovery"", ""Without recovery (cannot be plotted)"", ""L""); legend.AddEntry(""recovery"", ""With recovery"", ""L""); frame.Draw(); legend.Draw(); c.Draw(); ; c.SaveAs(""rf612_recoverFromInvalidParameters.png""); formatOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t formatDefinition TGWin32VirtualXProxy.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html:4232,recover,recovery,4232,doc/master/rf612__recoverFromInvalidParameters_8py.html,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html,1,['recover'],['recovery']
Safety," canvas to file; 4956/// }// end loop; 4957/// c1.Print(""file.ps]""); // No actual print, just close.; 4958/// ~~~; 4959/// As before, the same macro is valid for PDF files.; 4960///; 4961/// It is possible to print a canvas into an animated GIF file by specifying the; 4962/// file name as ""myfile.gif+"" or ""myfile.gif+NN"", where NN*10ms is delay; 4963/// between the subimages' display. If NN is omitted the delay between; 4964/// subimages is zero. Each picture is added in the animation thanks to a loop; 4965/// similar to the following one:; 4966/// ~~~ {.cpp}; 4967/// for (int i=0; i<10; ++i) {; 4968/// // fill canvas for context i; 4969/// // ...; 4970///; 4971/// c1.Print(""file.gif+5""); // print canvas to GIF file with 50ms delays; 4972/// }// end loop; 4973/// ~~~; 4974/// The delay between each frame must be specified in each Print() statement.; 4975/// If the file ""myfile.gif"" already exists, the new frame are appended at; 4976/// the end of the file. To avoid this, delete it first with `gSystem->Unlink(myfile.gif);`; 4977/// If you want the gif file to repeat or loop forever, check TASImage::WriteImage documentation; 4978 ; 4979void TPad::Print(const char *filename, Option_t *option); 4980{; 4981 if (!GetCanvas()); 4982 return;; 4983 ; 4984 TString psname, fs1 = filename;; 4985 ; 4986 // ""["" and ""]"" are special characters for ExpandPathName. When they are at the end; 4987 // of the file name (see help) they must be removed before doing ExpandPathName.; 4988 if (fs1.EndsWith(""["")) {; 4989 fs1.Replace((fs1.Length()-1),1,"" "");; 4990 gSystem->ExpandPathName(fs1);; 4991 fs1.Replace((fs1.Length()-1),1,""["");; 4992 } else if (fs1.EndsWith(""]"")) {; 4993 fs1.Replace((fs1.Length()-1),1,"" "");; 4994 gSystem->ExpandPathName(fs1);; 4995 fs1.Replace((fs1.Length()-1),1,""]"");; 4996 } else {; 4997 gSystem->ExpandPathName(fs1);; 4998 }; 4999 ; 5000 // Set the default option as ""Postscript"" (Should be a data member of TPad); 5001 const char *opt_default = ""ps"";; 5002 ; 5003 TString",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TPad_8cxx_source.html:160172,avoid,avoid,160172,doc/master/TPad_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html,1,['avoid'],['avoid']
Safety," case of opt == kOob: -2 means EWOULDBLOCK and -3 EINVAL. In case of non-blocking mode (kNoBlock) -4 means EWOULDBLOCK. Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET). ; Reimplemented in TServerSocket, TPSocket, and TSSLSocket.; Definition at line 898 of file TSocket.cxx. ◆ RecvStreamerInfos(). Bool_t TSocket::RecvStreamerInfos ; (; TMessage * ; mess). protected . Receive a message containing streamer infos. ; In case the message contains streamer infos they are imported, the message will be deleted and the method returns kTRUE. ; Definition at line 928 of file TSocket.cxx. ◆ Select(). Int_t TSocket::Select ; (; Int_t ; interest = kRead, . Long_t ; timeout = -1 . ). virtual . Waits for this socket to change status. ; If interest=kRead, the socket will be watched to see if characters become available for reading; if interest=kWrite the socket will be watched to see if a write will not block. The argument 'timeout' specifies a maximum time to wait in millisec. Default no timeout. Returns 1 if a change of status of interest has been detected within timeout; 0 in case of timeout; < 0 if an error occured. ; Definition at line 443 of file TSocket.cxx. ◆ Send() [1/4]. Int_t TSocket::Send ; (; const char * ; str, . Int_t ; kind = kMESS_STRING . ). virtual . Send a character string buffer. ; Use kind to set the TMessage ""what"" field. Returns the number of bytes in the string str that were sent and -1 in case of error. In case the kind has been or'ed with kMESS_ACK, the call will only return after having received an acknowledgement, making the sending process synchronous. ; Reimplemented in TServerSocket, TPSocket, and TSSLSocket.; Definition at line 500 of file TSocket.cxx. ◆ Send() [2/4]. Int_t TSocket::Send ; (; const TMessage & ; mess). virtual . Send a TMessage object. ; Returns the number of bytes in the TMessage that were sent and -1 in case of error. In case the TMessage::What has been or'ed with kMESS_ACK, the call will only return after having rece",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSocket.html:34588,timeout,timeout,34588,doc/master/classTSocket.html,https://root.cern,https://root.cern/doc/master/classTSocket.html,1,['timeout'],['timeout']
Safety," cast of Thread0 to void(*) in the TThread constructor may raise problems with C++ virtual function table. However, Thread0 may call another virtual member function virtual void Myclass::Func0() which then can be overridden in a derived class of Myclass. (See example TMhs3).; Class Myclass may also provide a method to stop the running thread:; Int_t Myclass::Threadstop() {; if (mTh) {; TThread::Delete(mTh);; delete mTh;; mTh=0;; return 0;; }; return 1;; }; Example TMhs3: Class TThreadframe (TThreadframe.h, TThreadframe.cxx) is a simple example of a framework class managing up to four threaded methods. Class TMhs3 (TMhs3.h, TMhs3.cxx) inherits from this base class, showing the mhs3 example 8.1 (mhs3.h, mhs3.cxx)within a class. The Makefile of this example builds the shared libraries libTThreadframe.so and libTMhs3.so. These are either loaded or executed by the ROOT script TMhs3demo.C, or are linked against an executable: TMhs3run.cxx.; 23.3.1 Known Problems; Parts of the ROOT framework, like the interpreter, are not yet thread-safe. Therefore, you should use this package with caution. If you restrict your threads to distinct and `simple’ duties, you will able to benefit from their use. The TThread class is available on all platforms, which provide a POSIX compliant thread implementation. On Linux, Xavier Leroy’s Linux Threads implementation is widely used, but the TThread implementation should be usable on all platforms that provide pthread.; Linux Xlib on SMP machines is not yet thread-safe. This may cause crashes during threaded graphics operations; this problem is independent of ROOT.; Object instantiation: there is no implicit locking mechanism for memory allocation and global ROOT lists. The user has to explicitly protect their code when using them.; 23.4 The Signals of ROOT; The list of default signals handled by ROOT is:; kSigChildkSigPipe; kSigBuskSigAlarm; kSigSegmentationViolationkSigUrgent; kSigIllegalInstructionkSigFloatingException; kSigSystemkSigWindowCh",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1117010,safe,safe,1117010,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['safe'],['safe']
Safety," cells are the same size,; set by the widest and the highest child frame.; - s gives the amount of separation in pixels between cells; - h are the hints, see TGTableLayoutHints. ~TGTableLayout(); TGTableLayout constructor. void FindRowColSizes(); Find the sizes of rows and columns needed to statisfy; children's layout policies. void FindRowColSizesInit(); Initialize values needed to determine the size of rows and columns. void FindRowColSizesSinglyAttached(); Determine the size of rows/cols needed for singly attached children. void FindRowColSizesHomogeneous(); If the table is homogeneous make sure all col/rows are same; size as biggest col/row. void FindRowColSizesMultiplyAttached(); Checks any children which span multiple col/rows. void SetRowColResize(UInt_t real_size, UInt_t nthings, TGTableLayout::TableData_t* thing, Bool_t homogeneous); If main frame is bigger or smaller than all children,; expand/shrink to fill. This is symmetric under row<-->col; switching so it is abstracted out to a normal function to save typing. void SetRowColSizes(); This gets the new sizes needed to fit the table to the parent; frame. To be called after FindRowColSizes. void SetRowColSizesInit(); Initialize rows/cols. By default they do not expand and they; do shrink. What the children want determine what the rows/cols do. void CheckSanity(); Sanity check various values. void Layout(); Make a table layout of all frames in the list. TGDimension GetDefaultSize() const; Return default dimension of the table layout. void SavePrimitive(ostream& out, Option_t* = """"). TGTableLayoutHints& operator=(const TGTableLayout& ). TGTableLayout(const TGTableLayout& ). » Author: Brett Viren 04/15/2001 » Copyright (C) 2001, Brett Viren *; » Last changed: root/gui:$Id: TGTableLayout.h 23115 2008-04-10 13:35:37Z rdm $ » Last generated: 2010-09-23 20:08; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGTableLayout.html:9577,Sanity check,Sanity check,9577,root/html528/TGTableLayout.html,https://root.cern,https://root.cern/root/html528/TGTableLayout.html,1,['Sanity check'],['Sanity check']
Safety," cells are the same size,; set by the widest and the highest child frame.; - s gives the amount of separation in pixels between cells; - h are the hints, see TGTableLayoutHints. ~TGTableLayout(); TGTableLayout constructor. void FindRowColSizes(); Find the sizes of rows and columns needed to statisfy; children's layout policies. void FindRowColSizesInit(); Initialize values needed to determine the size of rows and columns. void FindRowColSizesSinglyAttached(); Determine the size of rows/cols needed for singly attached children. void FindRowColSizesHomogeneous(); If the table is homogeneous make sure all col/rows are same; size as biggest col/row. void FindRowColSizesMultiplyAttached(); Checks any children which span multiple col/rows. void SetRowColResize(UInt_t real_size, UInt_t nthings, TGTableLayout::TableData_t* thing, Bool_t homogeneous); If main frame is bigger or smaller than all children,; expand/shrink to fill. This is symmetric under row<-->col; switching so it is abstracted out to a normal function to save typing. void SetRowColSizes(); This gets the new sizes needed to fit the table to the parent; frame. To be called after FindRowColSizes. void SetRowColSizesInit(); Initialize rows/cols. By default they do not expand and they; do shrink. What the children want determine what the rows/cols do. void CheckSanity(); Sanity check various values. void Layout(); Make a table layout of all frames in the list. TGDimension GetDefaultSize() const; Return default dimension of the table layout. void SavePrimitive(ostream& out, Option_t* = """"). TGTableLayoutHints& operator=(const TGTableLayout& ). TGTableLayout(const TGTableLayout& ). » Author: Brett Viren 04/15/2001 » Copyright (C) 2001, Brett Viren *; » Last changed: root/gui:$Id: TGTableLayout.h 23115 2008-04-10 13:35:37Z rdm $ » Last generated: 2011-07-04 15:30; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGTableLayout.html:9677,Sanity check,Sanity check,9677,root/html530/TGTableLayout.html,https://root.cern,https://root.cern/root/html530/TGTableLayout.html,1,['Sanity check'],['Sanity check']
Safety," cells are the same size,; set by the widest and the highest child frame.; - s gives the amount of separation in pixels between cells; - h are the hints, see TGTableLayoutHints. ~TGTableLayout(); TGTableLayout constructor. void FindRowColSizes(); Find the sizes of rows and columns needed to statisfy; children's layout policies. void FindRowColSizesInit(); Initialize values needed to determine the size of rows and columns. void FindRowColSizesSinglyAttached(); Determine the size of rows/cols needed for singly attached children. void FindRowColSizesHomogeneous(); If the table is homogeneous make sure all col/rows are same; size as biggest col/row. void FindRowColSizesMultiplyAttached(); Checks any children which span multiple col/rows. void SetRowColResize(UInt_t real_size, UInt_t nthings, TGTableLayout::TableData_t* thing, Bool_t homogeneous); If main frame is bigger or smaller than all children,; expand/shrink to fill. This is symmetric under row<-->col; switching so it is abstracted out to a normal function to save typing. void SetRowColSizes(); This gets the new sizes needed to fit the table to the parent; frame. To be called after FindRowColSizes. void SetRowColSizesInit(); Initialize rows/cols. By default they do not expand and they; do shrink. What the children want determine what the rows/cols do. void CheckSanity(); Sanity check various values. void Layout(); Make a table layout of all frames in the list. TGDimension GetDefaultSize() const; Return default dimension of the table layout. void SavePrimitive(ostream& out, Option_t* = """"). TGTableLayoutHints& operator=(const TGTableLayout& ). TGTableLayout(const TGTableLayout& ). » Author: Brett Viren 04/15/2001 » Copyright (C) 2001, Brett Viren *; » Last changed: root/gui:$Id: TGTableLayout.h 23115 2008-04-10 13:35:37Z rdm $ » Last generated: 2011-11-03 20:16; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGTableLayout.html:9677,Sanity check,Sanity check,9677,root/html532/TGTableLayout.html,https://root.cern,https://root.cern/root/html532/TGTableLayout.html,1,['Sanity check'],['Sanity check']
Safety," char *path)Guess mime type base on file extension.Definition THttpServer.cxx:1479; THttpServer::GetSnifferTRootSniffer * GetSniffer() constreturns pointer on objects snifferDefinition THttpServer.h:89; THttpServer::ReplaceJSROOTLinksvoid ReplaceJSROOTLinks(std::shared_ptr< THttpCallArg > &arg, const std::string &version="""")Replaces all references like ""jsrootsys/..."" or other pre-configured pathes.Definition THttpServer.cxx:847; THttpServer::fTerminatedBool_t fTerminated! termination flag, disables all requests processingDefinition THttpServer.h:37; THttpServer::Restrictvoid Restrict(const char *path, const char *options)Restrict access to specified object.Definition THttpServer.cxx:1386; THttpTimerDefinition THttpServer.cxx:42; THttpTimer::fNormalTmoutLong_t fNormalTmoutDefinition THttpServer.cxx:43; THttpTimer::fSlowBool_t fSlowDefinition THttpServer.cxx:44; THttpTimer::fSlowCntInt_t fSlowCntDefinition THttpServer.cxx:45; THttpTimer::Timeoutvoid Timeout() overridetimeout handler used to process http requests in main ROOT threadDefinition THttpServer.cxx:73; THttpTimer::IsSlowBool_t IsSlow() constDefinition THttpServer.cxx:69; THttpTimer::SetSlowvoid SetSlow(Bool_t flag)Definition THttpServer.cxx:53; THttpTimer::fServerTHttpServer & fServerDefinition THttpServer.cxx:48; THttpTimer::THttpTimerTHttpTimer(Long_t milliSec, Bool_t mode, THttpServer &serv)!< server processing requestsDefinition THttpServer.cxx:51; THttpWSHandlerClass for user-side handling of websocket with THttpServer.Definition THttpWSHandler.h:25; THttpWSHandler::GetDefaultPageContentvirtual TString GetDefaultPageContent()Provides content of default web page for registered web-socket handler Can be content of HTML page or...Definition THttpWSHandler.h:79; TIterDefinition TCollection.h:235; TList::Addvoid Add(TObject *obj) overrideDefinition TList.h:83; TList::Deletevoid Delete(Option_t *option="""") overrideRemove all objects from the list AND delete all heap based objects.Definition TList.cxx:468; TNa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THttpServer_8cxx_source.html:66328,Timeout,Timeoutvoid,66328,doc/master/THttpServer_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THttpServer_8cxx_source.html,2,['Timeout'],"['Timeout', 'Timeoutvoid']"
Safety," char *value);  add attribute to node ;  ; void * AddChild (void *parent, const char *childname, const char *content=nullptr, bool isRootNode=false);  add child node ;  ; Bool_t AddComment (void *node, const char *comment);  ; Bool_t AddRawLine (void *node, const char *raw);  XML helpers. ;  ; std::vector< TMatrixDSym * > * CalcCovarianceMatrices (const std::vector< const Event * > &events, Int_t maxCls, VariableTransformBase *transformBase=nullptr);  ; std::vector< TMatrixDSym * > * CalcCovarianceMatrices (const std::vector< Event * > &events, Int_t maxCls, VariableTransformBase *transformBase=nullptr);  compute covariance matrices ;  ; Bool_t CheckForSilentOption (const TString &) const;  check for ""silence"" option in configuration option string ;  ; Bool_t CheckForVerboseOption (const TString &) const;  check if verbosity ""V"" set in option ;  ; Bool_t CheckSplines (const TH1 *, const TSpline *);  check quality of splining by comparing splines and histograms in each bin ;  ; const TString & Color (const TString &);  human readable color strings ;  ; void ComputeStat (const std::vector< TMVA::Event * > &, std::vector< Float_t > *, Double_t &, Double_t &, Double_t &, Double_t &, Double_t &, Double_t &, Int_t signalClass, Bool_t norm=kFALSE);  sanity check ;  ; Double_t ComputeVariance (Double_t sumx2, Double_t sumx, Int_t nx);  compute variance from given sums ;  ; Bool_t ContainsRegularExpression (const TString &s);  check if regular expression helper function to search for ""$!%^&()'<>?= "" in a string ;  ; void FormattedOutput (const std::vector< Double_t > &, const std::vector< TString > &, const TString titleVars, const TString titleValues, MsgLogger &logger, TString format=""%+1.3f"");  formatted output of simple table ;  ; void FormattedOutput (const TMatrixD &, const std::vector< TString > &, MsgLogger &logger);  formatted output of matrix (with labels) ;  ; void FormattedOutput (const TMatrixD &, const std::vector< TString > &vert, const std::vector< TString > ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1Tools.html:2304,sanity check,sanity check,2304,doc/master/classTMVA_1_1Tools.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1Tools.html,1,['sanity check'],['sanity check']
Safety," char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoConeSeg&operator=(const TGeoConeSeg&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tSafetyS(const Double_t* point, Bool_t in, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t phi1, Double_t phi2, Int_t skipz = 0); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; voidTGeoCone::SetConeDimensions(Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); voidSetConsDimensions(Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t phi1, Double_t phi2); virtual ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoConeSeg.html:9626,Safe,SafetyPhi,9626,root/html602/TGeoConeSeg.html,https://root.cern,https://root.cern/root/html602/TGeoConeSeg.html,2,['Safe'],['SafetyPhi']
Safety," char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoTubeSeg&operator=(const TGeoTubeSeg&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tSafetyS(const Double_t* point, Bool_t in, Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2, Int_t skipz = 0); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoTubeSeg.html:9760,Safe,SafetyPhi,9760,root/html602/TGeoTubeSeg.html,https://root.cern,https://root.cern/root/html602/TGeoTubeSeg.html,2,['Safe'],['SafetyPhi']
Safety," char* name, Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2, Double_t lx, Double_t ly, Double_t lz, Double_t tx, Double_t ty, Double_t tz); constructor. TGeoCtub(Double_t* params); ctor with parameters. ~TGeoCtub(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute minimum bounding box of the ctub. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; check if point is contained in the cut tube; check the lower cut plane. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. Double_t GetZcoord(Double_t xc, Double_t yc, Double_t zc) const; compute real Z coordinate of a point belonging to either lower or; higher caps (z should be either +fDz or -fDz). Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the cut tube. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the cut tube. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Divide the tube along one axis. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; in case shape has some negative parameters, these has to be computed; in order to fit the mother. void InspectShape() const; print shape parameters. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape, according; to option. The matching point on the shape is stored in spoint. void SetCtubDimensions(Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2, Double_t lx, Double_t ly, Double_t lz,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoCtub.html:14836,safe,safe,14836,root/html528/TGeoCtub.html,https://root.cern,https://root.cern/root/html528/TGeoCtub.html,3,['safe'],['safe']
Safety," char* objname, TString& itemname); TRootSnifferScanRec&operator=(const TRootSnifferScanRec&); Bool_tScanOnlyFields() const; voidSetField(const char* name, const char* value, Bool_t with_quotes = kTRUE); Bool_tSetResult(void* obj, TClass* cl, TDataMember* member = 0); voidSetRootClass(TClass* cl); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TRootSnifferScanRec(); TRootSnifferScanRec(const TRootSnifferScanRec&). Data Members; protected:. Bool_tfHasMore! indicates that potentially there are more items can be found; TStringfItemName! name of current item; TListfItemsNames! list of created items names, need to avoid duplication; Int_tfLevel! current level of hierarchy; UInt_tfMask! defines operation kind; Bool_tfNodeStarted! indicate if node was started; Int_tfNumChilds! number of childs; Int_tfNumFields! number of fields; TRootSnifferScanRec*fParent! pointer on parent record; Int_tfRestriction! restriction 0 - default, 1 - read-only, 2 - full access; const char*fSearchPath! current path searched; TRootSnifferStore*fStore! object to store results; static TRootSnifferScanRec::(anonymous)kActions; static TRootSnifferScanRec::(anonymous)kCheckChilds; static TRootSnifferScanRec::(anonymous)kExpand; static TRootSnifferScanRec::(anonymous)kOnlyFields; static TRootSnifferScanRec::(anonymous)kScan; static TRootSnifferScanRec::(anonymous)kSearch. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TRootSnifferScanRec(); constructor. ~TRootSnifferScanRec(); destructor. void SetField(const char* name, const char* value, Bool_t with_quotes = kTRUE); record field for current element. void BeforeNextChild(); indicates that new child for current element will be started. void MakeItemName(const char* objname, TString& itemname); constructs item name from object name; if special symbols like '/', '#', ':', '&', '?' are used in object name; they wil",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TRootSnifferScanRec.html:1687,avoid,avoid,1687,root/html604/TRootSnifferScanRec.html,https://root.cern,https://root.cern/root/html604/TRootSnifferScanRec.html,1,['avoid'],['avoid']
Safety," char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowCache(Bool_t all = kFALSE); voidTProof::ShowData(); voidTProof::ShowDataSet(const char* dataset = """", const char* opt = ""M""); virtual voidShowDataSetCache(const char* dataset = 0); voidTProof::ShowDataSetQuota(Option_t* opt = 0); virtual voidShowDataSets(const char* uri = """", const char* = 0); voidTProof::ShowEnabledPackages(Bool_t all = kFALSE); voidTProof::ShowFeedback() const; voidTProof::ShowLog(Int_t qry = -1); voidTProof::ShowLog(const char* queryref); virtual voidShowMembers(TMemberInspector& insp); voidTProof::ShowMissingFiles(TQueryResult* qr = 0); voidTProof::ShowPackages(Bool_t all = kFALSE, Bool_t redirlog = kFALSE); voidTProof::ShowParameters(const char* wildcard = ""PROOF_*"") const; voidTProof::ShowQueries(Option_t* opt = """"); virtual Int_tTNamed::Sizeof() const; voidTProof::StartupMessage(const char* msg, Bool_t status, Int_t done, Int_t total)SIGNAL ; voidTProof::StopProcess(Bool_t abort, Int_t timeout = -1); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; voidTProof::Touch(); Int_tTProof::UploadDataSet(const char* dataset, TList* files, const char* dest = 0, Int_t opt = kAskUser, TList* skippedFiles = 0); Int_tTProof::UploadDataSet(const char* dataset, const char* files, const char* dest = 0, Int_t opt = kAskUser, TList* skippedFiles = 0); Int_tTProof::UploadDataSetFromFile(const char* dataset, const char* file, const char* dest = 0, Int_t opt = kAskUser, TList* skippedFiles = 0); Int_tTProof::UploadPackage(const char* par, TProof::EUploadPackageOpt opt = kUntar); virtual voidTObject::UseCurrentStyle(); Bool_tTProof::UseDynamicStartup() const; virtual Int_tVerifyDataSet(const char* uri, const char* = 0); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProofLite.html:16912,abort,abort,16912,root/html530/TProofLite.html,https://root.cern,https://root.cern/root/html530/TProofLite.html,2,['abort'],['abort']
Safety," char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTGeoBBox::ComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidTGeoBBox::ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); static TEveGeoPolyShape*Construct(TGeoCompositeShape* cshp, Int_t n_seg); virtual Bool_tTGeoBBox::Contains(Double_t* point) const; static Bool_tTGeoBBox::Contains(const Double_t* point, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin); virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoBBox::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tTGeoBBox::DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoBBox::DistFromInside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); virtual Double_tTGeoBBox::DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoBBox::DistFromOutside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*TGeoBBox::Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEveGeoPolyShape.html:1823,safe,safe,1823,root/html528/TEveGeoPolyShape.html,https://root.cern,https://root.cern/root/html528/TEveGeoPolyShape.html,2,['safe'],['safe']
Safety," cl, const char* method, const char* proto, Bool_t objectIsConst = kFALSE, ROOT::EFunctionMatchMode = ROOT::kConversionMatch). void Execute(const char* function, const char* params, int* error = 0). void Execute(TObject* obj, TClass* cl, const char* method, const char* params, int* error = 0). void Execute(TObject* obj, TClass* cl, TMethod* method, TObjArray* params, int* error = 0). void ExecuteWithArgsAndReturn(TMethod* method, void* address, const void*[] args = 0, int = 0, void* ret = 0) const. Long_t ExecuteMacro(const char* filename, TInterpreter::EErrorCode* error = 0). Bool_t IsErrorMessagesEnabled() const. Bool_t SetErrorMessages(Bool_t enable = kTRUE). Bool_t IsProcessLineLocked() const. void SetProcessLineLock(Bool_t lock = kTRUE). const char * TypeName(const char* s). int DisplayClass(FILE* , const char* , int , int ) const; All the functions below must be virtual with a dummy implementation; These functions are redefined in TCling.; The dummy implementation avoids an implementation in TGWin32InterpreterProxy; Misc. {return 0;}. int DisplayIncludePath(FILE* ) const; {return 0;}. void * FindSym(const char* ) const; {return 0;}. void GenericError(const char* ) const; {;}. Long_t GetExecByteCode() const; {return 0;}. Long_t Getgvp() const; {return 0;}. const char * Getp2f2funcname(void* ) const; {return 0;}. const char * GetTopLevelMacroName() const; {return 0;}. const char * GetCurrentMacroName() const; {return 0;}. int GetSecurityError() const; {return 0;}. int LoadFile(const char* ) const; {return 0;}. Bool_t LoadText(const char* ) const; {return kFALSE;}. const char * MapCppName(const char* ) const; {return 0;}. void SetAlloclockfunc(void(*)() ) const; {;}. void SetAllocunlockfunc(void(*)() ) const; {;}. int SetClassAutoloading(int ) const; {return 0;}. int SetClassAutoparsing(int ); {return 0;}. void SetErrmsgcallback(void* ) const; {;}. void Setgvp(Long_t ) const; {;}. void SetRTLD_NOW() const; {;}. void SetRTLD_LAZY() const; {;}. void SetTempLevel(int",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TInterpreter.html:30240,avoid,avoids,30240,root/html602/TInterpreter.html,https://root.cern,https://root.cern/root/html602/TInterpreter.html,2,['avoid'],['avoids']
Safety," clang does not accept it's own headers; 333 * in a release build configuration. Disable what is too much in; 334 * -Weverything. */; 335#pragma clang diagnostic ignored ""-Wdisabled-macro-expansion""; 336#endif; 337 ; 338#if defined(__GNUC__) || defined(__MINGW32__); 339/* Who on earth came to the conclusion, using __DATE__ should rise; 340 * an ""expansion of date or time macro is not reproducible""; 341 * warning. That's exactly what was intended by using this macro.; 342 * Just disable this nonsense warning. */; 343 ; 344/* And disabling them does not work either:; 345 * #pragma clang diagnostic ignored ""-Wno-error=date-time""; 346 * #pragma clang diagnostic ignored ""-Wdate-time""; 347 * So we just have to disable ALL warnings for some lines; 348 * of code.; 349 * This seems to be a known GCC bug, not resolved since 2012:; 350 * https://gcc.gnu.org/bugzilla/show_bug.cgi?id=53431; 351 */; 352#endif; 353 ; 354 ; 355#if defined(__MACH__) /* Apple OSX section */; 356 ; 357#if defined(__clang__); 358#if (__clang_major__ == 3) && ((__clang_minor__ == 7) || (__clang_minor__ == 8)); 359/* Avoid warnings for Xcode 7. It seems it does no longer exist in Xcode 8 */; 360#pragma clang diagnostic ignored ""-Wno-reserved-id-macro""; 361#pragma clang diagnostic ignored ""-Wno-keyword-macro""; 362#endif; 363#endif; 364 ; 365#ifndef CLOCK_MONOTONIC; 366#define CLOCK_MONOTONIC (1); 367#endif; 368#ifndef CLOCK_REALTIME; 369#define CLOCK_REALTIME (2); 370#endif; 371 ; 372#include <mach/clock.h>; 373#include <mach/mach.h>; 374#include <mach/mach_time.h>; 375#include <sys/errno.h>; 376#include <sys/time.h>; 377 ; 378/* clock_gettime is not implemented on OSX prior to 10.12 */; 379static int; 380_civet_clock_gettime(int clk_id, struct timespec *t); 381{; 382 memset(t, 0, sizeof(*t));; 383 if (clk_id == CLOCK_REALTIME) {; 384 struct timeval now;; 385 int rv = gettimeofday(&now, NULL);; 386 if (rv) {; 387 return rv;; 388 }; 389 t->tv_sec = now.tv_sec;; 390 t->tv_nsec = now.tv_usec * 1000;; 391 ret",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:13118,Avoid,Avoid,13118,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,2,['Avoid'],['Avoid']
Safety," classes, those classes should be; 7348 // cross-checked in testHashRecursiveRemove.cxx; 7349 static const char *handVerified[] = {; 7350 ""TEnvRec"", ""TDataType"", ""TObjArray"", ""TList"", ""THashList"",; 7351 ""TClass"", ""TCling"", ""TInterpreter"", ""TMethod"", ""ROOT::Internal::TCheckHashRecursiveRemoveConsistency"",; 7352 ""TCheckHashRecursiveRemoveConsistency"", ""TGWindow"",; 7353 ""TDirectory"", ""TDirectoryFile"", ""TObject"", ""TH1"",; 7354 ""TQClass"", ""TGlobal"" };; 7355 ; 7356 if (cname && cname[0]) {; 7357 for (auto cursor : handVerified) {; 7358 if (strcmp(cname, cursor) == 0); 7359 return true;; 7360 }; 7361 }; 7362 return false;; 7363}; 7364 ; 7365////////////////////////////////////////////////////////////////////////////////; 7366/// Return true is the Hash/RecursiveRemove setup is consistent, i.e. when all; 7367/// classes in the class hierarchy that overload TObject::Hash do call; 7368/// ROOT::CallRecursiveRemoveIfNeeded in their destructor.; 7369/// i.e. it is safe to call the Hash virtual function during the RecursiveRemove operation.; 7370 ; 7371Bool_t ROOT::Internal::HasConsistentHashMember(TClass &clRef); 7372{; 7373 return clRef.HasConsistentHashMember();; 7374}; 7375 ; 7376////////////////////////////////////////////////////////////////////////////////; 7377/// Return true if we have access to a constructor usable for I/O. This is; 7378/// typically the default constructor but can also be a constructor specifically; 7379/// marked for I/O (for example a constructor taking a TRootIOCtor* as an; 7380/// argument). In other words, if this routine returns true, TClass::New is; 7381/// guarantee to succeed.; 7382/// To know if the class described by this TClass has a default constructor; 7383/// (public or not), use; 7384/// \code{.cpp}; 7385/// cl->GetProperty() & kClassHasDefaultCtor; 7386/// \endcode; 7387/// To know if the class described by this TClass has a public default; 7388/// constructor use:; 7389/// \code{.cpp}; 7390/// gInterpreter->ClassInfo_HasDefaultConstruc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:283009,safe,safe,283009,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['safe'],['safe']
Safety," classes, those classes should be; 7415 // cross-checked in testHashRecursiveRemove.cxx; 7416 static const char *handVerified[] = {; 7417 ""TEnvRec"", ""TDataType"", ""TObjArray"", ""TList"", ""THashList"",; 7418 ""TClass"", ""TCling"", ""TInterpreter"", ""TMethod"", ""ROOT::Internal::TCheckHashRecursiveRemoveConsistency"",; 7419 ""TCheckHashRecursiveRemoveConsistency"", ""TGWindow"",; 7420 ""TDirectory"", ""TDirectoryFile"", ""TObject"", ""TH1"",; 7421 ""TQClass"", ""TGlobal"" };; 7422 ; 7423 if (cname && cname[0]) {; 7424 for (auto cursor : handVerified) {; 7425 if (strcmp(cname, cursor) == 0); 7426 return true;; 7427 }; 7428 }; 7429 return false;; 7430}; 7431 ; 7432////////////////////////////////////////////////////////////////////////////////; 7433/// Return true is the Hash/RecursiveRemove setup is consistent, i.e. when all; 7434/// classes in the class hierarchy that overload TObject::Hash do call; 7435/// ROOT::CallRecursiveRemoveIfNeeded in their destructor.; 7436/// i.e. it is safe to call the Hash virtual function during the RecursiveRemove operation.; 7437 ; 7438Bool_t ROOT::Internal::HasConsistentHashMember(TClass &clRef); 7439{; 7440 return clRef.HasConsistentHashMember();; 7441}; 7442 ; 7443////////////////////////////////////////////////////////////////////////////////; 7444/// Return true if we have access to a constructor usable for I/O. This is; 7445/// typically the default constructor but can also be a constructor specifically; 7446/// marked for I/O (for example a constructor taking a TRootIOCtor* as an; 7447/// argument). In other words, if this routine returns true, TClass::New is; 7448/// guarantee to succeed.; 7449/// To know if the class described by this TClass has a default constructor; 7450/// (public or not), use; 7451/// \code{.cpp}; 7452/// cl->GetProperty() & kClassHasDefaultCtor; 7453/// \endcode; 7454/// To know if the class described by this TClass has a public default; 7455/// constructor use:; 7456/// \code{.cpp}; 7457/// gInterpreter->ClassInfo_HasDefaultConstruc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:285760,safe,safe,285760,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['safe'],['safe']
Safety," collcl = LoadClassDefault(collname.c_str(), silent);; 3163 if (collcl) {; 3164 auto p = collcl->GetCollectionProxy();; 3165 if (p); 3166 cl = p->GetValueClass();; 3167 if (cl); 3168 return cl;; 3169 }; 3170 }; 3171 }; 3172 } else if (TClassEdit::IsSTLCont( normalizedName.c_str() )) {; 3173 ; 3174 return gInterpreter->GenerateTClass(normalizedName.c_str(), kTRUE, silent);; 3175 }; 3176 ; 3177 // Check the interpreter only after autoparsing the template if any.; 3178 if (!ispairbase) {; 3179 std::string::size_type posLess = normalizedName.find('<');; 3180 if (posLess != std::string::npos) {; 3181 gCling->AutoParse(normalizedName.substr(0, posLess).c_str());; 3182 }; 3183 }; 3184 ; 3185 //last attempt. Look in CINT list of all (compiled+interpreted) classes; 3186 if (gDebug>0){; 3187 printf(""TClass::GetClass: Header Parsing - The representation of %s was not found in the type system. A lookup in the interpreter is about to be tried: this can cause parsing. This can be avoided selecting %s in the linkdef/selection file.\n"",normalizedName.c_str(), normalizedName.c_str());; 3188 }; 3189 if (normalizedName.length()) {; 3190 auto cci = gInterpreter->CheckClassInfo(normalizedName.c_str(), kTRUE /* autoload */,; 3191 kTRUE /*Only class, structs and ns*/);; 3192 ; 3193 // We could have an interpreted class with an inline ClassDef, in this case we do not; 3194 // want to create an 'interpreted' TClass but we want the one triggered via the call to; 3195 // the Dictionary member. If we go ahead and generate the 'interpreted' version it will; 3196 // replace if/when there is a call to IsA on an object of this type.; 3197 ; 3198 if (cci == TInterpreter::kWithClassDefInline) {; 3199 auto ci = gInterpreter->ClassInfo_Factory(normalizedName.c_str());; 3200 auto funcDecl = gInterpreter->GetFunctionWithPrototype(ci, ""Dictionary"", """", false, ROOT::kExactMatch);; 3201 auto method = gInterpreter->MethodInfo_Factory(funcDecl);; 3202 typedef void (*tcling_callfunc_Wrapper_t)(void *, int, vo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:121169,avoid,avoided,121169,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['avoid'],['avoided']
Safety," collcl = LoadClassDefault(collname.c_str(), silent);; 3230 if (collcl) {; 3231 auto p = collcl->GetCollectionProxy();; 3232 if (p); 3233 cl = p->GetValueClass();; 3234 if (cl); 3235 return cl;; 3236 }; 3237 }; 3238 }; 3239 } else if (TClassEdit::IsSTLCont( normalizedName.c_str() )) {; 3240 ; 3241 return gInterpreter->GenerateTClass(normalizedName.c_str(), kTRUE, silent);; 3242 }; 3243 ; 3244 // Check the interpreter only after autoparsing the template if any.; 3245 if (!ispairbase) {; 3246 std::string::size_type posLess = normalizedName.find('<');; 3247 if (posLess != std::string::npos) {; 3248 gCling->AutoParse(normalizedName.substr(0, posLess).c_str());; 3249 }; 3250 }; 3251 ; 3252 //last attempt. Look in CINT list of all (compiled+interpreted) classes; 3253 if (gDebug>0){; 3254 printf(""TClass::GetClass: Header Parsing - The representation of %s was not found in the type system. A lookup in the interpreter is about to be tried: this can cause parsing. This can be avoided selecting %s in the linkdef/selection file.\n"",normalizedName.c_str(), normalizedName.c_str());; 3255 }; 3256 if (normalizedName.length()) {; 3257 auto cci = gInterpreter->CheckClassInfo(normalizedName.c_str(), kTRUE /* autoload */,; 3258 kTRUE /*Only class, structs and ns*/);; 3259 ; 3260 // We could have an interpreted class with an inline ClassDef, in this case we do not; 3261 // want to create an 'interpreted' TClass but we want the one triggered via the call to; 3262 // the Dictionary member. If we go ahead and generate the 'interpreted' version it will; 3263 // replace if/when there is a call to IsA on an object of this type.; 3264 ; 3265 if (cci == TInterpreter::kWithClassDefInline) {; 3266 auto ci = gInterpreter->ClassInfo_Factory(normalizedName.c_str());; 3267 auto funcDecl = gInterpreter->GetFunctionWithPrototype(ci, ""Dictionary"", """", false, ROOT::kExactMatch);; 3268 auto method = gInterpreter->MethodInfo_Factory(funcDecl);; 3269 typedef void (*tcling_callfunc_Wrapper_t)(void *, int, vo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:123920,avoid,avoided,123920,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['avoid'],['avoided']
Safety," collection.; 234 continue;; 235 }; 236 // The next object to be merged with is a collection; 237 // the iterator skips the 'holes' the collections, we also need to do so.; 238 objtomerge = ((TSeqCollection*)collcrt)->At(indobj);; 239 if (!objtomerge) {; 240 Warning(""Merge"", ""object of type %s (position %d in list) not found in list %d. Continuing..."",; 241 object->ClassName(), indobj, indcoll);; 242 continue;; 243 }; 244/*; 245 // Dangerous - may try to merge non-corresponding histograms (A.G); 246 while (objtomerge == 0; 247 && indobj < ((TSeqCollection*)collcrt)->LastIndex(); 248 ) {; 249 ++indobj;; 250 objtomerge = ((TSeqCollection*)collcrt)->At(indobj);; 251 }; 252*/; 253 if (object->IsA() != objtomerge->IsA()) {; 254 Error(""Merge"", ""object of type %s at index %d not matching object of type %s in input list"",; 255 object->ClassName(), indobj, objtomerge->ClassName());; 256 SafeDelete(templist);; 257 return 0;; 258 }; 259 // Add object at index indobj in the temporary list; 260 if (mergeable) {; 261 templist->Add(objtomerge);; 262 nmerged++;; 263 } else {; 264 // Just add it to the dedicated temp list for later addition to the current list; 265 if (!notmergeable && IsA()); 266 notmergeable = (TSeqCollection*)IsA()->New();; 267 if (notmergeable); 268 notmergeable->Add(objtomerge);; 269 else; 270 Warning(""Merge"", ""temp list for non mergeable objects not created!"");; 271 }; 272 }; 273 // Merge current object with objects in the temporary list; 274 if (mergeable) {; 275 callEnv.SetParam((Longptr_t) templist);; 276 callEnv.Execute(object);; 277 SafeDelete(templist);; 278 }; 279 indobj++;; 280 }; 281 ; 282 // Add the non-mergeable objects, if any; 283 if (notmergeable && notmergeable->GetSize() > 0) {; 284 TIter nxnm(notmergeable);; 285 while (auto onm = nxnm()); 286 Add(onm->Clone());; 287 SafeDelete(notmergeable);; 288 }; 289 ; 290 return nmerged;; 291}; SafeDelete#define SafeDelete(p)Definition RConfig.hxx:525; b#define b(i)Definition RSha256.hxx:100; a#define a(i)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSeqCollection_8cxx_source.html:8879,Safe,SafeDelete,8879,doc/master/TSeqCollection_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSeqCollection_8cxx_source.html,1,['Safe'],['SafeDelete']
Safety," composite p.d.fs.Definition RooAbsReal.cxx:1438; RooAbsReal::createIntegralRooFit::OwningPtr< RooAbsReal > createIntegral(const RooArgSet &iset, const RooCmdArg &arg1, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}) constCreate an object that represents the integral of the function over one or more observables listed in ...Definition RooAbsReal.cxx:514; RooAbsReal::ScaleTypeScaleTypeDefinition RooAbsReal.h:276; RooAbsReal::NumEvent@ NumEventDefinition RooAbsReal.h:276; RooAbsReal::Relative@ RelativeDefinition RooAbsReal.h:276; RooAbsReal::Raw@ RawDefinition RooAbsReal.h:276; RooAbsReal::RelativeExpected@ RelativeExpectedDefinition RooAbsReal.h:276; RooAbsReal::getValdouble getVal(const RooArgSet *normalisationSet=nullptr) constEvaluate object.Definition RooAbsReal.h:103; RooAbsReal::plotSanityChecksbool plotSanityChecks(RooPlot *frame) constUtility function for plotOn(), perform general sanity check on frame to ensure safe plotting operatio...Definition RooAbsReal.cxx:2860; RooAbsReal::printMultilinevoid printMultiline(std::ostream &os, Int_t contents, bool verbose=false, TString indent="""") const overrideStructure printing.Definition RooAbsReal.cxx:455; RooAbsReal::redirectServersHookbool redirectServersHook(const RooAbsCollection &newServerList, bool mustReplaceAll, bool nameChange, bool isRecursiveStep) overrideFunction that is called at the end of redirectServers().Definition RooAbsReal.cxx:4474; RooAbsReal::_valuedouble _valueCache for current value of object.Definition RooAbsReal.h:536; RooAbsReal::analyticalIntegralvirtual double analyticalIntegral(Int_t code, const char *rangeName=nullptr) constImplements the actual analytical integral(s) advertised by getAnalyticalIntegral.Definition RooAbsReal.cxx:394; RooAbsReal::integralNameSuffixTString integralNameSuffix(const RooArgSet &iset, const RooArgSet *nset=nullptr, const char *r",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html:157088,sanity check,sanity check,157088,doc/master/RooAbsPdf_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html,2,"['safe', 'sanity check']","['safe', 'sanity check']"
Safety," connection;; 336 }; 337 Clear(""nodelete"");; 338}; 339 ; 340////////////////////////////////////////////////////////////////////////////////; 341/// Remove connection from the list. For more info see; 342/// TQObject::Disconnect(); 343 ; 344Bool_t TQConnectionList::Disconnect(void *receiver, const char *slot_name); 345{; 346 TQConnection *connection = nullptr;; 347 Bool_t return_value = kFALSE;; 348 ; 349 TObjLink *lnk = FirstLink();; 350 TObjLink *savlnk; // savlnk is used when link is deleted; 351 ; 352 while (lnk) {; 353 connection = (TQConnection*)lnk->GetObject();; 354 const char *name = connection->GetName();; 355 void *obj = connection->GetReceiver();; 356 ; 357 if (!slot_name || !slot_name[0]; 358 || !strcmp(name,slot_name)) {; 359 ; 360 if (!receiver || (receiver == obj)) {; 361 return_value = kTRUE;; 362 savlnk = lnk->Next(); // keep next link ..; 363 Remove(lnk);; 364 lnk = savlnk; // current link == saved ...; 365 connection->Remove(this); // remove back reference; 366 if (connection->IsEmpty()) SafeDelete(connection);; 367 continue; // .. continue from saved link; 368 }; 369 }; 370 lnk = lnk->Next();; 371 }; 372 return return_value;; 373}; 374 ; 375////////////////////////////////////////////////////////////////////////////////; 376/// List signal name and list all connections in this signal list.; 377 ; 378void TQConnectionList::ls(Option_t *option) const; 379{; 380 std::cout << ""TQConnectionList:"" << ""\t"" << GetName() << std::endl;; 381 ((TQConnectionList*)this)->R__FOR_EACH(TQConnection,Print)(option);; 382}; 383 ; 384 ; 385////////////////////////////////////////////////////////////////////////////////; 386/// TQObject Constructor.; 387/// Comment:; 388/// - In order to minimize memory allocation fListOfSignals and; 389/// fListOfConnections are allocated only if it is neccesary; 390/// - When fListOfSignals/fListOfConnections are empty they will; 391/// be deleted; 392 ; 393TQObject::TQObject(); 394{; 395 fListOfSignals = nullptr;; 396 fListOfConne",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TQObject_8cxx_source.html:11879,Safe,SafeDelete,11879,doc/master/TQObject_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TQObject_8cxx_source.html,1,['Safe'],['SafeDelete']
Safety," const Double_t* dirs, Double_t* norms, Int_t vecsize); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidCreateThreadData(Int_t nthreads); virtual voidTGeoPcon::DefineSection(Int_t snum, Double_t z, Double_t rmin, Double_t rmax); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tTGeoPcon::DistToSegZ(const Double_t* point, const Double_t* dir, Int_t& iz) const; virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Double_t&TGeoPcon::Dphi(); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::E",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoPgon.html:2875,safe,safe,2875,root/html534/TGeoPgon.html,https://root.cern,https://root.cern/root/html534/TGeoPgon.html,3,['safe'],['safe']
Safety," const RooArgSet *projectedVars=nullptr, bool scaling=true, const RooArgSet *condObs=nullptr, bool setError=true) constFill the ROOT histogram 'hist' with values sampled from this function at the bin centers.Definition RooAbsReal.cxx:947; RooAbsReal::createScanRIRooFit::OwningPtr< RooAbsReal > createScanRI(const RooArgSet &iset, const RooArgSet &nset, Int_t numScanBins, Int_t intOrder)Utility function for createRunningIntegral that construct an object implementing the numeric scanning...Definition RooAbsReal.cxx:3810; RooAbsReal::_DEBUG_getValdouble _DEBUG_getVal(const RooArgSet *normalisationSet) constDebug version of getVal(), which is slow and does error checking.Definition RooAbsReal.cxx:4434; RooAbsReal::createFundamentalRooFit::OwningPtr< RooAbsArg > createFundamental(const char *newname=nullptr) const overrideCreate a RooRealVar fundamental object with our properties.Definition RooAbsReal.cxx:3130; RooAbsReal::plotSanityChecksbool plotSanityChecks(RooPlot *frame) constUtility function for plotOn(), perform general sanity check on frame to ensure safe plotting operatio...Definition RooAbsReal.cxx:2860; RooAbsReal::bindVarsRooFit::OwningPtr< RooAbsFunc > bindVars(const RooArgSet &vars, const RooArgSet *nset=nullptr, bool clipInvalid=false) constCreate an interface adaptor f(vars) that binds us to the specified variables (in arbitrary order).Definition RooAbsReal.cxx:2980; RooAbsReal::selectNormalizationvirtual void selectNormalization(const RooArgSet *depSet=nullptr, bool force=false)Interface function to force use of a given set of observables to interpret function value.Definition RooAbsReal.cxx:3360; RooAbsReal::derivativeRooDerivative * derivative(RooRealVar &obs, Int_t order=1, double eps=0.001)Return function representing first, second or third order derivative of this function.Definition RooAbsReal.cxx:3987; RooAbsReal::chi2FitTovirtual RooFit::OwningPtr< RooFitResult > chi2FitTo(RooDataHist &data, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8cxx_source.html:220683,sanity check,sanity check,220683,doc/master/RooAbsReal_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html,2,"['safe', 'sanity check']","['safe', 'sanity check']"
Safety," const TBuffer3D & GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; Fills a static 3D buffer and returns a reference. void Contains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoTube(); methods; constructors. Int_t GetByteCount() const; {return 48;}. Double_t GetRmin() const; {return fRmin;}. Double_t GetRmax() const; {return fRmax;}. Double_t GetDz() const; {return fDz;}. Bool_t HasRmin() const; {return (fRmin>0)?kTRUE:kFALSE;}. Bool_t IsCylType() const; {return kTRUE;}. » Author: Andrei Gheata 24/10/01 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-03-14 16:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoTube.html:20359,safe,safe,20359,root/html534/TGeoTube.html,https://root.cern,https://root.cern/root/html534/TGeoTube.html,3,"['Safe', 'safe']","['Safety', 'safe']"
Safety," const TBuffer3D & GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; Fills a static 3D buffer and returns a reference. void Contains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoTube(); methods; constructors. Int_t GetByteCount() const; {return 48;}. Double_t GetRmin() const; {return fRmin;}. Double_t GetRmax() const; {return fRmax;}. Double_t GetDz() const; {return fDz;}. Bool_t HasRmin() const; {return (fRmin>0)?kTRUE:kFALSE;}. Bool_t IsCylType() const; {return kTRUE;}. » Author: Andrei Gheata 24/10/01 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-02 16:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGeoTube.html:22113,safe,safe,22113,root/html604/TGeoTube.html,https://root.cern,https://root.cern/root/html604/TGeoTube.html,3,"['Safe', 'safe']","['Safety', 'safe']"
Safety," const TBuffer3D & GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; Fills a static 3D buffer and returns a reference. void Contains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoTube(); methods; constructors. Int_t GetByteCount() const; {return 48;}. Double_t GetRmin() const; {return fRmin;}. Double_t GetRmax() const; {return fRmax;}. Double_t GetDz() const; {return fDz;}. Bool_t HasRmin() const; {return (fRmin>0)?kTRUE:kFALSE;}. Bool_t IsCylType() const; {return kTRUE;}. » Author: Andrei Gheata 24/10/01 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-30 15:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoTube.html:22113,safe,safe,22113,root/html602/TGeoTube.html,https://root.cern,https://root.cern/root/html602/TGeoTube.html,3,"['Safe', 'safe']","['Safety', 'safe']"
Safety," const TString & ; name, . const TString & ; options, . const TString & ; suffix = """", . PDF * ; defaultPDF = nullptr, . Bool_t ; norm = kTRUE . ). explicit . Definition at line 193 of file PDF.cxx. ◆ ~PDF(). TMVA::PDF::~PDF ; (; ). virtual . Definition at line 246 of file PDF.cxx. Member Function Documentation. ◆ AddXMLTo(). void TMVA::PDF::AddXMLTo ; (; void * ; parent). XML file writing. ; Definition at line 919 of file PDF.cxx. ◆ BuildKDEPDF(). void TMVA::PDF::BuildKDEPDF ; (; ). private . creates high-binned reference histogram to be used instead of the PDF for speed reasons ; Definition at line 387 of file PDF.cxx. ◆ BuildPDF(). void TMVA::PDF::BuildPDF ; (; const TH1 * ; theHist). Definition at line 260 of file PDF.cxx. ◆ BuildSplinePDF(). void TMVA::PDF::BuildSplinePDF ; (; ). private . build the PDF from the original histograms ; Definition at line 321 of file PDF.cxx. ◆ CheckHist(). void TMVA::PDF::CheckHist ; (; ); const. private . sanity check: compare PDF with original histogram ; Definition at line 553 of file PDF.cxx. ◆ Class(). static TClass * TMVA::PDF::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TMVA::PDF::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TMVA::PDF::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 211 of file PDF.h. ◆ DeclareOptions(). void TMVA::PDF::DeclareOptions ; (; ). define the options (their key words) that can be set in the option string ; know options:; PDFInterpol[ivar] <string> Spline0, Spline1, Spline2 <default>, Spline3, Spline5, KDE used to interpolate reference histograms if no variable index is given, it is valid for ALL the variables. NSmooth <int> how often the input histos are smoothed; MinNSmooth <int> min number of smoothing iterations, for bins with most data; MaxNSmooth <int> max number of smoothing iterations, for bins with least data; NAvEvtPerBin <int> min",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1PDF.html:20995,sanity check,sanity check,20995,doc/master/classTMVA_1_1PDF.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1PDF.html,1,['sanity check'],['sanity check']
Safety," const char * UnixHomedirectory (const char *user, char *path, char *mydir);  Returns the user's home directory. ;  ; static const char * UnixHomedirectory (const char *user=nullptr);  Returns the user's home directory. ;  ; static void UnixIgnoreSignal (ESignals sig, Bool_t ignore);  If ignore is true ignore the specified signal, else restore previous behaviour. ;  ; static int UnixMakedir (const char *name);  Make a Unix file system directory. ;  ; static Long64_t UnixNow ();  Get current time in milliseconds since 0:00 Jan 1 1995. ;  ; static void * UnixOpendir (const char *name);  Open a directory. ;  ; static int UnixRecv (int sock, void *buf, int len, int flag);  Receive exactly length bytes into buffer. ;  ; static void UnixResetSignal (ESignals sig);  Restore old signal handler for specified signal. ;  ; static void UnixResetSignals ();  Restore old signal handlers. ;  ; static int UnixSelect (Int_t nfds, TFdSet *readready, TFdSet *writeready, Long_t timeout);  Wait for events on the file descriptors specified in the readready and writeready masks or for timeout (in milliseconds) to occur. ;  ; static int UnixSend (int sock, const void *buf, int len, int flag);  Send exactly length bytes from buffer. ;  ; static int UnixSetitimer (Long_t ms);  Set interval timer to time-out in ms milliseconds. ;  ; static void UnixSigAlarmInterruptsSyscalls (Bool_t set);  When the argument is true the SIGALRM signal handler is set so that interrupted syscalls will not be restarted by the kernel. ;  ; static void UnixSignal (ESignals sig, SigHandler_t h);  Set a signal handler for a signal. ;  ; static const char * UnixSigname (ESignals sig);  Return the signal name associated with a signal. ;  ; static int UnixTcpConnect (const char *hostname, int port, int tcpwindowsize);  Open a TCP/IP connection to server and connect to a service (i.e. ;  ; static int UnixTcpService (int port, Bool_t reuse, int backlog, int tcpwindowsize);  Open a socket, bind to it and start listening fo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMacOSXSystem.html:34780,timeout,timeout,34780,doc/master/classTMacOSXSystem.html,https://root.cern,https://root.cern/doc/master/classTMacOSXSystem.html,4,['timeout'],['timeout']
Safety," const char* image, TProof* proof, Int_t stype, const char* workdir, const char* msd, Int_t nwk = 1); Create a PROOF slave object. Called via the TProof ctor. void Init(const char* host, Int_t stype); Init a PROOF slave object. Called via the TXSlave ctor.; The Init method is technology specific and is overwritten by derived; classes. void ParseBuffer(); Parse fBuffer after a connection attempt. Int_t SetupServ(Int_t stype, const char* conffile); Init a PROOF slave object. Called via the TXSlave ctor.; The Init method is technology specific and is overwritten by derived; classes. ~TXSlave(); Destroy slave. void Close(Option_t* opt = """"); Close slave socket. Int_t Ping(); Ping the remote master or slave servers.; Returns 0 if ok, -1 if it did not ping or in case of error. void Touch(); Touch the client admin file to proof we are alive. void Interrupt(Int_t type); Send interrupt to master or slave servers.; Returns 0 if ok, -1 in case of error. void StopProcess(Bool_t abort, Int_t timeout); Sent stop/abort request to PROOF server. It will be; processed asynchronously by a separate thread. Int_t GetProofdProtocol(TSocket* s); Find out the remote proofd protocol version.; Returns -1 in case of error. TObjString * SendCoordinator(Int_t kind, const char* msg = 0, Int_t int2 = 0); Send message to intermediate coordinator.; If any output is due, this is returned as a generic message. void SetAlias(const char* alias); Set an alias for this session. If reconnection is supported, the alias; will be communicated to the remote coordinator so that it can be recovered; when reconnecting. Int_t SendGroupPriority(const char* grp, Int_t priority); Communicate to the coordinator the priprity of the group to which the; user belongs; Return 0 on success. Bool_t HandleError(const void* in = 0); Handle error on the input socket. Bool_t HandleInput(const void* in = 0); Handle asynchronous input on the socket. void SetInterruptHandler(Bool_t on = kTRUE); Set/Unset the interrupt handler. voi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TXSlave.html:10665,abort,abort,10665,root/html602/TXSlave.html,https://root.cern,https://root.cern/root/html602/TXSlave.html,6,"['abort', 'timeout']","['abort', 'timeout']"
Safety," const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoScaledShape&operator=(const TGeoScaledShape&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidTGeoBBox::SetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetPoints(Double_t* points) const; virtual voidSetPoi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoScaledShape.html:8485,Safe,SafetyPhi,8485,root/html534/TGeoScaledShape.html,https://root.cern,https://root.cern/root/html534/TGeoScaledShape.html,1,['Safe'],['SafetyPhi']
Safety," const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoPgon&operator=(const TGeoPgon&); virtual voidTGeoShape::Paint(Option_t* option = """"); Double_t&TGeoPcon::Phi1(); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); Double_t&TGeoPcon::Rmax(Int_t ipl); Double_t&TGeoPcon::Rmin(Int_t ipl); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); Double_tSafetyToSegment(const Double_t* point, Int_t ipl, Int_t iphi, Bool_t in, Double_t safphi, Double_t safmin = TGeoShape::Big()) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoPgon.html:9047,safe,safe,9047,root/html602/TGeoPgon.html,https://root.cern,https://root.cern/root/html602/TGeoPgon.html,2,['safe'],['safe']
Safety," const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoShapeAssembly&operator=(const TGeoShapeAssembly&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); voidRecomputeBoxLast(); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidTGeoBBox::SetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetPoints(Double_t* points) const; virtual voidSetPoi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoShapeAssembly.html:8236,Safe,SafetyPhi,8236,root/html602/TGeoShapeAssembly.html,https://root.cern,https://root.cern/root/html602/TGeoShapeAssembly.html,2,['Safe'],['SafetyPhi']
Safety," const char* title, Int_t nbinsx, Double_t xlow, Double_t xup); Normal constructor for fix bin size histograms. Creates the main histogram structure:; name : name of histogram (avoid blanks); title : histogram title; if title is of the form ""stringt;stringx;stringy;stringz""; the histogram title is set to stringt,; the x axis title to stringy, the y axis title to stringy, etc.; nbins : number of bins; xlow : low edge of first bin; xup : upper edge of last bin (not included in last bin). When an histogram is created, it is automatically added to the list; of special objects in the current directory.; To find the pointer to this histogram in the current directory; by its name, do:; TH1F *h1 = (TH1F*)gDirectory->FindObject(name);. TH1(const char* name, const char* title, Int_t nbinsx, const Float_t* xbins); Normal constructor for variable bin size histograms. Creates the main histogram structure:; name : name of histogram (avoid blanks); title : histogram title; if title is of the form ""stringt;stringx;stringy;stringz""; the histogram title is set to stringt,; the x axis title to stringx, the y axis title to stringy, etc.; nbins : number of bins; xbins : array of low-edges for each bin; This is an array of size nbins+1. TH1(const char* name, const char* title, Int_t nbinsx, const Double_t* xbins); Normal constructor for variable bin size histograms. Creates the main histogram structure:; name : name of histogram (avoid blanks); title : histogram title; if title is of the form ""stringt;stringx;stringy;stringz""; the histogram title is set to stringt,; the x axis title to stringx, the y axis title to stringy, etc.; nbins : number of bins; xbins : array of low-edges for each bin; This is an array of size nbins+1. TH1(const TH1& ); Copy constructor.; The list of functions is not copied. (Use Clone if needed). Bool_t AddDirectoryStatus(); static function: cannot be inlined on Windows/NT. void Browse(TBrowser* b); Browe the Histogram object. void Build(); Creates histogram basic",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TH1.html:40947,avoid,avoid,40947,root/html602/TH1.html,https://root.cern,https://root.cern/root/html602/TH1.html,2,['avoid'],['avoid']
Safety," const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; Double_tDaxis(Double_t* pt, Double_t* dir, Double_t t) const; Double_tDDaxis(Double_t* pt, Double_t* dir, Double_t t) const; Double_tDDDaxis(Double_t* pt, Double_t* dir, Double_t t) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoTorus.html:2249,safe,safe,2249,root/html532/TGeoTorus.html,https://root.cern,https://root.cern/root/html532/TGeoTorus.html,1,['safe'],['safe']
Safety," const override;; 141 ; 142 ; 143 inline const Text_t *getUnit() const {; 144 // Return string with unit description; 145 return _unit.Data();; 146 }; 147 inline void setUnit(const char *unit) {; 148 // Set unit description to given string; 149 _unit= unit;; 150 }; 151 TString getTitle(bool appendUnit= false) const;; 152 ; 153 // Lightweight interface adaptors (caller takes ownership); 154 RooFit::OwningPtr<RooAbsFunc> bindVars(const RooArgSet &vars, const RooArgSet* nset=nullptr, bool clipInvalid=false) const;; 155 ; 156 // Create a fundamental-type object that can hold our value.; 157 RooFit::OwningPtr<RooAbsArg> createFundamental(const char* newname=nullptr) const override;; 158 ; 159 // Analytical integration support; 160 virtual Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName=nullptr) const ;; 161 virtual double analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName=nullptr) const ;; 162 virtual Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName=nullptr) const ;; 163 virtual double analyticalIntegral(Int_t code, const char* rangeName=nullptr) const ;; 164 virtual bool forceAnalyticalInt(const RooAbsArg& /*dep*/) const {; 165 // Interface to force RooRealIntegral to offer given observable for internal integration; 166 // even if this is deemed unsafe. This default implementation returns always false; 167 return false ;; 168 }; 169 virtual void forceNumInt(bool flag=true) {; 170 // If flag is true, all advertised analytical integrals will be ignored; 171 // and all integrals are calculated numerically; 172 _forceNumInt = flag ;; 173 }; 174 bool getForceNumInt() const { return _forceNumInt ; }; 175 ; 176 // Chi^2 fits to histograms; 177 virtual RooFit::OwningPtr<RooFitResult> chi2FitTo(RooDataHist& data, const RooCmdArg& arg1={}, const RooCmdArg& arg2={},; 178 const RooCmdArg& arg3={}, const RooCmdArg& arg4={}, const RooCmdArg& a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8h_source.html:7157,unsafe,unsafe,7157,doc/master/RooAbsReal_8h_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html,1,['unsafe'],['unsafe']
Safety," const. overridevirtual . Reimplemented from TGeoBBox. ◆ IsA(). TClass * TGeoXtru::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TGeoBBox.; Definition at line 121 of file TGeoXtru.h. ◆ IsPointInsidePlane(). Bool_t TGeoXtru::IsPointInsidePlane ; (; const Double_t * ; point, . Double_t * ; vert, . Double_t * ; norm . ); const. protected . ◆ MakeBuffer3D(). TBuffer3D * TGeoXtru::MakeBuffer3D ; (; ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ operator=(). TGeoXtru & TGeoXtru::operator= ; (; const TGeoXtru & ; ). protecteddelete . ◆ Safety(). Double_t TGeoXtru::Safety ; (; const Double_t * ; point, . Bool_t ; in = kTRUE . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ Safety_v(). void TGeoXtru::Safety_v ; (; const Double_t * ; points, . const Bool_t * ; inside, . Double_t * ; safe, . Int_t ; vecsize . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ SafetyToSector(). Double_t TGeoXtru::SafetyToSector ; (; const Double_t * ; point, . Int_t ; iz, . Double_t ; safmin, . Bool_t ; in . ). protected . ◆ SavePrimitive(). void TGeoXtru::SavePrimitive ; (; std::ostream & ; out, . Option_t * ; option = """" . ). overridevirtual . Save a primitive as a C++ statement(s) on output stream ""out"". ; Reimplemented from TGeoBBox. ◆ SetCurrentVertices(). void TGeoXtru::SetCurrentVertices ; (; Double_t ; x0, . Double_t ; y0, . Double_t ; scale . ). ◆ SetCurrentZ(). void TGeoXtru::SetCurrentZ ; (; Double_t ; z, . Int_t ; iz . ). ◆ SetDimensions(). void TGeoXtru::SetDimensions ; (; Double_t * ; param). overridevirtual . Reimplemented from TGeoBBox. ◆ SetIz(). void TGeoXtru::SetIz ; (; Int_t ; iz). protected . ◆ SetPoints() [1/2]. void TGeoXtru::SetPoints ; (; Double_t * ; points); const. overridevirtual . Reimplemented from TGeoBBox. ◆ SetPoints() [2/2]. void TGeoXtru::SetPoints ; (; Float_t * ; points); const. overridevirtual . Reimplemented from TGeoBBox. ◆ SetSeg(). void TGeoXtru::SetSeg ; (; Int_t ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoXtru.html:30339,Safe,SafetyToSector,30339,doc/master/classTGeoXtru.html,https://root.cern,https://root.cern/doc/master/classTGeoXtru.html,1,['Safe'],['SafetyToSector']
Safety," const; Create a list of leaf nodes in the arg tree starting with; ourself as top node that match any of the names of the variable list; of the supplied data set (the dependents). The caller of this; function is responsible for deleting the returned argset.; The complement of this function is getObservables(). RooArgSet* getObservables(const RooArgSet* depList, Bool_t valueOnly = kTRUE) const; Create a list of leaf nodes in the arg tree starting with; ourself as top node that match any of the names the args in the; supplied argset. The caller of this function is responsible; for deleting the returned argset. The complement of this function; is getObservables(). RooArgSet* getComponents() const; Return a RooArgSet with all component (branch nodes) of the; expression tree headed by this object. Bool_t checkObservables(const RooArgSet* nset) const; Overloadable function in which derived classes can implement; consistency checks of the variables. If this function returns; true, indicating an error, the fitter or generator will abort. Bool_t recursiveCheckObservables(const RooArgSet* nset) const; Recursively call checkObservables on all nodes in the expression tree. Bool_t dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Test whether we depend on (ie, are served by) any object in the; specified collection. Uses the dependsOn(RooAbsArg&) member function. Bool_t dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Test whether we depend on (ie, are served by) the specified object.; Note that RooAbsArg objects are considered equivalent if they have; the same name. Bool_t overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; Test if any of the nodes of tree are shared with that of the given tree. Bool_t observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Test if any of the dependents of the arg tree (as determined by getObservab",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsArg.html:22675,abort,abort,22675,root/html528/RooAbsArg.html,https://root.cern,https://root.cern/root/html528/RooAbsArg.html,6,['abort'],['abort']
Safety," const; TGeoArb8::InsidePolygonstatic Bool_t InsidePolygon(Double_t x, Double_t y, Double_t *pts); TGeoArb8::DivideTGeoVolume * Divide(TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) override; TGeoArb8::fDzDouble_t fDzDefinition TGeoArb8.h:26; TGeoArb8::operator=TGeoArb8 & operator=(const TGeoArb8 &)=delete; TGeoArb8::GetBoundingCylindervoid GetBoundingCylinder(Double_t *param) const override; TGeoArb8::EGeoArb8TypeEGeoArb8TypeDefinition TGeoArb8.h:19; TGeoArb8::kArb8Trap@ kArb8TrapDefinition TGeoArb8.h:22; TGeoArb8::kArb8Tra@ kArb8TraDefinition TGeoArb8.h:23; TGeoArb8::fTwistDouble_t * fTwistDefinition TGeoArb8.h:27; TGeoArb8::GetAxisRangeDouble_t GetAxisRange(Int_t iaxis, Double_t &xlo, Double_t &xhi) const override; TGeoArb8::GetPlaneNormalstatic void GetPlaneNormal(Double_t *p1, Double_t *p2, Double_t *p3, Double_t *norm); TGeoArb8::CapacityDouble_t Capacity() const override; TGeoArb8::SafetyToFaceDouble_t SafetyToFace(const Double_t *point, Int_t iseg, Bool_t in) const; TGeoArb8::Sizeof3Dvoid Sizeof3D() const override; TGeoArb8::DistFromOutsideDouble_t DistFromOutside(const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override; TGeoArb8::IsTwistedBool_t IsTwisted() constDefinition TGeoArb8.h:80; TGeoArb8::GetVerticesDouble_t * GetVertices()Definition TGeoArb8.h:71; TGeoArb8::Contains_vvoid Contains_v(const Double_t *points, Bool_t *inside, Int_t vecsize) const override; TGeoArb8::InspectShapevoid InspectShape() const override; TGeoArb8::SafetyDouble_t Safety(const Double_t *point, Bool_t in=kTRUE) const override; TGeoArb8::TGeoArb8TGeoArb8(); TGeoArb8::GetTwistDouble_t GetTwist(Int_t iseg) const; TGeoArb8::TGeoArb8TGeoArb8(Double_t dz, Double_t *vertices=nullptr); TGeoArb8::DistFromInsideDouble_t DistFromInside(const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override; TGeoArb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoArb8_8h_source.html:13114,Safe,SafetyToFace,13114,doc/master/TGeoArb8_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoArb8_8h_source.html,2,"['Safe', 'safe']","['SafetyToFace', 'safe']"
Safety," const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. voidAddNode(TStructNode* node, ULong_t size); voidCountMembers(TClass* cl, TStructNode* parent, void* pointer); voidPrepare(); voidReset(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TListfColorsList with properties used to color nodes; TStructViewerGUI*fGUIPointer to GUI class; TObjArrayfLevelArrayArray with pointers to nodes on each level; TExMapfLevelMembersCountContains number of objects on each level; TExMapfLevelSizeContains total size in bytes of a level; void*fPointerMain pointer to represented object; TClass*fPointerClassTClass of a main pointer; TExMapfPointersMap of pointer to avoid circulation; TStructNode*fTopNodeMaster node for fPointer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TStructViewer(void* ptr = NULL, const char* clname = NULL); Default constructor. An argument ""ptr"" is a main pointer of type ""clname"", which should be shown in the viewer. ~TStructViewer(); Destructor. Clean all object after closing the viewer. void AddNode(TStructNode* node, ULong_t size); Find list with nodes on specified level and add node to this list and increment list of sizes and list of members. void CountMembers(TClass* cl, TStructNode* parent, void* pointer); Count allocated memory, increase member counters, find child nodes. void Draw(Option_t* option = """"); Draw object if there is valid pointer. TCanvas* GetCanvas(); Returns canvas used to keep TGeoV",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TStructViewer.html:7232,avoid,avoid,7232,root/html530/TStructViewer.html,https://root.cern,https://root.cern/root/html530/TStructViewer.html,3,['avoid'],['avoid']
Safety," const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTSlave::Touch(); TSlaveLite(const TSlaveLite&); TSlaveLite(const char* ord, Int_t perf, const char* image, TProof* proof, Int_t stype, const char* workdir, const char* msd, Int_t = 1); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTSlave::FlushSocket(); virtual voidTSlave::Interrupt(Int_t type); voidTObject::MakeZombie(); virtual Int_tTSlave::Ping(); virtual TObjString*TSlave::SendCoordinator(Int_t kind, const char* msg = 0, Int_t int2 = 0); virtual Int_tTSlave::SendGroupPriority(const char*, Int_t); virtual voidTSlave::SetAlias(const char* alias); voidTSlave::SetSocket(TSocket* s); virtual voidTSlave::SetStatus(Int_t st); virtual voidTSlave::StopProcess(Bool_t abort, Int_t timeout). private:. voidInit(). Data Members; public:. static TSlave::ESlaveStatusTSlave::kActive; static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TSlave::ESlaveStatusTSlave::kInactive; static TSlave::ESlaveStatusTSlave::kInvalid; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TSlave::ESlaveTypeTSlave::kMaster; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSlaveLite.html:6690,abort,abort,6690,root/html602/TSlaveLite.html,https://root.cern,https://root.cern/root/html602/TSlaveLite.html,4,"['abort', 'timeout']","['abort', 'timeout']"
Safety," const; { return fOtherTypes[12]; }. Bool_t GetUseSuffixes() const; configuration of SQL. { return fUseSuffixes; }. Int_t GetArrayLimit() const; { return fArrayLimit; }. void SkipArrayLimit(); { SetArrayLimit(-1); }. const char* GetTablesType() const; { return fTablesType.Data(); }. Int_t GetUseTransactions() const; { return fUseTransactions; }. Int_t GetUseIndexes() const; { return fUseIndexes; }. Int_t GetQuerisCounter() const; { return fQuerisCounter; }. void DrawMap(const char* = ""*"", Option_t* = """"); {}. void FillBuffer(char*& ); {}. void Flush(); {}. Long64_t GetEND() const; { return 0; }. Int_t GetErrno() const; { return 0; }. void ResetErrno() const; {}. Int_t GetNfree() const; { return 0; }. Int_t GetNbytesInfo() const; {return 0; }. Int_t GetNbytesFree() const; {return 0; }. Long64_t GetSeekFree() const; {return 0; }. Long64_t GetSeekInfo() const; {return 0; }. Long64_t GetSize() const; { return 0; }. void MakeFree(Long64_t , Long64_t ); {}. void MakeProject(const char* , const char* = ""*"", Option_t* = ""new""); {}. void Map(); {}. void Paint(Option_t* = """"); {}. void Print(Option_t* = """") const; {}. Bool_t ReadBuffer(char* , Int_t ); { return kFALSE; }. Bool_t ReadBuffer(char* , Long64_t , Int_t ); { return kFALSE; }. void ReadFree(); {}. Int_t Recover(); { return 0; }. void Seek(Long64_t , TFile::ERelativeTo = kBeg); {}. void SetEND(Long64_t ); {}. Int_t Sizeof() const; { return 0; }. void UseCache(Int_t = 10, Int_t = 0); {}. Bool_t WriteBuffer(const char* , Int_t ); { return kFALSE; }. Int_t Write(const char* = 0, Int_t = 0, Int_t = 0); { return 0; }. Int_t Write(const char* = 0, Int_t = 0, Int_t = 0) const; { return 0; }. void WriteFree(); {}. » Author: Sergey Linev 20/11/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/sql:$Id$ » Last generated: 2015-03-14 16:49; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TSQLFile.html:49690,Recover,Recover,49690,root/html534/TSQLFile.html,https://root.cern,https://root.cern/root/html534/TSQLFile.html,1,['Recover'],['Recover']
Safety," constructor: start a remote session at 'url' accepting callbacks; on local port 'port'; if port is already in use scan up to 'scan - 1'; ports starting from port + 1, i.e. port + 1, ... , port + scan - 1. ~TApplicationRemote(); Destructor. Int_t Broadcast(const TMessage& mess); Broadcast a message to the remote session.; Returns 0 on success, -1 in case of error. Int_t Broadcast(const char* mess, Int_t kind = kMESS_STRING, Int_t type = kRRT_Undef); Broadcast a character string buffer to the remote session.; Use kind to set the TMessage what field.; Returns 0 on success, -1 in case of error. Int_t BroadcastObject(const TObject* obj, Int_t kind = kMESS_OBJECT); Broadcast an object to the remote session.; Use kind to set the TMessage what field.; Returns 0 on success, -1 in case of error. Int_t BroadcastRaw(const void* buffer, Int_t length); Broadcast a raw buffer of specified length to the remote session.; Returns 0 on success, -1 in case of error. Int_t Collect(Long_t timeout = -1); Collect responses from the remote server.; Returns the number of messages received.; If timeout >= 0, wait at most timeout seconds (timeout = -1 by default,; which means wait forever). Int_t CollectInput(); Collect and analyze available input from the socket.; Returns 0 on success, -1 if any failure occurs. void RecvLogFile(Int_t size); Receive the log file from the server. Int_t SendObject(const TObject* obj); Send object to server.; Return 0 on success, -1 in case of error. Bool_t CheckFile(const char* file, Long_t modtime); Check if a file needs to be send to the server. Use the following; algorithm:; - check if file appears in file map; - if yes, get file's modtime and check against time in map,; if modtime not same get md5 and compare against md5 in map,; if not same return kTRUE.; - if no, get file's md5 and modtime and store in file map, ask; slave if file exists with specific md5, if yes return kFALSE,; if no return kTRUE.; Returns kTRUE in case file needs to be send, returns kFA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TApplicationRemote.html:14497,timeout,timeout,14497,root/html526/TApplicationRemote.html,https://root.cern,https://root.cern/root/html526/TApplicationRemote.html,7,['timeout'],['timeout']
Safety," crossing. This should be used instead of the method FindNextBoundary() whenever the tracking is not imposed in association with an external MC transport engine (which provide their own algorithms for boundary crossing).; TGeoNode *TGeoManager::FindNextBoundaryAndStep(Double_t stepmax,; Bool_t comp_safe=kFALSE);; The meaning of the parameters here is the same as for FindNextBoundary, but the safety value is triggered by an input flag. The output is the node after the boundary crossing.; 18.5.7.3 Computing the Safe Radius; Other important navigation query for tracking is the computation of the safe distance. This represents the maximum step that can be made from the current point in any direction that assures that no boundary will be crossed. Knowing this value gives additional freedom to the stepping algorithm to propagate the current track on the corresponding range without checking if the current state has changed. In other words, the modeller insures that the current state does not change in any point within the safety radius around the current point.; The computation of the safe radius is automatically computed any time when the next boundary is queried within a limited step:; TGeoNode *crossed = gGeoManager->FindNextBoundary(pstep);; Double_t safety = gGeoManager->GetSafeDistance();; Otherwise, the computation of safety can always be forced:; Double_t safety = gGeoManager->Safety();; 18.5.7.4 Making a Step; The modeller is able to make steps starting from the current point along the current direction and having the current step length. The new point and its corresponding state will be automatically computed:; TGeoNode *TGeoManager::Step(Bool_t is_geom = kTRUE,; Bool_t cross = kTRUE);; We will explain the method above by its use cases. The input flag is_geom allows specifying if the step is limited by geometrical reasons (a boundary crossing) or is an arbitrary step. The flag cross can be used in case the step is made on a boundary and specifies if user wants to",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:988253,safe,safety,988253,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['safe'],['safety']
Safety," defining interface to a TTree query result with the same interface as for SQL databases ;  CTTreeRowClass defining interface to a row of a TTree query result ;  CTTreeSQLImplement TTree for a SQL backend ;  CTTreeTableInterfaceTTreeTableInterface is used to interface to data that is stored in a TTree ;  CTTreeViewA helper class that encapsulates a file and a tree ;  CTTreeViewerA graphic user interface designed to handle ROOT trees and to take advantage of TTree class features ;  CTTUBEA tube ;  CTTUBSA segment of a tube ;  CTTVLVContainerThis class represent the list view container for the ;  CTTVLVEntryThis class represent entries that goes into the TreeViewer listview container ;  CTTVRecordI/O classes for TreeViewer session handling ;  CTTVSessionI/O classes for TreeViewer session handling ;  CTUDPSocket;  CTUnfoldAn algorithm to unfold distributions from detector to truth level ;  CTUnfoldBinningBinning schemes for use with the unfolding algorithm TUnfoldDensity ;  CTUnfoldBinningXMLXML interfate to binning schemes, for use with the unfolding algorithm TUnfoldDensity ;  CTUnfoldDensityAn algorithm to unfold distributions from detector to truth level ;  CTUnfoldSysAn algorithm to unfold distributions from detector to truth level, with background subtraction and propagation of systematic uncertainties ;  CTUnixSystem;  CTUnuranTUnuran class ;  CTUnuranBaseDistTUnuranBaseDist, base class for Unuran distribution classees such as TUnuranContDist (for one-dimension) or TUnuranMultiContDist (multi-dimension) ;  CTUnuranContDistTUnuranContDist class describing one dimensional continuous distribution ;  CTUnuranDiscrDistTUnuranDiscrDist class for one dimensional discrete distribution ;  CTUnuranEmpDistTUnuranEmpDist class for describing empiral distributions ;  CTUnuranMultiContDistTUnuranMultiContDist class describing multi dimensional continuous distributions ;  CTUnuranSamplerTUnuranSampler class class implementing the ROOT::Math::DistSampler interface using the UNU.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/annotated.html:202617,detect,detector,202617,doc/v610/annotated.html,https://root.cern,https://root.cern/doc/v610/annotated.html,8,['detect'],['detector']
Safety," destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); 487 /// - concurrent usage of _different_ ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); 488 /// - concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; 489 /// - concurrent calls to the interpreter through gInterpreter; 490 /// - concurrent loading of ROOT plug-ins; 491 ///; 492 /// In addition, gDirectory, gFile and gPad become a thread-local variable.; 493 /// In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents.; 494 /// gFile and gPad default to nullptr, as it is for single-thread programs.; 495 ///; 496 /// The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different; 497 /// canvases from different threads (and analogous operations such as invoking `Draw` on a `TObject`) is not thread-safe.; 498 ///; 499 /// Note that there is no `DisableThreadSafety()`. ROOT's thread-safety features cannot be disabled once activated.; 500 // clang-format on; 501 void EnableThreadSafety(); 502 {; 503 static void (*sym)() = (void(*)())Internal::GetSymInLibImt(""ROOT_TThread_Initialize"");; 504 if (sym); 505 sym();; 506 }; 507 ; 508 ////////////////////////////////////////////////////////////////////////////////; 509 /// @param[in] numthreads Number of threads to use. If not specified or; 510 /// set to zero, the number of threads is automatically; 511 /// decided by the implementation. Any other value is; 512 /// used as a hint.; 513 ///; 514 /// ROOT must be built with the compilation flag `imt=ON` for this feature to be available.; 515 /// The following objects and methods automatically take advantage of; 516 /// multi-threading if a call to `EnableImplicitMT` has been made before usage:; 517 ///; 518 ///",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:18033,safe,safe,18033,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,2,['safe'],['safe']
Safety," dictionary parsing is done and these headers cannot be selected anymore. ;  ; static llvm::cl::SubCommand gBareClingSubcommand (""bare-cling"", ""Call directly cling and exit."");  ; static bool GenerateAllDict (TModuleGenerator &modGen, clang::CompilerInstance *compilerInstance, const std::string &currentDirectory);  Generates a PCH from the given ModuleGenerator and CompilerInstance. ;  ; int GenerateFullDict (std::ostream &dictStream, cling::Interpreter &interp, RScanner &scan, const ROOT::TMetaUtils::RConstructorTypes &ctorTypes, bool isSplit, bool isGenreflex, bool isSelXML, bool writeEmptyRootPCM);  ; static std::string GenerateFwdDeclString (const RScanner &scan, const cling::Interpreter &interp);  Generate the fwd declarations of the selected entities. ;  ; void GenerateLinkdef (llvm::cl::list< std::string > &InputFiles, std::string &code_for_parser);  ; void GenerateNecessaryIncludes (std::ostream &dictStream, const std::string &includeForSource, const std::string &extraIncludes);  ; const std::string GenerateStringFromHeadersForClasses (const HeadersDeclsMap_t &headersClassesMap, const std::string &detectedUmbrella, bool payLoadOnly=false);  Generate a string for the dictionary from the headers-classes map. ;  ; int GenReflexMain (int argc, char **argv);  Translate the arguments of genreflex into rootcling ones and forward them to the RootCling function. ;  ; const char * GetExePath ();  Returns the executable path name, used e.g. by SetRootSys(). ;  ; std::pair< std::string, std::string > GetExternalNamespaceAndContainedEntities (const std::string line);  Performance is not critical here. ;  ; size_t GetFullArrayLength (const clang::ConstantArrayType *arrayType);  ; std::string GetFwdDeclnArgsToKeepString (const ROOT::TMetaUtils::TNormalizedCtxt &normCtxt, cling::Interpreter &interp);  ; static llvm::StringRef GetModuleNameFromRdictName (llvm::StringRef rdictName);  ; void GetMostExternalEnclosingClassName (const clang::DeclContext &theContext, std::string &",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rootcling__impl_8cxx.html:10343,detect,detectedUmbrella,10343,doc/master/rootcling__impl_8cxx.html,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx.html,1,['detect'],['detectedUmbrella']
Safety," difficult questions is about the choice of tau.; The method implemented in TUnfold is the L-curve method:; a two-dimensional curve is plotted; x-axis: log10(chisquare); y-axis: log10(regularisation condition); In many cases this curve has an L-shape. The best choice of tau is in the; kink of the L. Within TUnfold a simple version of the L-curve analysis is available.; It tests a given number of points in a predefined tau-range and searches; for the maximum of the curvature in the L-curve (kink position).; if no tau range is given, the range of the scan is determined automatically. A nice overview of the L-curve method is given in:; The L-curve and Its Use in the Numerical Treatment of Inverse Problems; (2000) by P. C. Hansen, in Computational Inverse Problems in; Electrocardiology, ed. P. Johnston,; Advances in Computational Bioengineering; http://www.imm.dtu.dk/~pch/TR/Lcurve.ps. Alternative Regularisation conditions. Regularisation is needed for most unfolding problems, in order to avoid; large oscillations and large correlations on the output bins.; It means that some extra conditions are applied on the output bins. Within TUnfold these conditions are posed on the difference (x-x0), where; x: unfolding output; x0: the bias distribution, by default calculated from; the input matrix A. There is a method SetBias() to change the; bias distribution.; The 3rd argument to DoUnfold() is a scale factor applied to the bias; bias_default[j] = sum_i A[i][j]; x0[j] = scaleBias*bias[j]; The scale factor can be used to; (a) completely suppress the bias by setting it to zero; (b) compensate differences in the normalisation between data; and Monte Carlo. If the regularisation is strong, i.e. large parameter tau,; then the distribution x or its derivatives will look like the bias; distribution. If the parameter tau is small, the distribution x is; independent of the bias. Three basic types of regularisation are implemented in TUnfold. condition regularisation. kRegModeNone none; k",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TUnfold.html:5553,avoid,avoid,5553,root/html534/TUnfold.html,https://root.cern,https://root.cern/root/html534/TUnfold.html,3,['avoid'],['avoid']
Safety," dir, Double_t* norm, Double_t c1, Double_t s1, Double_t c2, Double_t s2); virtual Bool_tTObject::Notify(); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoHype&operator=(const TGeoHype&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; Double_tRadiusHypeSq(Double_t z, Bool_t inner) const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(Double_t* point, Bool_t in = kTRUE) const; static Double_tTGeoShape::SafetyPhi(Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoTube::SafetyS(Double_t* point, Bool_t in, Double_t rmin, Double_t rmax, Double_t dz, Int_t skipz = 0); Double_tSafetyToHype(Double_t* point, Bool_t inner, Bool_t in) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetHypeDimensions(Double_t rin, Double_t stin, Double_t rout, Double_t stout, Double_t dz); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoHype.html:9193,Safe,SafetyPhi,9193,root/html528/TGeoHype.html,https://root.cern,https://root.cern/root/html528/TGeoHype.html,1,['Safe'],['SafetyPhi']
Safety," directions. ;  ; Bool_t Contains (const Double_t *point) const override;  Test if point is inside the scaled shape. ;  ; void Contains_v (const Double_t *points, Bool_t *inside, Int_t vecsize) const override;  Check the inside status for each of the points in the array. ;  ; Int_t DistancetoPrimitive (Int_t px, Int_t py) override;  compute closest distance from point px,py to each vertex. Should not be called. ;  ; Double_t DistFromInside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override;  Compute distance from inside point to surface of the scaled shape. ;  ; void DistFromInside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override;  Compute distance from array of input points having directions specified by dirs. Store output in dists. ;  ; Double_t DistFromOutside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override;  Compute distance from outside point to surface of the scaled shape. ;  ; void DistFromOutside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override;  Compute distance from array of input points having directions specified by dirs. Store output in dists. ;  ; TGeoVolume * Divide (TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) override;  Cannot divide assemblies. ;  ; const TBuffer3D & GetBuffer3D (Int_t reqSections, Bool_t localFrame) const override;  Fills a static 3D buffer and returns a reference. ;  ; TGeoShape * GetMakeRuntimeShape (TGeoShape *mother, TGeoMatrix *mat) const override;  in case shape has some negative parameters, these has to be computed in order to fit the mother ;  ; void GetMeshNumbers (Int_t &nvert, Int_t &nsegs, Int_t &npols) const override;  Returns numbers of vertices, segments and polygons composing the sh",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoScaledShape.html:2306,safe,safe,2306,doc/master/classTGeoScaledShape.html,https://root.cern,https://root.cern/doc/master/classTGeoScaledShape.html,1,['safe'],['safe']
Safety," dirs. Store output in dists. ;  ; TGeoVolume * Divide (TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) override;  Divide the shape along one axis. ;  ; void GetBoundingCylinder (Double_t *) const override;  ; TGeoShape * GetMakeRuntimeShape (TGeoShape *, TGeoMatrix *) const override;  ; void GetMeshNumbers (Int_t &nvert, Int_t &nsegs, Int_t &npols) const override;  Returns numbers of vertices, segments and polygons composing the shape mesh. ;  ; Int_t GetNmeshVertices () const override;  ; virtual Double_t * GetNorm ();  ; virtual Double_t * GetPoint ();  ; void InspectShape () const override;  print shape parameters ;  ; TClass * IsA () const override;  ; Bool_t IsCylType () const override;  ; Double_t Safety (const Double_t *point, Bool_t in=kTRUE) const override;  computes the closest distance from given point to this shape, according to option. ;  ; void Safety_v (const Double_t *points, const Bool_t *inside, Double_t *safe, Int_t vecsize) const override;  Compute safe distance from each of the points in the input array. ;  ; void SavePrimitive (std::ostream &out, Option_t *option="""") override;  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void SetDimensions (Double_t *param) override;  Set half-space parameters as stored in an array. ;  ; void SetPoints (Double_t *) const override;  ; void SetPoints (Float_t *) const override;  ; void Sizeof3D () const override;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TGeoBBox;  TGeoBBox ();  ;  TGeoBBox (const char *name, Double_t dx, Double_t dy, Double_t dz, Double_t *origin=nullptr);  ;  TGeoBBox (Double_t *param);  ;  TGeoBBox (Double_t dx, Double_t dy, Double_t dz, Double_t *origin=nullptr);  ;  ~TGeoBBox () override;  ; Bool_t CouldBeCrossed (const Double_t *point, const Double_t *dir) const override;  ; co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoHalfSpace.html:4062,safe,safe,4062,doc/master/classTGeoHalfSpace.html,https://root.cern,https://root.cern/doc/master/classTGeoHalfSpace.html,2,['safe'],['safe']
Safety," distinct subset of entries, and their partial results are merged before returning the final values to the user. There are no guarantees on the order in which threads will process the batches of entries. In particular, note that this means that, for multi-thread event loops, there is no guarantee on the order in which Snapshot() will write entries: they could be scrambled with respect to the input dataset. The values of the special rdfentry_ column will also not correspond to the entry numbers in the input dataset (e.g. TChain) in multi-thread runs.; WarningBy default, RDataFrame will use as many threads as the hardware supports, using up all the resources on a machine. This might be undesirable on shared computing resources such as a batch cluster. Therefore, when running on shared computing resources, use ROOT::EnableImplicitMT(i); replacing i with the number of CPUs/slots that were allocated for this job. Thread-safety of user-defined expressions; RDataFrame operations such as Histo1D() or Snapshot() are guaranteed to work correctly in multi-thread event loops. User-defined expressions, such as strings or lambdas passed to Filter(), Define(), Foreach(), Reduce() or Aggregate() will have to be thread-safe, i.e. it should be possible to call them concurrently from different threads.; Note that simple Filter() and Define() transformations will inherently satisfy this requirement: Filter() / Define() expressions will often be pure in the functional programming sense (no side-effects, no dependency on external state), which eliminates all risks of race conditions.; In order to facilitate writing of thread-safe operations, some RDataFrame features such as Foreach(), Define() or OnPartialResult() offer thread-aware counterparts (ForeachSlot(), DefineSlot(), OnPartialResultSlot()): their only difference is that they will pass an extra slot argument (an unsigned integer) to the user-defined expression. When calling user-defined code concurrently, RDataFrame guarantees that",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:46281,safe,safety,46281,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,2,['safe'],['safety']
Safety," divisions. For Z division; creates all volumes with different shapes and returns pointer to volume that; was divided. In case a wrong division axis is supplied, returns pointer to; volume that was divided. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; in case shape has some negative parameters, these has to be computed; in order to fit the mother. void InspectShape() const; print shape parameters. TBuffer3D * MakeBuffer3D() const; Creates a TBuffer3D describing *this* shape.; Coordinates are in local reference frame. void SetSegsAndPols(TBuffer3D& buffer) const; Fill TBuffer3D structure for segments and polygons. Double_t Safety(const Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape, according; to option. The matching point on the shape is stored in spoint. Double_t SafetyS(const Double_t* point, Bool_t in, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t phi1, Double_t phi2, Int_t skipz = 0); Static method to compute the closest distance from given point to this shape. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetConsDimensions(Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t phi1, Double_t phi2); Set dimensions of the cone segment. void SetDimensions(Double_t* param); Set dimensions of the cone segment from an array. void SetPoints(Double_t* points) const; Create cone segment mesh points. void SetPoints(Float_t* points) const; Create cone segment mesh points. void GetMeshNumbers(Int_t& nvert, Int_t& nsegs, Int_t& npols) const; Returns numbers of vertices, s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoConeSeg.html:18966,Safe,Safety,18966,root/html534/TGeoConeSeg.html,https://root.cern,https://root.cern/root/html534/TGeoConeSeg.html,3,['Safe'],['Safety']
Safety," do in this case. Bool_t Contains(const Double_t* point) const; Test if point is inside this shape. Bool_t Contains(const Double_t* point, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin); Static method to check if point[3] is located inside a box of having dx, dy, dz; as half-lengths. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the box.; Boundary safe algorithm. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); Compute distance from inside point to surface of the box.; Boundary safe algorithm. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the box.; Boundary safe algorithm. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); Compute distance from outside point to surface of the box.; Boundary safe algorithm. const char * GetAxisName(Int_t iaxis) const; Returns name of axis IAXIS. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. Double_t GetFacetArea(Int_t index = 0) const; Get area in internal units of the facet with a given index.; Possible index values:; 0 - all facets togeather; 1 to 6 - facet index from bottom to top Z. Bool_t GetPointsOnFacet(Int_t index, Int_t npoints, Double_t* array) const; Fills array with n random points located on the surface of indexed facet.; The output array must be provided w",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoBBox.html:16453,safe,safe,16453,root/html534/TGeoBBox.html,https://root.cern,https://root.cern/root/html534/TGeoBBox.html,3,['safe'],['safe']
Safety," double relTol=-1, unsigned int calls=0);  constructor of GSL MCIntegrator. ;  ;  ~GSLMCIntegrator () override;  destructor ;  ; double ChiSqr ();  returns chi-squared per degree of freedom for the estimate of the integral in the Vegas algorithm ;  ; double Error () const override;  return the estimate of the absolute Error of the last Integral calculation ;  ; std::unique_ptr< ROOT::Math::IOptions > ExtraOptions () const;  get the specific options (for Vegas or Miser) in term of string- name. ;  ; MCIntegration::Type GetType () const;  return the type (need to be called GetType to avoid a conflict with typedef) ;  ; const char * GetTypeName () const;  return the name ;  ; double Integral (const double *a, const double *b) override;  evaluate the integral using the previously defined function ;  ; double Integral (const GSLMonteFuncPointer &f, unsigned int dim, double *a, double *b, void *p=nullptr);  evaluate the Integral of a function f over the defined hypercube (a,b) ;  ; int NEval () const override;  return number of function evaluations in calculating the integral (This is an fixed by the user) ;  ; ROOT::Math::IntegratorMultiDimOptions Options () const override;  get the option used for the integration ;  ; double Result () const override;  return the type of the integration used ;  ; void SetAbsTolerance (double absTolerance) override;  set the desired absolute Error ;  ; void SetExtraOptions (const ROOT::Math::IOptions &opt);  Set the extra options for Vegas and Miser. ;  ; void SetFunction (const IMultiGenFunction &f) override;  method to set the a generic integration function ;  ; void SetFunction (GSLMonteFuncPointer f, unsigned int dim, void *p=nullptr);  ; void SetGenerator (GSLRandomEngine &r);  set random number generator ;  ; void SetMode (MCIntegration::Mode mode);  set integration mode for VEGAS method The possible MODE are : MCIntegration::kIMPORTANCE (default) : VEGAS will use importance sampling MCIntegration::kSTRATIFIED : VEGAS will use strat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1GSLMCIntegrator.html:1341,avoid,avoid,1341,doc/master/classROOT_1_1Math_1_1GSLMCIntegrator.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1GSLMCIntegrator.html,1,['avoid'],['avoid']
Safety," double& Aki) const; voidGetRanges(Int_t& minX, Int_t& maxX, Int_t& minY, Int_t& maxY, Int_t& minZ, Int_t& maxZ) const; boolIsExcluded(Int_t bin) const. Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TObjArrayfAjiarray of pointers to predictions of real template distributions; Double_tfChisquareTemplate fit chisquare; TH1*fDatapointer to the ""data"" histogram to be fitted to; vector<Int_t>fExcludedBinsbins excluded from the fit; Bool_tfFitDoneflags whether a valid fit has been performed; Double_t*fFractionstemplate fractions scaled to the ""data"" histogram statistics; Int_tfHighLimitXlast bin in X dimension; Int_tfHighLimitYlast bin in Y dimension; Int_tfHighLimitZlast bin in Z dimension; Double_tfIntegralData""data"" histogram content integral over allowed fit range; Double_t*fIntegralMCssame for template histograms (weights not taken into account); Int_tfLowLimitXfirst bin in X dimension; Int_tfLowLimitYfirst bin in Y dimension; Int_tfLowLimitZfirst bin in Z dimension; TObjArrayfMCsarray of pointers to template histograms; Int_tfNDFNumber of degrees of freedom in the fit; Int_tfNparnumber of fit parameters; Int_tfNpfitsNumber of points used in the fit; TH1*fPlotpointer to histogram containing summed template predictions; TObjArrayfWeightsarray of pointers to corresponding weight factors (may be null). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFractionFitter(); TFractionFitter default constructor. TFractionFitter(TH1* data, TObjArray* MCs, Option_t* option = """"); TFractionFitter constructor. Does a complete initialisation (including; consistency checks, default fit range as the whole histogram but without; under- and overflows, and declaration of the fit parameters). Note that; the hi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TFractionFitter.html:11327,predict,predictions,11327,root/html530/TFractionFitter.html,https://root.cern,https://root.cern/root/html530/TFractionFitter.html,4,['predict'],['predictions']
Safety," double* p) const; doubleROOT::Math::IParametricFunctionOneDim::operator()(const double* x, const double* p) const; ROOT::Math::VavilovAccurateCdf&operator=(const ROOT::Math::VavilovAccurateCdf&); virtual stringParameterName(unsigned int i) const; virtual const double*Parameters() const; virtual voidSetParameters(const double* p); ROOT::Math::VavilovAccurateCdfVavilovAccurateCdf(); ROOT::Math::VavilovAccurateCdfVavilovAccurateCdf(const double* p); ROOT::Math::VavilovAccurateCdfVavilovAccurateCdf(const ROOT::Math::VavilovAccurateCdf&). Data Members; private:. doublefP[5]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; VavilovAccurateCdf(). Default constructor. VavilovAccurateCdf(const double* p). Constructor with parameter values; @param p vector of doubles containing the parameter values (Norm, x0, xi, kappa, beta2). virtual ~VavilovAccurateCdf(). Destructor. const double * Parameters() const. Access the parameter values. void SetParameters(const double* p). Set the parameter values; @param p vector of doubles containing the parameter values (Norm, x0, xi, kappa, beta2). unsigned int NPar() const. Return the number of Parameters. std::string ParameterName(unsigned int i) const. Return the name of the i-th parameter (starting from zero); Overwrite if want to avoid the default name (""Par_0, Par_1, ...""). double DoEval(double x) const. Evaluate the function. @param x The Landau parameter \f$x = \lambda_L\f$. double DoEvalPar(double x, const double* p) const. Evaluate the function, using parameters p. @param x The Landau parameter \f$x = \lambda_L\f$; @param p vector of doubles containing the parameter values (Norm, x0, xi, kappa, beta2). IBaseFunctionOneDim * Clone() const. Return a clone of the object. » Last changed: root/mathmore:$Id$ » Last generated: 2015-06-30 14:27; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__VavilovAccurateCdf.html:3599,avoid,avoid,3599,root/html602/ROOT__Math__VavilovAccurateCdf.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__VavilovAccurateCdf.html,1,['avoid'],['avoid']
Safety," double* p) const; doubleROOT::Math::IParametricFunctionOneDim::operator()(const double* x, const double* p) const; ROOT::Math::VavilovAccurateCdf&operator=(const ROOT::Math::VavilovAccurateCdf&); virtual stringParameterName(unsigned int i) const; virtual const double*Parameters() const; virtual voidSetParameters(const double* p); ROOT::Math::VavilovAccurateCdfVavilovAccurateCdf(); ROOT::Math::VavilovAccurateCdfVavilovAccurateCdf(const double* p); ROOT::Math::VavilovAccurateCdfVavilovAccurateCdf(const ROOT::Math::VavilovAccurateCdf&). Data Members; private:. doublefP[5]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; VavilovAccurateCdf(). Default constructor. VavilovAccurateCdf(const double* p). Constructor with parameter values; @param p vector of doubles containing the parameter values (Norm, x0, xi, kappa, beta2). virtual ~VavilovAccurateCdf(). Destructor. const double * Parameters() const. Access the parameter values. void SetParameters(const double* p). Set the parameter values; @param p vector of doubles containing the parameter values (Norm, x0, xi, kappa, beta2). unsigned int NPar() const. Return the number of Parameters. std::string ParameterName(unsigned int i) const. Return the name of the i-th parameter (starting from zero); Overwrite if want to avoid the default name (""Par_0, Par_1, ...""). double DoEval(double x) const. Evaluate the function. @param x The Landau parameter \f$x = \lambda_L\f$. double DoEvalPar(double x, const double* p) const. Evaluate the function, using parameters p. @param x The Landau parameter \f$x = \lambda_L\f$; @param p vector of doubles containing the parameter values (Norm, x0, xi, kappa, beta2). IBaseFunctionOneDim * Clone() const. Return a clone of the object. » Last changed: root/mathmore:$Id$ » Last generated: 2015-09-08 17:01; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__VavilovAccurateCdf.html:2840,avoid,avoid,2840,root/html534/ROOT__Math__VavilovAccurateCdf.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__VavilovAccurateCdf.html,1,['avoid'],['avoid']
Safety," double* p) const; doubleROOT::Math::IParametricFunctionOneDim::operator()(const double* x, const double* p) const; ROOT::Math::VavilovAccurateCdf&operator=(const ROOT::Math::VavilovAccurateCdf&); virtual stringParameterName(unsigned int i) const; virtual const double*Parameters() const; virtual voidSetParameters(const double* p); ROOT::Math::VavilovAccurateCdfVavilovAccurateCdf(); ROOT::Math::VavilovAccurateCdfVavilovAccurateCdf(const double* p); ROOT::Math::VavilovAccurateCdfVavilovAccurateCdf(const ROOT::Math::VavilovAccurateCdf&). Data Members; private:. doublefP[5]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; VavilovAccurateCdf(). Default constructor. VavilovAccurateCdf(const double* p). Constructor with parameter values; @param p vector of doubles containing the parameter values (Norm, x0, xi, kappa, beta2). virtual ~VavilovAccurateCdf(). Destructor. const double * Parameters() const. Access the parameter values. void SetParameters(const double* p). Set the parameter values; @param p vector of doubles containing the parameter values (Norm, x0, xi, kappa, beta2). unsigned int NPar() const. Return the number of Parameters. std::string ParameterName(unsigned int i) const. Return the name of the i-th parameter (starting from zero); Overwrite if want to avoid the default name (""Par_0, Par_1, ...""). double DoEval(double x) const. Evaluate the function. @param x The Landau parameter \f$x = \lambda_L\f$. double DoEvalPar(double x, const double* p) const. Evaluate the function, using parameters p. @param x The Landau parameter \f$x = \lambda_L\f$; @param p vector of doubles containing the parameter values (Norm, x0, xi, kappa, beta2). IBaseFunctionOneDim * Clone() const. Return a clone of the object. » Last changed: root/mathmore:$Id$ » Last generated: 2015-09-08 17:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/ROOT__Math__VavilovAccurateCdf.html:3599,avoid,avoid,3599,root/html604/ROOT__Math__VavilovAccurateCdf.html,https://root.cern,https://root.cern/root/html604/ROOT__Math__VavilovAccurateCdf.html,1,['avoid'],['avoid']
Safety," drawing. In all these cases AddObject() returns kNone, as it does for successful addition,; simply indicating it does not require you to provide further information about; this object. You should; not try to make any assumptions about what the viewer did with it.; This enables the viewer to be connected to a client which sends potentially; millions of objects, and only accept those that are of interest at a certain; time, caching the relatively small number of CPU/memory costly logical shapes,; and retaining/discarding the physical placements as required. The viewer may; decide to force the client to rebuild (republish) the scene (via; a TPad; repaint; at; present),; and; thus; collect; these; objects if; the; internal viewer state changes. It does this presently by forcing a repaint; on the attached TPad object - hence the reason for putting all publishing to; the viewer in the attached pad objects Paint() method. We will likely remove; this requirement in the future, indicating the rebuild request via a normal; ROOT signal, which the client can detect. Physical IDs; TVirtualViewer3D provides for two methods of object addition:virtual Int_t AddObject(const; TBuffer3D & buffer, Bool_t * addChildren = 0); virtual Int_t AddObject(UInt_t physicalID, const TBuffer3D & buffer, Bool_t * addChildren = 0); If you use the first (simple) case a viewer using logical/physical pairs; SetSectionsValid(TBuffer3D::kBoundingBox);; will generate IDs for each physical object internally. In the second you; can specify; a unique identifier from the client, which allows the viewer to be more; efficient. It can now cache both logical and physical objects, and only discard; physical; objects no longer of interest as part of scene rebuilds. Child Objects; In many geometries there is a rigid containment hierarchy, and so if the viewer; is not interested in a certain object due to limits/size then it will also; not be interest in any of the contained branch of descendents. Both AddObject(); ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TBuffer3D.html:7726,detect,detect,7726,root/html526/TBuffer3D.html,https://root.cern,https://root.cern/root/html526/TBuffer3D.html,7,['detect'],['detect']
Safety," drawing. In all these cases AddObject() returns kNone, as it does for successful addition,; simply indicating it does not require you to provide further information about; this object. You should; not try to make any assumptions about what the viewer did with it.; This enables the viewer to be connected to a client which sends potentially; millions of objects, and only accept those that are of interest at a certain; time, caching the relatively small number of CPU/memory costly logical shapes,; and retaining/discarding the physical placements as required. The viewer may; decide to force the client to rebuild (republish) the scene (via; a TPad; repaint; at; present),; and; thus; collect; these; objects if; the; internal viewer state changes. It does this presently by forcing a repaint; on the attached TPad object - hence the reason for putting all publishing to; the viewer in the attached pad objects Paint() method. We will likely remove; this requirement in the future, indicating the rebuild request via a normal; ROOT signal, which the client can detect. Physical IDs; TVirtualViewer3D provides for two methods of object addition:virtual Int_t AddObject(const; TBuffer3D & buffer, Bool_t * addChildren = 0); virtual Int_t AddObject(UInt_t physicalID, const TBuffer3D & buffer, Bool_t * addChildren = 0); If you use the first (simple) case a viewer using logical/physical pairs; will generate IDs for each physical object internally. In the second you; can specify; a unique identifier from the client, which allows the viewer to be more; efficient. It can now cache both logical and physical objects, and only discard; physical; objects no longer of interest as part of scene rebuilds. Child Objects; In many geometries there is a rigid containment hierarchy, and so if the viewer; is not interested in a certain object due to limits/size then it will also; not be interest in any of the contained branch of descendents. Both AddObject(); methods have an addChildren parameter. The v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualViewer3D.html:9777,detect,detect,9777,root/html528/TVirtualViewer3D.html,https://root.cern,https://root.cern/root/html528/TVirtualViewer3D.html,6,['detect'],['detect']
Safety," dump2(); Debug stuff, should go... RooPlot * plotOn(RooPlot* frame, RooAbsData::PlotOpt o) const; Back end function to plotting functionality. Plot RooDataHist on given; frame in mode specified by plot options 'o'. The main purpose of; this function is to match the specified binning on 'o' to the; internal binning of the plot observable in this RooDataHist. Double_t weight(const RooArgSet& bin, Int_t intOrder = 1, Bool_t correctForBinSize = kFALSE, Bool_t cdfBoundaries = kFALSE); Return the weight at given coordinates with optional; interpolation. If intOrder is zero, the weight; for the bin enclosing the coordinates; contained in 'bin' is returned. For higher values,; the result is interpolated in the real dimensions; of the dataset. void weightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = Poisson) const; Return the error on current weight. Double_t interpolateDim(RooRealVar& dim, const RooAbsBinning* binning, Double_t xval, Int_t intOrder, Bool_t correctForBinSize, Bool_t cdfBoundaries); Perform boundary safe 'intOrder'-th interpolation of weights in dimension 'dim'; at current value 'xval'. void add(const RooArgSet& row, Double_t weight, Double_t sumw2); Increment the weight of the bin enclosing the coordinates given; by 'row' by the specified amount. Add the sum of weights squared; for the bin by 'sumw2' rather than wgt^2. void set(const RooArgSet& row, Double_t weight, Double_t wgtErrLo, Double_t wgtErrHi); Increment the weight of the bin enclosing the coordinates; given by 'row' by the specified amount. Associate errors; [wgtErrLo,wgtErrHi] with the event weight on this bin. void set(Double_t weight, Double_t wgtErr = -1); Increment the weight of the bin enclosing the coordinates; given by 'row' by the specified amount. Associate errors; [wgtErrLo,wgtErrHi] with the event weight on this bin. void set(const RooArgSet& row, Double_t weight, Double_t wgtErr = -1); Increment the weight of the bin enclosing the coordinates; given by 'row' by the s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooDataHist.html:28080,safe,safe,28080,root/html528/RooDataHist.html,https://root.cern,https://root.cern/root/html528/RooDataHist.html,1,['safe'],['safe']
Safety," dump2(); Debug stuff, should go... RooPlot * plotOn(RooPlot* frame, RooAbsData::PlotOpt o) const; Back end function to plotting functionality. Plot RooDataHist on given; frame in mode specified by plot options 'o'. The main purpose of; this function is to match the specified binning on 'o' to the; internal binning of the plot observable in this RooDataHist. Double_t weight(const RooArgSet& bin, Int_t intOrder = 1, Bool_t correctForBinSize = kFALSE, Bool_t cdfBoundaries = kFALSE); Return the weight at given coordinates with optional; interpolation. If intOrder is zero, the weight; for the bin enclosing the coordinates; contained in 'bin' is returned. For higher values,; the result is interpolated in the real dimensions; of the dataset. void weightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = Poisson) const; Return the error on current weight. Double_t interpolateDim(RooRealVar& dim, const RooAbsBinning* binning, Double_t xval, Int_t intOrder, Bool_t correctForBinSize, Bool_t cdfBoundaries); Perform boundary safe 'intOrder'-th interpolation of weights in dimension 'dim'; at current value 'xval'. void add(const RooArgSet& row, Double_t wgt, Double_t sumw2); Increment the weight of the bin enclosing the coordinates given; by 'row' by the specified amount. Add the sum of weights squared; for the bin by 'sumw2' rather than wgt^2. void set(const RooArgSet& row, Double_t weight, Double_t wgtErrLo, Double_t wgtErrHi); Increment the weight of the bin enclosing the coordinates; given by 'row' by the specified amount. Associate errors; [wgtErrLo,wgtErrHi] with the event weight on this bin. void set(Double_t weight, Double_t wgtErr = -1); Increment the weight of the bin enclosing the coordinates; given by 'row' by the specified amount. Associate errors; [wgtErrLo,wgtErrHi] with the event weight on this bin. void set(const RooArgSet& row, Double_t weight, Double_t wgtErr = -1); Increment the weight of the bin enclosing the coordinates; given by 'row' by the spec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooDataHist.html:27273,safe,safe,27273,root/html526/RooDataHist.html,https://root.cern,https://root.cern/root/html526/RooDataHist.html,1,['safe'],['safe']
Safety," each packet; TStatus*fSelStatus! status of query in progress; TSelector*fSelector! the latest selector; TClass*fSelectorClass! class of the latest selector; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; TTimer*fStopTimerTimer associated with a stop request; TMutex*fStopTimerMtxTo protect the stop timer; Long64_tfTotalEventsnumber of events requested; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static THashList*fgDrawInputParsList of input parameters to be kept on drawing actions. private:. TList*fAutoBinsMap of min/max values by name for slaves. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofPlayer(TProof* proof = 0); Default ctor. ~TProofPlayer(); Destructor. void SetProcessing(Bool_t on = kTRUE); Set processing bit according to 'on'. void StopProcess(Bool_t abort, Int_t timeout = -1); Stop the process after this event. If timeout is positive, start; a timer firing after timeout seconds to hard-stop time-expensive; events. void SetDispatchTimer(Bool_t on = kTRUE); Enable/disable the timer to dispatch pening events while processing. void SetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); Enable/disable the timer to stop/abort processing.; The 'timeout' is in seconds. void AddQueryResult(TQueryResult* q); Add query result to the list, making sure that there are no; duplicates. void RemoveQueryResult(const char* ref); Remove all query result instances referenced 'ref' from; the list of results. TQueryResult * GetQueryResult(const char* ref); Get query result instances referenced 'ref' from; the list of results. void SetCurrentQuery(TQueryResult* q); Set current query and save previous value. void AddInput(TObject* inp); Add object to input list. void ClearInput(); Clear input list. TObject * GetOutput(const char* name) const; Get output object by name. TList * GetOutputList() const; Get output list. Int_t ReinitSelector(TQueryResul",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofPlayer.html:15524,timeout,timeout,15524,root/html534/TProofPlayer.html,https://root.cern,https://root.cern/root/html534/TProofPlayer.html,6,['timeout'],['timeout']
Safety," embedding such nodes into geometry. Nodes have visualization attributes as the volume has. When undefined by users, painting a node on a pad will take the corresponding volume attributes.; 18.4.2 Creating and Positioning Volumes; 18.4.2.1 Making Volumes; As mentioned before, volumes are the basic objects used in building the geometrical hierarchy. They represent objects that are not positioned, but store all information about the placement of the other volumes they may contain. Therefore a volume can be replicated several times in the geometry. As it was explained, in order to create a volume, one has to put together a shape and a medium, which are already defined.; Volumes have to be named by users at creation time. Every different name may represent a unique volume object, but may also represent more general a family (class) of volume objects having the same shape type and medium, but possibly different shape parameters. It is the user’s task to provide different names for different volume families in order to avoid ambiguities at tracking time.; A generic family rather than a single volume is created only in two cases: when a parametric shape is used or when a division operation is applied. Each volume in the geometry stores a unique ID corresponding to its family. In order to ease-up their creation, the manager class is providing an API that allows making a shape and a volume in a single step.; 18.4.2.2 Example of Volume Creation; // Making a volume out of a shape and a medium.; TGeoVolume *vol = new TGeoVolume(""VNAME"",ptrShape,ptrMed);. // Making a volume out of a shape but without a defined medium.; TGeoVolume *vol = new TGeoVolume(""VNAME"",ptrShape);. // Making a volume with a given shape in one step; TGeoVolume *vol = gGeoManager->MakeBox(""VNAME"",ptrMed,dx,dy,dz);; TGeoVolume *vol = gGeoManager->MakeTubs(""VNAME"",ptrMed,rmin,rmax,; dz,phi1,phi2);. // See class TGeoManager for the rest of shapes.; // Making a volume with a given shape with a unique prototype; T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:935137,avoid,avoid,935137,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['avoid'],['avoid']
Safety," entries have been accepted and rejected by the filters. See the section on [named filters](#named-filters-and-cutflow-reports) for a more detailed explanation. The method returns a ROOT::RDF::RCutFlowReport instance which can be queried programmatically to get information about the effects of the individual cuts. |; 139| Stats() | Return a TStatistic object filled with the input columns. |; 140| StdDev() | Return the unbiased standard deviation of the processed column values. |; 141| Sum() | Return the sum of the values in the column. If the type of the column is inferred, the return type is `double`, the type of the column otherwise. |; 142| Take() | Extract a column from the dataset as a collection of values, e.g. a `std::vector<float>` for a column of type `float`. |; 143 ; 144| **Instant action** | **Description** |; 145|---------------------|-----------------|; 146| Foreach() | Execute a user-defined function on each entry. Users are responsible for the thread-safety of this callable when executing with implicit multi-threading enabled. |; 147| ForeachSlot() | Same as Foreach(), but the user-defined function must take an extra `unsigned int slot` as its first parameter. `slot` will take a different value, `0` to `nThreads - 1`, for each thread of execution. This is meant as a helper in writing thread-safe Foreach() actions when using RDataFrame after ROOT::EnableImplicitMT(). ForeachSlot() works just as well with single-thread execution: in that case `slot` will always be `0`. |; 148| Snapshot() | Write the processed dataset to disk, in a new TTree and TFile. Custom columns can be saved as well, filtered entries are not saved. Users can specify which columns to save (default is all). Snapshot, by default, overwrites the output file if it already exists. Snapshot() can be made *lazy* setting the appropriate flag in the snapshot options.|; 149 ; 150 ; 151### Queries; 152 ; 153These operations do not modify the dataframe or book computations but simply return info",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RDataFrame_8cxx_source.html:10529,safe,safety,10529,doc/v632/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/RDataFrame_8cxx_source.html,1,['safe'],['safety']
Safety," entries have been accepted and rejected by the filters. See the section on [named filters](#named-filters-and-cutflow-reports) for a more detailed explanation. The method returns a ROOT::RDF::RCutFlowReport instance which can be queried programmatically to get information about the effects of the individual cuts. |; 143| Stats() | Return a TStatistic object filled with the input columns. |; 144| StdDev() | Return the unbiased standard deviation of the processed column values. |; 145| Sum() | Return the sum of the values in the column. If the type of the column is inferred, the return type is `double`, the type of the column otherwise. |; 146| Take() | Extract a column from the dataset as a collection of values, e.g. a `std::vector<float>` for a column of type `float`. |; 147 ; 148| **Instant action** | **Description** |; 149|---------------------|-----------------|; 150| Foreach() | Execute a user-defined function on each entry. Users are responsible for the thread-safety of this callable when executing with implicit multi-threading enabled. |; 151| ForeachSlot() | Same as Foreach(), but the user-defined function must take an extra `unsigned int slot` as its first parameter. `slot` will take a different value, `0` to `nThreads - 1`, for each thread of execution. This is meant as a helper in writing thread-safe Foreach() actions when using RDataFrame after ROOT::EnableImplicitMT(). ForeachSlot() works just as well with single-thread execution: in that case `slot` will always be `0`. |; 152| Snapshot() | Write the processed dataset to disk, in a new TTree and TFile. Custom columns can be saved as well, filtered entries are not saved. Users can specify which columns to save (default is all). Snapshot, by default, overwrites the output file if it already exists. Snapshot() can be made *lazy* setting the appropriate flag in the snapshot options.|; 153 ; 154 ; 155### Queries; 156 ; 157These operations do not modify the dataframe or book computations but simply return info",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDataFrame_8cxx_source.html:10971,safe,safety,10971,doc/master/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html,1,['safe'],['safety']
Safety," entry; in the collection becomes in turn top level branches, etc.; The splitlevel is decreased by 1 everytime a new collection is found.; For example if list is a TObjArray*; - if splitlevel = 1, one top level branch is created for each element; of the TObjArray.; - if splitlevel = 2, one top level branch is created for each array element.; if, in turn, one of the array elements is a TCollection, one top level; branch will be created for each element of this collection. In case a collection element is a TClonesArray, the special Tree constructor; for TClonesArray is called.; The collection itself cannot be a TClonesArray. The function returns the total number of branches created. If name is given, all branch names will be prefixed with name_. IMPORTANT NOTE1: This function should not be called with splitlevel < 1. IMPORTANT NOTE2: The branches created by this function will have names; corresponding to the collection or object names. It is important; to give names to collections to avoid misleading branch names or; identical branch names. By default collections have a name equal to; the corresponding class name, eg the default name for a TList is ""TList"". Example--------------------------------------------------------------:. {; TTree T(""T"",""test list"");; TList *l = new TList();. TObjArray *a1 = new TObjArray();; a1->SetName(""a1"");; l->Add(a1);; TH1F *ha1a = new TH1F(""ha1a"",""ha1"",100,0,1);; TH1F *ha1b = new TH1F(""ha1b"",""ha1"",100,0,1);; a1->Add(ha1a);; a1->Add(ha1b);; TObjArray *b1 = new TObjArray();; b1->SetName(""b1"");; l->Add(b1);; TH1F *hb1a = new TH1F(""hb1a"",""hb1"",100,0,1);; TH1F *hb1b = new TH1F(""hb1b"",""hb1"",100,0,1);; b1->Add(hb1a);; b1->Add(hb1b);. TObjArray *a2 = new TObjArray();; a2->SetName(""a2"");; l->Add(a2);; TH1S *ha2a = new TH1S(""ha2a"",""ha2"",100,0,1);; TH1S *ha2b = new TH1S(""ha2b"",""ha2"",100,0,1);; a2->Add(ha2a);; a2->Add(ha2b);. T.Branch(l,16000,2);; T.Print();; }. Int_t Branch(const char* folder, Int_t bufsize = 32000, Int_t splitlevel = 99); Create one",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTree.html:42710,avoid,avoid,42710,root/html528/TTree.html,https://root.cern,https://root.cern/root/html528/TTree.html,2,['avoid'],['avoid']
Safety," epsilon) ||; 293 (i == j && (*d)(i,i) < 0)) {; 294 //d->Print();; 295 Log() << kWARNING << ""<GetSQRootMatrix> error in matrix diagonalization; printed S and B"" << Endl;; 296 }; 297 }; 298 }; 299 ; 300 // make exactly diagonal; 301 for (i=0; i<n; i++) for (j=0; j<n; j++) if (j != i) (*d)(i,j) = 0;; 302 ; 303 // compute the square-root C' of covariance matrix: C = C'*C'; 304 for (i=0; i<n; i++) (*d)(i,i) = TMath::Sqrt((*d)(i,i));; 305 ; 306 TMatrixD* sqrtMat = new TMatrixD( n, n );; 307 sqrtMat->Mult( (*s), (*d) );; 308 (*sqrtMat) *= (*si);; 309 ; 310 // invert square-root matrices; 311 sqrtMat->Invert();; 312 ; 313 delete eigen;; 314 delete s;; 315 delete si;; 316 delete d;; 317 ; 318 return sqrtMat;; 319}; 320 ; 321////////////////////////////////////////////////////////////////////////////////; 322/// turns covariance into correlation matrix; 323 ; 324const TMatrixD* TMVA::Tools::GetCorrelationMatrix( const TMatrixD* covMat ); 325{; 326 ; 327 if (covMat == 0) return 0;; 328 // sanity check; 329 Int_t nvar = covMat->GetNrows();; 330 if (nvar != covMat->GetNcols()); 331 Log() << kFATAL << ""<GetCorrelationMatrix> input matrix not quadratic"" << Endl;; 332 ; 333 Log() << kWARNING;; 334 TMatrixD* corrMat = new TMatrixD( nvar, nvar );; 335 for (Int_t ivar=0; ivar<nvar; ivar++) {; 336 for (Int_t jvar=0; jvar<nvar; jvar++) {; 337 if (ivar != jvar) {; 338 Double_t d = (*covMat)(ivar, ivar)*(*covMat)(jvar, jvar);; 339 if (d > 1E-20) {; 340 (*corrMat)(ivar, jvar) = (*covMat)(ivar, jvar)/TMath::Sqrt(d);; 341 } else {; 342 Log() << ""<GetCorrelationMatrix> zero variances for variables ""; 343 << ""("" << ivar << "", "" << jvar << "")"" << Endl;; 344 (*corrMat)(ivar, jvar) = 0;; 345 }; 346 if (TMath::Abs( (*corrMat)(ivar,jvar)) > 1){; 347 Log() << kWARNING; 348 << "" Element corr(""<<ivar<<"",""<<ivar<<"")="" << (*corrMat)(ivar,jvar); 349 << "" sigma2=""<<d; 350 << "" cov(""<<ivar<<"",""<<ivar<<"")="" <<(*covMat)(ivar, ivar); 351 << "" cov(""<<jvar<<"",""<<jvar<<"")="" <<(*covMat)(jvar, jvar); 352 << Endl;;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Tools_8cxx_source.html:11190,sanity check,sanity check,11190,doc/master/Tools_8cxx_source.html,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html,1,['sanity check'],['sanity check']
Safety," ex, double eyl, double eyh). add one dim data with error in the coordinate (x) and asymmetric errors in the value (y); in this case store the y errors and not the inverse. void Add(const double* x, double val). add multi-dim coordinate data with only value (no errors). void Add(const double* x, double val, double eval). add multi-dim coordinate data with only error in value. void Add(const double* x, double val, const double* ex, double eval). add multi-dim coordinate data with both error in coordinates and value. void Add(const double* x, double val, const double* ex, double elval, double ehval). add multi-dim coordinate data with both error in coordinates and value. const double * Coords(unsigned int ipoint) const. return a pointer to the coordinates data for the given fit point. double Value(unsigned int ipoint) const. return the value for the given fit point. double Error(unsigned int ipoint) const. return error on the value for the given fit point; Safe (but slower) method returning correctly the error on the value; in case of asymm errors return the average 0.5(eu + el). double InvError(unsigned int ipoint) const. Return the inverse of error on the value for the given fit point; useful when error in the coordinates are not stored and then this is used directly this as the weight in; the least square function. const double * CoordErrors(unsigned int ipoint) const. Return a pointer to the errors in the coordinates for the given fit point. const double * GetPoint(unsigned int ipoint, double& value) const. retrieve at the same time a pointer to the coordinate data and the fit value; More efficient than calling Coords(i) and Value(i). const double * GetPoint(unsigned int ipoint, double& value, double& invError) const. retrieve in a single call a pointer to the coordinate data, value and inverse error for; the given fit point.; To be used only when type is kValueError or kNoError. In the last case the value 1 is returned; for the error. const double * GetPointError",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Fit__BinData.html:9777,Safe,Safe,9777,root/html528/ROOT__Fit__BinData.html,https://root.cern,https://root.cern/root/html528/ROOT__Fit__BinData.html,6,['Safe'],['Safe']
Safety," experimental hall. This generally happens not only for the detector modules, but also for their components. The accurate knowledge of the detector real misalignments can be extremely important for getting close to its designed resolution and the expected tracking efficiency. TGeo offers tools for representing positioning misalignments, applying them to the ideal geometry and performing navigation under these conditions. Detector tracking algorithms can then directly query the geometry for navigation purposes or for retrieving actual misalignment information.; 18.8.1 Physical Nodes; Physical nodes are the actual “touchable” objects in the geometry, representing actually a path of positioned volumes starting with the top node: path=/TOP/A_1/B_4/C_3 , where A, B, C represent names of volumes. The number of physical nodes is given by the total number of possible of branches in the geometry hierarchy. In case of detector geometries and specially for calorimeters this number can be of the order 106-109, therefore it is impossible to create all physical nodes as objects in memory. In TGeo, physical nodes are represented by the class TGeoPhysicalNode and can be created on demand for alignment purposes:; TGeoPhysicalNode(const char* path); The knowledge of the path to the objects that need to be misaligned is essential since there is no other way of identifying them. One can however create “symbolic links” to any complex path to make it more representable for the object it designates:; TGeoPNEntry(const char* unique_name, const char* path); void TGeoPNEntry::SetPhysicalNode(TGeoPhysicalNode *node); Such a symbolic link hides the complexity of the path to the align object and replaces it with a more meaningful name. In addition, TGeoPNEntry objects are faster to search by name and they may optionally store an additional user matrix.; // Creating a symlink object.; TGeoPNEntry *TGeoManager::SetAlignableEntry(const char *unique_n,; const char*path); // Retrieving an existing al",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1014044,detect,detector,1014044,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['detect'],['detector']
Safety," fInfo->SetBit(TStreamerInfo::kBuildRunning);; 247 fInfo->SetBit(TStreamerInfo::kBuildOldUsed);; 248 }; 249 ~TPreventRecursiveBuildGuard() {; 250 fInfo->ResetBit(TStreamerInfo::kBuildOldUsed);; 251 fInfo->ResetBit(TStreamerInfo::kBuildRunning);; 252 }; 253 TStreamerInfo* fInfo;; 254 };; 255 ; 256}; 257 ; 258////////////////////////////////////////////////////////////////////////////////; 259/// Build the I/O data structure for the current class version.; 260///; 261/// A list of TStreamerElement derived classes is built by scanning; 262/// one by one the list of data members of the analyzed class.; 263void TStreamerInfo::Build(Bool_t isTransient); 264{; 265 // Did another thread already do the work?; 266 if (fIsCompiled) return;; 267 ; 268 R__LOCKGUARD(gInterpreterMutex);; 269 ; 270 // Did another thread already do the work while we were waiting ..; 271 if (fIsCompiled) return;; 272 ; 273 // Has Build already been run?; 274 if (fIsBuilt) return;; 275 ; 276 // Are we recursing on ourself?; 277 if (TestBit(TStreamerInfo::kBuildRunning)) return;; 278 ; 279 // This is used to avoid unwanted recursive call to Build or BuildOld.; 280 TPreventRecursiveBuildGuard buildGuard(this);; 281 ; 282 if (fClass->GetCollectionProxy()) {; 283 TVirtualCollectionProxy *proxy = fClass->GetCollectionProxy();; 284 TString title;; 285 if (proxy->GetValueClass()) {; 286 title.Form(""<%s%s> Used to call the proper TStreamerInfo case"",proxy->GetValueClass()->GetName(),proxy->HasPointers() ? ""*"" : """");; 287 } else {; 288 title .Form(""<%s%s> Used to call the proper TStreamerInfo case"",TDataType::GetTypeName(proxy->GetType()),proxy->HasPointers() ? ""*"" : """");; 289 }; 290 TStreamerElement* element = new TStreamerSTL(""This"", title.Data(), 0, fClass->GetName(), *proxy, 0);; 291 fElements->Add(element);; 292 Compile();; 293 fCheckSum = fClass->GetCheckSum();; 294 fIsBuilt = kTRUE;; 295 return;; 296 }; 297 ; 298 // Warn on read/write of RVec (see 6.24 release notes); 299 if (strncmp(GetName(), ""ROOT::V",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:8271,avoid,avoid,8271,doc/master/TStreamerInfo_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html,1,['avoid'],['avoid']
Safety," fNTried = nullptr;; 136 fMTried = nullptr;; 137 fHullPoints = nullptr;; 138 fOrder = nullptr;; 139 fDist = nullptr;; 140 fXN = nullptr;; 141 fYN = nullptr;; 142}; 143 ; 144 ; 145////////////////////////////////////////////////////////////////////////////////; 146/// Return the z value corresponding to the (x,y) point in fGraph2D; 147 ; 148Double_t TGraphDelaunay::ComputeZ(Double_t x, Double_t y); 149{; 150 // Initialise the Delaunay algorithm if needed.; 151 // CreateTrianglesDataStructure computes fXoffset, fYoffset,; 152 // fXScaleFactor and fYScaleFactor;; 153 // needed in this function.; 154 if (!fInit) {; 155 CreateTrianglesDataStructure();; 156 FindHull();; 157 fInit = kTRUE;; 158 }; 159 ; 160 // Find the z value corresponding to the point (x,y).; 161 Double_t xx, yy;; 162 xx = (x+fXoffset)*fXScaleFactor;; 163 yy = (y+fYoffset)*fYScaleFactor;; 164 Double_t zz = Interpolate(xx, yy);; 165 ; 166 // Wrong zeros may appear when points sit on a regular grid.; 167 // The following line try to avoid this problem.; 168 if (zz==0) zz = Interpolate(xx+0.0001, yy);; 169 ; 170 return zz;; 171}; 172 ; 173 ; 174////////////////////////////////////////////////////////////////////////////////; 175/// Function used internally only. It creates the data structures needed to; 176/// compute the Delaunay triangles.; 177 ; 178void TGraphDelaunay::CreateTrianglesDataStructure(); 179{; 180 // Offset fX and fY so they average zero, and scale so the average; 181 // of the X and Y ranges is one. The normalized version of fX and fY used; 182 // in Interpolate.; 183 Double_t xmax = fGraph2D->GetXmax();; 184 Double_t ymax = fGraph2D->GetYmax();; 185 Double_t xmin = fGraph2D->GetXmin();; 186 Double_t ymin = fGraph2D->GetYmin();; 187 fXoffset = -(xmax+xmin)/2.;; 188 fYoffset = -(ymax+ymin)/2.;; 189 fXScaleFactor = 1./(xmax-xmin);; 190 fYScaleFactor = 1./(ymax-ymin);; 191 fXNmax = (xmax+fXoffset)*fXScaleFactor;; 192 fXNmin = (xmin+fXoffset)*fXScaleFactor;; 193 fYNmax = (ymax+fYoffset)*fYScale",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphDelaunay_8cxx_source.html:5238,avoid,avoid,5238,doc/master/TGraphDelaunay_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphDelaunay_8cxx_source.html,1,['avoid'],['avoid']
Safety," faces out of which one is parallel with the XY plane (Z faces). All faces are parallelograms in the general case. The Z faces have 2 edges parallel with the X-axis. TGeoPara class. The shape has the center in the origin and it is defined by:. dX, dY, dZ: half-lengths of the projections of the edges on X, Y and Z. The lower Z face is positioned at -dZ, while the upper at +dZ.; alpha: angle between the segment defined by the centers of the X-parallel edges and Y axis [-90,90] in degrees; theta: theta angle of the segment defined by the centers of the Z faces;; phi: phi angle of the same segment. TGeoPara(dX,dY,dZ,alpha,theta,phi);; A box is a particular parallelepiped having the parameters: (dX,dY,dZ,0.,0.,0.).; 18.3.2.3 Trapezoids; In general, we will call trapezoidal shapes having 8 vertices and up to 6 trapezoid faces. Besides that, two of the opposite faces are parallel to XY plane and are positioned at dZ. Since general trapezoids are seldom used in detector geometry descriptions, there are several primitives implemented in the modeller for particular cases.; Trd1 is a trapezoid with only X varying with Z. It is defined by the half-length in Z, the half-length in X at the lowest and highest Z planes and the half-length in Y:; TGeoTrd1(Double_t dx1,Double_t dx2,Double_t dy,Double_t dz);. TGeoTrd1 class. Trd2 is a trapezoid with both X and Y varying with Z. It is defined by the half-length in Z, the half-length in X at the lowest and highest Z planes and the half-length in Y at these planes:; TGeoTrd2(Double_t dx1,Double_t dx2,Double_t dy1,Double_t dy2, Double_t dz);. TGeoTrd2 class. 18.3.2.4 General Trapezoid - TGeoTrap Class; A general trapezoid is one for which the faces perpendicular to z are trapezes but their centers are not necessary at the same x, y coordinates. TGeoTrap Class. It has eleven parameters: the half length in z, the polar angles from the center of the face at low z to that at high z, H1 the half length in y at low z, LB1 the half length in x at",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:901361,detect,detector,901361,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['detect'],['detector']
Safety," feature of algorithm is the technique for step restriction. For an initial value of parameter \({\vec\theta}^0\) a parallelepiped \(P_0\) is built with the center at \({\vec\theta}^0\) and axes parallel to coordinate axes \(\theta_i\). The lengths of parallelepiped sides along i-th axis is \(2b_i\), where \(b_i\) is such a value that the functions \(f_j(\vec\theta)\) are quasi-linear all over the parallelepiped.; FUMILI takes into account simple linear inequalities in the form:; \[ \theta_i^{min}\le\theta_i\le\theta^{max}_i\]; They form parallelepiped \(P\) (\(P_0\) may be deformed by \(P\)). Very similar step formulae are used in FUMILI for negative logarithm of the likelihood function with the same idea - linearization of function argument.; 5.12 Neural Networks; 5.12.1 Introduction; Neural Networks are used in various fields for data analysis and classification, both for research and commercial institutions. Some randomly chosen examples are image analysis, financial movements’ predictions and analysis, or sales forecast and product shipping optimization. In particles physics neural networks are mainly used for classification tasks (signal over background discrimination). A vast majority of commonly used neural networks are multilayer perceptrons. This implementation of multilayer perceptrons is inspired from the MLPfit package, which remains one of the fastest tools for neural networks studies.; 5.12.2 The MLP; The multilayer perceptron is a simple feed-forward network with the following structure showed on the left. It is made of neurons characterized by a bias and weighted links in between - let’s call those links synapses. The input neurons receive the inputs, normalize them and forward them to the first hidden layer. Each neuron in any subsequent layer first computes a linear combination of the outputs of the previous layer. The output of the neuron is then function of that combination with f being linear for output neurons or a sigmoid for hidden layers.; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:230545,predict,predictions,230545,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['predict'],['predictions']
Safety," fields. The timestamp is a 60-bit value. For UUID version 1, this; is represented by Coordinated Universal Time (UTC/GMT) as; a count of 100-nanosecond intervals since 00:00:00.00,; 15 October 1582 (the date of Gregorian reform to the; Christian calendar). The version number is multiplexed in the 4 most significant; bits of the 'fTimeHiAndVersion' field. There are two defined; versions:; MSB <---; Version 4-Bit Code Description. | 1 0 0 0 1 DCE version, as specified herein.; | 2 0 0 1 0 DCE Security version, with; | embedded POSIX UIDs.; | 3 0 0 1 1 node id is a random value. Clock Sequence. The clock sequence value must be changed whenever:. The UUID generator detects that the local value of UTC; has gone backward; this may be due to re-syncing of the system; clock. While a node is operational, the UUID service always saves; the last UTC used to create a UUID. Each time a new UUID; is created, the current UTC is compared to the saved value; and if either the current value is less or the saved value; was lost, then the clock sequence is incremented modulo; 16,384, thus avoiding production of duplicted UUIDs. The clock sequence must be initialized to a random number; to minimize the correlation across system. This provides; maximum protection against node identifiers that may move; or switch from system to system rapidly. Clock Adjustment. UUIDs may be created at a rate greater than the system clock; resolution. Therefore, the system must also maintain an; adjustment value to be added to the lower-order bits of the; time. Logically, each time the system clock ticks, the; adjustment value is cleared. Every time a UUID is generated,; the current adjustment value is read and incremented, and; then added to the UTC time field of the UUID. Clock Overrun. The 100-nanosecond granularity of time should prove sufficient; even for bursts of UUID production in the next generation of; high-performance multiprocessors. If a system overruns the; clock adjustment by requesting too",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TUUID.html:2406,avoid,avoiding,2406,root/html528/TUUID.html,https://root.cern,https://root.cern/root/html528/TUUID.html,6,['avoid'],['avoiding']
Safety," file TFile.cxx. ◆ ReadFree(). void TFile::ReadFree ; (; ). virtual . Read the FREE linked list. ; Every file has a linked list (fFree) of free segments. This linked list has been written on the file via WriteFree as a single data record. ; Reimplemented in TSQLFile, and TXMLFile.; Definition at line 1925 of file TFile.cxx. ◆ ReadProcessID(). TProcessID * TFile::ReadProcessID ; (; UShort_t ; pidf). virtual . The TProcessID with number pidf is read from this file. ; If the object is not already entered in the gROOT list, it is added. ; Definition at line 1951 of file TFile.cxx. ◆ ReadStreamerInfo(). void TFile::ReadStreamerInfo ; (; ). virtual . Read the list of StreamerInfo from this file. ; The key with name holding the list of TStreamerInfo objects is read. The corresponding TClass objects are updated. Note that this function is not called if the static member fgReadInfo is false. (see TFile::SetReadStreamerInfo) ; Definition at line 3605 of file TFile.cxx. ◆ Recover(). Int_t TFile::Recover ; (; ). virtual . Attempt to recover file if not correctly closed. ; The function returns the number of keys that have been recovered. If no keys can be recovered, the file will be declared Zombie by the calling function. This function is automatically called when opening a file. If the file is open in read only mode, the file is not modified. If open in update mode and the function finds something to recover, a new directory header is written to the file. When opening the file gain no message from Recover will be reported. If keys have been recovered, the file is usable and you can safely read the corresponding objects. If the file is not usable (a zombie), you can test for this case with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {<actions to take if file is unusable>}; If the file has been recovered, the bit kRecovered is set in the TFile object in memory. You can test if the file has been recovered with if (f.TestBit(TFile::kRecovered)) {... the file has been rec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTFile.html:88735,Recover,Recover,88735,doc/v632/classTFile.html,https://root.cern,https://root.cern/doc/v632/classTFile.html,2,['Recover'],['Recover']
Safety," file name finishes with ""("", the file is not closed; if the Postscript or PDF file name finishes with "")"" and the file has been opened with ""("", the file is closed. Example: {; TCanvas c1(""c1"");; h1.Draw();; c1.Print(""c1.ps(""); //write canvas and keep the ps file open; h2.Draw();; c1.Print(""c1.ps""); canvas is added to ""c1.ps""; h3.Draw();; c1.Print(""c1.ps)""); canvas is added to ""c1.ps"" and ps file is closed; }; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; In the previous example replacing ""ps"" by ""pdf"" will create a multi-pages PDF file.; Note that the following sequence writes the canvas to ""c1.ps"" and closes the ps file.: TCanvas c1(""c1"");; h1.Draw();; c1.Print(""c1.ps"");; The TCanvas::Print(""file.ps("") mechanism is very useful, but it can be a little inconvenient to have the action of opening/closing a file being atomic with printing a page. Particularly if pages are being generated in some loop one needs to detect the special cases of first and last page and then munge the argument to Print() accordingly.; The ""["" and ""]"" can be used instead of ""("" and "")"".; Example: c1.Print(""file.ps[""); // No actual print, just open file.ps; for (int i=0; i<10; ++i) {; // fill canvas for context i; // ...; ; c1.Print(""file.ps""); // actually print canvas to file; }// end loop; c1.Print(""file.ps]""); // No actual print, just close.; As before, the same macro is valid for PDF files.; It is possible to print a canvas into an animated GIF file by specifying the file name as ""myfile.gif+"" or ""myfile.gif+NN"", where NN*10ms is delay between the subimages' display. If NN is omitted the delay between subimages is zero. Each picture is added in the animation thanks to a loop similar to the following one: for (int i=0; i<10; ++i) {; // fill canvas for context i; // ...; ; c1.Print(""file.gif+5""); // print canvas to GIF file with 50ms delays; }// end loop; The delay between each frame must be specified in each Print() statement. If ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPad.html:105287,detect,detect,105287,doc/master/classTPad.html,https://root.cern,https://root.cern/doc/master/classTPad.html,1,['detect'],['detect']
Safety," file will not be compressed. . 1 minimal compression level but fast. . ... .... . 9 maximal compression level but slower and might use more memory. . (For the currently supported algorithms, the maximum level is 9) If compress is negative it indicates the compression level is not set yet. The enumeration ROOT::RCompressionSetting::EAlgorithm associates each algorithm with a number. There is a utility function to help to set the value of compress. For example, ROOT::CompressionSettings(ROOT::kLZMA, 1) will build an integer which will set the compression to use the LZMA algorithm and compression level 1. These are defined in the header file Compression.h. Note that the compression settings may be changed at any time. The new compression settings will only apply to branches created or attached after the setting is changed and other objects written after the setting is changed. In case the file does not exist or is not a valid ROOT file, it is made a Zombie. One can detect this situation with a code like: TFile f(""file.root"");; if (f.IsZombie()) {; std::cout << ""Error opening file"" << std::endl;; exit(-1);; }; f#define f(i)Definition RSha256.hxx:104; If you open a file instead with TFile::Open(""file.root"") use rather the following code as a nullptr is returned. TFile* f = TFile::Open(""file.root"");; if (!f) {; std::cout << ""Error opening file"" << std::endl;; exit(-1);; }; TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definition TFile.cxx:4089; When opening the file, the system checks the validity of this directory. If something wrong is detected, an automatic Recovery is performed. In this case, the file is scanned sequentially reading all logical blocks and attempting to rebuild a correct directory (see TFile::Recover). One can disable the automatic recovery procedure when reading one or more files by setting the en",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTFile.html:51431,detect,detect,51431,doc/v632/classTFile.html,https://root.cern,https://root.cern/doc/v632/classTFile.html,2,['detect'],['detect']
Safety," files from other locations which can be configured with AddServerLocation() method or directly via: WebGui.ServerLocations: location1:/file/path/to/location1;location2:/file/path/to/location2 . Definition at line 430 of file RWebWindowsManager.cxx. ◆ CreateWindow(). std::shared_ptr< RWebWindow > RWebWindowsManager::CreateWindow ; (; ). Creates new window To show window, RWebWindow::Show() have to be called. ; Definition at line 619 of file RWebWindowsManager.cxx. ◆ GenerateKey(). std::string RWebWindowsManager::GenerateKey ; (; int ; keylen = 32). staticprivate . Static method to generate cryptographic key Parameter keylen defines length of cryptographic key in bytes Output string will be hex formatted and includes ""-"" separator after every 4 bytes Example for 16 bytes: ""fca45856-41bee066-ff74cc96-9154d405"". ; Definition at line 250 of file RWebWindowsManager.cxx. ◆ GetLaunchTmout(). float ROOT::RWebWindowsManager::GetLaunchTmout ; (; ); const. inlineprivate . Returns timeout for launching new browser process. ; Definition at line 66 of file RWebWindowsManager.hxx. ◆ GetServer(). THttpServer * ROOT::RWebWindowsManager::GetServer ; (; ); const. inline . Returns THttpServer instance. ; Definition at line 89 of file RWebWindowsManager.hxx. ◆ GetServerAddr(). std::string ROOT::RWebWindowsManager::GetServerAddr ; (; ); const. inline . Returns http address of the server, empty string when not available. ; Definition at line 92 of file RWebWindowsManager.hxx. ◆ GetServerLocations(). std::map< std::string, std::string > RWebWindowsManager::GetServerLocations ; (; ). static . Returns server locations as <std::string, std::string> Key is location name (with slash at the end) and value is file path. ; Definition at line 209 of file RWebWindowsManager.cxx. ◆ GetUrl(). std::string RWebWindowsManager::GetUrl ; (; RWebWindow & ; win, . bool ; remote = false, . std::string * ; produced_key = nullptr . ). private . Provide URL address to access specified window from inside or from r",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RWebWindowsManager.html:12981,timeout,timeout,12981,doc/master/classROOT_1_1RWebWindowsManager.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RWebWindowsManager.html,1,['timeout'],['timeout']
Safety," find_library() after integrating with ROOT.; [#15751] - [RF] Using a conditional RooProdPdf in a multi-channel fit spawns too many integrals with new CPU evaluation backend; [#15791] - JS ROOT does not draw tprofile2d correctly with “TEXT” draw option; [#15799] - pyunittests-pyroot-pyz-ttree-setbranchaddress segfaults with Python 3.13; [ROOT-7412] - Strange results looking for nested types; [ROOT-8439] - PyROOT does not treat exceptions properly in overloaded methods; [ROOT-9307] - TPad::GetListOfPrimitives() double deletion error in TList::Clear(). Release 6.32.04; Published on August 14, 2024; Items addressed in this release. [#7223] - [RF] RDataFrame to RooDataSet/RooDataHist conversion; [#7782] - [RF] Allow to set nbins for RooPlot (or disallow); [#9838] - [RF] RooCurve::Average() overestimating average values of standard precision curves on small; [#11565] - [RF] Crash in RooStats::ToyMCSample::GenerateToyData; [#13387] - Please recover SrvAuthenticate from libSrvAuth library; [#14541] - [ROOT-6193] Editor for palette axis cannot set title properties; [#15104] - new PyROOT/cppyy fails to pickle enums; [#15161] - Attribute (getitem) differences for PyROOT objects in ROOT master; [#15234] - cppyy - wrong object type when iterating over a polymorphic container; [#15269] - Iterators in pyROOT working differently in ROOT master compared to 6.30/02; [#15315] - PyROOT Example with inheriting from ROOT.Math.IMultiGenFunction doesn’t work after recent cppyy upgrade; [#15425] - TTreeProcessorMP processes events multiple times when there are more threads than entries; [#15755] - [RF][HS3] Higgs discovery workspaces roundtrip; [#15874] - [Hist] Backwards compatibility broken for THnSparseL in 6.32; [#15887] - Broken plot .C macros for default Name() argument in plotOn(); [#15977] - [gui] Event StatusBar does not work well when TMarker outside of zoom region; [#15986] - Problems with TUri compilation; [#16031] - VecOps binary functions not using the right types; [#16038] - ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/release-notes.html:44565,recover,recover,44565,doc/v632/release-notes.html,https://root.cern,https://root.cern/doc/v632/release-notes.html,1,['recover'],['recover']
Safety," finding any improvement.; ; # Set up the parameters such that the PDF would come out negative. The PDF is now undefined.; a1.setVal(10.0); a2.setVal(-1.0); ; # Perform a fit:; fitWithoutRecovery = pdf.fitTo(; data,; Save=True,; RecoverFromUndefinedRegions=0.0, # This is how RooFit behaved prior to ROOT 6.24; PrintEvalErrors=-1, # We are expecting a lot of evaluation errors. -1 switches off printing.; PrintLevel=-1,; ); ; pdf.plotOn(frame, LineColor=""r"", Name=""noRecovery""); ; ; # RooFit since ROOT 6.24; # --------------------------------; # The minimiser gets information about the ""badness"" of the violation of the function definition. It uses this; # to find its way out of the disallowed parameter regions.; print(""\n\n\n-------------- Starting second fit ---------------\n\n""); ; # Reset the parameters such that the PDF is again undefined.; a1.setVal(10.0); a2.setVal(-1.0); ; # Fit again, but pass recovery information to the minimiser:; fitWithRecovery = pdf.fitTo(; data,; Save=True,; RecoverFromUndefinedRegions=1.0, # The magnitude of the recovery information can be chosen here.; # Higher values mean more aggressive recovery.; PrintEvalErrors=-1, # We are still expecting a few evaluation errors.; PrintLevel=0,; ); ; pdf.plotOn(frame, LineColor=""b"", Name=""recovery""); ; ; # Collect results and plot.; # --------------------------------; # We print the two fit results, and plot the fitted curves.; # The curve of the fit without recovery cannot be plotted, because the PDF is undefined if a2 < 0.; fitWithoutRecovery.Print(); print(; ""Without recovery, the fitter encountered {}"".format(fitWithoutRecovery.numInvalidNLL()); + "" invalid function values. The parameters are unchanged.\n""; ); ; fitWithRecovery.Print(); print(; ""With recovery, the fitter encountered {}"".format(fitWithoutRecovery.numInvalidNLL()); + "" invalid function values, but the parameters are fitted.\n""; ); ; legend = ROOT.TLegend(0.5, 0.7, 0.9, 0.9); legend.SetBorderSize(0); legend.SetFillStyle(0); legend.Ad",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html:3162,Recover,RecoverFromUndefinedRegions,3162,doc/master/rf612__recoverFromInvalidParameters_8py.html,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html,1,['Recover'],['RecoverFromUndefinedRegions']
Safety," finds something to recover,; a new directory header is written to the file. When opening the file gain; no message from Recover will be reported.; If keys have been recovered, the file is usable and you can safely; read the corresponding objects.; If the file is not usable (a zombie), you can test for this case; with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {file is unusable); If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; You can test if the file has been recovered with; if (f.TestBit(TFile::kRecovered)) {.. the file has been recovered}. When writing TTrees to a file, it is important to save the Tree header; at regular intervals (see TTree::AutoSave). If a file containing a Tree; is recovered, the last Tree header written to the file will be used.; In this case all the entries in all the branches written before writing; the header are valid entries. One can disable the automatic recovery procedure by setting; TFile.Recover 0; in the system.rootrc file. Int_t ReOpen(Option_t* mode); Reopen a file with a different access mode, like from READ to; UPDATE or from NEW, CREATE, RECREATE, UPDATE to READ. Thus the; mode argument can be either ""READ"" or ""UPDATE"". The method returns; 0 in case the mode was successfully modified, 1 in case the mode; did not change (was already as requested or wrong input arguments); and -1 in case of failure, in which case the file cannot be used; anymore. The current directory (gFile) is changed to this file. void SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); Set position from where to start reading. void Seek(Long64_t offset, TFile::ERelativeTo pos = kBeg); Seek to a specific position in the file. Pos it either kBeg, kCur or kEnd. void SetCompressionAlgorithm(Int_t algorithm = 0); See comments for function SetCompressionSettings. void SetCompressionLevel(Int_t level = 1); See comments for function SetCompressionSettings. void SetCompressionSettings(Int_t settings = 1); Use",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TFile.html:36587,Recover,Recover,36587,root/html530/TFile.html,https://root.cern,https://root.cern/root/html530/TFile.html,5,['Recover'],['Recover']
Safety," finds something to recover,; a new directory header is written to the file. When opening the file gain; no message from Recover will be reported.; If keys have been recovered, the file is usable and you can safely; read the corresponding objects.; If the file is not usable (a zombie), you can test for this case; with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {file is unusable); If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; You can test if the file has been recovered with; if (f.TestBit(TFile::kRecovered)) {.. the file has been recovered}. When writing TTrees to a file, it is important to save the Tree header; at regular intervals (see TTree::AutoSave). If a file containing a Tree; is recovered, the last Tree header written to the file will be used.; In this case all the entries in all the branches written before writing; the header are valid entries. One can disable the automatic recovery procedure by setting; TFile.Recover 0; in the system.rootrc file. Int_t ReOpen(Option_t* mode); Reopen a file with a different access mode, like from READ to; UPDATE or from NEW, CREATE, RECREATE, UPDATE to READ. Thus the; mode argument can be either ""READ"" or ""UPDATE"". The method returns; 0 in case the mode was successfully modified, 1 in case the mode; did not change (was already as requested or wrong input arguments); and -1 in case of failure, in which case the file cannot be used; anymore. The current directory (gFile) is changed to this file. void SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); Set position from where to start reading. void Seek(Long64_t offset, TFile::ERelativeTo pos = kBeg); Seek to a specific position in the file. Pos it either kBeg, kCur or kEnd. void SetCompressionLevel(Int_t level = 1); Set level of compression for this file:; level = 0 objects written to this file will not be compressed.; level = 1 minimal compression level but fast. level = 9 maximal compression level but slow. Note t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFile.html:35861,Recover,Recover,35861,root/html528/TFile.html,https://root.cern,https://root.cern/root/html528/TFile.html,1,['Recover'],['Recover']
Safety," first time, the class static; variable fgTracks is 0 and the TClonesArray fgTracks is created. ~Event(). Event(); constructors. Event(const TMVA::Event& ). explicit Event(const vector<Float_t>& values, const vector<Float_t>& targetValues, const vector<Float_t>& spectatorValues, UInt_t theClass = 0, Double_t weight = 1.0, Double_t boostweight = 1.0). explicit Event(const vector<Float_t>& , UInt_t theClass, Double_t weight = 1.0, Double_t boostweight = 1.0). Bool_t IsDynamic() const; accessors. {return fDynamic; }. Double_t GetWeight() const; Double_t GetWeight() const { return fWeight*fBoostWeight; }. Double_t GetOriginalWeight() const; { return fWeight; }. Double_t GetBoostWeight() const; { return TMath::Max(Double_t(0.0001),fBoostWeight); }. UInt_t GetClass() const; { return fClass; }. UInt_t GetNVariables() const. UInt_t GetNTargets() const. UInt_t GetNSpectators() const. Float_t GetValue(UInt_t ivar) const. std::vector<Float_t>& GetValues(); For a detailed explanation, please see the heading ""Avoid Duplication in const and Non-const Member Function,"" on p. 23, in Item 3 ""Use const whenever possible,"" in Effective C++, 3d ed by Scott Meyers, ISBN-13: 9780321334879.; http://stackoverflow.com/questions/123758/how-do-i-remove-code-duplication-between-similar-const-and-non-const-member-func. const std::vector<Float_t>& GetValues() const. Float_t GetTarget(UInt_t itgt) const; { return fTargets.at(itgt); }. std::vector<Float_t>& GetTargets(); { return fTargets; }. const std::vector<Float_t>& GetTargets() const; { return fTargets; }. Float_t GetSpectator(UInt_t ivar) const. std::vector<Float_t>& GetSpectators(); { return fSpectators; }. const std::vector<Float_t>& GetSpectators() const; { return fSpectators; }. void SetWeight(Double_t w); { fWeight=w; }. void SetBoostWeight(Double_t w) const; { fDoNotBoost ? fDoNotBoost = kFALSE : fBoostWeight=w; }. void ScaleBoostWeight(Double_t s) const; { fDoNotBoost ? fDoNotBoost = kFALSE : fBoostWeight *= s; }. void SetClass(UInt_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__Event.html:7150,Avoid,Avoid,7150,root/html534/TMVA__Event.html,https://root.cern,https://root.cern/root/html534/TMVA__Event.html,1,['Avoid'],['Avoid']
Safety," fitting an histogram ;  ► fitsio;  FITS_tutorial1.C ;  FITS_tutorial2.C ;  FITS_tutorial3.C ;  FITS_tutorial4.C ;  FITS_tutorial5.C ;  FITS_tutorial6.C ;  FITS_tutorial7.C ;  ► foam;  foam_demo.C Demonstrate the TFoam class ;  foam_demopers.C This simple macro demonstrates persistency of FOAM object ;  foam_kanwa.C This program can be execute from the command line as folows: ;  ► geom;  assembly.CGeometry detector assembly example ;  building.CDrawing a building where Dept ;  cheongwadae.CDrawing the Cheongwadae building which is the Presidential Residence of the Republic of Korea, using ROOT geometry class ;  csgdemo.CCombinatorial Solid Geometry example ;  geo2stp.CExports a geometry in step format ;  geodemo.CGUI to draw the geometry shapes ;  geomAlice.CScript drawing a detector geometry (here ALICE) ;  geomAlice_itsv.CScript drawing a detector geometry (here ITSV from Alice) ;  geomAtlas.CScript drawing a detector geometry (here ATLAS) ;  geomBrahms.CScript drawing a detector geometry (here BRAHMS) ;  geomD0.CScript drawing a detector geometry (here D0) ;  geometry.CExample of the old geometry package (now obsolete) ;  iterplugin.cxx;  lego.CDrawing a figure, made of lego block, using ROOT geometry class ;  mp3player.CDrawing a mp3 type music player, using ROOT geometry class ;  na49.CThis file has been generated automatically via the root utility toroot from an interactive version of GEANT (see ROOT class TGeometry header for an example of use) This shows an example of the old geometry package (now obsolete) ;  na49geomfile.CBefore executing this macro, the file makegeometry.C must have been executed ;  na49view.CThis macro generates with 2 views of the NA49 detector using the old obsolete geometry package ;  parallel_world.CMisaligning geometry generate in many cases overlaps, due to the idealization of the design and the fact that in real life movements of the geometry volumes have constraints and are correlated ;  RadioNuclides.CMacro that demonstrates usa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/files.html:111280,detect,detector,111280,doc/v616/files.html,https://root.cern,https://root.cern/doc/v616/files.html,1,['detect'],['detector']
Safety," float number with negative exponent; [ROOT-8331] - Error in the member function Multiply(const Double_t *vin, Double_t* vout, Double_t w) in TEveTrans of Eve package; [ROOT-8489] - Toy generation using RooCBShape with conditional PDF; [ROOT-8497] - Wrong likelihood is computed for RooProdPdf containing a RooFFTConvPdf; [ROOT-8535] - Non unique UUID; [ROOT-8885] - Cannot create a branch of long, unsigned long, std::size_t types; [ROOT-9062] - $HOME is not automatically extended in TCling; [ROOT-9240] - Compiled program with libNew.so crash; [ROOT-9324] - [cling] segfault when calling cout both from jitted and compiled code; [ROOT-9483] - TMVAGui::mvaeffs crashes when compiled stand-alone; [ROOT-9497] - TCling::Calc() must not abort; [ROOT-9563] - [TreeProcMT] Trees in subdirectories are not supported (and their usage lead to a crash); [ROOT-9583] - TF1::Random; [ROOT-9674] - [DF] Wrong branch type inference in some cases; [ROOT-9731] - [DF] Cannot read columns holding TVector3 pointers; [ROOT-9975] - [DF] Cannot access certain sub-branches; [ROOT-9977] - [DF] SaveGraph produces an empty graph; [ROOT-10023] - [TTreeReader] Unable to read TBranchObject; [ROOT-10152] - [DF] Cannot analyze friend trees in subdirectories with MT; [ROOT-10215] - RDataFrame can’t Snapshot an std::array; [ROOT-10464] - TBB Deprecation Warning; [ROOT-10468] - Crash when users rootlogon contains std::cout in embedded python; [ROOT-10499] - TROOT::ProcessLine(""cout ..."") crashes when called from compiled code; [ROOT-10623] - Functions TF2::Moment2, TF2::CentralMoment2, and similar for TF3 work only for Formula based object; [ROOT-10639] - [DF] Handle errors in opening Snapshot output files; [ROOT-10663] - ROOT dictionary for ATLAS persistent class can’t load correctly; [ROOT-10692] - CMake should use system default C++ standard; [ROOT-10702] - [TTree] Wrong data could be silently written if data-member of object has same name as another branch; [ROOT-10703] - TCling fails to catch compiled exc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v624/release-notes.html:32626,abort,abort,32626,doc/v624/release-notes.html,https://root.cern,https://root.cern/doc/v624/release-notes.html,1,['abort'],['abort']
Safety," for a variable of type long64.](https://docs.microsoft.com/en-us/cpp/c-language/cpp-integer-limits)<br>; 65\anchor floatmax3 (***) 2^24 = 16777216 is the [maximum integer that can be properly represented by a float32 with 23-bit mantissa.](https://stackoverflow.com/a/3793950/7471760)<br>; 66\anchor doublemax3 (****) 2^53 = 9007199254740992 is the [maximum integer that can be properly represented by a double64 with 52-bit mantissa.](https://stackoverflow.com/a/3793950/7471760); 67</sup>; 68*/; 69 ; 70 ; 71////////////////////////////////////////////////////////////////////////////////; 72/// Default constructor.; 73 ; 74TH3::TH3(); 75{; 76 fDimension = 3;; 77 fTsumwy = fTsumwy2 = fTsumwxy = 0;; 78 fTsumwz = fTsumwz2 = fTsumwxz = fTsumwyz = 0;; 79}; 80 ; 81 ; 82////////////////////////////////////////////////////////////////////////////////; 83/// Constructor for fix bin size 3-D histograms.; 84/// Creates the main histogram structure.; 85///; 86/// \param[in] name name of histogram (avoid blanks); 87/// \param[in] title histogram title.; 88/// If title is of the form `stringt;stringx;stringy;stringz`,; 89/// the histogram title is set to `stringt`,; 90/// the x axis title to `stringx`, the y axis title to `stringy`, etc.; 91/// \param[in] nbinsx number of bins along the X axis; 92/// \param[in] xlow low edge of the X axis first bin; 93/// \param[in] xup upper edge of the X axis last bin (not included in last bin); 94/// \param[in] nbinsy number of bins along the Y axis; 95/// \param[in] ylow low edge of the Y axis first bin; 96/// \param[in] yup upper edge of the Y axis last bin (not included in last bin); 97/// \param[in] nbinsz number of bins along the Z axis; 98/// \param[in] zlow low edge of the Z axis first bin; 99/// \param[in] zup upper edge of the Z axis last bin (not included in last bin); 100 ; 101TH3::TH3(const char *name,const char *title,Int_t nbinsx,Double_t xlow,Double_t xup; 102 ,Int_t nbinsy,Double_t ylow,Double_t yup; 103 ,Int_t nbinsz,Double_t zlo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH3_8cxx_source.html:3892,avoid,avoid,3892,doc/master/TH3_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html,1,['avoid'],['avoid']
Safety," force = kFALSE); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTProofPlayer::SetCurrentQuery(TQueryResult* q); virtual voidTProofPlayer::SetDispatchTimer(Bool_t on = kTRUE); virtual voidTProofPlayer::SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTProofPlayer::SetExitStatus(TVirtualProofPlayer::EExitStatus st); virtual voidTProofPlayer::SetInitTime(); virtual voidTProofPlayer::SetMaxDrawQueries(Int_t max); virtual voidTProofPlayer::SetMerging(Bool_t = kTRUE); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTProofPlayer::SetOutputFilePath(const char* fp); voidTProofPlayer::SetProcessing(Bool_t on = kTRUE); virtual voidTProofPlayer::SetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector&); virtual voidTProofPlayer::StopProcess(Bool_t abort, Int_t timeout = -1); virtual voidTProofPlayer::StoreFeedback(TObject* slave, TList* out); virtual voidTProofPlayer::StoreOutput(TList* out); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTProofPlayer::UpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidTProofPlayer::UpdateProgressInfo(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofPlayerLocal.html:11648,abort,abort,11648,root/html534/TProofPlayerLocal.html,https://root.cern,https://root.cern/root/html534/TProofPlayerLocal.html,4,"['abort', 'timeout']","['abort', 'timeout']"
Safety," frame and a container for graphics objects within that frame.Definition RooPlot.h:45; RooPlot::framestatic RooPlot * frame(const RooAbsRealLValue &var, double xmin, double xmax, Int_t nBins)Create a new frame for a given variable in x.Definition RooPlot.cxx:225; RooPlot::GetYaxisTAxis * GetYaxis() constDefinition RooPlot.cxx:1264; RooPlot::Drawvoid Draw(Option_t *options=nullptr) overrideDraw this plot and all of the elements it contains.Definition RooPlot.cxx:637; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TCanvasThe Canvas class.Definition TCanvas.h:23; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf201_compositeDefinition rf201_composite.py:1; ; [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) indirectly selected PDF components: (); [#1] INFO:Plotting -- RooAbsPdf::plotOn",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf201__composite_8C.html:6219,safe,safe,6219,doc/master/rf201__composite_8C.html,https://root.cern,https://root.cern/doc/master/rf201__composite_8C.html,1,['safe'],['safe']
Safety," from TGeoPcon.; Definition at line 118 of file TGeoPgon.h. ◆ IsCrossingSlice(). Bool_t TGeoPgon::IsCrossingSlice ; (; const Double_t * ; point, . const Double_t * ; dir, . Int_t ; iphi, . Double_t ; sstart, . Int_t & ; ipl, . Double_t & ; snext, . Double_t ; stepmax . ); const. protected . ◆ LocatePhi(). void TGeoPgon::LocatePhi ; (; const Double_t * ; point, . Int_t & ; ipsec . ); const. protected . ◆ MakeBuffer3D(). TBuffer3D * TGeoPgon::MakeBuffer3D ; (; ); const. overridevirtual . Reimplemented from TGeoPcon. ◆ operator=(). TGeoPgon & TGeoPgon::operator= ; (; const TGeoPgon & ; ). protecteddelete . ◆ Rpg(). Double_t TGeoPgon::Rpg ; (; Double_t ; z, . Int_t ; ipl, . Bool_t ; inner, . Double_t & ; a, . Double_t & ; b . ); const. protected . ◆ Rproj(). Double_t TGeoPgon::Rproj ; (; Double_t ; z, . const Double_t * ; point, . const Double_t * ; dir, . Double_t ; cphi, . Double_t ; sphi, . Double_t & ; a, . Double_t & ; b . ); const. protected . ◆ Safety(). Double_t TGeoPgon::Safety ; (; const Double_t * ; point, . Bool_t ; in = kTRUE . ); const. overridevirtual . Reimplemented from TGeoPcon. ◆ Safety_v(). void TGeoPgon::Safety_v ; (; const Double_t * ; points, . const Bool_t * ; inside, . Double_t * ; safe, . Int_t ; vecsize . ); const. overridevirtual . Reimplemented from TGeoPcon. ◆ SafetyToSegment(). Double_t TGeoPgon::SafetyToSegment ; (; const Double_t * ; point, . Int_t ; ipl, . Int_t ; iphi, . Bool_t ; in, . Double_t ; safphi, . Double_t ; safmin = TGeoShape::Big() . ); const. ◆ SavePrimitive(). void TGeoPgon::SavePrimitive ; (; std::ostream & ; out, . Option_t * ; option = """" . ). overridevirtual . Save a primitive as a C++ statement(s) on output stream ""out"". ; Reimplemented from TGeoPcon. ◆ SetDimensions(). void TGeoPgon::SetDimensions ; (; Double_t * ; param). overridevirtual . Reimplemented from TGeoPcon. ◆ SetNedges(). void TGeoPgon::SetNedges ; (; Int_t ; ne). inline . Definition at line 108 of file TGeoPgon.h. ◆ SetPoints() [1/2]. void TGeoPgon::SetPo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoPgon.html:32683,Safe,Safety,32683,doc/master/classTGeoPgon.html,https://root.cern,https://root.cern/doc/master/classTGeoPgon.html,1,['Safe'],['Safety']
Safety," from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . #include </home/sftnight/build/workspace/root-makedoc-master/rootspi/rdoc/src/master/tutorials/tree/JetEvent.h>. Inheritance diagram for JetEvent:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ JetEvent(). JetEvent::JetEvent ; (; ). Create a JetEvent object. ; When the constructor is invoked for the first time, the class static variables fgxxx are 0 and the TClonesArray fgxxx are created. ; Definition at line 24 of file JetEvent.cxx. ◆ ~JetEvent(). JetEvent::~JetEvent ; (; ). override . Definition at line 38 of file JetEvent.cxx. Member Function Documentation. ◆ AddHitA(). Hit * JetEvent::AddHitA ; (; ). Add a new hit to the list of hits in detector A. ; Definition at line 124 of file JetEvent.cxx. ◆ AddHitB(). Hit * JetEvent::AddHitB ; (; ). Add a new hit to the list of hits in detector B. ; Definition at line 134 of file JetEvent.cxx. ◆ AddJet(). Jet * JetEvent::AddJet ; (; ). Add a new Jet to the list of tracks for this event. ; Definition at line 102 of file JetEvent.cxx. ◆ AddTrack(). Track * JetEvent::AddTrack ; (; ). Add a new track to the list of tracks for this event. ; Definition at line 113 of file JetEvent.cxx. ◆ Build(). void JetEvent::Build ; (; Int_t ; jetm = 3, . Int_t ; trackm = 10, . Int_t ; hitam = 100, . Int_t ; hitbm = 10 . ). Build one event. ; Definition at line 46 of file JetEvent.cxx. ◆ Clear(). void JetEvent::Clear ; (; Option_t * ; option = """"). overridevirtual . Reimplemented from TObject.; Definition at line 143 of file JetEvent.cxx. ◆ GetJets(). TClonesArray * JetEvent::GetJets ; (; ); const. inline . Definition at line 96 of file JetEvent.h. ◆ GetNhitA(). Int_t JetEvent::GetNhit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classJetEvent.html:11367,detect,detector,11367,doc/master/classJetEvent.html,https://root.cern,https://root.cern/doc/master/classJetEvent.html,1,['detect'],['detector']
Safety," from inside point to outside of this composite shape. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Divide all range of iaxis in range/step cells. void GetMeshNumbers(Int_t& nvert, Int_t& nsegs, Int_t& npols) const; Returns numbers of vertices, segments and polygons composing the shape mesh. void InspectShape() const; print shape parameters. void MakeNode(const char* expression); Make a booleann node according to the top level boolean operation of expression.; Propagates signal to branches until expression is fully decomposed.; printf(""Making node for : %s\n"", expression);. Bool_t PaintComposite(Option_t* option = """") const; Paint this composite shape into the current 3D viewer; Returns bool flag indicating if the caller should continue to; paint child objects. void RegisterYourself(); Register the shape and all components to TGeoManager class. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape, according; to option. The matching point on the shape is stored in spoint. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetPoints(Double_t* points) const; create points for a composite shape. void SetPoints(Float_t* points) const; create points for a composite shape. void Sizeof3D() const; compute size of this 3D object. Int_t GetNmeshVertices() const; Return number of vertices of the mesh representation. TGeoCompositeShape(const TGeoCompositeShape& gcs); { }. TGeoCompositeShape& operator=(const TGeoCompositeShape& gcs). TGeoBoolNode * GetBoolNode() const; {return fNode;}. void GetBoundingCylinder(Double_t* ) const; {;}. TGeoShape * GetMakeRuntimeShape(TGeoShape* , TGeoMatrix* ) const; {return 0;}. Bool_t GetPointsOnSegments(Int_t , Double_t* ) const; {return kFALSE;}. Bool_t IsComposite() const; {return kTRUE;}. Bool_t IsCylType() const; {return kFALSE;}. v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoCompositeShape.html:19335,Safe,Safety,19335,root/html528/TGeoCompositeShape.html,https://root.cern,https://root.cern/root/html528/TGeoCompositeShape.html,3,['Safe'],['Safety']
Safety," from the TH1 object passed as argument; 203 ; 204TGraphErrors::TGraphErrors(const TH1 *h); 205 : TGraph(h); 206{; 207 if (!CtorAllocate()) return;; 208 ; 209 for (Int_t i = 0; i < fNpoints; i++) {; 210 fEX[i] = h->GetBinWidth(i + 1) * gStyle->GetErrorX();; 211 fEY[i] = h->GetBinError(i + 1);; 212 }; 213}; 214 ; 215 ; 216////////////////////////////////////////////////////////////////////////////////; 217/// GraphErrors constructor reading input from `filename`.; 218///; 219/// `filename` is assumed to contain at least 2 columns of numbers; 220///; 221/// Convention for format (default=`""%lg %lg %lg %lg""`); 222///; 223/// - format = `%lg %lg` read only 2 first columns into X,Y; 224/// - format = `%lg %lg %lg` read only 3 first columns into X,Y and EY; 225/// - format = `%lg %lg %lg %lg` read only 4 first columns into X,Y,EX,EY.; 226///; 227/// For files separated by a specific delimiter different from ' ' and `\\t` (e.g. `;` in csv files); 228/// you can avoid using `%*s` to bypass this delimiter by explicitly specify the `option` argument,; 229/// e.g. `option="" \\t,;""` for columns of figures separated by any of these characters (`' ', '\\t', ',', ';'`); 230/// used once (e.g. `""1;1""`) or in a combined way (`"" 1;,;; 1""`).; 231///; 232/// Note in that case, the instantiation is about 2 times slower.; 233/// In case a delimiter is specified, the format `""%lg %lg %lg""` will read X,Y,EX.; 234 ; 235TGraphErrors::TGraphErrors(const char *filename, const char *format, Option_t *option); 236 : TGraph(100); 237{; 238 if (!CtorAllocate()) return;; 239 Double_t x, y, ex, ey;; 240 TString fname = filename;; 241 gSystem->ExpandPathName(fname);; 242 std::ifstream infile(fname.Data());; 243 if (!infile.good()) {; 244 MakeZombie();; 245 Error(""TGraphErrors"", ""Cannot open file: %s, TGraphErrors is Zombie"", filename);; 246 fNpoints = 0;; 247 return;; 248 }; 249 std::string line;; 250 Int_t np = 0;; 251 ; 252 if (strcmp(option, """") == 0) { // No delimiters specified (standard construc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphErrors_8cxx_source.html:7502,avoid,avoid,7502,doc/master/TGraphErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphErrors_8cxx_source.html,1,['avoid'],['avoid']
Safety," full (with prototype) method name and resolve any typedefs in the method signature. ;  ; static Bool_t ConnectToClass (const char *sender_class, const char *signal, TClass *receiver_class, void *receiver, const char *slot);  This method allows to make connection from any object of the same class to the receiver object. ;  ; static Bool_t ConnectToClass (TQObject *sender, const char *signal, TClass *receiver_class, void *receiver, const char *slot);  Create connection between sender and receiver. ;  ;  Protected Attributes inherited from TTimer; TTime fAbsTime;  ; TString fCommand;  ; Bool_t fIntSyscalls;  ; TObject * fObject;  ; Bool_t fSync;  ; TTime fTime;  ; UInt_t fTimeID;  ; Bool_t fTimeout;  ;  Protected Attributes inherited from TQObject; TList * fListOfConnections;  list of signals from this object ;  ; TList * fListOfSignals;  ; Bool_t fSignalsBlocked;  list of connections to this object ;  ;  Static Protected Attributes inherited from TQObject; static Bool_t fgAllSignalsBlocked = kFALSE;  flag used for suppression of signals ;  . Inheritance diagram for ROOT::RBrowserTimer:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RBrowserTimer(). ROOT::RBrowserTimer::RBrowserTimer ; (; Long_t ; milliSec, . Bool_t ; mode, . RBrowser & ; br . ). inline . !< browser processing postponed requests ; constructor ; Definition at line 52 of file RBrowser.cxx. Member Function Documentation. ◆ Timeout(). void ROOT::RBrowserTimer::Timeout ; (; ). inlineoverridevirtual . timeout handler used to process postponed requests in main ROOT thread ; Reimplemented from TTimer.; Definition at line 56 of file RBrowser.cxx. Member Data Documentation. ◆ fBrowser. RBrowser& ROOT::RBrowserTimer::fBrowser. Definition at line 49 of file RBrowser.cxx. gui/browserv7/src/RBrowser.cxx. ROOTRBrowserTimer. ROOT v6-32 - Reference Guide Generated on Fri Nov 1 2024 15:13:36 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RBrowserTimer.html:17607,Timeout,Timeout,17607,doc/v632/classROOT_1_1RBrowserTimer.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RBrowserTimer.html,3,"['Timeout', 'timeout']","['Timeout', 'timeout']"
Safety," function stores the name into a static array. ;  ; Int_t GetMaxIndex (Int_t i) const;  ; TClass * GetNewClass () const;  ; Int_t GetNewType () const;  ; Int_t GetOffset () const;  ; void GetSequenceType (TString &type) const;  Fill type with the string representation of sequence information including 'cached','repeat','write' or 'nodelete'. ;  ; TMemberStreamer * GetStreamer () const;  Return the local streamer object. ;  ; Int_t GetTObjectOffset () const;  ; Int_t GetType () const;  ; const char * GetTypeName () const;  ; const char * GetTypeNameBasic () const;  Return type name of this element in case the type name is not a standard basic type, return the basic type name known to CINT. ;  ; Double_t GetXmax () const;  ; Double_t GetXmin () const;  ; virtual Bool_t IsBase () const;  Return kTRUE if the element represent a base class. ;  ; virtual Bool_t IsOldFormat (const char *newTypeName);  The early 3.00/00 and 3.01/01 versions used to store dm->GetTypeName instead of dm->GetFullTypename if this case is detected, the element type name is modified. ;  ; virtual Bool_t IsTransient () const;  Return kTRUE if the element represent an entity that is not written to the disk (transient members, cache allocator/deallocator, etc.) ;  ; void ls (Option_t *option="""") const override;  Print the content of the element. ;  ; virtual void SetArrayDim (Int_t dim);  Set number of array dimensions. ;  ; virtual void SetMaxIndex (Int_t dim, Int_t max);  set maximum index for array with dimension dim ;  ; virtual void SetNewClass (TClass *cl);  ; virtual void SetNewType (Int_t dtype);  ; virtual void SetOffset (Int_t offset);  ; virtual void SetSize (Int_t dsize);  ; virtual void SetStreamer (TMemberStreamer *streamer);  set pointer to Streamer function for this element ;  ; virtual void SetTObjectOffset (Int_t tobjoffset);  ; virtual void SetType (Int_t dtype);  ; virtual void SetTypeName (const char *name);  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTStreamerLoop.html:3401,detect,detected,3401,doc/master/classTStreamerLoop.html,https://root.cern,https://root.cern/doc/master/classTStreamerLoop.html,1,['detect'],['detected']
Safety," gGeometryLocked;; 4310 gGeometryLocked = new_value;; 4311 return val;; 4312}; 4313 ; 4314TGeoManager::EDefaultUnits TGeoManager::GetDefaultUnits(); 4315{; 4316 return fgDefaultUnits;; 4317}; 4318 ; 4319void TGeoManager::SetDefaultUnits(EDefaultUnits new_value); 4320{; 4321 if (fgDefaultUnits == new_value) {; 4322 gGeometryLocked = true;; 4323 return;; 4324 } else if (gGeometryLocked) {; 4325 ::Fatal(""TGeoManager"", ""The system of units may only be changed once, \n""; 4326 ""BEFORE any elements and materials are created! \n""; 4327 ""Alternatively unlock the default units at own risk."");; 4328 } else if (new_value == kG4Units) {; 4329 ::Info(""TGeoManager"", ""Changing system of units to Geant4 units (mm, ns, MeV)."");; 4330 } else if (new_value == kRootUnits) {; 4331 ::Info(""TGeoManager"", ""Changing system of units to ROOT units (cm, s, GeV)."");; 4332 }; 4333 fgDefaultUnits = new_value;; 4334}; 4335 ; 4336void TGeoManager::SetExportPrecision(UInt_t prec); 4337{; 4338 fgExportPrecision = prec;; 4339}; 4340 ; 4341UInt_t TGeoManager::GetExportPrecision(); 4342{; 4343 return fgExportPrecision;; 4344}; SafeDelete#define SafeDelete(p)Definition RConfig.hxx:525; b#define b(i)Definition RSha256.hxx:100; f#define f(i)Definition RSha256.hxx:104; a#define a(i)Definition RSha256.hxx:99; h#define h(i)Definition RSha256.hxx:106; sizesize_t size(const MatrixT &matrix)retrieve the size of a square matrix; Bool_tbool Bool_tDefinition RtypesCore.h:63; Int_tint Int_tDefinition RtypesCore.h:45; UChar_tunsigned char UChar_tDefinition RtypesCore.h:38; ULong_tunsigned long ULong_tDefinition RtypesCore.h:55; UInt_tunsigned int UInt_tDefinition RtypesCore.h:46; Float_tfloat Float_tDefinition RtypesCore.h:57; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; Double_tdouble Double_tDefinition RtypesCore.h:59; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; Option_tconst char Option_tDefinition RtypesCore.h:66; BIT#define BIT(n)Definition Rtypes.h:90; ClassImp#define ClassImp(name)Definiti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoManager_8cxx_source.html:157940,Safe,SafeDelete,157940,doc/master/TGeoManager_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html,2,['Safe'],['SafeDelete']
Safety," gROOT list, it is added. Int_t Recover(); Attempt to recover file if not correctly closed.; The function returns the number of keys that have been recovered.; If no keys can be recovered, the file will be declared Zombie by; the calling function. This function is automatically called when; opening a file. If the file is open in read only mode, the file is not modified.; If open in update mode and the function finds something to recover,; a new directory header is written to the file. When opening the file gain; no message from Recover will be reported.; If keys have been recovered, the file is usable and you can safely; read the corresponding objects.; If the file is not usable (a zombie), you can test for this case; with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {file is unusable); If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; You can test if the file has been recovered with; if (f.TestBit(TFile::kRecovered)) {.. the file has been recovered}. When writing TTrees to a file, it is important to save the Tree header; at regular intervals (see TTree::AutoSave). If a file containing a Tree; is recovered, the last Tree header written to the file will be used.; In this case all the entries in all the branches written before writing; the header are valid entries. One can disable the automatic recovery procedure by setting; TFile.Recover 0; in the system.rootrc file. Int_t ReOpen(Option_t* mode); Reopen a file with a different access mode, like from READ to; UPDATE or from NEW, CREATE, RECREATE, UPDATE to READ. Thus the; mode argument can be either ""READ"" or ""UPDATE"". The method returns; 0 in case the mode was successfully modified, 1 in case the mode; did not change (was already as requested or wrong input arguments); and -1 in case of failure, in which case the file cannot be used; anymore. The current directory (gFile) is changed to this file. void SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); Set posi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFile.html:35464,recover,recovered,35464,root/html528/TFile.html,https://root.cern,https://root.cern/root/html528/TFile.html,6,['recover'],['recovered']
Safety," geometry (here ALICE). ;  ; file  geomAlice_itsv.C;  Script drawing a detector geometry (here ITSV from Alice). ;  ; file  geomAtlas.C;  Script drawing a detector geometry (here ATLAS). ;  ; file  geomBrahms.C;  Script drawing a detector geometry (here BRAHMS). ;  ; file  geomD0.C;  Script drawing a detector geometry (here D0). ;  ; file  geometry.C;  Example of the old geometry package (now obsolete) ;  ; file  lego.C;  Drawing a figure, made of lego block, using ROOT geometry class. ;  ; file  mp3player.C;  Drawing a mp3 type music player, using ROOT geometry class. ;  ; file  na49.C;  This file has been generated automatically via the root utility toroot from an interactive version of GEANT (see ROOT class TGeometry header for an example of use) This shows an example of the old geometry package (now obsolete) ;  ; file  na49geomfile.C;  Before executing this macro, the file makegeometry.C must have been executed. ;  ; file  na49view.C;  This macro generates with 2 views of the NA49 detector using the old obsolete geometry package. ;  ; file  parallel_world.C;  Misaligning geometry generate in many cases overlaps, due to the idealization of the design and the fact that in real life movements of the geometry volumes have constraints and are correlated. ;  ; file  RadioNuclides.C;  Macro that demonstrates usage of radioactive elements/materials/mixtures with TGeo package. ;  ; file  robot.C;  Drawing a famous Korean robot, TaekwonV, using ROOT geometry class. ;  ; file  rootgeom.C;  Definition of a simple geometry (the 4 ROOT characters) ;  ; file  runplugin.C;  Creates and runs a simple iterator plugin connected to TGeoPainter iterator. ;  ; file  shapes.C;  The old geometry shapes (see script geodemo.C) ;  ; file  shapesAnim.C;  Macro illustrating how to animate a geometry picture using a Timer. ;  ; file  south_gate.C;  Drawing a famous Korean gate, the South gate, called Namdeamoon in Korean, using ROOT geometry class. ;  ; file  station1.C;  Drawing a space sta",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__tutorial__geom.html:1624,detect,detector,1624,doc/master/group__tutorial__geom.html,https://root.cern,https://root.cern/doc/master/group__tutorial__geom.html,1,['detect'],['detector']
Safety," getObservables()."") RooFit const RooAbsArg &testArg const { return observableOverlaps(dset,testArg);  ; const RooAbsArg &testArg const { return observableOverlaps(depList, testArg);  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Static Protected Member Functions inherited from RooAbsReal; static void globalSelectComp (bool flag);  Global switch controlling the activation of the selectComp() functionality. ;  ;  Static Protected Member Functions inherited from RooAbsArg; static void ioStreamerPass2Finalize ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooAddition.h>. Inheritance diagram for RooAddition:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooAddition() [1/4]. RooAddition::RooAddition ; (; ). inline . Definition at line 30 of file RooAddition.h. ◆ RooAddition() [2/4]. RooAddition::RooAddition ; (; const char * ; name, . const char * ; title, . const RooArgList & ; sumSet . ). Constructor with a single set consisting of RooAbsReal. ; Parameters. [in]nameName of the PDF ; [in]titleTitle ; [in]sumSetThe value of the function will be the sum of the values in this set . Definition at line 58 of file RooAddition.cxx. ◆ RooAddition() [3/4]. RooAddition::RooAddition ; (; const char * ; name, . const char * ; title, . const RooArgList & ; sumSet1, . const RooArgList & ; sumSet2 . ). Constructor with two sets of RooAbsReals. ; The ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAddition.html:60083,Avoid,Avoids,60083,doc/master/classRooAddition.html,https://root.cern,https://root.cern/doc/master/classRooAddition.html,1,['Avoid'],['Avoids']
Safety," getObservables()."") RooFit const RooAbsArg &testArg const { return observableOverlaps(dset,testArg);  ; const RooAbsArg &testArg const { return observableOverlaps(depList, testArg);  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Static Protected Member Functions inherited from RooAbsReal; static void globalSelectComp (bool flag);  Global switch controlling the activation of the selectComp() functionality. ;  ;  Static Protected Member Functions inherited from RooAbsArg; static void ioStreamerPass2Finalize ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooCFunction1Binding.h>. Inheritance diagram for RooCFunction1Binding< VO, VI >:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooCFunction1Binding() [1/3]. template<class VO , class VI > . RooCFunction1Binding< VO, VI >::RooCFunction1Binding ; (; ). inline . Definition at line 220 of file RooCFunction1Binding.h. ◆ RooCFunction1Binding() [2/3]. template<class VO , class VI > . RooCFunction1Binding< VO, VI >::RooCFunction1Binding ; (; const char * ; name, . const char * ; title, . VO(*)(VI) ; _func, . RooAbsReal & ; _x . ). Definition at line 257 of file RooCFunction1Binding.h. ◆ RooCFunction1Binding() [3/3]. template<class VO , class VI > . RooCFunction1Binding< VO, VI >::RooCFunction1Binding ; (; const RooCFunction1Binding< VO, VI > & ; other, . const char * ; name = nullptr . ). De",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCFunction1Binding.html:60081,Avoid,Avoids,60081,doc/master/classRooCFunction1Binding.html,https://root.cern,https://root.cern/doc/master/classRooCFunction1Binding.html,1,['Avoid'],['Avoids']
Safety," getObservables()."") RooFit const RooAbsArg &testArg const { return observableOverlaps(dset,testArg);  ; const RooAbsArg &testArg const { return observableOverlaps(depList, testArg);  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Static Protected Member Functions inherited from RooAbsReal; static void globalSelectComp (bool flag);  Global switch controlling the activation of the selectComp() functionality. ;  ;  Static Protected Member Functions inherited from RooAbsArg; static void ioStreamerPass2Finalize ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooCFunction2Binding.h>. Inheritance diagram for RooCFunction2Binding< VO, VI1, VI2 >:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooCFunction2Binding() [1/3]. template<class VO , class VI1 , class VI2 > . RooCFunction2Binding< VO, VI1, VI2 >::RooCFunction2Binding ; (; ). inline . Definition at line 230 of file RooCFunction2Binding.h. ◆ RooCFunction2Binding() [2/3]. template<class VO , class VI1 , class VI2 > . RooCFunction2Binding< VO, VI1, VI2 >::RooCFunction2Binding ; (; const char * ; name, . const char * ; title, . VO(*)(VI1, VI2) ; _func, . RooAbsReal & ; _x, . RooAbsReal & ; _y . ). Definition at line 267 of file RooCFunction2Binding.h. ◆ RooCFunction2Binding() [3/3]. template<class VO , class VI1 , class VI2 > . RooCFunction2Binding< VO, VI1, VI2 >::RooCFunction2Binding ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCFunction2Binding.html:60161,Avoid,Avoids,60161,doc/master/classRooCFunction2Binding.html,https://root.cern,https://root.cern/doc/master/classRooCFunction2Binding.html,1,['Avoid'],['Avoids']
Safety," getObservables()."") RooFit const RooAbsArg &testArg const { return observableOverlaps(dset,testArg);  ; const RooAbsArg &testArg const { return observableOverlaps(depList, testArg);  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Static Protected Member Functions inherited from RooAbsReal; static void globalSelectComp (bool flag);  Global switch controlling the activation of the selectComp() functionality. ;  ;  Static Protected Member Functions inherited from RooAbsArg; static void ioStreamerPass2Finalize ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooCFunction3Binding.h>. Inheritance diagram for RooCFunction3Binding< VO, VI1, VI2, VI3 >:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooCFunction3Binding() [1/3]. template<class VO , class VI1 , class VI2 , class VI3 > . RooCFunction3Binding< VO, VI1, VI2, VI3 >::RooCFunction3Binding ; (; ). inline . Definition at line 240 of file RooCFunction3Binding.h. ◆ RooCFunction3Binding() [2/3]. template<class VO , class VI1 , class VI2 , class VI3 > . RooCFunction3Binding< VO, VI1, VI2, VI3 >::RooCFunction3Binding ; (; const char * ; name, . const char * ; title, . VO(*)(VI1, VI2, VI3) ; _func, . RooAbsReal & ; _x, . RooAbsReal & ; _y, . RooAbsReal & ; _z . ). Definition at line 280 of file RooCFunction3Binding.h. ◆ RooCFunction3Binding() [3/3]. template<class VO , class VI1 , class VI2 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCFunction3Binding.html:60235,Avoid,Avoids,60235,doc/master/classRooCFunction3Binding.html,https://root.cern,https://root.cern/doc/master/classRooCFunction3Binding.html,1,['Avoid'],['Avoids']
Safety," getObservables()."") RooFit const RooAbsArg &testArg const { return observableOverlaps(dset,testArg);  ; const RooAbsArg &testArg const { return observableOverlaps(depList, testArg);  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Static Protected Member Functions inherited from RooAbsReal; static void globalSelectComp (bool flag);  Global switch controlling the activation of the selectComp() functionality. ;  ;  Static Protected Member Functions inherited from RooAbsArg; static void ioStreamerPass2Finalize ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooCFunction4Binding.h>. Inheritance diagram for RooCFunction4Binding< VO, VI1, VI2, VI3, VI4 >:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooCFunction4Binding() [1/3]. template<class VO , class VI1 , class VI2 , class VI3 , class VI4 > . RooCFunction4Binding< VO, VI1, VI2, VI3, VI4 >::RooCFunction4Binding ; (; ). inline . Definition at line 227 of file RooCFunction4Binding.h. ◆ RooCFunction4Binding() [2/3]. template<class VO , class VI1 , class VI2 , class VI3 , class VI4 > . RooCFunction4Binding< VO, VI1, VI2, VI3, VI4 >::RooCFunction4Binding ; (; const char * ; name, . const char * ; title, . VO(*)(VI1, VI2, VI3, VI4) ; _func, . RooAbsReal & ; _x, . RooAbsReal & ; _y, . RooAbsReal & ; _z, . RooAbsReal & ; _w . ). Definition at line 267 of file RooCFunction4Binding.h. ◆ RooCFun",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCFunction4Binding.html:60306,Avoid,Avoids,60306,doc/master/classRooCFunction4Binding.html,https://root.cern,https://root.cern/doc/master/classRooCFunction4Binding.html,1,['Avoid'],['Avoids']
Safety," getObservables()."") RooFit const RooAbsArg &testArg const { return observableOverlaps(dset,testArg);  ; const RooAbsArg &testArg const { return observableOverlaps(depList, testArg);  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Static Protected Member Functions inherited from RooAbsReal; static void globalSelectComp (bool flag);  Global switch controlling the activation of the selectComp() functionality. ;  ;  Static Protected Member Functions inherited from RooAbsArg; static void ioStreamerPass2Finalize ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooChangeTracker.h>. Inheritance diagram for RooChangeTracker:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooChangeTracker() [1/3]. RooChangeTracker::RooChangeTracker ; (; ). default . ◆ RooChangeTracker() [2/3]. RooChangeTracker::RooChangeTracker ; (; const char * ; name, . const char * ; title, . const RooArgSet & ; trackSet, . bool ; checkValues = false . ). Constructor. ; The set trackSet contains the observables to be tracked for changes. If checkValues is true an additional validation step is activated where the numeric values of the tracked arguments are compared with reference values ensuring that values have actually changed. ; Definition at line 52 of file RooChangeTracker.cxx. ◆ RooChangeTracker() [3/3]. RooChangeTracker::RooChangeTracker ; (; const RooChangeTracker & ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooChangeTracker.html:60461,Avoid,Avoids,60461,doc/master/classRooChangeTracker.html,https://root.cern,https://root.cern/doc/master/classRooChangeTracker.html,1,['Avoid'],['Avoids']
Safety," getObservables()."") RooFit const RooAbsArg &testArg const { return observableOverlaps(dset,testArg);  ; const RooAbsArg &testArg const { return observableOverlaps(depList, testArg);  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Static Protected Member Functions inherited from RooAbsReal; static void globalSelectComp (bool flag);  Global switch controlling the activation of the selectComp() functionality. ;  ;  Static Protected Member Functions inherited from RooAbsArg; static void ioStreamerPass2Finalize ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooConstraintSum.h>. Inheritance diagram for RooConstraintSum:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooConstraintSum() [1/3]. RooConstraintSum::RooConstraintSum ; (; ). inline . Definition at line 30 of file RooConstraintSum.h. ◆ RooConstraintSum() [2/3]. RooConstraintSum::RooConstraintSum ; (; const char * ; name, . const char * ; title, . const RooArgSet & ; constraintSet, . const RooArgSet & ; paramSet, . bool ; takeGlobalObservablesFromData = false . ). Constructor with set of constraint p.d.f.s. All elements in constraintSet must inherit from RooAbsPdf. ; Definition at line 46 of file RooConstraintSum.cxx. ◆ RooConstraintSum() [3/3]. RooConstraintSum::RooConstraintSum ; (; const RooConstraintSum & ; other, . const char * ; name = nullptr . ). Copy constructor. ; Definit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooConstraintSum.html:60375,Avoid,Avoids,60375,doc/master/classRooConstraintSum.html,https://root.cern,https://root.cern/doc/master/classRooConstraintSum.html,1,['Avoid'],['Avoids']
Safety," getObservables()."") RooFit const RooAbsArg &testArg const { return observableOverlaps(dset,testArg);  ; const RooAbsArg &testArg const { return observableOverlaps(depList, testArg);  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Static Protected Member Functions inherited from RooAbsReal; static void globalSelectComp (bool flag);  Global switch controlling the activation of the selectComp() functionality. ;  ;  Static Protected Member Functions inherited from RooAbsArg; static void ioStreamerPass2Finalize ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooDerivative.h>. Inheritance diagram for RooDerivative:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooDerivative() [1/4]. RooDerivative::RooDerivative ; (; ). default . Default constructor. . ◆ RooDerivative() [2/4]. RooDerivative::RooDerivative ; (; const char * ; name, . const char * ; title, . RooAbsReal & ; func, . RooRealVar & ; x, . Int_t ; order = 1, . double ; eps = 0.001 . ). Definition at line 53 of file RooDerivative.cxx. ◆ RooDerivative() [3/4]. RooDerivative::RooDerivative ; (; const char * ; name, . const char * ; title, . RooAbsReal & ; func, . RooRealVar & ; x, . const RooArgSet & ; nset, . Int_t ; order = 1, . double ; eps = 0.001 . ). Definition at line 68 of file RooDerivative.cxx. ◆ ~RooDerivative(). RooDerivative::~RooDerivative ; (; ). overridedefault . ◆ Ro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooDerivative.html:60027,Avoid,Avoids,60027,doc/master/classRooDerivative.html,https://root.cern,https://root.cern/doc/master/classRooDerivative.html,1,['Avoid'],['Avoids']
Safety," getObservables()."") RooFit const RooAbsArg &testArg const { return observableOverlaps(dset,testArg);  ; const RooAbsArg &testArg const { return observableOverlaps(depList, testArg);  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Static Protected Member Functions inherited from RooAbsReal; static void globalSelectComp (bool flag);  Global switch controlling the activation of the selectComp() functionality. ;  ;  Static Protected Member Functions inherited from RooAbsArg; static void ioStreamerPass2Finalize ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooErrorVar.h>. Inheritance diagram for RooErrorVar:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooErrorVar() [1/3]. RooErrorVar::RooErrorVar ; (; ). inline . Default constructor. ; Definition at line 32 of file RooErrorVar.h. ◆ RooErrorVar() [2/3]. RooErrorVar::RooErrorVar ; (; const char * ; name, . const char * ; title, . const RooRealVar & ; input . ). Construct an lvalue variable representing the error of RooRealVar input. ; Definition at line 44 of file RooErrorVar.cxx. ◆ RooErrorVar() [3/3]. RooErrorVar::RooErrorVar ; (; const RooErrorVar & ; other, . const char * ; name = nullptr . ). Definition at line 55 of file RooErrorVar.cxx. ◆ ~RooErrorVar(). RooErrorVar::~RooErrorVar ; (; ). overridedefault . Member Function Documentation. ◆ Class(). static TClass * RooErrorVar::Cla",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooErrorVar.html:69423,Avoid,Avoids,69423,doc/master/classRooErrorVar.html,https://root.cern,https://root.cern/doc/master/classRooErrorVar.html,1,['Avoid'],['Avoids']
Safety," getObservables()."") RooFit const RooAbsArg &testArg const { return observableOverlaps(dset,testArg);  ; const RooAbsArg &testArg const { return observableOverlaps(depList, testArg);  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Static Protected Member Functions inherited from RooAbsReal; static void globalSelectComp (bool flag);  Global switch controlling the activation of the selectComp() functionality. ;  ;  Static Protected Member Functions inherited from RooAbsArg; static void ioStreamerPass2Finalize ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooExtendedBinding.h>. Inheritance diagram for RooExtendedBinding:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooExtendedBinding() [1/3]. RooExtendedBinding::RooExtendedBinding ; (; ). inline . Definition at line 22 of file RooExtendedBinding.h. ◆ RooExtendedBinding() [2/3]. RooExtendedBinding::RooExtendedBinding ; (; const char * ; name, . const char * ; title, . RooAbsPdf & ; _pdf . ). Definition at line 20 of file RooExtendedBinding.cxx. ◆ RooExtendedBinding() [3/3]. RooExtendedBinding::RooExtendedBinding ; (; const RooExtendedBinding & ; other, . const char * ; name = nullptr . ). Definition at line 27 of file RooExtendedBinding.cxx. Member Function Documentation. ◆ Class(). static TClass * RooExtendedBinding::Class ; (; ). static . ReturnsTClass describing this class . ◆ Clas",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooExtendedBinding.html:59383,Avoid,Avoids,59383,doc/master/classRooExtendedBinding.html,https://root.cern,https://root.cern/doc/master/classRooExtendedBinding.html,1,['Avoid'],['Avoids']
Safety," getObservables()."") RooFit const RooAbsArg &testArg const { return observableOverlaps(dset,testArg);  ; const RooAbsArg &testArg const { return observableOverlaps(depList, testArg);  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Static Protected Member Functions inherited from RooAbsReal; static void globalSelectComp (bool flag);  Global switch controlling the activation of the selectComp() functionality. ;  ;  Static Protected Member Functions inherited from RooAbsArg; static void ioStreamerPass2Finalize ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooFirstMoment.h>. Inheritance diagram for RooFirstMoment:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooFirstMoment() [1/4]. RooFirstMoment::RooFirstMoment ; (; ). default . ◆ RooFirstMoment() [2/4]. RooFirstMoment::RooFirstMoment ; (; const char * ; name, . const char * ; title, . RooAbsReal & ; func, . RooRealVar & ; x . ). Definition at line 43 of file RooFirstMoment.cxx. ◆ RooFirstMoment() [3/4]. RooFirstMoment::RooFirstMoment ; (; const char * ; name, . const char * ; title, . RooAbsReal & ; func, . RooRealVar & ; x, . const RooArgSet & ; nset, . bool ; intNSet = false . ). Definition at line 75 of file RooFirstMoment.cxx. ◆ RooFirstMoment() [4/4]. RooFirstMoment::RooFirstMoment ; (; const RooFirstMoment & ; other, . const char * ; name = nullptr . ). Definition at line 118 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFirstMoment.html:60624,Avoid,Avoids,60624,doc/master/classRooFirstMoment.html,https://root.cern,https://root.cern/doc/master/classRooFirstMoment.html,1,['Avoid'],['Avoids']
Safety," getObservables()."") RooFit const RooAbsArg &testArg const { return observableOverlaps(dset,testArg);  ; const RooAbsArg &testArg const { return observableOverlaps(depList, testArg);  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Static Protected Member Functions inherited from RooAbsReal; static void globalSelectComp (bool flag);  Global switch controlling the activation of the selectComp() functionality. ;  ;  Static Protected Member Functions inherited from RooAbsArg; static void ioStreamerPass2Finalize ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooFracRemainder.h>. Inheritance diagram for RooFracRemainder:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooFracRemainder() [1/3]. RooFracRemainder::RooFracRemainder ; (; ). inline . Default constructor. ; Definition at line 29 of file RooFracRemainder.h. ◆ RooFracRemainder() [2/3]. RooFracRemainder::RooFracRemainder ; (; const char * ; name, . const char * ; title, . const RooArgSet & ; sumSet . ). Constructor with given set of input fractions. All arguments in sumSet must be of type RooAbsReal. ; Definition at line 48 of file RooFracRemainder.cxx. ◆ RooFracRemainder() [3/3]. RooFracRemainder::RooFracRemainder ; (; const RooFracRemainder & ; other, . const char * ; name = nullptr . ). Copy constructor. ; Definition at line 66 of file RooFracRemainder.cxx. Member Function Documen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFracRemainder.html:59721,Avoid,Avoids,59721,doc/master/classRooFracRemainder.html,https://root.cern,https://root.cern/doc/master/classRooFracRemainder.html,1,['Avoid'],['Avoids']
Safety," getObservables()."") RooFit const RooAbsArg &testArg const { return observableOverlaps(dset,testArg);  ; const RooAbsArg &testArg const { return observableOverlaps(depList, testArg);  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Static Protected Member Functions inherited from RooAbsReal; static void globalSelectComp (bool flag);  Global switch controlling the activation of the selectComp() functionality. ;  ;  Static Protected Member Functions inherited from RooAbsArg; static void ioStreamerPass2Finalize ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooFunctor1DBinding.h>. Inheritance diagram for RooFunctor1DBinding:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooFunctor1DBinding() [1/3]. RooFunctor1DBinding::RooFunctor1DBinding ; (; ). inline . Definition at line 35 of file RooFunctor1DBinding.h. ◆ RooFunctor1DBinding() [2/3]. RooFunctor1DBinding::RooFunctor1DBinding ; (; const char * ; name, . const char * ; title, . const ROOT::Math::IBaseFunctionOneDim & ; ftor, . RooAbsReal & ; var . ). Definition at line 39 of file RooFunctor1DBinding.cxx. ◆ RooFunctor1DBinding() [3/3]. RooFunctor1DBinding::RooFunctor1DBinding ; (; const RooFunctor1DBinding & ; other, . const char * ; name = nullptr . ). Definition at line 48 of file RooFunctor1DBinding.cxx. Member Function Documentation. ◆ Class(). static TClass * RooFunctor1DBinding::C",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFunctor1DBinding.html:60014,Avoid,Avoids,60014,doc/master/classRooFunctor1DBinding.html,https://root.cern,https://root.cern/doc/master/classRooFunctor1DBinding.html,1,['Avoid'],['Avoids']
Safety," getObservables()."") RooFit const RooAbsArg &testArg const { return observableOverlaps(dset,testArg);  ; const RooAbsArg &testArg const { return observableOverlaps(depList, testArg);  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Static Protected Member Functions inherited from RooAbsReal; static void globalSelectComp (bool flag);  Global switch controlling the activation of the selectComp() functionality. ;  ;  Static Protected Member Functions inherited from RooAbsArg; static void ioStreamerPass2Finalize ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooFunctorBinding.h>. Inheritance diagram for RooFunctorBinding:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooFunctorBinding() [1/3]. RooFunctorBinding::RooFunctorBinding ; (; ). default . ◆ RooFunctorBinding() [2/3]. RooFunctorBinding::RooFunctorBinding ; (; const char * ; name, . const char * ; title, . const ROOT::Math::IBaseFunctionMultiDim & ; ftor, . const RooArgList & ; v . ). Create a RooFit function that makes ftor usable in RooFit. ; Parameters. nameName of the object. ; titleTitle (e.g. for plotting) ; ftorFunctor instance to be evaluated. ; vRooFit variables to be passed to the function. . Definition at line 56 of file RooFunctorBinding.cxx. ◆ RooFunctorBinding() [3/3]. RooFunctorBinding::RooFunctorBinding ; (; const RooFunctorBinding & ; other, . const char * ; name ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFunctorBinding.html:60160,Avoid,Avoids,60160,doc/master/classRooFunctorBinding.html,https://root.cern,https://root.cern/doc/master/classRooFunctorBinding.html,1,['Avoid'],['Avoids']
Safety," getObservables()."") RooFit const RooAbsArg &testArg const { return observableOverlaps(dset,testArg);  ; const RooAbsArg &testArg const { return observableOverlaps(depList, testArg);  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Static Protected Member Functions inherited from RooAbsReal; static void globalSelectComp (bool flag);  Global switch controlling the activation of the selectComp() functionality. ;  ;  Static Protected Member Functions inherited from RooAbsArg; static void ioStreamerPass2Finalize ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooHistFunc.h>. Inheritance diagram for RooHistFunc:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooHistFunc() [1/6]. RooHistFunc::RooHistFunc ; (; ). inline . Definition at line 33 of file RooHistFunc.h. ◆ RooHistFunc() [2/6]. RooHistFunc::RooHistFunc ; (; const char * ; name, . const char * ; title, . const RooArgSet & ; vars, . const RooDataHist & ; dhist, . Int_t ; intOrder = 0 . ). Constructor from a RooDataHist. ; The variable listed in 'vars' control the dimensionality of the function. Any additional dimensions present in 'dhist' will be projected out. RooDataHist dimensions can be either real or discrete. See RooDataHist::RooDataHist for details on the binning. RooHistFunc neither owns or clone 'dhist' and the user must ensure the input histogram exists for the entire life ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooHistFunc.html:62329,Avoid,Avoids,62329,doc/master/classRooHistFunc.html,https://root.cern,https://root.cern/doc/master/classRooHistFunc.html,1,['Avoid'],['Avoids']
Safety," getObservables()."") RooFit const RooAbsArg &testArg const { return observableOverlaps(dset,testArg);  ; const RooAbsArg &testArg const { return observableOverlaps(depList, testArg);  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Static Protected Member Functions inherited from RooAbsReal; static void globalSelectComp (bool flag);  Global switch controlling the activation of the selectComp() functionality. ;  ;  Static Protected Member Functions inherited from RooAbsArg; static void ioStreamerPass2Finalize ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooLegendre.h>. Inheritance diagram for RooLegendre:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooLegendre() [1/4]. RooLegendre::RooLegendre ; (; ). Definition at line 56 of file RooLegendre.cxx. ◆ RooLegendre() [2/4]. RooLegendre::RooLegendre ; (; const char * ; name, . const char * ; title, . RooAbsReal & ; ctheta, . int ; l, . int ; m = 0 . ). TODO: for now, we assume that ctheta has a range [-1,1] should map the ctheta range onto this interval, and adjust integrals... ; Definition at line 65 of file RooLegendre.cxx. ◆ RooLegendre() [3/4]. RooLegendre::RooLegendre ; (; const char * ; name, . const char * ; title, . RooAbsReal & ; ctheta, . int ; l1, . int ; m1, . int ; l2, . int ; m2 . ). Definition at line 75 of file RooLegendre.cxx. ◆ RooLegendre() [4/4]. RooLegendre::RooLeg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooLegendre.html:59915,Avoid,Avoids,59915,doc/master/classRooLegendre.html,https://root.cern,https://root.cern/doc/master/classRooLegendre.html,1,['Avoid'],['Avoids']
Safety," getObservables()."") RooFit const RooAbsArg &testArg const { return observableOverlaps(dset,testArg);  ; const RooAbsArg &testArg const { return observableOverlaps(depList, testArg);  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Static Protected Member Functions inherited from RooAbsReal; static void globalSelectComp (bool flag);  Global switch controlling the activation of the selectComp() functionality. ;  ;  Static Protected Member Functions inherited from RooAbsArg; static void ioStreamerPass2Finalize ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooLinearVar.h>. Inheritance diagram for RooLinearVar:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooLinearVar() [1/3]. RooLinearVar::RooLinearVar ; (; ). inline . Definition at line 32 of file RooLinearVar.h. ◆ RooLinearVar() [2/3]. RooLinearVar::RooLinearVar ; (; const char * ; name, . const char * ; title, . RooAbsRealLValue & ; variable, . const RooAbsReal & ; slope, . const RooAbsReal & ; offset, . const char * ; unit = """" . ). Constructor with RooAbsRealLValue variable and RooAbsReal slope and offset. ; Definition at line 57 of file RooLinearVar.cxx. ◆ RooLinearVar() [3/3]. RooLinearVar::RooLinearVar ; (; const RooLinearVar & ; other, . const char * ; name = nullptr . ). Copy constructor. ; Definition at line 89 of file RooLinearVar.cxx. ◆ ~RooLinearVar(). RooLinearVar::~Roo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooLinearVar.html:68905,Avoid,Avoids,68905,doc/master/classRooLinearVar.html,https://root.cern,https://root.cern/doc/master/classRooLinearVar.html,1,['Avoid'],['Avoids']
Safety," getObservables()."") RooFit const RooAbsArg &testArg const { return observableOverlaps(dset,testArg);  ; const RooAbsArg &testArg const { return observableOverlaps(depList, testArg);  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Static Protected Member Functions inherited from RooAbsReal; static void globalSelectComp (bool flag);  Global switch controlling the activation of the selectComp() functionality. ;  ;  Static Protected Member Functions inherited from RooAbsArg; static void ioStreamerPass2Finalize ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooMoment.h>. Inheritance diagram for RooMoment:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooMoment() [1/4]. RooMoment::RooMoment ; (; ). default . ◆ RooMoment() [2/4]. RooMoment::RooMoment ; (; const char * ; name, . const char * ; title, . RooAbsReal & ; func, . RooRealVar & ; x, . Int_t ; order = 1, . bool ; central = false, . bool ; takeRoot = false . ). Definition at line 46 of file RooMoment.cxx. ◆ RooMoment() [3/4]. RooMoment::RooMoment ; (; const char * ; name, . const char * ; title, . RooAbsReal & ; func, . RooRealVar & ; x, . const RooArgSet & ; nset, . Int_t ; order = 1, . bool ; central = false, . bool ; takeRoot = false, . bool ; intNSet = false . ). Definition at line 90 of file RooMoment.cxx. ◆ RooMoment() [4/4]. RooMoment::RooMoment ; (; const RooMoment & ; othe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooMoment.html:60696,Avoid,Avoids,60696,doc/master/classRooMoment.html,https://root.cern,https://root.cern/doc/master/classRooMoment.html,1,['Avoid'],['Avoids']
Safety," getObservables()."") RooFit const RooAbsArg &testArg const { return observableOverlaps(dset,testArg);  ; const RooAbsArg &testArg const { return observableOverlaps(depList, testArg);  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Static Protected Member Functions inherited from RooAbsReal; static void globalSelectComp (bool flag);  Global switch controlling the activation of the selectComp() functionality. ;  ;  Static Protected Member Functions inherited from RooAbsArg; static void ioStreamerPass2Finalize ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooMomentMorphFunc.h>. Inheritance diagram for RooMomentMorphFunc:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Enumeration Documentation. ◆ Setting. enum RooMomentMorphFunc::Setting. EnumeratorLinear ; NonLinear ; NonLinearPosFractions ; NonLinearLinFractions ; SineLinear . Definition at line 32 of file RooMomentMorphFunc.h. Constructor & Destructor Documentation. ◆ RooMomentMorphFunc() [1/4]. RooMomentMorphFunc::RooMomentMorphFunc ; (; ). Definition at line 38 of file RooMomentMorphFunc.cxx. ◆ RooMomentMorphFunc() [2/4]. RooMomentMorphFunc::RooMomentMorphFunc ; (; const char * ; name, . const char * ; title, . RooAbsReal & ; _m, . const RooArgList & ; varList, . const RooArgList & ; pdfList, . const RooArgList & ; mrefList, . Setting ; setting = NonLinearPosFractions . ). Definition at line 65 of file RooMomentMorp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooMomentMorphFunc.html:60689,Avoid,Avoids,60689,doc/master/classRooMomentMorphFunc.html,https://root.cern,https://root.cern/doc/master/classRooMomentMorphFunc.html,1,['Avoid'],['Avoids']
Safety," getObservables()."") RooFit const RooAbsArg &testArg const { return observableOverlaps(dset,testArg);  ; const RooAbsArg &testArg const { return observableOverlaps(depList, testArg);  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Static Protected Member Functions inherited from RooAbsReal; static void globalSelectComp (bool flag);  Global switch controlling the activation of the selectComp() functionality. ;  ;  Static Protected Member Functions inherited from RooAbsArg; static void ioStreamerPass2Finalize ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooMomentMorphFuncND.h>. Inheritance diagram for RooMomentMorphFuncND:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Typedef Documentation. ◆ Base_t. using RooMomentMorphFuncND::Base_t = RooAbsReal. Definition at line 36 of file RooMomentMorphFuncND.h. ◆ Grid. using RooMomentMorphFuncND::Grid = Grid2. Definition at line 79 of file RooMomentMorphFuncND.h. Member Enumeration Documentation. ◆ Setting. enum RooMomentMorphFuncND::Setting. EnumeratorLinear ; SineLinear ; NonLinear ; NonLinearPosFractions ; NonLinearLinFractions . Definition at line 97 of file RooMomentMorphFuncND.h. Constructor & Destructor Documentation. ◆ RooMomentMorphFuncND() [1/5]. RooMomentMorphFuncND::RooMomentMorphFuncND ; (; ). Definition at line 49 of file RooMomentMorphFuncND.cxx. ◆ RooMomentMorphFuncND() [2/5]. RooMomentMorphFuncND::RooMomentMor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooMomentMorphFuncND.html:61188,Avoid,Avoids,61188,doc/master/classRooMomentMorphFuncND.html,https://root.cern,https://root.cern/doc/master/classRooMomentMorphFuncND.html,1,['Avoid'],['Avoids']
Safety," getObservables()."") RooFit const RooAbsArg &testArg const { return observableOverlaps(dset,testArg);  ; const RooAbsArg &testArg const { return observableOverlaps(depList, testArg);  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Static Protected Member Functions inherited from RooAbsReal; static void globalSelectComp (bool flag);  Global switch controlling the activation of the selectComp() functionality. ;  ;  Static Protected Member Functions inherited from RooAbsArg; static void ioStreamerPass2Finalize ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooNumConvolution.h>. Inheritance diagram for RooNumConvolution:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooNumConvolution() [1/3]. RooNumConvolution::RooNumConvolution ; (; ). Definition at line 80 of file RooNumConvolution.cxx. ◆ RooNumConvolution() [2/3]. RooNumConvolution::RooNumConvolution ; (; const char * ; name, . const char * ; title, . RooRealVar & ; convVar, . RooAbsReal & ; inPdf, . RooAbsReal & ; resmodel, . const RooNumConvolution * ; proto = nullptr . ). Constructor of convolution operator PDF. ; convVar : convolution variable (on which both pdf and resmodel should depend) pdf : input 'physics' pdf resmodel : input 'resolution' pdf; output is pdf(x) (X) resmodel(x) = Int [ pdf(x') resmodel (x-x') ] dx' ; Definition at line 106 of file RooNumConvolution.cxx. ◆ Roo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooNumConvolution.html:64224,Avoid,Avoids,64224,doc/master/classRooNumConvolution.html,https://root.cern,https://root.cern/doc/master/classRooNumConvolution.html,1,['Avoid'],['Avoids']
Safety," getObservables()."") RooFit const RooAbsArg &testArg const { return observableOverlaps(dset,testArg);  ; const RooAbsArg &testArg const { return observableOverlaps(depList, testArg);  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Static Protected Member Functions inherited from RooAbsReal; static void globalSelectComp (bool flag);  Global switch controlling the activation of the selectComp() functionality. ;  ;  Static Protected Member Functions inherited from RooAbsArg; static void ioStreamerPass2Finalize ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooParamHistFunc.h>. Inheritance diagram for RooParamHistFunc:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooParamHistFunc() [1/3]. RooParamHistFunc::RooParamHistFunc ; (; ). inline . Definition at line 26 of file RooParamHistFunc.h. ◆ RooParamHistFunc() [2/3]. RooParamHistFunc::RooParamHistFunc ; (; const char * ; name, . const char * ; title, . RooDataHist & ; dh, . const RooAbsArg & ; x, . const RooParamHistFunc * ; paramSource = nullptr, . bool ; paramRelative = true . ). Definition at line 32 of file RooParamHistFunc.cxx. ◆ RooParamHistFunc() [3/3]. RooParamHistFunc::RooParamHistFunc ; (; const RooParamHistFunc & ; other, . const char * ; name = nullptr . ). Definition at line 62 of file RooParamHistFunc.cxx. Member Function Documentation. ◆ analyticalIntegralWN(). double Roo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooParamHistFunc.html:60448,Avoid,Avoids,60448,doc/master/classRooParamHistFunc.html,https://root.cern,https://root.cern/doc/master/classRooParamHistFunc.html,1,['Avoid'],['Avoids']
Safety," getObservables()."") RooFit const RooAbsArg &testArg const { return observableOverlaps(dset,testArg);  ; const RooAbsArg &testArg const { return observableOverlaps(depList, testArg);  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Static Protected Member Functions inherited from RooAbsReal; static void globalSelectComp (bool flag);  Global switch controlling the activation of the selectComp() functionality. ;  ;  Static Protected Member Functions inherited from RooAbsArg; static void ioStreamerPass2Finalize ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooPolyFunc.h>. Inheritance diagram for RooPolyFunc:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooPolyFunc() [1/5]. RooPolyFunc::RooPolyFunc ; (; ). Default constructor. ; Definition at line 133 of file RooPolyFunc.cxx. ◆ RooPolyFunc() [2/5]. RooPolyFunc::RooPolyFunc ; (; const char * ; name, . const char * ; title, . RooAbsReal & ; x, . const RooAbsCollection & ; coefList . ). ◆ RooPolyFunc() [3/5]. RooPolyFunc::RooPolyFunc ; (; const char * ; name, . const char * ; title, . RooAbsReal & ; x, . RooAbsReal & ; y, . const RooAbsCollection & ; coefList . ). ◆ RooPolyFunc() [4/5]. RooPolyFunc::RooPolyFunc ; (; const char * ; name, . const char * ; title, . const RooAbsCollection & ; vars . ). Parameterised constructor. ; Definition at line 138 of file RooPolyFunc.cxx. ◆ RooPolyFunc(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooPolyFunc.html:60998,Avoid,Avoids,60998,doc/master/classRooPolyFunc.html,https://root.cern,https://root.cern/doc/master/classRooPolyFunc.html,1,['Avoid'],['Avoids']
Safety," getObservables()."") RooFit const RooAbsArg &testArg const { return observableOverlaps(dset,testArg);  ; const RooAbsArg &testArg const { return observableOverlaps(depList, testArg);  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Static Protected Member Functions inherited from RooAbsReal; static void globalSelectComp (bool flag);  Global switch controlling the activation of the selectComp() functionality. ;  ;  Static Protected Member Functions inherited from RooAbsArg; static void ioStreamerPass2Finalize ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooPolyVar.h>. Inheritance diagram for RooPolyVar:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooPolyVar() [1/4]. RooPolyVar::RooPolyVar ; (; ). inline . Definition at line 27 of file RooPolyVar.h. ◆ RooPolyVar() [2/4]. RooPolyVar::RooPolyVar ; (; const char * ; name, . const char * ; title, . RooAbsReal & ; x . ). Constructor of flat polynomial function. ; Definition at line 69 of file RooPolyVar.cxx. ◆ RooPolyVar() [3/4]. RooPolyVar::RooPolyVar ; (; const char * ; name, . const char * ; title, . RooAbsReal & ; x, . const RooArgList & ; coefList, . Int_t ; lowestOrder = 0 . ). Construct polynomial in x with coefficients in coefList. ; If lowestOrder is not zero, then the first element in coefList is interpreted as as the 'lowestOrder' coefficients and all subsequent coefficient e",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooPolyVar.html:60107,Avoid,Avoids,60107,doc/master/classRooPolyVar.html,https://root.cern,https://root.cern/doc/master/classRooPolyVar.html,1,['Avoid'],['Avoids']
Safety," getObservables()."") RooFit const RooAbsArg &testArg const { return observableOverlaps(dset,testArg);  ; const RooAbsArg &testArg const { return observableOverlaps(depList, testArg);  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Static Protected Member Functions inherited from RooAbsReal; static void globalSelectComp (bool flag);  Global switch controlling the activation of the selectComp() functionality. ;  ;  Static Protected Member Functions inherited from RooAbsArg; static void ioStreamerPass2Finalize ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooProduct.h>. Inheritance diagram for RooProduct:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooProduct() [1/4]. RooProduct::RooProduct ; (; ). Default constructor. ; Definition at line 52 of file RooProduct.cxx. ◆ RooProduct() [2/4]. RooProduct::RooProduct ; (; const char * ; name, . const char * ; title, . const RooArgList & ; prodSet . ). Construct function representing the product of functions in prodSet. ; Definition at line 71 of file RooProduct.cxx. ◆ RooProduct() [3/4]. RooProduct::RooProduct ; (; const char * ; name, . const char * ; title, . RooAbsReal & ; real1, . RooAbsReal & ; real2 . ). Definition at line 84 of file RooProduct.cxx. ◆ RooProduct() [4/4]. RooProduct::RooProduct ; (; const RooProduct & ; other, . const char * ; name = nullptr . ). Copy constructor. ; D",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooProduct.html:60712,Avoid,Avoids,60712,doc/master/classRooProduct.html,https://root.cern,https://root.cern/doc/master/classRooProduct.html,1,['Avoid'],['Avoids']
Safety," getObservables()."") RooFit const RooAbsArg &testArg const { return observableOverlaps(dset,testArg);  ; const RooAbsArg &testArg const { return observableOverlaps(depList, testArg);  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Static Protected Member Functions inherited from RooAbsReal; static void globalSelectComp (bool flag);  Global switch controlling the activation of the selectComp() functionality. ;  ;  Static Protected Member Functions inherited from RooAbsArg; static void ioStreamerPass2Finalize ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooProfileLL.h>. Inheritance diagram for RooProfileLL:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooProfileLL() [1/3]. RooProfileLL::RooProfileLL ; (; ). Default constructor Should only be used by proof. ; Definition at line 42 of file RooProfileLL.cxx. ◆ RooProfileLL() [2/3]. RooProfileLL::RooProfileLL ; (; const char * ; name, . const char * ; title, . RooAbsReal & ; nllIn, . const RooArgSet & ; observables . ). Constructor of profile likelihood given input likelihood nll w.r.t the given set of variables. ; The input log likelihood is minimized w.r.t to all other variables of the likelihood at each evaluation and the value of the global log likelihood minimum is always subtracted. ; Definition at line 56 of file RooProfileLL.cxx. ◆ RooProfileLL() [3/3]. RooProfileLL::RooProfile",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooProfileLL.html:61041,Avoid,Avoids,61041,doc/master/classRooProfileLL.html,https://root.cern,https://root.cern/doc/master/classRooProfileLL.html,1,['Avoid'],['Avoids']
Safety," getObservables()."") RooFit const RooAbsArg &testArg const { return observableOverlaps(dset,testArg);  ; const RooAbsArg &testArg const { return observableOverlaps(depList, testArg);  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Static Protected Member Functions inherited from RooAbsReal; static void globalSelectComp (bool flag);  Global switch controlling the activation of the selectComp() functionality. ;  ;  Static Protected Member Functions inherited from RooAbsArg; static void ioStreamerPass2Finalize ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooPullVar.h>. Inheritance diagram for RooPullVar:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooPullVar() [1/3]. RooPullVar::RooPullVar ; (; ). default . ◆ RooPullVar() [2/3]. RooPullVar::RooPullVar ; (; const char * ; name, . const char * ; title, . RooRealVar & ; meas, . RooAbsReal & ; truth . ). Construct the pull of the RooRealVar 'meas'. ; Parameters. [in]nameName of the pull variable. ; [in]titleThe title (for plotting). ; [in]measThe measurement. This variable needs to have an error, and therefore is a RooRealVar. ; [in]truthThe true value. . Definition at line 46 of file RooPullVar.cxx. ◆ RooPullVar() [3/3]. RooPullVar::RooPullVar ; (; const RooPullVar & ; other, . const char * ; name = nullptr . ). Copy constructor. ; Definition at line 60 of file RooPullVar.cxx. Member ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooPullVar.html:59795,Avoid,Avoids,59795,doc/master/classRooPullVar.html,https://root.cern,https://root.cern/doc/master/classRooPullVar.html,1,['Avoid'],['Avoids']
Safety," getObservables()."") RooFit const RooAbsArg &testArg const { return observableOverlaps(dset,testArg);  ; const RooAbsArg &testArg const { return observableOverlaps(depList, testArg);  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Static Protected Member Functions inherited from RooAbsReal; static void globalSelectComp (bool flag);  Global switch controlling the activation of the selectComp() functionality. ;  ;  Static Protected Member Functions inherited from RooAbsArg; static void ioStreamerPass2Finalize ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooRangeBoolean.h>. Inheritance diagram for RooRangeBoolean:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooRangeBoolean() [1/3]. RooRangeBoolean::RooRangeBoolean ; (; ). default . ◆ RooRangeBoolean() [2/3]. RooRangeBoolean::RooRangeBoolean ; (; const char * ; name, . const char * ; title, . RooAbsRealLValue & ; x, . const char * ; rangeName . ). Definition at line 38 of file RooRangeBoolean.cxx. ◆ RooRangeBoolean() [3/3]. RooRangeBoolean::RooRangeBoolean ; (; const RooRangeBoolean & ; other, . const char * ; name = nullptr . ). Copy constructor. ; Definition at line 50 of file RooRangeBoolean.cxx. Member Function Documentation. ◆ Class(). static TClass * RooRangeBoolean::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooRangeBoolea",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooRangeBoolean.html:59485,Avoid,Avoids,59485,doc/master/classRooRangeBoolean.html,https://root.cern,https://root.cern/doc/master/classRooRangeBoolean.html,1,['Avoid'],['Avoids']
Safety," getObservables()."") RooFit const RooAbsArg &testArg const { return observableOverlaps(dset,testArg);  ; const RooAbsArg &testArg const { return observableOverlaps(depList, testArg);  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Static Protected Member Functions inherited from RooAbsReal; static void globalSelectComp (bool flag);  Global switch controlling the activation of the selectComp() functionality. ;  ;  Static Protected Member Functions inherited from RooAbsArg; static void ioStreamerPass2Finalize ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooRatio.h>. Inheritance diagram for RooRatio:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooRatio() [1/7]. RooRatio::RooRatio ; (; ). Definition at line 40 of file RooRatio.cxx. ◆ RooRatio() [2/7]. RooRatio::RooRatio ; (; const char * ; name, . const char * ; title, . double ; numerator, . double ; denominator . ). Definition at line 75 of file RooRatio.cxx. ◆ RooRatio() [3/7]. RooRatio::RooRatio ; (; const char * ; name, . const char * ; title, . double ; numerator, . RooAbsReal & ; denominator . ). Definition at line 64 of file RooRatio.cxx. ◆ RooRatio() [4/7]. RooRatio::RooRatio ; (; const char * ; name, . const char * ; title, . RooAbsReal & ; numerator, . double ; denominator . ). Definition at line 53 of file RooRatio.cxx. ◆ RooRatio() [5/7]. RooRatio::RooRatio ; (; const c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooRatio.html:59824,Avoid,Avoids,59824,doc/master/classRooRatio.html,https://root.cern,https://root.cern/doc/master/classRooRatio.html,1,['Avoid'],['Avoids']
Safety," getObservables()."") RooFit const RooAbsArg &testArg const { return observableOverlaps(dset,testArg);  ; const RooAbsArg &testArg const { return observableOverlaps(depList, testArg);  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Static Protected Member Functions inherited from RooAbsReal; static void globalSelectComp (bool flag);  Global switch controlling the activation of the selectComp() functionality. ;  ;  Static Protected Member Functions inherited from RooAbsArg; static void ioStreamerPass2Finalize ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooRecursiveFraction.h>. Inheritance diagram for RooRecursiveFraction:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooRecursiveFraction() [1/3]. RooRecursiveFraction::RooRecursiveFraction ; (; ). default . ◆ RooRecursiveFraction() [2/3]. RooRecursiveFraction::RooRecursiveFraction ; (; const char * ; name, . const char * ; title, . const RooArgList & ; fracSet . ). Constructor of plain RooAddPdf fraction from list of recursive fractions. ; Definition at line 45 of file RooRecursiveFraction.cxx. ◆ RooRecursiveFraction() [3/3]. RooRecursiveFraction::RooRecursiveFraction ; (; const RooRecursiveFraction & ; other, . const char * ; name = nullptr . ). Copy constructor. ; Definition at line 68 of file RooRecursiveFraction.cxx. Member Function Documentation. ◆ Class(). static TClass * RooR",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooRecursiveFraction.html:59750,Avoid,Avoids,59750,doc/master/classRooRecursiveFraction.html,https://root.cern,https://root.cern/doc/master/classRooRecursiveFraction.html,1,['Avoid'],['Avoids']
Safety," getObservables()."") RooFit const RooAbsArg &testArg const { return observableOverlaps(dset,testArg);  ; const RooAbsArg &testArg const { return observableOverlaps(depList, testArg);  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Static Protected Member Functions inherited from RooAbsReal; static void globalSelectComp (bool flag);  Global switch controlling the activation of the selectComp() functionality. ;  ;  Static Protected Member Functions inherited from RooAbsArg; static void ioStreamerPass2Finalize ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooSecondMoment.h>. Inheritance diagram for RooSecondMoment:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooSecondMoment() [1/4]. RooSecondMoment::RooSecondMoment ; (; ). default . ◆ RooSecondMoment() [2/4]. RooSecondMoment::RooSecondMoment ; (; const char * ; name, . const char * ; title, . RooAbsReal & ; func, . RooRealVar & ; x, . bool ; central = false, . bool ; takeRoot = false . ). Definition at line 49 of file RooSecondMoment.cxx. ◆ RooSecondMoment() [3/4]. RooSecondMoment::RooSecondMoment ; (; const char * ; name, . const char * ; title, . RooAbsReal & ; func, . RooRealVar & ; x, . const RooArgSet & ; nset, . bool ; central = false, . bool ; takeRoot = false, . bool ; intNSet = false . ). Definition at line 95 of file RooSecondMoment.cxx. ◆ RooSecondMoment() [4/4]. RooSecon",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooSecondMoment.html:60762,Avoid,Avoids,60762,doc/master/classRooSecondMoment.html,https://root.cern,https://root.cern/doc/master/classRooSecondMoment.html,1,['Avoid'],['Avoids']
Safety," getObservables()."") RooFit const RooAbsArg &testArg const { return observableOverlaps(dset,testArg);  ; const RooAbsArg &testArg const { return observableOverlaps(depList, testArg);  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Static Protected Member Functions inherited from RooAbsReal; static void globalSelectComp (bool flag);  Global switch controlling the activation of the selectComp() functionality. ;  ;  Static Protected Member Functions inherited from RooAbsArg; static void ioStreamerPass2Finalize ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooStats/Heaviside.h>. Inheritance diagram for RooStats::Heaviside:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ Heaviside() [1/3]. RooStats::Heaviside::Heaviside ; (; ). inline . Definition at line 23 of file Heaviside.h. ◆ Heaviside() [2/3]. Heaviside::Heaviside ; (; const char * ; name, . const char * ; title, . RooAbsReal & ; _x, . RooAbsReal & ; _c . ). Definition at line 32 of file Heaviside.cxx. ◆ Heaviside() [3/3]. Heaviside::Heaviside ; (; const Heaviside & ; other, . const char * ; name = nullptr . ). Definition at line 43 of file Heaviside.cxx. Member Function Documentation. ◆ Class(). static TClass * RooStats::Heaviside::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooStats::Heaviside::Class_Name ; (; ). static . Return",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooStats_1_1Heaviside.html:59605,Avoid,Avoids,59605,doc/master/classRooStats_1_1Heaviside.html,https://root.cern,https://root.cern/doc/master/classRooStats_1_1Heaviside.html,1,['Avoid'],['Avoids']
Safety," getObservables()."") RooFit const RooAbsArg &testArg const { return observableOverlaps(dset,testArg);  ; const RooAbsArg &testArg const { return observableOverlaps(depList, testArg);  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Static Protected Member Functions inherited from RooAbsReal; static void globalSelectComp (bool flag);  Global switch controlling the activation of the selectComp() functionality. ;  ;  Static Protected Member Functions inherited from RooAbsArg; static void ioStreamerPass2Finalize ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooStats/HistFactory/FlexibleInterpVar.h>. Inheritance diagram for RooStats::HistFactory::FlexibleInterpVar:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ FlexibleInterpVar() [1/5]. FlexibleInterpVar::FlexibleInterpVar ; (; ). Default constructor. ; Definition at line 36 of file FlexibleInterpVar.cxx. ◆ FlexibleInterpVar() [2/5]. FlexibleInterpVar::FlexibleInterpVar ; (; const char * ; name, . const char * ; title, . const RooArgList & ; _paramList, . double ; nominal, . std::vector< double > const & ; low, . std::vector< double > const & ; high . ). Definition at line 44 of file FlexibleInterpVar.cxx. ◆ FlexibleInterpVar() [3/5]. FlexibleInterpVar::FlexibleInterpVar ; (; const char * ; name, . const char * ; title, . const RooArgList & ; _paramList, . double ; nominal, . std::vector",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooStats_1_1HistFactory_1_1FlexibleInterpVar.html:60917,Avoid,Avoids,60917,doc/master/classRooStats_1_1HistFactory_1_1FlexibleInterpVar.html,https://root.cern,https://root.cern/doc/master/classRooStats_1_1HistFactory_1_1FlexibleInterpVar.html,1,['Avoid'],['Avoids']
Safety," getObservables()."") RooFit const RooAbsArg &testArg const { return observableOverlaps(dset,testArg);  ; const RooAbsArg &testArg const { return observableOverlaps(depList, testArg);  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Static Protected Member Functions inherited from RooAbsReal; static void globalSelectComp (bool flag);  Global switch controlling the activation of the selectComp() functionality. ;  ;  Static Protected Member Functions inherited from RooAbsArg; static void ioStreamerPass2Finalize ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooStats/HistFactory/LinInterpVar.h>. Inheritance diagram for RooStats::HistFactory::LinInterpVar:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ LinInterpVar() [1/4]. RooStats::HistFactory::LinInterpVar::LinInterpVar ; (; ). default . ◆ LinInterpVar() [2/4]. LinInterpVar::LinInterpVar ; (; const char * ; name, . const char * ; title, . const RooArgList & ; _paramList, . double ; nominal, . std::vector< double > ; low, . std::vector< double > ; high . ). Definition at line 37 of file LinInterpVar.cxx. ◆ LinInterpVar() [3/4]. LinInterpVar::LinInterpVar ; (; const char * ; name, . const char * ; title . ). Constructor of flat polynomial function. ; Definition at line 58 of file LinInterpVar.cxx. ◆ LinInterpVar() [4/4]. LinInterpVar::LinInterpVar ; (; const LinInterpVar & ; other, . cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooStats_1_1HistFactory_1_1LinInterpVar.html:59809,Avoid,Avoids,59809,doc/master/classRooStats_1_1HistFactory_1_1LinInterpVar.html,https://root.cern,https://root.cern/doc/master/classRooStats_1_1HistFactory_1_1LinInterpVar.html,1,['Avoid'],['Avoids']
Safety," getObservables()."") RooFit const RooAbsArg &testArg const { return observableOverlaps(dset,testArg);  ; const RooAbsArg &testArg const { return observableOverlaps(depList, testArg);  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Static Protected Member Functions inherited from RooAbsReal; static void globalSelectComp (bool flag);  Global switch controlling the activation of the selectComp() functionality. ;  ;  Static Protected Member Functions inherited from RooAbsArg; static void ioStreamerPass2Finalize ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooStats/HistFactory/PiecewiseInterpolation.h>. Inheritance diagram for PiecewiseInterpolation:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ PiecewiseInterpolation() [1/3]. PiecewiseInterpolation::PiecewiseInterpolation ; (; ). Definition at line 49 of file PiecewiseInterpolation.cxx. ◆ PiecewiseInterpolation() [2/3]. PiecewiseInterpolation::PiecewiseInterpolation ; (; const char * ; name, . const char * ; title, . const RooAbsReal & ; nominal, . const RooArgList & ; lowSet, . const RooArgList & ; highSet, . const RooArgList & ; paramSet . ). Construct a new interpolation. ; The value of the function will be ; \[; A = \sum_i \mathrm{Interpolate}(\mathrm{low}_i, \mathrm{nominal}, \mathrm{high}_i).; \]. Parameters. nameName of the object. ; titleTitle (for e.g. plotting) ; nominalNomi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classPiecewiseInterpolation.html:61819,Avoid,Avoids,61819,doc/master/classPiecewiseInterpolation.html,https://root.cern,https://root.cern/doc/master/classPiecewiseInterpolation.html,1,['Avoid'],['Avoids']
Safety," getObservables()."") RooFit const RooAbsArg &testArg const { return observableOverlaps(dset,testArg);  ; const RooAbsArg &testArg const { return observableOverlaps(depList, testArg);  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Static Protected Member Functions inherited from RooAbsReal; static void globalSelectComp (bool flag);  Global switch controlling the activation of the selectComp() functionality. ;  ;  Static Protected Member Functions inherited from RooAbsArg; static void ioStreamerPass2Finalize ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooStats/HistFactory/RooBarlowBeestonLL.h>. Inheritance diagram for RooStats::HistFactory::RooBarlowBeestonLL:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooBarlowBeestonLL() [1/3]. RooStats::HistFactory::RooBarlowBeestonLL::RooBarlowBeestonLL ; (; ). Default constructor. Should only be used by proof. ; Definition at line 50 of file RooBarlowBeestonLL.cxx. ◆ RooBarlowBeestonLL() [2/3]. RooStats::HistFactory::RooBarlowBeestonLL::RooBarlowBeestonLL ; (; const char * ; name, . const char * ; title, . RooAbsReal & ; nll . ). Definition at line 57 of file RooBarlowBeestonLL.cxx. ◆ RooBarlowBeestonLL() [3/3]. RooStats::HistFactory::RooBarlowBeestonLL::RooBarlowBeestonLL ; (; const RooBarlowBeestonLL & ; other, . const char * ; name = nullptr . ). Definition at line 83 of file RooBarlowB",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooStats_1_1HistFactory_1_1RooBarlowBeestonLL.html:60424,Avoid,Avoids,60424,doc/master/classRooStats_1_1HistFactory_1_1RooBarlowBeestonLL.html,https://root.cern,https://root.cern/doc/master/classRooStats_1_1HistFactory_1_1RooBarlowBeestonLL.html,1,['Avoid'],['Avoids']
Safety," getObservables()."") RooFit const RooAbsArg &testArg const { return observableOverlaps(dset,testArg);  ; const RooAbsArg &testArg const { return observableOverlaps(depList, testArg);  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Static Protected Member Functions inherited from RooAbsReal; static void globalSelectComp (bool flag);  Global switch controlling the activation of the selectComp() functionality. ;  ;  Static Protected Member Functions inherited from RooAbsArg; static void ioStreamerPass2Finalize ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooTFnBinding.h>. Inheritance diagram for RooTFnBinding:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooTFnBinding() [1/4]. RooTFnBinding::RooTFnBinding ; (; ). default . ◆ RooTFnBinding() [2/4]. RooTFnBinding::RooTFnBinding ; (; const char * ; name, . const char * ; title, . TF1 * ; func, . const RooArgList & ; list . ). Definition at line 30 of file RooTFnBinding.cxx. ◆ RooTFnBinding() [3/4]. RooTFnBinding::RooTFnBinding ; (; const char * ; name, . const char * ; title, . TF1 * ; func, . const RooArgList & ; list, . const RooArgList & ; plist . ). Definition at line 40 of file RooTFnBinding.cxx. ◆ RooTFnBinding() [4/4]. RooTFnBinding::RooTFnBinding ; (; const RooTFnBinding & ; other, . const char * ; name = nullptr . ). Definition at line 52 of file RooTFnBinding.cxx. Member Func",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooTFnBinding.html:59872,Avoid,Avoids,59872,doc/master/classRooTFnBinding.html,https://root.cern,https://root.cern/doc/master/classRooTFnBinding.html,1,['Avoid'],['Avoids']
Safety," global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Static Protected Attributes; static Int_t _evalErrorCount = 0;  ; static std::map< const RooAbsArg *, std::pair< std::string, std::list< EvalError > > > _evalErrorList;  ; static ErrorLoggingMode _evalErrorMode = RooAbsReal::PrintErrors;  ; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . Private Member Functions; double _DEBUG_getVal (const RooArgSet *normalisationSet) const;  Debug version of getVal(), which is slow and does error checking. ;  . Friends; class AddCacheElem;  ; class BatchInterfaceAccessor;  ; class RooAddHelpers;  ; class RooAddModel;  ; class RooAddPdf;  ; class RooFit::EvalContext;  ; class RooRealBinding;  ; class RooRealSumFunc;  ; class RooRealSumPdf;  ; class RooVectorDataStore;  . Additional Inherited Members;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . #include <RooAbsReal.h>. Inheritance diagram for RooAbsReal:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Typedef Documentation. ◆ EvalErrorIter. typedef std::map<constRooAbsArg*,std::pair<std::string,std::list<EvalError>>>::const_iterator RooAbsReal::EvalErrorIter. Definition at line 347 of f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAbsReal.html:60997,Avoid,Avoids,60997,doc/v632/classRooAbsReal.html,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html,1,['Avoid'],['Avoids']
Safety," gradient vector for all tau same algorithm as MakeGradientVector() ; Definition at line 1259 of file RuleFitParams.cxx. ◆ Optimism(). Double_t TMVA::RuleFitParams::Optimism ; (; ). protected . implementation of eq. ; 7.17 in Hastie,Tibshirani & Friedman book this is the covariance between the estimated response yhat and the true value y. NOT REALLY SURE IF THIS IS CORRECT! — THIS IS NOT USED — ; Definition at line 925 of file RuleFitParams.cxx. ◆ Penalty(). Double_t TMVA::RuleFitParams::Penalty ; (; ); const. This is the ""lasso"" penalty To be used for regression. ; — NOT USED — ; Definition at line 356 of file RuleFitParams.cxx. ◆ Risk() [1/2]. Double_t TMVA::RuleFitParams::Risk ; (; UInt_t ; ind1, . UInt_t ; ind2, . Double_t ; neff . ); const. risk assessment ; Definition at line 314 of file RuleFitParams.cxx. ◆ Risk() [2/2]. Double_t TMVA::RuleFitParams::Risk ; (; UInt_t ; ind1, . UInt_t ; ind2, . Double_t ; neff, . UInt_t ; itau . ); const. risk assessment for tau model <itau> ; Definition at line 334 of file RuleFitParams.cxx. ◆ RiskPath(). Double_t TMVA::RuleFitParams::RiskPath ; (; ); const. inline . Definition at line 108 of file RuleFitParams.h. ◆ RiskPerf() [1/2]. Double_t TMVA::RuleFitParams::RiskPerf ; (; ); const. inline . Definition at line 109 of file RuleFitParams.h. ◆ RiskPerf() [2/2]. Double_t TMVA::RuleFitParams::RiskPerf ; (; UInt_t ; itau); const. inline . Definition at line 110 of file RuleFitParams.h. ◆ RiskPerfTst(). UInt_t TMVA::RuleFitParams::RiskPerfTst ; (; ). Estimates the error rate with the current set of parameters. ; using the <Perf> subsample. Return the tau index giving the lowest error ; Definition at line 1201 of file RuleFitParams.cxx. ◆ SetGDErrScale(). void TMVA::RuleFitParams::SetGDErrScale ; (; Double_t ; s). inline . Definition at line 85 of file RuleFitParams.h. ◆ SetGDNPathSteps(). void TMVA::RuleFitParams::SetGDNPathSteps ; (; Int_t ; np). inline . Definition at line 65 of file RuleFitParams.h. ◆ SetGDPathStep(). void TMV",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1RuleFitParams.html:16770,risk,risk,16770,doc/master/classTMVA_1_1RuleFitParams.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1RuleFitParams.html,1,['risk'],['risk']
Safety," h3.SetMaximum(1.35); # Set up plot for markers and errors; h3.Sumw2(); h3.SetStats(0); h3.Divide(h2); ; # Adjust y-axis settings; y = h3.GetYaxis(); y.SetTitle(""ratio h1/h2 ""); y.SetNdivisions(505); y.SetTitleSize(20); y.SetTitleFont(43); y.SetTitleOffset(1.55); y.SetLabelFont(43); y.SetLabelSize(15); ; # Adjust x-axis settings; x = h3.GetXaxis(); x.SetTitleSize(20); x.SetTitleFont(43); x.SetTitleOffset(4.0); x.SetLabelFont(43); x.SetLabelSize(15); ; return h3; ; ; def createCanvasPads():; c = TCanvas(""c"", ""canvas"", 800, 800); # Upper histogram plot is pad1; pad1 = TPad(""pad1"", ""pad1"", 0, 0.3, 1, 1.0); pad1.SetBottomMargin(0) # joins upper and lower plot; pad1.SetGridx(); pad1.Draw(); # Lower ratio plot is pad2; c.cd() # returns to main canvas before defining pad2; pad2 = TPad(""pad2"", ""pad2"", 0, 0.05, 1, 0.3); pad2.SetTopMargin(0) # joins upper and lower plot; pad2.SetBottomMargin(0.2); pad2.SetGridx(); pad2.Draw(); ; return c, pad1, pad2; ; ; def ratioplot():; # create required parts; h1 = createH1(); h2 = createH2(); h3 = createRatio(h1, h2); c, pad1, pad2 = createCanvasPads(); ; # draw everything; pad1.cd(); h1.Draw(); h2.Draw(""same""); # to avoid clipping the bottom zero, redraw a small axis; h1.GetYaxis().SetLabelSize(0.0); axis = TGaxis(-5, 20, -5, 220, 20, 220, 510, """"); axis.SetLabelFont(43); axis.SetLabelSize(15); axis.Draw(); pad2.cd(); h3.Draw(""ep""); ; # To hold window open when running from command line; # text = raw_input(); ; ; if __name__ == ""__main__"":; ratioplot(); TCanvasThe Canvas class.Definition TCanvas.h:23; TGaxisThe axis painter class.Definition TGaxis.h:24; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TPadThe most important graphics class in the ROOT system.Definition TPad.h:28; ratioplotDefinition ratioplot.py:1; AuthorMichael Moran ; Definition in file ratioplot.py. tutorialspyrootratioplot.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/ratioplot_8py.html:2237,avoid,avoid,2237,doc/master/ratioplot_8py.html,https://root.cern,https://root.cern/doc/master/ratioplot_8py.html,1,['avoid'],['avoid']
Safety," handles global queries related to geometry. However, shape-related queries might be sometimes useful:; Bool_t TGeoShape::Contains(Double_t *point[3]);; The method above returns kTRUE if the point *point is actually inside the shape. The point has to be defined in the local shape reference. For instance, for a box having DX,DY and DZhalf-lengths a point will be considered inside if:; -DX <= point[0] <= DX; -DY <= point[1] <= DY; -DZ <= point[2] <= DZ; Double_t TGeoShape::DistFromInside(Double_t *point[3],; Double_t *dir[3], Int_t iact,Double_t step,Double_t *safe);; The method computes the distance to exiting a shape from a given point inside, along a given direction. This direction is given by its director cosines with respect to the local shape coordinate system. This method provides additional information according the value of iact input parameter:. iact = 0computes only safe distance and fill it at the location given by SAFE;; iact = 1a proposed STEP is supplied. The safe distance is computed first. If this is bigger than STEP than the proposed step is approved and returned by the method since it does not cross the shape boundaries. Otherwise, the distance to exiting the shape is computed and returned;; iact = 2computes both safe distance and distance to exiting, ignoring the proposed step;; iact > 2computes only the distance to exiting, ignoring anything else. Double_t TGeoShape::DistFromOutside(Double_t *point[3],; Double_t *dir[3],Int_t iact,Double_t step,Double_t *safe);; This method computes the distance to entering a shape from a given point outside. It acts in the same way as the previous method.; Double_t TGeoShape::Safety(Double_t *point[3],Bool_t inside);; This computes the maximum shift of a point in any direction that does not change its inside/outsidestate (does not cross shape boundaries). The state of the point has to be properly supplied.; Double_t *TGeoShape::ComputeNormal(Double_t *point[3],; Double_t *dir[3],Double_t *norm[3]);; The method abo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:922760,safe,safe,922760,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['safe'],['safe']
Safety," has been; 217 badly parameterised so that individual errors are not very meaningful; 218 because they are so highly correlated.; 219 ; 220 6. Parameter at limit. This condition, signalled by a MINUIT warning; 221 message, may make both the function minimum and parameter errors; 222 unreliable. See the discussion above ``Getting the right parameter errors; 223 with limits''.; 224 ; 225 ; 226The best way to be absolutely sure of the errors, is to use; 227``independent'' calculations and compare them, or compare the calculated; 228errors with a picture of the function. Theoretically, the covariance; 229matrix for a ``physical'' function must be positive-definite at the; 230minimum, although it may not be so for all points far away from the; 231minimum, even for a well-determined physical problem. Therefore, if MIGRAD; 232reports that it has found a non-positive-definite covariance matrix, this; 233may be a sign of one or more of the following:; 234 ; 235##### A non-physical region:; 236 ; 237On its way to the minimum, MIGRAD may have traversed a region which has; 238unphysical behaviour, which is of course not a serious problem as long as; 239it recovers and leaves such a region.; 240 ; 241##### An underdetermined problem:; 242 ; 243If the matrix is not positive-definite even at the minimum, this may mean; 244that the solution is not well-defined, for example that there are more; 245unknowns than there are data points, or that the parameterisation of the; 246fit contains a linear dependence. If this is the case, then MINUIT (or any; 247other program) cannot solve your problem uniquely, and the error matrix; 248will necessarily be largely meaningless, so the user must remove the; 249under-determinedness by reformulating the parameterisation. MINUIT cannot; 250do this itself.; 251 ; 252##### Numerical inaccuracies:; 253 ; 254It is possible that the apparent lack of positive-definiteness is in fact; 255only due to excessive roundoff errors in numerical calculations in the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMinuit_8cxx_source.html:11622,recover,recovers,11622,doc/master/TMinuit_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html,1,['recover'],['recovers']
Safety," histogram with options.Definition TH1.cxx:3066; The ""SQL I/O"" package is currently under development. Any bug reports and suggestions are welcome. Author: S.Linev, GSI Darmstadt, S.Lin.nosp@m.ev@g.nosp@m.si.de ; Definition at line 30 of file TSQLFile.h. Public Types; enum  EIndexesKinds { kIndexesNone = 0; , kIndexesBasic = 1; , kIndexesClass = 2; , kIndexesAll = 3; };  ; enum  ETransactionKinds { kTransactionsOff = 0; , kTransactionsAuto = 1; , kTransactionsUser = 2; };  ;  Public Types inherited from TFile; enum  { kStartBigFile = 2000000000; };  ; enum  EAsyncOpenStatus { kAOSNotAsync = -1; , kAOSFailure = 0; , kAOSInProgress = 1; , kAOSSuccess = 2; };  Asynchronous open request status. More...;  ; enum  ECacheAction { kDisconnect = 0; , kDoNotDisconnect = 1; };  TTreeCache flushing semantics. More...;  ; enum  EFileType { ;   kDefault = 0; , kLocal = 1; , kNet = 2; , kWeb = 3; , ;   kFile = 4; , kMerge = 5. };  File type. More...;  ; enum  EOpenTimeOut { kInstantTimeout = 0; , kEternalTimeout = 999999999; };  Open timeout constants. More...;  ; enum  ERelativeTo { kBeg = 0; , kCur = 1; , kEnd = 2; };  ; enum  EStatusBits { ;   k630forwardCompatibility = (1ULL << ( 2 )); , kRecovered = (1ULL << ( 10 )); , kHasReferences = (1ULL << ( 11 )); , kDevNull = (1ULL << ( 12 )); , ;   kWriteError = (1ULL << ( 14 )); , kBinaryFile = (1ULL << ( 15 )); , kRedirected = (1ULL << ( 16 )); , kReproducible = (1ULL << ( 17 )). };  TFile status bits. BIT(13) is taken up by TObject. More...;  ;  Public Types inherited from TDirectoryFile; enum  EStatusBits { kCloseDirectory = (1ULL << ( 7 )); };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSQLFile.html:8687,timeout,timeout,8687,doc/master/classTSQLFile.html,https://root.cern,https://root.cern/doc/master/classTSQLFile.html,1,['timeout'],['timeout']
Safety," how to make a branch with a variable length array; how to read selective branches; how to fill a histogram from a branch; how to use TTree::Draw to show a 3D plot. A C structure (struct) is used to build a ROOT tree. In general we discourage the use of C structures, we recommend using a class instead. However, we do support them for legacy applications written in C or FORTRAN. The example struct holds simple variables and arrays. It maps to a Geant3 common block /gctrak/.This is the definition of the common block/structure:; const Int_t MAXMEC = 30;; // PARAMETER (MAXMEC=30); // COMMON/GCTRAK/VECT(7),GETOT,GEKIN,VOUT(7); // + ,NMEC,LMEC(MAXMEC); // + ,NAMEC(MAXMEC),NSTEP; // + ,PID,DESTEP,DESTEL,SAFETY,SLENG; // + ,STEP,SNEXT,SFIELD,TOFG,GEKRAT,UPWGHT. typedef struct {; Float_t vect[7];; Float_t getot;; Float_t gekin;; Float_t vout[7];; Int_t nmec;; Int_t lmec[MAXMEC];; Int_t namec[MAXMEC];; Int_t nstep;; Int_t pid;; Float_t destep;; Float_t destel;; Float_t safety;; Float_t sleng;; Float_t step;; Float_t snext;; Float_t sfield;; Float_t tofg;; Float_t gekrat;; Float_t upwght;; } Gctrak_t;; When using Geant3, the common block is filled by Geant3 routines at each step and only the TTree::Fill method needs to be called. In this example we emulate the Geant3 step routine with the helixStep function. We also emulate the filling of the particle values. The calls to the Branch methods are the same as if Geant3 were used.; void helixStep(Float_t step, Float_t *vect, Float_t *vout); {; // extrapolate track in constant field; Float_t field = 20; // field in kilogauss; enum Evect {kX,kY,kZ,kPX,kPY,kPZ,kPP};; vout[kPP] = vect[kPP];. Float_t h4 = field*2.99792e-4;; Float_t rho = -h4/vect[kPP];; Float_t tet = rho*step;; Float_t tsint = tet*tet/6;; Float_t sintt = 1 - tsint;; Float_t sint = tet*sintt;; Float_t cos1t = tet/2;; Float_t f1 = step*sintt;; Float_t f2 = step*cos1t;; Float_t f3 = step*tsint*vect[kPZ];; Float_t f4 = -tet*cos1t;; Float_t f5 = sint;; Float_t f6 = tet*cos1t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:561200,safe,safety,561200,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['safe'],['safety']
Safety," iact = 1,; 125 Double_t step = TGeoShape::Big(), Double_t *safe = nullptr) const override;; 126 void DistFromOutside_v(const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize,; 127 Double_t *step) const override;; 128 TGeoVolume *; 129 Divide(TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) override;; 130 Double_t GetTheta() const { return fTheta; }; 131 Double_t GetPhi() const { return fPhi; }; 132 Double_t GetH1() const { return fH1; }; 133 Double_t GetBl1() const { return fBl1; }; 134 Double_t GetTl1() const { return fTl1; }; 135 Double_t GetAlpha1() const { return fAlpha1; }; 136 Double_t GetH2() const { return fH2; }; 137 Double_t GetBl2() const { return fBl2; }; 138 Double_t GetTl2() const { return fTl2; }; 139 Double_t GetAlpha2() const { return fAlpha2; }; 140 TGeoShape *GetMakeRuntimeShape(TGeoShape *mother, TGeoMatrix *mat) const override;; 141 void SetDimensions(Double_t *param) override;; 142 Double_t Safety(const Double_t *point, Bool_t in = kTRUE) const override;; 143 void Safety_v(const Double_t *points, const Bool_t *inside, Double_t *safe, Int_t vecsize) const override;; 144 void SavePrimitive(std::ostream &out, Option_t *option = """") override;; 145 ; 146 ClassDefOverride(TGeoTrap, 1) // G3 TRAP shape; 147};; 148 ; 149class TGeoGtra : public TGeoTrap {; 150protected:; 151 // data members; 152 Double_t fTwistAngle; // twist angle in degrees; 153public:; 154 // constructors; 155 TGeoGtra();; 156 TGeoGtra(Double_t dz, Double_t theta, Double_t phi, Double_t twist, Double_t h1, Double_t bl1, Double_t tl1,; 157 Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2);; 158 TGeoGtra(const char *name, Double_t dz, Double_t theta, Double_t phi, Double_t twist, Double_t h1, Double_t bl1,; 159 Double_t tl1, Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2);; 160 // destructor; 161 ~TGeoGtra() override;; 162 Double_t DistFromInside(const Double_t *poi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoArb8_8h_source.html:7500,Safe,Safety,7500,doc/master/TGeoArb8_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoArb8_8h_source.html,1,['Safe'],['Safety']
Safety," id; TStringTNamed::fTitleobject title. private:. Double_tfN[3]; Double_tfP[3]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoHalfSpace(); Dummy constructor. TGeoHalfSpace(const char* name, Double_t* p, Double_t* n); Constructor with name, point on the plane and normal. TGeoHalfSpace(Double_t* params); Default constructor specifying minimum and maximum radius. ~TGeoHalfSpace(); destructor. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside the half-space. Int_t DistancetoPrimitive(Int_t px, Int_t py); A half-space does not have a mesh primitive. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to the plane. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to the plane. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Divide the shape along one axis. void GetMeshNumbers(Int_t& nvert, Int_t& nsegs, Int_t& npols) const; Returns numbers of vertices, segments and polygons composing the shape mesh. void InspectShape() const; print shape parameters. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape, according; to option. The matching point on the shape is stored in spoint. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetDimensions(Double_t* param); Set half-space parameters as stored in an array. TGeoHalfSpace(); constructors. Double_t Capacity() const; methods. {return 0.;}. void ComputeBBox(); {;}. Double_t * GetPoint(); {return fP;}. Double_t * GetN",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoHalfSpace.html:12007,safe,safe,12007,root/html528/TGeoHalfSpace.html,https://root.cern,https://root.cern/root/html528/TGeoHalfSpace.html,3,['safe'],['safe']
Safety," if (f.IsZombie()) {; std::cout << ""Error opening file"" << std::endl;; exit(-1);; }; f#define f(i)Definition RSha256.hxx:104; If you open a file instead with TFile::Open(""file.root"") use rather the following code as a nullptr is returned. TFile* f = TFile::Open(""file.root"");; if (!f) {; std::cout << ""Error opening file"" << std::endl;; exit(-1);; }; TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definition TFile.cxx:4089; When opening the file, the system checks the validity of this directory. If something wrong is detected, an automatic Recovery is performed. In this case, the file is scanned sequentially reading all logical blocks and attempting to rebuild a correct directory (see TFile::Recover). One can disable the automatic recovery procedure when reading one or more files by setting the environment variable ""TFile.Recover: 0"" in the system.rootrc file.; A bit TFile::kReproducible can be enabled specifying the ""reproducible"" url option when creating the file: TFile *f = TFile::Open(""name.root?reproducible"",""RECREATE"",""File title"");; Unlike regular TFiles, the content of such file has reproducible binary content when writing exactly same data. This achieved by writing pre-defined values for creation and modification date of TKey/TDirectory objects and null value for TUUID objects inside TFile. As drawback, TRef objects stored in such file cannot be read correctly.; In case the name of the file is not reproducible either (in case of creating temporary filenames) a value can be passed to the reproducible option to replace the name stored in the file. TFile *f = TFile::Open(""tmpname.root?reproducible=fixedname"",""RECREATE"",""File title"");. Definition at line 339 of file TFile.cxx. ◆ ~TFile(). TFile::~TFile ; (; ). override . File destructor. ; Definition at line 563 of file TFile.cxx. Member Function Documentation.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTFile.html:52480,Recover,Recover,52480,doc/v632/classTFile.html,https://root.cern,https://root.cern/doc/v632/classTFile.html,2,['Recover'],['Recover']
Safety," if (rc < 0); 1463 THLimitsFinder::GetLimitsFinder()->FindGoodLimits(this, xmin, xmax);; 1464 } else {; 1465 fBuffer = nullptr;; 1466 Int_t keep = fBufferSize; fBufferSize = 0;; 1467 if (xmin < fXaxis.GetXmin()) ExtendAxis(xmin, &fXaxis);; 1468 if (xmax >= fXaxis.GetXmax()) ExtendAxis(xmax, &fXaxis);; 1469 fBuffer = buffer;; 1470 fBufferSize = keep;; 1471 }; 1472 }; 1473 ; 1474 // call DoFillN which will not put entries in the buffer as FillN does; 1475 // set fBuffer to zero to avoid re-emptying the buffer from functions called; 1476 // by DoFillN (e.g Sumw2); 1477 buffer = fBuffer; fBuffer = nullptr;; 1478 DoFillN(nbentries,&buffer[2],&buffer[1],2);; 1479 fBuffer = buffer;; 1480 ; 1481 // if action == 1 - delete the buffer; 1482 if (action > 0) {; 1483 delete [] fBuffer;; 1484 fBuffer = nullptr;; 1485 fBufferSize = 0;; 1486 } else {; 1487 // if number of entries is consistent with buffer - set it negative to avoid; 1488 // refilling the histogram every time BufferEmpty(0) is called; 1489 // In case it is not consistent, by setting fBuffer[0]=0 is like resetting the buffer; 1490 // (it will not be used anymore the next time BufferEmpty is called); 1491 if (nbentries == (Int_t)fEntries); 1492 fBuffer[0] = -nbentries;; 1493 else; 1494 fBuffer[0] = 0;; 1495 }; 1496 return nbentries;; 1497}; 1498 ; 1499////////////////////////////////////////////////////////////////////////////////; 1500/// accumulate arguments in buffer. When buffer is full, empty the buffer; 1501///; 1502/// - `fBuffer[0]` = number of entries in buffer; 1503/// - `fBuffer[1]` = w of first entry; 1504/// - `fBuffer[2]` = x of first entry; 1505 ; 1506Int_t TH1::BufferFill(Double_t x, Double_t w); 1507{; 1508 if (!fBuffer) return -2;; 1509 Int_t nbentries = (Int_t)fBuffer[0];; 1510 ; 1511 ; 1512 if (nbentries < 0) {; 1513 // reset nbentries to a positive value so next time BufferEmpty() is called; 1514 // the histogram will be refilled; 1515 nbentries = -nbentries;; 1516 fBuffer[0] = nbentries;; 1517 if",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:58203,avoid,avoid,58203,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['avoid'],['avoid']
Safety," if the bounding box could be crossed by a vector. Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute closest distance from point px,py to each corner. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this box shape belonging to volume ""voldiv"" into ndiv equal volumes; called divname, from start position with the given step. Returns pointer; to created division cell volume. In case a wrong division axis is supplied,; returns pointer to volume to be divided. void ComputeBBox(); Compute bounding box - nothing to do in this case. Bool_t Contains(const Double_t* point) const; Test if point is inside this shape. Bool_t Contains(const Double_t* point, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin); Static method to check if point[3] is located inside a box of having dx, dy, dz; as half-lengths. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the box.; Boundary safe algorithm. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); Compute distance from inside point to surface of the box.; Boundary safe algorithm. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the box.; Boundary safe algorithm. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); Compute distance from outside point to surface of the box.; Boundary safe algorithm. const char * GetAxisName(Int_t iaxis) const; Returns name of axis IAXIS. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoBBox.html:15884,safe,safe,15884,root/html534/TGeoBBox.html,https://root.cern,https://root.cern/root/html534/TGeoBBox.html,3,['safe'],['safe']
Safety," in [length^2]. ;  ; Bool_t Contains (const Double_t *point) const;  Check if a point given by X = point[0], Y = point[1] is inside the polygon. ;  ; void Draw (Option_t *option="""") override;  Draw the polygon. ;  ; void FinishPolygon ();  Decompose polygon in a convex outscribed part and a list of daughter polygons that have to be subtracted to get the actual one. ;  ; void GetConvexVertices (Double_t *x, Double_t *y) const;  Fill list of vertices of the convex outscribed polygon into provided arrays. ;  ; Int_t GetNconvex () const;  ; Int_t GetNvert () const;  ; void GetVertices (Double_t *x, Double_t *y) const;  Fill list of vertices into provided arrays. ;  ; Double_t * GetX ();  ; Double_t * GetY ();  ; TClass * IsA () const override;  ; Bool_t IsClockwise () const;  ; Bool_t IsConvex () const;  ; Bool_t IsFinished () const;  ; Bool_t IsIllegalCheck () const;  Check for illegal crossings between non-consecutive segments. ;  ; Double_t Safety (const Double_t *point, Int_t &isegment) const;  Compute minimum distance from POINT to any segment. Returns segment index. ;  ; void SetConvex (Bool_t flag=kTRUE);  ; void SetNextIndex (Int_t index=-1);  Sets the next polygone index. ;  ; void SetXY (Double_t *x, Double_t *y);  Set X/Y array pointer for the polygon and daughters. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash (",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoPolygon.html:3887,Safe,Safety,3887,doc/master/classTGeoPolygon.html,https://root.cern,https://root.cern/doc/master/classTGeoPolygon.html,1,['Safe'],['Safety']
Safety," in debug mode or optimized. ; The values are:; TSystem::kDefault : compile the same as the current ROOT; TSystem::kDebug : compiled in debug mode; TSystem::kOpt : optimized the library . Definition at line 4077 of file TSystem.cxx. ◆ SetBuildDir(). void TSystem::SetBuildDir ; (; const char * ; build_dir, . Bool_t ; isflat = kFALSE . ). virtual . Set the location where ACLiC will create libraries and use as a scratch area. ; If unset, libraries will be created at the same location than the script.; Parameters. build_dirthe name of the build directory ; isflatIf false (default), then the libraries are actually stored in sub-directories of 'build_dir' including the full pathname of the script. If the script is located at /full/path/name/macro.C the library will be located at build_dir+/full/path/name/macro_C.so If 'isflat' is true, then no subdirectory is created and the library is created directly in the directory 'build_dir'. Note that in this mode there is a risk than 2 script of the same in different source directory will over-write each other. . NoteThis build_dir can also be controlled via ACLiC.BuildDir in your .rootrc. ; Definition at line 4043 of file TSystem.cxx. ◆ SetDisplay(). void TSystem::SetDisplay ; (; ). virtual . Set DISPLAY environment variable based on utmp entry. Only for UNIX. ; Reimplemented in TUnixSystem.; Definition at line 235 of file TSystem.cxx. ◆ SetDynamicPath(). void TSystem::SetDynamicPath ; (; const char * ; pathname). virtual . Set the dynamic path to a new value. ; If the value of 'path' is zero, the dynamic path is reset to its default value. ; Reimplemented in TUnixSystem, and TWinNTSystem.; Definition at line 1806 of file TSystem.cxx. ◆ Setenv(). void TSystem::Setenv ; (; const char * ; name, . const char * ; value . ). virtual . Set environment variable. ; Reimplemented in TUnixSystem, and TWinNTSystem.; Definition at line 1649 of file TSystem.cxx. ◆ SetErrorStr(). void TSystem::SetErrorStr ; (; const char * ; errstr). Set the sy",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSystem.html:83688,risk,risk,83688,doc/master/classTSystem.html,https://root.cern,https://root.cern/doc/master/classTSystem.html,1,['risk'],['risk']
Safety," incremental changes to a RNTupleModel More...;  ; class  RNTupleSerializer;  A helper class for serializing and deserialization of the RNTuple binary format. More...;  ; class  RNTupleWriteOptionsManip;  ; class  ROnDiskPage;  A page as being stored on disk, that is packed and compressed. More...;  ; class  ROnDiskPageMap;  A memory region that contains packed and compressed pages. More...;  ; class  ROnDiskPageMapHeap;  An ROnDiskPageMap that is used for an fMemory allocated as an array of unsigned char. More...;  ; class  RPage;  A page is a slice of a column that is mapped into memory. More...;  ; class  RPageAllocator;  Abstract interface to allocate and release pages. More...;  ; class  RPageAllocatorHeap;  Uses standard C++ memory allocation for the column data pages. More...;  ; class  RPageNullSink;  Dummy sink that discards all pages. More...;  ; class  RPagePersistentSink;  Base class for a sink with a physical storage backend. More...;  ; class  RPagePool;  A thread-safe cache of pages loaded from the page source. More...;  ; class  RPageRef;  Reference to a page stored in the page pool. More...;  ; class  RPageSink;  Abstract interface to write data into an ntuple. More...;  ; class  RPageSinkBuf;  Wrapper sink that coalesces cluster column page writes. More...;  ; class  RPageSinkDaos;  Storage provider that writes ntuple pages to into a DAOS container. More...;  ; class  RPageSinkFile;  Storage provider that write ntuple pages into a file. More...;  ; class  RPageSource;  Abstract interface to read data from an ntuple. More...;  ; class  RPageSourceDaos;  Storage provider that reads ntuple pages from a DAOS container. More...;  ; class  RPageSourceFile;  Storage provider that reads ntuple pages from a file. More...;  ; class  RPageSourceFriends;  Virtual storage that combines several other sources horizontally. More...;  ; class  RPageStorage;  Common functionality of an ntuple storage for both reading and writing. More...;  ; class  RProjectedFields; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Experimental_1_1Internal.html:8165,safe,safe,8165,doc/master/namespaceROOT_1_1Experimental_1_1Internal.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Experimental_1_1Internal.html,1,['safe'],['safe']
Safety," independent of the Tree. The Tree is initialized with fAutoFlush=-30000000, ie that, by default,; the first AutoFlush will be done when 30 MBytes of data are written to the file. CASE 3 : autof = 0. The AutoFlush mechanism is disabled. Flushing the buffers at regular intervals optimize the location of; consecutive entries on the disk by creating clusters of baskets. A cluster of baskets is a set of baskets that contains all; the data for a (consecutive) set of entries and that is stored; consecutively on the disk. When reading all the branches, this; is the minimum set of baskets that the TTreeCache will read. void SetAutoSave(Long64_t autos = 300000000); This function may be called at the start of a program to change; the default value for fAutoSave(300000000, ie 300 MBytes).; When filling the Tree the branch buffers as well as the Tree header; will be flushed to disk when more than fAutoSave bytes have been written to the file.; In case of a program crash, it will be possible to recover the data in the Tree; up to the last AutoSave point. void SetBasketSize(const char* bname, Int_t buffsize = 16000); Set a branch's basket size. bname is the name of a branch.; if bname=""*"", apply to all branches.; if bname=""xxx*"", apply to all branches with name starting with xxx; see TRegexp for wildcarding options; buffsize = branc basket size. Int_t SetBranchAddress(const char* bname, void* add, TBranch** ptr = 0); Change branch address, dealing with clone trees properly.; See TTree::CheckBranchAddressType for the semantic of the return value. Note: See the comments in TBranchElement::SetAddress() for the; meaning of the addr parameter and the object ownership policy. Int_t SetBranchAddress(const char* bname, void* add, TClass* realClass, EDataType datatype, Bool_t isptr); Verify the validity of the type of addr before calling SetBranchAddress.; See TTree::CheckBranchAddressType for the semantic of the return value. Note: See the comments in TBranchElement::SetAddress() for the;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTree.html:128554,recover,recover,128554,root/html602/TTree.html,https://root.cern,https://root.cern/root/html602/TTree.html,1,['recover'],['recover']
Safety," independent of the Tree. The Tree is initialized with fAutoFlush=-30000000, ie that, by default,; the first AutoFlush will be done when 30 MBytes of data are written to the file. CASE 3 : autof = 0. The AutoFlush mechanism is disabled. Flushing the buffers at regular intervals optimize the location of; consecutive entries on the disk by creating clusters of baskets. A cluster of baskets is a set of baskets that contains all; the data for a (consecutive) set of entries and that is stored; consecutively on the disk. When reading all the branches, this; is the minimum set of baskets that the TTreeCache will read. void SetAutoSave(Long64_t autos = 300000000); This function may be called at the start of a program to change; the default value for fAutoSave(300000000, ie 300 MBytes).; When filling the Tree the branch buffers as well as the Tree header; will be flushed to disk when more than fAutoSave bytes have been written to the file.; In case of a program crash, it will be possible to recover the data in the Tree; up to the last AutoSave point. void SetBasketSize(const char* bname, Int_t buffsize = 16000); Set a branch's basket size. bname is the name of a branch.; if bname=""*"", apply to all branches.; if bname=""xxx*"", apply to all branches with name starting with xxx; see TRegexp for wildcarding options; buffsize = branc basket size. Int_t SetBranchAddress(const char* bname, void** add, TBranch** ptr = 0); Change branch address, dealing with clone trees properly.; See TTree::CheckBranchAddressType for the semantic of the return value. Note: See the comments in TBranchElement::SetAddress() for the; meaning of the addr parameter. Int_t SetBranchAddress(const char* bname, void* add, TClass* realClass, EDataType datatype, Bool_t isptr); Verify the validity of the type of addr before calling SetBranchAddress.; See TTree::CheckBranchAddressType for the semantic of the return value. Note: See the comments in TBranchElement::SetAddress() for the; meaning of the addr parameter.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTree.html:122953,recover,recover,122953,root/html532/TTree.html,https://root.cern,https://root.cern/root/html532/TTree.html,1,['recover'],['recover']
Safety," inference; // The event-by-event inference takes the values of the variables as a std::vector<float>.; // Note that the return value is as well a std::vector<float> since the reader; // is also capable to process models with multiple outputs.; auto prediction = model.Compute({0.5, 1.0, -0.2, 1.5});; std::cout << ""Single-event inference: "" << prediction[0] << ""\n\n"";; ; // 2) Batch inference on data of multiple events; // For batch inference, the data needs to be structured as a matrix. For this; // purpose, TMVA makes use of the RTensor class. For convenience, we use RDataFrame; // and the AsTensor utility to make the read-out from the ROOT file.; ROOT::RDataFrame df(""TreeS"", filename);; auto df2 = df.Range(3); // Read only a small subset of the dataset; auto x = AsTensor<float>(df2, variables);; auto y = model.Compute(x);; ; std::cout << ""RTensor input for inference on data of multiple events:\n"" << x << ""\n\n"";; std::cout << ""Prediction performed on multiple events: "" << y << ""\n\n"";; ; // 3) Perform inference as part of an RDataFrame graph; // We write a small lambda function that performs for us the inference on; // a dataframe to omit code duplication.; auto make_histo = [&](const std::string &treename) {; ROOT::RDataFrame df(treename, filename);; auto df2 = df.Define(""y"", Compute<4, float>(model), variables);; return df2.Histo1D({treename.c_str(), "";BDT score;N_{Events}"", 30, -0.5, 0.5}, ""y"");; };; ; auto sig = make_histo(""TreeS"");; auto bkg = make_histo(""TreeB"");; ; // Make plot; gStyle->SetOptStat(0);; auto c = new TCanvas("""", """", 800, 800);; ; sig->SetLineColor(kRed);; bkg->SetLineColor(kBlue);; sig->SetLineWidth(2);; bkg->SetLineWidth(2);; bkg->Draw(""HIST"");; sig->Draw(""HIST SAME"");; ; TLegend legend(0.7, 0.7, 0.89, 0.89);; legend.SetBorderSize(0);; legend.AddEntry(""TreeS"", ""Signal"", ""l"");; legend.AddEntry(""TreeB"", ""Background"", ""l"");; legend.Draw();; ; c->DrawClone();; }; c#define c(i)Definition RSha256.hxx:101; kRed@ kRedDefinition Rtypes.h:66; kBlue@ k",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva003__RReader_8C.html:2931,Predict,Prediction,2931,doc/master/tmva003__RReader_8C.html,https://root.cern,https://root.cern/doc/master/tmva003__RReader_8C.html,1,['Predict'],['Prediction']
Safety," inlinefinalvirtual . Read the FREE linked list. ; Every file has a linked list (fFree) of free segments. This linked list has been written on the file via WriteFree as a single data record. ; Reimplemented from TFile.; Definition at line 85 of file TXMLFile.h. ◆ ReadFromFile(). Bool_t TXMLFile::ReadFromFile ; (; ). protected . read document from file Now full content of document reads into the memory Then document decomposed to separate keys and streamer info structures All irrelevant data will be cleaned ; Definition at line 559 of file TXMLFile.cxx. ◆ ReadKeysList(). Int_t TXMLFile::ReadKeysList ; (; TDirectory * ; dir, . XMLNodePointer_t ; topnode . ). protected . Read list of keys for directory. ; Definition at line 630 of file TXMLFile.cxx. ◆ ReadStreamerElement(). void TXMLFile::ReadStreamerElement ; (; XMLNodePointer_t ; node, . TStreamerInfo * ; info . ). protected . read and reconstruct single TStreamerElement from xml node ; Definition at line 825 of file TXMLFile.cxx. ◆ Recover(). Int_t TXMLFile::Recover ; (; ). inlinefinalvirtual . Attempt to recover file if not correctly closed. ; The function returns the number of keys that have been recovered. If no keys can be recovered, the file will be declared Zombie by the calling function. This function is automatically called when opening a file. If the file is open in read only mode, the file is not modified. If open in update mode and the function finds something to recover, a new directory header is written to the file. When opening the file gain no message from Recover will be reported. If keys have been recovered, the file is usable and you can safely read the corresponding objects. If the file is not usable (a zombie), you can test for this case with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {<actions to take if file is unusable>}; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; If the file has been recovered,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTXMLFile.html:66434,Recover,Recover,66434,doc/master/classTXMLFile.html,https://root.cern,https://root.cern/doc/master/classTXMLFile.html,1,['Recover'],['Recover']
Safety," int flag) overrideTUnixSystemvirtual; RedirectOutput(const char *name, const char *mode=""a"", RedirectHandle_t *h=nullptr) overrideTUnixSystemvirtual; RemoveFileHandler(TFileHandler *fh) overrideTUnixSystemvirtual; RemoveOnExit(TObject *obj)TSystem; RemoveSignalHandler(TSignalHandler *sh) overrideTUnixSystemvirtual; RemoveStdExceptionHandler(TStdExceptionHandler *eh)TSystemvirtual; RemoveTimer(TTimer *ti) overrideTUnixSystemvirtual; Rename(const char *from, const char *to) overrideTUnixSystemvirtual; ResetBit(UInt_t f)TObjectinline; ResetErrno()TSystemstatic; ResetSignal(ESignals sig, Bool_t reset=kTRUE) overrideTUnixSystemvirtual; ResetSignals() overrideTUnixSystemvirtual; ResetTimer(TTimer *ti) overrideTUnixSystemvirtual; Run()TSystemvirtual; SaveAs(const char *filename="""", Option_t *option="""") constTObjectvirtual; SavePrimitive(std::ostream &out, Option_t *option="""")TObjectvirtual; Select(TList *active, Long_t timeout) overrideTUnixSystemvirtual; Select(TFileHandler *fh, Long_t timeout) overrideTUnixSystemvirtual; SendBuf(int sock, const void *buffer, int length) overrideTUnixSystemvirtual; SendRaw(int sock, const void *buffer, int length, int flag) overrideTUnixSystemvirtual; SetAclicMode(EAclicMode mode)TSystemvirtual; SetBit(UInt_t f, Bool_t set)TObject; SetBit(UInt_t f)TObjectinline; SetBuildDir(const char *build_dir, Bool_t isflat=kFALSE)TSystemvirtual; SetDisplay() overrideTUnixSystemvirtual; SetDrawOption(Option_t *option="""")TObjectvirtual; SetDtorOnly(void *obj)TObjectstatic; SetDynamicPath(const char *lib) overrideTUnixSystemvirtual; Setenv(const char *name, const char *value) overrideTUnixSystemvirtual; SetErrorStr(const char *errstr)TSystem; SetFlagsDebug(const char *)TSystemvirtual; SetFlagsOpt(const char *)TSystemvirtual; SetFPEMask(Int_t mask=kDefaultMask) overrideTUnixSystemvirtual; SetIncludePath(const char *includePath)TSystemvirtual; SetLinkdefSuffix(const char *suffix)TSystemvirtual; SetLinkedLibs(const char *linkedLibs)TSystemvirtual; SetMakeE",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnixSystem-members.html:15011,timeout,timeout,15011,doc/master/classTUnixSystem-members.html,https://root.cern,https://root.cern/doc/master/classTUnixSystem-members.html,1,['timeout'],['timeout']
Safety," int length, int flag); virtual Int_tTSystem::RedirectOutput(const char* name, const char* mode = ""a"", RedirectHandle_t* h = 0); virtual TFileHandler*TSystem::RemoveFileHandler(TFileHandler* fh); voidTSystem::RemoveOnExit(TObject* obj); virtual TSignalHandler*TSystem::RemoveSignalHandler(TSignalHandler* sh); virtual TStdExceptionHandler*TSystem::RemoveStdExceptionHandler(TStdExceptionHandler* eh); virtual TTimer*TSystem::RemoveTimer(TTimer* t); virtual intTSystem::Rename(const char* from, const char* to); voidTObject::ResetBit(UInt_t f); static voidTSystem::ResetErrno(); virtual voidTSystem::ResetSignal(ESignals sig, Bool_t reset = kTRUE); virtual voidTSystem::ResetTimer(TTimer*); virtual voidTSystem::Run(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Int_tTSystem::Select(TList* active, Long_t timeout); virtual Int_tTSystem::Select(TFileHandler* fh, Long_t timeout); virtual intTSystem::SendBuf(int sock, const void* buffer, int length); virtual intTSystem::SendRaw(int sock, const void* buffer, int length, int flag); virtual voidTSystem::SetAclicMode(TSystem::EAclicMode mode); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTSystem::SetBuildDir(const char* build_dir, Bool_t isflat = kFALSE); virtual voidTSystem::SetDisplay(); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTSystem::SetDynamicPath(const char* pathname); virtual voidTSystem::Setenv(const char* name, const char* value); voidTSystem::SetErrorStr(const char* errstr); virtual voidTSystem::SetFlagsDebug(const char*); virtual voidTSystem::SetFlagsOpt(const char*); virtual Int_tTSystem::SetFPEMask(Int_t mask = kDefaultMask); virtual voidTSystem::SetIncludePath(const char* includePath); virtual voidTSystem::SetLinkdefSuffix(const char* suffix); virtual voidTSystem::SetLinkedLibs",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TDCacheSystem.html:11496,timeout,timeout,11496,root/html530/TDCacheSystem.html,https://root.cern,https://root.cern/root/html530/TDCacheSystem.html,10,['timeout'],['timeout']
Safety," integral of xf(x); 3755 // wrapped the member function EvalFirstMom in interface required by integrator using the functor class; 3756 ROOT::Math::Functor1D xfunc(&func, &TF1_EvalWrapper::EvalFirstMom);; 3757 giod.SetFunction(xfunc);; 3758 ; 3759 // estimate of mean value; 3760 Double_t xbar = giod.Integral(a, b) / norm;; 3761 ; 3762 // use different mean value in function wrapper; 3763 func.fX0 = xbar;; 3764 ROOT::Math::Functor1D xnfunc(&func, &TF1_EvalWrapper::EvalNMom);; 3765 giod.SetFunction(xnfunc);; 3766 ; 3767 Double_t res = giod.Integral(a, b) / norm;; 3768 return res;; 3769}; 3770 ; 3771 ; 3772//______________________________________________________________________________; 3773// some useful static utility functions to compute sampling points for IntegralFast; 3774////////////////////////////////////////////////////////////////////////////////; 3775/// Type safe interface (static method); 3776/// The number of sampling points are taken from the TGraph; 3777 ; 3778#ifdef INTHEFUTURE; 3779void TF1::CalcGaussLegendreSamplingPoints(TGraph *g, Double_t eps); 3780{; 3781 if (!g) return;; 3782 CalcGaussLegendreSamplingPoints(g->GetN(), g->GetX(), g->GetY(), eps);; 3783}; 3784 ; 3785 ; 3786////////////////////////////////////////////////////////////////////////////////; 3787/// Type safe interface (static method); 3788/// A TGraph is created with new with num points and the pointer to the; 3789/// graph is returned by the function. It is the responsibility of the; 3790/// user to delete the object.; 3791/// if num is invalid (<=0) NULL is returned; 3792 ; 3793TGraph *TF1::CalcGaussLegendreSamplingPoints(Int_t num, Double_t eps); 3794{; 3795 if (num <= 0); 3796 return 0;; 3797 ; 3798 TGraph *g = new TGraph(num);; 3799 CalcGaussLegendreSamplingPoints(g->GetN(), g->GetX(), g->GetY(), eps);; 3800 return g;; 3801}; 3802#endif; 3803 ; 3804 ; 3805////////////////////////////////////////////////////////////////////////////////; 3806/// Type: unsafe but fast interface fill",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TF1_8cxx_source.html:143571,safe,safe,143571,doc/master/TF1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html,2,['safe'],['safe']
Safety," internal mutex:; TCondition MyCondition(0);; You can now use the following methods of synchronization:. TCondition::Wait() waits until any thread sends a signal of the same condition instance: MyCondition.Wait() reacts on MyCondition.Signal() or MyCondition.Broadcast(). MyOtherCondition.Signal() has no effect.; If several threads wait for the signal from the same TCondition MyCondition, at MyCondition.Signal() only one thread will react; to activate a further thread another MyCondition.Signal() is required, etc.; If several threads wait for the signal from the same TCondition MyCondition, at MyCondition.Broadcast() all threads waiting for MyCondition are activated at once. In some tests of MyCondition using an internal mutex, Broadcast() activated only one thread (probably depending whether MyCondition had been signaled before). MyCondition.TimedWait(secs,nanosecs) waits for MyCondition until the absolute time in seconds and nanoseconds since beginning of the epoch (January, 1st, 1970) is reached; to use relative timeouts ‘‘delta’‘, it is required to calculate the absolute time at the beginning of waiting ‘‘now’’; for example:. Ulong_t now,then,delta; // seconds; TDatime myTime; // root daytime class; myTime.Set(); // myTime set to ""now""; now=myTime.Convert(); // to seconds since 1970. Return value wait of MyCondition.TimedWait should be 0, if MyCondition.Signal() was received, and should be nonzero, if timeout was reached. The conditions example shows how three threaded functions are synchronized using TCondition: a ROOT script condstart.C starts the threads, which are defined in a shared library (conditions.cxx, conditions.h).; 23.2.4.3 Xlib Connections; Usually Xlib is not thread safe. This means that calls to the X could fail, when it receives X-messages from different threads. The actual result depends strongly on which version of Xlib has been installed on your system. The only thing we can do here within ROOT is calling a special function XInitThreads()(whic",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1109760,timeout,timeouts,1109760,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['timeout'],['timeouts']
Safety," interpreter to funnel the Update(); 2517 // through the main thread) when the gThreadXAR mechanism does seemingly; 2518 // the same?; 2519 gInterpreter->Execute(this, IsA(), ""Update"", """");; 2520 return;; 2521 }; 2522 ; 2523 R__LOCKGUARD(gROOTMutex);; 2524 ; 2525 fUpdating = kTRUE;; 2526 ; 2527 if (!fCanvasImp->PerformUpdate(kFALSE)) {; 2528 ; 2529 if (!IsBatch()) FeedbackMode(kFALSE); // Goto double buffer mode; 2530 ; 2531 if (!UseGL() || fGLDevice == -1) PaintModified(); // Repaint all modified pad's; 2532 ; 2533 Flush(); // Copy all pad pixmaps to the screen; 2534 ; 2535 SetCursor(kCross);; 2536 }; 2537 ; 2538 fUpdating = kFALSE;; 2539}; 2540 ; 2541////////////////////////////////////////////////////////////////////////////////; 2542/// Asynchronous pad update.; 2543/// In case of web-based canvas triggers update of the canvas on the client side,; 2544/// but does not wait that real update is completed. Avoids blocking of caller thread.; 2545/// Have to be used if called from other web-based widget to avoid logical dead-locks.; 2546/// In case of normal canvas just canvas->Update() is performed.; 2547 ; 2548void TCanvas::UpdateAsync(); 2549{; 2550 fUpdated = kTRUE;; 2551 ; 2552 if (IsWeb()); 2553 fCanvasImp->PerformUpdate(kTRUE);; 2554 else; 2555 Update();; 2556}; 2557 ; 2558////////////////////////////////////////////////////////////////////////////////; 2559/// Used by friend class TCanvasImp.; 2560 ; 2561void TCanvas::DisconnectWidget(); 2562{; 2563 fCanvasID = 0;; 2564 fContextMenu = nullptr;; 2565}; 2566 ; 2567////////////////////////////////////////////////////////////////////////////////; 2568/// Check whether this canvas is to be drawn in grayscale mode.; 2569 ; 2570Bool_t TCanvas::IsGrayscale(); 2571{; 2572 return TestBit(kIsGrayscale);; 2573}; 2574 ; 2575////////////////////////////////////////////////////////////////////////////////; 2576/// Set whether this canvas should be painted in grayscale, and re-paint; 2577/// it if necessary.; 2578 ; 2579void",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCanvas_8cxx_source.html:82597,avoid,avoid,82597,doc/master/TCanvas_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCanvas_8cxx_source.html,1,['avoid'],['avoid']
Safety," intersection of two shapes contains a given point. ;  ; Int_t DistanceToPrimitive (Int_t px, Int_t py) override;  Compute minimum distance to shape vertices. ;  ; Double_t DistFromInside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=0, Double_t *safe=nullptr) const override;  Compute distance from a given point inside to the shape boundary. ;  ; Double_t DistFromOutside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=0, Double_t *safe=nullptr) const override;  Compute distance from a given point outside to the shape. ;  ; EGeoBoolType GetBooleanOperator () const override;  ; Int_t GetNpoints () override;  Returns number of vertices for the composite shape described by this intersection. ;  ; TClass * IsA () const override;  ; TGeoBoolNode * MakeClone () const override;  Make a clone of this. Pointers are preserved. ;  ; void Paint (Option_t *option) override;  Paint method. ;  ; Double_t Safety (const Double_t *point, Bool_t in=kTRUE) const override;  Compute safety distance for a union node;. ;  ; void SavePrimitive (std::ostream &out, Option_t *option="""") override;  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void Sizeof3D () const override;  Register 3D size of this shape. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TGeoBoolNode;  TGeoBoolNode ();  Default constructor. ;  ;  TGeoBoolNode (const char *expr1, const char *expr2);  Constructor called by TGeoCompositeShape providing 2 subexpressions for the 2 branches. ;  ;  TGeoBoolNode (TGeoShape *left, TGeoShape *right, TGeoMatrix *lmat=nullptr, TGeoMatrix *rmat=nullptr);  Constructor providing left and right shapes and matrices (in the Boolean operation). ;  ;  ~TGeoBoolNode () override;  Destructor. ;  ; void ClearThreadData () const;  ; void CreateThreadData (Int_t nthreads);  Create thread data ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoIntersection.html:2083,Safe,Safety,2083,doc/master/classTGeoIntersection.html,https://root.cern,https://root.cern/doc/master/classTGeoIntersection.html,2,"['Safe', 'safe']","['Safety', 'safety']"
Safety," into an array. void GetBranchOnlys(Int_t* isonly) const; Fill node copy numbers of current branch into an array. TGeoNode * CrossDivisionCell(); Cross a division cell. Distance to exit contained in fStep, current node; points to the cell node. TGeoNode * CrossBoundaryAndLocate(Bool_t downwards, TGeoNode* skipnode); Cross next boundary and locate within current node; The current point must be on the boundary of fCurrentNode. TGeoNode * FindNextBoundary(Double_t stepmax = TGeoShape::Big(), const char* path = """", Bool_t frombdr = kFALSE); Find distance to next boundary and store it in fStep. Returns node to which this; boundary belongs. If PATH is specified, compute only distance to the node to which; PATH points. If STEPMAX is specified, compute distance only in case fSafety is smaller; than this value. STEPMAX represent the step to be made imposed by other reasons than; geometry (usually physics processes). Therefore in this case this method provides the; answer to the question : ""Is STEPMAX a safe step ?"" returning a NULL node and filling; fStep with a big number.; In case frombdr=kTRUE, the isotropic safety is set to zero.; Note : safety distance for the current point is computed ONLY in case STEPMAX is; specified, otherwise users have to call explicitly TGeoManager::Safety() if; they want this computed for the current point. TGeoNode * FindNextDaughterBoundary(Double_t* point, Double_t* dir, Int_t& idaughter, Bool_t compmatrix = kFALSE); Computes as fStep the distance to next daughter of the current volume.; The point and direction must be converted in the coordinate system of the current volume.; The proposed step limit is fStep. TGeoNode * FindNextBoundaryAndStep(Double_t stepmax = TGeoShape::Big(), Bool_t compsafe = kFALSE); Compute distance to next boundary within STEPMAX. If no boundary is found,; propagate current point along current direction with fStep=STEPMAX. Otherwise; propagate with fStep=SNEXT (distance to boundary) and locate/return the next; node. T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoNavigator.html:14391,safe,safe,14391,root/html528/TGeoNavigator.html,https://root.cern,https://root.cern/root/html528/TGeoNavigator.html,6,['safe'],['safe']
Safety," is exactly the same scripts used by the continuous integration system (Jenkins).; For slc and centos systems using the gcc compiler; The instructions are a single line to source an existing script in AFS/CVMFS. In the following example OS is 'slc6', the compiler is 'gcc49', and build type is 'release'.; # on AFS:; source /afs/cern.ch/sw/lcg/app/releases/ROOT-externals/ROOT-latest/x86_64-slc6-gcc49-opt/setup.sh ; # on CVMFS; source /cvmfs/sft.cern.ch/lcg/views/ROOT-latest/x86_64-slc6-gcc49-opt/setup.csh. For all the other compilers (icc, clang,...) and systems; In this case we can use the script that is used by jenkins. The script expects 4 arguments:. LABEL is system OS and version. E.g. 'slc6', 'centos7', 'fedora14', 'mac1012', etc.; COMPILER is the compiler and version. E.g. 'icc16', 'clang37', 'native' (for the native compiler), etc.; BUILDTYPE is the type of the build. E.g. Release, Debug; EXTERNALS is the label for the set of versions of the externals. Typically 'ROOT-date', but 'ROOT-latest' is a safe bet. . git clone http://root.cern.ch/git/rootspi.git ; source rootspi/jenkins/jk-setup.sh slc6 icc14 Release ROOT-latest. Debugging an existing nightly build; Often when a build has failed in the nightlies we are required to debug it. The following are the instructions to get the correct environment for starting the debug session. As input you need to know the node name and the working directory in the build node (and the password of the sftnight account). You can get this information from the logs in Jenkins or CDash.; $ ssh sftnight@<node-name>; $ cd <work-directory>; $ source setup.sh; $ cd build; $ ctest -V -R <failing test>; or; $ make <failing target>. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. A",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/how-setup-root-externals-afscvmfs.html:3117,safe,safe,3117,d/how-setup-root-externals-afscvmfs.html,https://root.cern,https://root.cern/d/how-setup-root-externals-afscvmfs.html,1,['safe'],['safe']
Safety," is given – this number should be at least 2; Xvtx: array [nxy] of X coordinates of vertices; Yvtx: array [nxy] of Y coordinates of vertices; z: array [nz] of z plane positions; scale: array [nz] of scale factors; x0: array [nz] of x offsets; y0: array [nz] of y offsets. All XTRU shapes are correctly rendered in wire mode but can encounter difficulty when rendered as a solid with hidden surfaces. These exceptions occur if the outline shape is not a convex polygon. Both the X3D and OpenGL renderers expect polygons to be convex. The OpenGL spec specifies that points defining a polygon using the GL_POLYGON primitive may be rendered as the convex hull of that set.; Solid rendering under X3D can also give unexpected artifacts if the combination of x-y-z offsets and scales for the segments are chosen in such a manner that they represent a concave shape when sliced along a plane parallel to the z axis.; Choosing sets of point that represent a malformed polygon is not supported, but testing for such a condition is not implemented and thus it is left to the user to avoid this mistake. Definition at line 22 of file TXTRU.h. Public Member Functions;  TXTRU ();  TXTRU shape - default constructor. ;  ;  TXTRU (const char *name, const char *title, const char *material, Int_t nyx, Int_t nz);  TXTRU shape - normal constructor. ;  ;  TXTRU (const TXTRU &xtru);  TXTRU copy constructor. ;  ;  ~TXTRU () override;  TXTRU destructor deallocates arrays. ;  ; void Copy (TObject &xtru) const override;  TXTRU Copy method. ;  ; virtual void DefineSection (Int_t secNum, Float_t z, Float_t scale=1., Float_t x0=0., Float_t y0=0.);  Set z section iz information expand size of array if necessary. ;  ; virtual void DefineVertex (Int_t pointNum, Float_t x, Float_t y);  Set vertex point ipt to (x,y) expand size of array if necessary. ;  ; Int_t DistancetoPrimitive (Int_t px, Int_t py) override;  Compute the distance from point px,py to a TXTRU by calculating the closest approach to each corner. ;  ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTXTRU.html:2110,avoid,avoid,2110,doc/master/classTXTRU.html,https://root.cern,https://root.cern/doc/master/classTXTRU.html,1,['avoid'],['avoid']
Safety," is now using a new just-in-time compilation engine called OrcJIT, a development based on MCJIT. It enables interpretation of inline assembly and exceptions; it will hopefully in the near future also support interpreting thread local storage (but doesn’t at the moment).; Thanks to the new JIT, cling also comes with debug symbols for interpreted code; you can enable them with “.debug”.; Function evaluation; Function calls through TMethodCall etc have been accelerated.; llvm / clang; llvm / clang were updated to r227800. This includes everything from the clang 3.6 release.; Dictionary Generation; Detect usage of #pragma once for inlined headers.; Turn on verbosity of genreflex if the VERBOSE environment variable is defined.; Optimise forward declarations in rootmap files in order to make their interpretation faster.; Propagate attributes specified in xml selection files to selected classes even when selected through typedefs.; Optimise selection procedure caching selected declarations in the selection rules, therewith avoiding to query the AST twice.; Include in the PCH all the STL and C headers to guarantee portability of binaries from SLC6 to CC7.; I/O Libraries; I/O New functionalities. Support for forward_list and I/O of unordered stl containers.; Support for std::complex. I/O Behavior change. The I/O now properly skip the content of base class onfile that have been removed from the in-memory class layout.; The scheduling the I/O customization rules within a StreamerInfo is now as soon as possible, i.e. after all sources have been read. One significant consequence is that now when an object is stored in a split branch the rule is associtated with the branch of the last of the rule’s sources rather than the last of the object’s data member.; Properly support TStreamerInfo written by ROOT v4.00.; Fix the ordering of the keys in a TFile being written; in particular fixing the result of GetKey and FindKey which were no longer returning the lastest cycle for a TFile bei",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v604/release-notes.html:7701,avoid,avoiding,7701,doc/v604/release-notes.html,https://root.cern,https://root.cern/doc/v604/release-notes.html,1,['avoid'],['avoiding']
Safety," kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TVirtualProofPlayer(); { }. Long64_t Process(TDSet* set, const char* selector, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0). Bool_t JoinProcess(TList* workers). Long64_t Finalize(Bool_t force = kFALSE, Bool_t sync = kFALSE). Long64_t Finalize(TQueryResult* qr). Long64_t DrawSelect(TDSet* set, const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0). void HandleGetTreeHeader(TMessage* mess). void HandleRecvHisto(TMessage* mess). void StopProcess(Bool_t abort, Int_t timeout = -1). void AddInput(TObject* inp). void ClearInput(). TObject * GetOutput(const char* name) const. TList * GetOutputList() const. TList * GetInputList() const. TList * GetListOfResults() const. void AddQueryResult(TQueryResult* q). TQueryResult * GetCurrentQuery() const. TQueryResult * GetQueryResult(const char* ref). void RemoveQueryResult(const char* ref). void SetCurrentQuery(TQueryResult* q). void SetMaxDrawQueries(Int_t max). void RestorePreviousQuery(). Int_t AddOutputObject(TObject* obj). void AddOutput(TList* out). void StoreOutput(TList* out). void StoreFeedback(TObject* slave, TList* out). void Progress(Long64_t total, Long64_t processed). void Progress(TSlave* , Long64_t total, Long64_t processed). void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti). void Progress(TProofProgressInfo* ). void Progress(TSlave* , TProofProgressInfo* ). void Feedback(TList* objs). TDrawFeedb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TVirtualProofPlayer.html:13077,abort,abort,13077,root/html534/TVirtualProofPlayer.html,https://root.cern,https://root.cern/root/html534/TVirtualProofPlayer.html,2,"['abort', 'timeout']","['abort', 'timeout']"
Safety," kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Double_tfB[3]normalized direction for magnetic field; Double_tfCcurvature in XY plane; Double_tfDir[3]direction after a step; Double_tfDirInit[3]normalized initial direction; TGeoHMatrix*fMatrixtransformation of local helix frame to MARS ; Double_tfPhiphi angle; Double_tfPoint[3]point after a step; Double_tfPointInit[3]initial point; Int_tfQright/left-handed (+/- 1) - ""charge""; Double_tfSZ step of the helix / 2*PI; Double_tfStepcurrent step. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoHelix(); Dummy constructor. TGeoHelix(Double_t curvature, Double_t step, Int_t charge = 1); Normal constructor. ~TGeoHelix(); Destructor. Double_t ComputeSafeStep(Double_t epsil = 1E-6) const; Compute safe linear step that can be made such that the error; between linear-helix extrapolation is less than EPSIL. void InitPoint(Double_t x0, Double_t y0, Double_t z0); Initialize coordinates of a point on the helix. void InitPoint(Double_t* point); Set initial point on the helix. void InitDirection(Double_t dirx, Double_t diry, Double_t dirz, Bool_t is_normalized = kTRUE); Initialize particle direction (tangent on the helix in initial point). void InitDirection(Double_t* dir, Bool_t is_normalized = kTRUE); Initialize particle direction (tangent on the helix in initial point). Double_t GetTotalCurvature() const; Compute helix total curvature. void SetXYcurvature(Double_t curvature); Set XY curvature: c = 1/Rxy. void SetCharge(Int_t charge); Positive charge means left-handed helix. void SetField(Double_t bx, Double_t by, Double_t bz, Bool_t is_normalized = kTRUE); Initialize particle direction (tangent on the helix in initial point). void SetHelixStep(Double_t hstep); Set Z step of the helix on a complete turn. P",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoHelix.html:7729,safe,safe,7729,root/html528/TGeoHelix.html,https://root.cern,https://root.cern/root/html528/TGeoHelix.html,4,['safe'],['safe']
Safety," kDescending; ETupleOrdering::kUnexpected@ kUnexpected; TCling__LibraryLoadingFailedbool TCling__LibraryLoadingFailed(const std::string &errmessage, const std::string &libStem, bool permanent, bool resolved)Lookup libraries in LD_LIBRARY_PATH and DYLD_LIBRARY_PATH with mangled_name, which is extracted by er...Definition TCling.cxx:351; gIgnoredPCMNamesstatic const std::unordered_set< std::string > gIgnoredPCMNamesList of dicts that have the PCM information already in the PCH.Definition TCling.cxx:1939; s_IsLibraryLoadedstatic Bool_t s_IsLibraryLoaded(const char *libname, cling::Interpreter *fInterpreter)Definition TCling.cxx:3129; TCling__GetClassSharedLibsconst char * TCling__GetClassSharedLibs(const char *className, bool skipCore)Definition TCling.cxx:633; loadGlobalModuleIndexstatic GlobalModuleIndex * loadGlobalModuleIndex(cling::Interpreter &interp)Definition TCling.cxx:1080; TClingLookupHelper__ExistingTypeCheckbool TClingLookupHelper__ExistingTypeCheck(const std::string &tname, std::string &result)Try hard to avoid looking up in the Cling database as this could enduce an unwanted autoparsing.Definition TCling.cxx:903; HasASTFileOnDiskstatic bool HasASTFileOnDisk(clang::Module *M, const clang::Preprocessor &PP, std::string *FullFileName=nullptr)Checks if there is an ASTFile on disk for the given module M.Definition TCling.cxx:1065; TCling__UnlockCompilationDuringUserCodeExecutionvoid TCling__UnlockCompilationDuringUserCodeExecution(void *)Unlock the interpreter.Definition TCling.cxx:379; AlternateTuplestatic std::string AlternateTuple(const char *classname, const cling::LookupHelper &lh, Bool_t silent)Definition TCling.cxx:3947; R__InitStreamerInfoFactorystatic bool R__InitStreamerInfoFactory()Helper to initialize TVirtualStreamerInfo's factor early.Definition TCling.cxx:1664; TCling__AutoParseCallbackint TCling__AutoParseCallback(const char *className)Definition TCling.cxx:628; TCling__DEBUG__DCtoRecordDeclclang::RecordDecl * TCling__DEBUG__DCtoRecordDecl(cla",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:378938,avoid,avoid,378938,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['avoid'],['avoid']
Safety," kFALSE); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; voidRooAbsCollection::takeOwnership(); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidRooArgList::writeToStream(ostream& os, Bool_t compact). protected:. Bool_tRooAbsCollection::addServerClonesToList(const RooAbsArg& var); virtual voidRooAbsProxy::changeNormSet(const RooArgSet* newNormSet); virtual Bool_tchangePointer(const RooAbsCollection& newServerSet, Bool_t nameChange = kFALSE, Bool_t factoryInitMode = kFALSE); voidRooAbsCollection::clearStructureTags(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidRooAbsCollection::makeStructureTag(); voidRooAbsCollection::makeTypedStructureTag(); voidTObject::MakeZombie(); voidRooAbsCollection::safeDeleteList(); TNamed*RooAbsCollection::structureTag(); TNamed*RooAbsCollection::typedStructureTag(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. Bool_tRooAbsCollection::_allRRVAll contents are RRV; Bool_t_defShapeServerPropagate shape dirty flags?; Bool_t_defValueServerPropagate value dirty flags?; TIterator*_iter",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooListProxy.html:10731,safe,safeDeleteList,10731,root/html534/RooListProxy.html,https://root.cern,https://root.cern/root/html534/RooListProxy.html,1,['safe'],['safeDeleteList']
Safety," kFALSE); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; voidRooAbsCollection::takeOwnership(); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidRooArgList::writeToStream(ostream& os, Bool_t compact). protected:. Bool_tRooAbsCollection::addServerClonesToList(const RooAbsArg& var); virtual voidRooAbsProxy::changeNormSet(const RooArgSet* newNormSet); virtual Bool_tchangePointer(const RooAbsCollection& newServerSet, Bool_t nameChange = kFALSE, Bool_t factoryInitMode = kFALSE); voidRooAbsCollection::clearStructureTags(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidRooAbsCollection::makeStructureTag(); voidRooAbsCollection::makeTypedStructureTag(); voidTObject::MakeZombie(); voidRooAbsCollection::safeDeleteList(); TNamed*RooAbsCollection::structureTag(); TNamed*RooAbsCollection::typedStructureTag(). Data Members; public:. static RooPrintable::ContentsOptionRooPrintable::kAddress; static RooPrintable::ContentsOptionRooPrintable::kArgs; static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static RooPrintable::ContentsOptionRooPrintable::kClassName; static RooPrintable::ContentsOptionRooPrintable::kCollectionHeader; static RooPrintable::ContentsOptionRooPrintable::kExtras; static TObject::EStatusBitsTObject::kHasUUID; static RooPrintable::StyleOptionRooPrintable::kInline; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooListProxy.html:10714,safe,safeDeleteList,10714,root/html602/RooListProxy.html,https://root.cern,https://root.cern/root/html602/RooListProxy.html,2,['safe'],['safeDeleteList']
Safety," kGeoSavePrimitive = (1ULL << ( 20 )). };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Public Attributes inherited from TGeoBBox; static Bool_t DO NOT USE !The overlap detection does not work for all cases;  ; static Bool_t DEPRECATED;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TGeoTube;  TGeoTube (const TGeoTube &)=delete;  ; TGeoTube & operator= (const TGeoTube &)=delete;  ;  Protected Member Functions inherited from TGeoBBox;  TGeoBBox (const TGeoBBox &)=delete;  ; void FillBuffer3D (TBuffer3D &buffer, Int_t reqSections, Bool_t localFrame) const override;  Fill the supplied buffer, with sections in desired frame See TBuffer3D.h for explanation of sections, frame etc. ;  ; TGeoBBox & operator= (const TGeoBBox &)=delete;  ;  Protected Member Functions inherited from TGeoShape; Int_t GetBasicColor () const;  Get the basic color (0-7). ;  ; void SetOnBoundary (Bool_t);  ; void TransformPoints (Double_t *points, UInt_t NbPoints) const;  Tranform a set of points (LocalToMaster) ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . #include <TGeoHype.h>. Inheritance diagram for TGeoHype:. This browser is not able to show SVG: try Firefox",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoHype.html:25629,detect,detection,25629,doc/master/classTGeoHype.html,https://root.cern,https://root.cern/doc/master/classTGeoHype.html,1,['detect'],['detection']
Safety," kGeoSavePrimitive = (1ULL << ( 20 )). };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Public Attributes inherited from TGeoBBox; static Bool_t DO NOT USE !The overlap detection does not work for all cases;  ; static Bool_t DEPRECATED;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TGeoTube;  TGeoTube (const TGeoTube &)=delete;  ; TGeoTube & operator= (const TGeoTube &)=delete;  ;  Protected Member Functions inherited from TGeoBBox;  TGeoBBox (const TGeoBBox &)=delete;  ; void FillBuffer3D (TBuffer3D &buffer, Int_t reqSections, Bool_t localFrame) const override;  Fill the supplied buffer, with sections in desired frame See TBuffer3D.h for explanation of sections, frame etc. ;  ; TGeoBBox & operator= (const TGeoBBox &)=delete;  ;  Protected Member Functions inherited from TGeoShape; Int_t GetBasicColor () const;  Get the basic color (0-7). ;  ; void SetOnBoundary (Bool_t);  ; void TransformPoints (Double_t *points, UInt_t NbPoints) const;  Tranform a set of points (LocalToMaster) ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Attributes inherited from TGeoTube; Double_t fDz;  ; Double_t fRmax;  ; Double_t fRmin;  ;  Prot",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoEltu.html:24330,detect,detection,24330,doc/master/classTGeoEltu.html,https://root.cern,https://root.cern/doc/master/classTGeoEltu.html,1,['detect'],['detection']
Safety," kGetAlias = (1ULL << ( 2 )); , kGetBranch = (1ULL << ( 3 )); , ;   kGetEntry = (1ULL << ( 4 )); , kGetEntryWithIndex = (1ULL << ( 5 )); , kGetFriend = (1ULL << ( 6 )); , kGetFriendAlias = (1ULL << ( 7 )); , ;   kGetLeaf = (1ULL << ( 8 )); , kLoadTree = (1ULL << ( 9 )); , kPrint = (1ULL << ( 10 )); , kRemoveFriend = (1ULL << ( 11 )); , ;   kSetBranchStatus = (1ULL << ( 12 )). };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TChain; void InvalidateCurrentTree ();  Set the TTree to be reloaded as soon as possible. ;  ; void ReleaseChainProof ();  ;  Protected Member Functions inherited from TTree; virtual TBranch * BranchImp (const char *branchname, const char *classname, TClass *ptrClass, void *addobj, Int_t bufsize, Int_t splitlevel);  Same as TTree::Branch() with added check that addobj matches className. ;  ; virtual TBranch * BranchImp (const char *branchname, TClass *ptrClass, void *addobj, Int_t bufsize, Int_t splitlevel);  Same as TTree::Branch but automatic detection of the class name. ;  ; virtual TBranch * BranchImpArr (const char *branchname, EDataType datatype, std::size_t N, void *addobj, Int_t bufsize, Int_t splitlevel);  ; virtual TBranch * BranchImpRef (const char *branchname, const char *classname, TClass *ptrClass, void *addobj, Int_t bufsize, Int_t splitlevel);  Same as TTree::Branch but automatic detection of the class name. ;  ; virtual TBranch * BranchImpRef (const char *branchname, TClass *ptrClass, EDataType datatype, void *addobj, Int_t bufsize, Int_t splitlevel);  Same as TTree::Branch but automatic detection of the class name. ;  ; virtual TBranch * BronchExec (const char *name, const char *classname, void *addobj, bool isptrptr, Int_t bufsize, Int_t splitlevel);  Helper function implementing TTree::Bronch and TTree::Branch(const char *name, T &obj);. ;  ; virtual Int_t CheckBranchAddressType (TBranch *branch, TClass *ptrClass, EDataType datatype, bool p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofChain.html:51502,detect,detection,51502,doc/master/classTProofChain.html,https://root.cern,https://root.cern/doc/master/classTProofChain.html,1,['detect'],['detection']
Safety," kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TTimefAbsTimeabsolute time out time in ms; TStringfCommandinterpreter command to be executed; Bool_tfIntSyscallstrue is a-synchronous timer is to interrupt system calls; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; TObject*fObjectobject to be notified (if any); Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Bool_tfSynctrue if synchrounous timer; TTimefTimetime out time in ms; UInt_tfTimeIDthe system ID of this timer (for WIN32); Bool_tfTimeouttrue if timer has timed out; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTimer(Long_t milliSec = 0, Bool_t mode = kTRUE); Create timer that times out in ms milliseconds. If milliSec is 0; then the timeout will be the minimum timeout (see TSystem::ESysConstants,; i.e. 10 ms). If mode == kTRUE then the timer is synchronous else; a-synchronous. The default is synchronous. Add a timer to the system; eventloop by calling TurnOn(). Set command to be executed from Notify(); or set the object whose HandleTimer() method will be called via Notify(),; derive from TTimer and override Notify() or connect slots to the; signals Timeout(), TurnOn() and TurnOff(). TTimer(TObject* obj, Long_t milliSec, Bool_t mode = kTRUE); Create timer that times out in ms milliseconds. If mode == kTRUE then; the timer is synchronous else a-synchronous. The default is synchronous.; Add a timer to the system eventloop by calling TurnOn().; The object's HandleTimer() will be called by Notify(). TTimer(const char* command, Long_t milliSec, Bool_t mode = kTRUE); Create timer that times out in ms milliseconds. If mode == kTRUE then; the timer is synchronous else a-synchronous. The default is synchronous.; Add a timer to the system event",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTimer.html:11524,timeout,timeout,11524,root/html528/TTimer.html,https://root.cern,https://root.cern/root/html528/TTimer.html,8,['timeout'],['timeout']
Safety," kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . #include <TSelector.h>. Inheritance diagram for TSelector:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Enumeration Documentation. ◆ EAbort. enum TSelector::EAbort. EnumeratorkContinue ; kAbortProcess ; kAbortFile . Definition at line 34 of file TSelector.h. Constructor & Destructor Documentation. ◆ TSelector() [1/2]. TSelector::TSelector ; (; const TSelector & ; ). private . ◆ TSelector() [2/2]. TSelector::TSelector ; (; ). Default selector ctor. ; Definition at line 89 of file TSelector.cxx. ◆ ~TSelector(). TSelector::~TSelector ; (; ). override . Selector destructor. ; Definition at line 102 of file TSelector.cxx. Member Function Documentation. ◆ Abort(). void TSelector::Abort ; (; const char * ; why, . EAbort ; what = kAbortProcess . ). virtual . Abort processing. ; If what = kAbortProcess, the Process() loop will be aborted. If what = kAbortFile, the current file in a chain will be aborted and the processing will continue with the next file, if there is no next file then Process() will be aborted. Abort() can also be called from Begin(), SlaveBegin(), Init() and Notify(). After abort the SlaveTerminate() and Terminate() are always called. The abort flag can be checked in these methods using GetAbort(). ; Definition at line 116 of file TSelector.cxx. ◆ Begin(). virtual void TSelector::Begin ; (; TTree * ; ). inlinevirtual . Reimplemented in TSelEvent, TSelVerifyDataSet, TSelEventGen, TSelHandleDataSet, TProofDraw, h1analysisTreeReader, TProofDrawHist, TProofDrawProfile, TProofDrawProfile2D, TSelHist, TSelectorDraw, TSelectorEntries, and h1analysis.; Definition at line 54 of file TSelector.h. ◆ Class(). static TClass * TSelector::Class ; (; ). static . Returns",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSelector.html:15356,Abort,Abort,15356,doc/master/classTSelector.html,https://root.cern,https://root.cern/doc/master/classTSelector.html,1,['Abort'],['Abort']
Safety," kWriteDelete; };. protected:. TSelector::EAbortfAbortAbort status; TList*fInputList of objects available during processing; TObject*fObject!Current object if processing object (vs. TTree); TStringfOptionOption given to TTree::Process; TSelectorList*fOutput!List of objects created during processing; Long64_tfStatusSelector status. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSelector(); Default selector ctor. ~TSelector(); Selector destructor. void Abort(const char* why, TSelector::EAbort what = kAbortProcess); Abort processing. If what = kAbortProcess, the Process() loop will be; aborted. If what = kAbortFile, the current file in a chain will be; aborted and the processing will continue with the next file, if there; is no next file then Process() will be aborted. Abort() can also be; called from Begin(), SlaveBegin(), Init() and Notify(). After abort; the SlaveTerminate() and Terminate() are always called. The abort flag; can be checked in these methods using GetAbort(). TSelector * GetSelector(const char* filename); The code in filename is loaded (interpreted or compiled, see below),; filename must contain a valid class implementation derived from TSelector. If filename is of the form file.C, the file will be interpreted.; If filename is of the form file.C++, the file file.C will be compiled; and dynamically loaded. The corresponding binary file and shared; library will be deleted at the end of the function.; If filename is of the form file.C+, the file file.C will be compiled; and dynamically loaded. At next call, if file.C is older than file.o; and file.so, the file.C is not compiled, only file.so is loaded. The static function returns a pointer to a TSelector object. Bool_t IsStandardDraw(const char* selec); Find out if this is a standard selection used for Draw actions; (either TSelectorDraw, TProofDraw or deriving from them). Bool_t ProcessCut(Long64_t ); This method is called before processing entry. It is the u",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TSelector.html:9552,abort,abort,9552,root/html534/TSelector.html,https://root.cern,https://root.cern/root/html534/TSelector.html,1,['abort'],['abort']
Safety," layer. ; Definition at line 305 of file Net.h. ◆ Loss() [2/2]. template<typename Architecture_t , typename Layer_t > . auto TMVA::DNN::TNet< Architecture_t, Layer_t >::Loss ; (; Matrix_t & ; X, . const Matrix_t & ; Y, . const Matrix_t & ; weights, . bool ; applyDropout = false, . bool ; includeRegularization = true . ). inline . Propagate the input batch X through the net and evaluate the error function for the resulting activations of the output layer. ; Definition at line 320 of file Net.h. ◆ Prediction() [1/2]. template<typename Architecture_t , typename Layer_t > . void TMVA::DNN::TNet< Architecture_t, Layer_t >::Prediction ; (; Matrix_t & ; Y_hat, . EOutputFunction ; f . ); const. inline . Compute the neural network prediction obtained from applying the output function f to the activation of the last layer in the network. ; Definition at line 339 of file Net.h. ◆ Prediction() [2/2]. template<typename Architecture_t , typename Layer_t > . void TMVA::DNN::TNet< Architecture_t, Layer_t >::Prediction ; (; Matrix_t & ; Y_hat, . Matrix_t & ; X, . EOutputFunction ; f . ). inline . Compute the neural network prediction obtained from forwarding the batch X through the neural network and applying the output function f to the activation of the last layer in the network. ; Definition at line 329 of file Net.h. ◆ Print(). template<typename Architecture_t , typename Layer_t > . void TMVA::DNN::TNet< Architecture_t, Layer_t >::Print. Definition at line 392 of file Net.h. ◆ SetBatchSize(). template<typename Architecture_t , typename Layer_t = TLayer<Architecture_t>> . void TMVA::DNN::TNet< Architecture_t, Layer_t >::SetBatchSize ; (; size_t ; batchSize). inline . Definition at line 148 of file Net.h. ◆ SetDropoutProbabilities(). template<typename Architecture_t , typename Layer_t > . void TMVA::DNN::TNet< Architecture_t, Layer_t >::SetDropoutProbabilities ; (; const std::vector< Double_t > & ; probabilities). Definition at line 378 of file Net.h. ◆ SetInputWidth(). template<ty",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TNet.html:14220,Predict,Prediction,14220,doc/master/classTMVA_1_1DNN_1_1TNet.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TNet.html,1,['Predict'],['Prediction']
Safety," len, struct mg_response_info *ri);  ; static int parse_match_net (const struct vec *vec, const union usa *sa, int no_strict);  ; static int parse_port_string (const struct vec *vec, struct socket *so, int *ip_version);  ; static int parse_range_header (const char *header, int64_t *a, int64_t *b);  ; static int prepare_cgi_environment (struct mg_connection *conn, const char *prog, struct cgi_environment *env, unsigned char cgi_config_idx);  ; static int print_dav_dir_entry (struct de *de, void *data);  ; static int print_dir_entry (struct de *de);  ; static int print_props (struct mg_connection *conn, const char *uri, const char *name, struct mg_file_stat *filep);  ; static void process_new_connection (struct mg_connection *conn);  ; static void produce_socket (struct mg_context *ctx, const struct socket *sp);  ; static int pull_all (FILE *fp, struct mg_connection *conn, char *buf, int len);  ; static int pull_inner (FILE *fp, struct mg_connection *conn, char *buf, int len, double timeout);  ; static int push_all (struct mg_context *ctx, FILE *fp, SOCKET sock, SSL *ssl, const char *buf, int len);  ; static int push_inner (struct mg_context *ctx, FILE *fp, SOCKET sock, SSL *ssl, const char *buf, int len, double timeout);  ; static int put_dir (struct mg_connection *conn, const char *path);  ; static void put_file (struct mg_connection *conn, const char *path);  ; static int read_auth_file (struct mg_file *filep, struct read_auth_file_struct *workdata, int depth);  ; static int read_message (FILE *fp, struct mg_connection *conn, char *buf, int bufsiz, int *nread);  ; static void redirect_to_https_port (struct mg_connection *conn, int port);  ; static int refresh_trust (struct mg_connection *conn);  ; static void release_handler_ref (struct mg_connection *conn, struct mg_handler_info *handler_info);  ; static void remove_bad_file (const struct mg_connection *conn, const char *path);  ; static int remove_directory (struct mg_connection *conn, const char *dir);  ; static",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c.html:27074,timeout,timeout,27074,doc/master/civetweb_8c.html,https://root.cern,https://root.cern/doc/master/civetweb_8c.html,1,['timeout'],['timeout']
Safety," line 6880 of file TProofServ.cxx. ◆ CreateServer(). Int_t TProofServ::CreateServer ; (; ). virtual . Finalize the server setup. ; If master, create the TProof instance to talk to the worker or submaster nodes. Return 0 on success, -1 on error ; Reimplemented in TProofServLite.; Definition at line 790 of file TProofServ.cxx. ◆ DeclFileName(). static const char * TProofServ::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 344 of file TProofServ.h. ◆ DeletePlayer(). void TProofServ::DeletePlayer ; (; ). protectedvirtual . Delete player instance. ; Definition at line 5907 of file TProofServ.cxx. ◆ DisableTimeout(). virtual void TProofServ::DisableTimeout ; (; ). inlinevirtual . Definition at line 316 of file TProofServ.h. ◆ EnableTimeout(). virtual void TProofServ::EnableTimeout ; (; ). inlinevirtual . Definition at line 317 of file TProofServ.h. ◆ ErrorHandler(). void TProofServ::ErrorHandler ; (; Int_t ; level, . Bool_t ; abort, . const char * ; location, . const char * ; msg . ). static . The PROOF error handler function. ; It prints the message on fgErrorHandlerFile and if abort is set it aborts the application. ; Definition at line 5755 of file TProofServ.cxx. ◆ FilterLocalroot(). void TProofServ::FilterLocalroot ; (; TString & ; path, . const char * ; dsrv = ""root://dum/"" . ). static . If 'path' is local and 'dsrv' is Xrootd, apply 'path.Localroot' settings, if any. ; The final path via the server is dsrv+path. ; Definition at line 6966 of file TProofServ.cxx. ◆ FlushLogFile(). void TProofServ::FlushLogFile ; (; ). Reposition the read pointer in the log file to the very end. ; This allows to ""hide"" useful debug messages during normal operations while preserving the possibility to have them in case of problems. ; Definition at line 6013 of file TProofServ.cxx. ◆ Fork(). Int_t TProofServ::Fork ; (; ). protectedvirtual . Fork a child. ; If successful, return 0 in the child process and the child pid in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofServ.html:35420,abort,abort,35420,doc/master/classTProofServ.html,https://root.cern,https://root.cern/doc/master/classTProofServ.html,1,['abort'],['abort']
Safety," line 975 of file TSocket.cxx. ◆ RecvRaw(). Int_t TSocket::RecvRaw ; (; void * ; buffer, . Int_t ; length, . ESendRecvOptions ; opt = kDefault . ). virtual . Receive a raw buffer of specified length bytes. ; Using option kPeek one can peek at incoming data. Returns number of received bytes. Returns -1 in case of error. In case of opt == kOob: -2 means EWOULDBLOCK and -3 EINVAL. In case of non-blocking mode (kNoBlock) -4 means EWOULDBLOCK. Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET). ; Reimplemented in TServerSocket, TPSocket, and TSSLSocket.; Definition at line 898 of file TSocket.cxx. ◆ RecvStreamerInfos(). Bool_t TSocket::RecvStreamerInfos ; (; TMessage * ; mess). protected . Receive a message containing streamer infos. ; In case the message contains streamer infos they are imported, the message will be deleted and the method returns kTRUE. ; Definition at line 928 of file TSocket.cxx. ◆ Select(). Int_t TSocket::Select ; (; Int_t ; interest = kRead, . Long_t ; timeout = -1 . ). virtual . Waits for this socket to change status. ; If interest=kRead, the socket will be watched to see if characters become available for reading; if interest=kWrite the socket will be watched to see if a write will not block. The argument 'timeout' specifies a maximum time to wait in millisec. Default no timeout. Returns 1 if a change of status of interest has been detected within timeout; 0 in case of timeout; < 0 if an error occured. ; Definition at line 443 of file TSocket.cxx. ◆ Send() [1/4]. Int_t TSocket::Send ; (; const char * ; str, . Int_t ; kind = kMESS_STRING . ). virtual . Send a character string buffer. ; Use kind to set the TMessage ""what"" field. Returns the number of bytes in the string str that were sent and -1 in case of error. In case the kind has been or'ed with kMESS_ACK, the call will only return after having received an acknowledgement, making the sending process synchronous. ; Reimplemented in TServerSocket, TPSocket, and TSSLSocket.; Definitio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSocket.html:34261,timeout,timeout,34261,doc/master/classTSocket.html,https://root.cern,https://root.cern/doc/master/classTSocket.html,1,['timeout'],['timeout']
Safety," location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. TSelector(const TSelector&); TSelector&operator=(const TSelector&). Data Members; public:. enum EAbort { kContinue; kAbortProcess; kAbortFile; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TSelector::EAbortfAbortabort status; TList*fInputlist of objects available during processing; TObject*fObjectcurrent object if processing object (vs. TTree); TStringfOptionoption given to TTree::Process; TSelectorList*fOutputlist of objects created during processing; Long64_tfStatusselector status. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSelector(); Default selector ctor. ~TSelector(); Selector destructor. void Abort(const char* why, TSelector::EAbort what = kAbortProcess); Abort processing. If what = kAbortProcess, the Process() loop will be; aborted. If what = kAbortFile, the current file in a chain will be; aborted and the processing will continue with the next file, if there; is no next file then Process() will be aborted. Abort() can also be; called from Begin(), SlaveBegin(), Init() and Notify(). After abort; the SlaveTerminate() and Terminate() are always called. The abort flag; can be checked in these methods using GetAbort(). TSelector * GetSelector(const char* filename); The code in filename is loaded (interpreted or compiled, see below),; filename must contain a valid class implementation derived from TSelector. If filename is of the form file.C, the file will be interpreted.; If filename is of the form file.C++, the file file.C will be compiled; and dynamically loaded. The corresponding binary file and shared; library will be deleted at the end of the function.; If filename is of the form file.C+, the file file.C will",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSelector.html:8956,Abort,Abort,8956,root/html528/TSelector.html,https://root.cern,https://root.cern/root/html528/TSelector.html,6,['Abort'],['Abort']
Safety," low level read operation.; Returns kTRUE in case of failure. Bool_t ReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); Read the nbuf blocks described in arrays pos and len,; where pos[i] is the seek position of block i of length len[i].; Note that for nbuf=1, this call is equivalent to TFile::ReafBuffer.; This function is overloaded by TNetFile, TWebFile, etc.; Returns kTRUE in case of failure. Int_t ReadBufferViaCache(char* buf, Int_t len); Read buffer via cache. Returns 0 if the requested block is; not in the cache, 1 in case read via cache was successful,; 2 in case read via cache failed. void ReadFree(); Read the FREE linked list.; Every file has a linked list (fFree) of free segments.; This linked list has been written on the file via WriteFree; as a single data record. TProcessID * ReadProcessID(UShort_t pidf); The TProcessID with number pidf is read from this file.; If the object is not already entered in the gROOT list, it is added. Int_t Recover(); Attempt to recover file if not correctly closed.; The function returns the number of keys that have been recovered.; If no keys can be recovered, the file will be declared Zombie by; the calling function. This function is automatically called when; opening a file. If the file is open in read only mode, the file is not modified.; If open in update mode and the function finds something to recover,; a new directory header is written to the file. When opening the file gain; no message from Recover will be reported.; If keys have been recovered, the file is usable and you can safely; read the corresponding objects.; If the file is not usable (a zombie), you can test for this case; with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {file is unusable); If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; You can test if the file has been recovered with; if (f.TestBit(TFile::kRecovered)) {.. the file has been recovered}. When writing TTrees to a file, it is impor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFile.html:34492,Recover,Recover,34492,root/html528/TFile.html,https://root.cern,https://root.cern/root/html528/TFile.html,12,"['Recover', 'recover']","['Recover', 'recover']"
Safety," master. Reference Guide ; .  . Loading...; Searching...; No Matches. SparseData.cxx. Go to the documentation of this file. 1// @(#)root/mathcore:$Id$; 2// Author: David Gonzalez Maline Wed Aug 28 15:33:03 2009; 3 ; 4/**********************************************************************; 5 * *; 6 * Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; 7 * *; 8 * *; 9 **********************************************************************/; 10 ; 11// Implementation file for class BinData; 12 ; 13#include <iostream>; 14#include <iterator>; 15#include <algorithm>; 16 ; 17#include <vector>; 18#include <list>; 19 ; 20#include <stdexcept>; 21 ; 22#include <cmath>; 23#include <limits>; 24 ; 25#include ""Fit/BinData.h""; 26#include ""Fit/SparseData.h""; 27 ; 28using std::cout, std::endl, std::vector, std::list, std::ostream, std::ostream_iterator;; 29 ; 30namespace ROOT {; 31 ; 32 namespace Fit {; 33 ; 34 //This class is a helper. It represents a bin in N; 35 //dimensions. The change in the name is to avoid name collision.; 36 class Box; 37 {; 38 public:; 39 // Creates a Box with limits specified by the vectors and; 40 // content=value and error=error; 41 Box(const vector<double>& min, const vector<double>& max,; 42 const double value = 0.0, const double error = 1.0):; 43 fMin(min), fMax(max), fVal(value), fError(error); 44 { }; 45 ; 46 // Compares to Boxes to see if they are equal in all its; 47 // variables. This is to be used by the std::find algorithm; 48 bool operator==(const Box& b); 49 { return (fMin == b.fMin) && (fMax == b.fMax); 50 && (fVal == b.fVal) && (fError == b.fError); }; 51 ; 52 // Get the list of minimum coordinates; 53 const vector<double>& GetMin() const { return fMin; }; 54 // Get the list of maximum coordinates; 55 const vector<double>& GetMax() const { return fMax; }; 56 // Get the value of the Box; 57 double GetVal() const { return fVal; }; 58 // Get the error of the Box; 59 double GetError() const { return fError; }; 60 ; 61 // Add an amount to the cont",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/SparseData_8cxx_source.html:1070,avoid,avoid,1070,doc/master/SparseData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/SparseData_8cxx_source.html,1,['avoid'],['avoid']
Safety," means left-handed helix. ; Definition at line 195 of file TGeoHelix.cxx. ◆ SetField(). void TGeoHelix::SetField ; (; Double_t ; bx, . Double_t ; by, . Double_t ; bz, . Bool_t ; is_normalized = kTRUE . ). Initialize particle direction (tangent on the helix in initial point) ; Definition at line 211 of file TGeoHelix.cxx. ◆ SetHelixStep(). void TGeoHelix::SetHelixStep ; (; Double_t ; hstep). Set Z step of the helix on a complete turn. Positive or null. ; Definition at line 227 of file TGeoHelix.cxx. ◆ SetXYcurvature(). void TGeoHelix::SetXYcurvature ; (; Double_t ; curvature). Set XY curvature: c = 1/Rxy. ; Definition at line 178 of file TGeoHelix.cxx. ◆ Step(). void TGeoHelix::Step ; (; Double_t ; step). Make a step from current point along the helix and compute new point, direction and angle To reach a plane/ shape boundary, one has to: . Compute the safety to the plane/boundary; Define / update a helix according local field and particle state (position, direction, charge); Compute the magnetic safety (maximum distance for which the field can be considered constant); Call TGeoHelix::Step() having as argument the minimum between 1. and 3.; Repeat from 1. until the step to be made is small enough.; Add to the total step the distance along a straight line from the last point to the plane/shape boundary . Definition at line 260 of file TGeoHelix.cxx. ◆ StepToPlane(). Double_t TGeoHelix::StepToPlane ; (; Double_t * ; point, . Double_t * ; norm . ). Propagate initial point up to a given Z position in MARS. ; Definition at line 293 of file TGeoHelix.cxx. ◆ Streamer(). void TGeoHelix::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void TGeoHelix::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 73 of file TGeoHelix.h. ◆ UpdateHelix(). void TGeoHelix::UpdateHelix ; (; ). Update the local helix matrix. ; Definition at line 352 of file TGeoHeli",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoHelix.html:18358,safe,safety,18358,doc/master/classTGeoHelix.html,https://root.cern,https://root.cern/doc/master/classTGeoHelix.html,2,['safe'],['safety']
Safety," members ; TRobustEstimator Class ReferenceMath » Legacy Physics Classes. ; NoteDespite being in the group of Legacy statistics classes, TRobustEstimator is still useful and no drop-in replacement exists for it.; Minimum Covariance Determinant Estimator - a Fast Algorithm invented by Peter J.Rousseeuw and Katrien Van Dreissen ""A Fast Algorithm for the Minimum covariance Determinant Estimator"" Technometrics, August 1999, Vol.41, NO.3; What are robust estimators? ""An important property of an estimator is its robustness. An estimator; is called robust if it is insensitive to measurements that deviate; from the expected behaviour. There are 2 ways to treat such deviating; measurements: one may either try to recognise them and then remove; them from the data sample; or one may leave them in the sample, taking; care that they do not influence the estimate unduly. In both cases robust; estimators are needed...Robust procedures compensate for systematic errors; as much as possible, and indicate any situation in which a danger of not being; able to operate reliably is detected."" R.Fruhwirth, M.Regler, R.K.Bock, H.Grote, D.Notz ""Data Analysis Techniques for High-Energy Physics"", 2nd edition; What does this algorithm do? It computes a highly robust estimator of multivariate location and scatter. Then, it takes those estimates to compute robust distances of all the data vectors. Those with large robust distances are considered outliers. Robust distances can then be plotted for better visualization of the data.; How does this algorithm do it? The MCD objective is to find h observations(out of n) whose classical covariance matrix has the lowest determinant. The MCD estimator of location is then the average of those h points and the MCD estimate of scatter is their covariance matrix. The minimum(and default) h = (n+nvariables+1)/2 so the algorithm is effective when less than (n+nvar+1)/2 variables are outliers. The algorithm also allows for exact fit situations - that is, when h or",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTRobustEstimator.html:1314,detect,detected,1314,doc/master/classTRobustEstimator.html,https://root.cern,https://root.cern/doc/master/classTRobustEstimator.html,1,['detect'],['detected']
Safety," method is technology specific and is overwritten by derived; classes. ~TXSlave(); Destroy slave. void Close(Option_t* opt = """"); Close slave socket. Int_t Ping(); Ping the remote master or slave servers.; Returns 0 if ok, -1 if it did not ping or in case of error. void Touch(); Touch the client admin file to proof we are alive. void Interrupt(Int_t type); Send interrupt to master or slave servers.; Returns 0 if ok, -1 in case of error. void StopProcess(Bool_t abort, Int_t timeout); Sent stop/abort request to PROOF server. It will be; processed asynchronously by a separate thread. Int_t GetProofdProtocol(TSocket* s); Find out the remote proofd protocol version.; Returns -1 in case of error. TObjString * SendCoordinator(Int_t kind, const char* msg = 0, Int_t int2 = 0); Send message to intermediate coordinator.; If any output is due, this is returned as a generic message. void SetAlias(const char* alias); Set an alias for this session. If reconnection is supported, the alias; will be communicated to the remote coordinator so that it can be recovered; when reconnecting. Int_t SendGroupPriority(const char* grp, Int_t priority); Communicate to the coordinator the priprity of the group to which the; user belongs; Return 0 on success. Bool_t HandleError(const void* in = 0); Handle error on the input socket. Bool_t HandleInput(const void* in = 0); Handle asynchronous input on the socket. void SetInterruptHandler(Bool_t on = kTRUE); Set/Unset the interrupt handler. void FlushSocket(); Clean any input on the socket. TXSlave(const char* url, const char* ord, Int_t perf, const char* image, TProof* proof, Int_t stype, const char* workdir, const char* msd, Int_t nwk = 1). » Author: G. Ganis Oct 2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/proofx:$Id$ » Last generated: 2015-06-02 16:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TXSlave.html:11254,recover,recovered,11254,root/html604/TXSlave.html,https://root.cern,https://root.cern/root/html604/TXSlave.html,1,['recover'],['recovered']
Safety," method is technology specific and is overwritten by derived; classes. ~TXSlave(); Destroy slave. void Close(Option_t* opt = """"); Close slave socket. Int_t Ping(); Ping the remote master or slave servers.; Returns 0 if ok, -1 if it did not ping or in case of error. void Touch(); Touch the client admin file to proof we are alive. void Interrupt(Int_t type); Send interrupt to master or slave servers.; Returns 0 if ok, -1 in case of error. void StopProcess(Bool_t abort, Int_t timeout); Sent stop/abort request to PROOF server. It will be; processed asynchronously by a separate thread. Int_t GetProofdProtocol(TSocket* s); Find out the remote proofd protocol version.; Returns -1 in case of error. TObjString * SendCoordinator(Int_t kind, const char* msg = 0, Int_t int2 = 0); Send message to intermediate coordinator.; If any output is due, this is returned as a generic message. void SetAlias(const char* alias); Set an alias for this session. If reconnection is supported, the alias; will be communicated to the remote coordinator so that it can be recovered; when reconnecting. Int_t SendGroupPriority(const char* grp, Int_t priority); Communicate to the coordinator the priprity of the group to which the; user belongs; Return 0 on success. Bool_t HandleError(const void* in = 0); Handle error on the input socket. Bool_t HandleInput(const void* in = 0); Handle asynchronous input on the socket. void SetInterruptHandler(Bool_t on = kTRUE); Set/Unset the interrupt handler. void FlushSocket(); Clean any input on the socket. TXSlave(const char* url, const char* ord, Int_t perf, const char* image, TProof* proof, Int_t stype, const char* workdir, const char* msd, Int_t nwk = 1). » Author: G. Ganis Oct 2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/proofx:$Id$ » Last generated: 2015-06-30 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TXSlave.html:11254,recover,recovered,11254,root/html602/TXSlave.html,https://root.cern,https://root.cern/root/html602/TXSlave.html,1,['recover'],['recovered']
Safety," method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoParaboloid&operator=(const TGeoParaboloid&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidSetParaboloidDimensions(Double_t rlo, Double_t rhi, Double_t dz); virtu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoParaboloid.html:8779,Safe,SafetyPhi,8779,root/html602/TGeoParaboloid.html,https://root.cern,https://root.cern/root/html602/TGeoParaboloid.html,2,['Safe'],['SafetyPhi']
Safety," methods.; 65template <typename T>; 66constexpr auto hasBeginEnd(int) -> decltype(std::begin(std::declval<T>()), std::end(std::declval<T>()), true); 67{; 68 return true;; 69}; 70 ; 71template <typename>; 72constexpr bool hasBeginEnd(...); 73{; 74 return false;; 75}; 76 ; 77template <typename T, typename WrappedIterator_t, bool isDynamic>; 78class TypedIter {; 79 ; 80public:; 81 TypedIter(WrappedIterator_t const &iter) : fIter{iter} {}; 82 ; 83 TypedIter &operator++(); 84 {; 85 ++fIter;; 86 return *this;; 87 }; 88 TypedIter operator++(int); 89 {; 90 TypedIter tmp(*this);; 91 operator++();; 92 return tmp;; 93 }; 94 bool operator==(const TypedIter &rhs) const { return fIter == rhs.fIter; }; 95 bool operator!=(const TypedIter &rhs) const { return fIter != rhs.fIter; }; 96 ; 97 void swap(TypedIter &other) { fIter.swap(other.fIter); }; 98 ; 99 // We want to know at compile time whether dynamic_cast or static_cast is; 100 // used. First of all to avoid overhead, but also to avoid a compiler; 101 // error when using dynamic_cast on a non-polymorphic class. In C++17,; 102 // this can be done easily with `if constexpr`, but for the older; 103 // standards we have to use a more verbose alternative. Both ways are; 104 // explicitely implemented for different standards, so that when the; 105 // minimum C++ standard for ROOT is raised to C++17 it's easy to remember; 106 // that we can avoid much boilerplate code in this file.; 107#if (__cplusplus < 201700L); 108 T operator*() { return ROOT::Internal::RCast<T, isDynamic>::cast(*fIter); }; 109#else; 110 T operator*(); 111 {; 112 if constexpr (isDynamic) {; 113 return dynamic_cast<T>(*fIter);; 114 } else {; 115 if constexpr (std::is_polymorphic<RBaseType<T>>::value) {; 116 assert(dynamic_cast<T>(*fIter));; 117 }; 118 return static_cast<T>(*fIter);; 119 }; 120 }; 121#endif; 122 ; 123private:; 124 WrappedIterator_t fIter;; 125};; 126 ; 127} // namespace Internal; 128 ; 129/// Wraps any collection that can be used in range-based loops a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RRangeCast_8hxx_source.html:2763,avoid,avoid,2763,doc/master/RRangeCast_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RRangeCast_8hxx_source.html,4,['avoid'],['avoid']
Safety," mode.Definition TBuffer.cxx:302; TBuffer::WriteClassBuffervirtual Int_t WriteClassBuffer(const TClass *cl, void *pointer)=0; TBuffer::fVersionInt_t fVersionDefinition TBuffer.h:49; TBuffer::LengthInt_t Length() constDefinition TBuffer.h:100; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TProcessIDA TProcessID identifies a ROOT job in a unique way in time and space.Definition TProcessID.h:74; TProcessID::GetPIDstatic TProcessID * GetPID()static: returns pointer to current TProcessIDDefinition TProcessID.cxx:343; TStorage::ReAllocCharstatic char * ReAllocChar(char *vp, size_t size, size_t oldsize)Reallocate (i.e.Definition TStorage.cxx:228; TVirtualArrayWrapper around an object and giving indirect access to its content even if the object is not of a cla...Definition TVirtualArray.h:27; bool; double; int; unsigned int; nconst Int_t nDefinition legend1.C:16; ROOT::Internal::DefaultStreamervoid DefaultStreamer(TBuffer &R__b, const TClass *cl, void *objpointer)Default streamer implementation used by ClassDefInline to avoid requirement to include TBuffer....Definition TBuffer.cxx:30; lTLine lDefinition textangle.C:4. corebasesrcTBuffer.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:05 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBuffer_8cxx_source.html:22179,avoid,avoid,22179,doc/master/TBuffer_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBuffer_8cxx_source.html,1,['avoid'],['avoid']
Safety," moved into Doxygen. Still some work and polish has to be done but the reference guide in this new format is now online and can be seen from the ROOT home page.; Core Libraries; Dictionary generation; Fixed the dictionary generation in the case of class inside a namespace marked inlined.; Added mechanisms to stop the dictionary generation while parsing the XML and while selecting in presence of duplicates.; Fix ROOT-7760 : fully allow the usage of the dylib extension on OSx.; Fix ROOT-7723 : allow IOCtors to have as argument a ref to a type called void.; We added a dictionary for map as part of the default STL dictionary.; We added support for template parameter packs in class name involved in the I/O.; Thread safety and thread awareness; We added the function TMethodCall::GetCallFunc to allow direct access to the function wrapper.; We reduced thread serialization in TClass::GetCheckSum, TClass::GetBaseClassOffset and TClass::Property; TObjArray::Delete was updated to allow its caller to explicitly avoid costly checks (extra RecursiveRemove and lock); We removed the need to create a TThread object per thread in a multi-threaded application. Now ROOT can be used with any threading model (e.g. OpenMP, STL threads, TBB) transparently. All the internal synchronisation mechanisms of ROOT are activated by a single call: ROOT::EnableThreadSafety() which is the successor of the existing TThread::Initialize. This call must take place if ROOT needs to be used in a thread safe manner.; The implementation of TSemaphore was redone based on C++11 thread primitive in order to prevent cases where some of request post were lost.; TDirectory::TContext; We added a default constructor to TDirectory::TContext which record the current directory and will restore it at destruction time and does not change the current directory.; The constructor for TDirectory::TContext that takes a single TDirectory pointer as an argument was changed to set gDirectory to zero when being passed a null pointe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v606/release-notes.html:3596,avoid,avoid,3596,doc/v606/release-notes.html,https://root.cern,https://root.cern/doc/v606/release-notes.html,1,['avoid'],['avoid']
Safety," namespace  TDS;  ; namespace  TreeUtils;  Namespace hosting functions and classes to retrieve tree information for internal use. ;  ; namespace  TThreadedObjectUtils;  ; namespace  VecOps;  . Classes; class  ClassDefGenerateInitInstanceLocalInjector;  ; class  DictSelectionReader;  ; struct  GetFunctorType;  Internal class used by TF1 for obtaining the type from a functor out of the set of valid operator() signatures. More...;  ; struct  GetFunctorType< T(F::*)(const T *, const double *) const >;  ; struct  GetFunctorType< T(F::*)(const T *, const double *)>;  ; struct  GetFunctorType< T(F::*)(T *, double *) const >;  ; struct  GetFunctorType< T(F::*)(T *, double *)>;  ; struct  InterpreterMutexRegistrationRAII;  ; struct  ParsingStateRAII;  RAII used to store Parser, Sema, Preprocessor state for recursive parsing. More...;  ; struct  RBaseType;  ; struct  RCast;  ; struct  RCast< T, false, false >;  ; struct  RCast< T, false, true >;  ; class  RConcurrentHashColl;  This class is a thread-safe associative collection connecting a 256 bits digest/hash to a collection of uid (integer) This is used in the handling of the StreamerInfo record in TFile. More...;  ; struct  RDavixFileDes;  ; struct  RecurseCounts;  ; struct  RHashMap;  ; class  RIoUring;  ; class  RRawFile;  The RRawFile provides read-only access to local and remote files. More...;  ; class  RRawFileDavix;  The RRawFileDavix class provides read-only access to remote non-ROOT files. More...;  ; class  RRawFileNetXNG;  The RRawFileNetXNG class provides read-only access to remote files using root/roots protocol. More...;  ; struct  RRawFileNetXNGImpl;  ; class  RRawFileTFile;  The RRawFileTFile wraps an open TFile, but does not take ownership. More...;  ; class  RRawFileUnix;  The RRawFileUnix class uses POSIX calls to read from a mounted file system. More...;  ; class  RRawFileWin;  The RRawFileWin class uses portable C I/O calls to read from a drive. More...;  ; class  RSlotStack;  A thread-safe stack of N ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Internal.html:1350,safe,safe,1350,doc/master/namespaceROOT_1_1Internal.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Internal.html,2,['safe'],['safe']
Safety," new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoConeSeg&operator=(const TGeoConeSeg&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tSafetyS(const Double_t* point, Bool_t in, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t phi1, Double_t phi2, Int_t skipz = 0); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; voidTGeoCone::SetConeDimensions(Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); voidSetConsDimensions(Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t phi1, Double_t phi2); virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoConeSeg.html:10274,Safe,SafetySeg,10274,root/html534/TGeoConeSeg.html,https://root.cern,https://root.cern/root/html534/TGeoConeSeg.html,3,['Safe'],['SafetySeg']
Safety," nfr=0, Double_t dlong=0, Double_t dlat=0, Double_t dpsi=0)=0; TVirtualGeoPainter::Testvirtual void Test(Int_t npoints, Option_t *option)=0; TVirtualGeoPainter::SetVisOptionvirtual void SetVisOption(Int_t option=0)=0; TVirtualGeoPainter::GetViewBoxvirtual Double_t * GetViewBox()=0; TVirtualGeoPainter::EstimateCameraMovevirtual void EstimateCameraMove(Double_t, Double_t, Double_t *, Double_t *)Definition TVirtualGeoPainter.h:83; TVirtualGeoPainter::CheckBoundaryReferencevirtual void CheckBoundaryReference(Int_t icheck=-1)=0; TVirtualGeoPainter::SetNsegmentsvirtual void SetNsegments(Int_t nseg=20)=0; TVirtualGeoPainter::RandomRaysvirtual void RandomRays(Int_t nrays, Double_t startx, Double_t starty, Double_t startz, const char *target_vol, Bool_t check_norm)=0; TVirtualGeoPainter::RandomPointsvirtual void RandomPoints(const TGeoVolume *vol, Int_t npoints, Option_t *option="""")=0; TVirtualGeoPainter::CountVisibleNodesvirtual Int_t CountVisibleNodes()=0; TVirtualGeoPainter::DefaultAnglesvirtual void DefaultAngles()=0; TVirtualGeoPainter::SetNmeshPointsvirtual void SetNmeshPoints(Int_t npoints)=0; TVirtualGeoPainter::UnbombTranslationvirtual void UnbombTranslation(const Double_t *tr, Double_t *bombtr)=0; TVirtualGeoPainter::EditGeometryvirtual void EditGeometry(Option_t *option="""")=0; TVirtualGeoPainter::GetBombFactorsvirtual void GetBombFactors(Double_t &bombx, Double_t &bomby, Double_t &bombz, Double_t &bombr) const =0; TVirtualGeoPainter::CheckPointvirtual void CheckPoint(Double_t x=0, Double_t y=0, Double_t z=0, Option_t *option="""", Double_t safety=0.)=0; TVirtualGeoPainter::BombTranslationvirtual void BombTranslation(const Double_t *tr, Double_t *bombtr)=0; TVirtualGeoPainter::CheckShapevirtual void CheckShape(TGeoShape *shape, Int_t testNo, Int_t nsamples, Option_t *option)=0; TVirtualGeoPainter::ExecuteManagerEventvirtual void ExecuteManagerEvent(TGeoManager *geom, Int_t event, Int_t px, Int_t py)=0; TVirtualGeoPainter::SetBombFactorsvirtual void SetBombFactors(Doub",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoManager_8cxx_source.html:247962,safe,safety,247962,doc/master/TGeoManager_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html,1,['safe'],['safety']
Safety," node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Static Protected Attributes inherited from RooAbsPdf; static TString _normRangeOverride;  ; static Int_t _verboseEval = 0;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include </home/sftnight/build/workspace/root-makedoc-master/rootspi/rdoc/src/master/roofit/roofitcore/src/RooNormalizedPdf.h>. Inheritance diagram for RooNormalizedPdf:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooNormalizedPdf() [1/2]. RooNormalizedPdf::RooNormalizedPdf ; (; RooAbsPdf & ; pdf, . RooArgSet const & ; normSet . ). inline . Definition at line 21 of file RooNormalizedPdf.h. ◆ RooNormalizedPdf() [2/2]. RooNormalizedPdf::RooNormalizedPdf ; (; const RooNormalizedPdf & ; other, . const char * ; name . ). inline . Definition at line 34 of file RooNormalizedPdf.h. Member Function Documentation. ◆ analyticalIntegralWN(). double RooNormalizedPdf::analyticalIntegralWN ; (; Int_t ; code, . const RooArgSet * ; , . const char * ; rangeName = nullptr . ); const. inlineoverridevirtual . Fo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooNormalizedPdf.html:72752,Avoid,Avoids,72752,doc/master/classRooNormalizedPdf.html,https://root.cern,https://root.cern/doc/master/classRooNormalizedPdf.html,1,['Avoid'],['Avoids']
Safety," node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Static Protected Attributes inherited from RooAbsPdf; static TString _normRangeOverride;  ; static Int_t _verboseEval = 0;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <Roo2DKeysPdf.h>. Inheritance diagram for Roo2DKeysPdf:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ Roo2DKeysPdf() [1/2]. Roo2DKeysPdf::Roo2DKeysPdf ; (; const char * ; name, . const char * ; title, . RooAbsReal & ; xx, . RooAbsReal & ; yy, . RooDataSet & ; data, . TString ; options = ""a"", . double ; widthScaleFactor = 1.0 . ). Constructor. ; Parameters. [in]name; [in]title; [in]xx; [in]yy; [in]data; [in]options; [in]widthScaleFactor. Definition at line 49 of file Roo2DKeysPdf.cxx. ◆ Roo2DKeysPdf() [2/2]. Roo2DKeysPdf::Roo2DKeysPdf ; (; const Roo2DKeysPdf & ; other, . const char * ; name = nullptr . ). Copy constructor. ; Parameters. [in]other; [in]name. Definition at line 65 of file Roo2DKeysPdf.cxx. ◆ ~Roo2DKeysPdf(). Roo2DKeysPdf::~Roo2DKeysPdf ; (; ). override . Destructor. ; De",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRoo2DKeysPdf.html:75873,Avoid,Avoids,75873,doc/master/classRoo2DKeysPdf.html,https://root.cern,https://root.cern/doc/master/classRoo2DKeysPdf.html,1,['Avoid'],['Avoids']
Safety," node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Static Protected Attributes inherited from RooAbsPdf; static TString _normRangeOverride;  ; static Int_t _verboseEval = 0;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooBernstein.h>. Inheritance diagram for RooBernstein:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooBernstein() [1/3]. RooBernstein::RooBernstein ; (; ). default . ◆ RooBernstein() [2/3]. RooBernstein::RooBernstein ; (; const char * ; name, . const char * ; title, . RooAbsRealLValue & ; _x, . const RooArgList & ; _coefList . ). Definition at line 44 of file RooBernstein.cxx. ◆ RooBernstein() [3/3]. RooBernstein::RooBernstein ; (; const RooBernstein & ; other, . const char * ; name = nullptr . ). Definition at line 50 of file RooBernstein.cxx. Member Function Documentation. ◆ analyticalIntegral(). double RooBernstein::analyticalIntegral ; (; Int_t ; code, . const char * ; rangeName = nullptr . ); const. overridevirtual . Implements the actual analytical integral(s) advertised by g",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBernstein.html:74160,Avoid,Avoids,74160,doc/master/classRooBernstein.html,https://root.cern,https://root.cern/doc/master/classRooBernstein.html,1,['Avoid'],['Avoids']
Safety," node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Static Protected Attributes inherited from RooAbsPdf; static TString _normRangeOverride;  ; static Int_t _verboseEval = 0;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooBinSamplingPdf.h>. Inheritance diagram for RooBinSamplingPdf:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooBinSamplingPdf() [1/3]. RooBinSamplingPdf::RooBinSamplingPdf ; (; ). inline . Definition at line 31 of file RooBinSamplingPdf.h. ◆ RooBinSamplingPdf() [2/3]. RooBinSamplingPdf::RooBinSamplingPdf ; (; const char * ; name, . const char * ; title, . RooAbsRealLValue & ; observable, . RooAbsPdf & ; inputPdf, . double ; epsilon = 1.E-4 . ). Construct a new RooBinSamplingPdf. ; Parameters. [in]nameA name to identify this object. ; [in]titleTitle (for e.g. plotting) ; [in]observableObservable to integrate over (the one that is binned). ; [in]inputPdfA PDF whose bins should be sampled with higher precision. ; [in]epsilonRelative precision for the integrator, which is used to samp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBinSamplingPdf.html:77530,Avoid,Avoids,77530,doc/master/classRooBinSamplingPdf.html,https://root.cern,https://root.cern/doc/master/classRooBinSamplingPdf.html,1,['Avoid'],['Avoids']
Safety," node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Static Protected Attributes inherited from RooAbsPdf; static TString _normRangeOverride;  ; static Int_t _verboseEval = 0;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooChebychev.h>. Inheritance diagram for RooChebychev:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooChebychev() [1/3]. RooChebychev::RooChebychev ; (; ). default . ◆ RooChebychev() [2/3]. RooChebychev::RooChebychev ; (; const char * ; name, . const char * ; title, . RooAbsReal & ; _x, . const RooArgList & ; _coefList . ). Constructor. ; Definition at line 45 of file RooChebychev.cxx. ◆ RooChebychev() [3/3]. RooChebychev::RooChebychev ; (; const RooChebychev & ; other, . const char * ; name = nullptr . ). Definition at line 56 of file RooChebychev.cxx. Member Function Documentation. ◆ analyticalIntegral(). double RooChebychev::analyticalIntegral ; (; Int_t ; code, . const char * ; rangeName = nullptr . ); const. overridevirtual . Implements the actual analytical integral(s) advert",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooChebychev.html:73349,Avoid,Avoids,73349,doc/master/classRooChebychev.html,https://root.cern,https://root.cern/doc/master/classRooChebychev.html,1,['Avoid'],['Avoids']
Safety," node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Static Protected Attributes inherited from RooAbsPdf; static TString _normRangeOverride;  ; static Int_t _verboseEval = 0;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooChiSquarePdf.h>. Inheritance diagram for RooChiSquarePdf:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooChiSquarePdf() [1/3]. RooChiSquarePdf::RooChiSquarePdf ; (; ). Definition at line 31 of file RooChiSquarePdf.cxx. ◆ RooChiSquarePdf() [2/3]. RooChiSquarePdf::RooChiSquarePdf ; (; const char * ; name, . const char * ; title, . RooAbsReal & ; x, . RooAbsReal & ; ndof . ). Definition at line 37 of file RooChiSquarePdf.cxx. ◆ RooChiSquarePdf() [3/3]. RooChiSquarePdf::RooChiSquarePdf ; (; const RooChiSquarePdf & ; other, . const char * ; name = nullptr . ). Definition at line 47 of file RooChiSquarePdf.cxx. Member Function Documentation. ◆ analyticalIntegral(). double RooChiSquarePdf::analyticalIntegral ; (; Int_t ; code, . const char * ; rangeName = nullptr . ); const. overridevi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooChiSquarePdf.html:73119,Avoid,Avoids,73119,doc/master/classRooChiSquarePdf.html,https://root.cern,https://root.cern/doc/master/classRooChiSquarePdf.html,1,['Avoid'],['Avoids']
Safety," node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Static Protected Attributes inherited from RooAbsPdf; static TString _normRangeOverride;  ; static Int_t _verboseEval = 0;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooCrystalBall.h>. Inheritance diagram for RooCrystalBall:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooCrystalBall() [1/5]. RooCrystalBall::RooCrystalBall ; (; ). inline . Definition at line 16 of file RooCrystalBall.h. ◆ RooCrystalBall() [2/5]. RooCrystalBall::RooCrystalBall ; (; const char * ; name, . const char * ; title, . RooAbsReal & ; x, . RooAbsReal & ; x0, . RooAbsReal & ; sigmaL, . RooAbsReal & ; sigmaR, . RooAbsReal & ; alphaL, . RooAbsReal & ; nL, . RooAbsReal & ; alphaR, . RooAbsReal & ; nR . ). Creates the fully parametrized crystal ball shape with asymmetric Gaussian core and asymmetric tails. ; Parameters. nameName that identifies the PDF in computations. ; titleTitle for plotting. ; xThe variable of the PDF. ; x0Location parameter of the Gaussian component. ; si",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCrystalBall.html:74903,Avoid,Avoids,74903,doc/master/classRooCrystalBall.html,https://root.cern,https://root.cern/doc/master/classRooCrystalBall.html,1,['Avoid'],['Avoids']
Safety," node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Static Protected Attributes inherited from RooAbsPdf; static TString _normRangeOverride;  ; static Int_t _verboseEval = 0;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooGExpModel.h>. Inheritance diagram for RooGExpModel:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Enumeration Documentation. ◆ Type. enum RooGExpModel::Type. EnumeratorNormal ; Flipped . Definition at line 28 of file RooGExpModel.h. Constructor & Destructor Documentation. ◆ RooGExpModel() [1/6]. RooGExpModel::RooGExpModel ; (; ). default . ◆ RooGExpModel() [2/6]. RooGExpModel::RooGExpModel ; (; const char * ; name, . const char * ; title, . RooAbsRealLValue & ; xIn, . RooAbsReal & ; meanIn, . RooAbsReal & ; sigmaIn, . RooAbsReal & ; rlifeIn, . RooAbsReal & ; meanSF, . RooAbsReal & ; sigmaSF, . RooAbsReal & ; rlifeSF, . bool ; nlo = false, . Type ; type = Normal . ). Create a Gauss (x) Exp model with mean, sigma and tau parameters and scale factors for each parameter. ; NoteIf scale factors for the parameters are no",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooGExpModel.html:77735,Avoid,Avoids,77735,doc/master/classRooGExpModel.html,https://root.cern,https://root.cern/doc/master/classRooGExpModel.html,1,['Avoid'],['Avoids']
Safety," node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Static Protected Attributes inherited from RooAbsPdf; static TString _normRangeOverride;  ; static Int_t _verboseEval = 0;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooGaussModel.h>. Inheritance diagram for RooGaussModel:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooGaussModel() [1/5]. RooGaussModel::RooGaussModel ; (; ). default . ◆ RooGaussModel() [2/5]. RooGaussModel::RooGaussModel ; (; const char * ; name, . const char * ; title, . RooAbsRealLValue & ; x, . RooAbsReal & ; mean, . RooAbsReal & ; sigma . ). Definition at line 89 of file RooGaussModel.cxx. ◆ RooGaussModel() [3/5]. RooGaussModel::RooGaussModel ; (; const char * ; name, . const char * ; title, . RooAbsRealLValue & ; x, . RooAbsReal & ; mean, . RooAbsReal & ; sigma, . RooAbsReal & ; msSF . ). Definition at line 97 of file RooGaussModel.cxx. ◆ RooGaussModel() [4/5]. RooGaussModel::RooGaussModel ; (; const char * ; name, . const char * ; title, . RooAbsRealLValue & ; x, . RooAbs",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooGaussModel.html:75926,Avoid,Avoids,75926,doc/master/classRooGaussModel.html,https://root.cern,https://root.cern/doc/master/classRooGaussModel.html,1,['Avoid'],['Avoids']
Safety," node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Static Protected Attributes inherited from RooAbsPdf; static TString _normRangeOverride;  ; static Int_t _verboseEval = 0;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooJohnson.h>. Inheritance diagram for RooJohnson:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Enumeration Documentation. ◆ AnaInt_t. enum RooJohnson::AnaInt_t. private . EnumeratorkMass ; kMean ; kLambda ; kGamma ; kDelta . Definition at line 46 of file RooJohnson.h. Constructor & Destructor Documentation. ◆ RooJohnson() [1/3]. RooJohnson::RooJohnson ; (; ). inline . Definition at line 26 of file RooJohnson.h. ◆ RooJohnson() [2/3]. RooJohnson::RooJohnson ; (; const char * ; name, . const char * ; title, . RooAbsReal & ; mass, . RooAbsReal & ; mu, . RooAbsReal & ; lambda, . RooAbsReal & ; gamma, . RooAbsReal & ; delta, . double ; massThreshold = -std::numeric_limits<double>::max() . ). Construct a new Johnson PDF. ; Parameters. nameName that identifies the PDF in computations ; titleTitle for plotting ; massThe vari",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooJohnson.html:74054,Avoid,Avoids,74054,doc/master/classRooJohnson.html,https://root.cern,https://root.cern/doc/master/classRooJohnson.html,1,['Avoid'],['Avoids']
Safety," node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Static Protected Attributes inherited from RooAbsPdf; static TString _normRangeOverride;  ; static Int_t _verboseEval = 0;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooNovosibirsk.h>. Inheritance diagram for RooNovosibirsk:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooNovosibirsk() [1/3]. RooNovosibirsk::RooNovosibirsk ; (; ). inline . Definition at line 31 of file RooNovosibirsk.h. ◆ RooNovosibirsk() [2/3]. RooNovosibirsk::RooNovosibirsk ; (; const char * ; name, . const char * ; title, . RooAbsReal & ; _x, . RooAbsReal & ; _peak, . RooAbsReal & ; _width, . RooAbsReal & ; _tail . ). Definition at line 40 of file RooNovosibirsk.cxx. ◆ RooNovosibirsk() [3/3]. RooNovosibirsk::RooNovosibirsk ; (; const RooNovosibirsk & ; other, . const char * ; name = nullptr . ). Definition at line 55 of file RooNovosibirsk.cxx. Member Function Documentation. ◆ analyticalIntegral(). double RooNovosibirsk::analyticalIntegral ; (; Int_t ; code, . const char * ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooNovosibirsk.html:73147,Avoid,Avoids,73147,doc/master/classRooNovosibirsk.html,https://root.cern,https://root.cern/doc/master/classRooNovosibirsk.html,1,['Avoid'],['Avoids']
Safety," node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Static Protected Attributes inherited from RooAbsPdf; static TString _normRangeOverride;  ; static Int_t _verboseEval = 0;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooProdPdf.h>. Inheritance diagram for RooProdPdf:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooProdPdf() [1/7]. RooProdPdf::RooProdPdf ; (; ). Default constructor. ; Definition at line 82 of file RooProdPdf.cxx. ◆ RooProdPdf() [2/7]. RooProdPdf::RooProdPdf ; (; const char * ; name, . const char * ; title, . RooAbsPdf & ; pdf1, . RooAbsPdf & ; pdf2, . double ; cutOff = 0.0 . ). Constructor with 2 PDFs (most frequent use case). ; The optional cutOff parameter can be used as a speed optimization if one or more of the PDF have sizable regions with very small values, which would pull the entire product of PDFs to zero in those regions.; After each PDF multiplication, the running product is compared with the cutOff parameter. If the running product is smaller than the cutOff value, th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooProdPdf.html:80111,Avoid,Avoids,80111,doc/master/classRooProdPdf.html,https://root.cern,https://root.cern/doc/master/classRooProdPdf.html,1,['Avoid'],['Avoids']
Safety," node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Static Protected Attributes inherited from RooAbsPdf; static TString _normRangeOverride;  ; static Int_t _verboseEval = 0;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooTruthModel.h>. Inheritance diagram for RooTruthModel:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooTruthModel() [1/3]. RooTruthModel::RooTruthModel ; (; ). default . ◆ RooTruthModel() [2/3]. RooTruthModel::RooTruthModel ; (; const char * ; name, . const char * ; title, . RooAbsRealLValue & ; x . ). Constructor of a truth resolution model, i.e. a delta function in observable 'xIn'. ; Definition at line 89 of file RooTruthModel.cxx. ◆ RooTruthModel() [3/3]. RooTruthModel::RooTruthModel ; (; const RooTruthModel & ; other, . const char * ; name = nullptr . ). inline . Definition at line 26 of file RooTruthModel.h. Member Function Documentation. ◆ analyticalIntegral(). double RooTruthModel::analyticalIntegral ; (; Int_t ; code, . const char * ; rangeName = nullptr . ); const. overr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooTruthModel.html:75193,Avoid,Avoids,75193,doc/master/classRooTruthModel.html,https://root.cern,https://root.cern/doc/master/classRooTruthModel.html,1,['Avoid'],['Avoids']
Safety," node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Static Protected Attributes inherited from RooAbsPdf; static TString _normRangeOverride;  ; static Int_t _verboseEval = 0;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooWrapperPdf.h>. Inheritance diagram for RooWrapperPdf:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooWrapperPdf() [1/3]. RooWrapperPdf::RooWrapperPdf ; (; ). inline . Definition at line 27 of file RooWrapperPdf.h. ◆ RooWrapperPdf() [2/3]. RooWrapperPdf::RooWrapperPdf ; (; const char * ; name, . const char * ; title, . RooAbsReal & ; inputFunction, . bool ; selfNormalized = false . ). inline . Construct a new RooWrapperPdf. ; Parameters. [in]nameA name to identify this object. ; [in]titleTitle (for e.g. plotting) ; [in]inputFunctionAny RooAbsReal that should be converted into a PDF. Although it's possible ; [in]selfNormalizedThe return value the RooAbsPdf::selfNormalized() function for the wrapped PDF object. If it is true, then no automatic normalization will be performed when e",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooWrapperPdf.html:73519,Avoid,Avoids,73519,doc/master/classRooWrapperPdf.html,https://root.cern,https://root.cern/doc/master/classRooWrapperPdf.html,1,['Avoid'],['Avoids']
Safety," node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Static Protected Attributes inherited from RooAbsPdf; static TString _normRangeOverride;  ; static Int_t _verboseEval = 0;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . Inheritance diagram for PdfWrapper:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ PdfWrapper() [1/2]. PdfWrapper::PdfWrapper ; (; RooAbsReal & ; f, . RooAbsReal * ; coef, . bool ; expEvMode = false, . RooAbsPdf * ; expPdf = nullptr . ). inline . Definition at line 7165 of file xRooNode.cxx. ◆ ~PdfWrapper(). PdfWrapper::~PdfWrapper ; (; ). inlineoverride . Definition at line 7184 of file xRooNode.cxx. ◆ PdfWrapper() [2/2]. PdfWrapper::PdfWrapper ; (; const PdfWrapper & ; other, . const char * ; name = nullptr . ). inline . Definition at line 7185 of file xRooNode.cxx. Member Function Documentation. ◆ binBoundaries(). std::list< double > * PdfWrapper::binBoundaries ; (; RooAbsRealLValue & ; obs, . double ; xlo, . double ; xhi . ); const. inlineoverridevirtual . Retrieve bin boundaries if this di",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classPdfWrapper.html:72875,Avoid,Avoids,72875,doc/master/classPdfWrapper.html,https://root.cern,https://root.cern/doc/master/classPdfWrapper.html,1,['Avoid'],['Avoids']
Safety," node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Static Protected Attributes inherited from RooAbsPdf; static TString _normRangeOverride;  ; static Int_t _verboseEval = 0;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . Inheritance diagram for RooFixedProdPdf:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooFixedProdPdf() [1/2]. RooFixedProdPdf::RooFixedProdPdf ; (; std::unique_ptr< RooProdPdf > && ; prodPdf, . RooArgSet const & ; normSet . ). inline . Definition at line 2320 of file RooProdPdf.cxx. ◆ RooFixedProdPdf() [2/2]. RooFixedProdPdf::RooFixedProdPdf ; (; const RooFixedProdPdf & ; other, . const char * ; name = nullptr . ). inline . Definition at line 2326 of file RooProdPdf.cxx. Member Function Documentation. ◆ analyticalIntegral(). double RooFixedProdPdf::analyticalIntegral ; (; Int_t ; code, . const char * ; rangeName = nullptr . ); const. inlineoverridevirtual . Implements the actual analytical integral(s) advertised by getAnalyticalIntegral. ; This functions will only be called with codes return",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFixedProdPdf.html:73107,Avoid,Avoids,73107,doc/master/classRooFixedProdPdf.html,https://root.cern,https://root.cern/doc/master/classRooFixedProdPdf.html,1,['Avoid'],['Avoids']
Safety," node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Static Protected Attributes inherited from RooAbsPdf; static TString _normRangeOverride;  ; static Int_t _verboseEval = 0;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . Inheritance diagram for xRooProjectedPdf:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Function Documentation. ◆ clone(). TObject * xRooProjectedPdf::clone ; (; const char * ; newname); const. inlineoverridevirtual . Reimplemented from RooProjectedPdf.; Definition at line 7152 of file xRooNode.cxx. ◆ evaluate(). double xRooProjectedPdf::evaluate ; (; ); const. inlineoverrideprotectedvirtual . Evaluate projected p.d.f. ; Reimplemented from RooProjectedPdf.; Definition at line 7155 of file xRooNode.cxx. ◆ expectedEvents(). double xRooProjectedPdf::expectedEvents ; (; const RooArgSet * ; nset); const. inlineoverridevirtual . Return expected number of events to be used in calculation of extended likelihood. ; Return expected number of events from this p.d.f for use in extended likelihood calculations.; This default implementation ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classxRooProjectedPdf.html:73950,Avoid,Avoids,73950,doc/master/classxRooProjectedPdf.html,https://root.cern,https://root.cern/doc/master/classxRooProjectedPdf.html,1,['Avoid'],['Avoids']
Safety," norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); voidComputeTwist(); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoBBox::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tDistToPlane(const Double_t* point, const Double_t* dir, Int_t ipl, Bool_t in) const; virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoArb8.html:3291,safe,safe,3291,root/html534/TGeoArb8.html,https://root.cern,https://root.cern/root/html534/TGeoArb8.html,3,['safe'],['safe']
Safety," normRange2.reset(static_cast<RooCmdArg*>(RooFit::NormRange(getStringAttribute(""fitrange"")).Clone()));; 1952 cmdList.Add(normRange2.get());; 1953 }; 1954 ; 1955 if (plotRange || normRange2) {; 1956 coutI(Plotting) << ""RooAbsPdf::plotOn("" << GetName() << "") p.d.f was fitted in a subrange and no explicit ""; 1957 << (plotRange?""Range()"":"""") << ((plotRange&&normRange2)?"" and "":""""); 1958 << (normRange2?""NormRange()"":"""") << "" was specified. Plotting / normalising in fit range. To override, do one of the following""; 1959 << ""\n\t- Clear the automatic fit range attribute: <pdf>.removeStringAttribute(\""fitrange\"");""; 1960 << ""\n\t- Explicitly specify the plotting range: Range(\""<rangeName>\"").""; 1961 << ""\n\t- Explicitly specify where to compute the normalisation: NormRange(\""<rangeName>\"").""; 1962 << ""\n\tThe default (full) range can be denoted with Range(\""\"") / NormRange(\""\"").""<< endl ;; 1963 }; 1964 ; 1965 // Sanity checks; 1966 if (plotSanityChecks(frame)) return frame ;; 1967 ; 1968 // Select the pdf-specific commands; 1969 RooCmdConfig pc(""RooAbsPdf::plotOn("" + std::string(GetName()) + "")"");; 1970 pc.defineDouble(""scaleFactor"",""Normalization"",0,1.0) ;; 1971 pc.defineInt(""scaleType"",""Normalization"",0,Relative) ;; 1972 pc.defineSet(""compSet"",""SelectCompSet"",0) ;; 1973 pc.defineString(""compSpec"",""SelectCompSpec"",0) ;; 1974 pc.defineObject(""asymCat"",""Asymmetry"",0) ;; 1975 pc.defineDouble(""rangeLo"",""Range"",0,-999.) ;; 1976 pc.defineDouble(""rangeHi"",""Range"",1,-999.) ;; 1977 pc.defineString(""rangeName"",""RangeWithName"",0,"""") ;; 1978 pc.defineString(""normRangeName"",""NormRange"",0,"""") ;; 1979 pc.defineInt(""rangeAdjustNorm"",""Range"",0,0) ;; 1980 pc.defineInt(""rangeWNAdjustNorm"",""RangeWithName"",0,0) ;; 1981 pc.defineMutex(""SelectCompSet"",""SelectCompSpec"") ;; 1982 pc.defineMutex(""Range"",""RangeWithName"") ;; 1983 pc.allowUndefined() ; // unknowns may be handled by RooAbsReal; 1984 ; 1985 // Process and check varargs; 1986 pc.process(cmdList) ;; 1987 if (!pc.ok(true)) {; 1988 return fr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html:97514,Sanity check,Sanity checks,97514,doc/master/RooAbsPdf_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html,1,['Sanity check'],['Sanity checks']
Safety," not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  ROOT::Internal::ClassDefGenerateInitInstanceLocalInjector< T >;  ; class  ROOT::Internal::TCDGIILIBase;  ; class  ROOT::Internal::TDefaultInitBehavior;  ; struct  ROOT::Internal::THashConsistencyHolder< T >;  ; class  ROOT::Internal::TInitBehavior;  . Namespaces; namespace  ROOT;  tbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tbb::task_arena without forward declaring tbb::interface7 ;  ; namespace  ROOT::Internal;  . Macros; #define _ClassDefBase_(name, id, virtual_keyword, overrd);  Common part being called both by _ClassDefOutline_ and _ClassDefInline_. ;  ; #define _ClassDefInline_(name, id, virtual_keyword, overrd);  ; #define _ClassDefOutline_(name, id, virtual_keyword, overrd);  ; #define BIT(n)   (1ULL << (n));  ; #define ClassDef(name, id);  ; #define ClassDef2T2(name, Tmpl1, Tmpl2);  ; #define ClassDef3T2(name, Tmpl1, Tmpl2, Tmpl3);  ; #define ClassDefInline(name, id);  ; #define ClassDefInlineNV(name, id);  ; #define ClassDefInlineOverride(name, id);  ; #define ClassDefNV(name, id);  ; #define ClassDefOverride(name, id);  ; #define ClassDefT(name, id);  This ClassDefT is strictly redundant and is kept only for backward compatibility. ;  ; #define ClassDefT2(name, Tmpl);  ; #define ClassDefTNV(name, id);  ; #define ClassImp(name)   ClassImpUnique(name,default);  ; #define ClassImp2T(name, Tmpl1, Tmpl2)   templateClassImp(name);  ; #define ClassImp3T(name, Tmpl1, Tmpl2, Tmpl3)   templateClassImp(name);  ; #define ClassImpT(name, Tmpl)   templateClassImp(name);  ; #define ClassImpUnique(name, key);  ; #define CLRBIT(n, i)   ((n) &= ~BIT(i));  ; #define NamespaceImp(name)   NamespaceImpUnique(name,default);  ; #define NamespaceImpUnique(name, key);  Macro for Namespace. ;  ; #define R__ADD_INCLUDE_PATH(PATH);  ; #define R__ADD_LIBRARY_PATH(PATH);  ; #define R__CLING_PTRCHECK(ONOFF);  ; #define R__LOAD_LIBRARY(LIBRARY);  ; #",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Rtypes_8h.html:1778,redund,redundant,1778,doc/master/Rtypes_8h.html,https://root.cern,https://root.cern/doc/master/Rtypes_8h.html,2,['redund'],['redundant']
Safety," nothing changes (estimated proc time / 100); TMap*TVirtualPacketizer::fSlaveStatsslave status, keyed by correspondig TSlave; TTimeTVirtualPacketizer::fStartTimetime offset; Bool_tTVirtualPacketizer::fStopTermination of Process() requested?; Float_tTVirtualPacketizer::fTimeUpdttime between updates; Long64_tTVirtualPacketizer::fTotalEntriestotal number of entries to be distributed;; TVirtualPacketizer::EUseEstOptTVirtualPacketizer::fUseEstOptControl usage of estimated values for the progress info; Bool_tTVirtualPacketizer::fValidConstructed properly?; static TVirtualPacketizer::EUseEstOptTVirtualPacketizer::kEstAverage; static TVirtualPacketizer::EUseEstOptTVirtualPacketizer::kEstCurrent; static TVirtualPacketizer::EUseEstOptTVirtualPacketizer::kEstOff. private:. TList*fActivenodes with unfinished files; TList*fFileNodesnodes with files; Int_tfMaxPerfIdxmaximum of our slaves' performance index; Long_tfMaxSlaveCntmaximum number of workers per filenode (Long_t to avoid; Int_tfPacketAsAFractionused to calculate the packet size; Long64_tfPacketSizeglobal base packet size; TList*fPacketsall processed packets; TMap*fSlaveStatsslave status, keyed by correspondig TSlave; TList*fUnAllocatednodes with unallocated files. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPacketizer(TDSet* dset, TList* slaves, Long64_t first, Long64_t num, TList* input, TProofProgressStatus* st); Constructor. ~TPacketizer(); Destructor. void RemoveUnAllocNode(TPacketizer::TFileNode* ); Remove unallocated node. void RemoveActive(TPacketizer::TFileStat* file); Remove file from the list of actives. void RemoveActiveNode(TPacketizer::TFileNode* ); Remove node from the list of actives. void Reset(); Reset the internal datastructure for packet distribution. void ValidateFiles(TDSet* dset, TList* slaves, Long64_t maxent = -1, Bool_t byfile = kFALSE); Check existence of file/dir/tree an get number of entries.; Assumes the files have been setup. Long64_t GetEntrie",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TPacketizer.html:10895,avoid,avoid,10895,root/html602/TPacketizer.html,https://root.cern,https://root.cern/root/html602/TPacketizer.html,1,['avoid'],['avoid']
Safety," notify the master that worker is killed; Bool_tfThreadJoinedmark if async thread was joined; TStopwatchfWaitTimetime wating to prefetch a buffer (in usec). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFilePrefetch(TFile* ); Constructor. ~TFilePrefetch(); Destructor. void WaitFinishPrefetch(); Killing the async prefetching thread. void ReadAsync(TFPBlock* , Bool_t& ); Read one block and insert it in prefetchBuffers list. void ReadListOfBlocks(); Get blocks specified in prefetchBlocks. Bool_t BinarySearchReadList(TFPBlock* , Long64_t , Int_t , Int_t* ); Search for a requested element in a block and return the index. Long64_t GetWaitTime(); Return the time spent wating for buffer to be read in microseconds. Bool_t ReadBuffer(char* , Long64_t , Int_t ); Return a prefetched element. void ReadBlock(Long64_t* , Int_t* , Int_t ); Create a TFPBlock object or recycle one and add it to the prefetchBlocks list. void AddPendingBlock(TFPBlock* ); Safe method to add a block to the pendingList. TFPBlock* GetPendingBlock(); Safe method to remove a block from the pendingList. void AddReadBlock(TFPBlock* ); Safe method to add a block to the readList. TFPBlock* CreateBlockObj(Long64_t* , Int_t* , Int_t ); Create a new block or recycle an old one. TThread* GetThread() const; Return reference to the consumer thread. void SetFile(TFile* ); Change the file; When prefetching is enabled we also need to:; - make sure the async thread is not doing any work; - clear all blocks from prefetching and read list; - reset the file pointer. Int_t ThreadStart(); Used to start the consumer thread. TThread::VoidRtnFunc_t ThreadProc(void* ); Execution loop of the consumer thread. Int_t SumHex(const char* ); Sum up individual hex values to obtain a decimal value. Bool_t CheckBlockInCache(char*& , TFPBlock* ); Test if the block is in cache. char* GetBlockFromCache(const char* , Int_t ); Return a buffer from cache. void SaveBlockInCache(TFPBlock* ); Save the blo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TFilePrefetch.html:7475,Safe,Safe,7475,root/html534/TFilePrefetch.html,https://root.cern,https://root.cern/root/html534/TFilePrefetch.html,3,['Safe'],['Safe']
Safety," nsamples, option);; 3786}; 3787 ; 3788////////////////////////////////////////////////////////////////////////////////; 3789/// Geometry checking.; 3790/// - if option contains 'o': Optional overlap checkings (by sampling and by mesh).; 3791/// - if option contains 'b': Optional boundary crossing check + timing per volume.; 3792///; 3793/// STAGE 1: extensive overlap checking by sampling per volume. Stdout need to be; 3794/// checked by user to get report, then TGeoVolume::CheckOverlaps(0.01, ""s"") can; 3795/// be called for the suspicious volumes.; 3796///; 3797/// STAGE 2: normal overlap checking using the shapes mesh - fills the list of; 3798/// overlaps.; 3799///; 3800/// STAGE 3: shooting NRAYS rays from VERTEX and counting the total number of; 3801/// crossings per volume (rays propagated from boundary to boundary until; 3802/// geometry exit). Timing computed and results stored in a histo.; 3803///; 3804/// STAGE 4: shooting 1 mil. random rays inside EACH volume and calling; 3805/// FindNextBoundary() + Safety() for each call. The timing is normalized by the; 3806/// number of crossings computed at stage 2 and presented as percentage.; 3807/// One can get a picture on which are the most ""burned"" volumes during; 3808/// transportation from geometry point of view. Another plot of the timing per; 3809/// volume vs. number of daughters is produced.; 3810 ; 3811void TGeoManager::CheckGeometryFull(Int_t ntracks, Double_t vx, Double_t vy, Double_t vz, Option_t *option); 3812{; 3813 TString opt(option);; 3814 opt.ToLower();; 3815 if (!opt.Length()) {; 3816 Error(""CheckGeometryFull"", ""The option string must contain a letter. See method documentation."");; 3817 return;; 3818 }; 3819 Bool_t checkoverlaps = opt.Contains(""o"");; 3820 Bool_t checkcrossings = opt.Contains(""b"");; 3821 Double_t vertex[3];; 3822 vertex[0] = vx;; 3823 vertex[1] = vy;; 3824 vertex[2] = vz;; 3825 GetGeomPainter()->CheckGeometryFull(checkoverlaps, checkcrossings, ntracks, vertex);; 3826}; 3827 ; 3828",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoManager_8cxx_source.html:139301,Safe,Safety,139301,doc/master/TGeoManager_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html,1,['Safe'],['Safety']
Safety," nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Static Protected Attributes; static RooCategory * _dummyBlindState = nullptr;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . Additional Inherited Members;  Public Types inherited from RooAbsReal; enum  ErrorLoggingMode { PrintErrors; , CollectErrors; , CountErrors; , Ignore; };  ; enum  ScaleType { Raw; , Relative; , NumEvent; , RelativeExpected; };  ; using value_type = double;  ;  Public Types inherited from RooAbsArg; enum  CacheMode { Always =0; , NotAdvised =1; , Never =2; };  ; enum  ConstOpCode { Activate =0; , DeActivate =1; , ConfigChange =2; , ValueChange =3; };  ; enum  OperMode { Auto =0; , AClean =1; , ADirty =2; };  ; using RefCountList_t = RooSTLRefCountList< RooAbsArg >;  ; using RefCountListLegacyIterator_t = TIteratorToSTLInterface< RefCountList_t::Container_t >;  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 ))",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsHiddenReal.html:58229,Avoid,Avoids,58229,doc/master/classRooAbsHiddenReal.html,https://root.cern,https://root.cern/doc/master/classRooAbsHiddenReal.html,1,['Avoid'],['Avoids']
Safety," nullptr . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ DistFromOutside_v(). void TGeoParaboloid::DistFromOutside_v ; (; const Double_t * ; points, . const Double_t * ; dirs, . Double_t * ; dists, . Int_t ; vecsize, . Double_t * ; step . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ DistToParaboloid(). Double_t TGeoParaboloid::DistToParaboloid ; (; const Double_t * ; point, . const Double_t * ; dir, . Bool_t ; in . ); const. ◆ Divide(). TGeoVolume * TGeoParaboloid::Divide ; (; TGeoVolume * ; voldiv, . const char * ; divname, . Int_t ; iaxis, . Int_t ; ndiv, . Double_t ; start, . Double_t ; step . ). overridevirtual . Reimplemented from TGeoBBox. ◆ GetBoundingCylinder(). void TGeoParaboloid::GetBoundingCylinder ; (; Double_t * ; param); const. overridevirtual . Reimplemented from TGeoBBox. ◆ GetBuffer3D(). const TBuffer3D & TGeoParaboloid::GetBuffer3D ; (; Int_t ; reqSections, . Bool_t ; localFrame . ); const. overridevirtual . Stub implementation to avoid forcing implementation at this stage. ; Reimplemented from TGeoBBox. ◆ GetDz(). Double_t TGeoParaboloid::GetDz ; (; ); const. inline . Definition at line 58 of file TGeoParaboloid.h. ◆ GetMakeRuntimeShape(). TGeoShape * TGeoParaboloid::GetMakeRuntimeShape ; (; TGeoShape * ; mother, . TGeoMatrix * ; mat . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ GetMeshNumbers(). void TGeoParaboloid::GetMeshNumbers ; (; Int_t & ; nvert, . Int_t & ; nsegs, . Int_t & ; npols . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ GetNmeshVertices(). Int_t TGeoParaboloid::GetNmeshVertices ; (; ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ GetPointsOnSegments(). Bool_t TGeoParaboloid::GetPointsOnSegments ; (; Int_t ; , . Double_t * ;  . ); const. inlineoverridevirtual . Reimplemented from TGeoBBox.; Definition at line 64 of file TGeoParaboloid.h. ◆ GetRhi(). Double_t TGeoParaboloid::GetRhi ; (; ); const. inline . Definition at line 57 of file TGeoParaboloid.h. ◆ GetRlo(). Dou",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoParaboloid.html:26503,avoid,avoid,26503,doc/master/classTGeoParaboloid.html,https://root.cern,https://root.cern/doc/master/classTGeoParaboloid.html,1,['avoid'],['avoid']
Safety," number of pseudo-experiment of specified; 8311 if (opt.Contains(""X="")) {; 8312 int numpos = opt.Index(""X="") + 2; // 2 is length of X=; 8313 int numlen = 0;; 8314 int len = opt.Length();; 8315 while( (numpos+numlen<len) && isdigit(opt[numpos+numlen]) ); 8316 numlen++;; 8317 TString snum = opt(numpos,numlen);; 8318 int num = atoi(snum.Data());; 8319 if (num <= 0); 8320 Warning(""KolmogorovTest"",""invalid number of toys given: %d - use 1000"",num);; 8321 else; 8322 nEXPT = num;; 8323 }; 8324 ; 8325 Double_t dSEXPT;; 8326 TH1D hparent;; 8327 // we cannot have afunc1 and func2 both True; 8328 if (afunc1 || esum1 > esum2 ) h1->Copy(hparent);; 8329 else h2->Copy(hparent);; 8330 ; 8331 // copy h1Expt from h1 and h2. It is just needed to get the correct binning; 8332 ; 8333 ; 8334 if (hparent.GetMinimum() < 0.0) {; 8335 // we need to create a new histogram; 8336 // With negative bins we can't draw random samples in a meaningful way.; 8337 Warning(""KolmogorovTest"", ""Detected bins with negative weights, these have been ignored and output might be ""; 8338 ""skewed. Reduce number of bins for histogram?"");; 8339 while (hparent.GetMinimum() < 0.0) {; 8340 Int_t idx = hparent.GetMinimumBin();; 8341 hparent.SetBinContent(idx, 0.0);; 8342 }; 8343 }; 8344 ; 8345 // make nEXPT experiments (this should be a parameter); 8346 prb3 = 0;; 8347 TH1D h1Expt;; 8348 h1->Copy(h1Expt);; 8349 TH1D h2Expt;; 8350 h1->Copy(h2Expt);; 8351 // loop on pseudoexperients and generate the two histograms h1Expt and h2Expt according to the; 8352 // parent distribution. In case the parent distribution is not an histogram but a function randomize only one; 8353 // histogram; 8354 for (Int_t i=0; i < nEXPT; i++) {; 8355 if (!afunc1) {; 8356 h1Expt.Reset();; 8357 h1Expt.FillRandom(&hparent, (Int_t)esum1);; 8358 }; 8359 if (!afunc2) {; 8360 h2Expt.Reset();; 8361 h2Expt.FillRandom(&hparent, (Int_t)esum2);; 8362 }; 8363 // note we cannot have both afunc1 and afunc2 to be true; 8364 if (afunc1); 8365 dSEXPT = hparent.Kol",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:327503,Detect,Detected,327503,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['Detect'],['Detected']
Safety," nz); Default constructor. TGeoPcon(const char* name, Double_t phi, Double_t dphi, Int_t nz); Default constructor. TGeoPcon(Double_t* params); Default constructor in GEANT3 style; param[0] = phi1; param[1] = dphi; param[2] = nz. param[3] = z1; param[4] = Rmin1; param[5] = Rmax1. TGeoPcon(const TGeoPcon& ); copy constructor. TGeoPcon& operator=(const TGeoPcon& ); assignment operator. ~TGeoPcon(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box of the pcon; Check if the sections are in increasing Z order. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this shape; check total z range. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the polycone. Double_t DistToSegZ(Double_t* point, Double_t* dir, Int_t& iz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cfio, Double_t sfio, Double_t cdfi) const; compute distance to a pcon Z slice. Segment iz must be valid. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube. void DefineSection(Int_t snum, Double_t z, Double_t rmin, Double_t rmax); Defines z position of a section plane, rmin and rmax at this z. Sections; should be defined in increasing or decreasing Z order and the last section; HAS to be snum = fNz-1. Int_t GetNsegments() const; Returns number of segments on each mesh circle segment. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this polycone sha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoPcon.html:13117,safe,safe,13117,root/html528/TGeoPcon.html,https://root.cern,https://root.cern/root/html528/TGeoPcon.html,3,['safe'],['safe']
Safety," n . ). finalvirtual . WriteFastArray SQL implementation. ; NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Reimplemented from TBufferFile.; Definition at line 506 of file TBufferSQL.cxx. ◆ WriteFastArray() [9/15]. void TBufferSQL::WriteFastArray ; (; const UChar_t * ; uc, . Long64_t ; n . ). finalvirtual . WriteFastArray SQL implementation. ; NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Reimplemented from TBufferFile.; Definition at line 486 of file TBufferSQL.cxx. ◆ WriteFastArray() [10/15]. void TBufferSQL::WriteFastArray ; (; const UInt_t * ; ui, . Long64_t ; n . ). finalvirtual . WriteFastArray SQL implementation. ; NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Reimplemented from TBufferFile.; Definition at line 568 of file TBufferSQL.cxx. ◆ WriteFastArray() [11/15]. void TBufferSQL::WriteFastArray ; (; const ULong64_t * ; ul, . Long64_t ; n . ). finalvirtual . WriteFastArray SQL implementation. ; NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Reimplemented from TBufferFile.; Definition at line 648 of file TBufferSQL.cxx. ◆ WriteFastArray() [12/15]. void TBufferSQL::WriteFastArray ; (; const ULong_t * ; ul, . Long64_t ; n . ). finalvirtual . WriteFastArray SQL implementation. ; NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBufferSQL.html:54687,abort,aborts,54687,doc/master/classTBufferSQL.html,https://root.cern,https://root.cern/doc/master/classTBufferSQL.html,1,['abort'],['aborts']
Safety," of Migrad and Simplex ;  CCombinedMinimumBuilder;  CContoursError;  CDavidonErrorUpdatorUpdate of the covariance matrix for the Variable Metric minimizer (MIGRAD) ;  CFCNAdapterTemplate wrapped class for adapting to FCNBase signature ;  CFCNBaseInterface (abstract class) defining the function to be minimized, which has to be implemented by the user ;  CFCNGradAdapterTemplate wrapped class for adapting to FCNBase signature a IGradFunction ;  CFCNGradientBaseExtension of the FCNBase for providing the analytical Gradient of the function ;  CFumiliBuilderBuilds the FunctionMinimum using the Fumili method ;  CFumiliChi2FCNExtension of the FCNBase for the Fumili method ;  CFumiliErrorUpdatorIn the case of the Fumili algorithm the Error matrix (or the Hessian matrix containing the (approximate) second derivatives) is calculated using a linearization of the model function negleting second derivatives ;  CFumiliFCNAdapterTemplate wrapped class for adapting to FumiliFCNBase signature ;  CFumiliFCNBaseExtension of the FCNBase for the Fumili method ;  CFumiliGradientCalculator;  CFumiliMaximumLikelihoodFCNExtension of the FCNBase for the Fumili method ;  CFumiliMinimizerInstantiates the seed generator and Minimum builder for the Fumili minimization method ;  CFumiliStandardChi2FCNClass implementing the standard chi square function, which is the sum of the squares of the figures-of-merit calculated for each measurement point, the individual figures-of-merit being: (the Value predicted by the model-measured Value)/standard deviation ;  CFumiliStandardMaximumLikelihoodFCNClass implementing the Elements member function for the standard maximum likelihood method ;  CFunctionGradient;  CFunctionMinimizerBase class for function minimizers; user may give FCN or FCN with Gradient, Parameter starting values and initial Error guess (sigma) (or ""step size""), or Parameter starting values and initial covariance matrix; covariance matrix is stored in Upper triangular packed storage format, e.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/annotated.html:62928,predict,predicted,62928,doc/v612/annotated.html,https://root.cern,https://root.cern/doc/v612/annotated.html,4,['predict'],['predicted']
Safety," of RecursiveRemove (indirectly done; 84 // by 'Appending' this object to it's mother) before the object is completely; 85 // initialized.; 86 // However a better option would be to delay the publishing until the very end,; 87 // but it is currently done in the middle of the initialization (by Build which; 88 // is a public interface) ....; 89 R__LOCKGUARD(gROOTMutex);; 90 ; 91 fName = name;; 92 fTitle = title;; 93 ; 94 if (!initMotherDir) initMotherDir = gDirectory;; 95 ; 96 if (strchr(name,'/')) {; 97 ::Error(""TDirectoryFile"",""directory name (%s) cannot contain a slash"", name);; 98 gDirectory = nullptr;; 99 return;; 100 }; 101 if (strlen(GetName()) == 0) {; 102 ::Error(""TDirectoryFile"",""directory name cannot be \""\"""");; 103 gDirectory = nullptr;; 104 return;; 105 }; 106 ; 107 BuildDirectoryFile(initMotherDir ? initMotherDir->GetFile() : nullptr, initMotherDir);; 108 ; 109 TDirectory* motherdir = GetMotherDir();; 110 TFile* f = TDirectoryFile::GetFile();; 111 ; 112 if (!motherdir || !f) return;; 113 if (!f->IsWritable()) return; //*-* in case of a directory in memory; 114 if (motherdir->GetKey(name)) {; 115 Error(""TDirectoryFile"",""An object with name %s exists already"", name);; 116 return;; 117 }; 118 TClass *cl = nullptr;; 119 if (classname[0]) {; 120 cl = TClass::GetClass(classname);; 121 if (!cl) {; 122 Error(""TDirectoryFile"",""Invalid class name: %s"",classname);; 123 return;; 124 }; 125 } else {; 126 cl = TDirectoryFile::IsA();; 127 }; 128 ; 129 fBufferSize = 0;; 130 fWritable = kTRUE;; 131 ; 132 InitDirectoryFile(cl);; 133 ; 134 fModified = kFALSE;; 135 ; 136 // Temporarily redundant, see comment on lock early in the function.; 137 // R__LOCKGUARD(gROOTMutex);; 138 gROOT->GetUUIDs()->AddUUID(fUUID,this);; 139 // We should really be doing this now rather than in Build, see; 140 // comment at the start of the function.; 141 // if (initMotherDir && strlen(GetName()) != 0) initMotherDir->Append(this);; 142}; 143 ; 144////////////////////////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html:4629,redund,redundant,4629,doc/master/TDirectoryFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html,1,['redund'],['redundant']
Safety," of bytes for the object on file; Int_tfObjlenLength of uncompressed object in bytes; UShort_tfPidOffset! Offset to be added to the pid index in this key/buffer. This is actually saved in the high bits of fSeekPdir; Long64_tfSeekKeyLocation of object on file; Long64_tfSeekPdirLocation of parent directory on file; TStringTNamed::fTitleobject title; Int_tfVersionKey version identifier. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TKey(); TKey default constructor. TKey(TDirectory* motherDir); TKey default constructor. TKey(Long64_t pointer, Int_t nbytes, TDirectory* motherDir = 0); Create a TKey object to read keys.; Constructor called by TDirectoryFile::ReadKeys and by TFile::TFile.; A TKey object is created to read the keys structure itself. TKey(const char* name, const char* title, const TClass* cl, Int_t nbytes, TDirectory* motherDir = 0); Create a TKey object with the specified name, title for the given class. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). TKey(const TString& name, const TString& title, const TClass* cl, Int_t nbytes, TDirectory* motherDir = 0); Create a TKey object with the specified name, title for the given class. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). TKey(const TObject* obj, const char* name, Int_t bufsize, TDirectory* motherDir = 0); Create a TKey object for a TObject* and fill output buffer. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). TKey(const void* obj, const TClass* cl, const char* name, Int_t bufsize, TDirectory* motherDir = 0); Create a TKey object for any object obj of class cl d and fill; output buffer. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). void Build(TDirectory* motherDir,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TKey.html:9415,avoid,avoid,9415,root/html528/TKey.html,https://root.cern,https://root.cern/root/html528/TKey.html,2,['avoid'],['avoid']
Safety," of container; vector<TGenCollectionProxy::TStaging*,allocator<TGenCollectionProxy::TStaging*> >fStagedOptimization: Keep staged array once they were created; type_info&fTypeinfoType information; TGenCollectionProxy::Value*fValDescriptor of the Value_type; intfValDiffOffset between two consecutive value_types (memory layout).; intfValOffsetOffset from key to value (in maps); TGenCollectionProxy::Value*fValueDescriptor of the container value type; TStreamerInfoActions::TActionSequence*fWriteMemberWise. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void DeleteItem(void* ptr); Delete individual item from STL container. s. Streamer(TBuffer& refBuffer). s. Streamer(TBuffer& refBuffer). else s-> Clear(). Method & operator=(const TGenCollectionProxy& ); { call = m.call; return *this; }. void Resize(size_t nelement). TGenCollectionProxy* Initialize(Bool_t silent) const; Late initialization of collection proxy. TGenCollectionProxy* InitializeEx(Bool_t silent); Some hack to avoid const-ness. void CheckFunctions() const; Allow to check function pointers. TGenCollectionProxy(). TVirtualCollectionProxy* Generate() const; Virtual copy constructor. TGenCollectionProxy(const TGenCollectionProxy& copy); Copy constructor. TGenCollectionProxy(TGenCollectionProxy::Info_t typ, size_t iter_size); Initializing constructor. TGenCollectionProxy(const ROOT::TCollectionProxyInfo& info, TClass* cl). virtual ~TGenCollectionProxy(); Standard destructor. TClass * GetCollectionClass() const; Return a pointer to the TClass representing the container. Int_t GetCollectionType() const; Return the type of collection see TClassEdit::ESTLType. ULong_t GetIncrement() const; Return the offset between two consecutive value_types (memory layout). UInt_t Sizeof() const; Return the sizeof the collection object. void PushProxy(void* objstart); Push new proxy environment. void PopProxy(); Pop old proxy environment. Bool_t HasPointers() const; Return true if the content",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGenCollectionProxy.html:6640,avoid,avoid,6640,root/html534/TGenCollectionProxy.html,https://root.cern,https://root.cern/root/html534/TGenCollectionProxy.html,1,['avoid'],['avoid']
Safety," of first compound parent, if kSCBTakeAnyParentAsMaster bit is set;; If non of the above is true, *this* is returned. void AddParent(TEveElement* re); Add re into the list parents.; Adding parent is subordinate to adding an element.; This is an internal function. void RemoveParent(TEveElement* re); Remove re from the list of parents.; Removing parent is subordinate to removing an element.; This is an internal function. void CheckReferenceCount(const TEveException& eh = ""TEveElement::CheckReferenceCount ""); Check external references to this and eventually auto-destruct; the render-element. void CollectSceneParents(TEveElement::List_t& scenes); Collect all parents of class TEveScene. This is needed to; automatically detect which scenes need to be updated. Overriden in TEveScene to include itself and return. void CollectSceneParentsFromChildren(TEveElement::List_t& scenes, TEveElement* parent); Collect scene-parents from all children. This is needed to; automatically detect which scenes need to be updated during/after; a full sub-tree update.; Argument parent specifies parent in traversed hierarchy for which we can; skip the upwards search. void ExpandIntoListTree(TGListTree* ltree, TGListTreeItem* parent); Populates parent with elements.; parent must be an already existing representation of *this*.; Returns number of inserted elements.; If parent already has children, it does nothing. Element can be inserted in a list-tree several times, thus we can not; search through fItems to get parent here.; Anyhow, it is probably known as it must have been selected by the user. void DestroyListSubTree(TGListTree* ltree, TGListTreeItem* parent); Destroy sub-tree under item 'parent' in list-tree 'ltree'. TGListTreeItem* AddIntoListTree(TGListTree* ltree, TGListTreeItem* parent_lti); Add this element into ltree to an already existing item; parent_lti. Children, if any, are added as below the newly created item.; Returns the newly created list-tree-item. TGListTreeItem* AddIntoListT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEveElement.html:17964,detect,detect,17964,root/html528/TEveElement.html,https://root.cern,https://root.cern/root/html528/TEveElement.html,6,['detect'],['detect']
Safety," of free segments. This linked list has been written on the file via WriteFree as a single data record. ; Reimplemented from TFile.; Definition at line 239 of file TSQLFile.h. ◆ ReadSpecialObject(). TObject * TSQLFile::ReadSpecialObject ; (; Long64_t ; keyid, . TObject * ; obj = nullptr . ). protected . Read data of special kind of objects. ; Definition at line 851 of file TSQLFile.cxx. ◆ ReadSQLClassInfos(). void TSQLFile::ReadSQLClassInfos ; (; ). protected . Read all class infos from IdsTable. ; Definition at line 1911 of file TSQLFile.cxx. ◆ Recover(). Int_t TSQLFile::Recover ; (; ). inlinefinalvirtual . Attempt to recover file if not correctly closed. ; The function returns the number of keys that have been recovered. If no keys can be recovered, the file will be declared Zombie by the calling function. This function is automatically called when opening a file. If the file is open in read only mode, the file is not modified. If open in update mode and the function finds something to recover, a new directory header is written to the file. When opening the file gain no message from Recover will be reported. If keys have been recovered, the file is usable and you can safely read the corresponding objects. If the file is not usable (a zombie), you can test for this case with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {<actions to take if file is unusable>}; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; If the file has been recovered, the bit kRecovered is set in the TFile object in memory. You can test if the file has been recovered with if (f.TestBit(TFile::kRecovered)) {... the file has been recovered}; When writing TTrees to a file, it is important to save the Tree header at regular intervals (see TTree::AutoSave). If a file containing a Tree is recovered, the last Tree header written to the file will be used. In this case all the entries in all the branches written ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSQLFile.html:84834,recover,recover,84834,doc/master/classTSQLFile.html,https://root.cern,https://root.cern/doc/master/classTSQLFile.html,1,['recover'],['recover']
Safety," of histogram (avoid blanks) ; [in]titlehistogram title. If title is of the form stringt;stringx;stringy;stringz the histogram title is set to stringt, the x axis title to stringx, the y axis title to stringy, etc. ; [in]nbinsxnumber of bins ; [in]xbinsarray of low-edges for each bin. This is an array of type float and size nbinsx+1 ; [in]nbinsynumber of bins ; [in]ybinsarray of low-edges for each bin. This is an array of type float and size nbinsy+1 ; [in]nbinsznumber of bins ; [in]zbinsarray of low-edges for each bin. This is an array of type float and size nbinsz+1 . Definition at line 142 of file TH3.cxx. ◆ TH3() [4/5]. TH3::TH3 ; (; const char * ; name, . const char * ; title, . Int_t ; nbinsx, . const Double_t * ; xbins, . Int_t ; nbinsy, . const Double_t * ; ybins, . Int_t ; nbinsz, . const Double_t * ; zbins . ). protected . Constructor for variable bin size (along X, Y and Z axis) 3-D histograms using input arrays of type double. ; Parameters. [in]namename of histogram (avoid blanks) ; [in]titlehistogram title. If title is of the form stringt;stringx;stringy;stringz the histogram title is set to stringt, the x axis title to stringx, the y axis title to stringy, etc. ; [in]nbinsxnumber of bins ; [in]xbinsarray of low-edges for each bin. This is an array of type double and size nbinsx+1 ; [in]nbinsynumber of bins ; [in]ybinsarray of low-edges for each bin. This is an array of type double and size nbinsy+1 ; [in]nbinsznumber of bins ; [in]zbinsarray of low-edges for each bin. This is an array of type double and size nbinsz+1 . Definition at line 179 of file TH3.cxx. ◆ TH3() [5/5]. TH3::TH3 ; (; const TH3 & ; ). privatedelete . ◆ ~TH3(). TH3::~TH3 ; (; ). override . Destructor. ; Definition at line 200 of file TH3.cxx. Member Function Documentation. ◆ AddBinContent() [1/4]. void TH3::AddBinContent ; (; Int_t ; bin). overridevirtual . Increment bin content by 1. ; Passing an out-of-range bin leads to undefined behavior ; Reimplemented from TH1.; Reimplemented in ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH3.html:61540,avoid,avoid,61540,doc/master/classTH3.html,https://root.cern,https://root.cern/doc/master/classTH3.html,1,['avoid'],['avoid']
Safety," of new and delete calls in large loops like this (O(100000) x O(10000) times new/delete):; TObjArray a(10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000); for (int i = 0; i < ev->Ntracks; i++) { // O(10000); a[i] = new TTrack(x,y,z,...);; ...; }; ...; a.Delete();; }; You better use a TClonesArray which reduces the number of new/delete calls to only O(10000):; TClonesArray a(""TTrack"", 10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000); for (int i = 0; i < ev->Ntracks; i++) { // O(10000); TTrack *track = (Track*)a.ConstructedAt(i);; track->Set(x,y,z,...);; ...; }; ...; a.Clear(); // Or Clear(""C"") if the track objects must be returned (via Track::Clear) to a default state.; }; Considering that a pair of new/delete calls on average cost about 70 ms, O(109) new/deletes will save about 19 hours. For the other collections, see the class reference guide on the web and the test program $ROOTSYS/test/tcollex.cxx.; 16.9 Template Containers and STL; Some people dislike polymorphic containers because they are not truly “type safe”. In the end, the compiler leaves it the user to ensure that the types are correct. This only leaves the other alternative: creating a new class each time a new (container organization) / (contained object) combination is needed. To say the least this could be very tedious. Most people faced with this choice would, for each type of container:; Define the class leaving a dummy name for the contained object type. When a particular container was needed, copy the code and then do a global search and replace for the contained class. C++ has a built in template scheme that effectively does just this. For example:; template<class T>; class ArrayContainer {; private:; T *member[10];; ...; };; This is an array container with a 10-element array of pointers to T, it could hold up to 10 T objects. This array is flawed because it is static and hard-coded, it should be dynamic. However, the important point is that the template statement indicate",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:855641,safe,safe,855641,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['safe'],['safe']
Safety, of processors to use in parallel calculation mode; Int_tRooAbsTestStatistic::_nEventsTotal number of events in test statistic calculation; Int_tRooAbsTestStatistic::_nGofNumber of sub-contexts ; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooArgSet*_normSetPointer to set with observables used for normalization; Int_tRooAbsTestStatistic::_numSetsTotal number of partitions in parallel calculation mode; Double_tRooAbsTestStatistic::_offset! Offset; Double_tRooAbsTestStatistic::_offsetCarry! avoids loss of precision; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_t_optimized!; RooAbsData*_origDataOriginal data ; RooAbsReal*_origFuncOriginal function ; Bool_t_ownDataDo we own the dataset; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooSetProxyRooAbsTestStatistic::_paramSetParameters of the test statistic (=parameters of the input function); Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooArgSet*_projDepsSet of projected observable; const RooArgSet*RooAbsTestStatistic::_projDepsPointer to set with projected observables; RooRefArrayRooAbsArg::_proxyListlist of proxies; stringRooAbsTestStatistic::_rangeNameName of range in which to calculate test statistic; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; TString_sealNoticeUser-defined notice shown when reading a sealed likelihood ; Bool_t_sealedIs test statistic sealed -- i.e. no access to data ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Int_tRooAbsTestStatistic::_setNumPartition number of this instance in parallel calculation mode; Bool_tRooAbsAr,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsOptTestStatistic.html:38861,avoid,avoids,38861,root/html534/RooAbsOptTestStatistic.html,https://root.cern,https://root.cern/root/html534/RooAbsOptTestStatistic.html,1,['avoid'],['avoids']
Safety," of signals from this object; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TVirtualProofPlayer * Create(const char* player, TProof* p, TSocket* s = 0); Create a PROOF player. TVirtualProofPlayer(); { ResetBit(TVirtualProofPlayer::kIsSubmerger); }. virtual ~TVirtualProofPlayer(); { }. Long64_t Process(TDSet* set, const char* selector, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0). Bool_t JoinProcess(TList* workers). Long64_t Finalize(Bool_t force = kFALSE, Bool_t sync = kFALSE). Long64_t Finalize(TQueryResult* qr). Long64_t DrawSelect(TDSet* set, const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0). void HandleGetTreeHeader(TMessage* mess). void HandleRecvHisto(TMessage* mess). void StopProcess(Bool_t abort, Int_t timeout = -1). void AddInput(TObject* inp). void ClearInput(). TObject * GetOutput(const char* name) const. TList * GetOutputList() const. TList * GetInputList() const. TList * GetListOfResults() const. void AddQueryResult(TQueryResult* q). TQueryResult * GetCurrentQuery() const. TQueryResult * GetQueryResult(const char* ref). void RemoveQueryResult(const char* ref). void SetCurrentQuery(TQueryResult* q). void SetMaxDrawQueries(Int_t max). void RestorePreviousQuery(). Int_t AddOutputObject(TObject* obj). void AddOutput(TList* out). void StoreOutput(TList* out). void StoreFeedback(TObject* slave, TList* out). void Progress(Long64_t total, Long64_t processed). void Progress(TSlave* , Long64_t total, Long64_t processed). void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti). void Progress(TProofProgressInfo* ). void Progress(TSlave* , TProofProgressInfo* ). void Feedback(TList* objs). TDrawFeedb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TVirtualProofPlayer.html:13954,abort,abort,13954,root/html604/TVirtualProofPlayer.html,https://root.cern,https://root.cern/root/html604/TVirtualProofPlayer.html,2,"['abort', 'timeout']","['abort', 'timeout']"
Safety," of the OS interface. ;  ; virtual TSignalHandler * RemoveSignalHandler (TSignalHandler *sh);  Remove a signal handler from list of signal handlers. ;  ; virtual TStdExceptionHandler * RemoveStdExceptionHandler (TStdExceptionHandler *eh);  Remove an exception handler from list of exception handlers. ;  ; virtual TTimer * RemoveTimer (TTimer *t);  Remove timer from list of system timers. ;  ; virtual int Rename (const char *from, const char *to);  Rename a file. ;  ; virtual void ResetSignal (ESignals sig, Bool_t reset=kTRUE);  If reset is true reset the signal handler for the specified signal to the default handler, else restore previous behaviour. ;  ; virtual void ResetSignals ();  Reset signals handlers to previous behaviour. ;  ; virtual void ResetTimer (TTimer *);  ; virtual void Run ();  System event loop. ;  ; virtual Int_t Select (TFileHandler *fh, Long_t timeout);  Select on active file descriptors (called by TMonitor). ;  ; virtual Int_t Select (TList *active, Long_t timeout);  Select on active file descriptors (called by TMonitor). ;  ; virtual int SendBuf (int sock, const void *buffer, int length);  Send a buffer headed by a length indicator. ;  ; virtual int SendRaw (int sock, const void *buffer, int length, int flag);  Send exactly length bytes from buffer. ;  ; virtual void SetAclicMode (EAclicMode mode);  AclicMode indicates whether the library should be built in debug mode or optimized. ;  ; virtual void SetBuildDir (const char *build_dir, Bool_t isflat=kFALSE);  Set the location where ACLiC will create libraries and use as a scratch area. ;  ; virtual void SetDisplay ();  Set DISPLAY environment variable based on utmp entry. Only for UNIX. ;  ; virtual void SetDynamicPath (const char *pathname);  Set the dynamic path to a new value. ;  ; virtual void Setenv (const char *name, const char *value);  Set environment variable. ;  ; void SetErrorStr (const char *errstr);  Set the system error string. ;  ; virtual void SetFlagsDebug (const char *);  Flags",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTNetSystem.html:15561,timeout,timeout,15561,doc/master/classTNetSystem.html,https://root.cern,https://root.cern/doc/master/classTNetSystem.html,6,['timeout'],['timeout']
Safety," off when fAutoFlush == 0. Release 6.24/06; Published on September 1, 2021; Bugs and Issues fixed in this release. [#8931] - TDirectory::RegisterGDirectory is MT unsafe; [#8011] - Bug in RooAbsPdf::extendedTerm when expected events is negative. Release 6.24/08; Published on September 29, 2022; Bugs and Issues fixed in this release. [ROOT-10829] - pure virtual method called error; [#8933] - CMAKE_INSTALL_PYTHONDIR on macOS creates broken symlinks; [#9017] - Access of deleted object during hadd tear down.; [#8072] - Failures with root 6.24.00 on Fedora 33 ppc64le; [#9297] - ROOT 6.24 debug build failed on ppc64le; [#9424] - ROOT 6.24 failed to build with GCC10 or 11 on ppc64le arch; [#9547] - [RF] RooFit crashes when ROOT is built with Clang 13; [#9543] - roottest-root-treeformula-stl-make crashes during process termination; [#8987] - Missing operator= in code generated by MakeProject; [#7754] - Segfault when using schema evolution; [#8428] - I/O customization rule not run on split sub-object of a non-collection object.; [#9899] - TTree incorrectly run I/O customization rules on “new” data members.; [#9939] - Hadd super slow since TFileMerger modification; [#10170] - Crashes when reading a TTree with a friend; [#8549] - A crash when opening a TTree and its friend on TFile::Close(); [#10131] - Open too many different non-versioned layouts for pair; [#10353] - Thread-safety issue in TClassEdit (StdLen)? [6.24.06]; [#7276] - [RF] ROOT 6.22/06 crashes reading old workspace file; [#10548] - Use of undeclared identifier on Mac ARM; [#10478] - runtime_cxxmodules fails to build with GCC12; [#11080] - Backport the fix on computation of the radiation and nuclear interaction lengths to v6.24; [#10645] - [TTreeReader] Cannot read Float16_t branch; [#11260] - TTreeReaderArray does not support Double32_t; [#11383] - Deadlock in ErrorHandler when invoked at library initialization time. HEAD of the v6-24-00-patches branch; These changes will be part of a future 6.24/10. None so far. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v624/release-notes.html:51132,safe,safety,51132,doc/v624/release-notes.html,https://root.cern,https://root.cern/doc/v624/release-notes.html,1,['safe'],['safety']
Safety," on GitHub via web browser. ;  ; virtual void Help (const char *line);  The function lists useful commands ("".help"") or opens the online reference guide, generated with Doxygen ("".help scope"" or "".help scope::member""). ;  ; virtual void LoadGraphicsLibs ();  Load shared libs necessary for graphics. ;  ; virtual void MakeBatch ();  Switch to batch mode. ;  ; virtual Longptr_t ProcessRemote (const char *line, Int_t *error=nullptr);  Process the content of a line starting with "".R"" (already stripped-off) The format is. ;  ; void SetSignalHandler (TSignalHandler *sh);  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Member Functions inherited from TQObject; virtual void * GetSender ();  ; virtual const char * GetSenderClassName () const;  . Static Protected Member Functions; static void ErrorHandler (Int_t level, Bool_t abort, const char *location, const char *msg);  The error handler function. ;  ;  Static Protected Member Functions inherited from TApplication; static void Close (TApplication *app);  Static function used to close a remote application. ;  ; static TApplication * Open (const char *url, Int_t debug, const char *script);  Static function used to attach to an existing remote application or to start one. ;  ; static Int_t ParseRemoteLine (const char *ln, TString &hostdir, TString &user, Int_t &dbg, TString &script);  Parse the content of a line starting with "".R"" (already stripped-off) The format is. ;  ;  Static Protected Member Functions inherited from TQObject; static Int_t CheckConnectArgs (TQObject *sender, TClass *sender_class, const char *signal, TClass *receiver_class, const char *slot);  Checking of consistency of sender/receiver methods/arguments. ;  ; static TString CompressName (const char *method_name);  Removes ""const"" words and blanks from full (with prototype) method nam",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTApplicationServer.html:19232,abort,abort,19232,doc/master/classTApplicationServer.html,https://root.cern,https://root.cern/doc/master/classTApplicationServer.html,1,['abort'],['abort']
Safety," open in update mode and the function finds something to recover, a new directory header is written to the file. When opening the file gain no message from Recover will be reported. If keys have been recovered, the file is usable and you can safely read the corresponding objects. If the file is not usable (a zombie), you can test for this case with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {<actions to take if file is unusable>}; If the file has been recovered, the bit kRecovered is set in the TFile object in memory. You can test if the file has been recovered with if (f.TestBit(TFile::kRecovered)) {... the file has been recovered}; When writing TTrees to a file, it is important to save the Tree header at regular intervals (see TTree::AutoSave). If a file containing a Tree is recovered, the last Tree header written to the file will be used. In this case all the entries in all the branches written before writing the header are valid entries. One can disable the automatic recovery procedure by setting TFile.Recover 0; in the system.rootrc file. ; Reimplemented in TSQLFile, and TXMLFile.; Definition at line 2048 of file TFile.cxx. ◆ ReOpen(). Int_t TFile::ReOpen ; (; Option_t * ; mode). virtual . Reopen a file with a different access mode. ; For example, it is possible to change from READ to UPDATE or from NEW, CREATE, RECREATE, UPDATE to READ. Thus the mode argument can be either ""READ"" or ""UPDATE"". The method returns 0 in case the mode was successfully modified, 1 in case the mode did not change (was already as requested or wrong input arguments) and -1 in case of failure, in which case the file cannot be used anymore. The current directory (gFile) is changed to this file. ; Reimplemented in TSQLFile, TXMLFile, TNetFile, TWebFile, and TNetXNGFile.; Definition at line 2162 of file TFile.cxx. ◆ ResetErrno(). void TFile::ResetErrno ; (; ); const. virtual . Method resetting the errno. ; Reimplemented in TSQLFile, TXMLFile, TDCacheFile, and TMemFile.; Definiti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTFile.html:90089,recover,recovery,90089,doc/v632/classTFile.html,https://root.cern,https://root.cern/doc/v632/classTFile.html,2,['recover'],['recovery']
Safety," operator. ~TGeoPcon(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box of the pcon; Check if the sections are in increasing Z order. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; test if point is inside this shape; check total z range. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the polycone. Double_t DistToSegZ(const Double_t* point, const Double_t* dir, Int_t& iz) const; compute distance to a pcon Z slice. Segment iz must be valid. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube. void DefineSection(Int_t snum, Double_t z, Double_t rmin, Double_t rmax); Defines z position of a section plane, rmin and rmax at this z. Sections; should be defined in increasing or decreasing Z order and the last section; HAS to be snum = fNz-1. Int_t GetNsegments() const; Returns number of segments on each mesh circle segment. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this polycone shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. Returns pointer; to created division cell volume in case of Z divisions. Z divisions can be; performed if the divided range is in between two consecutive Z planes.; In case a wrong division axis is supplied, returns pointer to; volume that was divided. const char * GetAxisName(Int_t iaxis) const; Returns name",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoPcon.html:14850,safe,safe,14850,root/html534/TGeoPcon.html,https://root.cern,https://root.cern/root/html534/TGeoPcon.html,3,['safe'],['safe']
Safety," operator=(const TGeoXtru& ); assignment operator. ~TGeoXtru(); destructor. Double_t Capacity() const; Compute capacity [length^3] of this shape. void ComputeBBox(); compute bounding box of the pcon. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this shape; Check Z range. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistToPlane(Double_t* point, Double_t* dir, Int_t iz, Int_t ivert, Double_t stepmax, Bool_t in) const; Compute distance to a Xtru lateral surface. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the polycone; locate Z segment. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube; Warning(""DistFromOutside"", ""not implemented"");. Bool_t DefinePolygon(Int_t nvert, const Double_t* xv, const Double_t* yv); Creates the polygon representing the blueprint of any Xtru section.; nvert = number of vertices >2; xv[nvert] = array of X vertex positions; yv[nvert] = array of Y vertex positions; *NOTE* should be called before DefineSection or ctor with 'param'. void DefineSection(Int_t snum, Double_t z, Double_t x0 = 0., Double_t y0 = 0., Double_t scale = 1.); defines z position of a section plane, rmin and rmax at this z. Double_t GetZ(Int_t ipl) const; Return the Z coordinate for segment ipl. void GetPlaneNormal(const Double_t* vert, Double_t* norm) const; Returns normal vector to the planar quadrilateral defined by vector VERT.; The normal points outwards the xtru. void GetPlaneVertices(Int_t iz, Int_t ivert, Double_t* vert) const; Returns (x,y,z) of 3 vertices of the surface defined by Z sections (iz,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoXtru.html:15509,safe,safe,15509,root/html528/TGeoXtru.html,https://root.cern,https://root.cern/root/html528/TGeoXtru.html,2,['safe'],['safe']
Safety," operator=(const TSelector&); // not implemented; 47 ; 48public:; 49 TSelector();; 50 ~TSelector() override;; 51 ; 52 virtual int Version() const { return 0; }; 53 virtual void Init(TTree *) { }; 54 virtual void Begin(TTree *) { }; 55 virtual void SlaveBegin(TTree *) { }; 56 bool Notify() override { return true; }; 57 const char *GetOption() const override { return fOption.Data(); }; 58 virtual Long64_t GetStatus() const { return fStatus; }; 59 virtual Int_t GetEntry(Long64_t /*entry*/, Int_t /*getall*/ = 0) { return 0; }; 60 virtual bool ProcessCut(Long64_t /*entry*/);; 61 virtual void ProcessFill(Long64_t /*entry*/);; 62 virtual bool Process(Long64_t /*entry*/);; 63 virtual void ImportOutput(TList *output);; 64 virtual void SetOption(const char *option) { fOption = option; }; 65 virtual void SetObject(TObject *obj) { fObject = obj; }; 66 virtual void SetInputList(TList *input) { fInput = input; }; 67 virtual void SetStatus(Long64_t status) { fStatus = status; }; 68 virtual TList *GetInputList() const { return fInput; }; 69 virtual TList *GetOutputList() const { return fOutput; }; 70 virtual void SlaveTerminate() { }; 71 virtual void Terminate() { }; 72 virtual void Abort(const char *why, EAbort what = kAbortProcess);; 73 virtual EAbort GetAbort() const { return fAbort; }; 74 virtual void ResetAbort() { fAbort = kContinue; }; 75 ; 76 static TSelector *GetSelector(const char *filename);; 77 static bool IsStandardDraw(const char *selec);; 78 ; 79 ClassDefOverride(TSelector,2) //A utility class for tree and object processing; 80};; 81 ; 82#endif; 83 ; Long64_tlong long Long64_tDefinition RtypesCore.h:69; ClassDefOverride#define ClassDefOverride(name, id)Definition Rtypes.h:346; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; inputOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void inputDefinition TGWin32VirtualXProxy.cxx:142; filenameOption_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSelector_8h_source.html:2797,Abort,Abort,2797,doc/master/TSelector_8h_source.html,https://root.cern,https://root.cern/doc/master/TSelector_8h_source.html,1,['Abort'],['Abort']
Safety," option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTProofPlayer::SetCurrentQuery(TQueryResult* q); virtual voidTProofPlayer::SetDispatchTimer(Bool_t on = kTRUE); virtual voidTProofPlayer::SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTProofPlayer::SetExitStatus(TVirtualProofPlayer::EExitStatus st); virtual voidTProofPlayerRemote::SetInitTime(); virtual voidTProofPlayer::SetMaxDrawQueries(Int_t max); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTProofPlayer::SetOutputFilePath(const char* fp); voidTProofPlayer::SetProcessing(Bool_t on = kTRUE); virtual voidTProofPlayer::SetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidTProofPlayerRemote::StopProcess(Bool_t abort, Int_t timeout = -1); virtual voidTProofPlayerRemote::StoreFeedback(TObject* slave, TList* out); virtual voidTProofPlayerRemote::StoreOutput(TList* out); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TProofPlayerSuperMaster(TProof* proof = 0); TProofPlayerSuperMaster(const TProofPlayerSuperMaster&); virtual voidTProofPlayer::UpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidTProofPlayer::UpdateProgressInfo(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofPlayerSuperMaster.html:11621,abort,abort,11621,root/html602/TProofPlayerSuperMaster.html,https://root.cern,https://root.cern/root/html602/TProofPlayerSuperMaster.html,1,['abort'],['abort']
Safety," or Opera instead.; [legend]; Member Enumeration Documentation. ◆ EStatusBits. enum TKey::EStatusBits. private . EnumeratorkIsDirectoryFile ; kReproducible . Definition at line 31 of file TKey.h. Constructor & Destructor Documentation. ◆ TKey() [1/9]. TKey::TKey ; (; const TKey & ; ). privatedelete . ◆ TKey() [2/9]. TKey::TKey ; (; ). TKey default constructor. ; Definition at line 87 of file TKey.cxx. ◆ TKey() [3/9]. TKey::TKey ; (; TDirectory * ; motherDir). TKey default constructor. ; Definition at line 99 of file TKey.cxx. ◆ TKey() [4/9]. TKey::TKey ; (; TDirectory * ; motherDir, . const TKey & ; orig, . UShort_t ; pidOffset . ). Copy a TKey from its original directory to the new 'motherDir'. ; Definition at line 111 of file TKey.cxx. ◆ TKey() [5/9]. TKey::TKey ; (; const char * ; name, . const char * ; title, . const TClass * ; cl, . Int_t ; nbytes, . TDirectory * ; motherDir . ). Create a TKey object with the specified name, title for the given class. ; WARNING: in name avoid special characters like '^','$','.' that are used by the regular expression parser (see TRegexp). ; Definition at line 191 of file TKey.cxx. ◆ TKey() [6/9]. TKey::TKey ; (; const TString & ; name, . const TString & ; title, . const TClass * ; cl, . Int_t ; nbytes, . TDirectory * ; motherDir . ). Create a TKey object with the specified name, title for the given class. ; WARNING: in name avoid special characters like '^','$','.' that are used by the regular expression parser (see TRegexp). ; Definition at line 207 of file TKey.cxx. ◆ TKey() [7/9]. TKey::TKey ; (; const TObject * ; obj, . const char * ; name, . Int_t ; bufsize, . TDirectory * ; motherDir . ). Create a TKey object for a TObject* and fill output buffer. ; WARNING: in name avoid special characters like '^','$','.' that are used by the regular expression parser (see TRegexp). ; Definition at line 223 of file TKey.cxx. ◆ TKey() [8/9]. TKey::TKey ; (; const void * ; obj, . const TClass * ; cl, . const char * ; name, . Int_t ; bufsi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTKey.html:18261,avoid,avoid,18261,doc/master/classTKey.html,https://root.cern,https://root.cern/doc/master/classTKey.html,1,['avoid'],['avoid']
Safety," or an alias for a raw pointer otherwise.; RooFit::OwningPtr<RooAbsReal> RooAbsReal::createIntegral(...) const override; {; std::unique_ptr<RooAbsReal> integral;; // Prepare a std::unique_ptr as the return value; ...; // Use the RooFit::makeOwningPtr<T>() helper to translate the; // std::unique_ptr to the actual return type (either std::unique_ptr<T> or T*).; return RooFit::makeOwningPtr<RooAbsReal>(std::move(integral));; }; The biggest application of the memory-safe interfaces is to spot memory leaks in RooFit-based frameworks. If you make sure that your framework compiles both with and without ROOFIT_MEMORY_SAFE_INTERFACES, you can get rid of all memory leaks related to RooFit user error! After making the necessary changes, you can remove the marco definition again to keep backwards compatibility.; Note that the memory-safe interfaces might become the default at some point, so doing this backwards-compatible migration early is strongly encouraged and appreciated.; Removal of some memory-unsafe interfaces. The final bool takeOwnership parameter of the RooAddition and RooStats::HistFactory::PiecewiseInterpolation constructors was removed. This is to avoid situations where ownership is not clear to the compiler. Now, ownership of the input RooAbsArgs is never passed in the constructor. If you want the pass input ownership to the created object, please use addOwnedComponents. If you want to be extra safe, make sure the inputs are in an owning collection and then std::move the collection, so that the ownership is always clear.; Example:; RooArgList sumSet;; sumSet.add(*(new RooRealVar(""var1"", ""var1"", 1.0)));; sumSet.add(*(new RooRealVar(""var2"", ""var2"", 3.0)));; RooAddition addition{""addition"", ""addition"", sumSet, /*takeOwnership=*/true};; should become:; RooArgList sumSet;; sumSet.addOwned(std::make_unique<RooRealVar>(""var1"", ""var1"", 1.0));; sumSet.addOwned(std::make_unique<RooRealVar>(""var2"", ""var2"", 3.0));; RooAddition addition{""addition"", ""addition"", sumSet};; additi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/release-notes.html:11244,unsafe,unsafe,11244,doc/v632/release-notes.html,https://root.cern,https://root.cern/doc/v632/release-notes.html,1,['unsafe'],['unsafe']
Safety," or for timeout (in milliseconds) to occur. Returns; 3897/// the number of ready descriptors, or 0 in case of timeout, or < 0 in; 3898/// case of an error, with -2 being EINTR and -3 EBADF. In case of EINTR; 3899/// the errno has been reset and the method can be called again.; 3900 ; 3901int TUnixSystem::UnixSelect(Int_t nfds, TFdSet *readready, TFdSet *writeready,; 3902 Long_t timeout); 3903{; 3904 int retcode;; 3905 ; 3906 fd_set *rd = (readready) ? (fd_set*)readready->GetBits() : nullptr;; 3907 fd_set *wr = (writeready) ? (fd_set*)writeready->GetBits() : nullptr;; 3908 ; 3909 if (timeout >= 0) {; 3910 struct timeval tv;; 3911 tv.tv_sec = Int_t(timeout / 1000);; 3912 tv.tv_usec = (timeout % 1000) * 1000;; 3913 retcode = select(nfds, rd, wr, nullptr, &tv);; 3914 } else {; 3915 retcode = select(nfds, rd, wr, nullptr, nullptr);; 3916 }; 3917 if (retcode == -1) {; 3918 if (GetErrno() == EINTR) {; 3919 ResetErrno(); // errno is not self reseting; 3920 return -2;; 3921 }; 3922 if (GetErrno() == EBADF); 3923 return -3;; 3924 return -1;; 3925 }; 3926 ; 3927 return retcode;; 3928}; 3929 ; 3930//---- directories -------------------------------------------------------------; 3931 ; 3932////////////////////////////////////////////////////////////////////////////////; 3933/// Returns the user's home directory.; 3934 ; 3935const char *TUnixSystem::UnixHomedirectory(const char *name); 3936{; 3937 static char path[kMAXPATHLEN], mydir[kMAXPATHLEN] = { '\0' };; 3938 return UnixHomedirectory(name, path, mydir);; 3939}; 3940 ; 3941////////////////////////////////////////////////////////////////////////////; 3942/// Returns the user's home directory.; 3943 ; 3944const char *TUnixSystem::UnixHomedirectory(const char *name, char *path, char *mydir); 3945{; 3946 struct passwd *pw;; 3947 if (name) {; 3948 pw = getpwnam(name);; 3949 if (pw) {; 3950 strncpy(path, pw->pw_dir, kMAXPATHLEN-1);; 3951 path[kMAXPATHLEN-1] = '\0';; 3952 return path;; 3953 }; 3954 } else {; 3955 if (mydir[0]); 3956 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TUnixSystem_8cxx_source.html:125462,timeout,timeout,125462,doc/master/TUnixSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html,1,['timeout'],['timeout']
Safety," or the assignment (=) operator. For maximum flexibility and minimize memory allocation, the coordinate system classes are templated on the scalar type. To avoid exposing templated parameter to the users, typedefs are defined for all types of vectors based on doubles. See in the examples for all the possible types of vector classes, which can be constructed by users with the available coordinate system types.; 13.12.1.4 Coordinate System Tag; The 2D and 3D points and vector classes can be associated to a tag defining the coordinate system. This can be used to distinguish between vectors of different coordinate systems like global or local vectors. The coordinate system tag is a template parameter of the ROOT::Math::DisplacementVector3D and ROOT::Math::PositionVector3D (and also for 2D classes). A default tag exists for users who do not need this functionality, ROOT::Math::DefaultCoordinateSystemTag.; 13.12.1.5 Transformations; The transformations are modeled using simple (non-template) classes, using double as the scalar type to avoid too large numerical errors. The transformations are grouped in rotations (in 3 dimensions), Lorentz transformations and Poincare transformations, which are translation/rotation combinations. Each group has several members which may model physically equivalent transformations but with different internal representations. Transformation classes can operate on all type of vectors by using the operator ()or the operator * and the transformations can be combined via the operator *. The available transformations are:. 3D rotation classes; rotation described by a 3x3 matrix (ROOT::Math::Rotation3D); rotation described by Euler angles (ROOT::Math::EulerAngles); rotation described by a direction axis and an angle (ROOT::Math::AxisAngle); rotation described by a quaternion (ROOT::Math::Quaternion); optimized rotation around x (ROOT::Math::RotationX), y (ROOT::Math::RotationY) and z (ROOT::Math::RotationZ) and described by just one angle.; 3D tran",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:723163,avoid,avoid,723163,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['avoid'],['avoid']
Safety," or to extend some collection kinds. Bool_t IsDrawableClass(TClass* cl); return true if object can be drawn. void ScanHierarchy(const char* topname, const char* path, TRootSnifferStore* store, Bool_t only_fields = kFALSE); scan ROOT hierarchy with provided store object. void * FindInHierarchy(const char* path, TClass** cl = 0, TDataMember** member = 0, Int_t* chld = 0); Search element with specified path; Returns pointer on element; Optionally one could obtain element class, member description; and number of childs. When chld!=0, not only element is searched,; but also number of childs are counted. When member!=0, any object; will be scanned for its data members (disregard of extra options). TObject * FindTObjectInHierarchy(const char* path); Search element in hierarchy, derived from TObject. ULong_t GetStreamerInfoHash(); Returns hash value for streamer infos; At the moment - just number of items in streamer infos list. ULong_t GetItemHash(const char* itemname); Get hash function for specified item; used to detect any changes in the specified object. Bool_t CanDrawItem(const char* path); Method verifies if object can be drawn. Bool_t CanExploreItem(const char* path); Method returns true when object has childs or; one could try to expand item. void CreateMemFile(); Creates TMemFile instance, which used for objects streaming; One could not use TBufferFile directly,; while one also require streamer infos list. Bool_t ProduceJson(const char* path, const char* options, TString& res); produce JSON data for specified item; For object conversion TBufferJSON is used. Bool_t ExecuteCmd(const char* path, const char* options, TString& res); execute command marked as _kind=='Command'. Bool_t ProduceItem(const char* path, const char* options, TString& res, Bool_t asjson = kTRUE); produce JSON/XML for specified item; contrary to h.json request, only fields for specified item are stored. Bool_t ProduceXml(const char* path, const char* options, TString& res); produce XML data for sp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TRootSniffer.html:14237,detect,detect,14237,root/html534/TRootSniffer.html,https://root.cern,https://root.cern/root/html534/TRootSniffer.html,2,['detect'],['detect']
Safety," origin; UInt_tTGeoShape::fShapeBitsshape bits; Int_tTGeoShape::fShapeIdshape id; TStringTNamed::fTitleobject title; TGeoVolumeAssembly*fVolumeassembly volume. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoShapeAssembly(); Default constructor. TGeoShapeAssembly(TGeoVolumeAssembly* vol); Constructor specifying hyperboloid parameters. ~TGeoShapeAssembly(); destructor. void ComputeBBox(); Compute bounding box of the assembly. void RecomputeBoxLast(); Recompute bounding box of the assembly after adding a node. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Should not be called. Bool_t Contains(Double_t* point) const; Test if point is inside the assembly. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each vertex. Should not be called. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the hyperboloid. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the hyperboloid.; fVolume->SetNextNodeIndex(-1);. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Cannot divide assemblies. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; in case shape has some negative parameters, these has to be computed; in order to fit the mother. void InspectShape() const; print shape parameters. void SetSegsAndPols(TBuffer3D& buff) const; Fill TBuffer3D structure for segments and polygons. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape, according; to option. The matching point on the shape is stored in spoint. void S",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoShapeAssembly.html:11939,safe,safe,11939,root/html528/TGeoShapeAssembly.html,https://root.cern,https://root.cern/root/html528/TGeoShapeAssembly.html,3,['safe'],['safe']
Safety," other external MC for simulation, therefore it does not contain any; constraints related to physics. However, the package defines a number of; hooks for tracking, such as media, materials, magnetic field or track state flags,; in order to allow interfacing to tracking MC's. The final goal is to be; able to use the same geometry for several purposes, such as tracking,; reconstruction or visualization, taking advantage of the ROOT features; related to bookkeeping, I/O, histograming, browsing and GUI's. The geometrical modeler is the most important component of the package and; it provides answers to the basic questions like ""Where am I ?"" or ""How far; from the next boundary ?"", but also to more complex ones like ""How far from; the closest surface ?"" or ""Which is the next crossing along a helix ?"". The architecture of the modeler is a combination between a GEANT-like; containment scheme and a normal CSG binary tree at the level of shapes. An; important common feature of all detector geometry descriptions is the; mother-daughter concept. This is the most natural approach when tracking; is concerned and imposes a set of constraints to the way geometry is defined.; Constructive solid geometry composition is used only in order to create more; complex shapes from an existing set of primitives through boolean operations.; This feature is not implemented yet but in future full definition of boolean; expressions will be supported. Practically every geometry defined in GEANT style can be mapped by the modeler.; The basic components used for building the logical hierarchy of the geometry; are called ""volumes"" and ""nodes"". Volumes (sometimes called ""solids"") are fully; defined geometrical objects having a given shape and medium and possibly; containing a list of nodes. Nodes represent just positioned instances of volumes; inside a container volume and they are not directly defined by user. They are; automatically created as a result of adding one volume inside other or dividing;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoManager.html:1451,detect,detector,1451,root/html528/TGeoManager.html,https://root.cern,https://root.cern/root/html528/TGeoManager.html,6,['detect'],['detector']
Safety," output, . std::span< const double > ; xVals, . bool ; correctForBinSize, . bool ; cdfBoundaries . ). private . A vectorized version of interpolateDim for boundary safe linear interpolation of one dimensional histograms. ; Parameters. [out]outputAn array of interpolated weights corresponding to the values in xVals. ; [in]xValsAn array of event coordinates for which the weights should be calculated. ; [in]correctForBinSizeEnable the inverse bin volume correction factor. ; [in]cdfBoundariesEnable the special boundary condition for a cdf: Underflow bins are assumed to have weight zero and overflow bins have weight one. Otherwise, the histogram is mirrored at the boundaries for the interpolation. . Definition at line 1263 of file RooDataHist.cxx. ◆ interpolateQuadratic(). void RooDataHist::interpolateQuadratic ; (; double * ; output, . std::span< const double > ; xVals, . bool ; correctForBinSize, . bool ; cdfBoundaries . ). private . A vectorized version of interpolateDim for boundary safe quadratic interpolation of one dimensional histograms. ; Parameters. [out]outputAn array of interpolated weights corresponding to the values in xVals. ; [in]xValsAn array of event coordinates for which the weights should be calculated. ; [in]correctForBinSizeEnable the inverse bin volume correction factor. ; [in]cdfBoundariesEnable the special boundary condition for a cdf: Underflow bins are assumed to have weight zero and overflow bins have weight one. Otherwise, the histogram is mirrored at the boundaries for the interpolation. . Definition at line 1156 of file RooDataHist.cxx. ◆ IsA(). TClass * RooDataHist::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooAbsData.; Definition at line 282 of file RooDataHist.h. ◆ isNonPoissonWeighted(). bool RooDataHist::isNonPoissonWeighted ; (; ); const. overridevirtual . Returns true if dataset contains entries with a non-integer weight. ; Reimplemented from RooAbsData.; Definition at lin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooDataHist.html:64986,safe,safe,64986,doc/master/classRooDataHist.html,https://root.cern,https://root.cern/doc/master/classRooDataHist.html,1,['safe'],['safe']
Safety," over uniform observables; RooArgSet_uniformVars; Int_t_updateFMaxPerEventIf true, maximum p.d.f value needs to be recalculated for each event; Bool_tRooAbsGenContext::_verboseVerbose messaging?; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooGenContext(const RooAbsPdf& model, const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE, const RooArgSet* forceDirect = 0); Initialize a new context for generating events with the specified; variables, using the specified PDF model. A prototype dataset (if provided); is not cloned and still belongs to the caller. The contents and shape; of this dataset can be changed between calls to generate() as long as the; expected columns to be copied to the generated dataset are present.; Any argument supplied in the forceDirect RooArgSet are always offered; for internal generation to the p.d.f., even if this is deemed unsafe by; the logic of RooGenContext. ~RooGenContext(); Destructor. void attach(const RooArgSet& params); Attach the cloned model to the event buffer we will be filling. void initGenerator(const RooArgSet& theEvent); Perform one-time initialization of the generator context. void generateEvent(RooArgSet& theEvent, Int_t remaining); Generate one event. The 'remaining' integer is not used other than; for printing messages. void printMultiline(ostream& os, Int_t content, Bool_t verbose = kFALSE, TString indent = """") const; Printing interface. RooGenContext(const RooAbsPdf& model, const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE, const RooArgSet* forceDirect = 0). » Last changed: Fri Dec 2 14:26:49 2011 » Last generated: 2011-12-02 14:26; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooGenContext.html:10300,unsafe,unsafe,10300,root/html532/RooGenContext.html,https://root.cern,https://root.cern/root/html532/RooGenContext.html,1,['unsafe'],['unsafe']
Safety," over uniform observables; RooArgSet_uniformVars; Int_t_updateFMaxPerEventIf true, maximum p.d.f value needs to be recalculated for each event; Bool_tRooAbsGenContext::_verboseVerbose messaging?; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooGenContext(const RooAbsPdf& model, const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE, const RooArgSet* forceDirect = 0); Initialize a new context for generating events with the specified; variables, using the specified PDF model. A prototype dataset (if provided); is not cloned and still belongs to the caller. The contents and shape; of this dataset can be changed between calls to generate() as long as the; expected columns to be copied to the generated dataset are present.; Any argument supplied in the forceDirect RooArgSet are always offered; for internal generation to the p.d.f., even if this is deemed unsafe by; the logic of RooGenContext. ~RooGenContext(); Destructor. void attach(const RooArgSet& params); Attach the cloned model to the event buffer we will be filling. void initGenerator(const RooArgSet& theEvent); Perform one-time initialization of the generator context. void generateEvent(RooArgSet& theEvent, Int_t remaining); Generate one event. The 'remaining' integer is not used other than; for printing messages. void printMultiline(ostream& os, Int_t content, Bool_t verbose = kFALSE, TString indent = """") const; Printing interface. RooGenContext(const RooAbsPdf& model, const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE, const RooArgSet* forceDirect = 0). » Last changed: Mon Jul 4 15:23:00 2011 » Last generated: 2011-07-04 15:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooGenContext.html:10181,unsafe,unsafe,10181,root/html530/RooGenContext.html,https://root.cern,https://root.cern/root/html530/RooGenContext.html,1,['unsafe'],['unsafe']
Safety," over uniform observables; RooArgSet_uniformVars; Int_t_updateFMaxPerEventIf true, maximum p.d.f value needs to be recalculated for each event; Bool_tRooAbsGenContext::_verboseVerbose messaging?; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooGenContext(const RooAbsPdf& model, const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE, const RooArgSet* forceDirect = 0); Initialize a new context for generating events with the specified; variables, using the specified PDF model. A prototype dataset (if provided); is not cloned and still belongs to the caller. The contents and shape; of this dataset can be changed between calls to generate() as long as the; expected columns to be copied to the generated dataset are present.; Any argument supplied in the forceDirect RooArgSet are always offered; for internal generation to the p.d.f., even if this is deemed unsafe by; the logic of RooGenContext. ~RooGenContext(); Destructor. void attach(const RooArgSet& params); Attach the cloned model to the event buffer we will be filling. void initGenerator(const RooArgSet& theEvent); Perform one-time initialization of the generator context. void generateEvent(RooArgSet& theEvent, Int_t remaining); Generate one event. The 'remaining' integer is not used other than; for printing messages. void printMultiline(ostream& os, Int_t content, Bool_t verbose = kFALSE, TString indent = """") const; Printing interface. RooGenContext(const RooAbsPdf& model, const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE, const RooArgSet* forceDirect = 0). » Last changed: Sat Sep 5 16:40:26 2015 » Last generated: 2015-09-05 16:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooGenContext.html:10322,unsafe,unsafe,10322,root/html534/RooGenContext.html,https://root.cern,https://root.cern/root/html534/RooGenContext.html,1,['unsafe'],['unsafe']
Safety," override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void Terminate () override;  See TProofDraw::Terminate(). ;  ;  Public Member Functions inherited from TProofDraw;  TProofDraw ();  Constructor. ;  ;  ~TProofDraw () override;  Destructor. ;  ; void Begin (TTree *) override;  Executed by the client before processing. ;  ; void Init (TTree *) override;  Init the tree. ;  ; Bool_t Notify () override;  Called when a new tree is loaded. ;  ; Bool_t Process (Long64_t) override;  Executed for each entry. ;  ; void SlaveTerminate () override;  Executed by each slave after the processing has finished, before returning the results to the client. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; int Version () const override;  ;  Public Member Functions inherited from TSelector;  TSelector ();  Default selector ctor. ;  ;  ~TSelector () override;  Selector destructor. ;  ; virtual void Abort (const char *why, EAbort what=kAbortProcess);  Abort processing. ;  ; virtual EAbort GetAbort () const;  ; virtual Int_t GetEntry (Long64_t, Int_t=0);  ; virtual TList * GetInputList () const;  ; const char * GetOption () const override;  ; virtual TList * GetOutputList () const;  ; virtual Long64_t GetStatus () const;  ; virtual void ImportOutput (TList *output);  Imports the content of 'output' in the internal output list. ;  ; TClass * IsA () const override;  ; bool Notify () override;  This method must be overridden to handle object notification (the base implementation is no-op). ;  ; virtual bool ProcessCut (Long64_t);  This method is called before processing entry. ;  ; virtual void ProcessFill (Long64_t);  This method is called for all selected entries. ;  ; virtual void ResetAbort ();  ; virtual void SetInputList (TList *input);  ; virtual void SetObject (TObject *obj);  ; virtual void SetOption (const char *option);  ; virtual void SetStatus (Long64_t status);  ; void Streamer (TBuffer &) overri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofDrawListOfGraphs.html:1581,Abort,Abort,1581,doc/master/classTProofDrawListOfGraphs.html,https://root.cern,https://root.cern/doc/master/classTProofDrawListOfGraphs.html,4,['Abort'],['Abort']
Safety," override;; 144 void SavePrimitive(std::ostream &out, Option_t *option = """") override;; 145 ; 146 ClassDefOverride(TGeoTrap, 1) // G3 TRAP shape; 147};; 148 ; 149class TGeoGtra : public TGeoTrap {; 150protected:; 151 // data members; 152 Double_t fTwistAngle; // twist angle in degrees; 153public:; 154 // constructors; 155 TGeoGtra();; 156 TGeoGtra(Double_t dz, Double_t theta, Double_t phi, Double_t twist, Double_t h1, Double_t bl1, Double_t tl1,; 157 Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2);; 158 TGeoGtra(const char *name, Double_t dz, Double_t theta, Double_t phi, Double_t twist, Double_t h1, Double_t bl1,; 159 Double_t tl1, Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2);; 160 // destructor; 161 ~TGeoGtra() override;; 162 Double_t DistFromInside(const Double_t *point, const Double_t *dir, Int_t iact = 1, Double_t step = TGeoShape::Big(),; 163 Double_t *safe = nullptr) const override;; 164 void DistFromInside_v(const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize,; 165 Double_t *step) const override;; 166 Double_t DistFromOutside(const Double_t *point, const Double_t *dir, Int_t iact = 1,; 167 Double_t step = TGeoShape::Big(), Double_t *safe = nullptr) const override;; 168 void DistFromOutside_v(const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize,; 169 Double_t *step) const override;; 170 TGeoShape *GetMakeRuntimeShape(TGeoShape *mother, TGeoMatrix *mat) const override;; 171 Double_t GetTwistAngle() const { return fTwistAngle; }; 172 Double_t Safety(const Double_t *point, Bool_t in = kTRUE) const override;; 173 void Safety_v(const Double_t *points, const Bool_t *inside, Double_t *safe, Int_t vecsize) const override;; 174 void SetDimensions(Double_t *param) override;; 175 void SavePrimitive(std::ostream &out, Option_t *option = """") override;; 176 ; 177 ClassDefOverride(TGeoGtra, 1) // G3 GTRA shape; 178};; 179 ; 180#endif; Int_tint Int_tDefinition RtypesCore.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoArb8_8h_source.html:8907,safe,safe,8907,doc/master/TGeoArb8_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoArb8_8h_source.html,3,"['Safe', 'safe']","['Safety', 'safe']"
Safety," p.d.f evaluates to NaN @ numerator=wrap_pdf=-0.675078, denominator=wrap_pdf_Int[pTV]=86190.2; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=-0.675078, denominator=wrap_pdf_Int[pTV]=86190.2; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=0.186765 cHl3=8.8591 cHq3=-0.971282; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=-6.32705, denominator=wrap_pdf_Int[pTV]=46316; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=0.218731 cHl3=0.37397 cHq3=-2.08166; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=38.6705, denominator=wrap_pdf_Int[pTV]=90131.3; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=38.6705, denominator=wrap_pdf_Int[pTV]=90131.3; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=38.6705, denominator=wrap_pdf_Int[pTV]=90131.3; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=38.6705, denominator=wrap_pdf_Int[pTV]=90131.3; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=3.22694 cHl3=-7.04051 cHq3=0.54016; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=-2.21831, denominator=wrap_pdf_Int[pTV]=89722.5; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf712__lagrangianmorphfit_8C.html:11430,recover,recover,11430,doc/master/rf712__lagrangianmorphfit_8C.html,https://root.cern,https://root.cern/doc/master/rf712__lagrangianmorphfit_8C.html,2,['recover'],['recover']
Safety," p.d.f evaluates to NaN @ numerator=wrap_pdf=486.968, denominator=wrap_pdf_Int[pTV]=829530; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=0.154263 cHl3=2.95902 cHq3=-2.78828; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=59.1285, denominator=wrap_pdf_Int[pTV]=200921; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=0.338546 cHl3=0.879879 cHq3=-1.35856; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=14.3535, denominator=wrap_pdf_Int[pTV]=34082.1; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=14.3535, denominator=wrap_pdf_Int[pTV]=34082.1; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=14.3535, denominator=wrap_pdf_Int[pTV]=34082.1; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=14.3535, denominator=wrap_pdf_Int[pTV]=34082.1; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=0.372361 cHl3=0.491134 cHq3=-0.886807; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=5.8312, denominator=wrap_pdf_Int[pTV]=12183.6; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(wrap_pdf) Calculating sum-of-weights-squared correction matrix for covariance matrix; [#1] INFO:InputArguments -- RooAbsData::plotOn(pseudo_dh) INFO: dataset has non-integer weights, auto-selecting SumW2 errors instead ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf712__lagrangianmorphfit_8C.html:15764,recover,recover,15764,doc/master/rf712__lagrangianmorphfit_8C.html,https://root.cern,https://root.cern/doc/master/rf712__lagrangianmorphfit_8C.html,2,['recover'],['recover']
Safety," param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tGetActive(Long_t timeout = -1) const; Int_tGetDeActive() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TList*GetListOfActives() const; TList*TQObject::GetListOfClassSignals() const; TList*TQObject::GetListOfConnections() const; TList*GetListOfDeActives() const; TList*TQObject::GetListOfSignals() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual Bool_tTQObject::HasConnection(const char* signal_name) const; virtual ULong_tTObject::Hash() const; virtual voidTQObject::HighPriority(const char* signal_name, const char* slot_name = 0); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObje",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMonitor.html:4367,timeout,timeout,4367,root/html602/TMonitor.html,https://root.cern,https://root.cern/root/html602/TMonitor.html,2,['timeout'],['timeout']
Safety," pass a pointer to this object to timer, see the SetObject() method.; Pass an interpreter command to timer, see SetCommand() method.; Create a TTimer, connect its Timeout() signal to the appropriate methods. Then when the time is up it will emit a Timeout() signal and call connected slots. Minimum timeout interval is defined in TSystem::ESysConstants as kItimerResolution (currently 10 ms).; Signal/slots example: TTimer *timer = new TTimer();; timer->Connect(""Timeout()"", ""myObjectClassName"",; myObject, ""TimerDone()"");; timer->Start(2000, kTRUE); // 2 seconds single-shot; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; TQObject::ConnectBool_t Connect(const char *signal, const char *receiver_class, void *receiver, const char *slot)Non-static method is used to connect from the signal of this object to the receiver slot.Definition TQObject.cxx:869; TTimerHandles synchronous and a-synchronous timer events.Definition TTimer.h:51; TTimer::Startvirtual void Start(Long_t milliSec=-1, Bool_t singleShot=kFALSE)Starts the timer with a milliSec timeout.Definition TTimer.cxx:213; To emit the Timeout signal repeatedly with minimum timeout: timer->Start(0, kFALSE);; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94. Definition at line 51 of file TTimer.h. Public Member Functions;  TTimer (const char *command, Long_t milliSec, Bool_t mode=kTRUE);  Create timer that times out in ms milliseconds. ;  ;  TTimer (Long_t milliSec=0, Bool_t mode=kTRUE);  Create timer that times out in ms milliseconds. ;  ;  TTimer (TObject *obj, Long_t milliSec, Bool_t mode=kTRUE);  Create timer that times out in ms milliseconds. ;  ; virtual ~TTimer ();  ; void Add () override;  ; Bool_t CheckTimer (const TTime &now);  Check if timer timed out. ;  ; TTime GetAbsTime () const;  ; const char * GetCommand () const;  ; TObject * GetObject ();  ; TTime GetTime () const;  ; UInt_t GetTimerID ();  ; Bool_t HasTimedOut () const;  ; TClass * IsA () const override;  ; Bool_t IsAsync () const;  ; Bool_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTimer.html:1840,timeout,timeout,1840,doc/master/classTTimer.html,https://root.cern,https://root.cern/doc/master/classTTimer.html,1,['timeout'],['timeout']
Safety," path. const char * GetLinkedLibs() const; Return the list of library linked to this executable.; See TSystem::CompileMacro for more details. const char * GetLinkdefSuffix() const; Return the linkdef suffix chosen by the user for ACLiC.; See TSystem::CompileMacro for more details. const char * GetSoExt() const; Get the shared library extension. const char * GetObjExt() const; Get the object file extension. void SetBuildDir(const char* build_dir, Bool_t isflat = kFALSE); Set the location where ACLiC will create libraries and use as; a scratch area.; If isflast is flase, then the libraries are actually stored in; sub-directories of 'build_dir' including the full pathname of the; script. If the script is location at /full/path/name/macro.C; the library will be located at 'build_dir+/full/path/name/macro_C.so'; If 'isflat' is true, then no subdirectory is created and the library; is created directly in the directory 'build_dir'. Note that in this; mode there is a risk than 2 script of the same in different source; directory will over-write each other. void SetFlagsDebug(const char* ); FlagsDebug should contain the options to pass to the C++ compiler; in order to compile the library in debug mode. void SetFlagsOpt(const char* ); FlagsOpt should contain the options to pass to the C++ compiler; in order to compile the library in optimized mode. void SetAclicMode(TSystem::EAclicMode mode); AclicMode indicates whether the library should be built in; debug mode or optimized. The values are:; TSystem::kDefault : compile the same as the current ROOT; TSystem::kDebug : compiled in debug mode; TSystem::kOpt : optimized the library. void SetMakeExe(const char* directives); Directives has the same syntax as the argument of SetMakeSharedLib but is; used to create an executable. This creation is used as a means to output; a list of unresolved symbols, when loading a shared library has failed.; The required variable is $ExeName rather than $SharedLib, e.g.:; gSystem->SetMakeExe(; ""g++ ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSystem.html:44212,risk,risk,44212,root/html528/TSystem.html,https://root.cern,https://root.cern/root/html528/TSystem.html,6,['risk'],['risk']
Safety," pid index in this key/buffer. This is actually saved in the high bits of fSeekPdir; Long64_tfSeekKeyLocation of object on file; Long64_tfSeekPdirLocation of parent directory on file; TStringTNamed::fTitleobject title; Int_tfVersionKey version identifier. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TKey(); TKey default constructor. TKey(TDirectory* motherDir); TKey default constructor. TKey(TDirectory* motherDir, const TKey& orig, UShort_t pidOffset); Copy a TKey from its original directory to the new 'motherDir'. TKey(Long64_t pointer, Int_t nbytes, TDirectory* motherDir = 0); Create a TKey object to read keys.; Constructor called by TDirectoryFile::ReadKeys and by TFile::TFile.; A TKey object is created to read the keys structure itself. TKey(const char* name, const char* title, const TClass* cl, Int_t nbytes, TDirectory* motherDir = 0); Create a TKey object with the specified name, title for the given class. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). TKey(const TString& name, const TString& title, const TClass* cl, Int_t nbytes, TDirectory* motherDir = 0); Create a TKey object with the specified name, title for the given class. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). TKey(const TObject* obj, const char* name, Int_t bufsize, TDirectory* motherDir = 0); Create a TKey object for a TObject* and fill output buffer. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). TKey(const void* obj, const TClass* cl, const char* name, Int_t bufsize, TDirectory* motherDir = 0); Create a TKey object for any object obj of class cl d and fill; output buffer. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). void Build(TDirectory* motherDir,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TKey.html:9684,avoid,avoid,9684,root/html532/TKey.html,https://root.cern,https://root.cern/root/html532/TKey.html,2,['avoid'],['avoid']
Safety," plotting.; # We create pointers to the plotted objects. We want these objects to leak out of the function,; # so we can still see them after it returns.; c = ROOT.TCanvas(); frame = x.frame(); data.plotOn(frame, Name=""data""); ; # Plotting a PDF with disallowed parameters doesn't work. We would get a lot of error messages.; # Therefore, we disable plotting messages in RooFit's message streams:; ROOT.RooMsgService.instance().getStream(0).removeTopic(ROOT.RooFit.Plotting); ROOT.RooMsgService.instance().getStream(1).removeTopic(ROOT.RooFit.Plotting); ; ; # RooFit before ROOT 6.24; # --------------------------------; # Before 6.24, RooFit wasn't able to recover from invalid parameters. The minimiser just errs around; # the starting values of the parameters without finding any improvement.; ; # Set up the parameters such that the PDF would come out negative. The PDF is now undefined.; a1.setVal(10.0); a2.setVal(-1.0); ; # Perform a fit:; fitWithoutRecovery = pdf.fitTo(; data,; Save=True,; RecoverFromUndefinedRegions=0.0, # This is how RooFit behaved prior to ROOT 6.24; PrintEvalErrors=-1, # We are expecting a lot of evaluation errors. -1 switches off printing.; PrintLevel=-1,; ); ; pdf.plotOn(frame, LineColor=""r"", Name=""noRecovery""); ; ; # RooFit since ROOT 6.24; # --------------------------------; # The minimiser gets information about the ""badness"" of the violation of the function definition. It uses this; # to find its way out of the disallowed parameter regions.; print(""\n\n\n-------------- Starting second fit ---------------\n\n""); ; # Reset the parameters such that the PDF is again undefined.; a1.setVal(10.0); a2.setVal(-1.0); ; # Fit again, but pass recovery information to the minimiser:; fitWithRecovery = pdf.fitTo(; data,; Save=True,; RecoverFromUndefinedRegions=1.0, # The magnitude of the recovery information can be chosen here.; # Higher values mean more aggressive recovery.; PrintEvalErrors=-1, # We are still expecting a few evaluation errors.; PrintLevel=0,; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html:2392,Recover,RecoverFromUndefinedRegions,2392,doc/master/rf612__recoverFromInvalidParameters_8py.html,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html,1,['Recover'],['RecoverFromUndefinedRegions']
Safety," points, const Double_t* dirs, Double_t* norms, Int_t vecsize); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidDefineSection(Int_t snum, Double_t z, Double_t rmin, Double_t rmax); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tDistToSegZ(const Double_t* point, const Double_t* dir, Int_t& iz) const; virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Double_t&Dphi(); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* meth",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoPcon.html:2711,safe,safe,2711,root/html534/TGeoPcon.html,https://root.cern,https://root.cern/root/html534/TGeoPcon.html,3,['safe'],['safe']
Safety, private . ! Derivative for curvature matrix ; Definition at line 129 of file TSVDUnfold.h. ◆ fDHist. TH1D* TSVDUnfold::fDHist. private . ! Distribution of d (for checking regularization) ; Definition at line 132 of file TSVDUnfold.h. ◆ fKReg. Int_t TSVDUnfold::fKReg. private . ! Regularisation parameter ; Definition at line 131 of file TSVDUnfold.h. ◆ fMatToyMode. Bool_t TSVDUnfold::fMatToyMode. private . ! Internal switch for evaluation of statistical uncertainties from response matrix ; Definition at line 152 of file TSVDUnfold.h. ◆ fNdim. Int_t TSVDUnfold::fNdim. private . ! Truth and reconstructed dimensions ; Definition at line 128 of file TSVDUnfold.h. ◆ fNormalize. Bool_t TSVDUnfold::fNormalize. private . ! Normalize unfolded spectrum to 1 ; Definition at line 130 of file TSVDUnfold.h. ◆ fSVHist. TH1D* TSVDUnfold::fSVHist. private . ! Distribution of singular values ; Definition at line 133 of file TSVDUnfold.h. ◆ fToyhisto. TH1D* TSVDUnfold::fToyhisto. private . ! Toy MC histogram ; Definition at line 149 of file TSVDUnfold.h. ◆ fToymat. TH2D* TSVDUnfold::fToymat. private . ! Toy MC detector response matrix ; Definition at line 150 of file TSVDUnfold.h. ◆ fToyMode. Bool_t TSVDUnfold::fToyMode. private . ! Internal switch for covariance matrix propagation ; Definition at line 151 of file TSVDUnfold.h. ◆ fXini. const TH1D* TSVDUnfold::fXini. private . Truth distribution (MC) ; Definition at line 143 of file TSVDUnfold.h. ◆ fXinv. TH2D* TSVDUnfold::fXinv. private . ! Computed inverse of covariance matrix ; Definition at line 135 of file TSVDUnfold.h. ◆ fXtau. TH2D* TSVDUnfold::fXtau. private . ! Computed regularized covariance matrix ; Definition at line 134 of file TSVDUnfold.h. Libraries for TSVDUnfold:. [legend]; The documentation for this class was generated from the following files:; hist/hist/inc/TSVDUnfold.h; hist/hist/src/TSVDUnfold.cxx. TSVDUnfold. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:44:36 (GVA Time) using Doxygen 1.9.8   ; . ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSVDUnfold.html:26446,detect,detector,26446,doc/master/classTSVDUnfold.html,https://root.cern,https://root.cern/doc/master/classTSVDUnfold.html,1,['detect'],['detector']
Safety," private . Method to find potentially relevant candidate bounding boxes for safety calculation given a point. ; Uses BVH to do so. ; Definition at line 802 of file TGeoParallelWorld.cxx. ◆ GetGeometry(). TGeoManager * TGeoParallelWorld::GetGeometry ; (; ); const. inline . Definition at line 142 of file TGeoParallelWorld.h. ◆ GetLoopSafetyCandidates(). std::pair< double, double > TGeoParallelWorld::GetLoopSafetyCandidates ; (; double ; point[3], . std::vector< int > & ; candidates, . double ; margin = 0. . ); const. private . Method to find potentially relevant candidate bounding boxes for safety calculation given a point. ; Uses trivial algorithm to do so. ; Definition at line 740 of file TGeoParallelWorld.cxx. ◆ GetVolume(). TGeoVolume * TGeoParallelWorld::GetVolume ; (; ); const. inline . Definition at line 144 of file TGeoParallelWorld.h. ◆ InitSafetyVoxel(). void TGeoParallelWorld::InitSafetyVoxel ; (; TGeoVoxelGridIndex const & ; vi). private . Method to initialize the safety voxel at a specific 3D voxel (grid) index. ; Definition at line 916 of file TGeoParallelWorld.cxx. ◆ IsA(). TClass * TGeoParallelWorld::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 184 of file TGeoParallelWorld.h. ◆ IsClosed(). Bool_t TGeoParallelWorld::IsClosed ; (; ); const. inline . Definition at line 143 of file TGeoParallelWorld.h. ◆ IsUsingOverlaps(). Bool_t TGeoParallelWorld::IsUsingOverlaps ; (; ); const. inline . Definition at line 81 of file TGeoParallelWorld.h. ◆ operator=(). TGeoParallelWorld & TGeoParallelWorld::operator= ; (; const TGeoParallelWorld & ; ). protecteddelete . ◆ PrintBVH(). void TGeoParallelWorld::PrintBVH ; (; ); const. Prints the BVH. ; Definition at line 374 of file TGeoParallelWorld.cxx. ◆ PrintDetectedOverlaps(). Int_t TGeoParallelWorld::PrintDetectedOverlaps ; (; ); const. Print the overlaps which were detected during real tracking. ; Definition at line 135 of file TGeoP",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoParallelWorld.html:24236,safe,safety,24236,doc/master/classTGeoParallelWorld.html,https://root.cern,https://root.cern/doc/master/classTGeoParallelWorld.html,1,['safe'],['safety']
Safety," processed ; [in]callbackA callable with signature void(unsigned int, Value_t&) where Value_t is the type of the value contained in this RResultPtr . Returnsthis RResultPtr, to allow chaining of OnPartialResultSlot with other calls; See OnPartialResult for a generic explanation of the callback mechanism. Compared to OnPartialResult, this method has two major differences:; all worker threads invoke the callback once every specified number of events. The event count is per-thread, and callback invocation might happen concurrently (i.e. the callback must be thread-safe); the callable must take an extra unsigned int parameter corresponding to a multi-thread ""processing slot"": this is a ""helper value"" to simplify writing thread-safe callbacks: different worker threads might invoke the callback concurrently but always with different slot numbers.; a value of 0 for everyNEvents indicates the callback must be executed once per slot. For example, the following snippet prints out a thread-safe progress bar of the events processed by RDataFrame auto c = tdf.Count(); // any action would do, but `Count` is the most lightweight; std::string progress;; std::mutex bar_mutex;; c.OnPartialResultSlot(nEvents / 100, [&progress, &bar_mutex](unsigned int, ULong64_t &) {; std::lock_guard<std::mutex> lg(bar_mutex);; progress.push_back('#');; std::cout << ""\r["" << std::left << std::setw(100) << progress << ']' << std::flush;; });; std::cout << ""Analysis running..."" << std::endl;; *c; // trigger the event loop by accessing an action's result; std::cout << ""\nDone!"" << std::endl;; ULong64_tunsigned long long ULong64_tDefinition RtypesCore.h:70. Definition at line 364 of file RResultPtr.hxx. ◆ operator bool(). template<typename T > . ROOT::RDF::RResultPtr< T >::operator bool ; (; ); const. inlineexplicit . Definition at line 214 of file RResultPtr.hxx. ◆ operator*(). template<typename T > . T & ROOT::RDF::RResultPtr< T >::operator* ; (; ). inline . Get a pointer to the encapsulated object. ; Tr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDF_1_1RResultPtr.html:13168,safe,safe,13168,doc/master/classROOT_1_1RDF_1_1RResultPtr.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDF_1_1RResultPtr.html,1,['safe'],['safe']
Safety," progress bar. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSessionQueryFrame(TGWindow* parent, Int_t w, Int_t h); Constructor. ~TSessionQueryFrame(); Destructor. void Build(TSessionViewer* gui); Build query information frame. void Modified(Bool_t mod = kTRUE); Notify changes in query editor settings. void Feedback(TList* objs); Feedback function connected to Feedback signal.; Used to update feedback histograms. void UpdateHistos(TList* objs); Update feedback histograms. void Progress(Long64_t total, Long64_t processed); Update progress bar and status labels. void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti, Int_t actw, Int_t tses, Float_t eses); New version of Progress (just forward to the old version; for the time being). void ProgressLocal(Long64_t total, Long64_t processed); Update progress bar and status labels. void IndicateStop(Bool_t aborted); Indicate that Cancel or Stop was clicked. void ResetProgressDialog(const char* selec, Int_t files, Long64_t first, Long64_t entries); Reset progress frame information fields. void OnBtnFinalize(); Finalize query. void OnBtnStop(); Stop processing query. void OnBtnShowLog(); Show query log. void OnBtnRetrieve(); Retrieve query. void OnBtnAbort(); Abort processing query. void OnBtnSubmit(); Submit query. void UpdateButtons(TQueryDescription* desc); Update buttons state for the current query status. void UpdateInfos(); Update query information (header) text view. TGTab * GetTab() const; { return fTab; }. TCanvas * GetStatsCanvas() const; { return fStatsCanvas; }. TEditQueryFrame * GetQueryEditFrame() const; { return fFD; }. void Progress(Long64_t total, Long64_t processed). » Author: Marek Biskup, Jakub Madejczyk, Bertrand Bellenot 10/08/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/sessionviewer:$Id$ » Last generated: 2015-03-14 16:49; This page has ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TSessionQueryFrame.html:21881,abort,aborted,21881,root/html534/TSessionQueryFrame.html,https://root.cern,https://root.cern/root/html534/TSessionQueryFrame.html,1,['abort'],['aborted']
Safety," protocol.; 4108 if (gEnv->GetValue(""TFile.CrossProtocolRedirects"", 1) == 1) {; 4109 TUrl fileurl(expandedUrl, /* default is file */ kTRUE);; 4110 if (strcmp(fileurl.GetProtocol(), ""file"") == 0) {; 4111 ssize_t len = getxattr(fileurl.GetFile(), ""eos.url.xroot"", nullptr, 0);; 4112 if (len > 0) {; 4113 std::string xurl(len, 0);; 4114 if (getxattr(fileurl.GetFile(), ""eos.url.xroot"", &xurl[0], len) == len) {; 4115 if ((f = TFile::Open(xurl.c_str(), options, ftitle, compress, netopt))) {; 4116 if (!f->IsZombie()) {; 4117 return f;; 4118 } else {; 4119 delete f;; 4120 f = nullptr;; 4121 }; 4122 }; 4123 }; 4124 }; 4125 }; 4126 }; 4127#endif; 4128 ; 4129 // If a timeout has been specified extract the value and try to apply it (it requires; 4130 // support for asynchronous open, though; the following is completely transparent if; 4131 // such support if not available for the required protocol); 4132 TString opts(options);; 4133 Int_t ito = opts.Index(""TIMEOUT="");; 4134 if (ito != kNPOS) {; 4135 TString sto = opts(ito + strlen(""TIMEOUT=""), opts.Length());; 4136 while (!(sto.IsDigit()) && !(sto.IsNull())) { sto.Remove(sto.Length()-1,1); }; 4137 if (!(sto.IsNull())) {; 4138 // Timeout in millisecs; 4139 Int_t toms = sto.Atoi() * 1000;; 4140 if (gDebug > 0) ::Info(""TFile::Open"", ""timeout of %d millisec requested"", toms);; 4141 // Remove from the options field; 4142 sto.Insert(0, ""TIMEOUT="");; 4143 opts.ReplaceAll(sto, """");; 4144 // Asynchronous open; 4145 TFileOpenHandle *fh = TFile::AsyncOpen(expandedUrl, opts, ftitle, compress, netopt);; 4146 // Check the result in steps of 1 millisec; 4147 TFile::EAsyncOpenStatus aos = TFile::kAOSNotAsync;; 4148 aos = TFile::GetAsyncOpenStatus(fh);; 4149 Int_t xtms = toms;; 4150 while (aos == TFile::kAOSInProgress && xtms > 0) {; 4151 gSystem->Sleep(1);; 4152 xtms -= 1;; 4153 aos = TFile::GetAsyncOpenStatus(fh);; 4154 }; 4155 if (aos == TFile::kAOSNotAsync || aos == TFile::kAOSSuccess) {; 4156 // Do open the file now; 4157 f = TFile::Open(fh);",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:151212,TIMEOUT,TIMEOUT,151212,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,2,['TIMEOUT'],['TIMEOUT']
Safety," ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoParaboloid&operator=(const TGeoParaboloid&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidSetParaboloidDimensions(Double_t rlo, Double_t rhi, Double_t dz); virtual voidSetPoints(Double_t* points) const; virtual voidSetPoints(Float_t* points) const; voidTGeoShape",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoParaboloid.html:8880,Safe,SafetySeg,8880,root/html602/TGeoParaboloid.html,https://root.cern,https://root.cern/root/html602/TGeoParaboloid.html,2,['Safe'],['SafetySeg']
Safety," public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. stringfFileNamePrefix; intfHighBin; intfLowBin; doublefLumiError; doublefNomLumi; TFile*fOut_f; stringstreamfResultsPrefixStr; stringfRowTitle; vector<string>fSystToFix; FILE*pFile. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; HistoToWorkspaceFactory(); {}. ~HistoToWorkspaceFactory(). HistoToWorkspaceFactory(string , string , vector<string> , double = 200, double = 20, int = 0, int = 6, TFile* = 0). string FilePrefixStr(string ). void ProcessExpectedHisto(TH1F* hist, RooWorkspace* proto, string prefix, string productPrefix, string systTerm, double low, double high, int lowBin, int highBin). void AddMultiVarGaussConstraint(RooWorkspace* proto, string prefix, int lowBin, int highBin, vector<string>& likelihoodTermNames); these are the nominal predictions: eg. the mean of some space of variations; later fill these in a loop over histogram bins. void LinInterpWithConstraint(RooWorkspace* proto, TH1F* nominal, vector<TH1F*> lowHist, vector<TH1F*> highHist, vector<string> sourceName, string prefix, string productPrefix, string systTerm, int lowBin, int highBin, vector<string>& likelihoodTermNames); these are the nominal predictions: eg. the mean of some space of variations; later fill these in a loop over histogram bins; make list of abstract parameters that interpolate in space of variations; range is set using defined macro (see top of the page). string AddNormFactor(RooWorkspace* , string& , string& , RooStats::HistFactory::EstimateSummary& , bool ). void AddEfficiencyTerms(RooWorkspace* proto, string prefix, string interpName, map<string,pair<double,double> > systMap, vector<string>& likelihoodTermNames, vector<string>& totSystTermNames); add variables for",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooStats__HistFactory__HistoToWorkspaceFactory.html:8274,predict,predictions,8274,root/html528/RooStats__HistFactory__HistoToWorkspaceFactory.html,https://root.cern,https://root.cern/root/html528/RooStats__HistFactory__HistoToWorkspaceFactory.html,1,['predict'],['predictions']
Safety," queryend = kFALSE, Bool_t force = kFALSE); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTProofPlayer::SetCurrentQuery(TQueryResult* q); virtual voidTProofPlayer::SetDispatchTimer(Bool_t on = kTRUE); virtual voidTProofPlayer::SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTProofPlayer::SetExitStatus(TVirtualProofPlayer::EExitStatus st); virtual voidTProofPlayerRemote::SetInitTime(); virtual voidTProofPlayer::SetMaxDrawQueries(Int_t max); virtual voidTProofPlayerRemote::SetMerging(Bool_t on = kTRUE); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTProofPlayer::SetOutputFilePath(const char* fp); voidTProofPlayer::SetProcessing(Bool_t on = kTRUE); virtual voidTProofPlayer::SetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidTProofPlayerRemote::StopProcess(Bool_t abort, Int_t timeout = -1); virtual voidStoreFeedback(TObject* slave, TList* out); virtual voidTProofPlayerRemote::StoreOutput(TList* out); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TProofPlayerLite(TProof* proof = 0); TProofPlayerLite(const TProofPlayerLite&); virtual voidTProofPlayer::UpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidTProofPlayer::UpdateProgressInfo(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TProofPlayerLite.html:11137,timeout,timeout,11137,root/html604/TProofPlayerLite.html,https://root.cern,https://root.cern/root/html604/TProofPlayerLite.html,1,['timeout'],['timeout']
Safety," queryend = kFALSE, Bool_t force = kFALSE); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTProofPlayer::SetCurrentQuery(TQueryResult* q); virtual voidTProofPlayer::SetDispatchTimer(Bool_t on = kTRUE); virtual voidTProofPlayer::SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTProofPlayer::SetExitStatus(TVirtualProofPlayer::EExitStatus st); virtual voidTProofPlayerRemote::SetInitTime(); virtual voidTProofPlayer::SetMaxDrawQueries(Int_t max); virtual voidTProofPlayerRemote::SetMerging(Bool_t on = kTRUE); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTProofPlayer::SetOutputFilePath(const char* fp); voidTProofPlayer::SetProcessing(Bool_t on = kTRUE); virtual voidTProofPlayer::SetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidTProofPlayerRemote::StopProcess(Bool_t abort, Int_t timeout = -1); virtual voidTProofPlayerRemote::StoreFeedback(TObject* slave, TList* out); virtual voidTProofPlayerRemote::StoreOutput(TList* out); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TProofPlayerSuperMaster(TProof* proof = 0); TProofPlayerSuperMaster(const TProofPlayerSuperMaster&); virtual voidTProofPlayer::UpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidTProofPlayer::UpdateProgressInfo(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TProofPlayerSuperMaster.html:11547,timeout,timeout,11547,root/html604/TProofPlayerSuperMaster.html,https://root.cern,https://root.cern/root/html604/TProofPlayerSuperMaster.html,1,['timeout'],['timeout']
Safety," queryend = kFALSE, Bool_t force = kFALSE); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTProofPlayer::SetCurrentQuery(TQueryResult* q); virtual voidTProofPlayer::SetDispatchTimer(Bool_t on = kTRUE); virtual voidTProofPlayer::SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTProofPlayer::SetExitStatus(TVirtualProofPlayer::EExitStatus st); virtual voidTProofPlayerRemote::SetInitTime(); virtual voidTProofPlayer::SetMaxDrawQueries(Int_t max); virtual voidTProofPlayerRemote::SetMerging(Bool_t on = kTRUE); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTProofPlayer::SetOutputFilePath(const char* fp); voidTProofPlayer::SetProcessing(Bool_t on = kTRUE); virtual voidTProofPlayer::SetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector&); virtual voidTProofPlayerRemote::StopProcess(Bool_t abort, Int_t timeout = -1); virtual voidStoreFeedback(TObject* slave, TList* out); virtual voidTProofPlayerRemote::StoreOutput(TList* out); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTProofPlayer::UpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidTProofPlayer::UpdateProgressInfo(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofPlayerLite.html:11210,timeout,timeout,11210,root/html534/TProofPlayerLite.html,https://root.cern,https://root.cern/root/html534/TProofPlayerLite.html,1,['timeout'],['timeout']
Safety," queryend = kFALSE, Bool_t force = kFALSE); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTProofPlayer::SetCurrentQuery(TQueryResult* q); virtual voidTProofPlayer::SetDispatchTimer(Bool_t on = kTRUE); virtual voidTProofPlayer::SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTProofPlayer::SetExitStatus(TVirtualProofPlayer::EExitStatus st); virtual voidTProofPlayerRemote::SetInitTime(); virtual voidTProofPlayer::SetMaxDrawQueries(Int_t max); virtual voidTProofPlayerRemote::SetMerging(Bool_t on = kTRUE); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTProofPlayer::SetOutputFilePath(const char* fp); voidTProofPlayer::SetProcessing(Bool_t on = kTRUE); virtual voidTProofPlayer::SetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector&); virtual voidTProofPlayerRemote::StopProcess(Bool_t abort, Int_t timeout = -1); virtual voidTProofPlayerRemote::StoreFeedback(TObject* slave, TList* out); virtual voidTProofPlayerRemote::StoreOutput(TList* out); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTProofPlayer::UpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidTProofPlayer::UpdateProgressInfo(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofPlayerSuperMaster.html:11637,timeout,timeout,11637,root/html534/TProofPlayerSuperMaster.html,https://root.cern,https://root.cern/root/html534/TProofPlayerSuperMaster.html,1,['timeout'],['timeout']
Safety," read by TObject::Streamer, the pidf is read.; At this point, robj is entered into the table of objects of the TProcessID; corresponding to pidf. WARNING1: If MyClass is the class of the referenced object, The TObject; part of MyClass must be Streamed. One should not; call MyClass::Class()->IgnoreTObjectStreamer(). WARNING2: A TRef cannot point to another TRef. ObjectNumber. When an object is referenced (see TRef assignement operator or TRefArray::Add); a unique identifier is computed and stored in both the fUniqueID of the; referenced and referencing object. This uniqueID is computed by incrementing; by one the static global in TProcessID::fgNumber. fUniqueID is some sort of; serial object number in the current session. One can retrieve at any time; the current value of fgNumber by calling the static function TProcessID::GetObjectCount; or set this number via TProcessID::SetObjectCount.; To avoid a growing table of fObjects in TProcessID, in case, for example,; one processes many events in a loop, it might be necessary to reset the; ObjectNumber at the end of processing of one event. See an example; in $ROOTSYS/test/Event.cxx (look at function Build).; The value of ObjectNumber (say saveNumber=TProcessID::GetObjectCount()) may be; saved at the beginning of one event and reset to this original value; at the end of the event via TProcessID::SetObjectCount(saveNumber). These; actions may be stacked. Action on Demand. The normal behaviour of a TRef has been described above. In addition,; TRef supports also ""Actions on Demand"". It may happen that the object; referenced is not yet in memory, on a separate file or not yet computed.; In this case TRef is able to automatically execute an action:; - call to a compiled function (static function of member function); - call to an interpreted function; - execution of a CINT script. How to select this option?; In the definition of the TRef data member in the original class, do:; TRef fRef; //EXEC:execName. points to something; Whe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TRef.html:4166,avoid,avoid,4166,root/html528/TRef.html,https://root.cern,https://root.cern/root/html528/TRef.html,6,['avoid'],['avoid']
Safety," reasons, the names tdfentry_ and tdfslot_ are also accepted. These columns are ignored by operations such as Cache or Snapshot.; WarningNote that in multi-thread event loops the values of rdfentry_ do not correspond to what would be the entry numbers of a TChain constructed over the same set of ROOT files, as the entries are processed in an unspecified order. Just-in-time compilation: column type inference and explicit declaration of column types; C++ is a statically typed language: all types must be known at compile-time. This includes the types of the TTree branches we want to work on. For filters, defined columns and some of the actions, column types are deduced from the signature of the relevant filter function/temporary column expression/action function: // here b1 is deduced to be `int` and b2 to be `double`; df.Filter([](int x, double y) { return x > 0 && y < 0.; }, {""b1"", ""b2""});; If we specify an incorrect type for one of the columns, an exception with an informative message will be thrown at runtime, when the column value is actually read from the dataset: RDataFrame detects type mismatches. The same would happen if we swapped the order of ""b1"" and ""b2"" in the column list passed to Filter().; Certain actions, on the other hand, do not take a function as argument (e.g. Histo1D()), so we cannot deduce the type of the column at compile-time. In this case RDataFrame infers the type of the column from the TTree itself. This is why we never needed to specify the column types for all actions in the above snippets.; When the column type is not a common one such as int, double, char or float it is nonetheless good practice to specify it as a template parameter to the action itself, like this: df.Histo1D(""b1""); // OK, the type of ""b1"" is deduced at runtime; df.Min<MyNumber_t>(""myObject""); // OK, ""myObject"" is deduced to be of type `MyNumber_t`; Deducing types at runtime requires the just-in-time compilation of the relevant actions, which has a small runtime overhead",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:63599,detect,detects,63599,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,2,['detect'],['detects']
Safety," receiver object. ;  ; static Bool_t ConnectToClass (TQObject *sender, const char *signal, TClass *receiver_class, void *receiver, const char *slot);  Create connection between sender and receiver. ;  ;  Protected Attributes inherited from TTimer; TTime fAbsTime;  ; TString fCommand;  ; Bool_t fIntSyscalls;  ; TObject * fObject;  ; Bool_t fSync;  ; TTime fTime;  ; UInt_t fTimeID;  ; Bool_t fTimeout;  ;  Protected Attributes inherited from TQObject; TList * fListOfConnections;  list of signals from this object ;  ; TList * fListOfSignals;  ; Bool_t fSignalsBlocked;  list of connections to this object ;  ;  Static Protected Attributes inherited from TQObject; static Bool_t fgAllSignalsBlocked = kFALSE;  flag used for suppression of signals ;  . Inheritance diagram for TStopTimer:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TStopTimer(). TStopTimer::TStopTimer ; (; TProofPlayer * ; p, . Bool_t ; abort, . Int_t ; to . ). Constructor for the timer to stop/abort processing. ; The 'timeout' is in seconds. Make sure that 'to' make sense, i.e. not larger than 10 days; the minimum value is 10 ms (0 does not seem to start the timer ...). ; Definition at line 186 of file TProofPlayer.cxx. Member Function Documentation. ◆ Notify(). Bool_t TStopTimer::Notify ; (; ). overridevirtual . Handle the signal coming from the expiration of the timer associated with an abort or stop request. ; We raise an exception which will be processed in the event loop. ; Implements TSysEvtHandler.; Definition at line 205 of file TProofPlayer.cxx. Member Data Documentation. ◆ fAbort. Bool_t TStopTimer::fAbort. private . Definition at line 171 of file TProofPlayer.cxx. ◆ fPlayer. TProofPlayer* TStopTimer::fPlayer. private . Definition at line 172 of file TProofPlayer.cxx. proof/proofplayer/src/TProofPlayer.cxx. TStopTimer. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:44:33 (GVA Time) using Doxy",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTStopTimer.html:17486,abort,abort,17486,doc/master/classTStopTimer.html,https://root.cern,https://root.cern/doc/master/classTStopTimer.html,1,['abort'],['abort']
Safety," regularisation parameter ;  ; Int_t RegularizeBins (int start, int step, int nbin, ERegMode regmode);  add regularisation conditions for a group of bins ;  ; Int_t RegularizeBins2D (int start_bin, int step1, int nbin1, int step2, int nbin2, ERegMode regmode);  add regularisation conditions for 2d unfolding ;  ; Int_t RegularizeCurvature (int left_bin, int center_bin, int right_bin, Double_t scale_left=1.0, Double_t scale_right=1.0);  add a regularisation condition on the curvature of three truth bin ;  ; Int_t RegularizeDerivative (int left_bin, int right_bin, Double_t scale=1.0);  add a regularisation condition on the difference of two truth bin ;  ; Int_t RegularizeSize (int bin, Double_t scale=1.0);  add a regularisation condition on the magnitude of a truth bin ;  ; virtual Int_t ScanLcurve (Int_t nPoint, Double_t tauMin, Double_t tauMax, TGraph **lCurve, TSpline **logTauX=nullptr, TSpline **logTauY=nullptr, TSpline **logTauCurvature=nullptr);  scan the L curve, determine tau and unfold at the final value of tau ;  ; virtual Int_t ScanSURE (Int_t nPoint, Double_t tauMin, Double_t tauMax, TGraph **logTauSURE=nullptr, TGraph **df_chi2A=nullptr, TGraph **lCurve=nullptr);  minimize Stein's unbiased risk estimator ""SURE"" using successive calls to DoUnfold at various tau. ;  ; void SetBias (const TH1 *bias);  set bias vector ;  ; void SetConstraint (EConstraint constraint);  set type of area constraint ;  ; void SetEpsMatrix (Double_t eps);  set numerical accuracy for Eigenvalue analysis when inverting matrices with rank problems ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnfoldDensity.html:22096,risk,risk,22096,doc/master/classTUnfoldDensity.html,https://root.cern,https://root.cern/doc/master/classTUnfoldDensity.html,2,['risk'],['risk']
Safety," removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoHype&operator=(const TGeoHype&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; Double_tRadiusHypeSq(Double_t z, Bool_t inner) const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoTube::SafetyS(const Double_t* point, Bool_t in, Double_t rmin, Double_t rmax, Double_t dz, Int_t skipz = 0); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); Double_tSafetyToHype(const Double_t* point, Bool_t inner, Bool_t in) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetHypeDimensions(Double_t rin, Double_t stin, Double_t rout, Double_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoHype.html:9963,Safe,SafetyPhi,9963,root/html602/TGeoHype.html,https://root.cern,https://root.cern/root/html602/TGeoHype.html,2,['Safe'],['SafetyPhi']
Safety," reqSections, Bool_t localFrame) const; Fills a static 3D buffer and returns a reference. void Contains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoCone(); methods; constructors. Int_t GetByteCount() const; {return 56;}. Double_t GetDz() const; {return fDz;}. Double_t GetRmin1() const; {return fRmin1;}. Double_t GetRmax1() const; {return fRmax1;}. Double_t GetRmin2() const; {return fRmin2;}. Double_t GetRmax2() const; {return fRmax2;}. Bool_t IsCylType() const; {return kTRUE;}. » Author: Andrei Gheata 31/01/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-03-14 16:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoCone.html:20294,safe,safe,20294,root/html534/TGeoCone.html,https://root.cern,https://root.cern/root/html534/TGeoCone.html,3,"['Safe', 'safe']","['Safety', 'safe']"
Safety," reqSections, Bool_t localFrame) const; Fills a static 3D buffer and returns a reference. void Contains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoCone(); methods; constructors. Int_t GetByteCount() const; {return 56;}. Double_t GetDz() const; {return fDz;}. Double_t GetRmin1() const; {return fRmin1;}. Double_t GetRmax1() const; {return fRmax1;}. Double_t GetRmin2() const; {return fRmin2;}. Double_t GetRmax2() const; {return fRmax2;}. Bool_t IsCylType() const; {return kTRUE;}. » Author: Andrei Gheata 31/01/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-06-02 16:00; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGeoCone.html:22048,safe,safe,22048,root/html604/TGeoCone.html,https://root.cern,https://root.cern/root/html604/TGeoCone.html,3,"['Safe', 'safe']","['Safety', 'safe']"
Safety," reqSections, Bool_t localFrame) const; Fills a static 3D buffer and returns a reference. void Contains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoCone(); methods; constructors. Int_t GetByteCount() const; {return 56;}. Double_t GetDz() const; {return fDz;}. Double_t GetRmin1() const; {return fRmin1;}. Double_t GetRmax1() const; {return fRmax1;}. Double_t GetRmin2() const; {return fRmin2;}. Double_t GetRmax2() const; {return fRmax2;}. Bool_t IsCylType() const; {return kTRUE;}. » Author: Andrei Gheata 31/01/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-06-30 15:00; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoCone.html:22048,safe,safe,22048,root/html602/TGeoCone.html,https://root.cern,https://root.cern/root/html602/TGeoCone.html,3,"['Safe', 'safe']","['Safety', 'safe']"
Safety," required tasks in its local reference system. Note that the manager class handles global queries related to geometry. However, shape-related queries might be sometimes useful:; Bool_t TGeoShape::Contains(Double_t *point[3]);; Bool_tbool Bool_tDefinition RtypesCore.h:63; Double_tdouble Double_tDefinition RtypesCore.h:59; TGeoShape::Containsvirtual Bool_t Contains(const Double_t *point) const =0; The method above returns kTRUE if the point *point is actually inside the shape. The point has to be defined in the local shape reference. For instance, for a box having DX,DY and DZhalf-lengths a point will be considered inside if:; -DX <= point[0] <= DX; -DY <= point[1] <= DY; -DZ <= point[2] <= DZ; Double_t TGeoShape::DistFromInside(Double_t *point[3],; Double_t *dir[3], Int_t iact,Double_t step,Double_t *safe);; Int_tint Int_tDefinition RtypesCore.h:45; TGeoShape::DistFromInsidevirtual Double_t DistFromInside(const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const =0; The method computes the distance to exiting a shape from a given point inside, along a given direction. This direction is given by its director cosines with respect to the local shape coordinate system. This method provides additional information according the value of iact input parameter:. iact = 0computes only safe distance and fill it at the location given by SAFE;; iact = 1a proposed STEP is supplied. The safe distance is computed first. If this is bigger than STEP than the proposed step is approved and returned by the method since it does not cross the shape boundaries. Otherwise, the distance to exiting the shape is computed and returned;; iact = 2computes both safe distance and distance to exiting, ignoring the proposed step;; iact > 2computes only the distance to exiting, ignoring anything else. Double_t TGeoShape::DistFromOutside(Double_t *point[3],; Double_t *dir[3],Int_t iact,Double_t step,Double_t *safe);; TGeoShape::DistFromOutsid",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Shapes__classes.html:5572,safe,safe,5572,doc/master/group__Shapes__classes.html,https://root.cern,https://root.cern/doc/master/group__Shapes__classes.html,1,['safe'],['safe']
Safety," return(0);; 371}; 372 ; 373 ; 374int rsa_num_sget(rsa_NUMBER *n, char *s); 375{; 376#if rsa_MAXINT == ( (1 << rsa_MAXBIT) - 1 ); 377 rsa_INT *p;; 378 const char *hp;; 379 int bi,ab,i;; 380 long b;; 381 int first = 1;; 382 ; 383 bi = 4 * strlen(s);; 384 ab = rsa_MAXBIT - (bi + rsa_MAXBIT -1) % rsa_MAXBIT -1;; 385 i = (bi + rsa_MAXBIT-1) / rsa_MAXBIT;; 386 p = &n->n_part[ i -1 ];; 387 n->n_len = i;; 388 ; 389 if ( i > rsa_MAXLEN ); 390 return(EOF);; 391 ; 392 b = 0;; 393 while (bi > 0) {; 394 if ( (hp = strchr( gHEX, *s )) ); 395 i = hp - gHEX;; 396 else if ((hp = strchr( ghex, *s )) ); 397 i = hp - ghex;; 398 else; 399 return(EOF);; 400 s++;; 401 ; 402 b <<= 4;; 403 b |= (unsigned long)i;; 404 bi -= 4;; 405 ab += 4;; 406 while (ab >= rsa_MAXBIT) {; 407 i = (b >> (ab - rsa_MAXBIT));; 408 b &= ( 1L << (ab - rsa_MAXBIT)) -1L;; 409 ab -= rsa_MAXBIT;; 410 if (first && !i) {; 411 p--;; 412 n->n_len--;; 413 }; 414 else {; 415 first = 0;; 416 *p-- = i;; 417 }; 418 }; 419 }; 420 if (b); 421 abort();; 422 *s = '\0';; 423 ; 424 return (0);; 425#else; 426 char *p;; 427 int i,c;; 428 ; 429 if (! ginit); 430 num_init();; 431 ; 432 n->n_len = 0;; 433 while ( (c = *s++ & 0xFF)) {; 434 if ( p= strchr( gHEX, c) ); 435 i = p - gHEX;; 436 else if ( p= strchr( ghex, c) ); 437 i = p - ghex;; 438 else; 439 return(EOF);; 440 ; 441 a_mult( n, &gbits[4], n );; 442 if (i); 443 a_add( n, &gint16[i-1], n );; 444 }; 445 ; 446 return(0);; 447#endif; 448}; 449 ; 450int rsa_num_fget(rsa_NUMBER *n, FILE *f); 451{; 452 int j,c;; 453 char *np;; 454 char n_print[ rsa_STRLEN + 1 ];; 455 ; 456 np = n_print;; 457 j = sizeof(n_print);; 458 while ( (c=getc(f)) != EOF && ( isxdigit(c) || isspace(c)) ) {; 459 if (isspace(c)); 460 continue;; 461 if (! --j); 462 return(EOF);; 463 *np++ = (char)c;; 464 }; 465 *np = '\0';; 466 ; 467 if (c != EOF); 468 ungetc(c,f);; 469 ; 470 if ( rsa_num_sget( n, n_print) == EOF ); 471 return( EOF );; 472 ; 473 return(0);; 474}; 475 ; 476int rsa_cmp(rsa_NUMBER *c1, rsa_NUMBER *c2",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rsalib_8cxx_source.html:9542,abort,abort,9542,doc/master/rsalib_8cxx_source.html,https://root.cern,https://root.cern/doc/master/rsalib_8cxx_source.html,1,['abort'],['abort']
Safety," rhi; param[2] = dz. ~TGeoParaboloid(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box of the tube. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; test if point is inside the elliptical tube. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each vertex. Double_t DistToParaboloid(const Double_t* point, const Double_t* dir, Bool_t in) const; Compute distance from a point to the parabola given by:; z = a*rsq + b; rsq = x*x+y*y. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the paraboloid. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the paraboloid and safe distance. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Divide the paraboloid along one axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; in case shape has some negative parameters, these has to be computed; in order to fit the mother. void InspectShape() const; print shape parameters. TBuffer3D * MakeBuffer3D() const; Creates a TBuffer3D describing *this* shape.; Coordinates are in local reference frame. void SetSegsAndPols(TBuffer3D& buff) const; Fill TBuffer3D structure for segments and polygons. Double_t Safety(const Double_t* point, Bool_t in = kTRUE) const; Computes the closest distance from given point to this",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoParaboloid.html:14427,safe,safe,14427,root/html534/TGeoParaboloid.html,https://root.cern,https://root.cern/root/html534/TGeoParaboloid.html,6,['safe'],['safe']
Safety," selected entries.Definition TSelector.cxx:330; TSelector::EAbortEAbortDefinition TSelector.h:34; TSelector::kAbortFile@ kAbortFileDefinition TSelector.h:34; TSelector::kAbortProcess@ kAbortProcessDefinition TSelector.h:34; TSelector::kContinue@ kContinueDefinition TSelector.h:34; TSelector::ProcessCutvirtual bool ProcessCut(Long64_t)This method is called before processing entry.Definition TSelector.cxx:313; TSelector::Processvirtual bool Process(Long64_t)The Process() function is called for each entry in the tree (or possibly keyed object in the case of ...Definition TSelector.cxx:360; TSelector::ImportOutputvirtual void ImportOutput(TList *output)Imports the content of 'output' in the internal output list.Definition TSelector.cxx:270; TSelector::fOutputTSelectorList * fOutput! List of objects created during processingDefinition TSelector.h:42; TSelector::fStatusLong64_t fStatusSelector status.Definition TSelector.h:37; TSelector::Classstatic TClass * Class(); TSelector::Abortvirtual void Abort(const char *why, EAbort what=kAbortProcess)Abort processing.Definition TSelector.cxx:116; TSelector::fObjectTObject * fObject! Current object if processing object (vs. TTree)Definition TSelector.h:40; TSelector::~TSelector~TSelector() overrideSelector destructor.Definition TSelector.cxx:102; TSelector::fAbortEAbort fAbortAbort status.Definition TSelector.h:38; TSelector::TSelectorTSelector()Default selector ctor.Definition TSelector.cxx:89; TSelector::GetSelectorstatic TSelector * GetSelector(const char *filename)The code in filename is loaded (interpreted or compiled, see below), filename must contain a valid cl...Definition TSelector.cxx:142; TStringBasic string class.Definition TString.h:139; TString::Dataconst char * Data() constDefinition TString.h:376; TString::LastSsiz_t Last(char c) constFind last occurrence of a character c.Definition TString.cxx:931; TString::RemoveTString & Remove(Ssiz_t pos)Definition TString.h:685; TSystem::SplitAclicModevirtual TString SplitAcl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSelector_8cxx_source.html:20530,Abort,Abortvirtual,20530,doc/master/TSelector_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSelector_8cxx_source.html,3,['Abort'],"['Abort', 'Abortvirtual']"
Safety," send (internal use only) If necessary, provide credits to the client. ; Parameters. only_onceif true, data sending performed once or until there is no data to send . Definition at line 1216 of file RWebWindow.cxx. ◆ CheckDataToSend() [2/2]. bool RWebWindow::CheckDataToSend ; (; std::shared_ptr< WebConn > & ; conn). private . Checks if one should send data for specified connection Returns true when send operation was performed. ; Definition at line 1158 of file RWebWindow.cxx. ◆ CheckInactiveConnections(). void RWebWindow::CheckInactiveConnections ; (; ). private . Check if there are connection which are inactive for longer time For instance, batch browser will be stopped if no activity for 30 sec is there. ; Definition at line 658 of file RWebWindow.cxx. ◆ CheckPendingConnections(). void RWebWindow::CheckPendingConnections ; (; ). private . Check if started process(es) establish connection. ; After timeout such processed will be killed Method invoked from http server thread, therefore appropriate mutex must be used on all relevant data ; Definition at line 624 of file RWebWindow.cxx. ◆ CloseConnection(). void RWebWindow::CloseConnection ; (; unsigned ; connid). Close specified connection. ; Parameters. connidconnection id, when 0 - all connections will be closed . Definition at line 1447 of file RWebWindow.cxx. ◆ CloseConnections(). void RWebWindow::CloseConnections ; (; ). Closes all connection to clients Normally leads to closing of all correspondent browser windows Some browsers (like firefox) do not allow by default to close window. ; Definition at line 1438 of file RWebWindow.cxx. ◆ CompleteWSSend(). void RWebWindow::CompleteWSSend ; (; unsigned ; wsid). private . Complete websocket send operation Clear ""doing send"" flag and check if next operation has to be started. ; Definition at line 1088 of file RWebWindow.cxx. ◆ Create(). std::shared_ptr< RWebWindow > RWebWindow::Create ; (; ). static . Create new RWebWindow Using default RWebWindowsManager. ; Definition ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RWebWindow.html:26594,timeout,timeout,26594,doc/v632/classROOT_1_1RWebWindow.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RWebWindow.html,1,['timeout'],['timeout']
Safety," send (internal use only) If necessary, provide credits to the client. ; Parameters. only_onceif true, data sending performed once or until there is no data to send . Definition at line 1249 of file RWebWindow.cxx. ◆ CheckDataToSend() [2/2]. bool RWebWindow::CheckDataToSend ; (; std::shared_ptr< WebConn > & ; conn). private . Checks if one should send data for specified connection Returns true when send operation was performed. ; Definition at line 1191 of file RWebWindow.cxx. ◆ CheckInactiveConnections(). void RWebWindow::CheckInactiveConnections ; (; ). private . Check if there are connection which are inactive for longer time For instance, batch browser will be stopped if no activity for 30 sec is there. ; Definition at line 659 of file RWebWindow.cxx. ◆ CheckPendingConnections(). void RWebWindow::CheckPendingConnections ; (; ). private . Check if started process(es) establish connection. ; After timeout such processed will be killed Method invoked from http server thread, therefore appropriate mutex must be used on all relevant data ; Definition at line 625 of file RWebWindow.cxx. ◆ CloseConnection(). void RWebWindow::CloseConnection ; (; unsigned ; connid). Close specified connection. ; Parameters. connidconnection id, when 0 - all connections will be closed . Definition at line 1489 of file RWebWindow.cxx. ◆ CloseConnections(). void RWebWindow::CloseConnections ; (; ). Closes all connection to clients Normally leads to closing of all correspondent browser windows Some browsers (like firefox) do not allow by default to close window. ; Definition at line 1480 of file RWebWindow.cxx. ◆ CompleteWSSend(). void RWebWindow::CompleteWSSend ; (; unsigned ; wsid). private . Complete websocket send operation Clear ""doing send"" flag and check if next operation has to be started. ; Definition at line 1121 of file RWebWindow.cxx. ◆ Create(). std::shared_ptr< RWebWindow > RWebWindow::Create ; (; ). static . Create new RWebWindow Using default RWebWindowsManager. ; Definition ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RWebWindow.html:26197,timeout,timeout,26197,doc/master/classROOT_1_1RWebWindow.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RWebWindow.html,1,['timeout'],['timeout']
Safety," sequentially in the specified order until a successful open. If the file starts with ""root:"", ""roots:"" or ""rootk:"" a TNetFile object will be returned, with ""http:"" a TWebFile, with ""file:"" a local TFile, etc. (see the list of TFile plugin handlers in $ROOTSYS/etc/system.rootrc for regular expressions that will be checked) and as last a local file will be tried. Before opening a file via TNetFile a check is made to see if the URL specifies a local file. If that is the case the file will be opened via a normal TFile. To force the opening of a local file via a TNetFile use either TNetFile directly or specify as host ""localhost"". The netopt argument is only used by TNetFile. For the meaning of the options and other arguments see the constructors of the individual file classes. In case of error, it returns a nullptr.; For TFile implementations supporting asynchronous file open, see TFile::AsyncOpen(...), it is possible to request a timeout with the option TIMEOUT=<secs>: the timeout must be specified in seconds and it will be internally checked with granularity of one millisec. For remote files there is the option: CACHEREAD opens an existing file for reading through the file cache. The file will be downloaded to the cache and opened from there. If the download fails, it will be opened remotely. The file will be downloaded to the directory specified by SetCacheFileDir().; The caller is responsible for deleting the pointer. In READ mode, a nullptr is returned if the file does not exist or cannot be opened. In CREATE mode, a nullptr is returned if the file already exists or cannot be created. In RECREATE mode, a nullptr is returned if the file can not be created. In UPDATE mode, a nullptr is returned if the file cannot be created or opened. ; Definition at line 4089 of file TFile.cxx. ◆ Open() [2/2]. TFile * TFile::Open ; (; TFileOpenHandle * ; fh). static . Waits for the completion of an asynchronous open request. ; Returns the pointer to the associated TFile, transferrin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTFile.html:83557,timeout,timeout,83557,doc/v632/classTFile.html,https://root.cern,https://root.cern/doc/v632/classTFile.html,6,"['TIMEOUT', 'timeout']","['TIMEOUT', 'timeout']"
Safety," single data record. TProcessID * ReadProcessID(UShort_t pidf); The TProcessID with number pidf is read from this file.; If the object is not already entered in the gROOT list, it is added. Int_t Recover(); Attempt to recover file if not correctly closed.; The function returns the number of keys that have been recovered.; If no keys can be recovered, the file will be declared Zombie by; the calling function. This function is automatically called when; opening a file. If the file is open in read only mode, the file is not modified.; If open in update mode and the function finds something to recover,; a new directory header is written to the file. When opening the file gain; no message from Recover will be reported.; If keys have been recovered, the file is usable and you can safely; read the corresponding objects.; If the file is not usable (a zombie), you can test for this case; with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {file is unusable); If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; You can test if the file has been recovered with; if (f.TestBit(TFile::kRecovered)) {.. the file has been recovered}. When writing TTrees to a file, it is important to save the Tree header; at regular intervals (see TTree::AutoSave). If a file containing a Tree; is recovered, the last Tree header written to the file will be used.; In this case all the entries in all the branches written before writing; the header are valid entries. One can disable the automatic recovery procedure by setting; TFile.Recover 0; in the system.rootrc file. Int_t ReOpen(Option_t* mode); Reopen a file with a different access mode, like from READ to; UPDATE or from NEW, CREATE, RECREATE, UPDATE to READ. Thus the; mode argument can be either ""READ"" or ""UPDATE"". The method returns; 0 in case the mode was successfully modified, 1 in case the mode; did not change (was already as requested or wrong input arguments); and -1 in case of failure, in which ca",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFile.html:35289,recover,recovered,35289,root/html528/TFile.html,https://root.cern,https://root.cern/root/html528/TFile.html,6,['recover'],['recovered']
Safety," socket created via socketpair(). TSocket(const TSocket& s); TSocket copy ctor. void Close(Option_t* opt = """"); Close the socket. If option is ""force"", calls shutdown(id,2) to; shut down the connection. This will close the connection also; for the parent of this process. Also called via the dtor (without; option ""force"", call explicitly Close(""force"") if this is desired). TInetAddress GetLocalInetAddress(); Return internet address of local host to which the socket is bound.; In case of error TInetAddress::IsValid() returns kFALSE. Int_t GetLocalPort(); Return the local port # to which the socket is bound.; In case of error return -1. Int_t Select(Int_t interest = kRead, Long_t timeout = -1); Waits for this socket to change status. If interest=kRead,; the socket will be watched to see if characters become available for; reading; if interest=kWrite the socket will be watched to; see if a write will not block.; The argument 'timeout' specifies a maximum time to wait in millisec.; Default no timeout.; Returns 1 if a change of status of interest has been detected within; timeout; 0 in case of timeout; < 0 if an error occured. Int_t Send(Int_t kind); Send a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(Int_t status, Int_t kind); Send a status and a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always 2*sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(const char* mess, Int_t kind = kMESS_STRING); Send a character string buffer. Use kind to set the TMessage """,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TSocket.html:13882,timeout,timeout,13882,root/html534/TSocket.html,https://root.cern,https://root.cern/root/html534/TSocket.html,3,['timeout'],['timeout']
Safety," some information about the network in the terminal. void GatherInformations(); Collect informations about what is usefull in the network.; This method has to be called first when analyzing a network.; Fills the two analysis trees. void DrawDInput(Int_t i); Draws the distribution (on the test sample) of the; impact on the network output of a small variation of; the ith input. void DrawDInputs(); Draws the distribution (on the test sample) of the; impact on the network output of a small variation of; each input.; DrawDInputs() draws something that approximates the distribution of the; derivative of the NN w.r.t. each input. That quantity is recognized as; one of the measures to determine key quantities in the network. What is done is to vary one input around its nominal value and to see; how the NN changes. This is done for each entry in the sample and produces; a distribution. What you can learn from that is:; - is variable a really useful, or is my network insensitive to it ?; - is there any risk of big systematic ? Is the network extremely sensitive; to small variations of any of my inputs ?. As you might understand, this is to be considered with care and can serve; as input for an ""educated guess"" when optimizing the network. void DrawNetwork(Int_t neuron, const char* signal, const char* bg); Draws the distribution of the neural network (using ith neuron).; Two distributions are drawn, for events passing respectively the ""signal""; and ""background"" cuts. Only the test sample is used. TProfile* DrawTruthDeviation(Int_t outnode = 0, Option_t* option = """"); Create a profile of the difference of the MLP output minus the; true value for a given output node outnode, vs the true value for; outnode, for all test data events. This method is mainly useful; when doing regression analysis with the MLP (i.e. not classification,; but continuous truth values).; The resulting TProfile histogram is returned.; It is not drawn if option ""goff"" is specified.; Options are passed to TP",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMLPAnalyzer.html:7559,risk,risk,7559,root/html528/TMLPAnalyzer.html,https://root.cern,https://root.cern/root/html528/TMLPAnalyzer.html,3,['risk'],['risk']
Safety," start (cm). See also comments*; float phi0; /* azimuthal angle at start (deg) *; float z0; /* z-coord. at start (cm) *; float psi; /* azimuthal angle of pT vector (deg) *; float tanl; /* tan(dip) =pz/pt at start *; float invpt; /* 1/pt at start (GeV/c)^(-1) *; float curvature; /* Track curvature (1/cm) *; float covar[15]; /* full covariance matrix *; float chisq[2]; /* Chi-square per degree of freedom *; float x_first[3]; /* coord. of first measured point (cm) *; float x_last[3]; /* coord. of last measured point (cm) *; float length; /* from first to last point (cm) *; float impact; /* primary vertex (cm) *; unsigned long map[2]; /* extrap. info. (see preceeding comments)*; int id; /* Primary key (see comments) *; int iflag; /* bitmask quality info. (see comments) *; int det_id; /* Detector id information *; int method; /* Track finding/fitting method, packed *; int pid; /* Geant particle ID for assumed mass *; int n_point; /* SVT, TPC, FTPC component #s are packed *; int n_max_point; /* SVT, TPC, FTPC component #s are packed *; int n_fit_point; /* SVT, TPC, FTPC component #s are packed *; int icharge; /* Particle charge in units of |e| *; int id_start_vertex; /* final fit and primary track candidates *; } DST_TRACK_ST;. class St_dst_track : public TTable; {; public:; ClassDefTable(St_dst_track,dst_track_st); ClassDef(St_dst_track,2) //C++ wrapper for <dst_track> StAF table; };; #endif. where the CPP macro defines several convinient methods for the; ""table"" class (see: $ROOTSYS/table/inc/Ttypes.h for details:. #define ClassDefTable(className,structName); protected:; static TTableDescriptor *fgColDescriptors;; virtual TTableDescriptor *GetDescriptorPointer() const { return fgColDescriptors;}; virtual void SetDescriptorPointer(TTableDescriptor *list) const { fgColDescriptors = list;}; public:; typedef structName* iterator;; className() : TTable(_QUOTE_(className),sizeof(structName)) {SetType(_QUOTE_(structName));}; className(const char *name) : TTable(name,sizeof(stru",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTable.html:1955,Detect,Detector,1955,root/html528/TTable.html,https://root.cern,https://root.cern/root/html528/TTable.html,3,['Detect'],['Detector']
Safety," start web browser for such windows, one can provide real URL of the web server which will connect with that FastCGI instance: WebGui.FastCgiServer: https://your_apache_server.com/root_cgi_path. Definition at line 351 of file RWebWindowsManager.cxx. ◆ CreateWindow(). std::shared_ptr< RWebWindow > RWebWindowsManager::CreateWindow ; (; ). Creates new window To show window, RWebWindow::Show() have to be called. ; Definition at line 536 of file RWebWindowsManager.cxx. ◆ GenerateKey(). std::string RWebWindowsManager::GenerateKey ; (; int ; keylen = 32). staticprivate . Static method to generate cryptographic key Parameter keylen defines length of cryptographic key in bytes Output string will be hex formatted and includes ""-"" separator after every 4 bytes Example for 16 bytes: ""fca45856-41bee066-ff74cc96-9154d405"". ; Definition at line 178 of file RWebWindowsManager.cxx. ◆ GetLaunchTmout(). float ROOT::RWebWindowsManager::GetLaunchTmout ; (; ); const. inlineprivate . Returns timeout for launching new browser process. ; Definition at line 61 of file RWebWindowsManager.hxx. ◆ GetServer(). THttpServer * ROOT::RWebWindowsManager::GetServer ; (; ); const. inline . Returns THttpServer instance. ; Definition at line 84 of file RWebWindowsManager.hxx. ◆ GetServerAddr(). std::string ROOT::RWebWindowsManager::GetServerAddr ; (; ); const. inline . Returns http address of the server, empty string when not available. ; Definition at line 87 of file RWebWindowsManager.hxx. ◆ GetUrl(). std::string RWebWindowsManager::GetUrl ; (; RWebWindow & ; win, . bool ; remote = false, . std::string * ; produced_key = nullptr . ). private . Provide URL address to access specified window from inside or from remote. ; Definition at line 600 of file RWebWindowsManager.cxx. ◆ InformListener(). bool RWebWindowsManager::InformListener ; (; const std::string & ; msg). private . If ROOT_LISTENER_SOCKET variable is configured, message will be sent to that unix socket. ; Definition at line 227 of file RWebWind",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RWebWindowsManager.html:11088,timeout,timeout,11088,doc/v632/classROOT_1_1RWebWindowsManager.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RWebWindowsManager.html,1,['timeout'],['timeout']
Safety," start) > timeout_ns) {; 6122 /* Timeout */; 6123 break;; 6124 }; 6125 }; 6126 }; 6127 ; 6128 (void)err; /* Avoid unused warning if NO_SSL is set and DEBUG_TRACE is not; 6129 used */; 6130 ; 6131 return -1;; 6132}; 6133 ; 6134 ; 6135static int; 6136push_all(struct mg_context *ctx,; 6137 FILE *fp,; 6138 SOCKET sock,; 6139 SSL *ssl,; 6140 const char *buf,; 6141 int len); 6142{; 6143 double timeout = -1.0;; 6144 int n, nwritten = 0;; 6145 ; 6146 if (ctx == NULL) {; 6147 return -1;; 6148 }; 6149 ; 6150 if (ctx->dd.config[REQUEST_TIMEOUT]) {; 6151 timeout = atoi(ctx->dd.config[REQUEST_TIMEOUT]) / 1000.0;; 6152 }; 6153 if (timeout <= 0.0) {; 6154 timeout = strtod(config_options[REQUEST_TIMEOUT].default_value, NULL); 6155 / 1000.0;; 6156 }; 6157 ; 6158 while ((len > 0) && STOP_FLAG_IS_ZERO(&ctx->stop_flag)) {; 6159 n = push_inner(ctx, fp, sock, ssl, buf + nwritten, len, timeout);; 6160 if (n < 0) {; 6161 if (nwritten == 0) {; 6162 nwritten = -1; /* Propagate the error */; 6163 }; 6164 break;; 6165 } else if (n == 0) {; 6166 break; /* No more data to write */; 6167 } else {; 6168 nwritten += n;; 6169 len -= n;; 6170 }; 6171 }; 6172 ; 6173 return nwritten;; 6174}; 6175 ; 6176 ; 6177/* Read from IO channel - opened file descriptor, socket, or SSL descriptor.; 6178 * Return value:; 6179 * >=0 .. number of bytes successfully read; 6180 * -1 .. timeout; 6181 * -2 .. error; 6182 */; 6183static int; 6184pull_inner(FILE *fp,; 6185 struct mg_connection *conn,; 6186 char *buf,; 6187 int len,; 6188 double timeout); 6189{; 6190 int nread, err = 0;; 6191 ; 6192#if defined(_WIN32); 6193 typedef int len_t;; 6194#else; 6195 typedef size_t len_t;; 6196#endif; 6197 ; 6198 /* We need an additional wait loop around this, because in some cases; 6199 * with TLSwe may get data from the socket but not from SSL_read.; 6200 * In this case we need to repeat at least once.; 6201 */; 6202 ; 6203 if (fp != NULL) {; 6204 /* Use read() instead of fread(), because if we're reading from the; 6205 * CGI pipe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:179773,timeout,timeout,179773,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety," start) > timeout_ns) {; 6123 /* Timeout */; 6124 break;; 6125 }; 6126 }; 6127 }; 6128 ; 6129 (void)err; /* Avoid unused warning if NO_SSL is set and DEBUG_TRACE is not; 6130 used */; 6131 ; 6132 return -1;; 6133}; 6134 ; 6135 ; 6136static int; 6137push_all(struct mg_context *ctx,; 6138 FILE *fp,; 6139 SOCKET sock,; 6140 SSL *ssl,; 6141 const char *buf,; 6142 int len); 6143{; 6144 double timeout = -1.0;; 6145 int n, nwritten = 0;; 6146 ; 6147 if (ctx == NULL) {; 6148 return -1;; 6149 }; 6150 ; 6151 if (ctx->dd.config[REQUEST_TIMEOUT]) {; 6152 timeout = atoi(ctx->dd.config[REQUEST_TIMEOUT]) / 1000.0;; 6153 }; 6154 if (timeout <= 0.0) {; 6155 timeout = strtod(config_options[REQUEST_TIMEOUT].default_value, NULL); 6156 / 1000.0;; 6157 }; 6158 ; 6159 while ((len > 0) && STOP_FLAG_IS_ZERO(&ctx->stop_flag)) {; 6160 n = push_inner(ctx, fp, sock, ssl, buf + nwritten, len, timeout);; 6161 if (n < 0) {; 6162 if (nwritten == 0) {; 6163 nwritten = -1; /* Propagate the error */; 6164 }; 6165 break;; 6166 } else if (n == 0) {; 6167 break; /* No more data to write */; 6168 } else {; 6169 nwritten += n;; 6170 len -= n;; 6171 }; 6172 }; 6173 ; 6174 return nwritten;; 6175}; 6176 ; 6177 ; 6178/* Read from IO channel - opened file descriptor, socket, or SSL descriptor.; 6179 * Return value:; 6180 * >=0 .. number of bytes successfully read; 6181 * -1 .. timeout; 6182 * -2 .. error; 6183 */; 6184static int; 6185pull_inner(FILE *fp,; 6186 struct mg_connection *conn,; 6187 char *buf,; 6188 int len,; 6189 double timeout); 6190{; 6191 int nread, err = 0;; 6192 ; 6193#if defined(_WIN32); 6194 typedef int len_t;; 6195#else; 6196 typedef size_t len_t;; 6197#endif; 6198 ; 6199 /* We need an additional wait loop around this, because in some cases; 6200 * with TLSwe may get data from the socket but not from SSL_read.; 6201 * In this case we need to repeat at least once.; 6202 */; 6203 ; 6204 if (fp != NULL) {; 6205 /* Use read() instead of fread(), because if we're reading from the; 6206 * CGI pipe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:179805,timeout,timeout,179805,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety," static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. private:. TGCheckButton*fCursorCheckBoxCheck box ""Show mouse cursor"" for replaying; time_tfElapsedplaying/recording time; Window_tfFilteredIds[12]IDs of these windows in GUI recorder; TRecorder*fRecorderRecorder; TGPictureButton*fReplayButton for start of replaying; time_tfStart; TGPictureButton*fStartStopButton for start and stop of recording; TGLabel*fStatusLabel with actual status; TGLabel*fTimeDisplayLabel with time counter; TTimer*fTimerTimer for handling GUI of recorder; static const Int_tfgWidgetsCountNumber of windows in GUI recorder. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGRecorder(const TGWindow* p = 0, UInt_t w = 230, UInt_t h = 150); The GUI for the recorder. void SetDefault(); Sets GUI to the default inactive state. void Update(); Called when fTimer timeouts (every 0.025 second); Updates GUI of recorder. void StartStop(); Handles push of the fStartStop button; according to the current recorder state. void Replay(); Handles push of fReplay button; according to the current recorder state. ~TGRecorder(); Destructor. Cleanup the GUI. » Author: Katerina Opocenska 11/09/2008 » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-06-05 16:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGRecorder.html:22197,timeout,timeouts,22197,root/html534/TGRecorder.html,https://root.cern,https://root.cern/root/html534/TGRecorder.html,1,['timeout'],['timeouts']
Safety," static voidTGeoShape::NormalPhi(Double_t* point, Double_t* dir, Double_t* norm, Double_t c1, Double_t s1, Double_t c2, Double_t s2); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tTGeoBBox::Safety(Double_t* point, Bool_t in = kTRUE) const; static Double_tTGeoShape::SafetyPhi(Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTGeoBBox::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidTGeoBBox::SetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetFromFaceSet(TGLFaceSet* fs); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTGeoBBox::SetPoints(Double_t* points) const; virtual voidTGeoBB",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TEveGeoPolyShape.html:7940,Safe,Safety,7940,root/html530/TEveGeoPolyShape.html,https://root.cern,https://root.cern/root/html530/TEveGeoPolyShape.html,2,['Safe'],['Safety']
Safety," static voidTSlave::SetTXSlaveHook(TSlave_t xslavehook); virtual voidTObject::SetUniqueID(UInt_t uid); virtual Int_tSetupServ(Int_t stype, const char* conffile); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTouch(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidFlushSocket(); virtual voidInterrupt(Int_t type); voidTObject::MakeZombie(); virtual Int_tPing(); virtual TObjString*SendCoordinator(Int_t kind, const char* msg = 0, Int_t int2 = 0); virtual Int_tSendGroupPriority(const char* grp, Int_t priority); virtual voidSetAlias(const char* alias); voidTSlave::SetSocket(TSocket* s); virtual voidTSlave::SetStatus(Int_t st); virtual voidStopProcess(Bool_t abort, Int_t timeout). private:. static Int_tGetProofdProtocol(TSocket* s); voidInit(const char* host, Int_t stype); voidParseBuffer(). Data Members; public:. enum TSlave::ESlaveType { kMaster; kSlave; };; enum TSlave::ESlaveStatus { kInvalid; kActive; kInactive; };; enum TSlave::EStatusBits { kOutputRequested; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTSlave::fArchCompBuild architecture, compiler on worker (e.g. linux-gcc345); Long64_tTSlave::fBytesReadbytes read by slave (info is obtained from slave); Float_tTSlave::fCpuTimeCPU time spent executing commands (info o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TXSlave.html:6726,abort,abort,6726,root/html534/TXSlave.html,https://root.cern,https://root.cern/root/html534/TXSlave.html,2,"['abort', 'timeout']","['abort', 'timeout']"
Safety," std::runtime_error(std::string("">>> Interpreter compilation error:\n"") + reason);; 862 }; 863}; 864 ; 865//______________________________________________________________________________; 866//; 867//; 868//; 869 ; 870////////////////////////////////////////////////////////////////////////////////; 871 ; 872namespace{; 873 // An instance of this class causes the diagnostics of clang to be suppressed; 874 // during its lifetime; 875 class clangDiagSuppr {; 876 public:; 877 clangDiagSuppr(clang::DiagnosticsEngine& diag): fDiagEngine(diag){; 878 fOldDiagValue = fDiagEngine.getIgnoreAllWarnings();; 879 fDiagEngine.setIgnoreAllWarnings(true);; 880 }; 881 ; 882 ~clangDiagSuppr() {; 883 fDiagEngine.setIgnoreAllWarnings(fOldDiagValue);; 884 }; 885 private:; 886 clang::DiagnosticsEngine& fDiagEngine;; 887 bool fOldDiagValue;; 888 };; 889 ; 890}; 891 ; 892////////////////////////////////////////////////////////////////////////////////; 893/// Allow calling autoparsing from TMetaUtils; 894bool TClingLookupHelper__AutoParse(const char *cname); 895{; 896 return gCling->AutoParse(cname);; 897}; 898 ; 899////////////////////////////////////////////////////////////////////////////////; 900/// Try hard to avoid looking up in the Cling database as this could enduce; 901/// an unwanted autoparsing.; 902 ; 903bool TClingLookupHelper__ExistingTypeCheck(const std::string &tname,; 904 std::string &result); 905{; 906 result.clear();; 907 ; 908 unsigned long offset = 0;; 909 if (strncmp(tname.c_str(), ""const "", 6) == 0) {; 910 offset = 6;; 911 }; 912 unsigned long end = tname.length();; 913 while( end && (tname[end-1]=='&' || tname[end-1]=='*' || tname[end-1]==']') ) {; 914 if ( tname[end-1]==']' ) {; 915 --end;; 916 while ( end && tname[end-1]!='[' ) --end;; 917 }; 918 --end;; 919 }; 920 std::string innerbuf;; 921 const char *inner;; 922 if (end != tname.length()) {; 923 innerbuf = tname.substr(offset,end-offset);; 924 inner = innerbuf.c_str();; 925 } else {; 926 inner = tname.c_str()+offse",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:31876,avoid,avoid,31876,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['avoid'],['avoid']
Safety," sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTFile::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTFile::Print(Option_t* option = """") const; virtual voidTDirectoryFile::Purge(Short_t nkeep = 1); virtual voidTDirectory::pwd() const; virtual Int_tTObject::Read(const char* name); virtual voidTDirectoryFile::ReadAll(Option_t* option = """"); virtual Bool_tTWebFile::ReadBuffer(char* buf, Int_t len); virtual Bool_tTWebFile::ReadBuffer(char* buf, Long64_t pos, Int_t len); virtual Bool_tTFile::ReadBufferAsync(Long64_t offs, Int_t len); virtual Bool_tReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); virtual voidTFile::ReadFree(); virtual Int_tTDirectoryFile::ReadKeys(Bool_t forceRead = kTRUE); virtual TProcessID*TFile::ReadProcessID(UShort_t pidf); virtual voidTFile::ReadStreamerInfo(); virtual Int_tTDirectoryFile::ReadTObject(TObject* obj, const char* keyname); virtual Int_tTFile::Recover(); virtual voidTDirectory::RecursiveRemove(TObject* obj); virtual TObject*TDirectory::Remove(TObject*); virtual Int_tTWebFile::ReOpen(Option_t* mode); virtual voidTDirectoryFile::ResetAfterMerge(TFileMergeInfo*); voidTObject::ResetBit(UInt_t f); virtual voidTFile::ResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidTWebFile::Seek(Long64_t offset, TFile::ERelativeTo pos = kBeg); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tTFile::SetCacheFileDir(const char* cacheDir, Bool_t operat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TS3WebFile.html:12821,Recover,Recover,12821,root/html534/TS3WebFile.html,https://root.cern,https://root.cern/root/html534/TS3WebFile.html,1,['Recover'],['Recover']
Safety," t, Int_t bufSize = 32000); Attach the category index and label to as branches to the given; TTree. The index field will be attached as integer with name; <name>_idx, the label field will be attached as char[] with label; <name>_lbl. void fillTreeBranch(TTree& t); Fill tree branches associated with current object with current value. void setTreeBranchStatus(TTree& t, Bool_t active); (De)activate associate tree branch. void syncCache(const RooArgSet* set = 0); Explicitly synchronize RooAbsCategory internal cache. void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE); Copy the cached value from given source and raise dirty flag.; It is the callers responsability to ensure that the sources; cache is clean(valid) before this function is called, e.g. by; calling syncCache() on the source. const RooCatType* getOrdinal(UInt_t n, const char* rangeName = 0) const; Return state definition of ordinal nth defined state,; needed by the generator mechanism. RooAbsArg * createFundamental(const char* newname = 0) const; Create a RooCategory fundamental object with our properties. Bool_t isSignType(Bool_t mustHaveZero = kFALSE) const; Determine if category has 2 or 3 states with index values -1,0,1. Bool_t operator!=(Int_t index); { return !operator==(index);}. Bool_t operator!=(const char* label); { return !operator==(label);}. Bool_t operator!=(const RooAbsArg& other); { return !operator==(other);}. Int_t numTypes(const char* = 0) const; Return number of types defined (in range named rangeName if rangeName!=0). Bool_t isIntegrationSafeLValue(const RooArgSet* ) const; Is this l-value object safe for use as integration observable. Bool_t traceEvalHook(RooCatType ) const; Hook function for trace evaluation (dummy). RooCatType evaluate() const. » Last changed: Mon Dec 7 13:45:35 2009 » Last generated: 2009-12-07 13:45; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsCategory.html:24456,safe,safe,24456,root/html526/RooAbsCategory.html,https://root.cern,https://root.cern/root/html526/RooAbsCategory.html,1,['safe'],['safe']
Safety," table in which there are three color end points: RGB = {0, 0, 1}, {1, 0, 0}, and {1, 1, 1} = blue, red, white The first 40% of the table is used to go linearly from blue to red. The remaining 60% of the table is used to go linearly from red to white.; If you define a very short interval such that less than one color fits in it, no colors at all will be allocated. If this occurs for all intervals, ROOT will revert to the default palette.; Original code by Andreas Zoglauer (zog@m.nosp@m.pe.m.nosp@m.pg.de) ; Definition at line 2730 of file TColor.cxx. ◆ DeclFileName(). static const char * TColor::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 113 of file TColor.h. ◆ DefinedColors(). Bool_t TColor::DefinedColors ; (; Int_t ; set_always_on = 0). static . Static method returning kTRUE if some new colors have been defined after initialisation or since the last call to this method. ; This allows to avoid the colors and palette streaming in TCanvas::Streamer if not needed. If method called once with set_always_on = 1, all next canvases will be To reset such mode, just call methoid once with set_always_on = -1 ; Definition at line 1537 of file TColor.cxx. ◆ GetAlpha(). Float_t TColor::GetAlpha ; (; ); const. inline . Definition at line 66 of file TColor.h. ◆ GetBlue(). Float_t TColor::GetBlue ; (; ); const. inline . Definition at line 62 of file TColor.h. ◆ GetColor() [1/4]. Int_t TColor::GetColor ; (; const char * ; hexcolor). static . Static method returning color number for color specified by hex color string of form: ""#rrggbb"", where rr, gg and bb are in hex between [0,FF], e.g. ; ""#c0c0c0"".; The color retrieval is done using a threshold defined by SetColorThreshold.; If specified color does not exist it will be created with as name ""#rrggbb"" with rr, gg and bb in hex between [0,FF]. ; Definition at line 1920 of file TColor.cxx. ◆ GetColor() [2/4]. Int_t TColor::GetColor ; (; Float_t ; r, . Float_t ; g, .",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTColor.html:50487,avoid,avoid,50487,doc/master/classTColor.html,https://root.cern,https://root.cern/doc/master/classTColor.html,1,['avoid'],['avoid']
Safety," that stops this collection. Int_t Collect(TList* slaves, Long_t timeout = -1, Int_t endtype = -1, Bool_t deactonfail = kFALSE); Collect responses from the slave servers. Returns the number of slaves; that responded.; If timeout >= 0, wait at most timeout seconds (timeout = -1 by default,; which means wait forever).; If defined (>= 0) endtype is the message that stops this collection. Int_t Collect(ESlaves list, Long_t timeout, Int_t endtype, Bool_t deactonfail); Collect responses from the slave servers. Returns the number of slaves; that responded.; If timeout >= 0, wait at most timeout seconds (timeout = -1 by default,; which means wait forever).; If defined (>= 0) endtype is the message that stops this collection. Int_t Collect(TMonitor* mon, Long_t timeout = -1, Int_t endtype = -1, Bool_t deactonfail = kFALSE); Collect responses from the slave servers. Returns the number of messages; received. Can be 0 if there are no active slaves.; If timeout >= 0, wait at most timeout seconds (timeout = -1 by default,; which means wait forever).; If defined (>= 0) endtype is the message that stops this collection. void CleanGDirectory(TList* ol); Remove links to objects in list 'ol' from gDirectory. Int_t CollectInputFrom(TSocket* s, Int_t endtype = -1, Bool_t deactonfail = kFALSE); Collect and analyze available input from socket s.; Returns 0 on success, -1 if any failure occurs. Int_t HandleInputMessage(TSlave* wrk, TMessage* m, Bool_t deactonfail = kFALSE); Analyze the received message.; Returns 0 on success (1 if this the last message from this socket), -1 if; any failure occurs. void HandleSubmerger(TMessage* mess, TSlave* sl); Process a message of type kPROOF_SUBMERGER. void RedirectWorker(TSocket* s, TSlave* sl, Int_t output_size); Redirect output of worker sl to some merger. Int_t FindNextFreeMerger(); Return a merger, which is both active and still accepts some workers to be; assigned to it. It works on the 'round-robin' basis. void AskForOutput(TSlave* sl); Master as",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProof.html:42869,timeout,timeout,42869,root/html528/TProof.html,https://root.cern,https://root.cern/root/html528/TProof.html,9,['timeout'],['timeout']
Safety," that stops this collection. Int_t Collect(TList* slaves, Long_t timeout = -1, Int_t endtype = -1, Bool_t deactonfail = kFALSE); Collect responses from the slave servers. Returns the number of slaves; that responded.; If timeout >= 0, wait at most timeout seconds (timeout = -1 by default,; which means wait forever).; If defined (>= 0) endtype is the message that stops this collection. Int_t Collect(ESlaves list, Long_t timeout, Int_t endtype, Bool_t deactonfail); Collect responses from the slave servers. Returns the number of slaves; that responded.; If timeout >= 0, wait at most timeout seconds (timeout = -1 by default,; which means wait forever).; If defined (>= 0) endtype is the message that stops this collection. Int_t Collect(TMonitor* mon, Long_t timeout = -1, Int_t endtype = -1, Bool_t deactonfail = kFALSE); Collect responses from the slave servers. Returns the number of messages; received. Can be 0 if there are no active slaves.; If timeout >= 0, wait at most timeout seconds (timeout = -1 by default,; which means wait forever).; If defined (>= 0) endtype is the message that stops this collection.; Collect also stops its execution from time to time to check for new; workers in Dynamic Startup mode. Int_t PollForNewWorkers(); Asks the PROOF Serv for new workers in Dynamic Startup mode and activates; them. Returns the number of new workers found, or <0 on errors. void CleanGDirectory(TList* ol); Remove links to objects in list 'ol' from gDirectory. Int_t CollectInputFrom(TSocket* s, Int_t endtype = -1, Bool_t deactonfail = kFALSE); Collect and analyze available input from socket s.; Returns 0 on success, -1 if any failure occurs. Int_t HandleInputMessage(TSlave* wrk, TMessage* m, Bool_t deactonfail = kFALSE); Analyze the received message.; Returns 0 on success (1 if this the last message from this socket), -1 if; any failure occurs. void HandleSubmerger(TMessage* mess, TSlave* sl); Process a message of type kPROOF_SUBMERGER. void RedirectWorker(TSocket* s, TSlav",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProof.html:46725,timeout,timeout,46725,root/html534/TProof.html,https://root.cern,https://root.cern/root/html534/TProof.html,9,['timeout'],['timeout']
Safety," that this function is not called if the static member fgReadInfo is false. (see TFile::SetReadStreamerInfo) ; Definition at line 3605 of file TFile.cxx. ◆ Recover(). Int_t TFile::Recover ; (; ). virtual . Attempt to recover file if not correctly closed. ; The function returns the number of keys that have been recovered. If no keys can be recovered, the file will be declared Zombie by the calling function. This function is automatically called when opening a file. If the file is open in read only mode, the file is not modified. If open in update mode and the function finds something to recover, a new directory header is written to the file. When opening the file gain no message from Recover will be reported. If keys have been recovered, the file is usable and you can safely read the corresponding objects. If the file is not usable (a zombie), you can test for this case with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {<actions to take if file is unusable>}; If the file has been recovered, the bit kRecovered is set in the TFile object in memory. You can test if the file has been recovered with if (f.TestBit(TFile::kRecovered)) {... the file has been recovered}; When writing TTrees to a file, it is important to save the Tree header at regular intervals (see TTree::AutoSave). If a file containing a Tree is recovered, the last Tree header written to the file will be used. In this case all the entries in all the branches written before writing the header are valid entries. One can disable the automatic recovery procedure by setting TFile.Recover 0; in the system.rootrc file. ; Reimplemented in TSQLFile, and TXMLFile.; Definition at line 2048 of file TFile.cxx. ◆ ReOpen(). Int_t TFile::ReOpen ; (; Option_t * ; mode). virtual . Reopen a file with a different access mode. ; For example, it is possible to change from READ to UPDATE or from NEW, CREATE, RECREATE, UPDATE to READ. Thus the mode argument can be either ""READ"" or ""UPDATE"". The method returns 0 in case th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTFile.html:89559,recover,recovered,89559,doc/v632/classTFile.html,https://root.cern,https://root.cern/doc/v632/classTFile.html,2,['recover'],['recovered']
Safety," the BVH acceleration structure. ;  ; void CheckOverlaps (Double_t ovlp=0.001);  Check overlaps within a tolerance value. ;  ; Bool_t CloseGeometry ();  The main geometry must be closed. ;  ; void Draw (Option_t *option) override;  Draw the parallel world. ;  ; TGeoPhysicalNode * FindNextBoundary (Double_t point[3], Double_t dir[3], Double_t &step, Double_t stepmax=1.E30);  ; TGeoPhysicalNode * FindNode (Double_t point[3]);  ; AccelerationMode const & GetAccelerationMode () const;  ; TGeoManager * GetGeometry () const;  ; TGeoVolume * GetVolume () const;  ; TClass * IsA () const override;  ; Bool_t IsClosed () const;  ; Bool_t IsUsingOverlaps () const;  ; void PrintBVH () const;  Prints the BVH. ;  ; Int_t PrintDetectedOverlaps () const;  Print the overlaps which were detected during real tracking. ;  ; void RefreshPhysicalNodes ();  Refresh the node pointers and re-voxelize. ;  ; void ResetOverlaps () const;  Reset overlapflag for all volumes in geometry. ;  ; Double_t Safety (Double_t point[3], Double_t safmax=1.E30);  ; void SetAccelerationMode (AccelerationMode const &mode);  ; void SetUseOverlaps (Bool_t flag);  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoParallelWorld.html:3535,Safe,Safety,3535,doc/master/classTGeoParallelWorld.html,https://root.cern,https://root.cern/doc/master/classTGeoParallelWorld.html,1,['Safe'],['Safety']
Safety," the PDF would come out negative. The PDF is now undefined.; a1.setVal(10.0); a2.setVal(-1.0); ; # Perform a fit:; fitWithoutRecovery = pdf.fitTo(; data,; Save=True,; RecoverFromUndefinedRegions=0.0, # This is how RooFit behaved prior to ROOT 6.24; PrintEvalErrors=-1, # We are expecting a lot of evaluation errors. -1 switches off printing.; PrintLevel=-1,; ); ; pdf.plotOn(frame, LineColor=""r"", Name=""noRecovery""); ; ; # RooFit since ROOT 6.24; # --------------------------------; # The minimiser gets information about the ""badness"" of the violation of the function definition. It uses this; # to find its way out of the disallowed parameter regions.; print(""\n\n\n-------------- Starting second fit ---------------\n\n""); ; # Reset the parameters such that the PDF is again undefined.; a1.setVal(10.0); a2.setVal(-1.0); ; # Fit again, but pass recovery information to the minimiser:; fitWithRecovery = pdf.fitTo(; data,; Save=True,; RecoverFromUndefinedRegions=1.0, # The magnitude of the recovery information can be chosen here.; # Higher values mean more aggressive recovery.; PrintEvalErrors=-1, # We are still expecting a few evaluation errors.; PrintLevel=0,; ); ; pdf.plotOn(frame, LineColor=""b"", Name=""recovery""); ; ; # Collect results and plot.; # --------------------------------; # We print the two fit results, and plot the fitted curves.; # The curve of the fit without recovery cannot be plotted, because the PDF is undefined if a2 < 0.; fitWithoutRecovery.Print(); print(; ""Without recovery, the fitter encountered {}"".format(fitWithoutRecovery.numInvalidNLL()); + "" invalid function values. The parameters are unchanged.\n""; ); ; fitWithRecovery.Print(); print(; ""With recovery, the fitter encountered {}"".format(fitWithoutRecovery.numInvalidNLL()); + "" invalid function values, but the parameters are fitted.\n""; ); ; legend = ROOT.TLegend(0.5, 0.7, 0.9, 0.9); legend.SetBorderSize(0); legend.SetFillStyle(0); legend.AddEntry(""data"", ""Data"", ""P""); legend.AddEntry(""noRecovery"", ""W",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html:3218,recover,recovery,3218,doc/master/rf612__recoverFromInvalidParameters_8py.html,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html,1,['recover'],['recovery']
Safety," the TTree to be reloaded as soon as possible. ;  ; void ReleaseChainProof ();  ;  Protected Member Functions inherited from TTree; virtual TBranch * BranchImp (const char *branchname, const char *classname, TClass *ptrClass, void *addobj, Int_t bufsize, Int_t splitlevel);  Same as TTree::Branch() with added check that addobj matches className. ;  ; virtual TBranch * BranchImp (const char *branchname, TClass *ptrClass, void *addobj, Int_t bufsize, Int_t splitlevel);  Same as TTree::Branch but automatic detection of the class name. ;  ; virtual TBranch * BranchImpArr (const char *branchname, EDataType datatype, std::size_t N, void *addobj, Int_t bufsize, Int_t splitlevel);  ; virtual TBranch * BranchImpRef (const char *branchname, const char *classname, TClass *ptrClass, void *addobj, Int_t bufsize, Int_t splitlevel);  Same as TTree::Branch but automatic detection of the class name. ;  ; virtual TBranch * BranchImpRef (const char *branchname, TClass *ptrClass, EDataType datatype, void *addobj, Int_t bufsize, Int_t splitlevel);  Same as TTree::Branch but automatic detection of the class name. ;  ; virtual TBranch * BronchExec (const char *name, const char *classname, void *addobj, bool isptrptr, Int_t bufsize, Int_t splitlevel);  Helper function implementing TTree::Bronch and TTree::Branch(const char *name, T &obj);. ;  ; virtual Int_t CheckBranchAddressType (TBranch *branch, TClass *ptrClass, EDataType datatype, bool ptr);  Check whether or not the address described by the last 3 parameters matches the content of the branch. ;  ; Long64_t GetCacheAutoSize (bool withDefault=false);  Used for automatic sizing of the cache. ;  ; virtual TLeaf * GetLeafImpl (const char *branchname, const char *leafname);  Return pointer to the 1st Leaf named name in any Branch of this Tree or any branch in the list of friend trees. ;  ; char GetNewlineValue (std::istream &inputStream);  Determine which newline this file is using. ;  ; void ImportClusterRanges (TTree *fromtree);  Appends t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofChain.html:52073,detect,detection,52073,doc/master/classTProofChain.html,https://root.cern,https://root.cern/doc/master/classTProofChain.html,3,['detect'],['detection']
Safety," the Vegas algorithm ; Definition at line 439 of file GSLMCIntegrator.cxx. ◆ DoInitialize(). void ROOT::Math::GSLMCIntegrator::DoInitialize ; (; ). protected . Definition at line 401 of file GSLMCIntegrator.cxx. ◆ Error(). double ROOT::Math::GSLMCIntegrator::Error ; (; ); const. overridevirtual . return the estimate of the absolute Error of the last Integral calculation ; Implements ROOT::Math::VirtualIntegrator.; Definition at line 253 of file GSLMCIntegrator.cxx. ◆ ExtraOptions(). std::unique_ptr< ROOT::Math::IOptions > ROOT::Math::GSLMCIntegrator::ExtraOptions ; (; ); const. get the specific options (for Vegas or Miser) in term of string- name. ; return a new option object which is managed by user; This is for querying existing options and return object is managed by the user ; Definition at line 484 of file GSLMCIntegrator.cxx. ◆ GetType(). MCIntegration::Type ROOT::Math::GSLMCIntegrator::GetType ; (; ); const. inline . return the type (need to be called GetType to avoid a conflict with typedef) ; Definition at line 273 of file GSLMCIntegrator.h. ◆ GetTypeName(). const char * ROOT::Math::GSLMCIntegrator::GetTypeName ; (; ); const. return the name ; Definition at line 466 of file GSLMCIntegrator.cxx. ◆ Integral() [1/2]. double ROOT::Math::GSLMCIntegrator::Integral ; (; const double * ; a, . const double * ; b . ). overridevirtual . evaluate the integral using the previously defined function ; Implements ROOT::Math::VirtualIntegratorMultiDim.; Definition at line 182 of file GSLMCIntegrator.cxx. ◆ Integral() [2/2]. double ROOT::Math::GSLMCIntegrator::Integral ; (; const GSLMonteFuncPointer & ; f, . unsigned int ; dim, . double * ; a, . double * ; b, . void * ; p = nullptr . ). evaluate the Integral of a function f over the defined hypercube (a,b) ; Parameters. fintegration function. The function type must implement the mathlib::IGenFunction interface ; dimthe dimension ; alower value of the integration interval ; bupper value of the integration interval ; ppointer t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1GSLMCIntegrator.html:8067,avoid,avoid,8067,doc/master/classROOT_1_1Math_1_1GSLMCIntegrator.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1GSLMCIntegrator.html,1,['avoid'],['avoid']
Safety," the callable is applied to must be exactly T. Example usage together with RDataFrame (""varX"" columns must all be float variables): bool myVecFunc(std::vector<float> args);; df.Filter(PassAsVec<3, float>(myVecFunc), {""var1"", ""var2"", ""var3""});. Definition at line 103 of file RDFHelpers.hxx. ◆ RunGraphs(). unsigned int ROOT::RDF::RunGraphs ; (; std::vector< RResultHandle > ; handles). Trigger the event loop of multiple RDataFrames concurrently. ; Parameters. [in]handlesA vector of RResultHandles . ReturnsThe number of distinct computation graphs that have been processed; This function triggers the event loop of all computation graphs which relate to the given RResultHandles. The advantage compared to running the event loop implicitly by accessing the RResultPtr is that the event loops will run concurrently. Therefore, the overall computation of all results is generally more efficient. It should be noted that user-defined operations (e.g., Filters and Defines) of the different RDataFrame graphs are assumed to be safe to call concurrently.; ROOT::RDataFrame df1(""tree1"", ""file1.root"");; auto r1 = df1.Histo1D(""var1"");; ; ROOT::RDataFrame df2(""tree2"", ""file2.root"");; auto r2 = df2.Sum(""var2"");; ; // RResultPtr -> RResultHandle conversion is automatic; ROOT::RDF::RunGraphs({r1, r2});; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; ROOT::RDF::RunGraphsunsigned int RunGraphs(std::vector< RResultHandle > handles)Trigger the event loop of multiple RDataFrames concurrently.Definition RDFHelpers.cxx:66. Definition at line 66 of file RDFHelpers.cxx. ◆ SaveGraph() [1/2]. template<typename NodeType > . std::string ROOT::RDF::SaveGraph ; (; NodeType ; node). Create a graphviz representation of the dataframe computation graph, return it as a string. ; Parameters. [in]nodeany node of the graph. Called on the head (first) node, it prints the entire graph. Otherwise, only the branch the node b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1RDF.html:14112,safe,safe,14112,doc/master/namespaceROOT_1_1RDF.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1RDF.html,2,['safe'],['safe']
Safety," the current directory. ;  ; void Reset ();  Reset the key as it had not been 'filled' yet. ;  ; virtual Int_t WriteFileKeepBuffer (TFile *f=nullptr);  Write the encoded object supported by this key. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; TBranch * fBranch {nullptr};  Pointer to the basket support branch. ;  ; Int_t fBufferSize {0};  fBuffer length in bytes ;  ; TBuffer * fCompressedBufferRef {nullptr};  ! Compressed buffer. ;  ; Int_t * fDisplacement {nullptr};  ![fNevBuf] Displacement of entries in fBuffer(TKey) ;  ; Int_t * fEntryOffset {nullptr};  [fNevBuf] Offset of entries in fBuffer(TKey); generated at runtime. ;  ; bool fHeaderOnly {false};  True when only the basket header must be read/written. ;  ; UChar_t fIOBits {0};  !IO feature flags. Serialized in custom portion of streamer to avoid forward compat issues unless needed. ;  ; Int_t fLast {0};  Pointer to last used byte in basket. ;  ; Int_t fLastWriteBufferSize [3] = {0,0,0};  ! Size of the buffer last three buffers we wrote it to disk ;  ; Int_t fNevBuf {0};  Number of entries in basket. ;  ; Int_t fNevBufSize {0};  Length in Int_t of fEntryOffset OR fixed length of each entry if fEntryOffset is null! ;  ; UChar_t fNextBufferSizeRecord {0};  ! Index into fLastWriteBufferSize of the last buffer written to disk ;  ; bool fOwnsCompressedBuffer {false};  ! Whether or not we own the compressed buffer. ;  ; bool fReadEntryOffset {false};  !Set to true if offset array was read from a file. ;  ; bool fResetAllocation {false};  ! True if last reset re-allocated the memory ;  ;  Protected Attributes inherited from TKey; char * fBuffer;  Object buffer. ;  ; TBuffer * fBufferRef;  Pointer to the TBuffer object. ;  ; TString fClassName;  Object Class name. ;  ; Short_t fCycle;  Cycle number. ;  ; TDatime fDatime;  Date/T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBasket.html:18027,avoid,avoid,18027,doc/master/classTBasket.html,https://root.cern,https://root.cern/doc/master/classTBasket.html,1,['avoid'],['avoid']
Safety," the errno has been reset and the method can be called again. ; Definition at line 3901 of file TUnixSystem.cxx. ◆ UnixSend(). int TUnixSystem::UnixSend ; (; int ; sock, . const void * ; buffer, . int ; length, . int ; flag . ). staticprotected . Send exactly length bytes from buffer. ; Returns -1 in case of error, otherwise number of sent bytes. Returns -4 in case of kNoBlock and errno == EWOULDBLOCK. Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET). ; Definition at line 4558 of file TUnixSystem.cxx. ◆ UnixSetitimer(). int TUnixSystem::UnixSetitimer ; (; Long_t ; ms). staticprotected . Set interval timer to time-out in ms milliseconds. ; Definition at line 3875 of file TUnixSystem.cxx. ◆ UnixSigAlarmInterruptsSyscalls(). void TUnixSystem::UnixSigAlarmInterruptsSyscalls ; (; Bool_t ; set). staticprotected . When the argument is true the SIGALRM signal handler is set so that interrupted syscalls will not be restarted by the kernel. ; This is typically used in case one wants to put a timeout on an I/O operation. By default interrupted syscalls will always be restarted (for all signals). This can be controlled for each a-synchronous TTimer via the method TTimer::SetInterruptSyscalls(). ; Definition at line 3777 of file TUnixSystem.cxx. ◆ UnixSignal(). void TUnixSystem::UnixSignal ; (; ESignals ; sig, . SigHandler_t ; h . ). staticprotected . Set a signal handler for a signal. ; Definition at line 3703 of file TUnixSystem.cxx. ◆ UnixSigname(). const char * TUnixSystem::UnixSigname ; (; ESignals ; sig). staticprotected . Return the signal name associated with a signal. ; Definition at line 3813 of file TUnixSystem.cxx. ◆ UnixTcpConnect(). int TUnixSystem::UnixTcpConnect ; (; const char * ; hostname, . int ; port, . int ; tcpwindowsize . ). staticprotected . Open a TCP/IP connection to server and connect to a service (i.e. ; port). Use tcpwindowsize to specify the size of the receive buffer, it has to be specified here to make sure the window scale option i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnixSystem.html:76130,timeout,timeout,76130,doc/master/classTUnixSystem.html,https://root.cern,https://root.cern/doc/master/classTUnixSystem.html,1,['timeout'],['timeout']
Safety," the execution scenario allows it. For example, if ROOT is configured to use an external scheduler, setting a value for 'numthreads' might not have any effect. ; Definition at line 525 of file TROOT.cxx. ◆ EnableThreadSafety(). void ROOT::EnableThreadSafety ; (; ). Enables the global mutex to make ROOT thread safe/aware. ; The following becomes safe:; concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); concurrent usage of different ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; concurrent calls to the interpreter through gInterpreter; concurrent loading of ROOT plug-ins. In addition, gDirectory, gFile and gPad become a thread-local variable. In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents. gFile and gPad default to nullptr, as it is for single-thread programs.; The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different canvases from different threads (and analogous operations such as invoking Draw on a TObject) is not thread-safe.; Note that there is no DisableThreadSafety(). ROOT's thread-safety features cannot be disabled once activated. ; Definition at line 494 of file TROOT.cxx. ◆ FindEndSymbol(). static std::string::size_type ROOT::FindEndSymbol ; (; std::string & ; command). static . Definition at line 62 of file RConversionRuleParser.cxx. ◆ FromHumanReadableSize() [1/2]. template<typename T > . EFromHumanReadableSize ROOT::FromHumanReadableSize ; (; ROOT::Internal::TStringView ; str, . T & ; value . ). Definition at line 158 of file StringConv.hxx. ◆ FromHumanReadableSize() [2/2]. template<typename T > . EFromHumanReadableSize ROOT::FromHumanReadableSi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v624/namespaceROOT.html:21954,safe,safe,21954,doc/v624/namespaceROOT.html,https://root.cern,https://root.cern/doc/v624/namespaceROOT.html,1,['safe'],['safe']
Safety," the execution scenario allows it. For example, if ROOT is configured to use an external scheduler, setting a value for 'numthreads' might not have any effect. ; Definition at line 526 of file TROOT.cxx. ◆ EnableThreadSafety(). void ROOT::EnableThreadSafety ; (; ). Enables the global mutex to make ROOT thread safe/aware. ; The following becomes safe:; concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); concurrent usage of different ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; concurrent calls to the interpreter through gInterpreter; concurrent loading of ROOT plug-ins. In addition, gDirectory, gFile and gPad become a thread-local variable. In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents. gFile and gPad default to nullptr, as it is for single-thread programs.; The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different canvases from different threads (and analogous operations such as invoking Draw on a TObject) is not thread-safe.; Note that there is no DisableThreadSafety(). ROOT's thread-safety features cannot be disabled once activated. ; Definition at line 495 of file TROOT.cxx. ◆ FindEndSymbol(). static std::string::size_type ROOT::FindEndSymbol ; (; std::string & ; command). static . Definition at line 62 of file RConversionRuleParser.cxx. ◆ FromHumanReadableSize() [1/2]. template<typename T > . EFromHumanReadableSize ROOT::FromHumanReadableSize ; (; ROOT::Internal::TStringView ; str, . T & ; value . ). Definition at line 158 of file StringConv.hxx. ◆ FromHumanReadableSize() [2/2]. template<typename T > . EFromHumanReadableSize ROOT::FromHumanReadableSi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v622/namespaceROOT.html:21915,safe,safe,21915,doc/v622/namespaceROOT.html,https://root.cern,https://root.cern/doc/v622/namespaceROOT.html,1,['safe'],['safe']
Safety," the execution scenario allows it. For example, if ROOT is configured to use an external scheduler, setting a value for 'numthreads' might not have any effect. ; Definition at line 579 of file TROOT.cxx. ◆ EnableThreadSafety(). void ROOT::EnableThreadSafety ; (; ). Enables the global mutex to make ROOT thread safe/aware. ; The following becomes safe:; concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); concurrent usage of different ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; concurrent calls to the interpreter through gInterpreter; concurrent loading of ROOT plug-ins. In addition, gDirectory, gFile and gPad become a thread-local variable. In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents. gFile and gPad default to nullptr, as it is for single-thread programs.; The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different canvases from different threads (and analogous operations such as invoking Draw on a TObject) is not thread-safe.; Note that there is no DisableThreadSafety(). ROOT's thread-safety features cannot be disabled once activated. ; Definition at line 548 of file TROOT.cxx. ◆ FindEndSymbol(). static std::string::size_type ROOT::FindEndSymbol ; (; std::string & ; command). static . Definition at line 50 of file RConversionRuleParser.cxx. ◆ FromHumanReadableSize() [1/2]. template<typename T > . EFromHumanReadableSize ROOT::FromHumanReadableSize ; (; ROOT::Internal::TStringView ; str, . T & ; value . ). Definition at line 158 of file StringConv.hxx. ◆ FromHumanReadableSize() [2/2]. template<typename T > . EFromHumanReadableSize ROOT::FromHumanReadableSi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v618/namespaceROOT.html:21225,safe,safe,21225,doc/v618/namespaceROOT.html,https://root.cern,https://root.cern/doc/v618/namespaceROOT.html,1,['safe'],['safe']
Safety," the execution scenario allows it. For example, if ROOT is configured to use an external scheduler, setting a value for 'numthreads' might not have any effect. ; Definition at line 580 of file TROOT.cxx. ◆ EnableThreadSafety(). void ROOT::EnableThreadSafety ; (; ). Enables the global mutex to make ROOT thread safe/aware. ; The following becomes safe:; concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); concurrent usage of different ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; concurrent calls to the interpreter through gInterpreter; concurrent loading of ROOT plug-ins. In addition, gDirectory, gFile and gPad become a thread-local variable. In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents. gFile and gPad default to nullptr, as it is for single-thread programs.; The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different canvases from different threads (and analogous operations such as invoking Draw on a TObject) is not thread-safe.; Note that there is no DisableThreadSafety(). ROOT's thread-safety features cannot be disabled once activated. ; Definition at line 549 of file TROOT.cxx. ◆ FindEndSymbol(). static std::string::size_type ROOT::FindEndSymbol ; (; std::string & ; command). static . Definition at line 62 of file RConversionRuleParser.cxx. ◆ FromHumanReadableSize() [1/2]. template<typename T > . EFromHumanReadableSize ROOT::FromHumanReadableSize ; (; ROOT::Internal::TStringView ; str, . T & ; value . ). Definition at line 158 of file StringConv.hxx. ◆ FromHumanReadableSize() [2/2]. template<typename T > . EFromHumanReadableSize ROOT::FromHumanReadableSi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v620/namespaceROOT.html:21317,safe,safe,21317,doc/v620/namespaceROOT.html,https://root.cern,https://root.cern/doc/v620/namespaceROOT.html,1,['safe'],['safe']
Safety," the given class.; 187///; 188/// WARNING: in name avoid special characters like '^','$','.' that are used; 189/// by the regular expression parser (see TRegexp).; 190 ; 191TKey::TKey(const char *name, const char *title, const TClass *cl, Int_t nbytes, TDirectory* motherDir); 192 : TNamed(name,title); 193{; 194 Build(motherDir, cl->GetName(), -1);; 195 ; 196 fKeylen = Sizeof();; 197 fObjlen = nbytes;; 198 Create(nbytes);; 199}; 200 ; 201////////////////////////////////////////////////////////////////////////////////; 202/// Create a TKey object with the specified name, title for the given class.; 203///; 204/// WARNING: in name avoid special characters like '^','$','.' that are used; 205/// by the regular expression parser (see TRegexp).; 206 ; 207TKey::TKey(const TString &name, const TString &title, const TClass *cl, Int_t nbytes, TDirectory* motherDir); 208 : TNamed(name,title); 209{; 210 Build(motherDir, cl->GetName(), -1);; 211 ; 212 fKeylen = Sizeof();; 213 fObjlen = nbytes;; 214 Create(nbytes);; 215}; 216 ; 217////////////////////////////////////////////////////////////////////////////////; 218/// Create a TKey object for a TObject* and fill output buffer; 219///; 220/// WARNING: in name avoid special characters like '^','$','.' that are used; 221/// by the regular expression parser (see TRegexp).; 222 ; 223TKey::TKey(const TObject *obj, const char *name, Int_t bufsize, TDirectory* motherDir); 224 : TNamed(name, obj->GetTitle()); 225{; 226 R__ASSERT(obj);; 227 ; 228 if (!obj->IsA()->HasDefaultConstructor()) {; 229 Warning(""TKey"", ""since %s has no public constructor\n""; 230 ""\twhich can be called without argument, objects of this class\n""; 231 ""\tcan not be read with the current library. You will need to\n""; 232 ""\tadd a default constructor before attempting to read it."",; 233 obj->ClassName());; 234 }; 235 ; 236 Build(motherDir, obj->ClassName(), -1);; 237 ; 238 Int_t lbuf, nout, noutot, bufmax, nzip;; 239 fBufferRef = new TBufferFile(TBuffer::kWrite, bufsize)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TKey_8cxx_source.html:7649,avoid,avoid,7649,doc/master/TKey_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TKey_8cxx_source.html,1,['avoid'],['avoid']
Safety," the line segments of the shape mesh.; The output array must be provided with a length of minimum 3*npoints. Returns; true if operation is implemented. Int_t GetFittingBox(const TGeoBBox* parambox, TGeoMatrix* mat, Double_t& dx, Double_t& dy, Double_t& dz) const; Fills real parameters of a positioned box inside this one. Returns 0 if successfull. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; In case shape has some negative parameters, these has to be computed; in order to fit the mother. void GetMeshNumbers(Int_t& nvert, Int_t& nsegs, Int_t& npols) const; Returns numbers of vertices, segments and polygons composing the shape mesh. void InspectShape() const; Prints shape parameters. TBuffer3D * MakeBuffer3D() const; Creates a TBuffer3D describing *this* shape.; Coordinates are in local reference frame. void SetSegsAndPols(TBuffer3D& buffer) const; Fills TBuffer3D structure for segments and polygons. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; Computes the closest distance from given point to this shape. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); Set parameters of the box. void SetDimensions(Double_t* param); Set dimensions based on the array of parameters; param[0] - half-length in x; param[1] - half-length in y; param[2] - half-length in z. void SetBoxPoints(Double_t* points) const; Fill box vertices to an array. void SetPoints(Double_t* points) const; Fill box points. void SetPoints(Float_t* points) const; Fill box points. void Sizeof3D() const; fill size of this 3-D object; TVirtualGeoPainter *painter = gGeoManager->GetGeomPainter();; if (painter) painter->AddSize3D(8, 12, 6);. const TBuffer3D & GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; Fills a static 3D buffer and returns a reference. void FillBuffer3D(TBuffer3D& buffer, Int_t reqSections, Bool_t l",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoBBox.html:17423,Safe,Safety,17423,root/html528/TGeoBBox.html,https://root.cern,https://root.cern/root/html528/TGeoBBox.html,3,['Safe'],['Safety']
Safety," the list of memory objects of the current; directory or its sub-directories.; After this call the current directory is not changed.; To automatically set the current directory where the object is found,; use FindKeyAny(aname)->ReadObj(). TObject * Get(const char* namecycle); return pointer to object identified by namecycle. namecycle has the format name;cycle; name = * is illegal, cycle = * is illegal; cycle = """" or cycle = 9999 ==> apply to a memory object. examples:; foo : get object named foo in memory; if object is not in memory, try with highest cycle from file; foo;1 : get cycle 1 of foo on file. The retrieved object should in principle derive from TObject.; If not, the function TDirectoryFile::GetObject should be called.; However, this function will still work for a non-TObject, providing that; the calling application cast the return type to the correct type (which; is the actual type of the object). NOTE:; The method GetObject offers better protection and avoids the need; for any cast:; MyClass *obj;; directory->GetObject(""some object"",obj);; if (obj) { ... the object exist and inherits from MyClass ... }. VERY IMPORTANT NOTE:; In case the class of this object derives from TObject but not; as a first inheritance, one must use dynamic_cast<>().; Example 1: Normal case:; class MyClass : public TObject, public AnotherClass; then on return, one can do:; MyClass *obj = (MyClass*)directory->Get(""some object of MyClass"");. Example 2: Special case:; class MyClass : public AnotherClass, public TObject; then on return, one must do:; MyClass *obj = dynamic_cast<MyClass*>(directory->Get(""some object of MyClass""));. Of course, dynamic_cast<> can also be used in the example 1. void * GetObjectUnchecked(const char* namecycle); return pointer to object identified by namecycle.; The returned object may or may not derive from TObject. namecycle has the format name;cycle; name = * is illegal, cycle = * is illegal; cycle = """" or cycle = 9999 ==> apply to a memory object. VERY I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TDirectoryFile.html:16629,avoid,avoids,16629,root/html528/TDirectoryFile.html,https://root.cern,https://root.cern/root/html528/TDirectoryFile.html,6,['avoid'],['avoids']
Safety," the physical nodes of the parallel world. Better; be done before misalignment. void AddOverlap(const char* volname, Bool_t activate = kTRUE); To use this optimization, the user should declare the full list of volumes; which may overlap with any of the physical nodes of the parallel world. Better; be done before misalignment. Int_t PrintDetectedOverlaps() const; Print the overlaps which were detected during real tracking. void ResetOverlaps() const; Reset overlapflag for all volumes in geometry. Bool_t CloseGeometry(); The main geometry must be closed. void RefreshPhysicalNodes(); Refresh the node pointers and re-voxelize. To be called mandatory in case; re-alignment happened. TGeoPhysicalNode * FindNode(Double_t[3] point); Finds physical node containing the point. TGeoPhysicalNode * FindNextBoundary(Double_t[3] point, Double_t[3] dir, Double_t& step, Double_t stepmax = 1.0E+30); Same functionality as TGeoNavigator::FindNextDaughterBoundary for the; parallel world. Double_t Safety(Double_t[3] point, Double_t safmax = 1.0E+30); Compute safety for the parallel world. void CheckOverlaps(Double_t ovlp = 0.001); Check overlaps within a tolerance value. void Draw(Option_t* option); Draw the parallel world. TGeoParallelWorld(const TGeoParallelWorld& ). TGeoParallelWorld& operator=(const TGeoParallelWorld& ). TGeoParallelWorld(); constructors. {}. void SetUseOverlaps(Bool_t flag); Activate/deactivate overlap usage. {fUseOverlaps = flag;}. Bool_t IsUsingOverlaps() const; {return fUseOverlaps;}. TGeoManager * GetGeometry() const; Getters. {return fGeoManager;}. Bool_t IsClosed() const; {return fIsClosed;}. TGeoVolume * GetVolume() const; {return fVolume;}. » Author: Andrei Gheata 30/06/14 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: Tue Jun 2 16:02:24 2015 » Last generated: 2015-06-02 16:02; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGeoParallelWorld.html:8939,Safe,Safety,8939,root/html604/TGeoParallelWorld.html,https://root.cern,https://root.cern/root/html604/TGeoParallelWorld.html,2,"['Safe', 'safe']","['Safety', 'safety']"
Safety," the queue of submitted jobs.; to be called on the top master only. Int_t RegisterDataSets(TList* in, TList* out); Register TFileCollections in 'out' as datasets according to the rules in 'in'. void HandleQueryList(TMessage* mess); Handle request for list of queries. void HandleRemove(TMessage* mess, TString* slb = 0); Handle remove request. void HandleRetrieve(TMessage* mess, TString* slb = 0); Handle retrieve request. void HandleLibIncPath(TMessage* mess); Handle lib, inc search paths modification request. void HandleCheckFile(TMessage* mess, TString* slb = 0); Handle file checking request. Int_t HandleCache(TMessage* mess, TString* slb = 0); Handle here all cache and package requests. void HandleWorkerLists(TMessage* mess); Handle here all requests to modify worker lists. FILE * SetErrorHandlerFile(FILE* ferr); Set the file stream where to log (default stderr).; If ferr == 0 the default is restored.; Returns current setting. void ErrorHandler(Int_t level, Bool_t abort, const char* location, const char* msg); The PROOF error handler function. It prints the message on fgErrorHandlerFile and; if abort is set it aborts the application. Int_t CopyFromCache(const char* name, Bool_t cpbin); Retrieve any files related to 'macro' from the cache directory.; If 'cpbin' is true, the associated binaries are retrieved as well.; Returns 0 on success, -1 otherwise. Int_t CopyToCache(const char* name, Int_t opt = 0); Copy files related to 'macro' to the cache directory.; Action depends on 'opt':. opt = 0 copy 'macro' to cache and delete from cache any binary; related to name; e.g. if macro = bla.C, the binaries are; bla_C.so, bla_C.rootmap, ...; opt = 1 copy the binaries related to macro to the cache. Returns 0 on success, -1 otherwise. void MakePlayer(); Make player instance. void DeletePlayer(); Delete player instance. Int_t GetPriority(); Get the processing priority for the group the user belongs too. This; prioroty is a number (0 - 100) determined by a scheduler (third; party ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofServ.html:26581,abort,abort,26581,root/html528/TProofServ.html,https://root.cern,https://root.cern/root/html528/TProofServ.html,1,['abort'],['abort']
Safety," the record). Option compress is used to specify the compression level:; compress = 0 objects written to this file will not be compressed.; compress = 1 minimal compression level but fast. compress = 9 maximal compression level but slow. Note that the compression level may be changed at any time.; The new compression level will only apply to newly written objects.; The function TFile::Map() shows the compression factor; for each object written to this file.; The function TFile::GetCompressionFactor returns the global; compression factor for this file. In case the file does not exist or is not a valid ROOT file,; it is made a Zombie. One can detect this situation with a code like:; TFile f(""file.root"");; if (f.IsZombie()) {; cout << ""Error opening file"" << endl;; exit(-1);; }. When opening the file, the system checks the validity of this directory.; If something wrong is detected, an automatic Recovery is performed. In; this case, the file is scanned sequentially reading all logical blocks; and attempting to rebuild a correct directory (see TFile::Recover).; One can disable the automatic recovery procedure when reading one; or more files by setting the environment variable ""TFile::Recover 0""; in the system.rootrc file. TFile(const TFile& ); TFile objects can not be copied. ~TFile(); File destructor. void Init(Bool_t create); Initialize a TFile object.; TFile implementations providing asynchronous open functionality need to; override this method to run the appropriate checks before calling this; standard initialization part. See TXNetFile::Init for an example. void Close(Option_t* option = """"); Close a file.; If option == ""R"", all TProcessIDs referenced by this file are deleted.; Calling TFile::Close(""R"") might be necessary in case one reads a long list; of files having TRef, writing some of the referenced objects or TRef; to a new file. If the TRef or referenced objects of the file being closed; will not be referenced again, it is possible to minimize the size; of th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFile.html:26275,Recover,Recover,26275,root/html528/TFile.html,https://root.cern,https://root.cern/root/html528/TFile.html,1,['Recover'],['Recover']
Safety," the; 174/// object to be notified (if it was set).; 175 ; 176void TTimer::SetCommand(const char *command); 177{; 178 fObject = nullptr;; 179 fCommand = command;; 180}; 181 ; 182////////////////////////////////////////////////////////////////////////////////; 183/// Set the object to be notified at time out. Removes the command to; 184/// be executed (if it was set).; 185 ; 186void TTimer::SetObject(TObject *object); 187{; 188 fObject = object;; 189 fCommand = """";; 190}; 191 ; 192////////////////////////////////////////////////////////////////////////////////; 193/// When the argument is true the a-synchronous timer (SIGALRM) signal; 194/// handler is set so that interrupted syscalls will not be restarted; 195/// by the kernel. This is typically used in case one wants to put a; 196/// timeout on an I/O operation. By default interrupted syscalls will; 197/// be restarted.; 198 ; 199void TTimer::SetInterruptSyscalls(Bool_t set); 200{; 201 fIntSyscalls = set;; 202}; 203 ; 204////////////////////////////////////////////////////////////////////////////////; 205/// Starts the timer with a milliSec timeout. If milliSec is 0; 206/// then the timeout will be the minimum timeout (see TSystem::ESysConstants,; 207/// i.e. 10 ms), if milliSec is -1 then the time interval as previously; 208/// specified (in ctor or SetTime()) will be used.; 209/// If singleShot is kTRUE, the timer will be activated only once,; 210/// otherwise it will continue until it is stopped.; 211/// See also TurnOn(), Stop(), TurnOff().; 212 ; 213void TTimer::Start(Long_t milliSec, Bool_t singleShot); 214{; 215 if (milliSec >= 0); 216 SetTime(milliSec);; 217 Reset();; 218 TurnOn();; 219 if (singleShot); 220 Connect(this, ""Timeout()"", ""TTimer"", this, ""TurnOff()"");; 221 else; 222 Disconnect(this, ""Timeout()"", this, ""TurnOff()"");; 223}; 224 ; 225////////////////////////////////////////////////////////////////////////////////; 226/// Remove timer from system timer list. This requires that a timer; 227/// has be",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTimer_8cxx_source.html:7062,timeout,timeout,7062,doc/master/TTimer_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTimer_8cxx_source.html,1,['timeout'],['timeout']
Safety," this formula for this; entry (==TTreeFormula::GetNdata()); Iteration$: return the current iteration over this formula for this; entry (i.e. varies from 0 to Length$). Length$(formula): return the total number of element of the formula given as a; parameter.; Sum$(formula): return the sum of the value of the elements of the formula given; as a parameter. For example the mean for all the elements in; one entry can be calculated with:; Sum$(formula)/Length$(formula); Min$(formula): return the minimun (within one TTree entry) of the value of the; elements of the formula given as a parameter.; Max$(formula): return the maximum (within one TTree entry) of the value of the; elements of the formula given as a parameter.; MinIf$(formula,condition); MaxIf$(formula,condition): return the minimum (maximum) (within one TTree entry); of the value of the elements of the formula given as a parameter; if they match the condition. If not element match the condition, the result is zero. To avoid the; the result is zero. To avoid the consequent peak a zero, use the; pattern:; tree->Draw(""MinIf$(formula,condition)"",""condition"");; which will avoid calculation MinIf$ for the entries that have no match; for the condition. Alt$(primary,alternate) : return the value of ""primary"" if it is available; for the current iteration otherwise return the value of ""alternate"".; For example, with arr1[3] and arr2[2]; tree->Draw(""arr1+Alt$(arr2,0)"");; will draw arr1[0]+arr2[0] ; arr1[1]+arr2[1] and arr1[2]+0; Or with a variable size array arr3; tree->Draw(""Alt$(arr3[0],0)+Alt$(arr3[1],0)+Alt$(arr3[2],0)"");; will draw the sum arr3 for the index 0 to min(2,actual_size_of_arr3-1); As a comparison; tree->Draw(""arr3[0]+arr3[1]+arr3[2]"");; will draw the sum arr3 for the index 0 to 2 only if the; actual_size_of_arr3 is greater or equal to 3.; Note that the array in 'primary' is flatened/linearilized thus using; Alt$ with multi-dimensional arrays of different dimensions in unlikely; to yield the expected result",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTree.html:73864,avoid,avoid,73864,root/html528/TTree.html,https://root.cern,https://root.cern/root/html528/TTree.html,2,['avoid'],['avoid']
Safety," this formula for this; entry (==TTreeFormula::GetNdata()); Iteration$: return the current iteration over this formula for this; entry (i.e. varies from 0 to Length$). Length$(formula): return the total number of element of the formula given as a; parameter.; Sum$(formula): return the sum of the value of the elements of the formula given; as a parameter. For example the mean for all the elements in; one entry can be calculated with:; Sum$(formula)/Length$(formula); Min$(formula): return the minimun (within one TTree entry) of the value of the; elements of the formula given as a parameter.; Max$(formula): return the maximum (within one TTree entry) of the value of the; elements of the formula given as a parameter.; MinIf$(formula,condition); MaxIf$(formula,condition): return the minimum (maximum) (within one TTree entry); of the value of the elements of the formula given as a parameter; if they match the condition. If not element match the condition, the result is zero. To avoid the; the result is zero. To avoid the consequent peak a zero, use the; pattern:; tree->Draw(""MinIf$(formula,condition)"",""condition"");; which will avoid calculation MinIf$ for the entries that have no match; for the condition. Alt$(primary,alternate) : return the value of ""primary"" if it is available; for the current iteration otherwise return the value of ""alternate"".; For example, with arr1[3] and arr2[2]; tree->Draw(""arr1+Alt$(arr2,0)"");; will draw arr[0]+arr2[0] ; arr[1]+arr2[1] and arr[1]+0; Or with a variable size array arr3; tree->Draw(""Alt$(arr3[0],0)+Alt$(arr3[1],0)+Alt$(arr3[2],0)"");; will draw the sum arr3 for the index 0 to min(2,actual_size_of_arr3-1); As a comparison; tree->Draw(""arr3[0]+arr3[1]+arr3[2]"");; will draw the sum arr3 for the index 0 to 2 only if the; actual_size_of_arr3 is greater or equal to 3.; Note that the array in 'primary' is flattened/linearized thus using; Alt$ with multi-dimensional arrays of different dimensions in unlikely; to yield the expected results. T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreePlayer.html:30046,avoid,avoid,30046,root/html528/TTreePlayer.html,https://root.cern,https://root.cern/root/html528/TTreePlayer.html,1,['avoid'],['avoid']
Safety," thread. ; Definition at line 510 of file TThread.cxx. ◆ Kill() [1/3]. Int_t TThread::Kill ; (; ). Kill this thread. ; Returns 0 on success, otherwise an error number will be returned. ; Definition at line 590 of file TThread.cxx. ◆ Kill() [2/3]. Int_t TThread::Kill ; (; const char * ; name). static . Static method to kill thread by name. ; Returns 0 on success, otherwise an error number will be returned. ; Definition at line 622 of file TThread.cxx. ◆ Kill() [3/3]. Int_t TThread::Kill ; (; Long_t ; id). static . Static method to kill the thread by id. ; Returns 0 on success, otherwise an error number will be returned. ; Definition at line 606 of file TThread.cxx. ◆ Lock(). Int_t TThread::Lock ; (; ). static . Static method to lock the main thread mutex. ; Definition at line 772 of file TThread.cxx. ◆ operator=(). TThread & TThread::operator= ; (; const TThread & ; ). privatedelete . ◆ Printf(). void TThread::Printf ; (; const char * ; fmt, .  ; ... . ). static . Static method providing a thread safe printf. Appends a newline. ; Definition at line 916 of file TThread.cxx. ◆ Ps(). void TThread::Ps ; (; ). static . Static method listing the existing threads. ; Definition at line 843 of file TThread.cxx. ◆ ps(). static void TThread::ps ; (; ). inlinestatic . Definition at line 132 of file TThread.h. ◆ Run(). Int_t TThread::Run ; (; void * ; arg = nullptr, . const int ; affinity = -1 . ). Start the thread. ; This starts the static method TThread::Function() which calls the user function specified in the TThread ctor with the arg argument. If affinity is specified (>=0), a CPU affinity will be associated with the current thread. Returns 0 on success, otherwise an error number will be returned. ; Definition at line 566 of file TThread.cxx. ◆ Self(). TThread * TThread::Self ; (; ). static . Static method returning pointer to current thread. ; Definition at line 495 of file TThread.cxx. ◆ SelfId(). Long_t TThread::SelfId ; (; ). static . Static method returning the id for t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTThread.html:27074,safe,safe,27074,doc/master/classTThread.html,https://root.cern,https://root.cern/doc/master/classTThread.html,1,['safe'],['safe']
Safety," timer timed out. ;  ; TTime GetAbsTime () const;  ; const char * GetCommand () const;  ; TObject * GetObject ();  ; TTime GetTime () const;  ; UInt_t GetTimerID ();  ; Bool_t HasTimedOut () const;  ; TClass * IsA () const override;  ; Bool_t IsAsync () const;  ; Bool_t IsInterruptingSyscalls () const;  ; Bool_t IsRunning ();  This function checks if the timer is running within gSystem (Has been started and did not finish yet). ;  ; Bool_t IsSync () const;  ; void Remove () override;  ; void Reset ();  Reset the timer. ;  ; void SetCommand (const char *command);  Set the interpreter command to be executed at time out. ;  ; void SetInterruptSyscalls (Bool_t set=kTRUE);  When the argument is true the a-synchronous timer (SIGALRM) signal handler is set so that interrupted syscalls will not be restarted by the kernel. ;  ; void SetObject (TObject *object);  Set the object to be notified at time out. ;  ; void SetTime (Long_t milliSec);  ; void SetTimerID (UInt_t id=0);  ; virtual void Start (Long_t milliSec=-1, Bool_t singleShot=kFALSE);  Starts the timer with a milliSec timeout. ;  ; virtual void Stop ();  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void Timeout ();  ; virtual void TurnOff ();  Remove timer from system timer list. ;  ; virtual void TurnOn ();  Add the timer to the system timer list. ;  ;  Public Member Functions inherited from TSysEvtHandler;  TSysEvtHandler ();  ; virtual ~TSysEvtHandler ();  ; void Activate ();  Activate a system event handler. ;  ; virtual void Activated ();  ; virtual void Added ();  ; void DeActivate ();  De-activate a system event handler. ;  ; virtual void DeActivated ();  ; Bool_t IsActive () const;  ; virtual void Notified ();  ; virtual void Removed ();  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTipDelayTimer.html:2013,timeout,timeout,2013,doc/master/classTTipDelayTimer.html,https://root.cern,https://root.cern/doc/master/classTTipDelayTimer.html,3,['timeout'],['timeout']
Safety," to advance the readers to the desired data entry. Some predefined RDataSources are natively provided by ROOT such as the ROOT::RDF::RCsvDS which allows to read comma separated files: auto tdf = ROOT::RDF::FromCSV(""MuRun2010B.csv"");; auto filteredEvents =; tdf.Filter(""Q1 * Q2 == -1""); .Define(""m"", ""sqrt(pow(E1 + E2, 2) - (pow(px1 + px2, 2) + pow(py1 + py2, 2) + pow(pz1 + pz2, 2)))"");; auto h = filteredEvents.Histo1D(""m"");; h->Draw();; See also FromNumpy (Python-only), FromRNTuple(), FromArrow(), FromSqlite(). Computation graphs (storing and reusing sets of transformations); As we saw, transformed dataframes can be stored as variables and reused multiple times to create modified versions of the dataset. This implicitly defines a computation graph in which several paths of filtering/creation of columns are executed simultaneously, and finally aggregated results are produced.; RDataFrame detects when several actions use the same filter or the same defined column, and only evaluates each filter or defined column once per event, regardless of how many times that result is used down the computation graph. Objects read from each column are built once and never copied, for maximum efficiency. When ""upstream"" filters are not passed, subsequent filters, temporary column expressions and actions are not evaluated, so it might be advisable to put the strictest filters first in the graph. Visualizing the computation graph; It is possible to print the computation graph from any node to obtain a DOT (graphviz) representation either on the standard output or in a file.; Invoking the function ROOT::RDF::SaveGraph() on any node that is not the head node, the computation graph of the branch the node belongs to is printed. By using the head node, the entire computation graph is printed.; Following there is an example of usage: // First, a sample computational graph is built; ROOT::RDataFrame df(""tree"", ""f.root"");; ; auto df2 = df.Define(""x"", []() { return 1; }); .Filter(""col0 % 1 == col0",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:73308,detect,detects,73308,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,2,['detect'],['detects']
Safety," to autoload for %s"", cls);; 6299 }; 6300 ; 6301 if (!gROOT || !gInterpreter || gROOT->TestBit(TObject::kInvalidObject)) {; 6302 if (gDebug > 2) {; 6303 Info(""TCling::AutoLoad"",; 6304 ""Disabled due to gROOT or gInterpreter being invalid/not ready (the class name is %s)"", cls);; 6305 }; 6306 return 0;; 6307 }; 6308 // Prevent the recursion when the library dictionary are loaded.; 6309 SuspendAutoLoadingRAII autoLoadOff(this);; 6310 // Try using externally provided callback first.; 6311 if (fAutoLoadCallBack) {; 6312 int success = (*(AutoLoadCallBack_t)fAutoLoadCallBack)(cls);; 6313 if (success); 6314 return success;; 6315 }; 6316 ; 6317 // During the 'Deep' part of the search we will call GetClassSharedLibsForModule; 6318 // (when module are enabled) which might end up calling AutoParsing but; 6319 // that should only be for the cases where the library has no generated pcm; 6320 // and in that case a rootmap should be available.; 6321 // This avoids a very costly operation (for generally no gain) but reduce the; 6322 // quality of the search (i.e. bad in case of library with no pcm and no rootmap; 6323 // file).; 6324 TInterpreter::SuspendAutoParsing autoParseRaii(this);; 6325 std::unordered_set<std::string> visited;; 6326 return DeepAutoLoadImpl(cls, visited, false /*normalized*/);; 6327}; 6328 ; 6329////////////////////////////////////////////////////////////////////////////////; 6330/// Parse the payload or header.; 6331 ; 6332static cling::Interpreter::CompilationResult ExecAutoParse(const char *what,; 6333 Bool_t header,; 6334 cling::Interpreter *interpreter); 6335{; 6336 std::string code = gNonInterpreterClassDef ;; 6337 if (!header) {; 6338 // This is the complete header file content and not the; 6339 // name of a header.; 6340 code += what;; 6341 ; 6342 } else {; 6343 code += (""#include \"""");; 6344 code += what;; 6345 code += ""\""\n"";; 6346 }; 6347 code += (""#ifdef __ROOTCLING__\n""; 6348 ""#undef __ROOTCLING__\n""; 6349 + gInterpreterClassDef +; 6350 ""#endif"");; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:245490,avoid,avoids,245490,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['avoid'],['avoids']
Safety," to be distributed;; TVirtualPacketizer::EUseEstOptTVirtualPacketizer::fUseEstOptControl usage of estimated values for the progress info; Bool_tTVirtualPacketizer::fValidConstructed properly?. private:. TMap*fAssignedPackMap {worker,packetizer} of lat assignement; TVirtualPacketizer*fCurrentPacketizer being currently processed; TList*fPacketizersPacketizers to be processed; TIter*fPacketizersIterIterator on fPacketizers. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPacketizerMulti(TDSet* dset, TList* slaves, Long64_t first, Long64_t num, TList* input, TProofProgressStatus* st); Constructor. ~TPacketizerMulti(); Destructor. TDSetElement * GetNextPacket(TSlave* wrk, TMessage* r); Get next packet from the current packetizer.; If the current packetizer is done, move to next.; Retun null when all packetizers are done. TVirtualPacketizer * CreatePacketizer(TDSet* dset, TList* wrks, Long64_t first, Long64_t num, TList* input, TProofProgressStatus* st); Create a packetizer for dataset 'dset'; Return null on failure. TPacketizerMulti(). TPacketizerMulti(const TPacketizerMulti& ). void operator=(const TPacketizerMulti& ). Int_t GetEstEntriesProcessed(Float_t f, Long64_t& ent, Long64_t& bytes, Long64_t& calls). Float_t GetCurrentRate(Bool_t& all). void StopProcess(Bool_t abort, Bool_t stoptimer = kFALSE). void MarkBad(TSlave* wrk, TProofProgressStatus* st, TList** missing); { if (fCurrent) fCurrent->MarkBad(wrk, st, missing); return; }. Int_t AddProcessed(TSlave* wrk, TProofProgressStatus* st, Double_t lat, TList** missing). Int_t GetActiveWorkers(); { if (fCurrent) return fCurrent->GetActiveWorkers(); return 0; }. » Author: G. Ganis Jan 2010 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: Sat Mar 14 16:46:23 2015 » Last generated: 2015-03-14 16:46; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TPacketizerMulti.html:10656,abort,abort,10656,root/html534/TPacketizerMulti.html,https://root.cern,https://root.cern/root/html534/TPacketizerMulti.html,1,['abort'],['abort']
Safety," to components. ;  ;  ~TGeoIntersection () override;  Destructor — deletion of components handled by TGeoManager class. ;  ; void ComputeBBox (Double_t &dx, Double_t &dy, Double_t &dz, Double_t *origin) override;  Compute bounding box corresponding to a intersection of two shapes. ;  ; void ComputeNormal (const Double_t *point, const Double_t *dir, Double_t *norm) override;  Normal computation in POINT. The orientation is chosen so that DIR.dot.NORM>0. ;  ; Bool_t Contains (const Double_t *point) const override;  Find if a intersection of two shapes contains a given point. ;  ; Int_t DistanceToPrimitive (Int_t px, Int_t py) override;  Compute minimum distance to shape vertices. ;  ; Double_t DistFromInside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=0, Double_t *safe=nullptr) const override;  Compute distance from a given point inside to the shape boundary. ;  ; Double_t DistFromOutside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=0, Double_t *safe=nullptr) const override;  Compute distance from a given point outside to the shape. ;  ; EGeoBoolType GetBooleanOperator () const override;  ; Int_t GetNpoints () override;  Returns number of vertices for the composite shape described by this intersection. ;  ; TClass * IsA () const override;  ; TGeoBoolNode * MakeClone () const override;  Make a clone of this. Pointers are preserved. ;  ; void Paint (Option_t *option) override;  Paint method. ;  ; Double_t Safety (const Double_t *point, Bool_t in=kTRUE) const override;  Compute safety distance for a union node;. ;  ; void SavePrimitive (std::ostream &out, Option_t *option="""") override;  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void Sizeof3D () const override;  Register 3D size of this shape. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TGeoBoolNode; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoIntersection.html:1616,safe,safe,1616,doc/master/classTGeoIntersection.html,https://root.cern,https://root.cern/doc/master/classTGeoIntersection.html,1,['safe'],['safe']
Safety," to fall within 0-360 range.; Parameters. [in]huehue in degrees in range 0-360. This allows to limit impact of color adjustment to affect only limited range of hues.; [in]radiusvalue in degrees to be used in order to calculate the range of affected hues. Range is determined by substracting and adding this value from/to affected_hue.; [in]Hvalue by which to change hues in affected range. ; [in]Svalue by which to change saturation of the pixels in affected hue range. ; [in]Vvalue by which to change Value(brightness) of pixels in affected hue range.; [in]x,yposition on infinite surface tiled with original image, of the left-top corner of the area to be used for new image.; [in]width,heightsize of the area of the original image to be used for new image. Default is current width, height of the image. . Reimplemented from TImage.; Definition at line 2945 of file TASImage.cxx. ◆ Idx(). Int_t TASImage::Idx ; (; Int_t ; idx). inlineprivate . Return a valid index in fImage tables to avoid seg-fault by accessing out of indices out of array's ranges. ; Definition at line 6838 of file TASImage.cxx. ◆ Image2Drawable(). void TASImage::Image2Drawable ; (; ASImage * ; im, . Drawable_t ; wid, . Int_t ; x, . Int_t ; y, . Int_t ; xsrc = 0, . Int_t ; ysrc = 0, . UInt_t ; wsrc = 0, . UInt_t ; hsrc = 0, . Option_t * ; opt = """" . ). static . Draw asimage on drawable. ; Definition at line 1228 of file TASImage.cxx. ◆ InitVisual(). Bool_t TASImage::InitVisual ; (; ). staticprotected . Static function to initialize the ASVisual. ; Definition at line 2201 of file TASImage.cxx. ◆ IsA(). TClass * TASImage::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 211 of file TASImage.h. ◆ IsEditable(). Bool_t TASImage::IsEditable ; (; ); const. inlineoverridevirtual . Reimplemented from TImage.; Definition at line 95 of file TASImage.h. ◆ IsGray(). Bool_t TASImage::IsGray ; (; ); const. inlineoverridevirtual . Reimplement",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTASImage.html:64529,avoid,avoid,64529,doc/master/classTASImage.html,https://root.cern,https://root.cern/doc/master/classTASImage.html,1,['avoid'],['avoid']
Safety," to gStyle->SetOptFit(111); Statistics box editing; The following example show how to remove and add a line in a statistics box. Picture; Source. TCanvas *statsEditing() {; // This example shows:; // - how to remove a stat element from the stat box; // - how to add a new one; //; // Author: Olivier Couet. // Create and plot a test histogram with stats; TCanvas *se = new TCanvas;; TH1F *h = new TH1F(""h"",""test"",100,-3,3);; h->FillRandom(""gaus"",3000);; gStyle->SetOptStat();; h->Draw();; se->Update();. // Retrieve the stat box; TPaveStats *ps = (TPaveStats*)se->GetPrimitive(""stats"");; ps->SetName(""mystats"");; TList *list = ps->GetListOfLines();. // Remove the RMS line; TText *tconst = ps->GetLineWith(""RMS"");; list->Remove(tconst);. // Add a new line in the stat box.; // Note that ""="" is a control character; TLatex *myt = new TLatex(0,0,""Test = 10"");; myt ->SetTextFont(42);; myt ->SetTextSize(0.04);; myt ->SetTextColor(kRed);; list->Add(myt);. // the following line is needed to avoid that the automatic redrawing of stats; h->SetStats(0);. se->Modified();; return se;; } . Function Members (Methods); public:. virtual~TPaveStats(); voidTObject::AbstractMethod(const char* method) const; virtual TBox*AddBox(Double_t, Double_t, Double_t, Double_t); virtual TLine*AddLine(Double_t, Double_t, Double_t, Double_t); virtual TText*TPaveText::AddText(const char* label); virtual TText*TPaveText::AddText(Double_t x1, Double_t y1, const char* label); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTPaveText::Clear(Option_t* option = """")MENU ; virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTPave::ConvertNDCtoPad(); virtual voidTPave::Copy(TObject& pave) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDeleteText(); Int_tTAttLine::DistancetoLine(Int_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TPaveStats.html:5875,avoid,avoid,5875,root/html602/TPaveStats.html,https://root.cern,https://root.cern/root/html602/TPaveStats.html,2,['avoid'],['avoid']
Safety," to the local shape coordinate system. This method provides additional information according the value of iact input parameter:. iact = 0computes only safe distance and fill it at the location given by SAFE;; iact = 1a proposed STEP is supplied. The safe distance is computed first. If this is bigger than STEP than the proposed step is approved and returned by the method since it does not cross the shape boundaries. Otherwise, the distance to exiting the shape is computed and returned;; iact = 2computes both safe distance and distance to exiting, ignoring the proposed step;; iact > 2computes only the distance to exiting, ignoring anything else. Double_t TGeoShape::DistFromOutside(Double_t *point[3],; Double_t *dir[3],Int_t iact,Double_t step,Double_t *safe);; This method computes the distance to entering a shape from a given point outside. It acts in the same way as the previous method.; Double_t TGeoShape::Safety(Double_t *point[3],Bool_t inside);; This computes the maximum shift of a point in any direction that does not change its inside/outsidestate (does not cross shape boundaries). The state of the point has to be properly supplied.; Double_t *TGeoShape::ComputeNormal(Double_t *point[3],; Double_t *dir[3],Double_t *norm[3]);; The method above computes the director cosines of normal to the crossed shape surface from a given point towards direction. This is filled into the norm array, supplied by the user. The normal vector is always chosen such that its dot product with the direction is positive defined.; 18.3.5 Creating Shapes; Shape objects embeds only the minimum set of parameters that are fully describing a valid physical shape. For instance, the half-length, the minimum and maximum radius represent a tube. Shapes are used together with media in order to create volumes, which in their turn are the main components of the geometrical tree. A specific shape can be created stand-alone:; TGeoBBox *box = new TGeoBBox(""s_box"",halfX,halfY,halfZ); // named; TGeoTube *",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:923430,Safe,Safety,923430,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['Safe'],['Safety']
Safety," to volume ""voldiv"" into ndiv equal volumes; called divname, from start position with the given step. Returns pointer; to created division cell volume. In case a wrong division axis is supplied,; returns pointer to volume to be divided. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. Int_t GetFittingBox(const TGeoBBox* parambox, TGeoMatrix* mat, Double_t& dx, Double_t& dy, Double_t& dz) const; Fills real parameters of a positioned box inside this. Returns 0 if successfull. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; in case shape has some negative parameters, these has to be computed; in order to fit the mother. void InspectShape() const; print shape parameters. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape, according; to option. The matching point on the shape is stored in spoint. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetDimensions(Double_t* param); Set dimensions starting from an array. void SetPoints(Double_t* points) const; Create PARA mesh points. void SetPoints(Float_t* points) const; create sphere mesh points. void Sizeof3D() const; fill size of this 3-D object. TGeoPara(); methods; constructors. Int_t GetByteCount() const; {return 48;}. Int_t GetNmeshVertices() const; {return 8;}. Double_t GetX() const; {return fX;}. Double_t GetY() const; {return fY;}. Double_t GetZ() const; {return fZ;}. Double_t GetAlpha() const; {return fAlpha;}. Double_t GetTheta() const; {return fTheta;}. Double_t GetPhi() const; {return fPhi;}. Double_t GetTxy() const; {return fTxy;}. Double_t GetTxz() const; {return fTxz;}. Double_t GetTyz() const; {return fTyz;}. Bool_t I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoPara.html:14239,Safe,Safety,14239,root/html528/TGeoPara.html,https://root.cern,https://root.cern/root/html528/TGeoPara.html,3,['Safe'],['Safety']
Safety," to write the results of TTree::Draw and TChain::Draw into an entry list. Example: tree->Draw("">>elist"", ""x<0 && y>0"", ""entrylist"");; TEntryList *elist = (TEntryList*)gDirectory->Get(""elist"");; gDirectory#define gDirectoryDefinition TDirectory.h:384; TEntryListA List of entry numbers in a TTree or TChain.Definition TEntryList.h:26; ; Example of Loop on TEntryList with a TChain; void loopChain() {; TFile *fe = TFile::Open(""myelist.root"");; TEntryList *myelist = (TEntryList*)fe->Get(""myelist"");; TChain *chain = new TChain(""ntuple"");; chain->Add(""hsimple.root"");; chain->Add(""hsimple2.root"");; Long64_t listEntries = myelist->GetN();; Long64_t chainEntries = chain->GetEntries();; Int_t treenum = 0;; chain->SetEntryList(myelist);; ; for (entry=start;entry < end;entry++) {; entryNumber = chain->GetEntryNumber(entry);; if (entryNumber < 0) break;; localEntry = chain->LoadTree(entryNumber);; if (localEntry < 0) break;; ....; then either call; branch->GetEntry(localEntry);; or; chain->GetEntry(entryNumber);; In the later case the LoadTree is then somewhat redundant.; ...; }; }; Long64_tlong long Long64_tDefinition RtypesCore.h:69; TChainA chain is a collection of files containing TTree objects.Definition TChain.h:33; TChain::GetEntryNumberLong64_t GetEntryNumber(Long64_t entry) const overrideReturn entry number corresponding to entry.Definition TChain.cxx:1021; TChain::SetEntryListvoid SetEntryList(TEntryList *elist, Option_t *opt="""") overrideSet the input entry list (processing the entries of the chain will then be limited to the entries in ...Definition TChain.cxx:2703; TChain::Addvirtual Int_t Add(TChain *chain)Add all files referenced by the passed chain to this chain.Definition TChain.cxx:219; TChain::LoadTreeLong64_t LoadTree(Long64_t entry) overrideFind the tree which contains entry, and set it as the current tree.Definition TChain.cxx:1324; TChain::GetEntriesLong64_t GetEntries() const overrideReturn the total number of entries in the chain.Definition TChain.cxx:978; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEntryList.html:2417,redund,redundant,2417,doc/master/classTEntryList.html,https://root.cern,https://root.cern/doc/master/classTEntryList.html,1,['redund'],['redundant']
Safety," total number of; crossings per volume (rays propagated from boundary to boundary until; geometry exit). Timing computed and results stored in a histo.; STAGE4 : shooting 1 mil. random rays inside EACH volume and calling; FindNextBoundary() + Safety() for each call. The timing is normalized by the; number of crossings computed at stage 2 and presented as percentage.; One can get a picture on which are the most ""burned"" volumes during; transportation from geometry point of view. Another plot of the timing per; volume vs. number of daughters is produced.; All histos are saved in the file statistics.root. Int_t PropagateInGeom(Double_t* , Double_t* ); Propagate from START along DIR from boundary to boundary until exiting; geometry. Fill array of hits. void Score(TGeoVolume* , Int_t , Double_t ); Score a hit for VOL. void SetNmeshPoints(Int_t npoints = 1000); Set number of points to be generated on the shape outline when checking for overlaps. Double_t TimingPerVolume(TGeoVolume* ); Compute timing per ""FindNextBoundary"" + ""Safety"" call. Volume must be; in the current path. void CheckGeometry(Int_t nrays, Double_t startx, Double_t starty, Double_t startz) const; Shoot nrays with random directions from starting point (startx, starty, startz); in the reference frame of this volume. Track each ray until exiting geometry, then; shoot backwards from exiting point and compare boundary crossing points. void CleanPoints(Double_t* points, Int_t& numPoints) const; Clean-up the mesh of pcon/pgon from useless points. TGeoOverlap * MakeCheckOverlap(const char* name, TGeoVolume* vol1, TGeoVolume* vol2, TGeoMatrix* mat1, TGeoMatrix* mat2, Bool_t isovlp, Double_t ovlp); Check if the 2 non-assembly volume candidates overlap/extrude. Returns overlap object. void CheckOverlapsBySampling(TGeoVolume* vol, Double_t ovlp = 0.1, Int_t npoints = 1000000) const; Check illegal overlaps for volume VOL within a limit OVLP by sampling npoints; inside the volume shape. Int_t NChecksPerVolume(TGeoVolume",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoChecker.html:12551,Safe,Safety,12551,root/html528/TGeoChecker.html,https://root.cern,https://root.cern/root/html528/TGeoChecker.html,4,['Safe'],['Safety']
Safety," total number of; crossings per volume (rays propagated from boundary to boundary until; geometry exit). Timing computed and results stored in a histo.; STAGE4 : shooting 1 mil. random rays inside EACH volume and calling; FindNextBoundary() + Safety() for each call. The timing is normalized by the; number of crossings computed at stage 2 and presented as percentage.; One can get a picture on which are the most ""burned"" volumes during; transportation from geometry point of view. Another plot of the timing per; volume vs. number of daughters is produced.; All histos are saved in the file statistics.root. Int_t PropagateInGeom(Double_t* , Double_t* ); Propagate from START along DIR from boundary to boundary until exiting; geometry. Fill array of hits. void Score(TGeoVolume* , Int_t , Double_t ); Score a hit for VOL. void SetNmeshPoints(Int_t npoints = 1000); Set number of points to be generated on the shape outline when checking for overlaps. Double_t TimingPerVolume(TGeoVolume* ); Compute timing per ""FindNextBoundary"" + ""Safety"" call. Volume must be; in the current path. void CheckGeometry(Int_t nrays, Double_t startx, Double_t starty, Double_t startz) const; Shoot nrays with random directions from starting point (startx, starty, startz); in the reference frame of this volume. Track each ray until exiting geometry, then; shoot backwards from exiting point and compare boundary crossing points. void CleanPoints(Double_t* points, Int_t& numPoints) const; Clean-up the mesh of pcon/pgon from useless points. TGeoOverlap * MakeCheckOverlap(const char* name, TGeoVolume* vol1, TGeoVolume* vol2, TGeoMatrix* mat1, TGeoMatrix* mat2, Bool_t isovlp, Double_t ovlp); Check if the 2 non-assembly volume candidates overlap/extrude. Returns overlap object. void CheckOverlapsBySampling(TGeoVolume* vol, Double_t ovlp = 0.10000000000000001, Int_t npoints = 1000000) const; Check illegal overlaps for volume VOL within a limit OVLP by sampling npoints; inside the volume shape. Int_t NChecksPerV",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoChecker.html:13528,Safe,Safety,13528,root/html602/TGeoChecker.html,https://root.cern,https://root.cern/root/html602/TGeoChecker.html,2,['Safe'],['Safety']
Safety," two histograms at the same time ;  vectorizedFit.C use it for fitting an histogram ;  ► fitsio;  FITS_tutorial1.C ;  FITS_tutorial2.C ;  FITS_tutorial3.C ;  FITS_tutorial4.C ;  FITS_tutorial5.C ;  FITS_tutorial6.C ;  FITS_tutorial7.C ;  ► foam;  foam_demo.C Demonstrate the TFoam class ;  foam_demopers.C This simple macro demonstrates persistency of FOAM object ;  foam_kanwa.C This program can be execute from the command line as folows: ;  ► geom;  assembly.CGeometry detector assembly example ;  building.CDrawing a building where Dept ;  cheongwadae.CDrawing the Cheongwadae building which is the Presidential Residence of the Republic of Korea, using ROOT geometry class ;  csgdemo.CCombinatorial Solid Geometry example ;  geo2stp.CExports a geometry in step format ;  geodemo.CGUI to draw the geometry shapes ;  geomAlice.CScript drawing a detector geometry (here ALICE) ;  geomAlice_itsv.CScript drawing a detector geometry (here ITSV from Alice) ;  geomAtlas.CScript drawing a detector geometry (here ATLAS) ;  geomBrahms.CScript drawing a detector geometry (here BRAHMS) ;  geomD0.CScript drawing a detector geometry (here D0) ;  geometry.CExample of the old geometry package (now obsolete) ;  iterplugin.cxx;  lego.CDrawing a figure, made of lego block, using ROOT geometry class ;  mp3player.CDrawing a mp3 type music player, using ROOT geometry class ;  na49.CThis file has been generated automatically via the root utility toroot from an interactive version of GEANT (see ROOT class TGeometry header for an example of use) This shows an example of the old geometry package (now obsolete) ;  na49geomfile.CBefore executing this macro, the file makegeometry.C must have been executed ;  na49view.CThis macro generates with 2 views of the NA49 detector using the old obsolete geometry package ;  parallel_world.CMisaligning geometry generate in many cases overlaps, due to the idealization of the design and the fact that in real life movements of the geometry volumes have constraints and",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/files.html:111217,detect,detector,111217,doc/v616/files.html,https://root.cern,https://root.cern/doc/v616/files.html,1,['detect'],['detector']
Safety," typename to SQL typename. ;  ; TBasket * CreateBasket (TBranch *br) override;  Create a TBasketSQL. ;  ; virtual void CreateBranch (const TString &branchName, const TString &typeName);  Create the column(s) in the database that correspond to the branch/. ;  ; void CreateBranches ();  determine leaf description string ;  ; bool CreateTable (const TString &table);  Create the database table corresponding to this TTree. ;  ; std::vector< Int_t > * GetColumnIndice (TBranch *branch);  Return a vector of columns index corresponding to the current SQL table and the branch given as argument Returns 0 if no columns indices is found Otherwise returns a pointer to a vector to be deleted by the caller. ;  ; void Init ();  Initialization routine. ;  ; void ResetQuery ();  Reset the internal query. ;  ;  Protected Member Functions inherited from TTree; virtual TBranch * BranchImpArr (const char *branchname, EDataType datatype, std::size_t N, void *addobj, Int_t bufsize, Int_t splitlevel);  ; virtual TBranch * BranchImpRef (const char *branchname, const char *classname, TClass *ptrClass, void *addobj, Int_t bufsize, Int_t splitlevel);  Same as TTree::Branch but automatic detection of the class name. ;  ; virtual TBranch * BranchImpRef (const char *branchname, TClass *ptrClass, EDataType datatype, void *addobj, Int_t bufsize, Int_t splitlevel);  Same as TTree::Branch but automatic detection of the class name. ;  ; virtual TBranch * BronchExec (const char *name, const char *classname, void *addobj, bool isptrptr, Int_t bufsize, Int_t splitlevel);  Helper function implementing TTree::Bronch and TTree::Branch(const char *name, T &obj);. ;  ; virtual Int_t CheckBranchAddressType (TBranch *branch, TClass *ptrClass, EDataType datatype, bool ptr);  Check whether or not the address described by the last 3 parameters matches the content of the branch. ;  ; Long64_t GetCacheAutoSize (bool withDefault=false);  Used for automatic sizing of the cache. ;  ; virtual TLeaf * GetLeafImpl (const ch",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeSQL.html:39761,detect,detection,39761,doc/master/classTTreeSQL.html,https://root.cern,https://root.cern/doc/master/classTTreeSQL.html,1,['detect'],['detection']
Safety," unconnected bins, each with a dedicated name. . bins organized in a multidimensional distribution, defined by a set of axes. The axes are defined by a number of bins N and by (N+1) bin borders. In addition to the N bins inside there may be an underflow and an overflow bin . Each bin has a ""global"" bin number, which can be found using the GetGlobalBinNumber() methods. The global bin number 0 is reserved and corresponds to the case where no bin is found in the TUnfoldBinning tree.; Use in the analysis; Booking histograms: . Define binning schemes on detector level and on truth level. This can be done using the XML language, use the class TUnfoldBinningXML to read the binning scheme. The TUnfoldBinning objects can be written to a root file, preferentially together with the corresponding histograms. . For Monte Carlo, book histograms for the response matrix (detector vs truth level) using the method CreateHistogramOfMigrations() . For data and background, book histograms using the ""detector level"" binning scheme and the method CreateHistogram() . (if required) for the data covarianve matrix, book a histogram using the ""detector level"" binning scheme and the method CreateErrorMatrixHistogram() . For truth histograms, book histograms using the ""truth level"" binning scheme and the method CreateHistogram() . The histograms which are booked have all analysis bins arranged on one axis (global bin number). TUnfoldBinning provides methods to locate the global bin number: . Use the method FindNode() to locate a group of bins (e.g. signal, control distribution, etc) by their name, then: . Use the method GetGlobalBinNumber() to locate a bin in a distribution, then: . Use the TH1::Fill() method and the bin number to fill the appropriate bin in one of the histograms booked above. . Unfolding: Specify the response matrix and the binning schemes when constructing a TUnfoldDensity object. Tell TUnfoldDensity about the data, bakcground, systematic error histograms using the correspondi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnfoldBinning.html:2168,detect,detector,2168,doc/master/classTUnfoldBinning.html,https://root.cern,https://root.cern/doc/master/classTUnfoldBinning.html,1,['detect'],['detector']
Safety," used for authentication */; 2260 ; 2261#if defined(USE_LUA) && defined(USE_WEBSOCKET); 2262 /* linked list of shared lua websockets */; 2263 struct mg_shared_lua_websocket_list *shared_lua_websockets;; 2264#endif; 2265 ; 2266 /* Linked list of domains */; 2267 struct mg_domain_context *next;; 2268};; 2269 ; 2270 ; 2271/* Stop flag can be ""volatile"" or require a lock.; 2272 * MSDN uses volatile for ""Interlocked"" operations, but also explicitly; 2273 * states a read operation for int is always atomic. */; 2274#if defined(STOP_FLAG_NEEDS_LOCK); 2275 ; 2276typedef ptrdiff_t volatile stop_flag_t;; 2277 ; 2278static int; 2279STOP_FLAG_IS_ZERO(stop_flag_t *f); 2280{; 2281 stop_flag_t sf = mg_atomic_add(f, 0);; 2282 return (sf == 0);; 2283}; 2284 ; 2285static int; 2286STOP_FLAG_IS_TWO(stop_flag_t *f); 2287{; 2288 stop_flag_t sf = mg_atomic_add(f, 0);; 2289 return (sf == 2);; 2290}; 2291 ; 2292static void; 2293STOP_FLAG_ASSIGN(stop_flag_t *f, stop_flag_t v); 2294{; 2295 stop_flag_t sf;; 2296 do {; 2297 sf = mg_atomic_compare_and_swap(f, *f, v);; 2298 } while (sf != v);; 2299}; 2300 ; 2301#else /* STOP_FLAG_NEEDS_LOCK */; 2302 ; 2303typedef int volatile stop_flag_t;; 2304#define STOP_FLAG_IS_ZERO(f) ((*(f)) == 0); 2305#define STOP_FLAG_IS_TWO(f) ((*(f)) == 2); 2306#define STOP_FLAG_ASSIGN(f, v) ((*(f)) = (v)); 2307 ; 2308#endif /* STOP_FLAG_NEEDS_LOCK */; 2309 ; 2310 ; 2311struct mg_context {; 2312 ; 2313 /* Part 1 - Physical context:; 2314 * This holds threads, ports, timeouts, ...; 2315 * set for the entire server, independent from the; 2316 * addressed hostname.; 2317 */; 2318 ; 2319 /* Connection related */; 2320 int context_type; /* See CONTEXT_* above */; 2321 ; 2322 struct socket *listening_sockets;; 2323 struct mg_pollfd *listening_socket_fds;; 2324 unsigned int num_listening_sockets;; 2325 ; 2326 struct mg_connection *worker_connections; /* The connection struct, pre-; 2327 * allocated for each worker */; 2328 ; 2329#if defined(USE_SERVER_STATS); 2330 volatile ptrdif",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:71412,timeout,timeouts,71412,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['timeout'],['timeouts']
Safety," used for authentication */; 2261 ; 2262#if defined(USE_LUA) && defined(USE_WEBSOCKET); 2263 /* linked list of shared lua websockets */; 2264 struct mg_shared_lua_websocket_list *shared_lua_websockets;; 2265#endif; 2266 ; 2267 /* Linked list of domains */; 2268 struct mg_domain_context *next;; 2269};; 2270 ; 2271 ; 2272/* Stop flag can be ""volatile"" or require a lock.; 2273 * MSDN uses volatile for ""Interlocked"" operations, but also explicitly; 2274 * states a read operation for int is always atomic. */; 2275#if defined(STOP_FLAG_NEEDS_LOCK); 2276 ; 2277typedef ptrdiff_t volatile stop_flag_t;; 2278 ; 2279static int; 2280STOP_FLAG_IS_ZERO(stop_flag_t *f); 2281{; 2282 stop_flag_t sf = mg_atomic_add(f, 0);; 2283 return (sf == 0);; 2284}; 2285 ; 2286static int; 2287STOP_FLAG_IS_TWO(stop_flag_t *f); 2288{; 2289 stop_flag_t sf = mg_atomic_add(f, 0);; 2290 return (sf == 2);; 2291}; 2292 ; 2293static void; 2294STOP_FLAG_ASSIGN(stop_flag_t *f, stop_flag_t v); 2295{; 2296 stop_flag_t sf;; 2297 do {; 2298 sf = mg_atomic_compare_and_swap(f, *f, v);; 2299 } while (sf != v);; 2300}; 2301 ; 2302#else /* STOP_FLAG_NEEDS_LOCK */; 2303 ; 2304typedef int volatile stop_flag_t;; 2305#define STOP_FLAG_IS_ZERO(f) ((*(f)) == 0); 2306#define STOP_FLAG_IS_TWO(f) ((*(f)) == 2); 2307#define STOP_FLAG_ASSIGN(f, v) ((*(f)) = (v)); 2308 ; 2309#endif /* STOP_FLAG_NEEDS_LOCK */; 2310 ; 2311 ; 2312struct mg_context {; 2313 ; 2314 /* Part 1 - Physical context:; 2315 * This holds threads, ports, timeouts, ...; 2316 * set for the entire server, independent from the; 2317 * addressed hostname.; 2318 */; 2319 ; 2320 /* Connection related */; 2321 int context_type; /* See CONTEXT_* above */; 2322 ; 2323 struct socket *listening_sockets;; 2324 struct mg_pollfd *listening_socket_fds;; 2325 unsigned int num_listening_sockets;; 2326 ; 2327 struct mg_connection *worker_connections; /* The connection struct, pre-; 2328 * allocated for each worker */; 2329 ; 2330#if defined(USE_SERVER_STATS); 2331 volatile ptrdif",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:71444,timeout,timeouts,71444,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['timeout'],['timeouts']
Safety," useful only at geometry creation stage. The pointer to a shape is in fact needed only when referring to a given volume and it is always accessible at that level. Several volumes may reference a single shape; therefore its deletion is not possible once volumes were defined based on it.; The navigation features related for instance to tracking particles are performed in the following way: Each shape implement its specific algorithms for all required tasks in its local reference system. Note that the manager class handles global queries related to geometry. However, shape-related queries might be sometimes useful:; Bool_t TGeoShape::Contains(Double_t *point[3]);; The method above returns kTRUE if the point *point is actually inside the shape. The point has to be defined in the local shape reference. For instance, for a box having DX,DY and DZhalf-lengths a point will be considered inside if:; -DX <= point[0] <= DX; -DY <= point[1] <= DY; -DZ <= point[2] <= DZ; Double_t TGeoShape::DistFromInside(Double_t *point[3],; Double_t *dir[3], Int_t iact,Double_t step,Double_t *safe);; The method computes the distance to exiting a shape from a given point inside, along a given direction. This direction is given by its director cosines with respect to the local shape coordinate system. This method provides additional information according the value of iact input parameter:. iact = 0computes only safe distance and fill it at the location given by SAFE;; iact = 1a proposed STEP is supplied. The safe distance is computed first. If this is bigger than STEP than the proposed step is approved and returned by the method since it does not cross the shape boundaries. Otherwise, the distance to exiting the shape is computed and returned;; iact = 2computes both safe distance and distance to exiting, ignoring the proposed step;; iact > 2computes only the distance to exiting, ignoring anything else. Double_t TGeoShape::DistFromOutside(Double_t *point[3],; Double_t *dir[3],Int_t iact,Double_t s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:922338,safe,safe,922338,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['safe'],['safe']
Safety," variables "" << projectedVars; 1954 << (o.projectionRangeName?Form("" in range %s"",o.projectionRangeName):"""") << std::endl;; 1955 }; 1956 if (projDataNeededVars && !projDataNeededVars->empty()) {; 1957 coutI(Plotting) << ""RooAbsReal::plotOn("" << GetName() << "") plot on "" << plotVar->GetName(); 1958 << "" averages using data variables "" << *projDataNeededVars << std::endl ;; 1959 }; 1960 ; 1961 // Create projection integral; 1962 RooArgSet* projectionCompList = nullptr ;; 1963 ; 1964 RooArgSet deps;; 1965 getObservables(frame->getNormVars(), deps) ;; 1966 deps.remove(projectedVars,true,true) ;; 1967 if (projDataNeededVars) {; 1968 deps.remove(*projDataNeededVars,true,true) ;; 1969 }; 1970 deps.remove(*plotVar,true,true) ;; 1971 deps.add(*plotVar) ;; 1972 ; 1973 // Now that we have the final set of dependents, call checkObservables(); 1974 ; 1975 // WVE take out conditional observables; 1976 if (checkObservables(&deps)) {; 1977 coutE(Plotting) << ""RooAbsReal::plotOn("" << GetName() << "") error in checkObservables, abort"" << std::endl ;; 1978 if (projDataNeededVars) delete projDataNeededVars ;; 1979 return frame ;; 1980 }; 1981 ; 1982 RooAbsReal *projection = const_cast<RooAbsReal*>(createPlotProjection(deps, &projectedVars, projectionCompList, o.projectionRangeName));; 1983 cxcoutD(Plotting) << ""RooAbsReal::plotOn("" << GetName() << "") plot projection object is "" << projection->GetName() << std::endl ;; 1984 if (dologD(Plotting)) {; 1985 projection->printStream(ccoutD(Plotting),0,kVerbose) ;; 1986 }; 1987 ; 1988 // Always fix RooAddPdf normalizations; 1989 RooArgSet fullNormSet(deps) ;; 1990 fullNormSet.add(projectedVars) ;; 1991 if (projDataNeededVars && !projDataNeededVars->empty()) {; 1992 fullNormSet.add(*projDataNeededVars) ;; 1993 }; 1994 ; 1995 std::unique_ptr<RooArgSet> projectionComponents(projection->getComponents());; 1996 for(auto * pdf : dynamic_range_cast<RooAbsPdf*>(*projectionComponents)) {; 1997 if (pdf) {; 1998 pdf->selectNormalization(&fullNormSet) ;; 19",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8cxx_source.html:87296,abort,abort,87296,doc/master/RooAbsReal_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html,1,['abort'],['abort']
Safety," variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsPdf.html:2074,safe,safe,2074,root/html526/RooAbsPdf.html,https://root.cern,https://root.cern/root/html526/RooAbsPdf.html,12,['safe'],['safe']
Safety," via cache was successful,; 2 in case read via cache failed. void ReadFree(); Read the FREE linked list.; Every file has a linked list (fFree) of free segments.; This linked list has been written on the file via WriteFree; as a single data record. TProcessID * ReadProcessID(UShort_t pidf); The TProcessID with number pidf is read from this file.; If the object is not already entered in the gROOT list, it is added. Int_t Recover(); Attempt to recover file if not correctly closed.; The function returns the number of keys that have been recovered.; If no keys can be recovered, the file will be declared Zombie by; the calling function. This function is automatically called when; opening a file. If the file is open in read only mode, the file is not modified.; If open in update mode and the function finds something to recover,; a new directory header is written to the file. When opening the file gain; no message from Recover will be reported.; If keys have been recovered, the file is usable and you can safely; read the corresponding objects.; If the file is not usable (a zombie), you can test for this case; with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {file is unusable); If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; You can test if the file has been recovered with; if (f.TestBit(TFile::kRecovered)) {.. the file has been recovered}. When writing TTrees to a file, it is important to save the Tree header; at regular intervals (see TTree::AutoSave). If a file containing a Tree; is recovered, the last Tree header written to the file will be used.; In this case all the entries in all the branches written before writing; the header are valid entries. One can disable the automatic recovery procedure by setting; TFile.Recover 0; in the system.rootrc file. Int_t ReOpen(Option_t* mode); Reopen a file with a different access mode, like from READ to; UPDATE or from NEW, CREATE, RECREATE, UPDATE to READ. Thus the; mode argument ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFile.html:35039,recover,recovered,35039,root/html528/TFile.html,https://root.cern,https://root.cern/root/html528/TFile.html,12,"['recover', 'safe']","['recovered', 'safely']"
Safety," viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » PHYSICS; » TRobustEstimator. class TRobustEstimator: public TObject. TRobustEstimator. Minimum Covariance Determinant Estimator - a Fast Algorithm; invented by Peter J.Rousseeuw and Katrien Van Dreissen; ""A Fast Algorithm for the Minimum covariance Determinant Estimator""; Technometrics, August 1999, Vol.41, NO.3. What are robust estimators?; ""An important property of an estimator is its robustness. An estimator; is called robust if it is insensitive to measurements that deviate; from the expected behaviour. There are 2 ways to treat such deviating; measurements: one may either try to recongize them and then remove; them from the data sample; or one may leave them in the sample, taking; care that they do not influence the estimate unduly. In both cases robust; estimators are needed...Robust procedures compensate for systematic errors; as much as possible, and indicate any situation in which a danger of not being; able to operate reliably is detected.""; R.Fruhwirth, M.Regler, R.K.Bock, H.Grote, D.Notz; ""Data Analysis Techniques for High-Energy Physics"", 2nd edition. What does this algorithm do?; It computes a highly robust estimator of multivariate location and scatter.; Then, it takes those estimates to compute robust distances of all the; data vectors. Those with large robust distances are considered outliers.; Robust distances can then be plotted for better visualization of the data. How does this algorithm do it?; The MCD objective is to find h observations(out of n) whose classical; covariance matrix has the lowest determinant. The MCD estimator of location; is then the average of those h points and the MCD estimate of scatter; is their covariance matrix. The minimum(and default) h = (n+nvariables+1)/2; so the algorithm is effective when less than (n+nvar+1)/2 variables are outliers.; The algorithm also allows for exact fit situations - that is",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TRobustEstimator.html:1197,detect,detected,1197,root/html528/TRobustEstimator.html,https://root.cern,https://root.cern/root/html528/TRobustEstimator.html,6,['detect'],['detected']
Safety," virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoTorus&operator=(const TGeoTorus&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetPoin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoTorus.html:8433,safe,safe,8433,root/html602/TGeoTorus.html,https://root.cern,https://root.cern/root/html602/TGeoTorus.html,2,['safe'],['safe']
Safety," virtual TBuffer3D*TGeoBBox::MakeBuffer3D() const; voidTObject::MayNotUse(const char* method) const; static voidTGeoShape::NormalPhi(Double_t* point, Double_t* dir, Double_t* norm, Double_t c1, Double_t s1, Double_t c2, Double_t s2); virtual Bool_tTObject::Notify(); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tTGeoTrap::Safety(Double_t* point, Bool_t in = kTRUE) const; static Double_tTGeoShape::SafetyPhi(Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); Double_tTGeoArb8::SafetyToFace(Double_t* point, Int_t iseg, Bool_t in) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoArb8::SetDz(Double_t dz); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidTGeoArb8::SetPl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoGtra.html:9383,Safe,Safety,9383,root/html528/TGeoGtra.html,https://root.cern,https://root.cern/root/html528/TGeoGtra.html,1,['Safe'],['Safety']
Safety," virtual voidTFile::SetCacheWrite(TFileCacheWrite* cache); virtual voidTFile::SetCompressionAlgorithm(Int_t algorithm = 0); virtual voidTFile::SetCompressionLevel(Int_t level = 1); virtual voidTFile::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetEND(Long64_t); static voidTFile::SetFileBytesRead(Long64_t bytes = 0); static voidTFile::SetFileBytesWritten(Long64_t bytes = 0); static voidTFile::SetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTFile::SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); static Bool_tTFile::SetOnlyStaged(Bool_t onlystaged); static UInt_tTFile::SetOpenTimeout(UInt_t timeout); virtual voidTFile::SetOption(Option_t* option = "">""); static voidTFile::SetReadaheadSize(Int_t bufsize = 256000); virtual voidTFile::SetReadCalls(Int_t readcalls = 0); static voidTFile::SetReadStreamerInfo(Bool_t readinfo = kTRUE); virtual voidTDirectoryFile::SetSeekDir(Long64_t v); voidSetTablesType(const char* table_type); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTDirectoryFile::SetTRefAction(TObject* ref, TObject* parent); virtual voidTObject::SetUniqueID(UInt_t uid); voidSetUseIndexes(Int_t use_type = kIndexesBasic); voidSetUseSuffixes(Bool_t on = kTRUE); voidSetUseTransactions(Int_t mode = kTransactionsAuto); virtual voidTDirectoryFile::SetWritable(Bool_t writable = kTRUE); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidTFile::ShowStreamerInfo(); static Bool_tTFile::ShrinkCacheFileDir(Long64_t shrinkSize, Long_t cleanupInteval = 0); virtual Int_tSizeof() const; voidSkipArrayLimit(); voidStartLogFile(const char* fname)MENU ; B",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSQLFile.html:19693,timeout,timeout,19693,root/html602/TSQLFile.html,https://root.cern,https://root.cern/root/html602/TSQLFile.html,2,['timeout'],['timeout']
Safety," virtual voidTFile::SetCacheWrite(TFileCacheWrite* cache); virtual voidTFile::SetCompressionAlgorithm(Int_t algorithm = 0); virtual voidTFile::SetCompressionLevel(Int_t level = 1); virtual voidTFile::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetEND(Long64_t); static voidTFile::SetFileBytesRead(Long64_t bytes = 0); static voidTFile::SetFileBytesWritten(Long64_t bytes = 0); static voidTFile::SetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTFile::SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); static Bool_tTFile::SetOnlyStaged(Bool_t onlystaged); static UInt_tTFile::SetOpenTimeout(UInt_t timeout); virtual voidTFile::SetOption(Option_t* option = "">""); static voidTFile::SetReadaheadSize(Int_t bufsize = 256000); virtual voidTFile::SetReadCalls(Int_t readcalls = 0); static voidTFile::SetReadStreamerInfo(Bool_t readinfo = kTRUE); virtual voidTDirectoryFile::SetSeekDir(Long64_t v); voidSetTablesType(const char* table_type); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTDirectoryFile::SetTRefAction(TObject* ref, TObject* parent); virtual voidTObject::SetUniqueID(UInt_t uid); voidSetUseIndexes(Int_t use_type = kIndexesBasic); voidSetUseSuffixes(Bool_t on = kTRUE); voidSetUseTransactions(Int_t mode = kTransactionsAuto); virtual voidTDirectoryFile::SetWritable(Bool_t writable = kTRUE); virtual voidShowMembers(TMemberInspector& insp); virtual voidTFile::ShowStreamerInfo(); static Bool_tTFile::ShrinkCacheFileDir(Long64_t shrinkSize, Long_t cleanupInteval = 0); virtual Int_tSizeof() const; voidSkipArrayLimit(); voidStartLogFile(const char* fname)MENU ; Bool_tS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TSQLFile.html:19410,timeout,timeout,19410,root/html530/TSQLFile.html,https://root.cern,https://root.cern/root/html530/TSQLFile.html,2,['timeout'],['timeout']
Safety," virtual voidTFile::SetCacheWrite(TFileCacheWrite* cache); virtual voidTFile::SetCompressionAlgorithm(Int_t algorithm = 0); virtual voidTFile::SetCompressionLevel(Int_t level = 1); virtual voidTFile::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetEND(Long64_t); static voidTFile::SetFileBytesRead(Long64_t bytes = 0); static voidTFile::SetFileBytesWritten(Long64_t bytes = 0); static voidTFile::SetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTFile::SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); static Bool_tTFile::SetOnlyStaged(Bool_t onlystaged); static UInt_tTFile::SetOpenTimeout(UInt_t timeout); virtual voidTFile::SetOption(Option_t* option = "">""); static voidTFile::SetReadaheadSize(Int_t bufsize = 256000); virtual voidTFile::SetReadCalls(Int_t readcalls = 0); static voidTFile::SetReadStreamerInfo(Bool_t readinfo = kTRUE); virtual voidTDirectoryFile::SetSeekDir(Long64_t v); voidSetTablesType(const char* table_type); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTDirectoryFile::SetTRefAction(TObject* ref, TObject* parent); virtual voidTObject::SetUniqueID(UInt_t uid); voidSetUseIndexes(Int_t use_type = kIndexesBasic); voidSetUseSuffixes(Bool_t on = kTRUE); voidSetUseTransactions(Int_t mode = kTransactionsAuto); virtual voidTDirectoryFile::SetWritable(Bool_t writable = kTRUE); virtual voidShowMembers(TMemberInspector&); virtual voidTFile::ShowStreamerInfo(); static Bool_tTFile::ShrinkCacheFileDir(Long64_t shrinkSize, Long_t cleanupInteval = 0); virtual Int_tSizeof() const; voidSkipArrayLimit(); voidStartLogFile(const char* fname)MENU ; Bool_tStartT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TSQLFile.html:19839,timeout,timeout,19839,root/html534/TSQLFile.html,https://root.cern,https://root.cern/root/html534/TSQLFile.html,1,['timeout'],['timeout']
Safety," virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistanceToPrimitive(Int_t px, Int_t py); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TGeoBoolNode::EGeoBoolTypeGetBooleanOperator() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TGeoMatrix*GetLeftMatrix() const; TGeoShape*GetLeftShape() const; virtua",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoBoolNode.html:2451,safe,safe,2451,root/html528/TGeoBoolNode.html,https://root.cern,https://root.cern/root/html528/TGeoBoolNode.html,2,['safe'],['safe']
Safety," virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistanceToPrimitive(Int_t px, Int_t py); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TGeoBoolNode::EGeoBoolTypeGetBooleanOperator() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TGeoMatrix*TGeoBoolNode::GetLeftMatrix() const; TGeoShape*TGeoBoolNode::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoIntersection.html:2514,safe,safe,2514,root/html528/TGeoIntersection.html,https://root.cern,https://root.cern/root/html528/TGeoIntersection.html,6,['safe'],['safe']
Safety," virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . #include <TSVDUnfold.h>. Inheritance diagram for TSVDUnfold:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TSVDUnfold() [1/3]. TSVDUnfold::TSVDUnfold ; (; const TH1D * ; bdat, . const TH1D * ; bini, . const TH1D * ; xini, . const TH2D * ; Adet . ). Alternative constructor User provides data and MC test spectra, as well as detector response matrix, diagonal covariance matrix of measured spectrum built from the uncertainties on measured spectrum. ; Definition at line 75 of file TSVDUnfold.cxx. ◆ TSVDUnfold() [2/3]. TSVDUnfold::TSVDUnfold ; (; const TH1D * ; bdat, . TH2D * ; Bcov, . const TH1D * ; bini, . const TH1D * ; xini, . const TH2D * ; Adet . ). Default constructor Initialisation of TSVDUnfold User provides data and MC test spectra, as well as detector response matrix and the covariance matrix of the measured distribution. ; Definition at line 127 of file TSVDUnfold.cxx. ◆ TSVDUnfold() [3/3]. TSVDUnfold::TSVDUnfold ; (; const TSVDUnfold & ; other). Copy constructor. ; Definition at line 171 of file TSVDUnfold.cxx. ◆ ~TSVDUnfold(). TSVDUnfold::~TSVDUnfold ; (; ). override . Destructor. ; Definition at line 196 of file TSVDUnfold.cxx. Member Function Documentation. ◆ Class(). static TClass * TSVDUnfold::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TSVDUnfold::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TSVDUnfold::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 156 of file TSVDUnfold.h. ◆ CompProd(). TVectorD TSVDUnfold::CompProd ; (; const TVectorD & ; vec1, . const TVectorD & ; vec2 . ). staticprivate . Multiply entries of two vectors. ; Definition at line 702",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSVDUnfold.html:18323,detect,detector,18323,doc/master/classTSVDUnfold.html,https://root.cern,https://root.cern/doc/master/classTSVDUnfold.html,1,['detect'],['detector']
Safety," virtual~RooProofDriverSelector(); virtual voidTSelector::Abort(const char* why, TSelector::EAbort what = kAbortProcess); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTSelector::Begin(TTree*); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TSelector::EAbortTSelector::GetAbort() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tGetEntry(Long64_t entry, Int_t getall = 0",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooProofDriverSelector.html:431,Abort,Abort,431,root/html602/RooProofDriverSelector.html,https://root.cern,https://root.cern/root/html602/RooProofDriverSelector.html,2,['Abort'],['Abort']
Safety," virtual~TEvePointSelector(); virtual voidTSelector::Abort(const char* why, TSelector::EAbort what = kAbortProcess); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTSelectorDraw::Begin(TTree* tree); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEvePointSelector.html:684,Abort,Abort,684,root/html602/TEvePointSelector.html,https://root.cern,https://root.cern/root/html602/TEvePointSelector.html,2,['Abort'],['Abort']
Safety," virtual~TEveSelectorToEventList(); virtual voidTSelector::Abort(const char* why, TSelector::EAbort what = kAbortProcess); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTSelectorDraw::Begin(TTree* tree); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TSelector::EAbortTSelector::GetAbort() const; virtual Int_tTSelector",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEveSelectorToEventList.html:540,Abort,Abort,540,root/html602/TEveSelectorToEventList.html,https://root.cern,https://root.cern/root/html602/TEveSelectorToEventList.html,2,['Abort'],['Abort']
Safety," virtual~TGeoBoolNode(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoBoolNode.html:2325,safe,safe,2325,root/html528/TGeoBoolNode.html,https://root.cern,https://root.cern/root/html528/TGeoBoolNode.html,2,['safe'],['safe']
Safety," virtual~TGeoBoolNode(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidClearThreadData() const; virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Dou",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoBoolNode.html:2354,safe,safe,2354,root/html532/TGeoBoolNode.html,https://root.cern,https://root.cern/root/html532/TGeoBoolNode.html,1,['safe'],['safe']
Safety," virtual~TGeoIntersection(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidTGeoBoolNode::ClearThreadData() const; virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistanceToPrimitive(Int_t px, Int_t py); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TGeoBoolNode::EGeoBoolTypeGetBooleanOperator() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoIntersection.html:2431,safe,safe,2431,root/html532/TGeoIntersection.html,https://root.cern,https://root.cern/root/html532/TGeoIntersection.html,1,['safe'],['safe']
Safety," virtual~TNetXNGSystem(); virtual voidTSystem::Abort(int code = 0); voidTObject::AbstractMethod(const char* method) const; virtual intTSystem::AcceptConnection(int sock); virtual Bool_tTSystem::AccessPathName(const char* path, EAccessMode mode = kFileExists); virtual voidTSystem::AddDynamicPath(const char* pathname); virtual voidTSystem::AddFileHandler(TFileHandler* fh); virtual voidTSystem::AddIncludePath(const char* includePath); virtual voidTSystem::AddLinkedLibs(const char* linkedLib); virtual voidTSystem::AddSignalHandler(TSignalHandler* sh); virtual voidTSystem::AddStdExceptionHandler(TStdExceptionHandler* eh); virtual voidTSystem::AddTimer(TTimer* t); virtual intTSystem::AnnounceTcpService(int port, Bool_t reuse, int backlog, int tcpwindowsize = -1); virtual intTSystem::AnnounceUdpService(int port, int backlog); virtual intTSystem::AnnounceUnixService(int port, int backlog); virtual intTSystem::AnnounceUnixService(const char* sockpath, int backlog); virtual voidTObject::AppendPad(Option_t* option = """"); virtual const char*TSystem::BaseName(const char* pathname); voidTSystem::Beep(Int_t freq = -1, Int_t duration = -1, Bool_t setDefault = kFALSE); virtual voidTObject::Browse(TBrowser* b); Bool_tTSystem::cd(const char* path); virtual Bool_tTSystem::ChangeDirectory(const char* path); virtual intTSystem::Chmod(const char* file, UInt_t mode); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTSystem::CleanCompiledMacros(); virtual voidTNamed::Clear(Option_t* option = """"); ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TNetXNGSystem.html:518,Abort,Abort,518,root/html602/TNetXNGSystem.html,https://root.cern,https://root.cern/root/html602/TNetXNGSystem.html,2,['Abort'],['Abort']
Safety," virtual~TProofDraw(); virtual voidTSelector::Abort(const char* why, TSelector::EAbort what = kAbortProcess); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBegin(TTree*); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TSelector::EAbortTSelector::GetAbort() const; virtual Option_t*TOb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofDraw.html:562,Abort,Abort,562,root/html528/TProofDraw.html,https://root.cern,https://root.cern/root/html528/TProofDraw.html,6,['Abort'],['Abort']
Safety," virtual~TProofDrawEntryList(); virtual voidTSelector::Abort(const char* why, TSelector::EAbort what = kAbortProcess); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTProofDraw::Begin(TTree*); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TSelector::EAbortTSelector::GetAbort() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTSe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofDrawEntryList.html:468,Abort,Abort,468,root/html602/TProofDrawEntryList.html,https://root.cern,https://root.cern/root/html602/TProofDrawEntryList.html,2,['Abort'],['Abort']
Safety," virtual~TProofDrawEventList(); virtual voidTSelector::Abort(const char* why, TSelector::EAbort what = kAbortProcess); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTProofDraw::Begin(TTree*); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TSelector::EAbortTSelector::GetAbort() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTSe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofDrawEventList.html:468,Abort,Abort,468,root/html602/TProofDrawEventList.html,https://root.cern,https://root.cern/root/html602/TProofDrawEventList.html,2,['Abort'],['Abort']
Safety," virtual~TProofDrawGraph(); virtual voidTSelector::Abort(const char* why, TSelector::EAbort what = kAbortProcess); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTProofDraw::Begin(TTree*); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TSelector::EAbortTSelector::GetAbort() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTSelector::GetEntry",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofDrawGraph.html:452,Abort,Abort,452,root/html602/TProofDrawGraph.html,https://root.cern,https://root.cern/root/html602/TProofDrawGraph.html,2,['Abort'],['Abort']
Safety," virtual~TProofDrawHist(); virtual voidTSelector::Abort(const char* why, TSelector::EAbort what = kAbortProcess); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBegin(TTree* t); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TSelector::EAbortTSelector::GetAbort() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTSelector::GetEntry(Long64_t, Int",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofDrawHist.html:448,Abort,Abort,448,root/html602/TProofDrawHist.html,https://root.cern,https://root.cern/root/html602/TProofDrawHist.html,2,['Abort'],['Abort']
Safety," virtual~TProofDrawListOfGraphs(); virtual voidTSelector::Abort(const char* why, TSelector::EAbort what = kAbortProcess); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTProofDraw::Begin(TTree*); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TSelector::EAbortTSelector::GetAbort() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofDrawListOfGraphs.html:480,Abort,Abort,480,root/html602/TProofDrawListOfGraphs.html,https://root.cern,https://root.cern/root/html602/TProofDrawListOfGraphs.html,2,['Abort'],['Abort']
Safety," virtual~TProofDrawListOfPolyMarkers3D(); virtual voidTSelector::Abort(const char* why, TSelector::EAbort what = kAbortProcess); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTProofDraw::Begin(TTree*); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TSelector::EAbortTSelector::GetAbort() const; virtual Option_t*TObject::GetDrawOption() const; static Long_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofDrawListOfPolyMarkers3D.html:508,Abort,Abort,508,root/html602/TProofDrawListOfPolyMarkers3D.html,https://root.cern,https://root.cern/root/html602/TProofDrawListOfPolyMarkers3D.html,2,['Abort'],['Abort']
Safety," virtual~TProofDrawPolyMarker3D(); virtual voidTSelector::Abort(const char* why, TSelector::EAbort what = kAbortProcess); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTProofDraw::Begin(TTree*); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TSelector::EAbortTSelector::GetAbort() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofDrawPolyMarker3D.html:480,Abort,Abort,480,root/html602/TProofDrawPolyMarker3D.html,https://root.cern,https://root.cern/root/html602/TProofDrawPolyMarker3D.html,2,['Abort'],['Abort']
Safety," virtual~TProofDrawProfile(); virtual voidTSelector::Abort(const char* why, TSelector::EAbort what = kAbortProcess); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBegin(TTree* t); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TSelector::EAbortTSelector::GetAbort() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTSelector::GetEntry(L",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofDrawProfile.html:460,Abort,Abort,460,root/html602/TProofDrawProfile.html,https://root.cern,https://root.cern/root/html602/TProofDrawProfile.html,2,['Abort'],['Abort']
Safety," virtual~TProofDrawProfile2D(); virtual voidTSelector::Abort(const char* why, TSelector::EAbort what = kAbortProcess); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBegin(TTree* t); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TSelector::EAbortTSelector::GetAbort() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTSelector::Ge",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofDrawProfile2D.html:468,Abort,Abort,468,root/html602/TProofDrawProfile2D.html,https://root.cern,https://root.cern/root/html602/TProofDrawProfile2D.html,2,['Abort'],['Abort']
Safety," virtual~TSelVerifyDataSet(); virtual voidTSelector::Abort(const char* why, TSelector::EAbort what = kAbortProcess); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBegin(TTree*); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TSelector::EAbortTSelector::GetAbort() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSelVerifyDataSet.html:499,Abort,Abort,499,root/html602/TSelVerifyDataSet.html,https://root.cern,https://root.cern/root/html602/TSelVerifyDataSet.html,2,['Abort'],['Abort']
Safety," virtual~TSelectorDraw(); virtual voidTSelector::Abort(const char* why, TSelector::EAbort what = kAbortProcess); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBegin(TTree* tree); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TSelector::EAbortTSelector::GetAbort() const; virtual Int_tGetAction() const; virtual Bool_tGetCleanElist() const; virtual Int_tGetDimension() const; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSelectorDraw.html:473,Abort,Abort,473,root/html602/TSelectorDraw.html,https://root.cern,https://root.cern/root/html602/TSelectorDraw.html,2,['Abort'],['Abort']
Safety," virtual~TSelectorEntries(); virtual voidTSelector::Abort(const char* why, TSelector::EAbort what = kAbortProcess); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBegin(TTree* tree); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TSelector::EAbortTSelector::GetAbort() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tGetEntry(Long64_t entry, Int_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSelectorEntries.html:447,Abort,Abort,447,root/html602/TSelectorEntries.html,https://root.cern,https://root.cern/root/html602/TSelectorEntries.html,1,['Abort'],['Abort']
Safety," virtual~TSelectorEntries(); virtual voidTSelector::Abort(const char* why, TSelector::EAbort what = kAbortProcess); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBegin(TTree* tree); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TSelector::EAbortTSelector::GetAbort() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tGetEntry(Long64_t entry, Int_t getall = 0); virtual con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TSelectorEntries.html:423,Abort,Abort,423,root/html604/TSelectorEntries.html,https://root.cern,https://root.cern/root/html604/TSelectorEntries.html,1,['Abort'],['Abort']
Safety," virtual~TWebSystem(); virtual voidTSystem::Abort(int code = 0); voidTObject::AbstractMethod(const char* method) const; virtual intTSystem::AcceptConnection(int sock); virtual Bool_tAccessPathName(const char* path, EAccessMode mode); virtual voidTSystem::AddDynamicPath(const char* pathname); virtual voidTSystem::AddFileHandler(TFileHandler* fh); virtual voidTSystem::AddIncludePath(const char* includePath); virtual voidTSystem::AddLinkedLibs(const char* linkedLib); virtual voidTSystem::AddSignalHandler(TSignalHandler* sh); virtual voidTSystem::AddStdExceptionHandler(TStdExceptionHandler* eh); virtual voidTSystem::AddTimer(TTimer* t); virtual intTSystem::AnnounceTcpService(int port, Bool_t reuse, int backlog, int tcpwindowsize = -1); virtual intTSystem::AnnounceUdpService(int port, int backlog); virtual intTSystem::AnnounceUnixService(int port, int backlog); virtual intTSystem::AnnounceUnixService(const char* sockpath, int backlog); virtual voidTObject::AppendPad(Option_t* option = """"); virtual const char*TSystem::BaseName(const char* pathname); voidTSystem::Beep(Int_t freq = -1, Int_t duration = -1, Bool_t setDefault = kFALSE); virtual voidTObject::Browse(TBrowser* b); Bool_tTSystem::cd(const char* path); virtual Bool_tTSystem::ChangeDirectory(const char* path); virtual intTSystem::Chmod(const char* file, UInt_t mode); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTSystem::CleanCompiledMacros(); virtual voidTNamed::Clear(Option_t* option = """"); virtual",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TWebSystem.html:534,Abort,Abort,534,root/html602/TWebSystem.html,https://root.cern,https://root.cern/root/html602/TWebSystem.html,1,['Abort'],['Abort']
Safety," virtual~TWebSystem(); virtual voidTSystem::Abort(int code = 0); voidTObject::AbstractMethod(const char* method) const; virtual intTSystem::AcceptConnection(int sock); virtual Bool_tAccessPathName(const char* path, EAccessMode mode); virtual voidTSystem::AddDynamicPath(const char* pathname); virtual voidTSystem::AddFileHandler(TFileHandler* fh); virtual voidTSystem::AddIncludePath(const char* includePath); virtual voidTSystem::AddLinkedLibs(const char* linkedLib); virtual voidTSystem::AddSignalHandler(TSignalHandler* sh); virtual voidTSystem::AddStdExceptionHandler(TStdExceptionHandler* eh); virtual voidTSystem::AddTimer(TTimer* t); virtual intTSystem::AnnounceTcpService(int port, Bool_t reuse, int backlog, int tcpwindowsize = -1); virtual intTSystem::AnnounceUdpService(int port, int backlog); virtual intTSystem::AnnounceUnixService(int port, int backlog); virtual intTSystem::AnnounceUnixService(const char* sockpath, int backlog); virtual voidTObject::AppendPad(Option_t* option = """"); virtual const char*TSystem::BaseName(const char* pathname); voidTSystem::Beep(Int_t freq = -1, Int_t duration = -1, Bool_t setDefault = kFALSE); virtual voidTObject::Browse(TBrowser* b); Bool_tTSystem::cd(const char* path); virtual Bool_tTSystem::ChangeDirectory(const char* path); virtual intTSystem::Chmod(const char* file, UInt_t mode); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTSystem::CleanCompiledMacros(); virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TWebSystem.html:510,Abort,Abort,510,root/html604/TWebSystem.html,https://root.cern,https://root.cern/root/html604/TWebSystem.html,1,['Abort'],['Abort']
Safety," virtual~TXNetSystem(); virtual voidTSystem::Abort(int code = 0); voidTObject::AbstractMethod(const char* method) const; virtual intTSystem::AcceptConnection(int sock); virtual Bool_tAccessPathName(const char* path, EAccessMode mode); virtual voidTSystem::AddDynamicPath(const char* pathname); virtual voidTSystem::AddFileHandler(TFileHandler* fh); virtual voidTSystem::AddIncludePath(const char* includePath); virtual voidTSystem::AddLinkedLibs(const char* linkedLib); virtual voidTSystem::AddSignalHandler(TSignalHandler* sh); virtual voidTSystem::AddStdExceptionHandler(TStdExceptionHandler* eh); virtual voidTSystem::AddTimer(TTimer* t); virtual intTSystem::AnnounceTcpService(int port, Bool_t reuse, int backlog, int tcpwindowsize = -1); virtual intTSystem::AnnounceUdpService(int port, int backlog); virtual intTSystem::AnnounceUnixService(int port, int backlog); virtual intTSystem::AnnounceUnixService(const char* sockpath, int backlog); virtual voidTObject::AppendPad(Option_t* option = """"); virtual const char*TSystem::BaseName(const char* pathname); voidTSystem::Beep(Int_t freq = -1, Int_t duration = -1, Bool_t setDefault = kFALSE); virtual voidTObject::Browse(TBrowser* b); Bool_tTSystem::cd(const char* path); virtual Bool_tTSystem::ChangeDirectory(const char* path); virtual intTSystem::Chmod(const char* file, UInt_t mode); static TClass*Class(); virtual const c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TXNetSystem.html:667,Abort,Abort,667,root/html602/TXNetSystem.html,https://root.cern,https://root.cern/root/html602/TXNetSystem.html,2,['Abort'],['Abort']
Safety," void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; Test if point is inside the torus.; check phi range. Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute closest distance from point px,py to each vertex. Double_t Daxis(Double_t* pt, Double_t* dir, Double_t t) const; Computes distance to axis of the torus from point pt + t*dir;. Double_t DDaxis(Double_t* pt, Double_t* dir, Double_t t) const; Computes derivative w.r.t. t of the distance to axis of the torus from point pt + t*dir;. Double_t DDDaxis(Double_t* pt, Double_t* dir, Double_t t) const; Second derivative of distance to torus axis w.r.t t. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the torus. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the torus. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this torus shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. const char * GetAxisName(Int_t iaxis) const; Returns name of axis IAXIS. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2, dZ. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; Create a shape fitting the mother. void InspectShape() const; print shape parameters. TBuffer3D * MakeBuffer3D() const; Creates a TBuffer3D describing *this* shape.; Coordinates are in local reference frame. void SetSegsAnd",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoTorus.html:13393,safe,safe,13393,root/html528/TGeoTorus.html,https://root.cern,https://root.cern/root/html528/TGeoTorus.html,3,['safe'],['safe']
Safety," void RemoveQueryResult(const char* ref). void SetCurrentQuery(TQueryResult* q). void SetMaxDrawQueries(Int_t max). void RestorePreviousQuery(). Int_t AddOutputObject(TObject* obj). void AddOutput(TList* out). void StoreOutput(TList* out). void StoreFeedback(TObject* slave, TList* out). void Progress(Long64_t total, Long64_t processed). void Progress(TSlave* , Long64_t total, Long64_t processed). void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti). void Progress(TProofProgressInfo* ). void Progress(TSlave* , TProofProgressInfo* ). void Feedback(TList* objs). TDrawFeedback * CreateDrawFeedback(TProof* p). void SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt). void DeleteDrawFeedback(TDrawFeedback* f). TDSetElement * GetNextPacket(TSlave* slave, TMessage* r). Int_t ReinitSelector(TQueryResult* qr). void UpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax). Bool_t IsClient() const. EExitStatus GetExitStatus() const. void SetExitStatus(TVirtualProofPlayer::EExitStatus ). Long64_t GetEventsProcessed() const. void AddEventsProcessed(Long64_t ev). TProofProgressStatus* GetProgressStatus() const. void SetDispatchTimer(Bool_t on = kTRUE). void SetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0). void SetMerging(Bool_t on = kTRUE). Long64_t GetCacheSize(). Int_t GetLearnEntries(). void UpdateProgressInfo(). TVirtualPacketizer * GetPacketizer() const; { return 0; }. void SetOutputFilePath(const char* fp). Int_t SavePartialResults(Bool_t queryend = kFALSE, Bool_t force = kFALSE). » Author: Fons Rademakers 15/03/07 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/proof:$Id$ » Last generated: 2015-09-08 17:49; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TVirtualProofPlayer.html:15653,abort,abort,15653,root/html604/TVirtualProofPlayer.html,https://root.cern,https://root.cern/root/html604/TVirtualProofPlayer.html,2,"['abort', 'timeout']","['abort', 'timeout']"
Safety," void SetVisDensity(Double_t dens = 0.01); // *MENU*; 241 void SetVisLevel(Int_t level = 3); // *MENU*; 242 void SetVisOption(Int_t option = 0);; 243 void ViewLeaves(Bool_t flag = kTRUE); // *TOGGLE* *GETTER=IsVisLeaves; 244 void SaveAttributes(const char *filename = ""tgeoatt.C""); // *MENU*; 245 void RestoreMasterVolume(); // *MENU*; 246 void SetMaxVisNodes(Int_t maxnodes = 10000); // *MENU*; 247 //--- geometry checking; 248 void AnimateTracks(Double_t tmin = 0, Double_t tmax = 5E-8, Int_t nframes = 200, Option_t *option = ""/*""); // *MENU*; 249 void CheckBoundaryErrors(Int_t ntracks = 1000000, Double_t radius = -1.); // *MENU*; 250 void CheckBoundaryReference(Int_t icheck = -1);; 251 void CheckGeometryFull(Int_t ntracks = 1000000, Double_t vx = 0., Double_t vy = 0., Double_t vz = 0.,; 252 Option_t *option = ""ob""); // *MENU*; 253 void CheckGeometry(Option_t *option = """");; 254 void CheckOverlaps(Double_t ovlp = 0.1, Option_t *option = """"); // *MENU*; 255 void CheckPoint(Double_t x = 0, Double_t y = 0, Double_t z = 0, Option_t *option = """", Double_t safety = 0.); // *MENU*; 256 void CheckShape(TGeoShape *shape, Int_t testNo, Int_t nsamples, Option_t *option);; 257 void ConvertReflections();; 258 void DrawCurrentPoint(Int_t color = 2); // *MENU*; 259 void DrawTracks(Option_t *option = """"); // *MENU*; 260 void SetParticleName(const char *pname) { fParticleName = pname; }; 261 const char *GetParticleName() const { return fParticleName.Data(); }; 262 void DrawPath(const char *path, Option_t *option = """");; 263 void PrintOverlaps() const; // *MENU*; 264 void RandomPoints(const TGeoVolume *vol, Int_t npoints = 10000, Option_t *option = """");; 265 void RandomRays(Int_t nrays = 1000, Double_t startx = 0, Double_t starty = 0, Double_t startz = 0,; 266 const char *target_vol = nullptr, Bool_t check_norm = kFALSE);; 267 TGeoNode *SamplePoints(Int_t npoints, Double_t &dist, Double_t epsil = 1E-5, const char *g3path = """");; 268 void SetNmeshPoints(Int_t npoints = 1000);; 269 void Se",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoManager_8h_source.html:12862,safe,safety,12862,doc/master/TGeoManager_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoManager_8h_source.html,1,['safe'],['safety']
Safety," void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoTubeSeg&operator=(const TGeoTubeSeg&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tSafetyS(const Double_t* point, Bool_t in, Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2, Int_t skipz = 0); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetPoints(Double_t* points) const; virtual voidSetPoints(Float_t* points) const; voidTGeoShape::SetRuntime(Bool_t flag = kTRUE); virtual voidSetSegsAndPols(TBuffer3",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoTubeSeg.html:10306,Safe,SafetySeg,10306,root/html534/TGeoTubeSeg.html,https://root.cern,https://root.cern/root/html534/TGeoTubeSeg.html,3,['Safe'],['SafetySeg']
Safety," void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual Int_tTSocket::Reconnect(); virtual voidTObject::RecursiveRemove(TObject* obj); virtual Int_tTServerSocket::Recv(TMessage*&); virtual Int_tTServerSocket::Recv(Int_t&, Int_t&); virtual Int_tTServerSocket::Recv(char*, Int_t); virtual Int_tTServerSocket::Recv(char*, Int_t, Int_t&); virtual Int_tTServerSocket::RecvRaw(void*, Int_t, ESendRecvOptions = kDefault); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Int_tTSocket::Select(Int_t interest = kRead, Long_t timeout = -1); virtual Int_tTServerSocket::Send(const TMessage&); virtual Int_tTServerSocket::Send(Int_t); virtual Int_tTServerSocket::Send(Int_t, Int_t); virtual Int_tTServerSocket::Send(const char*, Int_t = kMESS_STRING); virtual Int_tTServerSocket::SendObject(const TObject*, Int_t = kMESS_OBJECT); virtual Int_tTServerSocket::SendRaw(const void*, Int_t, ESendRecvOptions = kDefault); static voidTServerSocket::SetAcceptOptions(UChar_t Opt); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTSocket::SetCompressionAlgorithm(Int_t algorithm = 0); voidTSocket::SetCompressionLevel(Int_t level = 1); voidTSocket::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual Int_tTSocket::SetOption(ESockOp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TPServerSocket.html:6208,timeout,timeout,6208,root/html530/TPServerSocket.html,https://root.cern,https://root.cern/root/html530/TPServerSocket.html,5,['timeout'],['timeout']
Safety," void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTFile::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTMemFile::Print(Option_t* option = """") const; virtual voidTDirectoryFile::Purge(Short_t nkeep = 1); virtual voidTDirectory::pwd() const; virtual Int_tTObject::Read(const char* name); virtual voidTDirectoryFile::ReadAll(Option_t* option = """"); virtual Bool_tTFile::ReadBuffer(char* buf, Int_t len); virtual Bool_tTFile::ReadBuffer(char* buf, Long64_t pos, Int_t len); virtual Bool_tTFile::ReadBufferAsync(Long64_t offs, Int_t len); virtual Bool_tTFile::ReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); virtual voidTFile::ReadFree(); virtual Int_tTDirectoryFile::ReadKeys(Bool_t forceRead = kTRUE); virtual TProcessID*TFile::ReadProcessID(UShort_t pidf); virtual voidTFile::ReadStreamerInfo(); virtual Int_tTDirectoryFile::ReadTObject(TObject* obj, const char* keyname); virtual Int_tTFile::Recover(); virtual voidTDirectory::RecursiveRemove(TObject* obj); virtual TObject*TDirectory::Remove(TObject*); virtual Int_tTFile::ReOpen(Option_t* mode); virtual voidTMemFile::ResetAfterMerge(TFileMergeInfo*); voidTObject::ResetBit(UInt_t f); virtual voidTMemFile::ResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidTFile::Seek(Long64_t offset, TFile::ERelativeTo pos = kBeg); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tTFile::SetCacheFileDir(const char* cacheDir, Bool_t operateDisconne",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TParallelMergingFile.html:11316,Recover,Recover,11316,root/html532/TParallelMergingFile.html,https://root.cern,https://root.cern/root/html532/TParallelMergingFile.html,2,['Recover'],['Recover']
Safety," void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTFile::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidPrint(Option_t* option = """") const; virtual voidTDirectoryFile::Purge(Short_t nkeep = 1); virtual voidTDirectory::pwd() const; virtual Int_tTObject::Read(const char* name); virtual voidTDirectoryFile::ReadAll(Option_t* option = """"); virtual Bool_tReadBuffer(char* buf, Int_t len); virtual Bool_tReadBuffer(char* buf, Long64_t pos, Int_t len); virtual Bool_tReadBufferAsync(Long64_t offs, Int_t len); virtual Bool_tReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); virtual voidTFile::ReadFree(); virtual Int_tTDirectoryFile::ReadKeys(Bool_t forceRead = kTRUE); virtual TProcessID*TFile::ReadProcessID(UShort_t pidf); virtual voidTFile::ReadStreamerInfo(); virtual Int_tTDirectoryFile::ReadTObject(TObject* obj, const char* keyname); virtual Int_tTFile::Recover(); virtual voidTDirectory::RecursiveRemove(TObject* obj); virtual TObject*TDirectory::Remove(TObject*); virtual Int_tReOpen(Option_t* mode); virtual voidTDirectoryFile::ResetAfterMerge(TFileMergeInfo*); voidTObject::ResetBit(UInt_t f); virtual voidResetCache(); virtual voidTFile::ResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidTNetFile::Seek(Long64_t offset, TFile::ERelativeTo pos = kBeg); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tTFile::SetCacheFileDir(const char* cacheDi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TXNetFile.html:11612,Recover,Recover,11612,root/html532/TXNetFile.html,https://root.cern,https://root.cern/root/html532/TXNetFile.html,2,['Recover'],['Recover']
Safety," void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTFile::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidPrint(Option_t* option = """") const; virtual voidTDirectoryFile::Purge(Short_t nkeep = 1); virtual voidTDirectory::pwd() const; virtual Int_tTObject::Read(const char* name); virtual voidTDirectoryFile::ReadAll(Option_t* option = """"); virtual Bool_tReadBuffer(char* buf, Int_t len); virtual Bool_tReadBuffer(char* buf, Long64_t pos, Int_t len); virtual Bool_tReadBufferAsync(Long64_t offs, Int_t len); virtual Bool_tReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); virtual voidTFile::ReadFree(); virtual Int_tTDirectoryFile::ReadKeys(Bool_t forceRead = kTRUE); virtual TProcessID*TFile::ReadProcessID(UShort_t pidf); virtual voidTFile::ReadStreamerInfo(); virtual Int_tTDirectoryFile::ReadTObject(TObject* obj, const char* keyname); virtual Int_tTFile::Recover(); virtual voidTDirectory::RecursiveRemove(TObject* obj); virtual TObject*TDirectory::Remove(TObject*); virtual Int_tReOpen(Option_t* mode); voidTObject::ResetBit(UInt_t f); virtual voidResetCache(); virtual voidTFile::ResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidTNetFile::Seek(Long64_t offset, TFile::ERelativeTo pos = kBeg); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tTFile::SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected =",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TXNetFile.html:11196,Recover,Recover,11196,root/html528/TXNetFile.html,https://root.cern,https://root.cern/root/html528/TXNetFile.html,1,['Recover'],['Recover']
Safety," void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTFile::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidPrint(Option_t* option = """") const; virtual voidTDirectoryFile::Purge(Short_t nkeep = 1); virtual voidTDirectory::pwd() const; virtual Int_tTObject::Read(const char* name); virtual voidTDirectoryFile::ReadAll(Option_t* option = """"); virtual Bool_tReadBuffer(char* buf, Int_t len); virtual Bool_tReadBuffer(char* buf, Long64_t pos, Int_t len); virtual Bool_tReadBufferAsync(Long64_t offs, Int_t len); virtual Bool_tReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); virtual voidTFile::ReadFree(); virtual Int_tTDirectoryFile::ReadKeys(Bool_t forceRead = kTRUE); virtual TProcessID*TFile::ReadProcessID(UShort_t pidf); virtual voidTFile::ReadStreamerInfo(); virtual Int_tTDirectoryFile::ReadTObject(TObject* obj, const char* keyname); virtual Int_tTFile::Recover(); virtual voidTDirectory::RecursiveRemove(TObject* obj); virtual TObject*TDirectory::Remove(TObject*); virtual Int_tReOpen(Option_t* mode); voidTObject::ResetBit(UInt_t f); virtual voidResetCache(); virtual voidTFile::ResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidTNetFile::Seek(Long64_t offset, TFile::ERelativeTo pos = kBeg); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tTFile::SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread =",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TXNetFile.html:11385,Recover,Recover,11385,root/html530/TXNetFile.html,https://root.cern,https://root.cern/root/html530/TXNetFile.html,1,['Recover'],['Recover']
Safety," void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTFile::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidPrint(Option_t* option = """") const; virtual voidTDirectoryFile::Purge(Short_t nkeep = 1); virtual voidTDirectory::pwd() const; virtual Int_tTObject::Read(const char* name); virtual voidTDirectoryFile::ReadAll(Option_t* option = """"); virtual Bool_tReadBuffer(char* buf, Int_t len); virtual Bool_tReadBuffer(char* buf, Long64_t pos, Int_t len); virtual Bool_tReadBufferAsync(Long64_t offs, Int_t len); virtual Bool_tReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); virtual voidTFile::ReadFree(); virtual Int_tTDirectoryFile::ReadKeys(Bool_t forceRead = kTRUE); virtual TProcessID*TFile::ReadProcessID(UShort_t pidf); virtual voidTFile::ReadStreamerInfo(); virtual Int_tTDirectoryFile::ReadTObject(TObject* obj, const char* keyname); virtual Int_tTFile::Recover(); virtual voidTDirectory::RecursiveRemove(TObject* obj); virtual TObject*TDirectory::Remove(TObject*); virtual Int_tReOpen(const Option_t* mode); virtual voidTDirectoryFile::ResetAfterMerge(TFileMergeInfo*); voidTObject::ResetBit(UInt_t f); virtual voidResetCache(); virtual voidTFile::ResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidTNetFile::Seek(Long64_t offset, TFile::ERelativeTo pos = kBeg); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tTFile::SetCacheFileDir(const char* c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TXNetFile.html:11489,Recover,Recover,11489,root/html602/TXNetFile.html,https://root.cern,https://root.cern/root/html602/TXNetFile.html,2,['Recover'],['Recover']
Safety," voidShowData(); voidTProof::ShowDataSet(const char* dataset = """", const char* opt = ""filter:SsCc""); virtual voidShowDataSetCache(const char* dataset = 0); voidTProof::ShowDataSetQuota(Option_t* opt = 0); virtual voidShowDataSets(const char* uri = """", const char* = 0); voidTProof::ShowEnabledPackages(Bool_t all = kFALSE); voidTProof::ShowFeedback() const; voidTProof::ShowLog(Int_t qry = -1); voidTProof::ShowLog(const char* queryref); virtual voidShowMembers(TMemberInspector&); voidTProof::ShowMissingFiles(TQueryResult* qr = 0); voidTProof::ShowPackages(Bool_t all = kFALSE, Bool_t redirlog = kFALSE); voidTProof::ShowParameters(const char* wildcard = ""PROOF_*"") const; voidTProof::ShowQueries(Option_t* opt = """"); virtual voidTProof::ShowStagingStatusDataSet(const char* dataset, const char* optStr = ""filter:SsCc""); virtual Int_tTNamed::Sizeof() const; voidTProof::StartupMessage(const char* msg, Bool_t status, Int_t done, Int_t total)SIGNAL ; voidTProof::StopProcess(Bool_t abort, Int_t timeout = -1); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; voidTProof::Touch(); Int_tTProof::UploadDataSet(const char*, TList*, const char* = 0, Int_t = 0, TList* = 0); Int_tTProof::UploadDataSet(const char*, const char*, const char* = 0, Int_t = 0, TList* = 0); Int_tTProof::UploadDataSetFromFile(const char*, const char*, const char* = 0, Int_t = 0, TList* = 0); Int_tTProof::UploadPackage(const char* par, TProof::EUploadPackageOpt opt = kUntar, TList* workers = 0); virtual voidTObject::UseCurrentStyle(); Bool_tTProof::UseDynamicStartup() const; virtual Int_tVerifyDataSet(const char* uri, const char* = 0); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofLite.html:18546,timeout,timeout,18546,root/html534/TProofLite.html,https://root.cern,https://root.cern/root/html534/TProofLite.html,1,['timeout'],['timeout']
Safety," voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); static voidComputeNormalS(Double_t* point, Double_t* dir, Double_t* norm, Double_t rmin, Double_t rmax, Double_t dz); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistFromInsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistFromOutsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); static voidDistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Doub",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoTube.html:2546,safe,safe,2546,root/html530/TGeoTube.html,https://root.cern,https://root.cern/root/html530/TGeoTube.html,1,['safe'],['safe']
Safety," voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTGeoArb8::ComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidTGeoArb8::ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); voidTGeoArb8::ComputeTwist(); virtual Bool_tTGeoArb8::Contains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoBBox::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tTGeoArb8::DistToPlane(Double_t* point, Double_t* dir, Int_t ipl, Bool_t in) const; virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoTrap.html:3060,safe,safe,3060,root/html532/TGeoTrap.html,https://root.cern,https://root.cern/root/html532/TGeoTrap.html,1,['safe'],['safe']
Safety," voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTGeoArb8::ComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidTGeoArb8::ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); voidTGeoArb8::ComputeTwist(); virtual Bool_tTGeoArb8::Contains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoBBox::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tTGeoArb8::DistToPlane(Double_t* point, Double_t* dir, Int_t ipl, Bool_t in) const; virtual TGeoVolume*TGeoTrap::Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* met",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoGtra.html:3039,safe,safe,3039,root/html532/TGeoGtra.html,https://root.cern,https://root.cern/root/html532/TGeoGtra.html,1,['safe'],['safe']
Safety," voidTGeoShape::NormalPhi(Double_t* point, Double_t* dir, Double_t* norm, Double_t c1, Double_t s1, Double_t c2, Double_t s2); virtual Bool_tTObject::Notify(); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoTorus&operator=(const TGeoTorus&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(Double_t* point, Bool_t in = kTRUE) const; static Double_tTGeoShape::SafetyPhi(Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetPoints(Double_t* points) const; virtual voidSetPoints(Float_t* points) const; voidTGeoShape::SetRuntime(Bool_t flag = kTRUE); virtual voidSetSegsAndPols(TBuffer3D& buff) const; voidTGeoShape::S",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoTorus.html:7764,Safe,SafetyPhi,7764,root/html528/TGeoTorus.html,https://root.cern,https://root.cern/root/html528/TGeoTorus.html,1,['Safe'],['SafetyPhi']
Safety," voidTObject::SetUniqueID(UInt_t uid); virtual voidTProof::ShowCache(Bool_t all = kFALSE); voidTProof::ShowData(); voidTProof::ShowDataSet(const char* dataset = """", const char* opt = ""M""); virtual voidTProof::ShowDataSetCache(const char* dataset = 0); voidTProof::ShowDataSetQuota(Option_t* opt = 0); virtual voidTProof::ShowDataSets(const char* uri = """", const char* optStr = """"); voidTProof::ShowEnabledPackages(Bool_t all = kFALSE); voidTProof::ShowFeedback() const; voidTProof::ShowLog(Int_t qry = -1); voidTProof::ShowLog(const char* queryref); virtual voidShowMembers(TMemberInspector& insp); voidTProof::ShowMissingFiles(TQueryResult* qr = 0); voidTProof::ShowPackages(Bool_t all = kFALSE, Bool_t redirlog = kFALSE); voidTProof::ShowParameters(const char* wildcard = ""PROOF_*"") const; voidTProof::ShowQueries(Option_t* opt = """"); virtual Int_tTNamed::Sizeof() const; voidTProof::StartupMessage(const char* msg, Bool_t status, Int_t done, Int_t total)SIGNAL ; voidTProof::StopProcess(Bool_t abort, Int_t timeout = -1); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; voidTProof::Touch(); Int_tTProof::UploadDataSet(const char* dataset, TList* files, const char* dest = 0, Int_t opt = kAskUser, TList* skippedFiles = 0); Int_tTProof::UploadDataSet(const char* dataset, const char* files, const char* dest = 0, Int_t opt = kAskUser, TList* skippedFiles = 0); Int_tTProof::UploadDataSetFromFile(const char* dataset, const char* file, const char* dest = 0, Int_t opt = kAskUser, TList* skippedFiles = 0); Int_tTProof::UploadPackage(const char* par, TProof::EUploadPackageOpt opt = kUntar); virtual voidTObject::UseCurrentStyle(); Bool_tTProof::UseDynamicStartup() const; virtual Int_tTProof::VerifyDataSet(const char* dataset, const char* optStr = """"); virtual voidTObject::Warning(const char* method, const char* msgfmt)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProofCondor.html:17491,abort,abort,17491,root/html530/TProofCondor.html,https://root.cern,https://root.cern/root/html530/TProofCondor.html,4,['abort'],['abort']
Safety," voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TEventIterObj&operator=(const TEventIterObj&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidTEventIter::StopProcess(Bool_t abort); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TEventIterObj.html:4616,abort,abort,4616,root/html530/TEventIterObj.html,https://root.cern,https://root.cern/root/html530/TEventIterObj.html,2,['abort'],['abort']
Safety," voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoSphere&operator=(const TGeoSphere&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); voidSetDimensions(Double_t* param, Int_t nparam); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); virtual voidSetNumberOfDivisions(Int_t p); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetPoints(Double_t* points) const; virtual voidSetPoints(Float_t* point",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoSphere.html:9240,Safe,SafetySeg,9240,root/html534/TGeoSphere.html,https://root.cern,https://root.cern/root/html534/TGeoSphere.html,1,['Safe'],['SafetySeg']
Safety," voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTGeoShape::Paint(Option_t* option = """"); Double_t&TGeoPcon::Phi1(); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); Double_t&TGeoPcon::Rmax(Int_t ipl); Double_t&TGeoPcon::Rmin(Int_t ipl); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); Double_tSafetyToSegment(const Double_t* point, Int_t ipl, Int_t iphi, Bool_t in, Double_t safphi, Double_t safmin = TGeoShape::Big()) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); voidSetNedges(Int_t ne); static voidTObject::SetObjectStat(Bool_t stat); virtual vo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoPgon.html:9404,Safe,SafetySeg,9404,root/html534/TGeoPgon.html,https://root.cern,https://root.cern/root/html534/TGeoPgon.html,1,['Safe'],['SafetySeg']
Safety," voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidEnableTimeout(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; static voidTProofServ::ErrorHandler(Int_t level, Bool_t abort, const char* location, const char* msg); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); static Long_tTApplication::ExecuteFile(const char* file, Int_t* error = 0, Bool_t keep = kFALSE); TApplication::EExitOnExceptionTApplication::ExitOnException(TApplication::EExitOnException opt = kExit); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; static voidTProofServ::FilterLocalroot(TString& path, const char* url = ""root://dum/""); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidTProofServ::FlushLogFile(); TObject*TProofServ::Get(const char* namecycle); Int_tTProofServ::GetActSessions() const; virtual TApplicationImp*TApplication::GetApplicationImp(); static TList*TApplication::GetApplications(); T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TXProofServ.html:4052,abort,abort,4052,root/html602/TXProofServ.html,https://root.cern,https://root.cern/root/html602/TXProofServ.html,2,['abort'],['abort']
Safety," void Safety_v (const Double_t *points, const Bool_t *inside, Double_t *safe, Int_t vecsize) const override;  Compute safe distance from each of the points in the input array. ;  ; void SavePrimitive (std::ostream &out, Option_t *option="""") override;  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void SetDimensions (Double_t *param) override;  Set half-space parameters as stored in an array. ;  ; void SetPoints (Double_t *) const override;  ; void SetPoints (Float_t *) const override;  ; void Sizeof3D () const override;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TGeoBBox;  TGeoBBox ();  ;  TGeoBBox (const char *name, Double_t dx, Double_t dy, Double_t dz, Double_t *origin=nullptr);  ;  TGeoBBox (Double_t *param);  ;  TGeoBBox (Double_t dx, Double_t dy, Double_t dz, Double_t *origin=nullptr);  ;  ~TGeoBBox () override;  ; Bool_t CouldBeCrossed (const Double_t *point, const Double_t *dir) const override;  ; const char * GetAxisName (Int_t iaxis) const override;  ; Double_t GetAxisRange (Int_t iaxis, Double_t &xlo, Double_t &xhi) const override;  ; const TBuffer3D & GetBuffer3D (Int_t reqSections, Bool_t localFrame) const override;  Stub implementation to avoid forcing implementation at this stage. ;  ; Int_t GetByteCount () const override;  ; virtual Double_t GetDX () const;  ; virtual Double_t GetDY () const;  ; virtual Double_t GetDZ () const;  ; virtual Double_t GetFacetArea (Int_t index=0) const;  ; Int_t GetFittingBox (const TGeoBBox *parambox, TGeoMatrix *mat, Double_t &dx, Double_t &dy, Double_t &dz) const override;  ; virtual const Double_t * GetOrigin () const;  ; virtual Bool_t GetPointsOnFacet (Int_t index, Int_t npoints, Double_t *array) const;  ; Bool_t GetPointsOnSegments (Int_t npoints, Double_t *array) const override;  ; virtual Bool_t IsNullBox () const;  ; Bool_t IsValidBox () const overri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoHalfSpace.html:5325,avoid,avoid,5325,doc/master/classTGeoHalfSpace.html,https://root.cern,https://root.cern/doc/master/classTGeoHalfSpace.html,1,['avoid'],['avoid']
Safety," void SendDNDPosition (Window_t target, int x, int y, Atom_t action, Time_t timestamp);  Send DND position message to target window. ;  ; void SendDNDStatus (Window_t target, Atom_t action);  Send DND status message to source window. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; Atom_t fAcceptedAction;  ; Cursor_t fDNDNoDropCursor;  no drop cursor type ;  ; Atom_t * fDraggerTypes;  lists of DND types ;  ; Bool_t fDragging;  kTRUE while dragging ;  ; TGDragWindow * fDragWin;  drag window ;  ; Bool_t fDropAccepted;  kTRUE if drop accepted ;  ; TTimer * fDropTimeout;  drop timeout ;  ; Atom_t fDropType;  drop type ;  ; UInt_t fGrabEventMask;  pointer grab event mask ;  ; Int_t fHotx;  ; Int_t fHoty;  hot point coordinates ;  ; Atom_t fLocalAction;  accepted and local actions ;  ; TGFrame * fLocalSource;  ; TGFrame * fLocalTarget;  local source and target ;  ; TGFrame * fMain;  pointer on TGMainFrame ;  ; Pixmap_t fMask;  pixmap used for the drag window ;  ; Pixmap_t fPic;  ; Bool_t fProxyOurs;  kTRUE if root proxy is ours ;  ; Window_t fSource;  ; Bool_t fStatusPending;  kTRUE if status is pending ;  ; Window_t fTarget;  source and target windows ;  ; Bool_t fTargetIsDNDAware;  kTRUE if target is DND aware ;  ; Atom_t * fTypelist;  ; Bool_t fUseVersion;  kTRUE if DND version is used ;  ; Atom_t fVersion;  not really an Atom, but a long ;  . Static Protected Attributes; static Atom_t fgDNDActionAsk = kNone;  ; static Atom_t fgDNDActionCopy = kNone;  ; static Atom_t fgDNDActionDescrip = kNone;  ; static Atom_t fgDNDActionLink = kNone;  ; static Atom_t fgDNDActionList = kNone;  ; static Atom_t fgDNDActionMove = kNone;  ; static Atom_t fgDNDActionPrivate = kNone;  ; static Atom_t fgDNDAware = kNone;  ; static Atom_t fgDNDDrop = kNone;  ; static Atom_t fgDNDEnter = kNone;  ; static Ato",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGDNDManager.html:12702,timeout,timeout,12702,doc/master/classTGDNDManager.html,https://root.cern,https://root.cern/doc/master/classTGDNDManager.html,1,['timeout'],['timeout']
Safety," volume ""voldiv"" into ndiv equal volumes; called divname, from start position with the given step. Returns pointer; to created division cell volume. In case a wrong division axis is supplied,; returns pointer to volume to be divided. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. Int_t GetFittingBox(const TGeoBBox* parambox, TGeoMatrix* mat, Double_t& dx, Double_t& dy, Double_t& dz) const; Fills real parameters of a positioned box inside this. Returns 0 if successfull. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; in case shape has some negative parameters, these has to be computed; in order to fit the mother. void InspectShape() const; print shape parameters. Double_t Safety(const Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape, according; to option. The matching point on the shape is stored in spoint. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetDimensions(Double_t* param); Set dimensions starting from an array. void SetPoints(Double_t* points) const; Create PARA mesh points. void SetPoints(Float_t* points) const; create sphere mesh points. void Sizeof3D() const; fill size of this 3-D object. void Contains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoPara.html:15423,Safe,Safety,15423,root/html534/TGeoPara.html,https://root.cern,https://root.cern/root/html534/TGeoPara.html,3,['Safe'],['Safety']
Safety," vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTFile::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTFile::Print(Option_t* option = """") const; virtual voidTDirectoryFile::Purge(Short_t nkeep = 1); virtual voidTDirectory::pwd() const; virtual Int_tTObject::Read(const char* name); virtual voidTDirectoryFile::ReadAll(Option_t* option = """"); virtual Bool_tReadBuffer(char* buffer, Int_t length); virtual Bool_tReadBuffer(char* buffer, Long64_t position, Int_t length); virtual Bool_tTFile::ReadBufferAsync(Long64_t offs, Int_t len); virtual Bool_tReadBuffers(char* buffer, Long64_t* position, Int_t* length, Int_t nbuffs); virtual voidTFile::ReadFree(); virtual Int_tTDirectoryFile::ReadKeys(Bool_t forceRead = kTRUE); virtual TProcessID*TFile::ReadProcessID(UShort_t pidf); virtual voidTFile::ReadStreamerInfo(); virtual Int_tTDirectoryFile::ReadTObject(TObject* obj, const char* keyname); virtual Int_tTFile::Recover(); virtual voidTDirectory::RecursiveRemove(TObject* obj); virtual TObject*TDirectory::Remove(TObject*); virtual Int_tReOpen(Option_t* modestr); virtual voidTDirectoryFile::ResetAfterMerge(TFileMergeInfo*); voidTObject::ResetBit(UInt_t f); virtual voidTFile::ResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidSeek(Long64_t offset, TFile::ERelativeTo position = kBeg); virtual voidSetAsyncOpenStatus(TFile::EAsyncOpenStatus status); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tTFile:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TNetXNGFile.html:11004,Recover,Recover,11004,root/html534/TNetXNGFile.html,https://root.cern,https://root.cern/root/html534/TNetXNGFile.html,3,['Recover'],['Recover']
Safety," want these objects to leak out of the function,; // so we can still see them after it returns.; TCanvas* c = new TCanvas();; RooPlot* frame = x.frame();; data->plotOn(frame, RooFit::Name(""data""));; ; // Plotting a PDF with disallowed parameters doesn't work. We would get a lot of error messages.; // Therefore, we disable plotting messages in RooFit's message streams:; RooMsgService::instance().getStream(0).removeTopic(RooFit::Plotting);; RooMsgService::instance().getStream(1).removeTopic(RooFit::Plotting);; ; ; // RooFit before ROOT 6.24; // --------------------------------; // Before 6.24, RooFit wasn't able to recover from invalid parameters. The minimiser just errs around; // the starting values of the parameters without finding any improvement.; ; // Set up the parameters such that the PDF would come out negative. The PDF is now undefined.; a1.setVal(10.);; a2.setVal(-1.);; ; // Perform a fit:; std::unique_ptr<RooFitResult> fitWithoutRecovery{pdf.fitTo(*data, RooFit::Save(),; RooFit::RecoverFromUndefinedRegions(0.), // This is how RooFit behaved prior to ROOT 6.24; RooFit::PrintEvalErrors(-1), // We are expecting a lot of evaluation errors. -1 switches off printing.; RooFit::PrintLevel(-1))};; ; pdf.plotOn(frame, RooFit::LineColor(kRed), RooFit::Name(""noRecovery""));; ; ; ; // RooFit since ROOT 6.24; // --------------------------------; // The minimiser gets information about the ""badness"" of the violation of the function definition. It uses this; // to find its way out of the disallowed parameter regions.; std::cout << ""\n\n\n-------------- Starting second fit ---------------\n\n"" << std::endl;; ; // Reset the parameters such that the PDF is again undefined.; a1.setVal(10.);; a2.setVal(-1.);; ; // Fit again, but pass recovery information to the minimiser:; std::unique_ptr<RooFitResult> fitWithRecovery{pdf.fitTo(*data, RooFit::Save(),; RooFit::RecoverFromUndefinedRegions(1.), // The magnitude of the recovery information can be chosen here.; // Higher values mean",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html:3669,Recover,RecoverFromUndefinedRegions,3669,doc/master/rf612__recoverFromInvalidParameters_8C.html,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html,1,['Recover'],['RecoverFromUndefinedRegions']
Safety," was joined; TStopwatchfWaitTimetime wating to prefetch a buffer (in usec). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFilePrefetch(TFile* ); Constructor. ~TFilePrefetch(); Destructor. void WaitFinishPrefetch(); Killing the async prefetching thread. void ReadAsync(TFPBlock* , Bool_t& ); Read one block and insert it in prefetchBuffers list. void ReadListOfBlocks(); Get blocks specified in prefetchBlocks. Bool_t BinarySearchReadList(TFPBlock* , Long64_t , Int_t , Int_t* ); Search for a requested element in a block and return the index. Long64_t GetWaitTime(); Return the time spent wating for buffer to be read in microseconds. Bool_t ReadBuffer(char* , Long64_t , Int_t ); Return a prefetched element. void ReadBlock(Long64_t* , Int_t* , Int_t ); Create a TFPBlock object or recycle one and add it to the prefetchBlocks list. void AddPendingBlock(TFPBlock* ); Safe method to add a block to the pendingList. TFPBlock* GetPendingBlock(); Safe method to remove a block from the pendingList. void AddReadBlock(TFPBlock* ); Safe method to add a block to the readList. TFPBlock* CreateBlockObj(Long64_t* , Int_t* , Int_t ); Create a new block or recycle an old one. TThread* GetThread() const; Return reference to the consumer thread. void SetFile(TFile* ); Change the file; When prefetching is enabled we also need to:; - make sure the async thread is not doing any work; - clear all blocks from prefetching and read list; - reset the file pointer. Int_t ThreadStart(); Used to start the consumer thread. TThread::VoidRtnFunc_t ThreadProc(void* ); Execution loop of the consumer thread. Int_t SumHex(const char* ); Sum up individual hex values to obtain a decimal value. Bool_t CheckBlockInCache(char*& , TFPBlock* ); Test if the block is in cache. char* GetBlockFromCache(const char* , Int_t ); Return a buffer from cache. void SaveBlockInCache(TFPBlock* ); Save the block content in cache. Bool_t SetCache(const char* ); Set the path of the cache dir",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TFilePrefetch.html:7551,Safe,Safe,7551,root/html534/TFilePrefetch.html,https://root.cern,https://root.cern/root/html534/TFilePrefetch.html,3,['Safe'],['Safe']
Safety," we're reading from the; 6205 * CGI pipe, fread() may block until IO buffer is filled up. We; 6206 * cannot afford to block and must pass all read bytes immediately; 6207 * to the client. */; 6208 nread = (int)read(fileno(fp), buf, (size_t)len);; 6209 ; 6210 err = (nread < 0) ? ERRNO : 0;; 6211 if ((nread == 0) && (len > 0)) {; 6212 /* Should get data, but got EOL */; 6213 return -2;; 6214 }; 6215 ; 6216#if defined(USE_MBEDTLS); 6217 } else if (conn->ssl != NULL) {; 6218 struct mg_pollfd pfd[1];; 6219 int to_read;; 6220 int pollres;; 6221 ; 6222 to_read = mbedtls_ssl_get_bytes_avail(conn->ssl);; 6223 ; 6224 if (to_read > 0) {; 6225 /* We already know there is no more data buffered in conn->buf; 6226 * but there is more available in the SSL layer. So don't poll; 6227 * conn->client.sock yet. */; 6228 ; 6229 pollres = 1;; 6230 if (to_read > len); 6231 to_read = len;; 6232 } else {; 6233 pfd[0].fd = conn->client.sock;; 6234 pfd[0].events = POLLIN;; 6235 ; 6236 to_read = len;; 6237 ; 6238 pollres = mg_poll(pfd,; 6239 1,; 6240 (int)(timeout * 1000.0),; 6241 &(conn->phys_ctx->stop_flag));; 6242 ; 6243 if (!STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 6244 return -2;; 6245 }; 6246 }; 6247 ; 6248 if (pollres > 0) {; 6249 nread = mbed_ssl_read(conn->ssl, (unsigned char *)buf, to_read);; 6250 if (nread <= 0) {; 6251 if ((nread == MBEDTLS_ERR_SSL_WANT_READ); 6252 || (nread == MBEDTLS_ERR_SSL_WANT_WRITE); 6253 || nread == MBEDTLS_ERR_SSL_ASYNC_IN_PROGRESS) {; 6254 nread = 0;; 6255 } else {; 6256 fprintf(stderr, ""SSL read failed, error %d\n"", nread);; 6257 return -2;; 6258 }; 6259 } else {; 6260 err = 0;; 6261 }; 6262 ; 6263 } else if (pollres < 0) {; 6264 /* Error */; 6265 return -2;; 6266 } else {; 6267 /* pollres = 0 means timeout */; 6268 nread = 0;; 6269 }; 6270 ; 6271#elif !defined(NO_SSL); 6272 } else if (conn->ssl != NULL) {; 6273 int ssl_pending;; 6274 struct mg_pollfd pfd[1];; 6275 int pollres;; 6276 ; 6277 if ((ssl_pending = SSL_pending(conn->ssl)) > 0) {; 6278 /*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:181901,timeout,timeout,181901,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety," we're reading from the; 6206 * CGI pipe, fread() may block until IO buffer is filled up. We; 6207 * cannot afford to block and must pass all read bytes immediately; 6208 * to the client. */; 6209 nread = (int)read(fileno(fp), buf, (size_t)len);; 6210 ; 6211 err = (nread < 0) ? ERRNO : 0;; 6212 if ((nread == 0) && (len > 0)) {; 6213 /* Should get data, but got EOL */; 6214 return -2;; 6215 }; 6216 ; 6217#if defined(USE_MBEDTLS); 6218 } else if (conn->ssl != NULL) {; 6219 struct mg_pollfd pfd[1];; 6220 int to_read;; 6221 int pollres;; 6222 ; 6223 to_read = mbedtls_ssl_get_bytes_avail(conn->ssl);; 6224 ; 6225 if (to_read > 0) {; 6226 /* We already know there is no more data buffered in conn->buf; 6227 * but there is more available in the SSL layer. So don't poll; 6228 * conn->client.sock yet. */; 6229 ; 6230 pollres = 1;; 6231 if (to_read > len); 6232 to_read = len;; 6233 } else {; 6234 pfd[0].fd = conn->client.sock;; 6235 pfd[0].events = POLLIN;; 6236 ; 6237 to_read = len;; 6238 ; 6239 pollres = mg_poll(pfd,; 6240 1,; 6241 (int)(timeout * 1000.0),; 6242 &(conn->phys_ctx->stop_flag));; 6243 ; 6244 if (!STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 6245 return -2;; 6246 }; 6247 }; 6248 ; 6249 if (pollres > 0) {; 6250 nread = mbed_ssl_read(conn->ssl, (unsigned char *)buf, to_read);; 6251 if (nread <= 0) {; 6252 if ((nread == MBEDTLS_ERR_SSL_WANT_READ); 6253 || (nread == MBEDTLS_ERR_SSL_WANT_WRITE); 6254 || nread == MBEDTLS_ERR_SSL_ASYNC_IN_PROGRESS) {; 6255 nread = 0;; 6256 } else {; 6257 fprintf(stderr, ""SSL read failed, error %d\n"", nread);; 6258 return -2;; 6259 }; 6260 } else {; 6261 err = 0;; 6262 }; 6263 ; 6264 } else if (pollres < 0) {; 6265 /* Error */; 6266 return -2;; 6267 } else {; 6268 /* pollres = 0 means timeout */; 6269 nread = 0;; 6270 }; 6271 ; 6272#elif !defined(NO_SSL); 6273 } else if (conn->ssl != NULL) {; 6274 int ssl_pending;; 6275 struct mg_pollfd pfd[1];; 6276 int pollres;; 6277 ; 6278 if ((ssl_pending = SSL_pending(conn->ssl)) > 0) {; 6279 /*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:181933,timeout,timeout,181933,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety," will be used as it is, so make sure to end it with '.gif+'. Use convert tool from ImageMagic if you want to set a different delay or enable looping. ; Definition at line 204 of file TGLAutoRotator.cxx. ◆ StartImageAutoSaveWithGUISettings(). void TGLAutoRotator::StartImageAutoSaveWithGUISettings ; (; ). Start auto-saving images as set-up via GUI. ; Definition at line 263 of file TGLAutoRotator.cxx. ◆ Stop(). void TGLAutoRotator::Stop ; (; ). Stop the auto-rotator. ; Definition at line 137 of file TGLAutoRotator.cxx. ◆ StopImageAutoSave(). void TGLAutoRotator::StopImageAutoSave ; (; ). Stops automatic saving of images. ; Definition at line 240 of file TGLAutoRotator.cxx. ◆ Streamer(). void TGLAutoRotator::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void TGLAutoRotator::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 114 of file TGLAutoRotator.h. ◆ Timeout(). void TGLAutoRotator::Timeout ; (; ). Called on every timer timeout. ; Moves / rotates the camera and optionally produces a screenshot. ; Definition at line 151 of file TGLAutoRotator.cxx. Member Data Documentation. ◆ fADolly. Double_t TGLAutoRotator::fADolly. protected . Definition at line 42 of file TGLAutoRotator.h. ◆ fATheta. Double_t TGLAutoRotator::fATheta. protected . Definition at line 41 of file TGLAutoRotator.h. ◆ fCamera. TGLCamera* TGLAutoRotator::fCamera. protected . Definition at line 31 of file TGLAutoRotator.h. ◆ fDeltaPhi. Double_t TGLAutoRotator::fDeltaPhi. protected . Definition at line 37 of file TGLAutoRotator.h. ◆ fDollyA0. Double_t TGLAutoRotator::fDollyA0. protected . Definition at line 44 of file TGLAutoRotator.h. ◆ fDt. Double_t TGLAutoRotator::fDt. protected . Definition at line 39 of file TGLAutoRotator.h. ◆ fImageAutoSave. Bool_t TGLAutoRotator::fImageAutoSave. protected . Definition at line 49 of file TGLAutoRotator.h. ◆ fImageCount. Int_t TGLAutoRot",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGLAutoRotator.html:20242,Timeout,Timeout,20242,doc/master/classTGLAutoRotator.html,https://root.cern,https://root.cern/doc/master/classTGLAutoRotator.html,1,['Timeout'],['Timeout']
Safety," will not be compressed.; level = 1, minimal compression level but fast. level = 9, maximal compression level but slower and might use more memory.; (For the currently supported algorithms, the maximum level is 9); If compress is negative it indicates the compression level is not set yet. The enumeration ROOT::ECompressionAlgorithm associates each; algorithm with a number. There is a utility function to help; to set the value of compress. For example,; ROOT::CompressionSettings(ROOT::kLZMA, 1); will build an integer which will set the compression to use; the LZMA algorithm and compression level 1. These are defined; in the header file Compression.h. Note that the compression settings may be changed at any time.; The new compression settings will only apply to branches created; or attached after the setting is changed and other objects written; after the setting is changed. In case the file does not exist or is not a valid ROOT file,; it is made a Zombie. One can detect this situation with a code like:; TFile f(""file.root"");; if (f.IsZombie()) {; cout << ""Error opening file"" << endl;; exit(-1);; }. When opening the file, the system checks the validity of this directory.; If something wrong is detected, an automatic Recovery is performed. In; this case, the file is scanned sequentially reading all logical blocks; and attempting to rebuild a correct directory (see TFile::Recover).; One can disable the automatic recovery procedure when reading one; or more files by setting the environment variable ""TFile.Recover: 0""; in the system.rootrc file. TFile(const TFile& ); TFile objects can not be copied. ~TFile(); File destructor. void Init(Bool_t create); Initialize a TFile object.; TFile implementations providing asynchronous open functionality need to; override this method to run the appropriate checks before calling this; standard initialization part. See TXNetFile::Init for an example. void Close(Option_t* option = """"); Close a file.; If option == ""R"", all TProcessIDs ref",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TFile.html:27270,detect,detect,27270,root/html534/TFile.html,https://root.cern,https://root.cern/root/html534/TFile.html,1,['detect'],['detect']
Safety," will not be compressed.; level = 1, minimal compression level but fast. level = 9, maximal compression level but slower and might use more memory.; (For the currently supported algorithms, the maximum level is 9); If compress is negative it indicates the compression level is not set yet. The enumeration ROOT::ECompressionAlgorithm associates each; algorithm with a number. There is a utility function to help; to set the value of compress. For example,; ROOT::CompressionSettings(ROOT::kLZMA, 1); will build an integer which will set the compression to use; the LZMA algorithm and compression level 1. These are defined; in the header file Compression.h. Note that the compression settings may be changed at any time.; The new compression settings will only apply to branches created; or attached after the setting is changed and other objects written; after the setting is changed. In case the file does not exist or is not a valid ROOT file,; it is made a Zombie. One can detect this situation with a code like:; TFile f(""file.root"");; if (f.IsZombie()) {; cout << ""Error opening file"" << endl;; exit(-1);; }. When opening the file, the system checks the validity of this directory.; If something wrong is detected, an automatic Recovery is performed. In; this case, the file is scanned sequentially reading all logical blocks; and attempting to rebuild a correct directory (see TFile::Recover).; One can disable the automatic recovery procedure when reading one; or more files by setting the environment variable ""TFile::Recover 0""; in the system.rootrc file. TFile(const TFile& ); TFile objects can not be copied. ~TFile(); File destructor. void Init(Bool_t create); Initialize a TFile object.; TFile implementations providing asynchronous open functionality need to; override this method to run the appropriate checks before calling this; standard initialization part. See TXNetFile::Init for an example. void Close(Option_t* option = """"); Close a file.; If option == ""R"", all TProcessIDs ref",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TFile.html:26587,detect,detect,26587,root/html530/TFile.html,https://root.cern,https://root.cern/root/html530/TFile.html,2,['detect'],['detect']
Safety," will not be compressed.; level = 1, minimal compression level but fast. level = 9, maximal compression level but slower and might use more memory.; (For the currently supported algorithms, the maximum level is 9); If compress is negative it indicates the compression level is not set yet. The enumeration ROOT::ECompressionAlgorithm associates each; algorithm with a number. There is a utility function to help; to set the value of compress. For example,; ROOT::CompressionSettings(ROOT::kLZMA, 1); will build an integer which will set the compression to use; the LZMA algorithm and compression level 1. These are defined; in the header file Compression.h. Note that the compression settings may be changed at any time.; The new compression settings will only apply to branches created; or attached after the setting is changed and other objects written; after the setting is changed. In case the file does not exist or is not a valid ROOT file,; it is made a Zombie. One can detect this situation with a code like:; TFile f(""file.root"");; if (f.IsZombie()) {; std::cout << ""Error opening file"" << std::endl;; exit(-1);; }. When opening the file, the system checks the validity of this directory.; If something wrong is detected, an automatic Recovery is performed. In; this case, the file is scanned sequentially reading all logical blocks; and attempting to rebuild a correct directory (see TFile::Recover).; One can disable the automatic recovery procedure when reading one; or more files by setting the environment variable ""TFile.Recover: 0""; in the system.rootrc file. TFile(const TFile& ); TFile objects can not be copied. ~TFile(); File destructor. void Init(Bool_t create); Initialize a TFile object.; TFile implementations providing asynchronous open functionality need to; override this method to run the appropriate checks before calling this; standard initialization part. See TXNetFile::Init for an example. void Close(Option_t* option = """"); Close a file.; If option == ""R"", all TProc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TFile.html:28089,detect,detect,28089,root/html602/TFile.html,https://root.cern,https://root.cern/root/html602/TFile.html,2,['detect'],['detect']
Safety," will return 0; 2211 // for both.; 2212 if (firstbin == 0 && lastbin == 0); 2213 {; 2214 firstbin = 1;; 2215 lastbin = inAxis->GetNbins();; 2216 }; 2217 }; 2218 if (firstbin < 0) firstbin = 0;; 2219 if (lastbin < 0) lastbin = inNbin + 1;; 2220 if (lastbin > inNbin+1) lastbin = inNbin + 1;; 2221 ; 2222 // Create the projection histogram; 2223 char *pname = (char*)name;; 2224 if (name && strcmp(name,expectedName) == 0) {; 2225 Int_t nch = strlen(GetName()) + 4;; 2226 pname = new char[nch];; 2227 snprintf(pname,nch,""%s%s"",GetName(),name);; 2228 }; 2229 TH1D *h1=nullptr;; 2230 //check if histogram with identical name exist; 2231 // if compatible reset and re-use previous histogram; 2232 // (see https://savannah.cern.ch/bugs/?54340); 2233 TObject *h1obj = gROOT->FindObject(pname);; 2234 if (h1obj && h1obj->InheritsFrom(TH1::Class())) {; 2235 if (h1obj->IsA() != TH1D::Class() ) {; 2236 Error(""DoProjection"",""Histogram with name %s must be a TH1D and is a %s"",name,h1obj->ClassName());; 2237 return nullptr;; 2238 }; 2239 h1 = (TH1D*)h1obj;; 2240 // reset the existing histogram and set always the new binning for the axis; 2241 // This avoid problems when the histogram already exists and the histograms is rebinned or its range has changed; 2242 // (see https://savannah.cern.ch/bugs/?94101 or https://savannah.cern.ch/bugs/?95808 ); 2243 h1->Reset();; 2244 const TArrayD *xbins = outAxis->GetXbins();; 2245 if (xbins->fN == 0) {; 2246 if ( originalRange ); 2247 h1->SetBins(outAxis->GetNbins(),outAxis->GetXmin(),outAxis->GetXmax());; 2248 else; 2249 h1->SetBins(lastOutBin-firstOutBin+1,outAxis->GetBinLowEdge(firstOutBin),outAxis->GetBinUpEdge(lastOutBin));; 2250 } else {; 2251 // case variable bins; 2252 if (originalRange ); 2253 h1->SetBins(outAxis->GetNbins(),xbins->fArray);; 2254 else; 2255 h1->SetBins(lastOutBin-firstOutBin+1,&xbins->fArray[firstOutBin-1]);; 2256 }; 2257 }; 2258 ; 2259 Int_t ncuts = 0;; 2260 if (opt.Contains(""["")) {; 2261 ((TH2 *)this)->GetPainter();; 2262 if (f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH2_8cxx_source.html:91312,avoid,avoid,91312,doc/master/TH2_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html,1,['avoid'],['avoid']
Safety," with sections in desired frame; See TBuffer3D.h for explanation of sections, frame etc. Int_t GetBasicColor() const; Get the basic color (0-7). const TBuffer3D & GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; Stub implementation to avoid forcing implementation at this stage. const char * GetPointerName() const; Provide a pointer name containing uid. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Execute mouse actions on this shape. void Draw(Option_t* option = """"); Draw this shape. void Paint(Option_t* option = """"); Paint this shape. void SetOnBoundary(Bool_t ); {;}. Double_t Big(); methods. {return 1.E30;}. Double_t Tolerance(); {return 1.E-10;}. Double_t Capacity() const. void ComputeBBox(). void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm). Bool_t Contains(Double_t* point) const. Bool_t CouldBeCrossed(Double_t* point, Double_t* dir) const. Int_t DistancetoPrimitive(Int_t px, Int_t py). Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step). const char * GetAxisName(Int_t iaxis) const. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const. void GetBoundingCylinder(Double_t* param) const. Int_t GetByteCount() const. Bool_t GetPointsOnSegments(Int_t npoints, Double_t* array) const. Int_t GetFittingBox(const TGeoBBox* parambox, TGeoMatrix* mat, Double_t& dx, Double_t& dy, Double_t& dz) const. Int_t GetId() const; {return fShapeId;}. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const. void GetMeshNumbers(Int_t& , Int_t& , Int_t& ) const; {;}. Int_t GetNmeshVertices() const; {return 0;}. Bool_t IsAssembly() const; {return kFALSE;}. Bool_t IsComposite() const; {return kFALSE;}. Bool_t IsCylType() const. Bool_t IsReflected() const; {return kFALSE;}. Bool_t IsRunTimeShape() const; {return TestShapeBit(kGeoRunT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoShape.html:19354,safe,safe,19354,root/html528/TGeoShape.html,https://root.cern,https://root.cern/root/html528/TGeoShape.html,2,['safe'],['safe']
Safety," words) that can be set in the option string; UseRandomisedTrees choose at each node splitting a random set of variables; UseNvars use UseNvars variables in randomised trees; SeparationType the separation criterion applied in the node splitting; known: GiniIndex; MisClassificationError; CrossEntropy; SDivSqrtSPlusB; nEventsMin: the minimum number of events in a node (leaf criteria, stop splitting); nCuts: the number of steps in the optimisation of the cut for a node (if < 0, then; step size is determined by the events); UseYesNoLeaf decide if the classification is done simply by the node type, or the S/B; (from the training) in the leaf node; NodePurityLimit the minimum purity to classify a node as a signal node (used in pruning and boosting to determine; misclassification error rate); PruneMethod The Pruning method:; known: NoPruning // switch off pruning completely; ExpectedError; CostComplexity; PruneStrength a parameter to adjust the amount of pruning. Should be large enouth such that overtraining is avoided"");. void DeclareCompatibilityOptions(); options that are used ONLY for the READER to ensure backward compatibility. void ProcessOptions(); the option string is decoded, for available options see ""DeclareOptions"". void SetMinNodeSize(Double_t sizeInPercent). void SetMinNodeSize(TString sizeInPercent). void Init( void ); common initialisation with defaults for the DT-Method. ~MethodDT( void ); destructor. void Train( void ). Double_t PruneTree(); prune the decision tree if requested (good for individual trees that are best grown out, and then; pruned back, while boosted decision trees are best 'small' trees to start with. Well, at least the; standard ""optimal pruning algorithms"" don't result in 'weak enough' classifiers !!. Double_t TestTreeQuality(TMVA::DecisionTree* dt). void AddWeightsXMLTo(void* parent) const. void ReadWeightsFromXML(void* wghtnode). void ReadWeightsFromStream(istream& istr). Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__MethodDT.html:22623,avoid,avoided,22623,root/html534/TMVA__MethodDT.html,https://root.cern,https://root.cern/root/html534/TMVA__MethodDT.html,3,['avoid'],['avoided']
Safety," words) that can be set in the option string; UseRandomisedTrees choose at each node splitting a random set of variables; UseNvars use UseNvars variables in randomised trees; SeparationType the separation criterion applied in the node splitting; known: GiniIndex; MisClassificationError; CrossEntropy; SDivSqrtSPlusB; nEventsMin: the minimum number of events in a node (leaf criteria, stop splitting); nCuts: the number of steps in the optimisation of the cut for a node (if < 0, then; step size is determined by the events); UseYesNoLeaf decide if the classification is done simply by the node type, or the S/B; (from the training) in the leaf node; NodePurityLimit the minimum purity to classify a node as a signal node (used in pruning and boosting to determine; misclassification error rate); PruneMethod The Pruning method:; known: NoPruning // switch off pruning completely; ExpectedError; CostComplexity; PruneStrength a parameter to adjust the amount of pruning. Should be large enouth such that overtraining is avoided"");. void ProcessOptions(); the option string is decoded, for available options see ""DeclareOptions"". void Init( void ); common initialisation with defaults for the DT-Method. ~MethodDT( void ); destructor. void Train( void ). Bool_t MonitorBoost(TMVA::MethodBoost* booster). Double_t PruneTree(const Int_t methodIndex). Double_t TestTreeQuality(TMVA::DecisionTree* dt). void AddWeightsXMLTo(void* parent) const. void ReadWeightsFromXML(void* wghtnode). void ReadWeightsFromStream(istream& istr). Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); returns MVA value. void GetHelpMessage() const. const TMVA::Ranking* CreateRanking(). Double_t GetPruneStrength(); { return fPruneStrength; }. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id: MethodDT.h 36966 2010-11-26 09:50:13Z evt $ » Last generated: 2010-11-26 14:27; This page has been automatically generated. For comments or suggestion",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodDT.html:21623,avoid,avoided,21623,root/html528/TMVA__MethodDT.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodDT.html,1,['avoid'],['avoided']
Safety," words) that can be set in the option string; UseRandomisedTrees choose at each node splitting a random set of variables; UseNvars use UseNvars variables in randomised trees; SeparationType the separation criterion applied in the node splitting; known: GiniIndex; MisClassificationError; CrossEntropy; SDivSqrtSPlusB; nEventsMin: the minimum number of events in a node (leaf criteria, stop splitting); nCuts: the number of steps in the optimisation of the cut for a node (if < 0, then; step size is determined by the events); UseYesNoLeaf decide if the classification is done simply by the node type, or the S/B; (from the training) in the leaf node; NodePurityLimit the minimum purity to classify a node as a signal node (used in pruning and boosting to determine; misclassification error rate); PruneMethod The Pruning method:; known: NoPruning // switch off pruning completely; ExpectedError; CostComplexity; PruneStrength a parameter to adjust the amount of pruning. Should be large enouth such that overtraining is avoided"");. void ProcessOptions(); the option string is decoded, for available options see ""DeclareOptions"". void Init( void ); common initialisation with defaults for the DT-Method. ~MethodDT( void ); destructor. void Train( void ). Bool_t MonitorBoost(TMVA::MethodBoost* booster). Double_t PruneTree(const Int_t methodIndex). Double_t TestTreeQuality(TMVA::DecisionTree* dt). void AddWeightsXMLTo(void* parent) const. void ReadWeightsFromXML(void* wghtnode). void ReadWeightsFromStream(istream& istr). Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); returns MVA value. void GetHelpMessage() const. const TMVA::Ranking* CreateRanking(). Double_t GetPruneStrength(); { return fPruneStrength; }. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id: MethodDT.h 39395 2011-05-26 10:05:54Z moneta $ » Last generated: 2011-07-04 15:34; This page has been automatically generated. For comments or suggest",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__MethodDT.html:22243,avoid,avoided,22243,root/html530/TMVA__MethodDT.html,https://root.cern,https://root.cern/root/html530/TMVA__MethodDT.html,1,['avoid'],['avoided']
Safety," words) that can be set in the option string; UseRandomisedTrees choose at each node splitting a random set of variables; UseNvars use UseNvars variables in randomised trees; SeparationType the separation criterion applied in the node splitting; known: GiniIndex; MisClassificationError; CrossEntropy; SDivSqrtSPlusB; nEventsMin: the minimum number of events in a node (leaf criteria, stop splitting); nCuts: the number of steps in the optimisation of the cut for a node (if < 0, then; step size is determined by the events); UseYesNoLeaf decide if the classification is done simply by the node type, or the S/B; (from the training) in the leaf node; NodePurityLimit the minimum purity to classify a node as a signal node (used in pruning and boosting to determine; misclassification error rate); PruneMethod The Pruning method:; known: NoPruning // switch off pruning completely; ExpectedError; CostComplexity; PruneStrength a parameter to adjust the amount of pruning. Should be large enouth such that overtraining is avoided"");. void ProcessOptions(); the option string is decoded, for available options see ""DeclareOptions"". void Init( void ); common initialisation with defaults for the DT-Method. ~MethodDT( void ); destructor. void Train( void ). Bool_t MonitorBoost(TMVA::MethodBoost* booster). Double_t PruneTree(const Int_t methodIndex). Double_t TestTreeQuality(TMVA::DecisionTree* dt). void AddWeightsXMLTo(void* parent) const. void ReadWeightsFromXML(void* wghtnode). void ReadWeightsFromStream(istream& istr). Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); returns MVA value. void GetHelpMessage() const. const TMVA::Ranking* CreateRanking(). Double_t GetPruneStrength(); { return fPruneStrength; }. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id: MethodDT.h 40005 2011-06-27 15:29:10Z stelzer $ » Last generated: 2011-12-02 14:28; This page has been automatically generated. For comments or sugges",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMVA__MethodDT.html:22243,avoid,avoided,22243,root/html532/TMVA__MethodDT.html,https://root.cern,https://root.cern/root/html532/TMVA__MethodDT.html,1,['avoid'],['avoided']
Safety," work is done here. Bool_t ReadBuffer(char* buf, Int_t len); Override TNetFile::ReadBuffer to deal with the xrootd server.; Returns kTRUE in case of errors. Bool_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Pass through to TNetFile implementation which will call back eventually; to our ReadBuffer with 2 arguments to deal with xrootd errors. Bool_t ReadBufferAsync(Long64_t offs, Int_t len); Implementation dealing with the xrootd server.; Returns kTRUE in case of errors.; This is the same as TXNetFile::ReadBuffer but using the async; call from xrootd. Bool_t ReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); Read the nbuf blocks described in arrays pos and len,; where pos[i] is the seek position of block i of length len[i].; Note that for nbuf=1, this call is equivalent to TFile::ReafBuffer; This function is overloaded by TNetFile, TWebFile, etc.; Returns kTRUE in case of failure.; Note: This is the overloading made in TXNetFile, If ReadBuffers; is supported by xrootd it will try to gt the whole list from one single; call avoiding the latency of multiple calls. Bool_t WriteBuffer(const char* buffer, Int_t BufferLength); Override TNetFile::WriteBuffer to deal with the xrootd server.; Returns kTRUE in case of errors. void Init(Bool_t create); Initialize the file. Makes sure that the file is really open before; calling TFile::Init. It may block. Bool_t IsOpen() const; Return kTRUE if the file is open, kFALSE otherwise. TFile::EAsyncOpenStatus GetAsyncOpenStatus(); Return status of asynchronous request. Int_t ReOpen(Option_t* mode); Re-open the file (see TNetFile::ReOpen() or TFile::ReOpen(); for more details). void Close(Option_t* opt = """"); Close the file (see TNetFile::Close() or TFile::Close(); for more details). void Flush(); Flushes un-written data. Int_t SysStat(Int_t fd, Long_t* id, Long64_t* size, Long_t* flags, Long_t* modtime); Override TNetFile::SysStat (see parent's method for more details). Int_t SysClose(Int_t fd); Override TNetFile::SysClo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TXNetFile.html:27499,avoid,avoiding,27499,root/html528/TXNetFile.html,https://root.cern,https://root.cern/root/html528/TXNetFile.html,4,['avoid'],['avoiding']
Safety," wrready, Long_t timeout); Return numbers of sockets that are ready for reading or writing.; Wait a maximum of timeout milliseconds.; Return 0 if timed-out. Return < 0 in case of error.; If rdready and/or wrready are not 0, the lists of sockets with; something to read and/or write are also returned. void SetReady(TSocket* sock); Called by TSocketHandler::Notify() to signal which socket is ready; to be read or written. User should not call this routine. The ready; socket will be returned via the Select() user function.; The Ready(TSocket *sock) signal is emitted. Int_t GetActive(Long_t timeout = -1) const; Return number of sockets in the active list. If timeout > 0, remove from; the list those sockets which did not have any activity since timeout; millisecs. If timeout = 0, then reset activity timestamp on all active; sockets. This time out is typically used if GetActive() is used to see; how many remotes still need to send something. If they pass the timeout; they will be skipped and GetActive() will return 0 and the loop can be; exited. Int_t GetDeActive() const; Return number of sockets in the de-active list. Bool_t IsActive(TSocket* s) const; Check if socket 's' is in the active list. Avoids the duplication; of active list via TMonitor::GetListOfActives(). TList * GetListOfActives() const; Returns a list with all active sockets. This list must be deleted; by the user. DO NOT call Delete() on this list as it will delete; the sockets that are still being used by the monitor. TList * GetListOfDeActives() const; Returns a list with all de-active sockets. This list must be deleted; by the user. DO NOT call Delete() on this list as it will delete; the sockets that are still being used by the monitor. void Ready(TSocket* sock); Emit signal when some socket is ready. void * GetSender(); { return this; }. void Interrupt(); { fInterrupt = kTRUE; }. void ResetInterrupt(); { fInterrupt = kFALSE; }. » Author: Fons Rademakers 09/01/97 » Copyright (C) 1995-2000, Rene Brun and F",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMonitor.html:13005,timeout,timeout,13005,root/html528/TMonitor.html,https://root.cern,https://root.cern/root/html528/TMonitor.html,6,['timeout'],['timeout']
Safety," x.setRange(""left"", 0.0, 4.0); x.setRange(""right"", 6.0, 10.0); ; model2 = ROOT.RooAddPdf(model); r2 = model2.fitTo(data, Range=""left,right"", Save=True, PrintLevel=-1); r2.Print(); ; frame2 = x.frame(Title=""Fit in left/right sideband""); data.plotOn(frame2); model2.plotOn(frame2, VisualizeError=r2); model2.plotOn(frame2); model2.paramOn(frame2); frame2.Draw(); ; ; # Fit in one region; # -------------------------------------------; # Note how restricting the region to only the left tail increases; # the fit uncertainty; ; canv.cd(3); x.setRange(""leftToMiddle"", 0.0, 5.0); ; model3 = ROOT.RooAddPdf(model); r3 = model3.fitTo(data, Range=""leftToMiddle"", Save=True, PrintLevel=-1); r3.Print(); ; frame3 = x.frame(Title=""Fit from left to middle""); data.plotOn(frame3); model3.plotOn(frame3, VisualizeError=r3); model3.plotOn(frame3); model3.paramOn(frame3); frame3.Draw(); ; canv.Draw(); ; canv.SaveAs(""rf204a_extendedLikelihood.png""); [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'signalRange' created with bounds [4,6]; [#1] INFO:Minimization -- p.d.f. provides expected number of events, including extended term in likelihood.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooFi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf204a__extendedLikelihood_8py.html:3855,safe,safe,3855,doc/master/rf204a__extendedLikelihood_8py.html,https://root.cern,https://root.cern/doc/master/rf204a__extendedLikelihood_8py.html,1,['safe'],['safe']
Safety," x2). Data Members; private:. ROOT::Fit::DataRange::RangeIntervalsfRangeslist of all ranges. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; explicit DataRange(unsigned int dim = 1). Default constructor (infinite range). {}. DataRange(double xmin, double xmax). construct a range for [xmin, xmax]. DataRange(double xmin, double xmax, double ymin, double ymax). construct a range for [xmin, xmax] , [ymin, ymax]. DataRange(double xmin, double xmax, double ymin, double ymax, double zmin, double zmax). construct a range for [xmin, xmax] , [ymin, ymax] , [zmin, zmax]. unsigned int NDim() const. get range dimension. { return fRanges.size(); }. unsigned int Size(unsigned int icoord = 0) const. return range size for coordinate icoord (starts from zero); Size == 0 indicates no range is present [-inf, + inf]. bool IsSet() const. return true if a range has been set in any of the coordinates; i.e. when it is not [-inf,+inf] for all coordinates; Avoid in case of multi-dim to loop on all the coordinated and ask the size. const RangeSet & Ranges(unsigned int icoord = 0) const. return the vector of ranges for the coordinate icoord. std::pair<double, double> operator()(unsigned int icoord = 0, unsigned int irange = 0) const. return the i-th range for the coordinate icoord.; Useful method when only one range is present for the given coordinate. void GetRange(unsigned int icoord, double& xmin, double& xmax) const. get the first range for given coordinate. If range does not exist; return -inf, +inf. void GetRange(double& xmin, double& xmax) const. get first range for the x - coordinate. { GetRange(0,xmin,xmax); }. void GetRange(double& xmin, double& xmax, double& ymin, double& ymax) const. get first range for the x and y coordinates. GetRange(0,xmin,xmax). void GetRange(double& xmin, double& xmax, double& ymin, double& ymax, double& zmin, double& zmax) const. get first range for the x and y and z coordinates. ~DataRange(). Destructor (no operatio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Fit__DataRange.html:3376,Avoid,Avoid,3376,root/html528/ROOT__Fit__DataRange.html,https://root.cern,https://root.cern/root/html528/ROOT__Fit__DataRange.html,6,['Avoid'],['Avoid']
Safety," x^{2}deriv^{2}}\sqrt{\sum ai^{2}},; 1106/// \f]; 1107/// where k is the double precision, ai are coefficients used in; 1108/// central difference formulas; 1109/// interpolation error is decreased by making the step size h smaller.; 1110///; 1111/// \author Anna Kreshuk; 1112 ; 1113Double_t TF1::Derivative(Double_t x, Double_t *params, Double_t eps) const; 1114{; 1115 if (GetNdim() > 1) {; 1116 Warning(""Derivative"", ""Function dimension is larger than one"");; 1117 }; 1118 ; 1119 ROOT::Math::RichardsonDerivator rd;; 1120 double xmin, xmax;; 1121 GetRange(xmin, xmax);; 1122 // this is not optimal (should be used the average x instead of the range); 1123 double h = eps * std::abs(xmax - xmin);; 1124 if (h <= 0) h = 0.001;; 1125 double der = 0;; 1126 if (params) {; 1127 ROOT::Math::WrappedTF1 wtf(*(const_cast<TF1 *>(this)));; 1128 wtf.SetParameters(params);; 1129 der = rd.Derivative1(wtf, x, h);; 1130 } else {; 1131 // no need to set parameters used a non-parametric wrapper to avoid allocating; 1132 // an array with parameter values; 1133 ROOT::Math::WrappedFunction<const TF1 & > wf(*this);; 1134 der = rd.Derivative1(wf, x, h);; 1135 }; 1136 ; 1137 gErrorTF1 = rd.Error();; 1138 return der;; 1139 ; 1140}; 1141 ; 1142 ; 1143////////////////////////////////////////////////////////////////////////////////; 1144/// Returns the second derivative of the function at point x,; 1145/// computed by Richardson's extrapolation method (use 2 derivative estimates; 1146/// to compute a third, more accurate estimation); 1147/// first, derivatives with steps h and h/2 are computed by central difference formulas; 1148/// \f[; 1149/// D(h) = \frac{f(x+h) - 2f(x) + f(x-h)}{h^{2}}; 1150/// \f]; 1151/// the final estimate; 1152/// \f[; 1153/// D = \frac{4D(h/2) - D(h)}{3}; 1154/// \f]; 1155/// ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition""; 1156///; 1157/// if the argument params is null, the current function parameters are used,; 1158/// otherwise the parameters in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TF1_8cxx_source.html:40356,avoid,avoid,40356,doc/master/TF1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html,1,['avoid'],['avoid']
Safety," yhat and the true value y. NOT REALLY SURE IF THIS IS CORRECT! — THIS IS NOT USED — ; Definition at line 925 of file RuleFitParams.cxx. ◆ Penalty(). Double_t TMVA::RuleFitParams::Penalty ; (; ); const. This is the ""lasso"" penalty To be used for regression. ; — NOT USED — ; Definition at line 356 of file RuleFitParams.cxx. ◆ Risk() [1/2]. Double_t TMVA::RuleFitParams::Risk ; (; UInt_t ; ind1, . UInt_t ; ind2, . Double_t ; neff . ); const. risk assessment ; Definition at line 314 of file RuleFitParams.cxx. ◆ Risk() [2/2]. Double_t TMVA::RuleFitParams::Risk ; (; UInt_t ; ind1, . UInt_t ; ind2, . Double_t ; neff, . UInt_t ; itau . ); const. risk assessment for tau model <itau> ; Definition at line 334 of file RuleFitParams.cxx. ◆ RiskPath(). Double_t TMVA::RuleFitParams::RiskPath ; (; ); const. inline . Definition at line 108 of file RuleFitParams.h. ◆ RiskPerf() [1/2]. Double_t TMVA::RuleFitParams::RiskPerf ; (; ); const. inline . Definition at line 109 of file RuleFitParams.h. ◆ RiskPerf() [2/2]. Double_t TMVA::RuleFitParams::RiskPerf ; (; UInt_t ; itau); const. inline . Definition at line 110 of file RuleFitParams.h. ◆ RiskPerfTst(). UInt_t TMVA::RuleFitParams::RiskPerfTst ; (; ). Estimates the error rate with the current set of parameters. ; using the <Perf> subsample. Return the tau index giving the lowest error ; Definition at line 1201 of file RuleFitParams.cxx. ◆ SetGDErrScale(). void TMVA::RuleFitParams::SetGDErrScale ; (; Double_t ; s). inline . Definition at line 85 of file RuleFitParams.h. ◆ SetGDNPathSteps(). void TMVA::RuleFitParams::SetGDNPathSteps ; (; Int_t ; np). inline . Definition at line 65 of file RuleFitParams.h. ◆ SetGDPathStep(). void TMVA::RuleFitParams::SetGDPathStep ; (; Double_t ; s). inline . Definition at line 68 of file RuleFitParams.h. ◆ SetGDTau(). void TMVA::RuleFitParams::SetGDTau ; (; Double_t ; t). inline . Definition at line 82 of file RuleFitParams.h. ◆ SetGDTauPrec(). void TMVA::RuleFitParams::SetGDTauPrec ; (; Double_t ; p). in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1RuleFitParams.html:17117,Risk,RiskPerf,17117,doc/master/classTMVA_1_1RuleFitParams.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1RuleFitParams.html,1,['Risk'],['RiskPerf']
Safety," zmin, zmax;. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Int_t IsOnBoundary(const Double_t* point) const; Check if a point in local sphere coordinates is close to a boundary within; shape tolerance. Return values:; 0 - not close to boundary; 1 - close to Rmin boundary; 2 - close to Rmax boundary; 3,4 - close to phi1/phi2 boundary; 5,6 - close to theta1/theta2 boundary. Bool_t IsPointInside(const Double_t* point, Bool_t checkR = kTRUE, Bool_t checkTh = kTRUE, Bool_t checkPh = kTRUE) const; Check if a point is inside radius/theta/phi ranges for the spherical sector. Bool_t Contains(const Double_t* point) const; test if point is inside this sphere; check Rmin<=R<=Rmax. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the sphere; Check if the bounding box is crossed within the requested distance. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the sphere. Double_t DistToSphere(const Double_t* point, const Double_t* dir, Double_t rsph, Bool_t check = kTRUE, Bool_t firstcross = kTRUE) const; compute distance to sphere of radius rsph. Direction has to be a unit vector. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step). const char * GetAxisName(Int_t iaxis) const; Returns name of axis IAXIS. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoSphere.html:15167,safe,safe,15167,root/html534/TGeoSphere.html,https://root.cern,https://root.cern/root/html534/TGeoSphere.html,3,['safe'],['safe']
Safety," { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. Bool_t_allRRVAll contents are RRV; RooLinkedList_listActual object store; TString_nameOur name.; static Int_tRooPrintable::_nameLength; Bool_t_ownContFlag to identify a list that owns its contents.; TNamed*_structureTag! Structure tag; TNamed*_typedStructureTag! Typed structure tag. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsCollection(); Destructor. RooLinkedListIter iterator(Bool_t dir = kIterForward) const. void safeDeleteList(); Examine client server dependencies in list and; delete contents in safe order: any client; is deleted before a server is deleted. RooAbsCollection* snapshot(Bool_t deepCopy = kTRUE) const; Take a snap shot of current collection contents:; An owning collection is returned containing clones of. - Elements in this collection; - External dependents of all elements; and recursively any dependents of those dependents; (if deepCopy flag is set). If deepCopy is specified, the client-server links between the cloned; list elements and the cloned external dependents are reconnected to; each other, making the snapshot a completely self-contained entity. Bool_t snapshot(RooAbsCollection& output, Bool_t deepCopy = kTRUE) const; Take a snap shot of current collection contents:; An owning collection is returned containing clones of. - Elements in this collection; - External dependents of all elements; and recursively any dependents of those dependents; (if deepCopy flag is set). If deepCopy is specified, the client-server links between the cloned; list ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsCollection.html:10167,safe,safeDeleteList,10167,root/html534/RooAbsCollection.html,https://root.cern,https://root.cern/root/html534/RooAbsCollection.html,2,['safe'],"['safe', 'safeDeleteList']"
Safety," {""x""});; std::cout << ""rms of x: "" << std::sqrt(sumSq / n) << std::endl;; nconst Int_t nDefinition legend1.C:16; In multi-thread runs, users are responsible for the thread-safety of the expression passed to Foreach(): thread will execute the expression concurrently. The code above would need to employ some resource protection mechanism to ensure non-concurrent writing of rms; but this is probably too much head-scratch for such a simple operation.; ForeachSlot() can help in this situation. It is an alternative version of Foreach() for which the function takes an additional ""processing slot"" parameter besides the columns it should be applied to. RDataFrame guarantees that ForeachSlot() will invoke the user expression with different slot parameters for different concurrent executions (see Special helper columns: rdfentry_ and rdfslot_ for more information on the slot parameter). We can take advantage of ForeachSlot() to evaluate a thread-safe root mean square of column ""x"": // Thread-safe evaluation of RMS of column ""x"" using ForeachSlot; ROOT::EnableImplicitMT();; const unsigned int nSlots = df.GetNSlots();; std::vector<double> sumSqs(nSlots, 0.);; std::vector<unsigned int> ns(nSlots, 0);; ; df.ForeachSlot([&sumSqs, &ns](unsigned int slot, double x) { sumSqs[slot] += x*x; ns[slot] += 1; }, {""x""});; double sumSq = std::accumulate(sumSqs.begin(), sumSqs.end(), 0.); // sum all squares; unsigned int n = std::accumulate(ns.begin(), ns.end(), 0); // sum all counts; std::cout << ""rms of x: "" << std::sqrt(sumSq / n) << std::endl;; Notice how we created one double variable for each processing slot and later merged their results via std::accumulate. Dataset joins with friend trees; Vertically concatenating multiple trees that have the same columns (creating a logical dataset with the same columns and more rows) is trivial in RDataFrame: just pass the tree name and a list of file names to RDataFrame's constructor, or create a TChain out of the desired trees and pass that to RDa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:69012,safe,safe,69012,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,4,['safe'],['safe']
Safety," {; 5024 // Destroy an array of pointers to not-pre-allocated objects.; 5025 Int_t len = ele->GetArrayLength();; 5026 if (!len) {; 5027 len = 1;; 5028 }; 5029 void** r = (void**) eaddr;; 5030 for (Int_t j = len - 1; j >= 0; --j) {; 5031 if (r[j]) {; 5032 cle->Destructor(r[j]);; 5033 r[j] = 0;; 5034 }; 5035 }; 5036 }; 5037 ; 5038 if (etype == kBase) {; 5039 if (cle->Property() & kIsAbstract) {; 5040 TVirtualStreamerInfo *einfo = cle->GetStreamerInfoAbstractEmulated();; 5041 if (einfo) einfo->Destructor(eaddr, kTRUE);; 5042 } else {; 5043 cle->Destructor(eaddr, kTRUE);; 5044 }; 5045 }; 5046 ; 5047 if (etype == kObject || etype == kAny ||; 5048 etype == kTObject || etype == kTString || etype == kTNamed) {; 5049 // A data member is destroyed, but not deleted.; 5050 cle->Destructor(eaddr, kTRUE);; 5051 }; 5052 ; 5053 if (etype == kSTL) {; 5054 // A data member is destroyed, but not deleted.; 5055 TVirtualCollectionProxy *pr = cle->GetCollectionProxy();; 5056 if (!pr) {; 5057 if (strcmp(ele->GetName(),""This"")==0) {; 5058 // missing information, avoid infinite loop; 5059 // by doing nothing ....; 5060 } else {; 5061 cle->Destructor(eaddr, kTRUE);; 5062 }; 5063 } else {; 5064 if (ele->TestBit(TStreamerElement::kDoNotDelete)) {; 5065 TVirtualCollectionProxy::TPushPop env(cle->GetCollectionProxy(), eaddr); // used for both this 'clear' and the 'clear' inside destructor.; 5066 cle->GetCollectionProxy()->Clear(); // empty the collection without deleting the pointer; 5067 pr->Destructor(eaddr, kTRUE);; 5068 } else {; 5069 pr->Destructor(eaddr, kTRUE);; 5070 }; 5071 }; 5072 }; 5073 ; 5074 if (etype == kObject + kOffsetL || etype == kAny + kOffsetL ||; 5075 etype == kTObject + kOffsetL || etype == kTString + kOffsetL ||; 5076 etype == kTNamed + kOffsetL || etype == kSTL + kOffsetL) {; 5077 // For a data member which is an array of objects, we; 5078 // destroy the objects, but do not delete them.; 5079 Int_t len = ele->GetArrayLength();; 5080 Int_t size = cle->Size();; 5081 char* r",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:201664,avoid,avoid,201664,doc/master/TStreamerInfo_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html,1,['avoid'],['avoid']
Safety," {; 6104 /* For sockets, wait for the socket using poll */; 6105 struct mg_pollfd pfd[1];; 6106 int pollres;; 6107 ; 6108 pfd[0].fd = sock;; 6109 pfd[0].events = POLLOUT;; 6110 pollres = mg_poll(pfd, 1, (int)(ms_wait), &(ctx->stop_flag));; 6111 if (!STOP_FLAG_IS_ZERO(&ctx->stop_flag)) {; 6112 return -2;; 6113 }; 6114 if (pollres > 0) {; 6115 continue;; 6116 }; 6117 }; 6118 ; 6119 if (timeout > 0) {; 6120 now = mg_get_current_time_ns();; 6121 if ((now - start) > timeout_ns) {; 6122 /* Timeout */; 6123 break;; 6124 }; 6125 }; 6126 }; 6127 ; 6128 (void)err; /* Avoid unused warning if NO_SSL is set and DEBUG_TRACE is not; 6129 used */; 6130 ; 6131 return -1;; 6132}; 6133 ; 6134 ; 6135static int; 6136push_all(struct mg_context *ctx,; 6137 FILE *fp,; 6138 SOCKET sock,; 6139 SSL *ssl,; 6140 const char *buf,; 6141 int len); 6142{; 6143 double timeout = -1.0;; 6144 int n, nwritten = 0;; 6145 ; 6146 if (ctx == NULL) {; 6147 return -1;; 6148 }; 6149 ; 6150 if (ctx->dd.config[REQUEST_TIMEOUT]) {; 6151 timeout = atoi(ctx->dd.config[REQUEST_TIMEOUT]) / 1000.0;; 6152 }; 6153 if (timeout <= 0.0) {; 6154 timeout = strtod(config_options[REQUEST_TIMEOUT].default_value, NULL); 6155 / 1000.0;; 6156 }; 6157 ; 6158 while ((len > 0) && STOP_FLAG_IS_ZERO(&ctx->stop_flag)) {; 6159 n = push_inner(ctx, fp, sock, ssl, buf + nwritten, len, timeout);; 6160 if (n < 0) {; 6161 if (nwritten == 0) {; 6162 nwritten = -1; /* Propagate the error */; 6163 }; 6164 break;; 6165 } else if (n == 0) {; 6166 break; /* No more data to write */; 6167 } else {; 6168 nwritten += n;; 6169 len -= n;; 6170 }; 6171 }; 6172 ; 6173 return nwritten;; 6174}; 6175 ; 6176 ; 6177/* Read from IO channel - opened file descriptor, socket, or SSL descriptor.; 6178 * Return value:; 6179 * >=0 .. number of bytes successfully read; 6180 * -1 .. timeout; 6181 * -2 .. error; 6182 */; 6183static int; 6184pull_inner(FILE *fp,; 6185 struct mg_connection *conn,; 6186 char *buf,; 6187 int len,; 6188 double timeout); 6189{; 6190 int nread,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:179446,timeout,timeout,179446,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety," {; 6105 /* For sockets, wait for the socket using poll */; 6106 struct mg_pollfd pfd[1];; 6107 int pollres;; 6108 ; 6109 pfd[0].fd = sock;; 6110 pfd[0].events = POLLOUT;; 6111 pollres = mg_poll(pfd, 1, (int)(ms_wait), &(ctx->stop_flag));; 6112 if (!STOP_FLAG_IS_ZERO(&ctx->stop_flag)) {; 6113 return -2;; 6114 }; 6115 if (pollres > 0) {; 6116 continue;; 6117 }; 6118 }; 6119 ; 6120 if (timeout > 0) {; 6121 now = mg_get_current_time_ns();; 6122 if ((now - start) > timeout_ns) {; 6123 /* Timeout */; 6124 break;; 6125 }; 6126 }; 6127 }; 6128 ; 6129 (void)err; /* Avoid unused warning if NO_SSL is set and DEBUG_TRACE is not; 6130 used */; 6131 ; 6132 return -1;; 6133}; 6134 ; 6135 ; 6136static int; 6137push_all(struct mg_context *ctx,; 6138 FILE *fp,; 6139 SOCKET sock,; 6140 SSL *ssl,; 6141 const char *buf,; 6142 int len); 6143{; 6144 double timeout = -1.0;; 6145 int n, nwritten = 0;; 6146 ; 6147 if (ctx == NULL) {; 6148 return -1;; 6149 }; 6150 ; 6151 if (ctx->dd.config[REQUEST_TIMEOUT]) {; 6152 timeout = atoi(ctx->dd.config[REQUEST_TIMEOUT]) / 1000.0;; 6153 }; 6154 if (timeout <= 0.0) {; 6155 timeout = strtod(config_options[REQUEST_TIMEOUT].default_value, NULL); 6156 / 1000.0;; 6157 }; 6158 ; 6159 while ((len > 0) && STOP_FLAG_IS_ZERO(&ctx->stop_flag)) {; 6160 n = push_inner(ctx, fp, sock, ssl, buf + nwritten, len, timeout);; 6161 if (n < 0) {; 6162 if (nwritten == 0) {; 6163 nwritten = -1; /* Propagate the error */; 6164 }; 6165 break;; 6166 } else if (n == 0) {; 6167 break; /* No more data to write */; 6168 } else {; 6169 nwritten += n;; 6170 len -= n;; 6171 }; 6172 }; 6173 ; 6174 return nwritten;; 6175}; 6176 ; 6177 ; 6178/* Read from IO channel - opened file descriptor, socket, or SSL descriptor.; 6179 * Return value:; 6180 * >=0 .. number of bytes successfully read; 6181 * -1 .. timeout; 6182 * -2 .. error; 6183 */; 6184static int; 6185pull_inner(FILE *fp,; 6186 struct mg_connection *conn,; 6187 char *buf,; 6188 int len,; 6189 double timeout); 6190{; 6191 int nread,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:179478,timeout,timeout,179478,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety," };  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . #include <TTask.h>. Inheritance diagram for TTask:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TTask() [1/3]. TTask::TTask ; (; ). Default constructor invoked when reading a TTask object from a file. ; Definition at line 98 of file TTask.cxx. ◆ TTask() [2/3]. TTask::TTask ; (; const char * ; name, . const char * ; title . ). Standard constructor. ; Definition at line 110 of file TTask.cxx. ◆ ~TTask(). TTask::~TTask ; (; ). virtual . Delete a task and its subtasks. ; Definition at line 168 of file TTask.cxx. ◆ TTask() [3/3]. TTask::TTask ; (; const TTask & ; task). Copy constructor. ; Definition at line 150 of file TTask.cxx. Member Function Documentation. ◆ Abort(). void TTask::Abort ; (; ). virtual . Abort current tree of tasks. ; After this call, the tree of tasks is ready to be executed again. The application must take care of cleaning data structures created by previous executions. ; Definition at line 192 of file TTask.cxx. ◆ Add(). void TTask::Add ; (; TTask * ; task). virtual . Add TTask to this. ; Definition at line 176 of file TTask.cxx. ◆ Browse(). void TTask::Browse ; (; TBrowser * ; b). overridevirtual . Browse the list of tasks. ; It is recommended to add the top level task to the list of ROOT browsables by: gROOT->GetListOfBrowsables()->Add(myTopLevelTask). Reimplemented from TObject.; Definition at line 211 of file TTask.cxx. ◆ Class(). static TClass * TTask::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TTask::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TTask::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTask.html:16531,Abort,Abort,16531,doc/master/classTTask.html,https://root.cern,https://root.cern/doc/master/classTTask.html,1,['Abort'],['Abort']
Safety,"  . Loading...; Searching...; No Matches. List of all members |; Public Types |; Public Member Functions |; Static Public Member Functions |; Private Member Functions |; Private Attributes |; List of all members ; TMVA::KDEKernel Class ReferenceTMVA. ; KDE Kernel for ""smoothing"" the PDFs. ; Definition at line 50 of file KDEKernel.h. Public Types; enum  EKernelBorder { kNoTreatment = 1; , kKernelRenorm = 2; , kSampleMirror = 3; };  ; enum  EKernelIter { kNonadaptiveKDE = 1; , kAdaptiveKDE = 2; };  ; enum  EKernelType { kNone = 0; , kGauss = 1; };  . Public Member Functions;  KDEKernel (EKernelIter kiter=kNonadaptiveKDE, const TH1 *hist=nullptr, Float_t lower_edge=0., Float_t upper_edge=1., EKernelBorder kborder=kNoTreatment, Float_t FineFactor=1.);  constructor sanity check ;  ; virtual ~KDEKernel (void);  destructor ;  ; Float_t GetBinKernelIntegral (Float_t lowr, Float_t highr, Float_t mean, Int_t binnum);  calculates the integral of the Kernel ;  ; const char * GetName () const;  ; virtual TClass * IsA () const;  ; void SetKernelType (EKernelType ktype=kGauss);  fIter == 1 —> nonadaptive KDE fIter == 2 —> adaptive KDE ;  ; virtual void Streamer (TBuffer &);  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  . Private Member Functions; MsgLogger & Log () const;  . Private Attributes; Float_t fFineFactor;  fine tuning factor for Adaptive KDE: factor to multiply the ""width"" of the Kernel function ;  ; TH1F * fFirstIterHist;  histogram to be filled in the hidden iteration ;  ; Bool_t fHiddenIteration;  Defines if whats currently running is the. ;  ; TH1F * fHist;  copy of input histogram ;  ; EKernelIter fIter;  iteration number ;  ; EKernelBorder fKDEborder;  The method to take care about ""border"" effects. ;  ; TF1 * fKernel_integ;  the integral of the Kernel function ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1KDEKernel.html:851,sanity check,sanity check,851,doc/master/classTMVA_1_1KDEKernel.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1KDEKernel.html,1,['sanity check'],['sanity check']
Safety,"  ; ERegularization GetRegularization () const;  ; Scalar_t GetWeightDecay () const;  ; void Initialize (EInitialization m);  Initialize the weights in the net with the initialization method. ;  ; void InitializeGradients ();  Initialize the gradients in the net to zero. ;  ; LayerIterator_t LayersBegin ();  Iterator to the first layer of the net. ;  ; LayerIterator_t LayersEnd ();  Iterator to the last layer of the net. ;  ; Scalar_t Loss (const Matrix_t &Y, const Matrix_t &weights, bool includeRegularization=true) const;  Evaluate the loss function of the net using the activations that are currently stored in the output layer. ;  ; Scalar_t Loss (Matrix_t &X, const Matrix_t &Y, const Matrix_t &weights, bool applyDropout=false, bool includeRegularization=true);  Propagate the input batch X through the net and evaluate the error function for the resulting activations of the output layer. ;  ; void Prediction (Matrix_t &Y_hat, EOutputFunction f) const;  Compute the neural network prediction obtained from applying the output function f to the activation of the last layer in the network. ;  ; void Prediction (Matrix_t &Y_hat, Matrix_t &X, EOutputFunction f);  Compute the neural network prediction obtained from forwarding the batch X through the neural network and applying the output function f to the activation of the last layer in the network. ;  ; void Print ();  ; void SetBatchSize (size_t batchSize);  ; void SetDropoutProbabilities (const std::vector< Double_t > &probabilities);  ; void SetInputWidth (size_t inputWidth);  ; void SetLossFunction (ELossFunction J);  ; void SetRegularization (ERegularization R);  ; void SetWeightDecay (Scalar_t weightDecay);  . Private Attributes; size_t fBatchSize;  Batch size for training and evaluation of the Network. ;  ; Matrix_t fDummy;  Empty matrix for last step in back propagation. ;  ; size_t fInputWidth;  Number of features in a single input event. ;  ; ELossFunction fJ;  The loss function of the network. ;  ; std::vector< L",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TNet.html:4071,Predict,Prediction,4071,doc/master/classTMVA_1_1DNN_1_1TNet.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TNet.html,2,"['Predict', 'predict']","['Prediction', 'prediction']"
Safety,"  ; Long64_t GetSeekInfo () const final;  ; Long64_t GetSize () const final;  Returns the current file size. ;  ; TClass * IsA () const override;  ; Bool_t IsOpen () const final;  return kTRUE if file is opened and can be accessed ;  ; void MakeFree (Long64_t, Long64_t) final;  Mark unused bytes on the file. ;  ; void MakeProject (const char *, const char *=""*"", Option_t *=""new"") final;  Generate source code necessary to access the objects stored in the file. ;  ; void Map () final;  ; void Map (Option_t *) final;  List the contents of a file sequentially. ;  ; void Paint (Option_t *="""") final;  Paint all objects in the file. ;  ; void Print (Option_t *="""") const final;  Print all objects in the file. ;  ; Bool_t ReadBuffer (char *, Int_t) final;  Read a buffer from the file. ;  ; Bool_t ReadBuffer (char *, Long64_t, Int_t) final;  Read a buffer from the file at the offset 'pos' in the file. ;  ; void ReadFree () final;  Read the FREE linked list. ;  ; Int_t Recover () final;  Attempt to recover file if not correctly closed. ;  ; Int_t ReOpen (Option_t *mode) final;  Reopen a file with a different access mode, like from READ to See TFile::Open() for details. ;  ; void ResetErrno () const final;  Method resetting the errno. ;  ; void Seek (Long64_t, ERelativeTo=kBeg) final;  Seek to a specific position in the file. Pos it either kBeg, kCur or kEnd. ;  ; void SetEND (Long64_t) final;  ; void SetStoreStreamerInfos (Bool_t iConvert=kTRUE) final;  If true, all correspondent to file TStreamerInfo objects will be stored in file this allows to apply schema evolution later for this file may be useful, when file used outside ROOT and TStreamerInfo objects does not required Can be changed only for newly created file. ;  ; void SetUsedDtd (Bool_t use=kTRUE) final;  Specify usage of DTD for this file. ;  ; void SetUseNamespaces (Bool_t iUseNamespaces=kTRUE) final;  Specify usage of namespaces in xml file In current implementation every instrumented class in file gets its unique n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTXMLFile.html:3872,Recover,Recover,3872,doc/master/classTXMLFile.html,https://root.cern,https://root.cern/doc/master/classTXMLFile.html,2,"['Recover', 'recover']","['Recover', 'recover']"
Safety,  ; RooAbsReal * _func = nullptr;  Pointer to original input function. ;  ; std::vector< std::unique_ptr< RooAbsTestStatistic > > _gofArray;  ! Array of sub-contexts representing part of the combined test statistic ;  ; GOFOpMode _gofOpMode = Slave;  Operation mode of test statistic instance. ;  ; bool _init = false;  ! Is object initialized ;  ; pRooRealMPFE * _mpfeArray = nullptr;  ! Array of parallel execution frond ends ;  ; RooFit::MPSplit _mpinterl = RooFit::BulkPartition;  Use interleaving strategy rather than N-wise split for partitioning of dataset for multiprocessor-split. ;  ; Int_t _nCPU = 1;  Number of processors to use in parallel calculation mode. ;  ; Int_t _nEvents = 0;  Total number of events in test statistic calculation. ;  ; Int_t _numSets = 1;  Total number of partitions in parallel calculation mode. ;  ; ROOT::Math::KahanSum< double > _offset {0.0};  ! Offset as KahanSum to avoid loss of precision ;  ; RooSetProxy _paramSet;  Parameters of the test statistic (=parameters of the input function) ;  ; const RooArgSet * _projDeps = nullptr;  Pointer to set with projected observables. ;  ; std::string _rangeName;  Name of range in which to calculate test statistic. ;  ; Int_t _setNum = 0;  Partition number of this instance in parallel calculation mode. ;  ; Int_t _simCount = 1;  Total number of component p.d.f.s in RooSimultaneous (if any) ;  ; bool _splitRange = false;  Split rangeName in RooSimultaneous index labels if true. ;  ; const bool _takeGlobalObservablesFromData = false;  If the global observable values are taken from data. ;  ; bool _verbose = false;  Verbose messaging if true. ;  ;  Protected Attributes inherited from RooAbsReal; bool _forceNumInt = false;  Force numerical integration if flag set. ;  ; TString _label;  Plot label for objects value. ;  ; RooFit::UniqueId< RooArgSet >::Value_t _lastNormSetId = RooFit::UniqueId<RooArgSet>::nullval;  Component selection flag for RooAbsPdf::plotCompOn. ;  ; Int_t _plotBins = 100;  Number of,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooChi2Var.html:62304,avoid,avoid,62304,doc/master/classRooChi2Var.html,https://root.cern,https://root.cern/doc/master/classRooChi2Var.html,1,['avoid'],['avoid']
Safety,"  ; TGeoPhysicalNode * FindNextBoundaryOrig (Double_t point[3], Double_t dir[3], Double_t &step, Double_t stepmax=1.E30);  Same functionality as TGeoNavigator::FindNextDaughterBoundary for the parallel world. ;  ; TGeoPhysicalNode * FindNodeBVH (Double_t point[3]);  Finds physical node containing the point. ;  ; TGeoPhysicalNode * FindNodeLoop (Double_t point[3]);  Finds physical node containing the point using simple algorithm (for debugging) ;  ; TGeoPhysicalNode * FindNodeOrig (Double_t point[3]);  Finds physical node containing the point (original version based on TGeoVoxelFinder) ;  ; std::pair< double, double > GetBVHSafetyCandidates (double point[3], std::vector< int > &candidates, double margin=0.) const;  Method to find potentially relevant candidate bounding boxes for safety calculation given a point. ;  ; std::pair< double, double > GetLoopSafetyCandidates (double point[3], std::vector< int > &candidates, double margin=0.) const;  Method to find potentially relevant candidate bounding boxes for safety calculation given a point. ;  ; void InitSafetyVoxel (TGeoVoxelGridIndex const &);  Method to initialize the safety voxel at a specific 3D voxel (grid) index. ;  ; Double_t SafetyBVH (Double_t point[3], Double_t safmax=1.E30);  Compute safety for the parallel world (using pure BVH traversal, mainly for debugging/fallback since VoxelSafety should be faster) ;  ; Double_t SafetyLoop (Double_t point[3], Double_t safmax=1.E30);  Compute safety for the parallel world (trivial loop version for comparison/debugging) ;  ; Double_t SafetyOrig (Double_t point[3], Double_t safmax=1.E30);  Compute safety for the parallel world (original version based on TGeoVoxelFinder) ;  ; void TestVoxelGrid ();  ; Double_t VoxelSafety (Double_t point[3], Double_t safmax=1.E30);  Compute safety for the parallel world used BVH structure with addiditional on-the-fly 3D grid/voxel caching —> essentially an O(1) algorithm !) ;  . Additional Inherited Members;  Protected Types inherited fr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoParallelWorld.html:15987,safe,safety,15987,doc/master/classTGeoParallelWorld.html,https://root.cern,https://root.cern/doc/master/classTGeoParallelWorld.html,1,['safe'],['safety']
Safety,"  ; class  PDFIntegral;  ; struct  PlaceExpr;  ; struct  PlaceExpr< T, D1, D2, D3, D4, A, MatRepSym< T, D1 >, MatRepStd< T, D3, D4 > >;  ; struct  PlaceExpr< T, D1, D2, D3, D4, A, MatRepSym< T, D1 >, MatRepSym< T, D3 > >;  ; struct  PlaceMatrix;  Structure to deal when a submatrix is placed in a matrix. More...;  ; struct  PlaceMatrix< T, D1, D2, D3, D4, MatRepSym< T, D1 >, MatRepStd< T, D3, D4 > >;  ; struct  PlaceMatrix< T, D1, D2, D3, D4, MatRepSym< T, D1 >, MatRepSym< T, D3 > >;  ; struct  PlainParameters;  ; struct  PlusEquals;  Evaluate the expression performing a += operation Need to check whether creating a temporary object with the expression result (like in op: A += A * B ) More...;  ; struct  PlusEquals< T, D1, D2, A, MatRepSym< T, D1 >, MatRepStd< T, D1, D2 > >;  Specialization for symmetrix += general : NOT Allowed operation. More...;  ; struct  PlusEquals< T, D1, D2, A, MatRepSym< T, D1 >, MatRepSym< T, D1 > >;  Specialization for symmetric matrices Evaluate the expression performing a += operation for symmetric matrices Need to have a separate functions to avoid to modify two times the off-diagonal elements (i.e applying two times the expression) Need to check whether creating a temporary object with the expression result (like in op: A += A * B ) More...;  ; class  Polar2D;  Class describing a polar 2D coordinate system based on r and phi Phi is restricted to be in the range [-PI,PI) More...;  ; class  Polar3D;  Class describing a polar coordinate system based on r, theta and phi Phi is restricted to be in the range [-PI,PI) More...;  ; class  Polynomial;  Parametric Function class describing polynomials of order n. More...;  ; class  PositionVector2D;  Class describing a generic position vector (point) in 2 dimensions. More...;  ; class  PositionVector3D;  Class describing a generic position vector (point) in 3 dimensions. More...;  ; class  PtEtaPhiE4D;  Class describing a 4D cylindrical coordinate system using Pt , Phi, Eta and E (or rho, phi, eta ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Math.html:25360,avoid,avoid,25360,doc/master/namespaceROOT_1_1Math.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Math.html,2,['avoid'],['avoid']
Safety,"  ; virtual void UseCurrentStyle ();  Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  . Static Public Member Functions; static Bool_t CheckFile (const char *path, const char *location=0);  CheckFile() returns kTRUE on success and kFALSE on failure. ;  ; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static TString GetDcapPath (const char *path);  Transform the input path into a path usuable by the dcap C library, i.e either dcap://nodename.org/where/filename.root or /pnfs/where/filename.root. ;  ; static const char * GetDcapVersion ();  Return dCache version string. ;  ; static void SetOnError (EOnErrorAction=kOnErrorDefault);  Set on error handler. ;  ; static void SetOpenTimeout (UInt_t secs);  Set file open timeout. ;  ; static void SetReplyHostName (const char *host_name);  Set reply host name. ;  ; static Bool_t Stage (const char *path, UInt_t secs, const char *location=0);  Stage() returns kTRUE on success and kFALSE on failure. ;  ;  Static Public Member Functions inherited from TFile; static TFileOpenHandle * AsyncOpen (const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0);  Submit an asynchronous open request. ;  ; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static Bool_t Cp (const char *src, const char *dst, Bool_t progressbar=kTRUE, UInt_t buffersize=1000000);  Allows to copy file from src to dst URL. ;  ; static TFile *& CurrentFile ();  Return the current ROOT file if any. ;  ; static const char * DeclFileName ();  ; static EAsyncOpenStatus GetAsyncOpenStatus (const char *name);  Get st",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDCacheFile.html:26993,timeout,timeout,26993,doc/master/classTDCacheFile.html,https://root.cern,https://root.cern/doc/master/classTDCacheFile.html,1,['timeout'],['timeout']
Safety,"  ; void PrintCacheInfo () const;  Print the information we have about which basket is currently cached and whether they have been 'used'/'read' from the cache. ;  ; virtual void ReadBasket (TBuffer &b);  Loop on all leaves of this branch to read Basket buffer. ;  ; virtual void Refresh (TBranch *b);  Refresh this branch using new information in b This function is called by TTree::Refresh. ;  ; virtual void Reset (Option_t *option="""");  Reset a Branch. ;  ; virtual void ResetAddress ();  Reset the address of the branch. ;  ; virtual void ResetAfterMerge (TFileMergeInfo *);  Reset a Branch. ;  ; virtual void ResetReadEntry ();  ; virtual void SetAddress (void *add);  Set address of this branch. ;  ; virtual void SetAutoDelete (bool autodel=true);  Set the automatic delete bit. ;  ; virtual void SetBasketSize (Int_t buffsize);  Set the basket size The function makes sure that the basket size is greater than fEntryOffsetlen. ;  ; virtual void SetBufferAddress (TBuffer *entryBuffer);  Set address of this branch directly from a TBuffer to avoid streaming. ;  ; void SetCompressionAlgorithm (Int_t algorithm=ROOT::RCompressionSetting::EAlgorithm::kUseGlobal);  Set compression algorithm. ;  ; void SetCompressionLevel (Int_t level=ROOT::RCompressionSetting::ELevel::kUseMin);  Set compression level. ;  ; void SetCompressionSettings (Int_t settings=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault);  Set compression settings. ;  ; virtual void SetEntries (Long64_t entries);  Set the number of entries in this branch. ;  ; virtual void SetEntryOffsetLen (Int_t len, bool updateSubBranches=false);  Update the default value for the branch's fEntryOffsetLen if and only if it was already non zero (and the new value is not zero) If updateExisting is true, also update all the existing branches. ;  ; virtual void SetFile (const char *filename);  Set file where this branch writes/reads its buffers. ;  ; virtual void SetFile (TFile *file=nullptr);  Set file where this branch writes/",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBranch.html:7870,avoid,avoid,7870,doc/master/classTBranch.html,https://root.cern,https://root.cern/doc/master/classTBranch.html,1,['avoid'],['avoid']
Safety,"  ;  Static Public Member Functions inherited from TAttMarker; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Width_t GetMarkerLineWidth (Style_t style);  Internal helper function that returns the line width of the given marker style (0 = filled marker) ;  ; static Style_t GetMarkerStyleBase (Style_t style);  Internal helper function that returns the corresponding marker style with line width 1 for the given style. ;  . Protected Member Functions; Int_t Fill () override;  Fill a Ntuple with current values in fArgs. ;  ;  Protected Member Functions inherited from TTree; virtual TBranch * BranchImp (const char *branchname, const char *classname, TClass *ptrClass, void *addobj, Int_t bufsize, Int_t splitlevel);  Same as TTree::Branch() with added check that addobj matches className. ;  ; virtual TBranch * BranchImp (const char *branchname, TClass *ptrClass, void *addobj, Int_t bufsize, Int_t splitlevel);  Same as TTree::Branch but automatic detection of the class name. ;  ; virtual TBranch * BranchImpArr (const char *branchname, EDataType datatype, std::size_t N, void *addobj, Int_t bufsize, Int_t splitlevel);  ; virtual TBranch * BranchImpRef (const char *branchname, const char *classname, TClass *ptrClass, void *addobj, Int_t bufsize, Int_t splitlevel);  Same as TTree::Branch but automatic detection of the class name. ;  ; virtual TBranch * BranchImpRef (const char *branchname, TClass *ptrClass, EDataType datatype, void *addobj, Int_t bufsize, Int_t splitlevel);  Same as TTree::Branch but automatic detection of the class name. ;  ; virtual TBranch * BronchExec (const char *name, const char *classname, void *addobj, bool isptrptr, Int_t bufsize, Int_t splitlevel);  Helper function implementing TTree::Bronch and TTree::Branch(const char *name, T &obj);. ;  ; virtual Int_t CheckBranchAddressType (TBranch *branch, TClass *ptrClass, EDataType datatype, bool p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTNtuple.html:39460,detect,detection,39460,doc/master/classTNtuple.html,https://root.cern,https://root.cern/doc/master/classTNtuple.html,2,['detect'],['detection']
Safety,"  CTLogEntry;  CTLogHandlerAbstract TLogHandler base class ;  CTLogManager;  ►NFitNamespace for the fitting classes ;  CBasicFCNBasicFCN class: base class for the objective functions used in the fits It has a reference to the data and th emodel function used in the fit ;  CBinDataClass describing the binned data sets : vectors of x coordinates, y values and optionally error on y values and error on coordinates The dimension of the coordinate is free There are 4 different options: ;  CBinPointObsolete class, no more in use ;  CChi2FCNChi2FCN class for binnned fits using the least square methods ;  CDataOptionsDataOptions : simple structure holding the options on how the data are filled ;  CDataRangeClass describing the range in the coordinates it supports multiple range in a coordinate ;  CDataVectorClass holding the fit data points ;  CDataWrapperClass maintaining a pointer to external data Using this class avoids copying the data when performing a fit NOTE: this class is not thread-safe and should not be used in parallel fits ;  CDummyDeleter;  CFcnAdapter;  CFitConfigClass describing the configuration of the fit, options and parameter settings using the ROOT::Fit::ParameterSettings class ;  CFitDataBase class for all the fit data types ;  CFitResultClass containg the result of the fit and all the related information (fitted parameter values, error, covariance matrix and minimizer result information) Contains a pointer also to the fitted (model) function, modified with the fit parameter values ;  CFitterFitter class, entry point for performing all type of fits ;  CLogLikelihoodFCNLogLikelihoodFCN class for likelihood fits ;  CParameterSettingsClass, describing value, limits and step size of the parameters Provides functionality also to set/retrieve values, step sizes, limits and fix the parameters ;  CPoissonLikelihoodFCNClass evaluating the log likelihood for binned Poisson likelihood fits it is template to distinguish gradient and non-gradient case ;  CSparseData;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/annotated.html:17327,safe,safe,17327,doc/v608/annotated.html,https://root.cern,https://root.cern/doc/v608/annotated.html,1,['safe'],['safe']
Safety,"  Reset this marker attributes to the default values. ;  ; virtual void SaveMarkerAttributes (std::ostream &out, const char *name, Int_t coldef=1, Int_t stydef=1, Int_t sizdef=1);  Save line attributes as C++ statement(s) on output stream out. ;  ; virtual void SetMarkerAttributes ();  Invoke the DialogCanvas Marker attributes. ;  ; virtual void SetMarkerColor (Color_t mcolor=1);  Set the marker color. ;  ; virtual void SetMarkerColorAlpha (Color_t mcolor, Float_t malpha);  Set a transparent marker color. ;  ; virtual void SetMarkerSize (Size_t msize=1);  Set the marker size. ;  ; virtual void SetMarkerStyle (Style_t mstyle=1);  Set the marker style. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Static Public Member Functions; static void AbsValue (Bool_t reject=kTRUE);  Static function: set the fgAbsValue flag. ;  ; static void CalcGaussLegendreSamplingPoints (Int_t num, Double_t *x, Double_t *w, Double_t eps=3.0e-11);  Type safe interface (static method) The number of sampling points are taken from the TGraph. ;  ; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Bool_t DefaultAddToGlobalList (Bool_t on=kTRUE);  Static method to add/avoid to add automatically functions to the global list (gROOT->GetListOfFunctions() ) After having called this static method, all the functions created afterwards will follow the desired behaviour. ;  ; static Double_t DerivativeError ();  Static function returning the error of the last call to the of Derivative's functions. ;  ; static TF1 * GetCurrent ();  Static function returning the current function being processed. ;  ; static void InitStandardFunctions ();  Create the basic function objects. ;  ; static Bool_t RejectedPoint ();  See TF1::RejectPoint above. ;  ; static void RejectPoint (Bool_t reject=kTRUE);  Static function to set the global flag to reject points the fgRejectPoint global flag i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTF1.html:41230,safe,safe,41230,doc/master/classTF1.html,https://root.cern,https://root.cern/doc/master/classTF1.html,1,['safe'],['safe']
Safety,"  Save the partial results of this query to a dedicated file under the user data directory. ;  ; void SetCurrentQuery (TQueryResult *q) override;  Set current query and save previous value. ;  ; void SetDispatchTimer (Bool_t on=kTRUE) override;  Enable/disable the timer to dispatch pening events while processing. ;  ; void SetDrawFeedbackOption (TDrawFeedback *f, Option_t *opt) override;  Set draw feedback option. ;  ; void SetExitStatus (EExitStatus st) override;  ; void SetInitTime () override;  ; void SetMaxDrawQueries (Int_t max) override;  ; void SetMerging (Bool_t=kTRUE) override;  ; void SetOutputFilePath (const char *fp) override;  ; void SetProcessing (Bool_t on=kTRUE);  Set processing bit according to 'on'. ;  ; void SetStopTimer (Bool_t on=kTRUE, Bool_t abort=kFALSE, Int_t timeout=0) override;  Enable/disable the timer to stop/abort processing. ;  ; virtual void StopFeedback ();  Stop feedback (may not be used in this class). ;  ; void StopProcess (Bool_t abort, Int_t timeout=-1) override;  Stop the process after this event. ;  ; void StoreFeedback (TObject *slave, TList *out) override;  Store feedback list (may not be used in this class). ;  ; void StoreOutput (TList *out) override;  Store output list (may not be used in this class). ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void UpdateAutoBin (const char *name, Double_t &xmin, Double_t &xmax, Double_t &ymin, Double_t &ymax, Double_t &zmin, Double_t &zmax) override;  Update automatic binning parameters for given object ""name"". ;  ; void UpdateProgressInfo () override;  Update fProgressStatus. ;  ;  Public Member Functions inherited from TVirtualProofPlayer;  TVirtualProofPlayer ();  ;  ~TVirtualProofPlayer () override;  ; TClass * IsA () const override;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Publi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayer.html:7580,abort,abort,7580,doc/master/classTProofPlayer.html,https://root.cern,https://root.cern/doc/master/classTProofPlayer.html,2,"['abort', 'timeout']","['abort', 'timeout']"
Safety,"  Static Protected Attributes inherited from TMemFile; static constexpr Long64_t fgDefaultBlockSize = 2 * 1024 * 1024;  ;  Static Protected Attributes inherited from TFile; static TList * fgAsyncOpenRequests = nullptr;  ; static std::atomic< Long64_t > fgBytesRead {0};  Number of bytes read by all TFile objects. ;  ; static std::atomic< Long64_t > fgBytesWrite {0};  Number of bytes written by all TFile objects. ;  ; static TString fgCacheFileDir;  Directory where to locally stage files. ;  ; static Bool_t fgCacheFileDisconnected = kTRUE;  Indicates, we trust in the files in the cache dir without stat on the cached file. ;  ; static Bool_t fgCacheFileForce = kFALSE;  Indicates, to force all READ to CACHEREAD. ;  ; static std::atomic< Long64_t > fgFileCounter {0};  Counter for all opened files. ;  ; static Bool_t fgOnlyStaged = kFALSE;  Before the file is opened, it is checked, that the file is staged, if not, the open fails. ;  ; static UInt_t fgOpenTimeout = TFile::kEternalTimeout;  Timeout for open operations in ms - 0 corresponds to blocking i/o. ;  ; static Int_t fgReadaheadSize = 256000;  Readahead buffer size. ;  ; static std::atomic< Int_t > fgReadCalls {0};  Number of bytes read from all TFile objects. ;  ; static Bool_t fgReadInfo = kTRUE;  if true (default) ReadStreamerInfo is called when opening a file ;  ; static ROOT::Internal::RConcurrentHashColl fgTsSIHashes;  !TS Set of hashes built from read streamer infos ;  ;  Static Protected Attributes inherited from TDirectory; static Bool_t fgAddDirectory = kTRUE;  MSVC doesn't support = ATOMIC_FLAG_INIT;. ;  . #include <ROOT/TBufferMerger.hxx>. Inheritance diagram for ROOT::TBufferMergerFile:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TBufferMergerFile() [1/3]. ROOT::TBufferMergerFile::TBufferMergerFile ; (; TBufferMerger & ; m). private . Constructor. ; Can only be called by TBufferMerger. Parameters. mMerger this f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1TBufferMergerFile.html:44060,Timeout,Timeout,44060,doc/v632/classROOT_1_1TBufferMergerFile.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1TBufferMergerFile.html,2,['Timeout'],['Timeout']
Safety,"  Static Protected Attributes inherited from TMemFile; static constexpr Long64_t fgDefaultBlockSize = 2 * 1024 * 1024;  ;  Static Protected Attributes inherited from TFile; static TList * fgAsyncOpenRequests = nullptr;  ; static std::atomic< Long64_t > fgBytesRead {0};  Number of bytes read by all TFile objects. ;  ; static std::atomic< Long64_t > fgBytesWrite {0};  Number of bytes written by all TFile objects. ;  ; static TString fgCacheFileDir;  Directory where to locally stage files. ;  ; static Bool_t fgCacheFileDisconnected = kTRUE;  Indicates, we trust in the files in the cache dir without stat on the cached file. ;  ; static Bool_t fgCacheFileForce = kFALSE;  Indicates, to force all READ to CACHEREAD. ;  ; static std::atomic< Long64_t > fgFileCounter {0};  Counter for all opened files. ;  ; static Bool_t fgOnlyStaged = kFALSE;  Before the file is opened, it is checked, that the file is staged, if not, the open fails. ;  ; static UInt_t fgOpenTimeout = TFile::kEternalTimeout;  Timeout for open operations in ms - 0 corresponds to blocking i/o. ;  ; static Int_t fgReadaheadSize = 256000;  Readahead buffer size. ;  ; static std::atomic< Int_t > fgReadCalls {0};  Number of bytes read from all TFile objects. ;  ; static Bool_t fgReadInfo = kTRUE;  if true (default) ReadStreamerInfo is called when opening a file ;  ; static ROOT::Internal::RConcurrentHashColl fgTsSIHashes;  !TS Set of hashes built from read streamer infos ;  ;  Static Protected Attributes inherited from TDirectory; static Bool_t fgAddDirectory = kTRUE;  MSVC doesn't support = ATOMIC_FLAG_INIT;. ;  . #include <TParallelMergingFile.h>. Inheritance diagram for TParallelMergingFile:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TParallelMergingFile(). TParallelMergingFile::TParallelMergingFile ; (; const char * ; filename, . Option_t * ; option = """", . const char * ; ftitle = """", . Int_t ; compress = ROOT::RCompr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTParallelMergingFile.html:43465,Timeout,Timeout,43465,doc/master/classTParallelMergingFile.html,https://root.cern,https://root.cern/doc/master/classTParallelMergingFile.html,1,['Timeout'],['Timeout']
Safety,"  TEveElementListProjected;  A projected element list – required for proper propagation of render state to projected views. More...;  ; class  TEveEventManager;  Base class for event management and navigation. More...;  ; class  TEveException;  Exception class thrown by TEve classes and macros. More...;  ; class  TEveFrameBox;  Description of a 2D or 3D frame that can be used to visually group a set of objects. More...;  ; class  TEveFrameBoxGL;  A class encapsulating GL rendering of TEveFrameBox via a static member function. More...;  ; class  TEveGDoubleValuator;  Composite GUI element for selection of range (label, two number-entries and double-slider). More...;  ; class  TEveGedEditor;  Specialization of TGedEditor for proper update propagation to TEveManager. More...;  ; class  TEveGedNameFrame;  Specialization of TGedNameFrame used in EVE. More...;  ; class  TEveGedNameTextButton;  Specialization of TGTextButton for EVE name frame. More...;  ; class  TEveGeoManagerHolder;  Exception safe wrapper for setting gGeoManager. More...;  ; class  TEveGeoNode;  Wrapper for TGeoNode that allows it to be shown in GUI and controlled as a TEveElement. More...;  ; class  TEveGeoNodeEditor;  Editor for TEveGeoNode class. More...;  ; class  TEveGeoPolyShape;  Description of TEveGeoPolyShape. More...;  ; class  TEveGeoShape;  Wrapper for TGeoShape with absolute positioning and color attributes allowing display of extracted TGeoShape's (without an active TGeoManager) and simplified geometries (needed for non-linear projections). More...;  ; class  TEveGeoShapeExtract;  Globally positioned TGeoShape with rendering attributes and an optional list of daughter shape-extracts. More...;  ; class  TEveGeoShapeProjected;  A 3D projected TEveGeoShape. More...;  ; class  TEveGeoTopNode;  A wrapper over a TGeoNode, possibly displaced with a global trasformation stored in TEveElement. More...;  ; class  TEveGeoTopNodeEditor;  Editor for TEveGeoTopNode class. More...;  ; class  TEveGListTre",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__TEve.html:7013,safe,safe,7013,doc/master/group__TEve.html,https://root.cern,https://root.cern/doc/master/group__TEve.html,1,['safe'],['safe']
Safety,"  flag that last geometric step was null ;  ; TGeoHMatrix * fGlobalMatrix;  current stored global matrix ;  ; Bool_t fIsEntering;  flag a safe start for point classification ;  ; Bool_t fIsExiting;  flag if current step just got into a new node ;  ; Bool_t fIsNullStep;  flag that a new point is in the same node as previous ;  ; Bool_t fIsOnBoundary;  flag that current point is outside geometry ;  ; Bool_t fIsOutside;  flag that next geometric step will exit current volume ;  ; Bool_t fIsSameLocation;  flag that current point is on some boundary ;  ; Bool_t fIsStepEntering;  flag that current track is about to leave current node ;  ; Bool_t fIsStepExiting;  flag that next geometric step will enter new volume ;  ; TGeoNode * fLastNode;  top physical node ;  ; Double_t fLastPoint [3];  current direction ;  ; Double_t fLastPWSafety {-1};  last point for which parallel world safety was ""evaluated"" ;  ; Double_t fLastPWSaftyPnt [3];  last point for which safety was computed ;  ; Double_t fLastSafety;  safety radius from current point ;  ; Int_t fLevel;  thread id for this navigator ;  ; Int_t fNextDaughterIndex;  number of overlapping nodes on current branch ;  ; TGeoNode * fNextNode;  last searched node ;  ; Int_t fNmany;  current geometry level; ;  ; Double_t fNormal [3];  last computed safety radius ;  ; Int_t * fOverlapClusters;  current recursive position in fOverlapClusters ;  ; Int_t fOverlapMark;  current size of fOverlapClusters ;  ; Int_t fOverlapSize;  next daughter index after FindNextBoundary ;  ; TString fPath;  current local matrix of the selected division cell ;  ; Double_t fPoint [3];  unit vector to current checked shape ;  ; Double_t fSafety;  step to be done from current point and direction ;  ; Bool_t fSearchOverlaps;  internal array for overlaps ;  ; Bool_t fStartSafe;  flags the type of the current node ;  ; Double_t fStep;  ; Int_t fThreadId;  last safety returned from parallel world (negative if invalid) ;  ; TGeoNode * fTopNode;  current node ;  .",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoNavigator.html:20341,safe,safety,20341,doc/master/classTGeoNavigator.html,https://root.cern,https://root.cern/doc/master/classTGeoNavigator.html,3,['safe'],['safety']
Safety," ◆ DistFromInside(). Double_t TGeoCompositeShape::DistFromInside ; (; const Double_t * ; point, . const Double_t * ; dir, . Int_t ; iact = 1, . Double_t ; step = TGeoShape::Big(), . Double_t * ; safe = nullptr . ); const. overridevirtual . Compute distance from inside point to outside of this composite shape. ; Reimplemented from TGeoBBox.; Definition at line 357 of file TGeoCompositeShape.cxx. ◆ DistFromInside_v(). void TGeoCompositeShape::DistFromInside_v ; (; const Double_t * ; points, . const Double_t * ; dirs, . Double_t * ; dists, . Int_t ; vecsize, . Double_t * ; step . ); const. overridevirtual . Compute distance from array of input points having directions specified by dirs. Store output in dists. ; Reimplemented from TGeoBBox.; Definition at line 607 of file TGeoCompositeShape.cxx. ◆ DistFromOutside(). Double_t TGeoCompositeShape::DistFromOutside ; (; const Double_t * ; point, . const Double_t * ; dir, . Int_t ; iact = 1, . Double_t ; step = TGeoShape::Big(), . Double_t * ; safe = nullptr . ); const. overridevirtual . Compute distance from outside point to this composite shape. ; Check if the bounding box is crossed within the requested distance ; Reimplemented from TGeoBBox.; Definition at line 343 of file TGeoCompositeShape.cxx. ◆ DistFromOutside_v(). void TGeoCompositeShape::DistFromOutside_v ; (; const Double_t * ; points, . const Double_t * ; dirs, . Double_t * ; dists, . Int_t ; vecsize, . Double_t * ; step . ); const. overridevirtual . Compute distance from array of input points having directions specified by dirs. Store output in dists. ; Reimplemented from TGeoBBox.; Definition at line 617 of file TGeoCompositeShape.cxx. ◆ Divide(). TGeoVolume * TGeoCompositeShape::Divide ; (; TGeoVolume * ; voldiv, . const char * ; divname, . Int_t ; iaxis, . Int_t ; ndiv, . Double_t ; start, . Double_t ; step . ). overridevirtual . Divide all range of iaxis in range/step cells. ; Reimplemented from TGeoBBox.; Definition at line 368 of file TGeoCompositeShape.cxx",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoCompositeShape.html:38579,safe,safe,38579,doc/master/classTGeoCompositeShape.html,https://root.cern,https://root.cern/doc/master/classTGeoCompositeShape.html,1,['safe'],['safe']
Safety," ◆ DistFromInside(). Double_t TGeoTubeSeg::DistFromInside ; (; const Double_t * ; point, . const Double_t * ; dir, . Int_t ; iact = 1, . Double_t ; step = TGeoShape::Big(), . Double_t * ; safe = nullptr . ); const. overridevirtual . Reimplemented from TGeoTube. ◆ DistFromInside_v(). void TGeoTubeSeg::DistFromInside_v ; (; const Double_t * ; points, . const Double_t * ; dirs, . Double_t * ; dists, . Int_t ; vecsize, . Double_t * ; step . ); const. overridevirtual . Reimplemented from TGeoTube. ◆ DistFromInsideS(). static Double_t TGeoTubeSeg::DistFromInsideS ; (; const Double_t * ; point, . const Double_t * ; dir, . Double_t ; rmin, . Double_t ; rmax, . Double_t ; dz, . Double_t ; c1, . Double_t ; s1, . Double_t ; c2, . Double_t ; s2, . Double_t ; cm, . Double_t ; sm, . Double_t ; cdfi . ). static . ◆ DistFromOutside(). Double_t TGeoTubeSeg::DistFromOutside ; (; const Double_t * ; point, . const Double_t * ; dir, . Int_t ; iact = 1, . Double_t ; step = TGeoShape::Big(), . Double_t * ; safe = nullptr . ); const. overridevirtual . Reimplemented from TGeoTube. ◆ DistFromOutside_v(). void TGeoTubeSeg::DistFromOutside_v ; (; const Double_t * ; points, . const Double_t * ; dirs, . Double_t * ; dists, . Int_t ; vecsize, . Double_t * ; step . ); const. overridevirtual . Reimplemented from TGeoTube. ◆ DistFromOutsideS(). static Double_t TGeoTubeSeg::DistFromOutsideS ; (; const Double_t * ; point, . const Double_t * ; dir, . Double_t ; rmin, . Double_t ; rmax, . Double_t ; dz, . Double_t ; c1, . Double_t ; s1, . Double_t ; c2, . Double_t ; s2, . Double_t ; cm, . Double_t ; sm, . Double_t ; cdfi . ). static . ◆ Divide(). TGeoVolume * TGeoTubeSeg::Divide ; (; TGeoVolume * ; voldiv, . const char * ; divname, . Int_t ; iaxis, . Int_t ; ndiv, . Double_t ; start, . Double_t ; step . ). overridevirtual . Reimplemented from TGeoTube. ◆ GetAxisRange(). Double_t TGeoTubeSeg::GetAxisRange ; (; Int_t ; iaxis, . Double_t & ; xlo, . Double_t & ; xhi . ); const. overridevirtual . Reimplement",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoTubeSeg.html:28651,safe,safe,28651,doc/master/classTGeoTubeSeg.html,https://root.cern,https://root.cern/doc/master/classTGeoTubeSeg.html,1,['safe'],['safe']
Safety," ◆ SetROOTVersion(). void TSlave::SetROOTVersion ; (; const char * ; rv). inline . Definition at line 159 of file TSlave.h. ◆ SetSessionTag(). void TSlave::SetSessionTag ; (; const char * ; st). inline . Definition at line 161 of file TSlave.h. ◆ SetSocket(). void TSlave::SetSocket ; (; TSocket * ; s). inlineprotected . Definition at line 112 of file TSlave.h. ◆ SetStatus(). virtual void TSlave::SetStatus ; (; Int_t ; st). inlineprotectedvirtual . Definition at line 113 of file TSlave.h. ◆ SetTXSlaveHook(). void TSlave::SetTXSlaveHook ; (; TSlave_t ; xslavehook). static . Set hook to TXSlave ctor. ; Definition at line 665 of file TSlave.cxx. ◆ SetupServ(). Int_t TSlave::SetupServ ; (; Int_t ; stype, . const char * ; conffile . ). virtual . Init a PROOF slave object. ; Called via the TSlave ctor. The Init method is technology specific and is overwritten by derived classes. ; Reimplemented in TSlaveLite.; Definition at line 178 of file TSlave.cxx. ◆ StopProcess(). void TSlave::StopProcess ; (; Bool_t ; abort, . Int_t ; timeout . ). protectedvirtual . Sent stop/abort request to PROOF server. ; Definition at line 629 of file TSlave.cxx. ◆ Streamer(). void TSlave::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject.; Reimplemented in TSlaveLite. ◆ StreamerNVirtual(). void TSlave::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 167 of file TSlave.h. ◆ Touch(). virtual void TSlave::Touch ; (; ). inlinevirtual . Definition at line 165 of file TSlave.h. Friends And Related Symbol Documentation. ◆ TProof. friend class TProof. friend . Definition at line 48 of file TSlave.h. ◆ TProofLite. friend class TProofLite. friend . Definition at line 49 of file TSlave.h. ◆ TSlaveLite. friend class TSlaveLite. friend . Definition at line 50 of file TSlave.h. ◆ TXSlave. friend class TXSlave. friend . Definition at line 51 of file TSlave.h. Member Data Documentation. ◆ fArchComp. TStr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSlave.html:23636,abort,abort,23636,doc/master/classTSlave.html,https://root.cern,https://root.cern/doc/master/classTSlave.html,1,['abort'],['abort']
Safety," ◆ fInputShape. std::vector<size_t> TMVA::MethodDL::fInputShape. private . Contains the batch size (no. ; of images in the batch), input depth (no. channels) and further input dimensions of the data (image height, width ...) ; Definition at line 178 of file MethodDL.h. ◆ fLayoutString. TString TMVA::MethodDL::fLayoutString. private . The string defining the layout of the deep net. ; Definition at line 194 of file MethodDL.h. ◆ fLossFunction. DNN::ELossFunction TMVA::MethodDL::fLossFunction. private . The loss function. ; Definition at line 190 of file MethodDL.h. ◆ fNet. std::unique_ptr<DeepNetImpl_t> TMVA::MethodDL::fNet. private . Definition at line 209 of file MethodDL.h. ◆ fNumValidationString. TString TMVA::MethodDL::fNumValidationString. private . The string defining the number (or percentage) of training data used for validation. ; Definition at line 199 of file MethodDL.h. ◆ fOutputFunction. DNN::EOutputFunction TMVA::MethodDL::fOutputFunction. private . The output function for making the predictions. ; Definition at line 189 of file MethodDL.h. ◆ fRandomSeed. size_t TMVA::MethodDL::fRandomSeed. private . The random seed used to initialize the weights and shuffling batches (default is zero) ; Definition at line 186 of file MethodDL.h. ◆ fResume. bool TMVA::MethodDL::fResume. private . Definition at line 200 of file MethodDL.h. ◆ fSettings. KeyValueVector_t TMVA::MethodDL::fSettings. private . Map for the training strategy. ; Definition at line 203 of file MethodDL.h. ◆ fTrainingSettings. std::vector<TTrainingSettings> TMVA::MethodDL::fTrainingSettings. private . The vector defining each training strategy. ; Definition at line 204 of file MethodDL.h. ◆ fTrainingStrategyString. TString TMVA::MethodDL::fTrainingStrategyString. private . The string defining the training strategy. ; Definition at line 196 of file MethodDL.h. ◆ fWeightInitialization. DNN::EInitialization TMVA::MethodDL::fWeightInitialization. private . The initialization method. ; Definition at li",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodDL.html:54259,predict,predictions,54259,doc/master/classTMVA_1_1MethodDL.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodDL.html,1,['predict'],['predictions']
Safety,"!!!!!!!!!!1. void PrintResults(Int_t level, Double_t amin) const. void ReleaseParameter(Int_t ipar). void SetFitMethod(const char* name). Int_t SetParameter(Int_t ipar, const char* parname, Double_t value, Double_t verr, Double_t vlow, Double_t vhigh). void SetFCN(void fcn); this for CINT (interactive functions). void SetFCN(void* ). void SetMinuitFCN(ROOT::Minuit2::FCNBase* f); set FCN using Minuit interface; you pass to the class ownership of FCNBase pointer. const ROOT::Minuit2::FCNBase * GetMinuitFCN() const; { return fMinuitFCN; }. const ROOT::Minuit2::ModularFunctionMinimizer * GetMinimizer() const; { return fMinimizer; }. int Minimize(int nfcn = 0, double edmval = 0.1); additional abstract methods to be implemented by derived classes. int GetStrategy(); { return fStrategy; }. int PrintLevel(); { return fDebug; }. void SetStrategy(int stra); { fStrategy = stra; }. void SetPrintLevel(int level); { fDebug = level; }. void SetMinimumTolerance(double mintol); set minimum tolerance to avoid having clients (as TGraf::Fit) setting tolerances too small. { fMinTolerance = mintol; }. double MinimumTolerance() const; { return fMinTolerance; }. void CreateMinimizer(TFitterMinuit::EMinimizerType = kMigrad); create the minimizer type (Migard or Simplex); can be re-implemented in the derived classes. void SetMinimizer(ROOT::Minuit2::ModularFunctionMinimizer* m); { fMinimizer = m; }. void CreateChi2FCN(); functions to create FCN - re-implemented in derived class (GFumili). void CreateChi2ExtendedFCN(). void CreateBinLikelihoodFCN(). void CreateUnbinLikelihoodFCN(); {}. ROOT::Minuit2::FunctionMinimum DoMinimization(int nfcn = 0, double edmval = 0.1); internal function to perform the actual minimization (could be implemented by derived classes). int ExamineMinimum(const ROOT::Minuit2::FunctionMinimum& ); internal funcition to study Function minimum results; return 0 if function minimum is OK or an error code. void Initialize(). » Author: L. Moneta 10/2005 » Copyright (c) 2005 RO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFitterMinuit.html:13585,avoid,avoid,13585,root/html528/TFitterMinuit.html,https://root.cern,https://root.cern/root/html528/TFitterMinuit.html,4,['avoid'],['avoid']
Safety,""""") const; virtual TBuffer3D*MakeBuffer3D() const; voidTObject::MayNotUse(const char* method) const; static voidTGeoShape::NormalPhi(Double_t* point, Double_t* dir, Double_t* norm, Double_t c1, Double_t s1, Double_t c2, Double_t s2); virtual Bool_tTObject::Notify(); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tTGeoBBox::Safety(Double_t* point, Bool_t in = kTRUE) const; static Double_tTGeoShape::SafetyPhi(Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTGeoBBox::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidTGeoBBox::SetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetFromFaceSet(TGLFaceSet* fs); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTGeoBBox::SetPoints(Double_t* points) const; virtual voidTGeoBB",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEveGeoPolyShape.html:7752,Safe,Safety,7752,root/html528/TEveGeoPolyShape.html,https://root.cern,https://root.cern/root/html528/TEveGeoPolyShape.html,1,['Safe'],['Safety']
Safety,""""", Option_t* option = """") constMENU ; virtual Int_tSavePartialResults(Bool_t queryend = kFALSE, Bool_t force = kFALSE); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetCurrentQuery(TQueryResult* q); virtual voidSetDispatchTimer(Bool_t on = kTRUE); virtual voidSetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetExitStatus(TVirtualProofPlayer::EExitStatus st); virtual voidSetInitTime(); virtual voidSetMaxDrawQueries(Int_t max); virtual voidSetMerging(Bool_t = kTRUE); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetOutputFilePath(const char* fp); voidSetProcessing(Bool_t on = kTRUE); virtual voidSetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStopFeedback(); virtual voidStopProcess(Bool_t abort, Int_t timeout = -1); virtual voidStoreFeedback(TObject* slave, TList* out); virtual voidStoreOutput(TList* out); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TProofPlayer(TProof* proof = 0); TProofPlayer(const TProofPlayer&); virtual voidUpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidUpdateProgressInfo(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TProofPlayer.html:10679,abort,abort,10679,root/html604/TProofPlayer.html,https://root.cern,https://root.cern/root/html604/TProofPlayer.html,2,"['abort', 'timeout']","['abort', 'timeout']"
Safety,""") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit const RooAbsArg &testArg const { return observableOverlaps(dset,testArg);  ; const RooAbsArg &testArg const { return observableOverlaps(depList, testArg);  ;  Static Protected Member Functions inherited from RooAbsReal; static void globalSelectComp (bool flag);  Global switch controlling the activation of the selectComp() functionality. ;  ;  Static Protected Member Functions inherited from RooAbsArg; static void ioStreamerPass2Finalize ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include </home/sftnight/build/workspace/root-makedoc-master/rootspi/rdoc/src/master/roofit/roofitcore/src/RooRealMPFE.h>. Inheritance diagram for RooRealMPFE:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Enumeration Documentation. ◆ Message. enum RooRealMPFE::Message. protected . EnumeratorSendReal ; SendCat ; Calculate ; Retrieve ; ReturnValue ; Terminate ; ConstOpt ; Verbose ; LogEvalError ; ApplyNLLW2 ; EnableOffset ; CalculateNoOffset . Definition at line 62 of file RooRealMPFE.h. ◆ State. enum RooRealMPFE::State. protected . EnumeratorInitialize ; Client ; Server ; Inline . Definition at line 59 of file RooRealMPFE.h. Constructor & Destructor Documentation. ◆ RooRealMPFE() [1/2]. RooRealMPFE::RooRealMPFE ; (; const char * ; name, . const char * ; title, . RooAbsReal & ; arg, . bool ; calcInline = false . ). Construct fro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooRealMPFE.html:62907,Avoid,Avoids,62907,doc/master/classRooRealMPFE.html,https://root.cern,https://root.cern/doc/master/classRooRealMPFE.html,1,['Avoid'],['Avoids']
Safety,""") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit const RooAbsArg &testArg const { return observableOverlaps(dset,testArg);  ; const RooAbsArg &testArg const { return observableOverlaps(depList, testArg);  ;  Static Protected Member Functions inherited from RooAbsReal; static void globalSelectComp (bool flag);  Global switch controlling the activation of the selectComp() functionality. ;  ;  Static Protected Member Functions inherited from RooAbsArg; static void ioStreamerPass2Finalize ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooAbsCachedReal.h>. Inheritance diagram for RooAbsCachedReal:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Typedef Documentation. ◆ CacheElem. using RooAbsCachedReal::CacheElem = FuncCacheElem. protected . Definition at line 89 of file RooAbsCachedReal.h. Constructor & Destructor Documentation. ◆ RooAbsCachedReal() [1/3]. RooAbsCachedReal::RooAbsCachedReal ; (; ). inline . Definition at line 27 of file RooAbsCachedReal.h. ◆ RooAbsCachedReal() [2/3]. RooAbsCachedReal::RooAbsCachedReal ; (; const char * ; name, . const char * ; title, . Int_t ; ipOrder = 0 . ). Constructor. ; Definition at line 50 of file RooAbsCachedReal.cxx. ◆ RooAbsCachedReal() [3/3]. RooAbsCachedReal::RooAbsCachedReal ; (; const RooAbsCachedReal & ; other, . const char * ; name = nullptr . ). Copy constructor. ; Definition at line 63 of file RooAb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsCachedReal.html:61803,Avoid,Avoids,61803,doc/master/classRooAbsCachedReal.html,https://root.cern,https://root.cern/doc/master/classRooAbsCachedReal.html,1,['Avoid'],['Avoids']
Safety,"""); Check illegal overlaps for volume VOL within a limit OVLP. void PrintOverlaps() const; Print the current list of overlaps held by the manager class. void CheckPoint(Double_t x = 0, Double_t y = 0, Double_t z = 0, Option_t* option = """"); --- Draw point (x,y,z) over the picture of the daughers of the volume containing this point.; Generates a report regarding the path to the node containing this point and the distance to; the closest boundary. void CheckShape(TGeoShape* shape, Int_t testNo, Int_t nsamples, Option_t* option); Test for shape navigation methods. Summary for test numbers:; 1: DistFromInside/Outside. Sample points inside the shape. Generate; directions randomly in cos(theta). Compute DistFromInside and move the; point with bigger distance. Compute DistFromOutside back from new point.; Plot d-(d1+d2); 2: Safety test. Sample points inside the bounding and compute safety. Generate; directions randomly in cos(theta) and compute distance to boundary. Check if; Distance to boundary is bigger than safety. void ShapeDistances(TGeoShape* shape, Int_t nsamples, Option_t* option); Test TGeoShape::DistFromInside/Outside. Sample points inside the shape. Generate; directions randomly in cos(theta). Compute d1 = DistFromInside and move the; point on the boundary. Compute DistFromOutside and propagate with d2 making sure that; the shape is not re-entered. Swap direction and call DistFromOutside that; should fall back on the same point on the boundary (at d2). Propagate back on boundary; then compute DistFromInside that should be bigger than d1.; Plot d-(d1+d2). void ShapeSafety(TGeoShape* shape, Int_t nsamples, Option_t* option); Check of validity of safe distance for a given shape.; Sample points inside the 2x bounding box and compute safety. Generate; directions randomly in cos(theta) and compute distance to boundary. Check if; distance to boundary is bigger than safety. void ShapeNormal(TGeoShape* shape, Int_t nsamples, Option_t* option); Check of validity of the n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoChecker.html:15050,safe,safety,15050,root/html530/TGeoChecker.html,https://root.cern,https://root.cern/root/html530/TGeoChecker.html,5,['safe'],['safety']
Safety,""", ""Any files (*)"", ""Image files (*png *.jpg)"" Should be specified before starting dialog. ;  ; void SetSelectedFilter (const std::string &name);  Configure selected filter Has to be one of the string from NameFilters entry. ;  ; void SetWorkingPath (const std::string &);  Change current working path of file dialog If dialog already shown, change will be immediately applied. ;  ; void Show (const RWebDisplayArgs &args="""");  Show or update RFileDialog in web window If web window already started - just refresh it like ""reload"" button does Reset result of file selection (if any) ;  . Static Public Member Functions; static std::shared_ptr< RFileDialog > Embed (const std::shared_ptr< RWebWindow > &window, unsigned connid, const std::string &args);  Create dialog instance to use as embedded dialog inside other widget Embedded dialog started on the client side where FileDialogController.SaveAs() method called Such method immediately send message with ""FILEDIALOG:"" prefix On the server side widget should detect such message and call RFileDialog::Embed() providing received string as second argument. ;  ; static bool IsMessageToStartDialog (const std::string &msg);  Check if this could be the message send by client to start new file dialog If returns true, one can call RFileDialog::Embedded() to really create file dialog instance inside existing widget. ;  ; static std::string NewFile (const std::string &title="""", const std::string &fname="""");  Start NewFile dialog. ;  ; static std::string OpenFile (const std::string &title="""", const std::string &fname="""");  Start OpenFile dialog. ;  ; static std::string SaveAs (const std::string &title="""", const std::string &fname="""");  Start SaveAs dialog. ;  . Protected Member Functions; std::string GetRegexp (const std::string &name) const;  Returns regexp for selected filter String should have form ""Filter name (*.ext1 *.ext2 ...) ;  ; void InvokeCallBack ();  Invoke specified callback. ;  ; void ProcessMsg (unsigned connid, const std::s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RFileDialog.html:2745,detect,detect,2745,doc/v632/classROOT_1_1RFileDialog.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RFileDialog.html,2,['detect'],['detect']
Safety,""", ""m_jlv"", ""m_bb"", ""m_wbb"", ""m_wwbb""}); .Define(""y"",""DNN_Values[0]""); .Histo1D({""h_bkg"", """", 100, 0, 1}, ""y"");; ; h1->SetLineColor(kRed);; h2->SetLineColor(kBlue);; ; auto c1 = new TCanvas();; gStyle->SetOptStat(0);; ; h2->DrawClone();; h1->DrawClone(""SAME"");; c1->BuildLegend();; ; }; kRed@ kRedDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h:66; inputOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void inputDefinition TGWin32VirtualXProxy.cxx:142; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TCanvasThe Canvas class.Definition TCanvas.h:23; TMVA::Experimental::RSofieReaderTMVA::RSofieReader class for reading external Machine Learning models in ONNX files,...Definition RSofieReader.hxx:45; TObject::DrawClonevirtual TObject * DrawClone(Option_t *option="""") constDraw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1).Definition TObject.cxx:305; TStyle::SetOptStatvoid SetOptStat(Int_t stat=1)The type of information printed in the histogram statistics box can be selected via the parameter mod...Definition TStyle.cxx:1640; c1return c1Definition legend1.C:41; h1TH1F * h1Definition legend1.C:5; TMVA::ExperimentalDefinition RModelParser_Keras.h:40; TMVA_SOFIE_GNN_Parser.h2h2Definition TMVA_SOFIE_GNN_Parser.py:188; outputstatic void output(); ; Model has not a defined batch size assume is 1 - input shape for tensor dense_input : { 1 , 7 }; Event prediction = 0.212106; AuthorLorenzo Moneta ; Definition in file TMVA_SOFIE_RSofieReader.C. tutorialstmvaTMVA_SOFIE_RSofieReader.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__SOFIE__RSofieReader_8C.html:3509,predict,prediction,3509,doc/master/TMVA__SOFIE__RSofieReader_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__SOFIE__RSofieReader_8C.html,1,['predict'],['prediction']
Safety,""", [bkg, sig1, sig2], [bkgfrac, sig1frac], True); ; # NB: Each coefficient is interpreted as the fraction of the; # left-hand component of the i-th recursive sum, i.e.; #; # sum4 = A + ( B + ( C + D) with fraction fA, and fC expands to; #; # sum4 = fA*A + (1-fA)*(fB*B + (1-fB)*(fC*C + (1-fC)*D)); ; # Plot recursive addition model; # ---------------------------------------------------------; model2.plotOn(xframe, LineColor=""r"", LineStyle=""--""); model2.plotOn(xframe, Components={bkg, sig2}, LineColor=""r"", LineStyle=""--""); model2.Print(""t""); ; # Draw the frame on the canvas; c = ROOT.TCanvas(""rf201_composite"", ""rf201_composite"", 600, 600); ROOT.gPad.SetLeftMargin(0.15); xframe.GetYaxis().SetTitleOffset(1.4); xframe.Draw(); ; c.SaveAs(""rf201_composite.png""); [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) indirectly selected PDF components: (); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg,sig2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) indirectly selected PDF components: (sig); 0x5b64db0 RooAddPdf::model",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf201__composite_8py.html:3774,safe,safe,3774,doc/master/rf201__composite_8py.html,https://root.cern,https://root.cern/doc/master/rf201__composite_8py.html,1,['safe'],['safe']
Safety,"""; 29#include ""TMatrixT.h""; 30#include ""CudaBuffers.h""; 31 ; 32//#include ""TMVA/RTensor.hxx""; 33 ; 34#ifdef R__HAS_CUDNN; 35#include ""cudnn.h""; 36#define CUDNNCHECK(ans) {cudnnError((ans), __FILE__, __LINE__); }; 37#endif; 38 ; 39namespace TMVA {; 40 ; 41 ; 42 ; 43#ifndef TMVA_RTENSOR; 44 ; 45namespace Experimental {; 46/// Memory layout type (copy from RTensor.hxx); 47enum class MemoryLayout : uint8_t {; 48 RowMajor = 0x01,; 49 ColumnMajor = 0x02; 50};; 51}; 52#endif; 53 ; 54namespace DNN {; 55 ; 56using MemoryLayout = TMVA::Experimental::MemoryLayout;; 57 ; 58#ifdef R__HAS_CUDNN; 59/**; 60 * Function to handle the status output of cuDNN function calls. See also; 61 * CUDACHECK in CudaMatrix.h.; 62 */; 63inline void cudnnError(cudnnStatus_t status, const char *file, int line, bool abort=true); 64{; 65 if (status != CUDNN_STATUS_SUCCESS) {; 66 fprintf(stderr, ""CUDNN Error: %s %s %d\n"", cudnnGetErrorString(status), file, line);; 67 if (abort); 68 exit(status);; 69 }; 70}; 71#endif; 72//____________________________________________________________________________; 73//; 74// Cuda Tensor; 75//____________________________________________________________________________; 76 ; 77/** TCudaTensor Class; 78 *; 79 * The TCudaTensor class extends the TCudaMatrix class for dimensions > 2.; 80 *; 81 */; 82template<typename AFloat>; 83class TCudaTensor; 84{; 85public:; 86 ; 87 using Shape_t = std::vector<size_t>;; 88 using MemoryLayout = TMVA::Experimental:: MemoryLayout;; 89 using Scalar_t = AFloat;; 90 ; 91 ; 92private:; 93 ; 94#ifdef R__HAS_CUDNN; 95 struct TensorDescriptor {; 96 cudnnTensorDescriptor_t fCudnnDesc;; 97 };; 98 ; 99 static std::vector<cudnnHandle_t> fCudnnHandle; ///< Holds the cuddn library context (one for every CUDA stream); 100 ; 101 static cudnnDataType_t fDataType; ///< Cudnn datatype used for the tensor; 102#else; 103 struct TensorDescriptor {; 104 };; 105#endif; 106 ; 107 /** For each GPU device keep the CUDA streams in which tensors are used.; 108 * Inst",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/CudaTensor_8h_source.html:2075,abort,abort,2075,doc/master/CudaTensor_8h_source.html,https://root.cern,https://root.cern/doc/master/CudaTensor_8h_source.html,2,['abort'],['abort']
Safety,"""h2"",""ptD0 vs dm_d"",30,0.135,0.165,30,-3,6);; ; fOutput->Add(hdmd);; fOutput->Add(h2);; ; // Entry list stuff (re-parse option because on PROOF only SlaveBegin is called); if (option.Contains(""fillList"")) {; fillList = kTRUE;; // Get the list; if (fInput) {; if ((elist = (TEntryList *) fInput->FindObject(""elist""))); // Need to clone to avoid problems when destroying the selector; elist = (TEntryList *) elist->Clone();; if (elist); fOutput->Add(elist);; else; fillList = kFALSE;; }; }; if (fillList) Info(""SlaveBegin"", ""creating an entry-list"");; if (option.Contains(""useList"")) useList = kTRUE;; }; ; ; Bool_t h1analysis::Process(Long64_t entry); {; // entry is the entry number in the current Tree; // Selection function to select D* and D0.; ; fProcessed++;; //in case one entry list is given in input, the selection has already been done.; if (!useList) {; // Read only the necessary branches to select entries.; // return as soon as a bad entry is detected; // to read complete event, call fChain->GetTree()->GetEntry(entry); b_md0_d->GetEntry(entry); if (TMath::Abs(md0_d-1.8646) >= 0.04) return kFALSE;; b_ptds_d->GetEntry(entry); if (ptds_d <= 2.5) return kFALSE;; b_etads_d->GetEntry(entry); if (TMath::Abs(etads_d) >= 1.5) return kFALSE;; b_ik->GetEntry(entry); ik--; //original ik used f77 convention starting at 1; b_ipi->GetEntry(entry); ipi--;; b_ntracks->GetEntry(entry);; b_nhitrp->GetEntry(entry);; if (nhitrp[ik]*nhitrp[ipi] <= 1) return kFALSE;; b_rend->GetEntry(entry);; b_rstart->GetEntry(entry);; if (rend[ik] -rstart[ik] <= 22) return kFALSE;; if (rend[ipi]-rstart[ipi] <= 22) return kFALSE;; b_nlhk->GetEntry(entry); if (nlhk[ik] <= 0.1) return kFALSE;; b_nlhpi->GetEntry(entry); if (nlhpi[ipi] <= 0.1) return kFALSE;; b_ipis->GetEntry(entry); ipis--; if (nlhpi[ipis] <= 0.1) return kFALSE;; b_njets->GetEntry(entry); if (njets < 1) return kFALSE;; }; // if option fillList, fill the entry list; if (fillList) elist->Enter(entry);; ; // to read complete event, call fChain->",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/h1analysis_8C.html:9332,detect,detected,9332,doc/master/h1analysis_8C.html,https://root.cern,https://root.cern/doc/master/h1analysis_8C.html,1,['detect'],['detected']
Safety,"""normal""; characters in a chunk, along with individual tab and newline chars in; their own chunks. All characters in the text layout are accounted for. void DrawCharsExp(Drawable_t dst, GContext_t gc, const char* source, Int_t numChars, Int_t x, Int_t y) const; Draw a string of characters on the screen. DrawCharsExp() expands; control characters that occur in the string to \X or \xXX sequences.; DrawChars() just draws the strings. dst -- Window or pixmap in which to draw.; gc -- Graphics context for drawing characters.; source -- Characters to be displayed. Need not be'\0' terminated.; For DrawChars(), all meta-characters (tabs, control; characters, and newlines) should be stripped out of the; string that is passed to this function. If they are not; stripped out, they will be displayed as regular printing; characters.; numChars -- Number of characters in string.; x, y -- Coordinates at which to place origin of string when drawing. void DrawChars(Drawable_t dst, GContext_t gc, const char* source, Int_t numChars, Int_t x, Int_t y) const; Perform a quick sanity check to ensure we won't overflow the X; coordinate space. void SavePrimitive(ostream& out, Option_t* = """"); Save the used font as a C++ statement(s) on output stream out. FontAttributes_t& operator=(const TGFont& font). TGFont(const char* name); (used for simulating a native underlined or strikeout font). TGFont(const TGFont& font). FontH_t GetFontHandle() const; { return fFontH; }. FontStruct_t GetFontStruct() const; { return fFontStruct; }. FontAttributes_t GetFontAttributes() const; { return fFA; }. Int_t TextHeight() const; { return fFM.fLinespace; }. » Author: Fons Rademakers 20/5/2003 » Copyright (C) 1995-2003, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGFont.h 35912 2010-09-30 13:43:06Z couet $ » Last generated: 2011-07-04 15:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGFont.html:14436,sanity check,sanity check,14436,root/html530/TGFont.html,https://root.cern,https://root.cern/root/html530/TGFont.html,1,['sanity check'],['sanity check']
Safety,"""normal""; characters in a chunk, along with individual tab and newline chars in; their own chunks. All characters in the text layout are accounted for. void DrawCharsExp(Drawable_t dst, GContext_t gc, const char* source, Int_t numChars, Int_t x, Int_t y) const; Draw a string of characters on the screen. DrawCharsExp() expands; control characters that occur in the string to \X or \xXX sequences.; DrawChars() just draws the strings. dst -- Window or pixmap in which to draw.; gc -- Graphics context for drawing characters.; source -- Characters to be displayed. Need not be'\0' terminated.; For DrawChars(), all meta-characters (tabs, control; characters, and newlines) should be stripped out of the; string that is passed to this function. If they are not; stripped out, they will be displayed as regular printing; characters.; numChars -- Number of characters in string.; x, y -- Coordinates at which to place origin of string when drawing. void DrawChars(Drawable_t dst, GContext_t gc, const char* source, Int_t numChars, Int_t x, Int_t y) const; Perform a quick sanity check to ensure we won't overflow the X; coordinate space. void SavePrimitive(ostream& out, Option_t* = """"); Save the used font as a C++ statement(s) on output stream out. FontAttributes_t& operator=(const TGFont& font). TGFont(const char* name); (used for simulating a native underlined or strikeout font). TGFont(const TGFont& font). FontH_t GetFontHandle() const; { return fFontH; }. FontStruct_t GetFontStruct() const; { return fFontStruct; }. FontAttributes_t GetFontAttributes() const; { return fFA; }. Int_t TextHeight() const; { return fFM.fLinespace; }. » Author: Fons Rademakers 20/5/2003 » Copyright (C) 1995-2003, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGFont.h 35912 2010-09-30 13:43:06Z couet $ » Last generated: 2011-11-03 20:14; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGFont.html:14436,sanity check,sanity check,14436,root/html532/TGFont.html,https://root.cern,https://root.cern/root/html532/TGFont.html,1,['sanity check'],['sanity check']
Safety,"## Optional methods; 2959 ///; 2960 /// If these methods are implemented they enable extra functionality as per the description below.; 2961 ///; 2962 /// * `Result_t &PartialUpdate(unsigned int slot)`: if present, it must return the value of the partial result of this action for the given 'slot'.; 2963 /// Different threads might call this method concurrently, but will do so with different 'slot' numbers.; 2964 /// RDataFrame leverages this method to implement RResultPtr::OnPartialResult().; 2965 /// * `ROOT::RDF::SampleCallback_t GetSampleCallback()`: if present, it must return a callable with the; 2966 /// appropriate signature (see ROOT::RDF::SampleCallback_t) that will be invoked at the beginning of the processing; 2967 /// of every sample, as in DefinePerSample().; 2968 /// * `Helper MakeNew(void *newResult)`: if implemented, it enables varying the action's result with VariationsFor(). It takes a; 2969 /// type-erased new result that can be safely cast to a `std::shared_ptr<Result_t> *` (a pointer to shared pointer) and should; 2970 /// be used as the action's output result.; 2971 ///; 2972 /// In case Book is called without specifying column types as template arguments, corresponding typed code will be just-in-time compiled; 2973 /// by RDataFrame. In that case the Helper class needs to be known to the ROOT interpreter.; 2974 ///; 2975 /// This action is *lazy*: upon invocation of this method the calculation is booked but not executed. Also see RResultPtr.; 2976 ///; 2977 /// ### Examples; 2978 /// See [this tutorial](https://root.cern/doc/master/df018__customActions_8C.html) for an example implementation of an action helper.; 2979 ///; 2980 /// It is also possible to inspect the code used by built-in RDataFrame actions at ActionHelpers.hxx.; 2981 ///; 2982 // clang-format on; 2983 template <typename FirstColumn = RDFDetail::RInferredType, typename... OtherColumns, typename Helper>; 2984 RResultPtr<typename std::decay_t<Helper>::Result_t> Book(Helper &&helper,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RInterface_8hxx_source.html:168604,safe,safely,168604,doc/master/RInterface_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RInterface_8hxx_source.html,1,['safe'],['safely']
Safety,"####################################################################################; 116 ; 117# Instantiating EncodeProcessDecode Model; 118 ; 119printMemory(""before instantiating""); 120ep_model = EncodeProcessDecode(); 121printMemory(""after instantiating""); 122 ; 123# Initializing randomized input data with maximum number of nodes/edges; 124GraphData = get_fix_graph_data_dict(num_max_nodes, num_max_edges, node_size, edge_size, global_size); 125 ; 126#input_graphs is a tuple representing the initial data; 127input_graph_data = utils_tf.data_dicts_to_graphs_tuple([GraphData]); 128 ; 129# Initializing randomized input data for core; 130# note that the core network has as input a double number of features; 131CoreGraphData = get_fix_graph_data_dict(num_max_nodes, num_max_edges, 2*LATENT_SIZE, 2*LATENT_SIZE, 2*LATENT_SIZE); 132input_core_graph_data = utils_tf.data_dicts_to_graphs_tuple([CoreGraphData]); 133 ; 134#initialize graph data for decoder (input is LATENT_SIZE); 135DecodeGraphData = get_fix_graph_data_dict(num_max_nodes, num_max_edges, LATENT_SIZE, LATENT_SIZE, LATENT_SIZE); 136 ; 137# Make prediction of GNN. This will initialize the GNN with weights; 138printMemory(""before first eval""); 139output_gn = ep_model(input_graph_data, processing_steps); 140printMemory(""after first eval""); 141#print(""---> Input:\n"",input_graph_data); 142#print(""\n\n------> Input core data:\n"",input_core_graph_data); 143#print(""\n\n---> Output:\n"",output_gn); 144 ; 145# Make SOFIE Model, the model will be made using a maximum number of nodes/edges which are inside GraphData; 146 ; 147encoder = ROOT.TMVA.Experimental.SOFIE.RModel_GraphIndependent.ParseFromMemory(ep_model._encoder._network, GraphData, filename = ""encoder""); 148encoder.Generate(); 149encoder.OutputGenerated(); 150 ; 151core = ROOT.TMVA.Experimental.SOFIE.RModel_GNN.ParseFromMemory(ep_model._core._network, CoreGraphData, filename = ""core""); 152core.Generate(); 153core.OutputGenerated(); 154 ; 155decoder = ROOT.TMVA.Experim",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__SOFIE__GNN__Parser_8py_source.html:5736,predict,prediction,5736,doc/master/TMVA__SOFIE__GNN__Parser_8py_source.html,https://root.cern,https://root.cern/doc/master/TMVA__SOFIE__GNN__Parser_8py_source.html,1,['predict'],['prediction']
Safety,"& ""Inconsistent enum fwd decl (end)!"");; 2168 while (isspace(fwdDeclsLine[posEnumNameEnd])); 2169 --posEnumNameEnd;; 2170 // posEnumNameEnd now points to the last character of the name.; 2171 ; 2172 std::string enumName = fwdDeclsLine.substr(posEnumName,; 2173 posEnumNameEnd - posEnumName + 1);; 2174 ; 2175 if (clang::NamedDecl* enumDecl; 2176 = cling::utils::Lookup::Named(&fInterpreter->getSema(),; 2177 enumName.c_str(), DC)) {; 2178 // We have an existing enum decl (forward or definition);; 2179 // skip this.; 2180 R__ASSERT(llvm::dyn_cast<clang::EnumDecl>(enumDecl) && ""not an enum decl!"");; 2181 (void)enumDecl;; 2182 continue;; 2183 }; 2184 }; 2185 }; 2186 ; 2187 fwdDeclsCodeLessEnums += fwdDeclsLine + ""\n"";; 2188 }; 2189 }; 2190 ; 2191 if (!fwdDeclsCodeLessEnums.empty()){ // Avoid the overhead if nothing is to be declared; 2192 auto compRes = fInterpreter->declare(fwdDeclsCodeLessEnums, &T);; 2193 assert(cling::Interpreter::kSuccess == compRes &&; 2194 ""The forward declarations could not be compiled"");; 2195 if (compRes!=cling::Interpreter::kSuccess){; 2196 Warning(""TCling::RegisterModule"",; 2197 ""Problems in compiling forward declarations for module %s: '%s'"",; 2198 modulename, fwdDeclsCodeLessEnums.c_str()) ;; 2199 }; 2200 else if (T){; 2201 // Loop over all decls in the transaction and go through them all; 2202 // to mark them properly.; 2203 // In order to do that, we first iterate over all the DelayedCallInfos; 2204 // within the transaction. Then we loop over all Decls in the DeclGroupRef; 2205 // contained in the DelayedCallInfos. For each decl, we traverse.; 2206 ExtLexicalStorageAdder elsa;; 2207 for (auto dciIt = T->decls_begin();dciIt!=T->decls_end();dciIt++){; 2208 cling::Transaction::DelayCallInfo& dci = *dciIt;; 2209 for(auto dit = dci.m_DGR.begin(); dit != dci.m_DGR.end(); ++dit) {; 2210 clang::Decl* declPtr = *dit;; 2211 elsa.TraverseDecl(declPtr);; 2212 }; 2213 }; 2214 }; 2215 }; 2216 ; 2217 // Now we register all the headers necessary for the cl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:84326,Avoid,Avoid,84326,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['Avoid'],['Avoid']
Safety,"& opt); doubleRelTolerance() const; voidSetAbsTolerance(double tol); voidSetExtraOptions(const ROOT::Math::IOptions& opt); voidSetRelTolerance(double tol); voidSetWKSize(unsigned int size); unsigned intWKSize() const. protected:. ROOT::Math::BaseIntegratorOptionsBaseIntegratorOptions(); voidClearExtra(). Data Members; protected:. doublefAbsToleranceabsolute tolerance; ROOT::Math::IOptions*fExtraOptionsextra options; intfIntegTypeIntegrator type (value converted from enum); unsigned intfNCalls(max) funxtion calls; doublefRelTolerancerelative tolerance; unsigned intfWKSizeworkspace size. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseIntegratorOptions(); protected constructor to avoid user creating this class. BaseIntegratorOptions(const ROOT::Math::BaseIntegratorOptions& opt); copy constructor. BaseIntegratorOptions & operator=(const ROOT::Math::BaseIntegratorOptions& opt); assignment operators. virtual ~BaseIntegratorOptions(); protected constructor to avoid user creating this class. { ClearExtra(); }. std::string Integrator() const; name of 1D integrator. double AbsTolerance() const; non-static methods for retrivieng options ; absolute tolerance. { return fAbsTolerance; }. double RelTolerance() const; absolute tolerance. { return fRelTolerance; }. unsigned int WKSize() const; size of the workspace. { return fWKSize; }. IOptions * ExtraOptions() const; return extra options. { return fExtraOptions; }. void SetAbsTolerance(double tol); non-static methods for setting options ; set the abs tolerance. { fAbsTolerance = tol; }. void SetRelTolerance(double tol); set the relative tolerance. { fRelTolerance = tol; }. void SetWKSize(unsigned int size); set workspace size. { fWKSize = size; }. void SetExtraOptions(const ROOT::Math::IOptions& opt); set extra options (in this case pointer is cloned). void ClearExtra(). » Author: L. Moneta Fri Aug 15 2008 » Copyright (c) 2008 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/ma",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__BaseIntegratorOptions.html:2010,avoid,avoid,2010,root/html602/ROOT__Math__BaseIntegratorOptions.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__BaseIntegratorOptions.html,2,['avoid'],['avoid']
Safety,"& strlen(library_specified) ) {; 2972 // Use the specified name instead of the default; 2973 libname = BaseName( library_specified );; 2974 library = library_specified;; 2975 ExpandPathName( library );; 2976 if (! IsAbsoluteFileName(library) ) {; 2977 AssignAndDelete( library , ConcatFileName( WorkingDirectory(), library ) );; 2978 }; 2979 library = TString(library) + ""."" + fSoExt;; 2980 }; 2981 library = gSystem->UnixPathName(library);; 2982 ; 2983 TString libname_ext ( libname );; 2984 libname_ext += ""."" + fSoExt;; 2985 ; 2986 TString lib_dirname = GetDirName( library );; 2987 // For some probably good reason, DirName on Windows returns the 'name' of; 2988 // the directory, omitting the drive letter (even if there was one). In; 2989 // consequence the result is not useable as a 'root directory', we need to; 2990 // add the drive letter if there was one..; 2991 if (library.Length()>1 && isalpha(library[0]) && library[1]==':') {; 2992 lib_dirname.Prepend(library(0,2));; 2993 }; 2994 // Strip potential, somewhat redundant '/.' from the pathname ...; 2995 if ( strncmp( &(lib_dirname[lib_dirname.Length()-2]), ""/."", 2) == 0 ) {; 2996 lib_dirname.Remove(lib_dirname.Length()-2);; 2997 }; 2998 if ( strncmp( &(lib_dirname[lib_dirname.Length()-2]), ""\\."", 2) == 0 ) {; 2999 lib_dirname.Remove(lib_dirname.Length()-2);; 3000 }; 3001 TString lib_location( lib_dirname );; 3002 Bool_t mkdirFailed = kFALSE;; 3003 ; 3004 if (build_loc.Length()==0) {; 3005 build_loc = lib_location;; 3006 } else {; 3007 // Removes an existing disk specification from the names; 3008 TRegexp disk_finder (""[A-z]:"");; 3009 Int_t pos = library.Index( disk_finder );; 3010 if (pos==0) library.Remove(pos,3);; 3011 pos = lib_location.Index( disk_finder );; 3012 if (pos==0) lib_location.Remove(pos,3);; 3013 ; 3014 if (flatBuildDir) {; 3015 AssignAndDelete( library, ConcatFileName( build_loc, libname_ext) );; 3016 } else {; 3017 AssignAndDelete( library, ConcatFileName( build_loc, library) );; 3018 }; 3019 ; 3020",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:100217,redund,redundant,100217,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,1,['redund'],['redundant']
Safety,"& var, Bool_t silent = kFALSE); Add element to non-owning set. The operation will fail if; a similarly named object already exists in the set, or; the set is specified to own its elements. Eventual error messages; can be suppressed with the silent flag. Bool_t addOwned(RooAbsArg& var, Bool_t silent = kFALSE); Add element to an owning set. The operation will fail if; a similarly named object already exists in the set, or; the set is not specified to own its elements. Eventual error messages; can be suppressed with the silent flag. RooAbsArg* addClone(const RooAbsArg& var, Bool_t silent = kFALSE); Add clone of specified element to an owning set. If sucessful, the; set will own the clone, not the original. The operation will fail if; a similarly named object already exists in the set, or; the set is not specified to own its elements. Eventual error messages; can be suppressed with the silent flag. RooAbsArg& operator[](const char* name) const; Array operator. Named element must exist in set, otherwise; code will abort. When used as lvalue in assignment operations, the element contained in; the list will not be changed, only the value of the existing element!. Bool_t checkForDup(const RooAbsArg& arg, Bool_t silent) const; Check if element with var's name is already in set. Double_t getRealValue(const char* name, Double_t defVal = 0, Bool_t verbose = kFALSE) const; Get value of a RooAbsReal stored in set with given name. If none is found, value of defVal is returned.; No error messages are printed unless the verbose flag is set. Bool_t setRealValue(const char* name, Double_t newVal = 0, Bool_t verbose = kFALSE); Set value of a RooAbsRealLValye stored in set with given name to newVal; No error messages are printed unless the verbose flag is set. const char* getCatLabel(const char* name, const char* defVal = """", Bool_t verbose = kFALSE) const; Get state name of a RooAbsCategory stored in set with given name. If none is found, value of defVal is returned.; No error messages ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooArgSet.html:18260,abort,abort,18260,root/html528/RooArgSet.html,https://root.cern,https://root.cern/root/html528/RooArgSet.html,6,['abort'],['abort']
Safety,"& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2, dZ. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; in case shape has some negative parameters, these has to be computed; in order to fit the mother. Bool_t GetPointsOnSegments(Int_t npoints, Double_t* array) const; Fills array with n random points located on the line segments of the shape mesh.; The output array must be provided with a length of minimum 3*npoints. Returns; true if operation is implemented. void InspectShape() const; print shape parameters. TBuffer3D * MakeBuffer3D() const; Creates a TBuffer3D describing *this* shape.; Coordinates are in local reference frame. void SetSegsAndPols(TBuffer3D& buffer) const; Fill TBuffer3D structure for segments and polygons. Double_t Safety(const Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape, according; to option. The matching point on the shape is stored in spoint. Double_t SafetyS(const Double_t* point, Bool_t in, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Int_t skipz = 0); computes the closest distance from given point to this shape, according; to option. The matching point on the shape is stored in spoint. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetConeDimensions(Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Set cone dimensions. void SetDimensions(Double_t* param); Set cone dimensions from an array. void SetPoints(Double_t* points) const; Create cone mesh points. void SetPoints(Float_t* points) const; Create cone mesh points. void GetMeshNumbers(Int_t& nvert, Int_t& nsegs, Int_t& npols) const; Returns numbers of vertices, segments and polygons composing the shape mesh. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoCone.html:17674,Safe,Safety,17674,root/html534/TGeoCone.html,https://root.cern,https://root.cern/root/html534/TGeoCone.html,3,['Safe'],['Safety']
Safety,"&vec);  Fill 1D histogram errors into vector. ;  ; static void M2H (const TMatrixD &mat, TH2D &histo);  Fill 2D histogram into matrix. ;  ; static TMatrixD MatDivVec (const TMatrixD &mat, const TVectorD &vec, Int_t zero=0);  Divide matrix entries by vector. ;  ; static void RegularisedSymMatInvert (TMatrixDSym &mat, Double_t eps=1e-3);  naive regularised inversion cuts off small elements ;  ; static void V2H (const TVectorD &vec, TH1D &histo);  Fill vector into 1D histogram. ;  ; static TVectorD VecDiv (const TVectorD &vec1, const TVectorD &vec2, Int_t zero=0);  Divide entries of two vectors. ;  . Private Attributes; Class members; Int_t fNdim;  ! Truth and reconstructed dimensions ;  ; Int_t fDdim;  ! Derivative for curvature matrix ;  ; Bool_t fNormalize;  ! Normalize unfolded spectrum to 1 ;  ; Int_t fKReg;  ! Regularisation parameter ;  ; TH1D * fDHist;  ! Distribution of d (for checking regularization) ;  ; TH1D * fSVHist;  ! Distribution of singular values ;  ; TH2D * fXtau;  ! Computed regularized covariance matrix ;  ; TH2D * fXinv;  ! Computed inverse of covariance matrix ;  ; Input histos; const TH1D * fBdat;  Measured distribution (data) ;  ; TH2D * fBcov;  Covariance matrix of measured distribution (data) ;  ; const TH1D * fBini;  Reconstructed distribution (MC) ;  ; const TH1D * fXini;  Truth distribution (MC) ;  ; const TH2D * fAdet;  Detector response matrix. ;  ; Evaluation of covariance matrices; TH1D * fToyhisto;  ! Toy MC histogram ;  ; TH2D * fToymat;  ! Toy MC detector response matrix ;  ; Bool_t fToyMode;  ! Internal switch for covariance matrix propagation ;  ; Bool_t fMatToyMode;  ! Internal switch for evaluation of statistical uncertainties from response matrix ;  . Additional Inherited Members;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSVDUnfold.html:16156,Detect,Detector,16156,doc/master/classTSVDUnfold.html,https://root.cern,https://root.cern/doc/master/classTSVDUnfold.html,1,['Detect'],['Detector']
Safety,"& ; biasGradients . ). protectedvirtual . Update the biases, given the current bias gradients. ; Implements TMVA::DNN::VOptimizer< Architecture_t, Layer_t, DeepNet_t >.; Definition at line 206 of file Adadelta.h. ◆ UpdateWeights(). template<typename Architecture_t , typename Layer_t , typename DeepNet_t > . auto TMVA::DNN::TAdadelta< Architecture_t, Layer_t, DeepNet_t >::UpdateWeights ; (; size_t ; layerIndex, . std::vector< Matrix_t > & ; weights, . const std::vector< Matrix_t > & ; weightGradients . ). protectedvirtual . Update the weights, given the current weight gradients. ; Implements TMVA::DNN::VOptimizer< Architecture_t, Layer_t, DeepNet_t >.; Definition at line 147 of file Adadelta.h. Member Data Documentation. ◆ fEpsilon. template<typename Architecture_t , typename Layer_t = VGeneralLayer<Architecture_t>, typename DeepNet_t = TDeepNet<Architecture_t, Layer_t>> . Scalar_t TMVA::DNN::TAdadelta< Architecture_t, Layer_t, DeepNet_t >::fEpsilon. protected . The Smoothing term used to avoid division by zero. ; Definition at line 52 of file Adadelta.h. ◆ fPastSquaredBiasGradients. template<typename Architecture_t , typename Layer_t = VGeneralLayer<Architecture_t>, typename DeepNet_t = TDeepNet<Architecture_t, Layer_t>> . std::vector<std::vector<Matrix_t> > TMVA::DNN::TAdadelta< Architecture_t, Layer_t, DeepNet_t >::fPastSquaredBiasGradients. protected . The accumulation of the square of the past bias gradients associated with the deep net. ; Definition at line 55 of file Adadelta.h. ◆ fPastSquaredBiasUpdates. template<typename Architecture_t , typename Layer_t = VGeneralLayer<Architecture_t>, typename DeepNet_t = TDeepNet<Architecture_t, Layer_t>> . std::vector<std::vector<Matrix_t> > TMVA::DNN::TAdadelta< Architecture_t, Layer_t, DeepNet_t >::fPastSquaredBiasUpdates. protected . The accumulation of the square of the past bias updates associated with the deep net. ; Definition at line 60 of file Adadelta.h. ◆ fPastSquaredWeightGradients. template<typename Architect",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TAdadelta.html:10837,avoid,avoid,10837,doc/master/classTMVA_1_1DNN_1_1TAdadelta.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TAdadelta.html,1,['avoid'],['avoid']
Safety,"& ; nvert, . Int_t & ; nsegs, . Int_t & ; npols . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ GetNmeshVertices(). Int_t TGeoEltu::GetNmeshVertices ; (; ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ GetPointsOnSegments(). Bool_t TGeoEltu::GetPointsOnSegments ; (; Int_t ; , . Double_t * ;  . ); const. inlineoverridevirtual . Reimplemented from TGeoBBox.; Definition at line 54 of file TGeoEltu.h. ◆ InspectShape(). void TGeoEltu::InspectShape ; (; ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ IsA(). TClass * TGeoEltu::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TGeoBBox.; Definition at line 65 of file TGeoEltu.h. ◆ IsCylType(). Bool_t TGeoEltu::IsCylType ; (; ); const. inlineoverridevirtual . Reimplemented from TGeoBBox.; Definition at line 56 of file TGeoEltu.h. ◆ operator=(). TGeoEltu & TGeoEltu::operator= ; (; const TGeoEltu & ; ). privatedelete . ◆ Safety(). Double_t TGeoEltu::Safety ; (; const Double_t * ; point, . Bool_t ; in = kTRUE . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ Safety_v(). void TGeoEltu::Safety_v ; (; const Double_t * ; points, . const Bool_t * ; inside, . Double_t * ; safe, . Int_t ; vecsize . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ SavePrimitive(). void TGeoEltu::SavePrimitive ; (; std::ostream & ; out, . Option_t * ; option = """" . ). overridevirtual . Save a primitive as a C++ statement(s) on output stream ""out"". ; Reimplemented from TGeoBBox. ◆ SetDimensions(). void TGeoEltu::SetDimensions ; (; Double_t * ; param). overridevirtual . Reimplemented from TGeoBBox. ◆ SetEltuDimensions(). void TGeoEltu::SetEltuDimensions ; (; Double_t ; a, . Double_t ; b, . Double_t ; dz . ). ◆ SetPoints() [1/2]. void TGeoEltu::SetPoints ; (; Double_t * ; points); const. overridevirtual . Reimplemented from TGeoBBox. ◆ SetPoints() [2/2]. void TGeoEltu::SetPoints ; (; Float_t * ; points); const. overridevirtual . Reimplemented from T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoEltu.html:31339,Safe,Safety,31339,doc/master/classTGeoEltu.html,https://root.cern,https://root.cern/doc/master/classTGeoEltu.html,1,['Safe'],['Safety']
Safety,"' or 'dirptr'. ;  ; void FreeDirectory (void *dirp=nullptr) override;  Free directory via rootd. ;  ; const char * GetDirEntry (void *dirp=nullptr) override;  Get directory entry via rootd. Returns 0 in case no more entries. ;  ; Int_t GetPathInfo (const char *path, FileStat_t &buf) override;  Get info about a file. ;  ; TClass * IsA () const override;  ; Int_t MakeDirectory (const char *name) override;  Make a directory via rootd. ;  ; void * OpenDirectory (const char *name) override;  Open a directory and return an opaque pointer to a dir structure. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; int Unlink (const char *path) override;  Remove a path. ;  ;  Public Member Functions inherited from TSystem;  TSystem (const char *name=""Generic"", const char *title=""Generic System"");  Create a new OS interface. ;  ; virtual ~TSystem ();  Delete the OS interface. ;  ; virtual void Abort (int code=0);  Abort the application. ;  ; virtual int AcceptConnection (int sock);  Accept a connection. ;  ; virtual void AddDynamicPath (const char *pathname);  Add a new directory to the dynamic path. ;  ; virtual void AddFileHandler (TFileHandler *fh);  Add a file handler to the list of system file handlers. ;  ; virtual void AddIncludePath (const char *includePath);  Add a directory to the already set include path. ;  ; virtual void AddLinkedLibs (const char *linkedLib);  Add linkedLib to already set linked libs. ;  ; virtual void AddSignalHandler (TSignalHandler *sh);  Add a signal handler to list of system signal handlers. ;  ; virtual void AddStdExceptionHandler (TStdExceptionHandler *eh);  Add an exception handler to list of system exception handlers. ;  ; virtual void AddTimer (TTimer *t);  Add timer to list of system timers. ;  ; virtual int AnnounceTcpService (int port, Bool_t reuse, int backlog, int tcpwindowsize=-1);  Announce TCP/IP service. ;  ; virtual int AnnounceUdpServic",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTNetSystem.html:1953,Abort,Abort,1953,doc/master/classTNetSystem.html,https://root.cern,https://root.cern/doc/master/classTNetSystem.html,2,['Abort'],['Abort']
Safety,"'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Static Protected Attributes; static RooArgSet _emptySet;  Supports named argument constructor. ;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . Private Member Functions;  RooChi2Var (const char *name, const char *title, RooAbsReal &func, RooDataHist &data, const RooArgSet &projDeps, FuncMode funcMode, RooAbsTestStatistic::Configuration const &cfg, RooDataHist::ErrorType etype);  . Additional Inherited Members;  Static Public Member Functions inherited from RooAbsReal; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static void clearEvalErrorLog ();  Clear the stack of evaluation error messages. ;  ; static const char * DeclFileName ();  ; static RooNumIntConfig * defaultIntegratorConfig ();  Returns the default numeric integration configuration for all RooAbsReals. ;  ; static std::map< constRooAbsArg *, std::pair< std::string, std::list< RooAbsReal::EvalError > > >::iterator evalErrorIter ();  ; static ErrorLoggingMode evalErrorLoggingMode ();  Return current",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooChi2Var.html:65558,Avoid,Avoids,65558,doc/master/classRooChi2Var.html,https://root.cern,https://root.cern/doc/master/classRooChi2Var.html,1,['Avoid'],['Avoids']
Safety,"(!set_gpass_option(ctx, NULL)) {; 19966 const char *err_msg = ""Invalid global password file"";; 19967 /* Fatal error - abort start. */; 19968 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 19969 ; 19970 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19971 mg_snprintf(NULL,; 19972 NULL, /* No truncation check for error buffers */; 19973 error->text,; 19974 error->text_buffer_size,; 19975 ""%s"",; 19976 err_msg);; 19977 }; 19978 free_context(ctx);; 19979 pthread_setspecific(sTlsKey, NULL);; 19980 return NULL;; 19981 }; 19982#endif; 19983 ; 19984#if defined(USE_MBEDTLS); 19985 if (!mg_sslctx_init(ctx, NULL)) {; 19986 const char *err_msg = ""Error initializing SSL context"";; 19987 /* Fatal error - abort start. */; 19988 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 19989 ; 19990 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19991 mg_snprintf(NULL,; 19992 NULL, /* No truncation check for error buffers */; 19993 error->text,; 19994 error->text_buffer_size,; 19995 ""%s"",; 19996 err_msg);; 19997 }; 19998 free_context(ctx);; 19999 pthread_setspecific(sTlsKey, NULL);; 20000 return NULL;; 20001 }; 20002 ; 20003#elif !defined(NO_SSL); 20004 if (!init_ssl_ctx(ctx, NULL)) {; 20005 const char *err_msg = ""Error initializing SSL context"";; 20006 /* Fatal error - abort start. */; 20007 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20008 ; 20009 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20010 mg_snprintf(NULL,; 20011 NULL, /* No truncation check for error buffers */; 20012 error->text,; 20013 error->text_buffer_size,; 20014 ""%s"",; 20015 err_msg);; 20016 }; 20017 free_context(ctx);; 20018 pthread_setspecific(sTlsKey, NULL);; 20019 return NULL;; 20020 }; 20021#endif; 20022 ; 20023 if (!set_ports_option(ctx)) {; 20024 const char *err_msg = ""Failed to setup server ports"";; 20025 /* Fatal error - abort start. */; 20026 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20027 ; 20028 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20029 mg_snprintf(NULL,; 20030 NULL, /* No ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:597849,abort,abort,597849,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['abort'],['abort']
Safety,"(!set_gpass_option(ctx, NULL)) {; 19967 const char *err_msg = ""Invalid global password file"";; 19968 /* Fatal error - abort start. */; 19969 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 19970 ; 19971 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19972 mg_snprintf(NULL,; 19973 NULL, /* No truncation check for error buffers */; 19974 error->text,; 19975 error->text_buffer_size,; 19976 ""%s"",; 19977 err_msg);; 19978 }; 19979 free_context(ctx);; 19980 pthread_setspecific(sTlsKey, NULL);; 19981 return NULL;; 19982 }; 19983#endif; 19984 ; 19985#if defined(USE_MBEDTLS); 19986 if (!mg_sslctx_init(ctx, NULL)) {; 19987 const char *err_msg = ""Error initializing SSL context"";; 19988 /* Fatal error - abort start. */; 19989 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 19990 ; 19991 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19992 mg_snprintf(NULL,; 19993 NULL, /* No truncation check for error buffers */; 19994 error->text,; 19995 error->text_buffer_size,; 19996 ""%s"",; 19997 err_msg);; 19998 }; 19999 free_context(ctx);; 20000 pthread_setspecific(sTlsKey, NULL);; 20001 return NULL;; 20002 }; 20003 ; 20004#elif !defined(NO_SSL); 20005 if (!init_ssl_ctx(ctx, NULL)) {; 20006 const char *err_msg = ""Error initializing SSL context"";; 20007 /* Fatal error - abort start. */; 20008 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20009 ; 20010 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20011 mg_snprintf(NULL,; 20012 NULL, /* No truncation check for error buffers */; 20013 error->text,; 20014 error->text_buffer_size,; 20015 ""%s"",; 20016 err_msg);; 20017 }; 20018 free_context(ctx);; 20019 pthread_setspecific(sTlsKey, NULL);; 20020 return NULL;; 20021 }; 20022#endif; 20023 ; 20024 if (!set_ports_option(ctx)) {; 20025 const char *err_msg = ""Failed to setup server ports"";; 20026 /* Fatal error - abort start. */; 20027 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20028 ; 20029 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20030 mg_snprintf(NULL,; 20031 NULL, /* No ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:597882,abort,abort,597882,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['abort'],['abort']
Safety,"(&conn->phys_ctx->stop_flag)) {; 6293 return -2;; 6294 }; 6295 }; 6296 if (pollres > 0) {; 6297 ERR_clear_error();; 6298 nread =; 6299 SSL_read(conn->ssl, buf, (ssl_pending > 0) ? ssl_pending : len);; 6300 if (nread <= 0) {; 6301 err = SSL_get_error(conn->ssl, nread);; 6302 if ((err == SSL_ERROR_SYSCALL) && (nread == -1)) {; 6303 err = ERRNO;; 6304 } else if ((err == SSL_ERROR_WANT_READ); 6305 || (err == SSL_ERROR_WANT_WRITE)) {; 6306 nread = 0;; 6307 } else {; 6308 /* All errors should return -2 */; 6309 DEBUG_TRACE(""SSL_read() failed, error %d"", err);; 6310 ERR_clear_error();; 6311 return -2;; 6312 }; 6313 ERR_clear_error();; 6314 } else {; 6315 err = 0;; 6316 }; 6317 } else if (pollres < 0) {; 6318 /* Error */; 6319 return -2;; 6320 } else {; 6321 /* pollres = 0 means timeout */; 6322 nread = 0;; 6323 }; 6324#endif; 6325 ; 6326 } else {; 6327 struct mg_pollfd pfd[1];; 6328 int pollres;; 6329 ; 6330 pfd[0].fd = conn->client.sock;; 6331 pfd[0].events = POLLIN;; 6332 pollres = mg_poll(pfd,; 6333 1,; 6334 (int)(timeout * 1000.0),; 6335 &(conn->phys_ctx->stop_flag));; 6336 if (!STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 6337 return -2;; 6338 }; 6339 if (pollres > 0) {; 6340 nread = (int)recv(conn->client.sock, buf, (len_t)len, 0);; 6341 err = (nread < 0) ? ERRNO : 0;; 6342 if (nread <= 0) {; 6343 /* shutdown of the socket at client side */; 6344 return -2;; 6345 }; 6346 } else if (pollres < 0) {; 6347 /* error callint poll */; 6348 return -2;; 6349 } else {; 6350 /* pollres = 0 means timeout */; 6351 nread = 0;; 6352 }; 6353 }; 6354 ; 6355 if (!STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 6356 return -2;; 6357 }; 6358 ; 6359 if ((nread > 0) || ((nread == 0) && (len == 0))) {; 6360 /* some data has been read, or no data was requested */; 6361 return nread;; 6362 }; 6363 ; 6364 if (nread < 0) {; 6365 /* socket error - check errno */; 6366#if defined(_WIN32); 6367 if (err == WSAEWOULDBLOCK) {; 6368 /* TODO (low): check if this is still required */; 6369 /* st",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:184346,timeout,timeout,184346,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety,"(&conn->phys_ctx->stop_flag)) {; 6294 return -2;; 6295 }; 6296 }; 6297 if (pollres > 0) {; 6298 ERR_clear_error();; 6299 nread =; 6300 SSL_read(conn->ssl, buf, (ssl_pending > 0) ? ssl_pending : len);; 6301 if (nread <= 0) {; 6302 err = SSL_get_error(conn->ssl, nread);; 6303 if ((err == SSL_ERROR_SYSCALL) && (nread == -1)) {; 6304 err = ERRNO;; 6305 } else if ((err == SSL_ERROR_WANT_READ); 6306 || (err == SSL_ERROR_WANT_WRITE)) {; 6307 nread = 0;; 6308 } else {; 6309 /* All errors should return -2 */; 6310 DEBUG_TRACE(""SSL_read() failed, error %d"", err);; 6311 ERR_clear_error();; 6312 return -2;; 6313 }; 6314 ERR_clear_error();; 6315 } else {; 6316 err = 0;; 6317 }; 6318 } else if (pollres < 0) {; 6319 /* Error */; 6320 return -2;; 6321 } else {; 6322 /* pollres = 0 means timeout */; 6323 nread = 0;; 6324 }; 6325#endif; 6326 ; 6327 } else {; 6328 struct mg_pollfd pfd[1];; 6329 int pollres;; 6330 ; 6331 pfd[0].fd = conn->client.sock;; 6332 pfd[0].events = POLLIN;; 6333 pollres = mg_poll(pfd,; 6334 1,; 6335 (int)(timeout * 1000.0),; 6336 &(conn->phys_ctx->stop_flag));; 6337 if (!STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 6338 return -2;; 6339 }; 6340 if (pollres > 0) {; 6341 nread = (int)recv(conn->client.sock, buf, (len_t)len, 0);; 6342 err = (nread < 0) ? ERRNO : 0;; 6343 if (nread <= 0) {; 6344 /* shutdown of the socket at client side */; 6345 return -2;; 6346 }; 6347 } else if (pollres < 0) {; 6348 /* error callint poll */; 6349 return -2;; 6350 } else {; 6351 /* pollres = 0 means timeout */; 6352 nread = 0;; 6353 }; 6354 }; 6355 ; 6356 if (!STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 6357 return -2;; 6358 }; 6359 ; 6360 if ((nread > 0) || ((nread == 0) && (len == 0))) {; 6361 /* some data has been read, or no data was requested */; 6362 return nread;; 6363 }; 6364 ; 6365 if (nread < 0) {; 6366 /* socket error - check errno */; 6367#if defined(_WIN32); 6368 if (err == WSAEWOULDBLOCK) {; 6369 /* TODO (low): check if this is still required */; 6370 /* st",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:184378,timeout,timeout,184378,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety,"() [6/9]. TKey::TKey ; (; const TString & ; name, . const TString & ; title, . const TClass * ; cl, . Int_t ; nbytes, . TDirectory * ; motherDir . ). Create a TKey object with the specified name, title for the given class. ; WARNING: in name avoid special characters like '^','$','.' that are used by the regular expression parser (see TRegexp). ; Definition at line 207 of file TKey.cxx. ◆ TKey() [7/9]. TKey::TKey ; (; const TObject * ; obj, . const char * ; name, . Int_t ; bufsize, . TDirectory * ; motherDir . ). Create a TKey object for a TObject* and fill output buffer. ; WARNING: in name avoid special characters like '^','$','.' that are used by the regular expression parser (see TRegexp). ; Definition at line 223 of file TKey.cxx. ◆ TKey() [8/9]. TKey::TKey ; (; const void * ; obj, . const TClass * ; cl, . const char * ; name, . Int_t ; bufsize, . TDirectory * ; motherDir . ). Create a TKey object for any object obj of class cl d and fill output buffer. ; WARNING: in name avoid special characters like '^','$','.' that are used by the regular expression parser (see TRegexp). ; Definition at line 298 of file TKey.cxx. ◆ TKey() [9/9]. TKey::TKey ; (; Long64_t ; pointer, . Int_t ; nbytes, . TDirectory * ; motherDir = nullptr . ). Create a TKey object to read keys. ; Constructor called by TDirectoryFile::ReadKeys and by TFile::TFile. A TKey object is created to read the keys structure itself. ; Definition at line 175 of file TKey.cxx. ◆ ~TKey(). TKey::~TKey ; (; ). override . TKey default destructor. ; Definition at line 526 of file TKey.cxx. Member Function Documentation. ◆ Browse(). void TKey::Browse ; (; TBrowser * ; b). overridevirtual . Read object from disk and call its Browse() method. ; If object with same name already exist in memory delete it (like TDirectoryFile::Get() is doing), except when the key references a folder in which case we don't want to re-read the folder object since it might contain new objects not yet saved. ; Reimplemented from TObject.; De",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTKey.html:19404,avoid,avoid,19404,doc/master/classTKey.html,https://root.cern,https://root.cern/doc/master/classTKey.html,1,['avoid'],['avoid']
Safety,"() const override;  ; void SlaveBegin (TTree *) override;  See TProofDraw::SlaveBegin(). ;  ; void SlaveTerminate () override;  See TProofDraw::SlaveTerminate(). ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void Terminate () override;  See TProofDraw::Terminate(). ;  ;  Public Member Functions inherited from TProofDraw;  TProofDraw ();  Constructor. ;  ;  ~TProofDraw () override;  Destructor. ;  ; void Begin (TTree *) override;  Executed by the client before processing. ;  ; Bool_t Notify () override;  Called when a new tree is loaded. ;  ; Bool_t Process (Long64_t) override;  Executed for each entry. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; int Version () const override;  ;  Public Member Functions inherited from TSelector;  TSelector ();  Default selector ctor. ;  ;  ~TSelector () override;  Selector destructor. ;  ; virtual void Abort (const char *why, EAbort what=kAbortProcess);  Abort processing. ;  ; virtual EAbort GetAbort () const;  ; virtual Int_t GetEntry (Long64_t, Int_t=0);  ; virtual TList * GetInputList () const;  ; const char * GetOption () const override;  ; virtual TList * GetOutputList () const;  ; virtual Long64_t GetStatus () const;  ; virtual void ImportOutput (TList *output);  Imports the content of 'output' in the internal output list. ;  ; TClass * IsA () const override;  ; bool Notify () override;  This method must be overridden to handle object notification (the base implementation is no-op). ;  ; virtual bool ProcessCut (Long64_t);  This method is called before processing entry. ;  ; virtual void ProcessFill (Long64_t);  This method is called for all selected entries. ;  ; virtual void ResetAbort ();  ; virtual void SetInputList (TList *input);  ; virtual void SetObject (TObject *obj);  ; virtual void SetOption (const char *option);  ; virtual void SetStatus (Long64_t status);  ; void Streamer (TBuffer &) overri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofDrawEntryList.html:1509,Abort,Abort,1509,doc/master/classTProofDrawEntryList.html,https://root.cern,https://root.cern/doc/master/classTProofDrawEntryList.html,4,['Abort'],['Abort']
Safety,"() const; voidCheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tCouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidDraw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tEpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoShape.html:7902,safe,safe,7902,root/html530/TGeoShape.html,https://root.cern,https://root.cern/root/html530/TGeoShape.html,1,['safe'],['safe']
Safety,"()) return;; 897 UShort_t pidf;; 898 if (R__b.IsReading()) {; 899 R__b.SkipVersion(); // Version_t R__v = R__b.ReadVersion(); if (R__v) { }; 900 R__b >> fUniqueID;; 901 const UInt_t isonheap = fBits & kIsOnHeap; // Record how this instance was actually allocated.; 902 R__b >> fBits;; 903 fBits |= isonheap | kNotDeleted; // by definition de-serialized object are not yet deleted.; 904 if (TestBit(kIsReferenced)) {; 905 //if the object is referenced, we must read its old address; 906 //and store it in the ProcessID map in gROOT; 907 R__b >> pidf;; 908 pidf += R__b.GetPidOffset();; 909 TProcessID *pid = R__b.ReadProcessID(pidf);; 910 if (pid) {; 911 UInt_t gpid = pid->GetUniqueID();; 912 if (gpid>=0xff) {; 913 fUniqueID = fUniqueID | 0xff000000;; 914 } else {; 915 fUniqueID = ( fUniqueID & 0xffffff) + (gpid<<24);; 916 }; 917 pid->PutObjectWithID(this);; 918 }; 919 }; 920 } else {; 921 R__b.WriteVersion(TObject::IsA());; 922 // Can not read TFile.h here and avoid going through the interpreter by; 923 // simply hard-coding this value.; 924 // This **must** be equal to TFile::k630forwardCompatibility; 925 constexpr int TFile__k630forwardCompatibility = BIT(2);; 926 const auto parent = R__b.GetParent();; 927 if (!TestBit(kIsReferenced)) {; 928 R__b << fUniqueID;; 929 if (R__unlikely(parent && parent->TestBit(TFile__k630forwardCompatibility))); 930 R__b << fBits;; 931 else; 932 R__b << (fBits & (~kIsOnHeap & ~kNotDeleted));; 933 } else {; 934 //if the object is referenced, we must save its address/file_pid; 935 UInt_t uid = fUniqueID & 0xffffff;; 936 R__b << uid;; 937 if (R__unlikely(parent && parent->TestBit(TFile__k630forwardCompatibility))); 938 R__b << fBits;; 939 else; 940 R__b << (fBits & (~kIsOnHeap & ~kNotDeleted));; 941 TProcessID *pid = TProcessID::GetProcessWithUID(fUniqueID,this);; 942 //add uid to the TRefTable if there is one; 943 TRefTable *table = TRefTable::GetRefTable();; 944 if(table) table->Add(uid, pid);; 945 pidf = R__b.WriteProcessID(pid);; 946 R__b <<",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TObject_8cxx_source.html:33999,avoid,avoid,33999,doc/master/TObject_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TObject_8cxx_source.html,1,['avoid'],['avoid']
Safety,"())) {; 4375 if (lib->TestBit(kMustCleanup)) {; 4376 TString libname = lib->GetTitle();; 4377#ifdef WIN32; 4378 // On Windows, we need to unload the dll before deleting it; 4379 if (gInterpreter->IsLibraryLoaded(libname)); 4380 ::FreeLibrary(::GetModuleHandle(libname));; 4381#endif; 4382 Unlink(libname);; 4383 TString target, soExt = ""."" + fSoExt;; 4384 libname.ReplaceAll(soExt, """");; 4385 for (const char *ext : extensions) {; 4386 target = libname + ext;; 4387 Unlink(target);; 4388 }; 4389 }; 4390 }; 4391}; 4392 ; 4393////////////////////////////////////////////////////////////////////////////////; 4394/// Register version of plugin library.; 4395 ; 4396TVersionCheck::TVersionCheck(int versionCode); 4397{; 4398 if (versionCode != TROOT::RootVersionCode() && gLibraryVersion); 4399 gLibraryVersion[gLibraryVersionIdx] = versionCode;; 4400}; FoundationUtils.hxxThe file contains utilities which are foundational and could be used across the core component of ROO...; SafeDelete#define SafeDelete(p)Definition RConfig.hxx:525; b#define b(i)Definition RSha256.hxx:100; f#define f(i)Definition RSha256.hxx:104; c#define c(i)Definition RSha256.hxx:101; a#define a(i)Definition RSha256.hxx:99; h#define h(i)Definition RSha256.hxx:106; e#define e(i)Definition RSha256.hxx:103; ROOT_RELEASE#define ROOT_RELEASEDefinition RVersion.hxx:29; sizesize_t size(const MatrixT &matrix)retrieve the size of a square matrix; Int_tint Int_tDefinition RtypesCore.h:45; kMaxIntconstexpr Int_t kMaxIntDefinition RtypesCore.h:105; Long_tlong Long_tDefinition RtypesCore.h:54; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; kNPOSconstexpr Ssiz_t kNPOSDefinition RtypesCore.h:117; Long64_tlong long Long64_tDefinition RtypesCore.h:69; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; Option_tconst char Option_tDefinition RtypesCore.h:66; ClassImp#define ClassImp(name)Definition Rtypes.h:382; kMAXPATHLEN@ kMAXPATHLENDefinition Rtypes.h:60; TApplication.h; gApplicationR__EXTERN TApplication * gAppl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:150832,Safe,SafeDelete,150832,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,2,['Safe'],['SafeDelete']
Safety,"(), len2 = stack2.size(), len = (len1 < len2) ? len1 : len2, indx = 0;; 273 while (indx < len) {; 274 if (stack1[indx] < stack2[indx]); 275 return -1;; 276 if (stack1[indx] > stack2[indx]); 277 return 1;; 278 ++indx;; 279 }; 280 ; 281 if (len1 < len2); 282 return -1;; 283 if (len1 > len2); 284 return 1;; 285 ; 286 return 0;; 287}; 288} // namespace; 289 ; 290/////////////////////////////////////////////////////////////////////; 291/// Issue signal, which distributed on all handlers - excluding source handler; 292 ; 293void RGeomDescription::IssueSignal(const void *handler, const std::string &kind); 294{; 295 std::vector<RGeomSignalFunc_t> funcs;; 296 ; 297 {; 298 TLockGuard lock(fMutex);; 299 for (auto &pair : fSignals); 300 if (!handler || (pair.first != handler)); 301 funcs.emplace_back(pair.second);; 302 }; 303 ; 304 // invoke signal outside locked mutex to avoid any locking; 305 for (auto func : funcs); 306 func(kind);; 307}; 308 ; 309/////////////////////////////////////////////////////////////////////; 310/// Add signal handler; 311 ; 312void RGeomDescription::AddSignalHandler(const void *handler, RGeomSignalFunc_t func); 313{; 314 TLockGuard lock(fMutex);; 315 fSignals.emplace_back(handler, func);; 316}; 317 ; 318/////////////////////////////////////////////////////////////////////; 319/// Remove signal handler; 320 ; 321void RGeomDescription::RemoveSignalHandler(const void *handler); 322{; 323 TLockGuard lock(fMutex);; 324 ; 325 for (auto iter = fSignals.begin(); iter != fSignals.end(); ++iter); 326 if (handler == iter->first) {; 327 fSignals.erase(iter);; 328 return;; 329 }; 330}; 331 ; 332/////////////////////////////////////////////////////////////////////; 333/// Pack matrix into vector, which can be send to client; 334/// Following sizes can be used for vector:; 335/// 0 - Identity matrix; 336/// 3 - Translation; 337/// 4 - Scale (last element always 1); 338/// 9 - Rotation; 339/// 16 - Full size; 340 ; 341void RGeomDescription::PackMatrix(std::vector<f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RGeomData_8cxx_source.html:7308,avoid,avoid,7308,doc/master/RGeomData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RGeomData_8cxx_source.html,2,['avoid'],['avoid']
Safety,"(). Bool_t TCling::HasPCMForLibrary ; (; const char * ; libname); const. finalvirtual . Return true if ROOT has cxxmodules pcm for a given library name. ; Implements TInterpreter.; Definition at line 3147 of file TCling.cxx. ◆ Initialize(). void TCling::Initialize ; (; ). finalvirtual . Initialize the interpreter, once TROOT::fInterpreter is set. ; Implements TInterpreter.; Definition at line 1636 of file TCling.cxx. ◆ InitRootmapFile(). void TCling::InitRootmapFile ; (; const char * ; name). private . Create a resource table and read the (possibly) three resource files, i.e. ; $ROOTSYS/etc/system<name> (or ROOTETCDIR/system<name>), $HOME/<name> and $PWD/<name>. ROOT always reads "".rootrc"" (in TROOT::InitSystem()). You can read additional user defined resource files by creating additional TEnv objects. By setting the shell variable ROOTENV_NO_HOME=1 the reading of the $HOME/<name> resource file will be skipped. This might be useful in case the home directory resides on an automounted remote file system and one wants to avoid the file system from being mounted. ; Definition at line 5655 of file TCling.cxx. ◆ InspectMembers(). void TCling::InspectMembers ; (; TMemberInspector & ; insp, . const void * ; obj, . const TClass * ; cl, . Bool_t ; isTransient . ). finalvirtual . Visit all members over members, recursing over base classes. ; Implements TInterpreter.; Definition at line 2684 of file TCling.cxx. ◆ InvalidateCachedDecl(). void TCling::InvalidateCachedDecl ; (; const std::tuple< TListOfDataMembers *, TListOfFunctions *, TListOfFunctionTemplates *, TListOfEnums * > & ; Lists, . const clang::Decl * ; D . ). private . Invalidate cached TCling information for the given declaration, and removed it from the appropriate object list. ; Parameters. [in]Lists- std::tuple<TListOfDataMembers&, TListOfFunctions&, TListOfFunctionTemplates&, TListOfEnums&> of pointers to the (global/class) object lists. ; [in]D- Decl to discard. . Definition at line 6891 of file TCling.cxx. ◆ I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTCling.html:107913,avoid,avoid,107913,doc/master/classTCling.html,https://root.cern,https://root.cern/doc/master/classTCling.html,1,['avoid'],['avoid']
Safety,"(). TGeoShape * TGeoTrd1::GetMakeRuntimeShape ; (; TGeoShape * ; mother, . TGeoMatrix * ; mat . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ GetOppositeCorner(). void TGeoTrd1::GetOppositeCorner ; (; const Double_t * ; point, . Int_t ; inorm, . Double_t * ; vertex, . Double_t * ; normals . ); const. ◆ GetVisibleCorner(). void TGeoTrd1::GetVisibleCorner ; (; const Double_t * ; point, . Double_t * ; vertex, . Double_t * ; normals . ); const. ◆ InspectShape(). void TGeoTrd1::InspectShape ; (; ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ IsA(). TClass * TGeoTrd1::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TGeoBBox.; Definition at line 78 of file TGeoTrd1.h. ◆ IsCylType(). Bool_t TGeoTrd1::IsCylType ; (; ); const. inlineoverridevirtual . Reimplemented from TGeoBBox.; Definition at line 68 of file TGeoTrd1.h. ◆ operator=(). TGeoTrd1 & TGeoTrd1::operator= ; (; const TGeoTrd1 & ; ). protecteddelete . ◆ Safety(). Double_t TGeoTrd1::Safety ; (; const Double_t * ; point, . Bool_t ; in = kTRUE . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ Safety_v(). void TGeoTrd1::Safety_v ; (; const Double_t * ; points, . const Bool_t * ; inside, . Double_t * ; safe, . Int_t ; vecsize . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ SavePrimitive(). void TGeoTrd1::SavePrimitive ; (; std::ostream & ; out, . Option_t * ; option = """" . ). overridevirtual . Save a primitive as a C++ statement(s) on output stream ""out"". ; Reimplemented from TGeoBBox. ◆ SetDimensions(). void TGeoTrd1::SetDimensions ; (; Double_t * ; param). overridevirtual . Reimplemented from TGeoBBox. ◆ SetPoints() [1/2]. void TGeoTrd1::SetPoints ; (; Double_t * ; points); const. overridevirtual . Reimplemented from TGeoBBox. ◆ SetPoints() [2/2]. void TGeoTrd1::SetPoints ; (; Float_t * ; points); const. overridevirtual . Reimplemented from TGeoBBox. ◆ SetVertex(). void TGeoTrd1::SetVertex ; (; Double_t * ; vertex); ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoTrd1.html:27597,Safe,Safety,27597,doc/master/classTGeoTrd1.html,https://root.cern,https://root.cern/doc/master/classTGeoTrd1.html,1,['Safe'],['Safety']
Safety,"(). TGeoShape * TGeoTrd2::GetMakeRuntimeShape ; (; TGeoShape * ; mother, . TGeoMatrix * ; mat . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ GetOppositeCorner(). void TGeoTrd2::GetOppositeCorner ; (; const Double_t * ; point, . Int_t ; inorm, . Double_t * ; vertex, . Double_t * ; normals . ); const. ◆ GetVisibleCorner(). void TGeoTrd2::GetVisibleCorner ; (; const Double_t * ; point, . Double_t * ; vertex, . Double_t * ; normals . ); const. ◆ InspectShape(). void TGeoTrd2::InspectShape ; (; ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ IsA(). TClass * TGeoTrd2::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TGeoBBox.; Definition at line 80 of file TGeoTrd2.h. ◆ IsCylType(). Bool_t TGeoTrd2::IsCylType ; (; ); const. inlineoverridevirtual . Reimplemented from TGeoBBox.; Definition at line 70 of file TGeoTrd2.h. ◆ operator=(). TGeoTrd2 & TGeoTrd2::operator= ; (; const TGeoTrd2 & ; ). protecteddelete . ◆ Safety(). Double_t TGeoTrd2::Safety ; (; const Double_t * ; point, . Bool_t ; in = kTRUE . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ Safety_v(). void TGeoTrd2::Safety_v ; (; const Double_t * ; points, . const Bool_t * ; inside, . Double_t * ; safe, . Int_t ; vecsize . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ SavePrimitive(). void TGeoTrd2::SavePrimitive ; (; std::ostream & ; out, . Option_t * ; option = """" . ). overridevirtual . Save a primitive as a C++ statement(s) on output stream ""out"". ; Reimplemented from TGeoBBox. ◆ SetDimensions(). void TGeoTrd2::SetDimensions ; (; Double_t * ; param). overridevirtual . Reimplemented from TGeoBBox. ◆ SetPoints() [1/2]. void TGeoTrd2::SetPoints ; (; Double_t * ; points); const. overridevirtual . Reimplemented from TGeoBBox. ◆ SetPoints() [2/2]. void TGeoTrd2::SetPoints ; (; Float_t * ; points); const. overridevirtual . Reimplemented from TGeoBBox. ◆ SetVertex(). void TGeoTrd2::SetVertex ; (; Double_t * ; vertex); ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoTrd2.html:27820,Safe,Safety,27820,doc/master/classTGeoTrd2.html,https://root.cern,https://root.cern/doc/master/classTGeoTrd2.html,1,['Safe'],['Safety']
Safety,"(). Volumes themselves support different visualization settings :; TGeoVolume::SetVisibility() : set volume visibility.; TGeoVolume::VisibleDaughters() : set daughters visibility. All these actions automatically updates the current view if any. Checking the geometry; Several checking methods are accessible from the volume context menu. They generally apply only to the visible parts of the drawn geometry in order to ease geometry checking, and their implementation is in the TGeoChecker class from the painting package.; Checking a given point.; Can be called from TGeoManager::CheckPoint(Double_t x, Double_t y, Double_t z). This method is drawing the daughters of the volume containing the point one level down, printing the path to the deepest physical node holding this point. It also computes the closest distance to any boundary. The point will be drawn in red, as well as a sphere having this closest distance as radius. In case a non-zero distance is given by the user as fifth argument of CheckPoint, this distance will be used as radius of the safety sphere. Shooting random points.; Can be called from TGeoVolume::RandomPoints() (context menu function) and it will draw this volume with current visualization settings. Random points are generated in the bounding box of the top drawn volume. The points are classified and drawn with the color of their deepest container. Only points in visible nodes will be drawn. Raytracing.; Can be called from TGeoVolume::RandomRays() (context menu of volumes) and will shoot rays from a given point in the local reference frame with random directions. The intersections with displayed nodes will appear as segments having the color of the touched node. Drawn geometry will be then made invisible in order to enhance rays. Definition at line 44 of file TGeoManager.h. Public Types; enum  EDefaultUnits { kG4Units = 0; , kRootUnits = 1; };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZom",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoManager.html:18648,safe,safety,18648,doc/master/classTGeoManager.html,https://root.cern,https://root.cern/doc/master/classTGeoManager.html,1,['safe'],['safety']
Safety,"(). const TMatrixDSparse * TUnfold::GetEinv ; (; void ; ); const. inlineprotected . matrix E-1, using internal bin counting ; Definition at line 256 of file TUnfold.h. ◆ GetEmatrix(). void TUnfold::GetEmatrix ; (; TH2 * ; ematrix, . const Int_t * ; binMap = nullptr . ); const. get output covariance matrix, possibly cumulated over several bins ; Parameters. [out]ematrixhistogram to store the covariance. The bin contents are overwritten. ; [in]binMap(default=nullptr) array for mapping truth bins to histogram bins. The use of binMap is explained with the documentation of the GetOutput() method ; Definition at line 3446 of file TUnfold.cxx. ◆ GetEpsMatrix(). Double_t TUnfold::GetEpsMatrix ; (; void ; ); const. inline . get numerical accuracy for Eigenvalue analysis when inverting matrices with rank problems ; Definition at line 352 of file TUnfold.h. ◆ GetFoldedOutput(). void TUnfold::GetFoldedOutput ; (; TH1 * ; out, . const Int_t * ; binMap = nullptr . ); const. get unfolding result on detector level ; Parameters. [out]outhistogram to store the correlation coefficiencts. The bin contents and errors are overwritten. ; [in]binMap(default=nullptr) array for mapping truth bins to histogram bins. This method returns the unfolding output folded by the response matrix, i.e. the vector Ax.; The use of binMap is explained with the documentation of the GetOutput() method ; Definition at line 2962 of file TUnfold.cxx. ◆ GetInput(). void TUnfold::GetInput ; (; TH1 * ; out, . const Int_t * ; binMap = nullptr . ); const. Input vector of measurements. ; Parameters. [out]outhistogram to store the measurements. Bin content and bin errors are overwritte. ; [in]binMap(default=nullptr) array for mapping truth bins to histogram bins. Bins which had an uncertainty of zero in the call to SetInput() maye acquire bin contents or bin errors different from the original settings in SetInput().; The use of binMap is explained with the documentation of the GetOutput() method ; Definition at line 30",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnfold.html:35945,detect,detector,35945,doc/master/classTUnfold.html,https://root.cern,https://root.cern/doc/master/classTUnfold.html,1,['detect'],['detector']
Safety,"(). virtual void TBuffer::ClassMember ; (; const char * ; , . const char * ; = nullptr, . Int_t ; = -1, . Int_t ; = -1 . ). pure virtual . Implemented in TBufferFile, TBufferJSON, TBufferSQL2, and TBufferXML. ◆ DeclFileName(). static const char * TBuffer::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 340 of file TBuffer.h. ◆ DecrementLevel(). virtual void TBuffer::DecrementLevel ; (; TVirtualStreamerInfo * ; ). pure virtual . Implemented in TBufferJSON, TBufferSQL2, TBufferXML, and TBufferFile. ◆ DetachBuffer(). void TBuffer::DetachBuffer ; (; ). inline . Definition at line 99 of file TBuffer.h. ◆ Expand(). void TBuffer::Expand ; (; Int_t ; newsize, . Bool_t ; copy = kTRUE . ). Expand (or shrink) the I/O buffer to newsize bytes. ; If copy is true (the default), the existing content of the buffer is preserved, otherwise the buffer is returned zero-ed out.; In order to avoid losing data, if the current length is greater than the requested size, we only shrink down to the current length. ; Definition at line 223 of file TBuffer.cxx. ◆ ForceWriteInfo(). virtual void TBuffer::ForceWriteInfo ; (; TVirtualStreamerInfo * ; info, . Bool_t ; force . ). pure virtual . Implemented in TBufferIO, and TMessage. ◆ ForceWriteInfoClones(). virtual void TBuffer::ForceWriteInfoClones ; (; TClonesArray * ; a). pure virtual . Implemented in TBufferIO. ◆ GetBufferDisplacement(). virtual Int_t TBuffer::GetBufferDisplacement ; (; ); const. pure virtual . Implemented in TBufferIO. ◆ GetBufferVersion(). Int_t TBuffer::GetBufferVersion ; (; ); const. inline . Definition at line 85 of file TBuffer.h. ◆ GetClass() [1/2]. TClass * TBuffer::GetClass ; (; const char * ; className). static . Forward to TROOT::GetClass(). ; Definition at line 336 of file TBuffer.cxx. ◆ GetClass() [2/2]. TClass * TBuffer::GetClass ; (; const std::type_info & ; typeinfo). static . Forward to TROOT::GetClass(). ; Definition at line 328 of file TBuffer.cx",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBuffer.html:31263,avoid,avoid,31263,doc/master/classTBuffer.html,https://root.cern,https://root.cern/doc/master/classTBuffer.html,1,['avoid'],['avoid']
Safety,"(). void ROOT::RGeomDescription::SetNSegments ; (; int ; n = 0). inline . Set number of segments for cylindrical shapes, if 0 - default value will be used. ; Definition at line 342 of file RGeomData.hxx. ◆ SetPhysNodeVisibility() [1/2]. bool RGeomDescription::SetPhysNodeVisibility ; (; const std::string & ; path, . bool ; on = true . ). Set visibility of physical node by itemname itemname in string with path like ""/TOP_1/SUB_2/NODE_3"". ; Definition at line 2016 of file RGeomData.cxx. ◆ SetPhysNodeVisibility() [2/2]. bool RGeomDescription::SetPhysNodeVisibility ; (; const std::vector< std::string > & ; path, . bool ; on = true . ). Set visibility of physical node by path It overrules TGeo visibility flags - but only for specific physical node. ; Definition at line 1970 of file RGeomData.cxx. ◆ SetPreferredOffline(). void ROOT::RGeomDescription::SetPreferredOffline ; (; bool ; on). inline . Set preference of offline operations. ; Server provides more info to client from the begin on to avoid communication ; Definition at line 358 of file RGeomData.hxx. ◆ SetSearch(). bool RGeomDescription::SetSearch ; (; const std::string & ; query, . const std::string & ; json . ). Change search query and belongs to it json string Returns true if any parameter was really changed. ; Definition at line 2130 of file RGeomData.cxx. ◆ SetTopVisible(). void ROOT::RGeomDescription::SetTopVisible ; (; bool ; on = true). inline . Set draw options as string for JSROOT TGeoPainter. ; Definition at line 332 of file RGeomData.hxx. ◆ SetVisLevel(). void ROOT::RGeomDescription::SetVisLevel ; (; int ; lvl = 3). inline . Set maximal visible level. ; Definition at line 327 of file RGeomData.hxx. Friends And Related Symbol Documentation. ◆ RGeomBrowserIter. friend class RGeomBrowserIter. friend . Definition at line 212 of file RGeomData.hxx. Member Data Documentation. ◆ fActiveItemName. std::string ROOT::RGeomDescription::fActiveItemName. private . ! name of item which should be activated in hierarchy ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RGeomDescription.html:27737,avoid,avoid,27737,doc/v632/classROOT_1_1RGeomDescription.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RGeomDescription.html,2,['avoid'],['avoid']
Safety,"(). void TBufferSQL::WriteCharStar ; (; char * ; s). finalvirtual . Write a char* string. ; Reimplemented from TBufferFile.; Definition at line 344 of file TBufferSQL.cxx. ◆ WriteDouble(). void TBufferSQL::WriteDouble ; (; Double_t ; d). finalvirtual . Operator<<. ; Reimplemented from TBufferFile.; Definition at line 212 of file TBufferSQL.cxx. ◆ WriteFastArray() [1/15]. void TBufferSQL::WriteFastArray ; (; const bool * ; b, . Long64_t ; n . ). finalvirtual . WriteFastArray SQL implementation. ; NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Reimplemented from TBufferFile.; Definition at line 427 of file TBufferSQL.cxx. ◆ WriteFastArray() [2/15]. void TBufferSQL::WriteFastArray ; (; const Char_t * ; c, . Long64_t ; n . ). finalvirtual . WriteFastArray SQL implementation. ; NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Reimplemented from TBufferFile.; Definition at line 447 of file TBufferSQL.cxx. ◆ WriteFastArray() [3/15]. void TBufferSQL::WriteFastArray ; (; const Double_t * ; d, . Long64_t ; n . ). finalvirtual . WriteFastArray SQL implementation. ; NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Reimplemented from TBufferFile.; Definition at line 688 of file TBufferSQL.cxx. ◆ WriteFastArray() [4/15]. void TBufferSQL::WriteFastArray ; (; const Float_t * ; f, . Long64_t ; n . ). finalvirtual . WriteFastArray SQL implementation. ; NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBufferSQL.html:51181,abort,aborts,51181,doc/master/classTBufferSQL.html,https://root.cern,https://root.cern/doc/master/classTBufferSQL.html,1,['abort'],['aborts']
Safety,"(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoSphere&operator=(const TGeoSphere&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); voidSetDimensions(Double_t* param, Int_t nparam); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); virtual voidSetNu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoSphere.html:9085,safe,safe,9085,root/html534/TGeoSphere.html,https://root.cern,https://root.cern/root/html534/TGeoSphere.html,1,['safe'],['safe']
Safety,"(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTGeoShape::Paint(Option_t* option = """"); Double_t&Phi1(); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); Double_t&Rmax(Int_t ipl); Double_t&Rmin(Int_t ipl); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); Double_tSafetyToSegment(const Double_t* point, Int_t ipl, Bool_t in = kTRUE, Double_t safmin = TGeoShape::Big()) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoPcon.html:8647,safe,safe,8647,root/html602/TGeoPcon.html,https://root.cern,https://root.cern/root/html602/TGeoPcon.html,2,['safe'],['safe']
Safety,"(1.0 - (effBH - effB))) / (1.0 + effS);; 934 // alternative idea; 935 //if (effBH<0) eta = (1.e-6+effB)/(1.0 + effS);; 936 //else eta = (effB - effBH) * (1.0 + 10.* effS);; 937 ; 938 // if a point is found which is better than an existing one, ... replace it.; 939 // preliminary best event -> backup; 940 if (effBH < 0 || effBH > effB) {; 941 fEffBvsSLocal->SetBinContent( ibinS, effB );; 942 for (UInt_t ivar=0; ivar<GetNvar(); ivar++) {; 943 fCutMin[ivar][ibinS-1] = fTmpCutMin[ivar]; // bin 1 stored in index 0; 944 fCutMax[ivar][ibinS-1] = fTmpCutMax[ivar];; 945 }; 946 }; 947 ; 948 // caution (!) this value is not good for a decision for MC, .. it is designed for GA; 949 // but .. it doesn't matter, as MC samplings are independent from the former ones; 950 // and the replacement of the best variables by better ones is done about 10 lines above.; 951 // ( if (effBH < 0 || effBH > effB) { .... ); 952 ; 953 if (ibinS<=1) {; 954 // add penalty for effS=0 bin; 955 // to avoid that the minimizer gets stuck in the zero-bin; 956 // force it towards higher efficiency; 957 Double_t penalty=0.,diff=0.;; 958 for (UInt_t ivar=0; ivar<GetNvar(); ivar++) {; 959 diff=(fCutRange[ivar]->GetMax()-fTmpCutMax[ivar])/(fCutRange[ivar]->GetMax()-fCutRange[ivar]->GetMin());; 960 penalty+=diff*diff;; 961 diff=(fCutRange[ivar]->GetMin()-fTmpCutMin[ivar])/(fCutRange[ivar]->GetMax()-fCutRange[ivar]->GetMin());; 962 penalty+=4.*diff*diff;; 963 }; 964 ; 965 if (effS<1.e-4) return 10.0+penalty;; 966 else return 10.*(1.-10.*effS);; 967 }; 968 return eta;; 969}; 970 ; 971////////////////////////////////////////////////////////////////////////////////; 972/// translates parameters into cuts; 973 ; 974void TMVA::MethodCuts::MatchParsToCuts( const std::vector<Double_t> & pars,; 975 Double_t* cutMin, Double_t* cutMax ); 976{; 977 for (UInt_t ivar=0; ivar<GetNvar(); ivar++) {; 978 Int_t ipar = 2*ivar;; 979 cutMin[ivar] = ((*fRangeSign)[ivar] > 0) ? pars[ipar] : pars[ipar] - pars[ipar+1];; 980 cutMax[ivar] ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodCuts_8cxx_source.html:35564,avoid,avoid,35564,doc/master/MethodCuts_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodCuts_8cxx_source.html,1,['avoid'],['avoid']
Safety,"(1ULL << ( 29 )); , ;   kGeoHype = (1ULL << ( 30 )); , kGeoSavePrimitive = (1ULL << ( 20 )). };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Public Attributes inherited from TGeoBBox; static Bool_t DO NOT USE !The overlap detection does not work for all cases;  ; static Bool_t DEPRECATED;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Attributes inherited from TGeoBBox; Double_t fDX;  ; Double_t fDY;  ; Double_t fDZ;  ; Double_t fOrigin [3];  ;  Protected Attributes inherited from TGeoShape; UInt_t fShapeBits;  ; Int_t fShapeId;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . #include <TGeoCompositeShape.h>. Inheritance diagram for TGeoCompositeShape:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TGeoCompositeShape() [1/5]. TGeoCompositeShape::TGeoCompositeShape ; (; const TGeoCompositeShape & ; ). protecteddelete . ◆ TGeoCompositeShape() [2/5]. TGeoCompositeShape::TGeoCompositeShape ; (; ). Default constructor. ; Definition at line 218 of file TGeoCompositeShape.cxx. ◆ TGeoCompositeShape() [3/5]. TGeoCompositeShape::TGeoCompositeShape ; (; const char * ; name, . const char * ; expression . ). Default constructor. ; Definition at line 227 of file TGeoCompositeShape.cxx. ◆ TGeoCompositeShape() [4/5]. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoCompositeShape.html:32710,detect,detection,32710,doc/master/classTGeoCompositeShape.html,https://root.cern,https://root.cern/doc/master/classTGeoCompositeShape.html,1,['detect'],['detection']
Safety,"(2,0,10*rms);; 376 ; 377 ; 378#ifdef DEBUG; 379 std::cout << ""Gaussian initial par values"" << constant << "" "" << mean << "" "" << rms << std::endl;; 380#endif; 381 ; 382}; 383 ; 384////////////////////////////////////////////////////////////////////////////////; 385/// Compute Initial values of parameters for a gaussian; 386/// derived from function H1InitGaus defined in TH1.cxx; 387 ; 388void Init2DGaus(const ROOT::Fit::BinData & data, TF1 * f1); 389{; 390 ; 391 static const double sqrtpi = 2.506628;; 392 ; 393 // - Compute mean value and RMS of the data; 394 unsigned int n = data.Size();; 395 if (n == 0) return;; 396 double sumx = 0, sumy = 0;; 397 double sumx2 = 0, sumy2 = 0;; 398 double allcha = 0;; 399 double valmax = 0;; 400 double rangex = data.Coords(n-1)[0] - data.Coords(0)[0];; 401 double rangey = data.Coords(n-1)[1] - data.Coords(0)[1];; 402 // to avoid binwidthx = 0 set arbitrarly to 1; 403 double binwidthx = 1, binwidthy = 1;; 404 if ( rangex > 0) binwidthx = rangex;; 405 if ( rangey > 0) binwidthy = rangey;; 406 double x0 = 0, y0 = 0;; 407 for (unsigned int i = 0; i < n; ++i) {; 408 double val;; 409 const double *coords = data.GetPoint(i,val);; 410 double x = coords[0], y = coords[1];; 411 sumx += val*x;; 412 sumy += val*y;; 413 sumx2 += val*x*x;; 414 sumy2 += val*y*y;; 415 allcha += val;; 416 if (val > valmax) valmax = val;; 417 if (i > 0) {; 418 double dx = x - x0;; 419 if (dx < binwidthx) binwidthx = dx;; 420 double dy = y - y0;; 421 if (dy < binwidthy) binwidthy = dy;; 422 }; 423 x0 = x;; 424 y0 = y;; 425 }; 426 ; 427 if (allcha <= 0) return;; 428 double meanx = sumx/allcha, meany = sumy/allcha;; 429 double rmsx = sumx2/allcha - meanx*meanx;; 430 double rmsy = sumy2/allcha - meany*meany;; 431 ; 432 ; 433 if (rmsx > 0); 434 rmsx = std::sqrt(rmsx);; 435 else; 436 rmsx = binwidthx*n/4;; 437 ; 438 if (rmsy > 0); 439 rmsy = std::sqrt(rmsy);; 440 else; 441 rmsy = binwidthy*n/4;; 442 ; 443 ; 444 //if the distribution is really gaussian, the best approximatio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/HFitInterface_8cxx_source.html:13215,avoid,avoid,13215,doc/master/HFitInterface_8cxx_source.html,https://root.cern,https://root.cern/doc/master/HFitInterface_8cxx_source.html,1,['avoid'],['avoid']
Safety,"(999999). ; Reimplemented from TGeoBBox.; Reimplemented in TGeoTubeSeg. ◆ DistFromInside(). Double_t TGeoTube::DistFromInside ; (; const Double_t * ; point, . const Double_t * ; dir, . Int_t ; iact = 1, . Double_t ; step = TGeoShape::Big(), . Double_t * ; safe = nullptr . ); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoTubeSeg. ◆ DistFromInside_v(). void TGeoTube::DistFromInside_v ; (; const Double_t * ; points, . const Double_t * ; dirs, . Double_t * ; dists, . Int_t ; vecsize, . Double_t * ; step . ); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoTubeSeg. ◆ DistFromInsideS(). static Double_t TGeoTube::DistFromInsideS ; (; const Double_t * ; point, . const Double_t * ; dir, . Double_t ; rmin, . Double_t ; rmax, . Double_t ; dz . ). static . ◆ DistFromOutside(). Double_t TGeoTube::DistFromOutside ; (; const Double_t * ; point, . const Double_t * ; dir, . Int_t ; iact = 1, . Double_t ; step = TGeoShape::Big(), . Double_t * ; safe = nullptr . ); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoTubeSeg. ◆ DistFromOutside_v(). void TGeoTube::DistFromOutside_v ; (; const Double_t * ; points, . const Double_t * ; dirs, . Double_t * ; dists, . Int_t ; vecsize, . Double_t * ; step . ); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoTubeSeg. ◆ DistFromOutsideS(). static Double_t TGeoTube::DistFromOutsideS ; (; const Double_t * ; point, . const Double_t * ; dir, . Double_t ; rmin, . Double_t ; rmax, . Double_t ; dz . ). static . ◆ DistToTube(). static void TGeoTube::DistToTube ; (; Double_t ; rsq, . Double_t ; nsq, . Double_t ; rdotn, . Double_t ; radius, . Double_t & ; b, . Double_t & ; delta . ). static . ◆ Divide(). TGeoVolume * TGeoTube::Divide ; (; TGeoVolume * ; voldiv, . const char * ; divname, . Int_t ; iaxis, . Int_t ; ndiv, . Double_t ; start, . Double_t ; step . ). overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoTubeSeg. ◆ GetAxi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoTube.html:26558,safe,safe,26558,doc/master/classTGeoTube.html,https://root.cern,https://root.cern/doc/master/classTGeoTube.html,1,['safe'],['safe']
Safety,"(; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TGeoBBox.; Definition at line 92 of file TGeoHype.h. ◆ IsCylType(). Bool_t TGeoHype::IsCylType ; (; ); const. inlineoverridevirtual . Reimplemented from TGeoBBox.; Definition at line 78 of file TGeoHype.h. ◆ MakeBuffer3D(). TBuffer3D * TGeoHype::MakeBuffer3D ; (; ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ operator=(). TGeoHype & TGeoHype::operator= ; (; const TGeoHype & ; ). privatedelete . ◆ RadiusHypeSq(). Double_t TGeoHype::RadiusHypeSq ; (; Double_t ; z, . Bool_t ; inner . ); const. ◆ Safety(). Double_t TGeoHype::Safety ; (; const Double_t * ; point, . Bool_t ; in = kTRUE . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ Safety_v(). void TGeoHype::Safety_v ; (; const Double_t * ; points, . const Bool_t * ; inside, . Double_t * ; safe, . Int_t ; vecsize . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ SafetyToHype(). Double_t TGeoHype::SafetyToHype ; (; const Double_t * ; point, . Bool_t ; inner, . Bool_t ; in . ); const. ◆ SavePrimitive(). void TGeoHype::SavePrimitive ; (; std::ostream & ; out, . Option_t * ; option = """" . ). overridevirtual . Save a primitive as a C++ statement(s) on output stream ""out"". ; Reimplemented from TGeoBBox. ◆ SetDimensions(). void TGeoHype::SetDimensions ; (; Double_t * ; param). overridevirtual . Reimplemented from TGeoBBox. ◆ SetHypeDimensions(). void TGeoHype::SetHypeDimensions ; (; Double_t ; rin, . Double_t ; stin, . Double_t ; rout, . Double_t ; stout, . Double_t ; dz . ). ◆ SetPoints() [1/2]. void TGeoHype::SetPoints ; (; Double_t * ; points); const. overridevirtual . Reimplemented from TGeoBBox. ◆ SetPoints() [2/2]. void TGeoHype::SetPoints ; (; Float_t * ; points); const. overridevirtual . Reimplemented from TGeoBBox. ◆ SetSegsAndPols(). void TGeoHype::SetSegsAndPols ; (; TBuffer3D & ; buff); const. overridevirtual . Reimplemented from TGeoBBox. ◆ Sizeof3D(). void TGeoHype::Sizeof3D ; (; ); ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoHype.html:33472,Safe,SafetyToHype,33472,doc/master/classTGeoHype.html,https://root.cern,https://root.cern/doc/master/classTGeoHype.html,1,['Safe'],['SafetyToHype']
Safety,"(; Ssiz_t ; nc). Return string capacity. ; If nc != current capacity Clone() the string in a string with the desired capacity. ; Definition at line 442 of file TString.cxx. ◆ Chop(). TString & TString::Chop ; (; ). inline . Definition at line 691 of file TString.h. ◆ Class(). static TClass * TString::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TString::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TString::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 473 of file TString.h. ◆ Clear(). void TString::Clear ; (; ). Clear string without changing its capacity. ; Definition at line 1235 of file TString.cxx. ◆ Clobber(). Ssiz_t TString::Clobber ; (; Ssiz_t ; nc). protected . Clear string and make sure it has a capacity of nc. ; WarningIf nc > MaxSize(), then Fatal() is raised, and only MaxSize() elements are allocated if Fatal does not abort ; ReturnsResulting allocated capacity (after clamping, if needed) ; Definition at line 1246 of file TString.cxx. ◆ Clone(). void TString::Clone ; (; Ssiz_t ; tot). private . Make self a distinct copy with capacity of at least tot, where tot cannot be smaller than the current length. ; Preserve previous contents. WarningIf tot > MaxSize(), then Fatal() is raised and only MaxSize() elements are allocated ; Definition at line 1279 of file TString.cxx. ◆ CompareTo() [1/2]. int TString::CompareTo ; (; const char * ; cs2, . ECaseCompare ; cmp = kExact . ); const. Compare a string to char *cs2. ; Returns returns zero if the two strings are identical, otherwise returns the difference between the first two differing bytes (treated as unsigned char values, so that ‘\200’ is greater than ‘\0’, for example). Zero-length strings are always identical. ; Definition at line 457 of file TString.cxx. ◆ CompareTo() [2/2]. int TString::CompareTo ; (; const TString & ; str, . ECaseCompare ; cmp = kExa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTString.html:25428,abort,abort,25428,doc/master/classTString.html,https://root.cern,https://root.cern/doc/master/classTString.html,2,['abort'],['abort']
Safety,"(Double_t *param);  ;  TGeoPara (Double_t dx, Double_t dy, Double_t dz, Double_t alpha, Double_t theta, Double_t phi);  ;  ~TGeoPara () override;  ; Double_t Capacity () const override;  ; void ComputeBBox () override;  ; void ComputeNormal (const Double_t *point, const Double_t *dir, Double_t *norm) override;  ; void ComputeNormal_v (const Double_t *points, const Double_t *dirs, Double_t *norms, Int_t vecsize) override;  ; Bool_t Contains (const Double_t *point) const override;  ; void Contains_v (const Double_t *points, Bool_t *inside, Int_t vecsize) const override;  ; Double_t DistFromInside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override;  ; void DistFromInside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override;  ; Double_t DistFromOutside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override;  ; void DistFromOutside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override;  ; TGeoVolume * Divide (TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) override;  ; Double_t GetAlpha () const;  ; Double_t GetAxisRange (Int_t iaxis, Double_t &xlo, Double_t &xhi) const override;  ; void GetBoundingCylinder (Double_t *param) const override;  ; Int_t GetByteCount () const override;  ; Int_t GetFittingBox (const TGeoBBox *parambox, TGeoMatrix *mat, Double_t &dx, Double_t &dy, Double_t &dz) const override;  ; TGeoShape * GetMakeRuntimeShape (TGeoShape *mother, TGeoMatrix *mat) const override;  ; Int_t GetNmeshVertices () const override;  ; Double_t GetPhi () const;  ; Double_t GetTheta () const;  ; Double_t GetTxy () const;  ; Double_t GetTxz () const;  ; Double_t GetTyz () const;  ; Double_t GetX () const;  ; Double_t GetY () const;  ; Double_t GetZ () const; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoPara.html:1513,safe,safe,1513,doc/master/classTGeoPara.html,https://root.cern,https://root.cern/doc/master/classTGeoPara.html,1,['safe'],['safe']
Safety,"(Int_t iaxis) const. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const. void GetBoundingCylinder(Double_t* param) const. Int_t GetByteCount() const. Bool_t GetPointsOnSegments(Int_t npoints, Double_t* array) const. Int_t GetFittingBox(const TGeoBBox* parambox, TGeoMatrix* mat, Double_t& dx, Double_t& dy, Double_t& dz) const. Int_t GetId() const; {return fShapeId;}. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const. void GetMeshNumbers(Int_t& , Int_t& , Int_t& ) const; {;}. Int_t GetNmeshVertices() const; {return 0;}. Bool_t IsAssembly() const; {return kFALSE;}. Bool_t IsComposite() const; {return kFALSE;}. Bool_t IsCylType() const. Bool_t IsReflected() const; {return kFALSE;}. Bool_t IsRunTimeShape() const; {return TestShapeBit(kGeoRunTimeShape);}. Bool_t IsValid() const; {return !TestShapeBit(kGeoInvalidShape);}. Bool_t IsValidBox() const. void InspectShape() const. TBuffer3D * MakeBuffer3D() const; {return 0;}. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const. void SetDimensions(Double_t* param). void SetId(Int_t id); {fShapeId = id;}. void SetPoints(Double_t* points) const. void SetPoints(Float_t* points) const. void SetSegsAndPols(TBuffer3D& buff) const. void SetRuntime(Bool_t flag = kTRUE); {SetShapeBit(kGeoRunTimeShape, flag);}. void Sizeof3D() const. void SetShapeBit(UInt_t f, Bool_t set); ----- bit manipulation. void ResetShapeBit(UInt_t f); { fShapeBits &= ~(f & kBitMask32); }. Bool_t TestShapeBit(UInt_t f) const; { return (Bool_t) ((fShapeBits & f) != 0); }. Int_t TestShapeBits(UInt_t f) const; { return (Int_t) (fShapeBits & f); }. void InvertShapeBit(UInt_t f); { fShapeBits ^= f & kBitMask32; }. » Author: Andrei Gheata 31/01/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id: TGeoShape.h 35047 2010-08-27 14:38:41Z agheata $ » Last generated: 2010-11-08 19:55; This page has been automatically generated. For comments or suggestions regarding the documentation or ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoShape.html:20494,Safe,Safety,20494,root/html528/TGeoShape.html,https://root.cern,https://root.cern/root/html528/TGeoShape.html,1,['Safe'],['Safety']
Safety,"(Int_t iaxis) const. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const. void GetBoundingCylinder(Double_t* param) const. Int_t GetByteCount() const. Bool_t GetPointsOnSegments(Int_t npoints, Double_t* array) const. Int_t GetFittingBox(const TGeoBBox* parambox, TGeoMatrix* mat, Double_t& dx, Double_t& dy, Double_t& dz) const. Int_t GetId() const; {return fShapeId;}. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const. void GetMeshNumbers(Int_t& , Int_t& , Int_t& ) const; {;}. Int_t GetNmeshVertices() const; {return 0;}. Bool_t IsAssembly() const; {return kFALSE;}. Bool_t IsComposite() const; {return kFALSE;}. Bool_t IsCylType() const. Bool_t IsReflected() const; {return kFALSE;}. Bool_t IsRunTimeShape() const; {return TestShapeBit(kGeoRunTimeShape);}. Bool_t IsValid() const; {return !TestShapeBit(kGeoInvalidShape);}. Bool_t IsValidBox() const. void InspectShape() const. TBuffer3D * MakeBuffer3D() const; {return 0;}. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const. void SetDimensions(Double_t* param). void SetId(Int_t id); {fShapeId = id;}. void SetPoints(Double_t* points) const. void SetPoints(Float_t* points) const. void SetSegsAndPols(TBuffer3D& buff) const. void SetRuntime(Bool_t flag = kTRUE); {SetShapeBit(kGeoRunTimeShape, flag);}. void Sizeof3D() const. void SetShapeBit(UInt_t f, Bool_t set); ----- bit manipulation. void ResetShapeBit(UInt_t f); { fShapeBits &= ~(f & kBitMask32); }. Bool_t TestShapeBit(UInt_t f) const; { return (Bool_t) ((fShapeBits & f) != 0); }. Int_t TestShapeBits(UInt_t f) const; { return (Int_t) (fShapeBits & f); }. void InvertShapeBit(UInt_t f); { fShapeBits ^= f & kBitMask32; }. » Author: Andrei Gheata 31/01/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id: TGeoShape.h 39018 2011-04-25 09:38:31Z agheata $ » Last generated: 2011-07-04 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoShape.html:21011,Safe,Safety,21011,root/html530/TGeoShape.html,https://root.cern,https://root.cern/root/html530/TGeoShape.html,1,['Safe'],['Safety']
Safety,"(Int_t iaxis) const. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const. void GetBoundingCylinder(Double_t* param) const. Int_t GetByteCount() const. Bool_t GetPointsOnSegments(Int_t npoints, Double_t* array) const. Int_t GetFittingBox(const TGeoBBox* parambox, TGeoMatrix* mat, Double_t& dx, Double_t& dy, Double_t& dz) const. Int_t GetId() const; {return fShapeId;}. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const. void GetMeshNumbers(Int_t& , Int_t& , Int_t& ) const; {;}. Int_t GetNmeshVertices() const; {return 0;}. Bool_t IsAssembly() const; {return kFALSE;}. Bool_t IsComposite() const; {return kFALSE;}. Bool_t IsCylType() const. Bool_t IsReflected() const; {return kFALSE;}. Bool_t IsRunTimeShape() const; {return TestShapeBit(kGeoRunTimeShape);}. Bool_t IsValid() const; {return !TestShapeBit(kGeoInvalidShape);}. Bool_t IsValidBox() const. void InspectShape() const. TBuffer3D * MakeBuffer3D() const; {return 0;}. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const. void SetDimensions(Double_t* param). void SetId(Int_t id); {fShapeId = id;}. void SetPoints(Double_t* points) const. void SetPoints(Float_t* points) const. void SetSegsAndPols(TBuffer3D& buff) const. void SetRuntime(Bool_t flag = kTRUE); {SetShapeBit(kGeoRunTimeShape, flag);}. void Sizeof3D() const. void SetShapeBit(UInt_t f, Bool_t set); ----- bit manipulation. void ResetShapeBit(UInt_t f); { fShapeBits &= ~(f & kBitMask32); }. Bool_t TestShapeBit(UInt_t f) const; { return (Bool_t) ((fShapeBits & f) != 0); }. Int_t TestShapeBits(UInt_t f) const; { return (Int_t) (fShapeBits & f); }. void InvertShapeBit(UInt_t f); { fShapeBits ^= f & kBitMask32; }. » Author: Andrei Gheata 31/01/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id: TGeoShape.h 41234 2011-10-06 15:48:52Z agheata $ » Last generated: 2011-12-02 14:27; This page has been automatically generated. For comments or suggestions regarding the documentation or ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoShape.html:21082,Safe,Safety,21082,root/html532/TGeoShape.html,https://root.cern,https://root.cern/root/html532/TGeoShape.html,1,['Safe'],['Safety']
Safety,"(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2, dZ. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; in case shape has some negative parameters, these has to be computed; in order to fit the mother. void InspectShape() const; print shape parameters. TBuffer3D * MakeBuffer3D() const; Creates a TBuffer3D describing *this* shape.; Coordinates are in local reference frame. void SetSegsAndPols(TBuffer3D& buff) const; Fill TBuffer3D structure for segments and polygons. Double_t Safety(const Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape, according; to option. The matching point on the shape is stored in spoint. Double_t SafetyS(const Double_t* point, Bool_t in, Double_t rmin, Double_t rmax, Double_t dz, Int_t skipz = 0); computes the closest distance from given point to this shape, according; to option. The matching point on the shape is stored in spoint. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetTubeDimensions(Double_t rmin, Double_t rmax, Double_t dz); Set tube dimensions. void SetDimensions(Double_t* param); Set tube dimensions starting from a list. Bool_t GetPointsOnSegments(Int_t npoints, Double_t* array) const; Fills array with n random points located on the line segments of the shape mesh.; The output array must be provided with a length of minimum 3*npoints. Returns; true if operation is implemented. void SetPoints(Double_t* points) const; create tube mesh points. void SetPoints(Float_t* points) const; create tube mesh points. Int_t GetNmeshVertices() const; Return number of vertices of the mesh representation. void GetMeshNumbers(Int_t& nvert, Int_t& nsegs, Int_t& npols) const; Returns numbers ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoTube.html:17741,Safe,SafetyS,17741,root/html534/TGeoTube.html,https://root.cern,https://root.cern/root/html534/TGeoTube.html,3,['Safe'],['SafetyS']
Safety,"(Long64_t pointer, Int_t nbytes, TDirectory* motherDir = 0); Create a TKey object to read keys.; Constructor called by TDirectoryFile::ReadKeys and by TFile::TFile.; A TKey object is created to read the keys structure itself. TKey(const char* name, const char* title, const TClass* cl, Int_t nbytes, TDirectory* motherDir = 0); Create a TKey object with the specified name, title for the given class. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). TKey(const TString& name, const TString& title, const TClass* cl, Int_t nbytes, TDirectory* motherDir = 0); Create a TKey object with the specified name, title for the given class. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). TKey(const TObject* obj, const char* name, Int_t bufsize, TDirectory* motherDir = 0); Create a TKey object for a TObject* and fill output buffer. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). TKey(const void* obj, const TClass* cl, const char* name, Int_t bufsize, TDirectory* motherDir = 0); Create a TKey object for any object obj of class cl d and fill; output buffer. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). void Build(TDirectory* motherDir, const char* classname, Long64_t filepos); method used in all TKey constructor to initialize basic data fields; filepos is used to calculate correct version number of key; if filepos==-1, end of file position is used. void Browse(TBrowser* b); Read object from disk and call its Browse() method.; If object with same name already exist in memory delete it (like; TDirectoryFile::Get() is doing), except when the key references a; folder in which case we don't want to re-read the folder object; since it might contain new objects not yet saved. void Create(Int_t nbytes, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TKey.html:9986,avoid,avoid,9986,root/html528/TKey.html,https://root.cern,https://root.cern/root/html528/TKey.html,4,['avoid'],['avoid']
Safety,"(Option_t* option); Paint method. TGeoIntersection(); Default constructor. TGeoIntersection(const char* expr1, const char* expr2); Constructor. TGeoIntersection(TGeoShape* left, TGeoShape* right, TGeoMatrix* lmat = 0, TGeoMatrix* rmat = 0); Constructor providing pointers to components. ~TGeoIntersection(); Destructor; --- deletion of components handled by TGeoManager class. void ComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); Compute bounding box corresponding to a intersection of two shapes. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Normal computation in POINT. The orientation is chosen so that DIR.dot.NORM>0. Bool_t Contains(Double_t* point) const; Find if a intersection of two shapes contains a given point. Int_t DistanceToPrimitive(Int_t px, Int_t py); Compute minimum distance to shape vertices. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Compute distance from a given point inside to the shape boundary. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Compute distance from a given point outside to the shape. Int_t GetNpoints(); Returns number of vertices for the composite shape described by this intersection. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; Compute safety distance for a union node;. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void Sizeof3D() const; Register 3D size of this shape. EGeoBoolType GetBooleanOperator() const. » Author: Andrei Gheata 30/05/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoBoolNode.h 32690 2010-03-21 08:47:56Z brun $ » Last generated: 2010-12-10 11:10; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoIntersection.html:8936,safe,safe,8936,root/html528/TGeoIntersection.html,https://root.cern,https://root.cern/root/html528/TGeoIntersection.html,3,"['Safe', 'safe']","['Safety', 'safe', 'safety']"
Safety,"(Option_t* option); Paint method. TGeoIntersection(); Default constructor. TGeoIntersection(const char* expr1, const char* expr2); Constructor. TGeoIntersection(TGeoShape* left, TGeoShape* right, TGeoMatrix* lmat = 0, TGeoMatrix* rmat = 0); Constructor providing pointers to components. ~TGeoIntersection(); Destructor; --- deletion of components handled by TGeoManager class. void ComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); Compute bounding box corresponding to a intersection of two shapes. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Normal computation in POINT. The orientation is chosen so that DIR.dot.NORM>0. Bool_t Contains(Double_t* point) const; Find if a intersection of two shapes contains a given point. Int_t DistanceToPrimitive(Int_t px, Int_t py); Compute minimum distance to shape vertices. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Compute distance from a given point inside to the shape boundary. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Compute distance from a given point outside to the shape. Int_t GetNpoints(); Returns number of vertices for the composite shape described by this intersection. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; Compute safety distance for a union node;. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void Sizeof3D() const; Register 3D size of this shape. EGeoBoolType GetBooleanOperator() const. » Author: Andrei Gheata 30/05/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoBoolNode.h 32690 2010-03-21 08:47:56Z brun $ » Last generated: 2011-07-04 15:31; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoIntersection.html:9036,safe,safe,9036,root/html530/TGeoIntersection.html,https://root.cern,https://root.cern/root/html530/TGeoIntersection.html,3,"['Safe', 'safe']","['Safety', 'safe', 'safety']"
Safety,"(TTree *t). Called every time a new TTree is attached.; void TSelector::SlaveBegin(). Create e.g. histograms in this method. This method is called (with or without PROOF) before looping on the entries in the Tree. When using PROOF, this method is called on each worker node.; void TSelector::Begin(). Mostly for backward compatibility; use SlaveBegin() instead. Both methods are called before looping on the entries in the Tree. When using PROOF, Begin() is called on the client only.; bool TSelector::Notify(). This method is called at the first entry of a new file in a chain.; bool TSelector::Process(Long64_t entry). This method is called to process an entry. It is the user's responsibility to read the corresponding entry in memory (may be just a partial read). Once the entry is in memory one can apply a selection and if the entry is selected histograms can be filled. Processing stops when this function returns false. This function combines the next two functions in one, avoiding to have to maintain state in the class to communicate between these two functions. See WARNING below about entry. This method is used by PROOF.; bool TSelector::ProcessCut(Long64_t entry). This method is called before processing entry. It is the user's responsibility to read the corresponding entry in memory (may be just a partial read). The function returns true if the entry must be processed, false otherwise. This method is obsolete, use Process(). See WARNING below about entry.; void TSelector::ProcessFill(Long64_t entry). This method is called for all selected entries. User fills histograms in this function. This method is obsolete, use Process(). See WARNING below about entry.; void TSelector::SlaveTerminate(). This method is called at the end of the loop on all PROOF worker nodes. In local mode this method is called on the client too.; void TSelector::Terminate(). This method is called at the end of the loop on all entries. When using PROOF Terminate() is call on the client only. Typicall",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSelector.html:1495,avoid,avoiding,1495,doc/master/classTSelector.html,https://root.cern,https://root.cern/doc/master/classTSelector.html,1,['avoid'],['avoiding']
Safety,"(aos == TFile::kAOSInProgress && xtms > 0) {; 4151 gSystem->Sleep(1);; 4152 xtms -= 1;; 4153 aos = TFile::GetAsyncOpenStatus(fh);; 4154 }; 4155 if (aos == TFile::kAOSNotAsync || aos == TFile::kAOSSuccess) {; 4156 // Do open the file now; 4157 f = TFile::Open(fh);; 4158 if (gDebug > 0) {; 4159 if (aos == TFile::kAOSSuccess); 4160 ::Info(""TFile::Open"", ""waited %d millisec for asynchronous open"", toms - xtms);; 4161 else; 4162 ::Info(""TFile::Open"", ""timeout option not supported (requires asynchronous""; 4163 "" open support)"");; 4164 }; 4165 } else {; 4166 if (xtms <= 0); 4167 ::Error(""TFile::Open"", ""timeout expired while opening '%s'"", expandedUrl.Data());; 4168 // Cleanup the request; 4169 SafeDelete(fh);; 4170 }; 4171 // Done; 4172 return f;; 4173 } else {; 4174 ::Warning(""TFile::Open"", ""incomplete 'TIMEOUT=' option specification - ignored"");; 4175 opts.ReplaceAll(""TIMEOUT="", """");; 4176 }; 4177 }; 4178 ; 4179 // We will use this from now on; 4180 const char *option = opts;; 4181 ; 4182 // Many URLs? Redirect output and print errors in case of global failure; 4183 TString namelist(expandedUrl);; 4184 Ssiz_t ip = namelist.Index(""|"");; 4185 Bool_t rediroutput = (ip != kNPOS &&; 4186 ip != namelist.Length()-1 && gDebug <= 0) ? kTRUE : kFALSE;; 4187 RedirectHandle_t rh;; 4188 if (rediroutput) {; 4189 TString outf = "".TFileOpen_"";; 4190 FILE *fout = gSystem->TempFileName(outf);; 4191 if (fout) {; 4192 fclose(fout);; 4193 gSystem->RedirectOutput(outf, ""w"", &rh);; 4194 }; 4195 }; 4196 ; 4197 // Try sequentially all names in 'names'; 4198 TString name, n;; 4199 Ssiz_t from = 0;; 4200 while (namelist.Tokenize(n, from, ""|"") && !f) {; 4201 ; 4202 // check if we read through a file cache; 4203 if (!strcasecmp(option, ""CACHEREAD"") ||; 4204 ((!strcasecmp(option,""READ"") || !option[0]) && fgCacheFileForce)) {; 4205 // Try opening the file from the cache; 4206 if ((f = TFile::OpenFromCache(n, option, ftitle, compress, netopt))); 4207 return f;; 4208 }; 4209 ; 4210 IncrementFileCounter(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:152869,TIMEOUT,TIMEOUT,152869,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['TIMEOUT'],['TIMEOUT']
Safety,"(arg*arg * halfBySigmaSq);; + output[i] = RooBatchCompute::fast_exp(arg*arg * halfBySigmaSq);; Unbiased binned fits; When RooFit performs binned fits, it takes the probability density at the bin centre as a proxy for the probability in the bin. This can lead to a bias. To alleviate this, the new class RooBinSamplingPdf has been added to RooFit. Also see arxiv:2012.02746.; More accurate residual and pull distributions; When making residual or pull distributions with RooPlot::residHist or RooPlot::pullHist, the histogram is now compared with the curve’s average values within a given bin by default, ensuring that residual and pull distributions are valid for strongly curved distributions. The old default behaviour was to interpolate the curve at the bin centres, which can still be enabled by setting the useAverage parameter of RooPlot::residHist or RooPlot::pullHist to false.; Improved recovery from invalid parameters; When a function in RooFit is undefined (Poisson with negative mean, PDF with negative values, etc), RooFit can now pass information about the “badness” of the violation to the minimiser. The minimiser can use this to compute a gradient to find its way out of the undefined region. This can drastically improve its ability to recover when unstable fit models are used, for example RooPolynomial.; For details, see the RooFit tutorial rf612_recoverFromInvalidParameters.C and arxiv:2012.02746.; Modernised RooDataHist; RooDataHist was partially modernised to improve const-correctness, to reduce side effects as well as its memory footprint, and to make it ready for RooFit’s faster batch evaluations. Derived classes that directly access protected members might need to be updated. This holds especially for direct accesses to _curWeight, _curWeightErrLo, etc, which have been removed. (It doesn’t make sense to write to these members from const functions when the same information can be retrieved using an index access operator of an array.) All similar accesses in deri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v624/release-notes.html:21675,recover,recovery,21675,doc/v624/release-notes.html,https://root.cern,https://root.cern/doc/v624/release-notes.html,1,['recover'],['recovery']
Safety,"(char* buf, Long64_t pos, Int_t len); Read specified byte range from remote file via dCache daemon.; Returns kTRUE in case of error. Bool_t ReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); Read the nbuf blocks described in arrays pos and len,; where pos[i] is the seek position of block i of length len[i].; Note that for nbuf=1, this call is equivalent to TFile::ReafBuffer.; This function is overloaded by TNetFile, TWebFile, etc.; Returns kTRUE in case of failure. Bool_t WriteBuffer(const char* buf, Int_t len); Write specified byte range to remote file via dCache daemon.; Returns kTRUE in case of error. Bool_t Stage(const char* path, UInt_t secs, const char* location = 0); Stage() returns kTRUE on success and kFALSE on failure. Bool_t CheckFile(const char* path, const char* location = 0); CheckFile() returns kTRUE on success and kFALSE on failure. In; case the file exists but is not cached, CheckFile() returns; kFALSE and errno is set to EAGAIN. void SetOpenTimeout(UInt_t secs); Set file open timeout. void SetOnError(TDCacheFile::OnErrorAction = kOnErrorDefault); Set on error handler. void SetReplyHostName(const char* host_name); Set reply host name. const char * GetDcapVersion(); Return dCache version string. Int_t SysOpen(const char* pathname, Int_t flags, UInt_t mode); Interface to system open. All arguments like in POSIX open. Int_t SysClose(Int_t fd); Interface to system close. All arguments like in POSIX close. Int_t SysRead(Int_t fd, void* buf, Int_t len); Interface to system read. All arguments like in POSIX read. Int_t SysWrite(Int_t fd, const void* buf, Int_t len); Interface to system write. All arguments like in POSIX write. Long64_t SysSeek(Int_t fd, Long64_t offset, Int_t whence); Interface to system seek. All arguments like in POSIX lseek. Int_t SysSync(Int_t fd); Interface to system sync. All arguments like in POSIX fsync.; dCache always keep it's files sync'ed, so there's no need to; sync() them manually. Int_t SysStat(Int_t fd, Long_t* i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TDCacheFile.html:24184,timeout,timeout,24184,root/html528/TDCacheFile.html,https://root.cern,https://root.cern/root/html528/TDCacheFile.html,3,['timeout'],['timeout']
Safety,"(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const double& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const double& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of length 1. bool IsInUse(const double* p) const. Function to check if a vector is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the vector is in use, for example in operations; like V = M * V, where M is a mtrix, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; used by operator<<(). » Last changed: root/smatrix:$Id$ » Last generated: 2015-06-30 14:26; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__SVector_Double32_t_3_.html:6895,avoid,avoid,6895,root/html602/ROOT__Math__SVector_Double32_t_3_.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__SVector_Double32_t_3_.html,10,['avoid'],['avoid']
Safety,"(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const double& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const double& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of length 1. bool IsInUse(const double* p) const. Function to check if a vector is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the vector is in use, for example in operations; like V = M * V, where M is a mtrix, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; used by operator<<(). » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:01; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__SVector_double_2_.html:6826,avoid,avoid,6826,root/html534/ROOT__Math__SVector_double_2_.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__SVector_double_2_.html,6,['avoid'],['avoid']
Safety,"(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const double& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const double& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of length 1. bool IsInUse(const double* p) const. Function to check if a vector is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the vector is in use, for example in operations; like V = M * V, where M is a mtrix, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; used by operator<<(). » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_3_.html:6895,avoid,avoid,6895,root/html604/ROOT__Math__SVector_Double32_t_3_.html,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_3_.html,10,['avoid'],['avoid']
Safety,"(const TIter& aIter) const; TObject*operator()(); TObject*operator*() const; TIter&operator++(); TIter&operator=(const TIter& rhs); Bool_toperator==(const TIter& aIter) const; voidReset(); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). protected:. TIter(). Data Members; private:. TIterator*fIteratorcollection iterator. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TIter(const TIter& iter); Copy a TIter. This involves allocating a new TIterator of the right; sub class and assigning it with the original. TIter & operator=(const TIter& rhs); Assigning an TIter to another. This involves allocatiing a new TIterator; of the right sub class and assigning it with the original. TIter & Begin(); Pointing to the first element of the container. TIter End(); Pointing to the element after the last - to a nullptr value in our case. TObject * operator()(const char *name). TIter(); { }. TIter(const TCollection* col, Bool_t dir = kIterForward); { }. TIter(TIterator* it); { }. virtual ~TIter(); { SafeDelete(fIterator); }. TObject * Next(); { return fIterator ? fIterator->Next() : nullptr; }. const TCollection * GetCollection() const; { return fIterator ? fIterator->GetCollection() : nullptr; }. Option_t * GetOption() const; { return fIterator ? fIterator->GetOption() : """"; }. void Reset(); { if (fIterator) fIterator->Reset(); }. TIter & operator++(); { Next(); return *this; }. Bool_t operator==(const TIter& aIter) const. Bool_t operator!=(const TIter& aIter) const. TObject * operator*() const; { return fIterator ? *(*fIterator): nullptr; }. » Author: Fons Rademakers 13/08/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/cont:$Id$ » Last generated: 2015-03-20 17:44; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TIter.html:2649,Safe,SafeDelete,2649,root/html534/TIter.html,https://root.cern,https://root.cern/root/html534/TIter.html,1,['Safe'],['SafeDelete']
Safety,"(const char *name);  Return kTRUE if 'url' matches the coordinates of this file. ;  ; virtual Bool_t MustFlush () const;  ; void Paint (Option_t *option="""") override;  Paint all objects in the file. ;  ; void Print (Option_t *option="""") const override;  Print all objects in the file. ;  ; virtual Bool_t ReadBuffer (char *buf, Int_t len);  Read a buffer from the file. ;  ; virtual Bool_t ReadBuffer (char *buf, Long64_t pos, Int_t len);  Read a buffer from the file at the offset 'pos' in the file. ;  ; virtual Bool_t ReadBufferAsync (Long64_t offs, Int_t len);  ; virtual Bool_t ReadBuffers (char *buf, Long64_t *pos, Int_t *len, Int_t nbuf);  Read the nbuf blocks described in arrays pos and len. ;  ; virtual void ReadFree ();  Read the FREE linked list. ;  ; virtual TProcessID * ReadProcessID (UShort_t pidf);  The TProcessID with number pidf is read from this file. ;  ; virtual void ReadStreamerInfo ();  Read the list of StreamerInfo from this file. ;  ; virtual Int_t Recover ();  Attempt to recover file if not correctly closed. ;  ; virtual Int_t ReOpen (Option_t *mode);  Reopen a file with a different access mode. ;  ; virtual void ResetErrno () const;  Method resetting the errno. ;  ; virtual void Seek (Long64_t offset, ERelativeTo pos=kBeg);  Seek to a specific position in the file. Pos it either kBeg, kCur or kEnd. ;  ; virtual void SetCacheRead (TFileCacheRead *cache, TObject *tree=nullptr, ECacheAction action=kDisconnect);  Set a pointer to the read cache. ;  ; virtual void SetCacheWrite (TFileCacheWrite *cache);  Set a pointer to the write cache. ;  ; virtual void SetCompressionAlgorithm (Int_t algorithm=ROOT::RCompressionSetting::EAlgorithm::kUseGlobal);  See comments for function SetCompressionSettings. ;  ; virtual void SetCompressionLevel (Int_t level=ROOT::RCompressionSetting::ELevel::kUseMin);  See comments for function SetCompressionSettings. ;  ; virtual void SetCompressionSettings (Int_t settings=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTFile.html:12400,Recover,Recover,12400,doc/v632/classTFile.html,https://root.cern,https://root.cern/doc/v632/classTFile.html,4,"['Recover', 'recover']","['Recover', 'recover']"
Safety,"(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoBBox&operator=(const TGeoBBox&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidSetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetPoints(Double_t* points) const; virtual voidSetPoints(Float_t* points) const; vo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoBBox.html:10043,Safe,SafetyPhi,10043,root/html602/TGeoBBox.html,https://root.cern,https://root.cern/root/html602/TGeoBBox.html,2,['Safe'],['SafetyPhi']
Safety,"(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoCone&operator=(const TGeoCone&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tSafetyS(const Double_t* point, Bool_t in, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Int_t skipz = 0); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; voidSetConeDimensions(Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoCone.html:9068,Safe,SafetyPhi,9068,root/html602/TGeoCone.html,https://root.cern,https://root.cern/root/html602/TGeoCone.html,2,['Safe'],['SafetyPhi']
Safety,"(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoCtub&operator=(const TGeoCtub&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoTubeSeg::SafetyS(const Double_t* point, Bool_t in, Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2, Int_t skipz = 0); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; voidSetCtubDimensions(Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2, Double_t lx, Double_t ly, Double_t lz, Double_t tx, Double_t ty, Double_t tz); virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoCtub.html:9893,Safe,SafetyPhi,9893,root/html602/TGeoCtub.html,https://root.cern,https://root.cern/root/html602/TGeoCtub.html,2,['Safe'],['SafetyPhi']
Safety,"(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoEltu&operator=(const TGeoEltu&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoTube::SafetyS(const Double_t* point, Bool_t in, Double_t rmin, Double_t rmax, Double_t dz, Int_t skipz = 0); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetEltuDimensions(Double_t a, Double_t b, Double_t dz); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtua",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoEltu.html:8911,Safe,SafetyPhi,8911,root/html602/TGeoEltu.html,https://root.cern,https://root.cern/root/html602/TGeoEltu.html,2,['Safe'],['SafetyPhi']
Safety,"(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoGtra&operator=(const TGeoGtra&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); Double_tTGeoArb8::SafetyToFace(const Double_t* point, Int_t iseg, Bool_t in) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoArb8::SetDz(Double_t dz); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); stati",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoGtra.html:10071,Safe,SafetyPhi,10071,root/html602/TGeoGtra.html,https://root.cern,https://root.cern/root/html602/TGeoGtra.html,2,['Safe'],['SafetyPhi']
Safety,"(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoPara&operator=(const TGeoPara&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetPoints(Double_t* points) const; virtual voidSetPoints(Float_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoPara.html:8562,Safe,SafetyPhi,8562,root/html602/TGeoPara.html,https://root.cern,https://root.cern/root/html602/TGeoPara.html,2,['Safe'],['SafetyPhi']
Safety,"(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoTrap&operator=(const TGeoTrap&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); Double_tTGeoArb8::SafetyToFace(const Double_t* point, Int_t iseg, Bool_t in) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoArb8::SetDz(Double_t dz); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); stati",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoTrap.html:9930,Safe,SafetyPhi,9930,root/html602/TGeoTrap.html,https://root.cern,https://root.cern/root/html602/TGeoTrap.html,2,['Safe'],['SafetyPhi']
Safety,"(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoTrd1&operator=(const TGeoTrd1&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetPoints(Double_t* points) const; virtual voidSetPoints(Float_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoTrd1.html:8523,Safe,SafetyPhi,8523,root/html602/TGeoTrd1.html,https://root.cern,https://root.cern/root/html602/TGeoTrd1.html,2,['Safe'],['SafetyPhi']
Safety,"(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoTrd2&operator=(const TGeoTrd2&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetPoints(Double_t* points) const; virtual voidSetPoints(Float_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoTrd2.html:8559,Safe,SafetyPhi,8559,root/html602/TGeoTrd2.html,https://root.cern,https://root.cern/root/html602/TGeoTrd2.html,2,['Safe'],['SafetyPhi']
Safety,"(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoTube&operator=(const TGeoTube&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tSafetyS(const Double_t* point, Bool_t in, Double_t rmin, Double_t rmax, Double_t dz, Int_t skipz = 0); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); stati",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoTube.html:9365,Safe,SafetyPhi,9365,root/html602/TGeoTube.html,https://root.cern,https://root.cern/root/html602/TGeoTube.html,2,['Safe'],['SafetyPhi']
Safety,"(const char* ref); voidTObject::ResetBit(UInt_t f); virtual voidRestorePreviousQuery(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tSavePartialResults(Bool_t queryend = kFALSE, Bool_t force = kFALSE); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetCurrentQuery(TQueryResult* q); virtual voidSetDispatchTimer(Bool_t on = kTRUE); virtual voidSetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetExitStatus(TVirtualProofPlayer::EExitStatus); virtual voidSetInitTime(); virtual voidSetMaxDrawQueries(Int_t max); virtual voidSetMerging(Bool_t on = kTRUE); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetOutputFilePath(const char* fp); virtual voidSetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStopProcess(Bool_t abort, Int_t timeout = -1); virtual voidStoreFeedback(TObject* slave, TList* out); virtual voidStoreOutput(TList* out); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TVirtualProofPlayer(); TVirtualProofPlayer(const TVirtualProofPlayer&); virtual voidUpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidUpdateProgressInfo(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TVirtualProofPlayer.html:10085,abort,abort,10085,root/html604/TVirtualProofPlayer.html,https://root.cern,https://root.cern/root/html604/TVirtualProofPlayer.html,1,['abort'],['abort']
Safety,"(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTProof::ShowCache(Bool_t all = kFALSE); voidTProof::ShowData(); voidTProof::ShowDataSet(const char* dataset = """", const char* opt = ""M""); virtual voidTProof::ShowDataSetCache(const char* dataset = 0); voidTProof::ShowDataSetQuota(Option_t* opt = 0); virtual voidTProof::ShowDataSets(const char* uri = """", const char* optStr = """"); voidTProof::ShowEnabledPackages(Bool_t all = kFALSE); voidTProof::ShowFeedback() const; voidTProof::ShowLog(Int_t qry = -1); voidTProof::ShowLog(const char* queryref); virtual voidShowMembers(TMemberInspector& insp); voidTProof::ShowPackages(Bool_t all = kFALSE, Bool_t redirlog = kFALSE); voidTProof::ShowParameters(const char* wildcard = ""PROOF_*"") const; voidTProof::ShowQueries(Option_t* opt = """"); virtual Int_tTNamed::Sizeof() const; voidTProof::StartupMessage(const char* msg, Bool_t status, Int_t done, Int_t total)SIGNAL ; voidTProof::StopProcess(Bool_t abort, Int_t timeout = -1); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; voidTProof::Touch(); Int_tTProof::UploadDataSet(const char* dataset, TList* files, const char* dest = 0, Int_t opt = kAskUser, TList* skippedFiles = 0); Int_tTProof::UploadDataSet(const char* dataset, const char* files, const char* dest = 0, Int_t opt = kAskUser, TList* skippedFiles = 0); Int_tTProof::UploadDataSetFromFile(const char* dataset, const char* file, const char* dest = 0, Int_t opt = kAskUser, TList* skippedFiles = 0); Int_tTProof::UploadPackage(const char* par, TProof::EUploadPackageOpt opt = kUntar); virtual voidTObject::UseCurrentStyle(); Bool_tTProof::UseDynamicStartup() const; virtual Int_tTProof::VerifyDataSet(const char* dataset, const char* optStr = """"); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtua",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofCondor.html:17318,timeout,timeout,17318,root/html528/TProofCondor.html,https://root.cern,https://root.cern/root/html528/TProofCondor.html,2,['timeout'],['timeout']
Safety,"(default: http://consult.cern.ch/xwho/people?); Root.Html.XWho:; If set to Doc++, allow method documentation in front of method even for methods in the source file (default: """"); Root.Html.DescriptionStyle:; Search path for the source and header files with their default settings:; Unix.*.Root.Html.SourceDir: .:src:include; WinNT.*.Root.Html.SourceDir: .;src;include; URL stem for ROOT documentation pages (default is """").; Root.Html.Root: http://root.cern.ch/root/html; Filesystem output directory for generated web pages (default: htmldoc).; Root.Html.OutputDir: htmldoc/; Address of the package’s home page (default: http://root.cern.ch):; Root.Html.HomePage:; Location of user defined header and footer files, see http://root.cern.ch/root/html/THtml#conf:header (defaults are """", example: ../header.txt, ../footer.txt):; Root.Html.Header:; Root.Html.Footer:; Tag for detecting class description comments (default value is set below).; Root.Html.Description: //____________________; Tag for detecting “Author” comment (default value is set below).; Root.Html.Author: // Author:; Tag for detecting “last updated” comment. THtml uses the current date if this tag is not found in a class source file (default value is set below).; Root.Html.LastUpdate: // @(#); Tag for detecting “Copyright” comment (default value is set below).; Root.Html.Copyright: * Copyright; 28.6.3 GUI Specific Settings; Set the “native” ROOT GUI interface to be used in a ROOT session.; Gui.Backend: native; Gui.Factory: native; GUI default fonts in use:; Gui.DefaultFont: -adobe-helvetica-medium-r-*-*-12-*-*-*-*-*-iso8859-1; Gui.MenuFont: -adobe-helvetica-medium-r-*-*-12-*-*-*-*-*-iso8859-1; Gui.MenuHiFont: -adobe-helvetica-bold-r-*-*-12-*-*-*-*-*-iso8859-1; Gui.DocFixedFont: -adobe-courier-medium-r-*-*-12-*-*-*-*-*-iso8859-1; Gui.DocPropFont: -adobe-helvetica-medium-r-*-*-12-*-*-*-*-*-iso8859-1; Gui.IconFont: -adobe-helvetica-medium-r-*-*-10-*-*-*-*-*-iso8859-1; Gui.StatusFont: -adobe-helvetica-medium-r-*-*-10-*-*-",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1260088,detect,detecting,1260088,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['detect'],['detecting']
Safety,"(delta);; 9639 std::unique_ptr<MutexStateAndRecurseCountDelta> uniqueP{typedDelta};; 9640 gCoreMutex->Apply(std::move(typedDelta->fDelta));; 9641 // Now that we have the lock, update the global; 9642 R__ASSERT(fInitialMutex.fRecurseCount == 0 && ""Inconsistent state of fInitialMutex! Another thread within Interpreter critical section."");; 9643 std::swap(fInitialMutex, typedDelta->fInitialState);; 9644 } else {; 9645 // This case happens when EnableThreadSafety is first called from; 9646 // the interpreter function we just handled.; 9647 // Since thread safety was not enabled at the time we rewound, there was; 9648 // no lock taken and even-though we should be locking the rest of this; 9649 // interpreter handling/modifying code (since there might be threads in; 9650 // flight), we can't because there would not be any lock guard to release the; 9651 // locks; 9652 if (fInitialMutex || fInitialMutex.fRecurseCount !=0); 9653 Error(""ApplyToInterpreterMutex"",; 9654 ""After returning from user code that turned on thread safety support, we notice that fInitialMutex is already used ... ""; 9655 ""so the rest of this function/stack execution might have race condition (with the other thread that thinks it has exclusive access to the interpreter state."");; 9656 }; 9657 }; 9658}; 9659 ; 9660////////////////////////////////////////////////////////////////////////////////; 9661/// Reset the interpreter lock to the state it had before interpreter-related; 9662/// calls happened.; 9663 ; 9664void *TCling::RewindInterpreterMutex(); 9665{; 9666 if (fInitialMutex) {; 9667 // Need to start a new recurse count.; 9668 std::unique_ptr<MutexStateAndRecurseCountDelta> uniqueP(new MutexStateAndRecurseCountDelta());; 9669 std::swap(uniqueP->fInitialState, fInitialMutex);; 9670 uniqueP->fDelta = gCoreMutex->Rewind(*uniqueP->fInitialState.fState);; 9671 return uniqueP.release();; 9672 }; 9673 R__ASSERT(fInitialMutex.fRecurseCount == 0);; 9674 return nullptr;; 9675}; ClingRAII.h; R__EXTERN#define R_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:373393,safe,safety,373393,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['safe'],['safety']
Safety,"(dset,testArg);  ; const RooAbsArg &testArg const { return observableOverlaps(depList, testArg);  ;  Protected Types inherited from RooAbsCachedReal; using CacheElem = FuncCacheElem;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Static Protected Member Functions inherited from RooAbsReal; static void globalSelectComp (bool flag);  Global switch controlling the activation of the selectComp() functionality. ;  ;  Static Protected Member Functions inherited from RooAbsArg; static void ioStreamerPass2Finalize ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooCachedReal.h>. Inheritance diagram for RooCachedReal:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooCachedReal() [1/4]. RooCachedReal::RooCachedReal ; (; ). inline . Definition at line 22 of file RooCachedReal.h. ◆ RooCachedReal() [2/4]. RooCachedReal::RooCachedReal ; (; const char * ; name, . const char * ; title, . RooAbsReal & ; _func, . const RooArgSet & ; cacheObs . ). Constructor taking name, title and function to be cached and fixed choice of variable to cache. ; To control granularity of the binning of the cache histogram set the desired properties in the binning named ""cache"" in the observables of the function. If the fixed set of cache observables does not match the observables defined in the use context of the p.d.f the cache is still filled completely. Ee.g. when it",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCachedReal.html:62960,Avoid,Avoids,62960,doc/master/classRooCachedReal.html,https://root.cern,https://root.cern/doc/master/classRooCachedReal.html,1,['Avoid'],['Avoids']
Safety,"(dset,testArg);  ; const RooAbsArg &testArg const { return observableOverlaps(depList, testArg);  ;  Protected Types inherited from RooAbsCachedReal; using CacheElem = FuncCacheElem;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Static Protected Member Functions inherited from RooAbsReal; static void globalSelectComp (bool flag);  Global switch controlling the activation of the selectComp() functionality. ;  ;  Static Protected Member Functions inherited from RooAbsArg; static void ioStreamerPass2Finalize ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooNumRunningInt.h>. Inheritance diagram for RooNumRunningInt:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooNumRunningInt() [1/2]. RooNumRunningInt::RooNumRunningInt ; (; const char * ; name, . const char * ; title, . RooAbsReal & ; _func, . RooRealVar & ; _x, . const char * ; bname = ""cache"" . ). Construct running integral of function '_func' over x_print from the lower bound on _x to the present value of _x using a numeric sampling technique. ; The sampling frequency is controlled by the binning named 'bname' and a default second order interpolation is applied to smooth the histogram-based c.d.f. ; Definition at line 51 of file RooNumRunningInt.cxx. ◆ RooNumRunningInt() [2/2]. RooNumRunningInt::RooNumRunningInt ; (; const RooNumRunningInt & ; other, . const char * ; name = null",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooNumRunningInt.html:62834,Avoid,Avoids,62834,doc/master/classRooNumRunningInt.html,https://root.cern,https://root.cern/doc/master/classRooNumRunningInt.html,1,['Avoid'],['Avoids']
Safety,"(kShowEventStatus)) fCanvasImp->ShowStatusBar(kTRUE);; 667 // ... and toolbar + editor; 668 if (TestBit(kShowToolBar)) fCanvasImp->ShowToolBar(kTRUE);; 669 if (TestBit(kShowEditor)) fCanvasImp->ShowEditor(kTRUE);; 670 if (TestBit(kShowToolTips)) fCanvasImp->ShowToolTips(kTRUE);; 671 }; 672}; 673 ; 674////////////////////////////////////////////////////////////////////////////////; 675/// Canvas destructor; 676 ; 677TCanvas::~TCanvas(); 678{; 679 Destructor();; 680}; 681 ; 682////////////////////////////////////////////////////////////////////////////////; 683/// Browse.; 684 ; 685void TCanvas::Browse(TBrowser *b); 686{; 687 Draw();; 688 cd();; 689 if (fgIsFolder) fPrimitives->Browse(b);; 690}; 691 ; 692////////////////////////////////////////////////////////////////////////////////; 693/// Actual canvas destructor.; 694 ; 695void TCanvas::Destructor(); 696{; 697 if (gThreadXAR) {; 698 void *arr[2];; 699 arr[1] = this;; 700 if ((*gThreadXAR)(""CDEL"", 2, arr, nullptr)) return;; 701 }; 702 ; 703 if (ROOT::Detail::HasBeenDeleted(this)) return;; 704 ; 705 SafeDelete(fContextMenu);; 706 if (!gPad) return;; 707 ; 708 Close();; 709 ; 710 //If not yet (batch mode?).; 711 SafeDelete(fPainter);; 712}; 713 ; 714////////////////////////////////////////////////////////////////////////////////; 715/// Set current canvas & pad. Returns the new current pad,; 716/// or 0 in case of failure.; 717/// See TPad::cd() for an explanation of the parameter.; 718 ; 719TVirtualPad *TCanvas::cd(Int_t subpadnumber); 720{; 721 if (fCanvasID == -1) return nullptr;; 722 ; 723 TPad::cd(subpadnumber);; 724 ; 725 // in case doublebuffer is off, draw directly onto display window; 726 if (!IsBatch() && !IsWeb() && !fDoubleBuffer); 727 gVirtualX->SelectWindow(fCanvasID);//Ok, does not matter for glpad.; 728 ; 729 return gPad;; 730}; 731 ; 732////////////////////////////////////////////////////////////////////////////////; 733/// Remove all primitives from the canvas.; 734/// If option ""D"" is specified, di",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCanvas_8cxx_source.html:23029,Safe,SafeDelete,23029,doc/master/TCanvas_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCanvas_8cxx_source.html,1,['Safe'],['SafeDelete']
Safety,"(nout == 0 || nout >= fObjlen) { //this happens when the buffer cannot be compressed; 265 delete[] fBuffer;; 266 bufcur = nullptr;; 267 fBuffer = fBufferRef->Buffer();; 268 Create(fObjlen);; 269 fBufferRef->SetBufferOffset(0);; 270 Streamer(*fBufferRef); //write key itself again; 271 return;; 272 }; 273 bufcur += nout;; 274 noutot += nout;; 275 objbuf += kMAXZIPBUF;; 276 nzip += kMAXZIPBUF;; 277 }; 278 Create(noutot);; 279 fBufferRef->SetBufferOffset(0);; 280 Streamer(*fBufferRef); //write key itself again; 281 memcpy(fBuffer,fBufferRef->Buffer(),fKeylen);; 282 delete fBufferRef; fBufferRef = 0;; 283 } else {; 284 fBuffer = fBufferRef->Buffer();; 285 Create(fObjlen);; 286 fBufferRef->SetBufferOffset(0);; 287 Streamer(*fBufferRef); //write key itself again; 288 }; 289}; 290 ; 291////////////////////////////////////////////////////////////////////////////////; 292/// Create a TKey object for any object obj of class cl d and fill; 293/// output buffer.; 294///; 295/// WARNING: in name avoid special characters like '^','$','.' that are used; 296/// by the regular expression parser (see TRegexp).; 297 ; 298TKey::TKey(const void *obj, const TClass *cl, const char *name, Int_t bufsize, TDirectory* motherDir); 299 : TNamed(name, ""object title""); 300{; 301 R__ASSERT(obj && cl);; 302 ; 303 if (!cl->HasDefaultConstructor()) {; 304 Warning(""TKey"", ""since %s has no public constructor\n""; 305 ""\twhich can be called without argument, objects of this class\n""; 306 ""\tcan not be read with the current library. You will need to\n""; 307 ""\tadd a default constructor before attempting to read it."",; 308 cl->GetName());; 309 }; 310 ; 311 TClass *clActual = cl->GetActualClass(obj);; 312 const void* actualStart;; 313 if (clActual) {; 314 const char *temp = (const char*) obj;; 315 // clActual->GetStreamerInfo();; 316 Int_t offset = (cl != clActual) ?; 317 clActual->GetBaseClassOffset(cl) : 0;; 318 temp -= offset;; 319 actualStart = temp;; 320 } else {; 321 // We could not determine the real ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TKey_8cxx_source.html:10679,avoid,avoid,10679,doc/master/TKey_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TKey_8cxx_source.html,1,['avoid'],['avoid']
Safety,"(nullptr); return 1; }; 82 Int_t CleanUp() override { WriteUnLock(nullptr); return 1; }; 83 ; 84 virtual std::unique_ptr<State> GetStateBefore() = 0;; 85 virtual std::unique_ptr<StateDelta> Rewind(const State& earlierState) = 0;; 86 virtual void Apply(std::unique_ptr<StateDelta> &&delta) = 0;; 87 ; 88 TVirtualRWMutex *Factory(Bool_t /*recursive*/ = kFALSE) override = 0;; 89 ; 90 ClassDefOverride(TVirtualRWMutex, 0) // Virtual mutex lock class; 91};; 92 ; 93//////////////////////////////////////////////////////////////////////////; 94// //; 95// TReadLockGuard //; 96// //; 97// This class provides RW mutex resource management in a guaranteed and //; 98// exception safe way. Use like this: //; 99// { //; 100// TReadLockGuard guard(mutex); //; 101// ... // read something //; 102// } //; 103// where mutex is a pointer to a TMutex object. //; 104// When guard goes out of scope the mutex is unlocked in the TLockGuard //; 105// destructor. The exception mechanism takes care of calling the dtors //; 106// of local objects so it is exception safe. //; 107// In contrast to std::lock_guard, TLockGuard constructor expects a //; 108// pointer, not the mutex object itself. //; 109// //; 110//////////////////////////////////////////////////////////////////////////; 111 ; 112class TReadLockGuard {; 113 ; 114private:; 115 TVirtualRWMutex *const fMutex;; 116 TVirtualRWMutex::Hint_t *fHint;; 117 ; 118 TReadLockGuard(const TReadLockGuard&) = delete;; 119 TReadLockGuard& operator=(const TReadLockGuard&) = delete;; 120 ; 121public:; 122 TReadLockGuard(TVirtualRWMutex *mutex) : fMutex(mutex), fHint(nullptr) {; 123 if (fMutex) fHint = fMutex->ReadLock();; 124 }; 125 ; 126 ~TReadLockGuard() { if (fMutex) fMutex->ReadUnLock(fHint); }; 127 ; 128 ClassDefNV(TReadLockGuard,0) // Exception safe read locking/unlocking of mutex; 129};; 130 ; 131class TWriteLockGuard {; 132 ; 133private:; 134 TVirtualRWMutex *const fMutex;; 135 TVirtualRWMutex::Hint_t *fHint;; 136 ; 137 TWriteLockGuard(const TWrite",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TVirtualRWMutex_8h_source.html:3996,safe,safe,3996,doc/master/TVirtualRWMutex_8h_source.html,https://root.cern,https://root.cern/doc/master/TVirtualRWMutex_8h_source.html,2,['safe'],['safe']
Safety,"(quotient);; 2186 std::reverse(buf.begin(), buf.end());; 2187 return (TString(buf.data()));; 2188}; 2189 ; 2190////////////////////////////////////////////////////////////////////////////////; 2191/// Converts string from base base_in to base base_out. Supported bases; 2192/// are 2-36. At most 64 bit data can be converted.; 2193 ; 2194TString TString::BaseConvert(const TString& s_in, Int_t base_in, Int_t base_out); 2195{; 2196 TString s_out = ""!"" ; // return value in case of issue; 2197 // checking base range; 2198 if (base_in < 2 || base_in > 36 || base_out < 2 || base_out > 36) {; 2199 Error(""TString::BaseConvert"", ""only bases 2-36 are supported (base_in=%d, base_out=%d)."", base_in, base_out);; 2200 return (s_out);; 2201 }; 2202 // cleaning s_in; 2203 TString s_in_ = s_in;; 2204 Bool_t isSigned = kFALSE;; 2205 if (s_in_[0] == '-') {; 2206 isSigned = kTRUE;; 2207 s_in_.Remove(0, 1);; 2208 }; 2209 if (!isSigned && s_in_[0] == '+') s_in_.Remove(0, 1); // !isSigned to avoid strings beginning with ""-+""; 2210 if (base_in == 16 && s_in_.BeginsWith(""0x"")) s_in_.Remove(0, 2); // removing hex prefix if any; 2211 s_in_ = TString(s_in_.Strip(TString::kLeading, '0')); // removing leading zeros (necessary for length comparison below); 2212 if (!s_in_.Length()) s_in_ += '0';; 2213 // checking s_in_ is expressed in the mentioned base; 2214 if (!s_in_.IsInBaseN(base_in)) {; 2215 Error(""TString::BaseConvert"", ""s_in=\""%s\"" is not in base %d"", s_in.Data(), base_in);; 2216 return (s_out);; 2217 }; 2218 // checking s_in <= 64 bits; 2219 TString s_max = TString::ULLtoa(18446744073709551615ULL, base_in);; 2220 if (s_in_.Length() > s_max.Length()) {; 2221 // string comparison (s_in_>s_max) does not take care of length; 2222 Error(""TString::BaseConvert"", ""s_in=\""%s\"" > %s = 2^64-1 in base %d."", s_in.Data(), s_max.Data(), base_in);; 2223 return (s_out);; 2224 } else if (s_in_.Length() == s_max.Length()) {; 2225 // if ( s_in_.Length() < s_max.Length() ) everything's fine; 2226 s_in_.ToLower(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TString_8cxx_source.html:70387,avoid,avoid,70387,doc/master/TString_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html,1,['avoid'],['avoid']
Safety,"(same physics properties). In other words, the limitation in proceeding this way is that D,E, and F must point to the same medium. If this was not the case, we would have to define different virtual volumes for each placement: C, C' and C"", having the same shape but different media matching the corresponding containers. This might not happen so often, but when it does, it forces the creation of several extra virtual volumes. Other limitation comes from the fact that any container is directly used by navigation algorithms to optimize tracking. These must geometrically contain their belongings (positioned volumes) so that these do not extrude its shape boundaries. Not respecting this rule generally leads to unpredictable results. Therefore A and B together must fit into C that has to fit also into D, E, and F. This is not always straightforward to accomplish, especially when instead of A and B we have many more volumes.; In order to avoid these problems, one can use for the difficult cases the class TGeoVolumeAssembly, representing an assembly of volumes. This behaves like a normal container volume supporting other volumes positioned inside, but it has neither shape nor medium. It cannot be used directly as a piece of the geometry, but just as a temporary structure helping temporary assembling and positioning volumes.; If we define now C as an assembly containing A and B, positioning the assembly into D,E and F will actually position only A and Bdirectly into these volumes, taking into account their combined transformations A/B to C and C to D/E/F. This looks much nicer, is it? In fact, it is and it is not. Of course, we managed to get rid of the ""unnecessary"" volume C in our geometry, but we end-up with a more flat structure for D,E and F (more daughters inside). This can get much worse when extensively used, as in the case: assemblies of assemblies.; For deciding what to choose between using virtual containers or assemblies for a specific case, one can use for both ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:33030,avoid,avoid,33030,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['avoid'],['avoid']
Safety,"(std::declval<T>()), true). constexpr . Definition at line 66 of file RRangeCast.hxx. ◆ HasConsistentHashMember() [1/2]. Bool_t ROOT::Internal::HasConsistentHashMember ; (; const char * ; cname). Return true is the Hash/RecursiveRemove setup is consistent, i.e. ; when all classes in the class hierarchy that overload TObject::Hash do call ROOT::CallRecursiveRemoveIfNeeded in their destructor. i.e. it is safe to call the Hash virtual function during the RecursiveRemove operation. This routines is used for a small subset of the class for which we need the answer before gROOT is properly initialized. ; Definition at line 7345 of file TClass.cxx. ◆ HasConsistentHashMember() [2/2]. Bool_t ROOT::Internal::HasConsistentHashMember ; (; TClass & ; clRef). Return true is the Hash/RecursiveRemove setup is consistent, i.e. ; when all classes in the class hierarchy that overload TObject::Hash do call ROOT::CallRecursiveRemoveIfNeeded in their destructor. i.e. it is safe to call the Hash virtual function during the RecursiveRemove operation. ; Definition at line 7371 of file TClass.cxx. ◆ IsImplicitMTEnabledImpl(). static Bool_t & ROOT::Internal::IsImplicitMTEnabledImpl ; (; ). static . Keeps track of the status of ImplicitMT w/o resorting to the load of libImt. ; Definition at line 463 of file TROOT.cxx. ◆ IsParBranchProcessingEnabled(). Bool_t ROOT::Internal::IsParBranchProcessingEnabled ; (; ). Returns true if parallel branch processing is enabled. ; Definition at line 447 of file TROOT.cxx. ◆ LogicalCPUBandwidthControl(). int ROOT::Internal::LogicalCPUBandwidthControl ; (; ). Returns the available number of logical cores. . Checks if there is CFS bandwidth control in place (linux, via cgroups, assuming standard paths); Otherwise, returns the number of logical cores provided by std::thread::hardware_concurrency() . Definition at line 50 of file RTaskArena.cxx. ◆ MinimalErrorHandler(). void ROOT::Internal::MinimalErrorHandler ; (; Int_t ; level, . Bool_t ; abort_bool, . const cha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/namespaceROOT_1_1Internal.html:36550,safe,safe,36550,doc/v632/namespaceROOT_1_1Internal.html,https://root.cern,https://root.cern/doc/v632/namespaceROOT_1_1Internal.html,1,['safe'],['safe']
Safety,"(std::declval<T>()), true). constexpr . Definition at line 66 of file RRangeCast.hxx. ◆ HasConsistentHashMember() [1/2]. Bool_t ROOT::Internal::HasConsistentHashMember ; (; const char * ; cname). Return true is the Hash/RecursiveRemove setup is consistent, i.e. ; when all classes in the class hierarchy that overload TObject::Hash do call ROOT::CallRecursiveRemoveIfNeeded in their destructor. i.e. it is safe to call the Hash virtual function during the RecursiveRemove operation. This routines is used for a small subset of the class for which we need the answer before gROOT is properly initialized. ; Definition at line 7412 of file TClass.cxx. ◆ HasConsistentHashMember() [2/2]. Bool_t ROOT::Internal::HasConsistentHashMember ; (; TClass & ; clRef). Return true is the Hash/RecursiveRemove setup is consistent, i.e. ; when all classes in the class hierarchy that overload TObject::Hash do call ROOT::CallRecursiveRemoveIfNeeded in their destructor. i.e. it is safe to call the Hash virtual function during the RecursiveRemove operation. ; Definition at line 7438 of file TClass.cxx. ◆ IsImplicitMTEnabledImpl(). static Bool_t & ROOT::Internal::IsImplicitMTEnabledImpl ; (; ). static . Keeps track of the status of ImplicitMT w/o resorting to the load of libImt. ; Definition at line 463 of file TROOT.cxx. ◆ IsParBranchProcessingEnabled(). Bool_t ROOT::Internal::IsParBranchProcessingEnabled ; (; ). Returns true if parallel branch processing is enabled. ; Definition at line 447 of file TROOT.cxx. ◆ LogicalCPUBandwidthControl(). int ROOT::Internal::LogicalCPUBandwidthControl ; (; ). Returns the available number of logical cores. . Checks if there is CFS bandwidth control in place (linux, via cgroups, assuming standard paths); Otherwise, returns the number of logical cores provided by std::thread::hardware_concurrency() . Definition at line 50 of file RTaskArena.cxx. ◆ MinimalErrorHandler(). void ROOT::Internal::MinimalErrorHandler ; (; Int_t ; level, . Bool_t ; abort_bool, . const cha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Internal.html:37131,safe,safe,37131,doc/master/namespaceROOT_1_1Internal.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Internal.html,1,['safe'],['safe']
Safety,"(the parameter numbering; follows that of the input template vector). TH1* GetPlot(); Return the ""template prediction"" corresponding to the fit result (this is not; the same as the weighted sum of template distributions, as template statistical; uncertainties are taken into account).; Note that the name of this histogram will simply be the same as that of the; ""data"" histogram, prefixed with the string ""Fraction fit to hist: "".; Note also that the histogram is managed by the TFractionFitter class, so the returned pointer will be invalid if; the class is deleted. void GetRanges(Int_t& minX, Int_t& maxX, Int_t& minY, Int_t& maxY, Int_t& minZ, Int_t& maxZ) const; Used internally to obtain the bin ranges according to the dimensionality of; the histogram and the limits set by hand. void ComputeFCN(Double_t& f, const Double_t* par, Int_t flag); Used internally to compute the likelihood value. void FindPrediction(int bin, double& t_i, int& k_0, double& A_ki) const; Function used internally to obtain the template prediction in the individual bins; 'bin' <=> 'i' (paper); 'par' <=> 'j' (paper). Double_t GetChisquare() const; Return the likelihood ratio Chi-squared (chi2) for the fit.; The value is computed when the fit is executed successfully.; Chi2 calculation is based on the ""likelihood ratio"" lambda,; lambda = L(y;n) / L(m;n),; where L(y;n) is the likelihood of the fit result <y> describing the data <n>; and L(m;n) is the likelihood of an unknown ""true"" underlying distribution; <m> describing the data <n>. Since <m> is unknown, the data distribution is; used instead,; lambda = L(y;n) / L(n;n).; Note that this ratio is 1 if the fit is perfect. The chi2 value is then; computed according to; chi2 = -2*ln(lambda).; This parameter can be shown to follow a Chi-square distribution. See for; example S. Baker and R. Cousins, ""Clarification of the use of chi-square; and likelihood functions in fits to histograms"", Nucl. Instr. Meth. A221,; pp. 437-442 (1984). Int_t GetNDF() const; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TFractionFitter.html:18855,predict,prediction,18855,root/html602/TFractionFitter.html,https://root.cern,https://root.cern/root/html602/TFractionFitter.html,2,['predict'],['prediction']
Safety,") + '"" );', 'A Simple Fitting Example' ); bar.AddButton( 'multifit', r'TPython::Exec( ""' + to_run.format('multifit.py') + '"" );', 'Fitting in Subranges of Histograms' ); bar.AddButton( 'h1draw', r'TPython::Exec( ""' + to_run.format('h1ReadAndDraw.py') + '"" );', 'Drawing Options for 1D Histograms' ); bar.AddButton( 'graph', r'TPython::Exec( ""' + to_run.format('graph.py') + '"" );', 'Example of a Simple Graph' ); bar.AddButton( 'gerrors', r'TPython::Exec( ""' + to_run.format('gerrors.py') + '"" );', 'Example of a Graph with Error Bars' ); bar.AddButton( 'tornado', r'TPython::Exec( ""' + to_run.format('tornado.py') + '"" );', 'Examples of 3-D PolyMarkers' ); bar.AddButton( 'shapes', r'TPython::Exec( ""' + to_run.format('shapes.py') + '"" );', 'The Geometry Shapes' ); bar.AddButton( 'geometry', r'TPython::Exec( ""' + to_run.format('geometry.py') + '"" );', 'Creation of the NA49 Geometry File' ); bar.AddButton( 'na49view', r'TPython::Exec( ""' + to_run.format('na49view.py') + '"" );', 'Two Views of the NA49 Detector Geometry' ); bar.AddButton( 'file', r'TPython::Exec( ""' + to_run.format('../legacy/pyroot/file.py') + '"" );', 'The ROOT File Format' ); bar.AddButton( 'fildir', r'TPython::Exec( ""' + to_run.format('../legacy/pyroot/fildir.py') + '"" );', 'The ROOT File, Directories and Keys' ); bar.AddButton( 'tree', r'TPython::Exec( ""' + to_run.format('../legacy/pyroot/tree.py') + '"" );', 'The Tree Data Structure' ); bar.AddButton( 'ntuple1', r'TPython::Exec( ""' + to_run.format('ntuple1.py') + '"" );', 'Ntuples and Selections' ); bar.AddButton( 'rootmarks', r'TPython::Exec( ""' + to_run.format('../legacy/pyroot/rootmarks.py') +'"" );', 'Prints an Estimated ROOTMARKS for Your Machine' ); bar.AddSeparator() # not implemented; bar.AddButton( 'make ntuple', r'TPython::Exec( ""' + to_run.format('mrt.py') + '"" );', 'Convert a text file to an ntuple' ); ; bar.Show(); ; ROOT.gROOT.SaveContext(); ; ; ## wait for input to keep the GUI (which lives on a ROOT event dispatcher) alive; if __name__ == '__m",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/demo_8py.html:3227,Detect,Detector,3227,doc/master/demo_8py.html,https://root.cern,https://root.cern/doc/master/demo_8py.html,1,['Detect'],['Detector']
Safety,") / 1000.0;; 6152 }; 6153 if (timeout <= 0.0) {; 6154 timeout = strtod(config_options[REQUEST_TIMEOUT].default_value, NULL); 6155 / 1000.0;; 6156 }; 6157 ; 6158 while ((len > 0) && STOP_FLAG_IS_ZERO(&ctx->stop_flag)) {; 6159 n = push_inner(ctx, fp, sock, ssl, buf + nwritten, len, timeout);; 6160 if (n < 0) {; 6161 if (nwritten == 0) {; 6162 nwritten = -1; /* Propagate the error */; 6163 }; 6164 break;; 6165 } else if (n == 0) {; 6166 break; /* No more data to write */; 6167 } else {; 6168 nwritten += n;; 6169 len -= n;; 6170 }; 6171 }; 6172 ; 6173 return nwritten;; 6174}; 6175 ; 6176 ; 6177/* Read from IO channel - opened file descriptor, socket, or SSL descriptor.; 6178 * Return value:; 6179 * >=0 .. number of bytes successfully read; 6180 * -1 .. timeout; 6181 * -2 .. error; 6182 */; 6183static int; 6184pull_inner(FILE *fp,; 6185 struct mg_connection *conn,; 6186 char *buf,; 6187 int len,; 6188 double timeout); 6189{; 6190 int nread, err = 0;; 6191 ; 6192#if defined(_WIN32); 6193 typedef int len_t;; 6194#else; 6195 typedef size_t len_t;; 6196#endif; 6197 ; 6198 /* We need an additional wait loop around this, because in some cases; 6199 * with TLSwe may get data from the socket but not from SSL_read.; 6200 * In this case we need to repeat at least once.; 6201 */; 6202 ; 6203 if (fp != NULL) {; 6204 /* Use read() instead of fread(), because if we're reading from the; 6205 * CGI pipe, fread() may block until IO buffer is filled up. We; 6206 * cannot afford to block and must pass all read bytes immediately; 6207 * to the client. */; 6208 nread = (int)read(fileno(fp), buf, (size_t)len);; 6209 ; 6210 err = (nread < 0) ? ERRNO : 0;; 6211 if ((nread == 0) && (len > 0)) {; 6212 /* Should get data, but got EOL */; 6213 return -2;; 6214 }; 6215 ; 6216#if defined(USE_MBEDTLS); 6217 } else if (conn->ssl != NULL) {; 6218 struct mg_pollfd pfd[1];; 6219 int to_read;; 6220 int pollres;; 6221 ; 6222 to_read = mbedtls_ssl_get_bytes_avail(conn->ssl);; 6223 ; 6224 if (to_read > 0) {; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:180409,timeout,timeout,180409,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety,") / 1000.0;; 6153 }; 6154 if (timeout <= 0.0) {; 6155 timeout = strtod(config_options[REQUEST_TIMEOUT].default_value, NULL); 6156 / 1000.0;; 6157 }; 6158 ; 6159 while ((len > 0) && STOP_FLAG_IS_ZERO(&ctx->stop_flag)) {; 6160 n = push_inner(ctx, fp, sock, ssl, buf + nwritten, len, timeout);; 6161 if (n < 0) {; 6162 if (nwritten == 0) {; 6163 nwritten = -1; /* Propagate the error */; 6164 }; 6165 break;; 6166 } else if (n == 0) {; 6167 break; /* No more data to write */; 6168 } else {; 6169 nwritten += n;; 6170 len -= n;; 6171 }; 6172 }; 6173 ; 6174 return nwritten;; 6175}; 6176 ; 6177 ; 6178/* Read from IO channel - opened file descriptor, socket, or SSL descriptor.; 6179 * Return value:; 6180 * >=0 .. number of bytes successfully read; 6181 * -1 .. timeout; 6182 * -2 .. error; 6183 */; 6184static int; 6185pull_inner(FILE *fp,; 6186 struct mg_connection *conn,; 6187 char *buf,; 6188 int len,; 6189 double timeout); 6190{; 6191 int nread, err = 0;; 6192 ; 6193#if defined(_WIN32); 6194 typedef int len_t;; 6195#else; 6196 typedef size_t len_t;; 6197#endif; 6198 ; 6199 /* We need an additional wait loop around this, because in some cases; 6200 * with TLSwe may get data from the socket but not from SSL_read.; 6201 * In this case we need to repeat at least once.; 6202 */; 6203 ; 6204 if (fp != NULL) {; 6205 /* Use read() instead of fread(), because if we're reading from the; 6206 * CGI pipe, fread() may block until IO buffer is filled up. We; 6207 * cannot afford to block and must pass all read bytes immediately; 6208 * to the client. */; 6209 nread = (int)read(fileno(fp), buf, (size_t)len);; 6210 ; 6211 err = (nread < 0) ? ERRNO : 0;; 6212 if ((nread == 0) && (len > 0)) {; 6213 /* Should get data, but got EOL */; 6214 return -2;; 6215 }; 6216 ; 6217#if defined(USE_MBEDTLS); 6218 } else if (conn->ssl != NULL) {; 6219 struct mg_pollfd pfd[1];; 6220 int to_read;; 6221 int pollres;; 6222 ; 6223 to_read = mbedtls_ssl_get_bytes_avail(conn->ssl);; 6224 ; 6225 if (to_read > 0) {; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:180441,timeout,timeout,180441,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety,") = inputValues[i];; 1306 }; 1307 ; 1308 fNet.Prediction(YHat, X, fOutputFunction);; 1309 return YHat(0,0);; 1310}; 1311 ; 1312////////////////////////////////////////////////////////////////////////////////; 1313 ; 1314const std::vector<Float_t> & TMVA::MethodDNN::GetRegressionValues(); 1315{; 1316 size_t nVariables = GetEvent()->GetNVariables();; 1317 Matrix_t X(1, nVariables);; 1318 ; 1319 const Event *ev = GetEvent();; 1320 const std::vector<Float_t>& inputValues = ev->GetValues();; 1321 for (size_t i = 0; i < nVariables; i++) {; 1322 X(0,i) = inputValues[i];; 1323 }; 1324 ; 1325 size_t nTargets = std::max(1u, ev->GetNTargets());; 1326 Matrix_t YHat(1, nTargets);; 1327 std::vector<Float_t> output(nTargets);; 1328 auto net = fNet.CreateClone(1);; 1329 net.Prediction(YHat, X, fOutputFunction);; 1330 ; 1331 for (size_t i = 0; i < nTargets; i++); 1332 output[i] = YHat(0, i);; 1333 ; 1334 if (fRegressionReturnVal == NULL) {; 1335 fRegressionReturnVal = new std::vector<Float_t>();; 1336 }; 1337 fRegressionReturnVal->clear();; 1338 ; 1339 Event * evT = new Event(*ev);; 1340 for (size_t i = 0; i < nTargets; ++i) {; 1341 evT->SetTarget(i, output[i]);; 1342 }; 1343 ; 1344 const Event* evT2 = GetTransformationHandler().InverseTransform(evT);; 1345 for (size_t i = 0; i < nTargets; ++i) {; 1346 fRegressionReturnVal->push_back(evT2->GetTarget(i));; 1347 }; 1348 delete evT;; 1349 return *fRegressionReturnVal;; 1350}; 1351 ; 1352const std::vector<Float_t> & TMVA::MethodDNN::GetMulticlassValues(); 1353{; 1354 size_t nVariables = GetEvent()->GetNVariables();; 1355 Matrix_t X(1, nVariables);; 1356 Matrix_t YHat(1, DataInfo().GetNClasses());; 1357 if (fMulticlassReturnVal == NULL) {; 1358 fMulticlassReturnVal = new std::vector<Float_t>(DataInfo().GetNClasses());; 1359 }; 1360 ; 1361 const std::vector<Float_t>& inputValues = GetEvent()->GetValues();; 1362 for (size_t i = 0; i < nVariables; i++) {; 1363 X(0,i) = inputValues[i];; 1364 }; 1365 ; 1366 fNet.Prediction(YHat, X, fOutputFunc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDNN_8cxx_source.html:47881,Predict,Prediction,47881,doc/master/MethodDNN_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDNN_8cxx_source.html,1,['Predict'],['Prediction']
Safety,") = split \""::\"",$_; $totalsize += $filesize;if ($totalsize > $cachesize) {if ( ( -e \""${filename}.ROOT.cachefile\"" ) || ( -e \""${filename}\"" ) ) {unlink \""$filename.ROOT.cachefile\"";unlink \""$filename\"";}}}close FIND;' "", fgCacheFileDir.Data(),shrinksize);; 4707#else; 4708 cmd.Form(""perl -e 'my $cachepath = \""%s\""; my $cachesize = %lld;my $findcommand=\""find $cachepath -type f -exec stat -c \\\""\\%%x::\\%%n::\\%%s\\\"" \\{\\} \\\\\\;\"";my $totalsize=0;open FIND, \""$findcommand | sort -k 1 |\"";while (<FIND>) { my ($accesstime, $filename, $filesize) = split \""::\"",$_; $totalsize += $filesize;if ($totalsize > $cachesize) {if ( ( -e \""${filename}.ROOT.cachefile\"" ) || ( -e \""${filename}\"" ) ) {unlink \""$filename.ROOT.cachefile\"";unlink \""$filename\"";}}}close FIND;' "", fgCacheFileDir.Data(),shrinksize);; 4709#endif; 4710 ; 4711 tagfile->WriteBuffer(cmd, 4096);; 4712 delete tagfile;; 4713 ; 4714 if ((gSystem->Exec(cmd)) != 0) {; 4715 ::Error(""TFile::ShrinkCacheFileDir"", ""error executing clean-up script"");; 4716 return kFALSE;; 4717 }; 4718 ; 4719 return kTRUE;; 4720}; 4721 ; 4722////////////////////////////////////////////////////////////////////////////////; 4723/// Sets open timeout time (in ms). Returns previous timeout value.; 4724 ; 4725UInt_t TFile::SetOpenTimeout(UInt_t timeout); 4726{; 4727 UInt_t to = fgOpenTimeout;; 4728 fgOpenTimeout = timeout;; 4729 return to;; 4730}; 4731 ; 4732////////////////////////////////////////////////////////////////////////////////; 4733/// Returns open timeout (in ms).; 4734 ; 4735UInt_t TFile::GetOpenTimeout(); 4736{; 4737 return fgOpenTimeout;; 4738}; 4739 ; 4740////////////////////////////////////////////////////////////////////////////////; 4741/// Sets only staged flag. Returns previous value of flag.; 4742/// When true we check before opening the file if it is staged, if not,; 4743/// the open fails.; 4744 ; 4745Bool_t TFile::SetOnlyStaged(Bool_t onlystaged); 4746{; 4747 Bool_t f = fgOnlyStaged;; 4748 fgOnlyStaged = onlystaged;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:173578,timeout,timeout,173578,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['timeout'],['timeout']
Safety,") == len) {; 4115 if ((f = TFile::Open(xurl.c_str(), options, ftitle, compress, netopt))) {; 4116 if (!f->IsZombie()) {; 4117 return f;; 4118 } else {; 4119 delete f;; 4120 f = nullptr;; 4121 }; 4122 }; 4123 }; 4124 }; 4125 }; 4126 }; 4127#endif; 4128 ; 4129 // If a timeout has been specified extract the value and try to apply it (it requires; 4130 // support for asynchronous open, though; the following is completely transparent if; 4131 // such support if not available for the required protocol); 4132 TString opts(options);; 4133 Int_t ito = opts.Index(""TIMEOUT="");; 4134 if (ito != kNPOS) {; 4135 TString sto = opts(ito + strlen(""TIMEOUT=""), opts.Length());; 4136 while (!(sto.IsDigit()) && !(sto.IsNull())) { sto.Remove(sto.Length()-1,1); }; 4137 if (!(sto.IsNull())) {; 4138 // Timeout in millisecs; 4139 Int_t toms = sto.Atoi() * 1000;; 4140 if (gDebug > 0) ::Info(""TFile::Open"", ""timeout of %d millisec requested"", toms);; 4141 // Remove from the options field; 4142 sto.Insert(0, ""TIMEOUT="");; 4143 opts.ReplaceAll(sto, """");; 4144 // Asynchronous open; 4145 TFileOpenHandle *fh = TFile::AsyncOpen(expandedUrl, opts, ftitle, compress, netopt);; 4146 // Check the result in steps of 1 millisec; 4147 TFile::EAsyncOpenStatus aos = TFile::kAOSNotAsync;; 4148 aos = TFile::GetAsyncOpenStatus(fh);; 4149 Int_t xtms = toms;; 4150 while (aos == TFile::kAOSInProgress && xtms > 0) {; 4151 gSystem->Sleep(1);; 4152 xtms -= 1;; 4153 aos = TFile::GetAsyncOpenStatus(fh);; 4154 }; 4155 if (aos == TFile::kAOSNotAsync || aos == TFile::kAOSSuccess) {; 4156 // Do open the file now; 4157 f = TFile::Open(fh);; 4158 if (gDebug > 0) {; 4159 if (aos == TFile::kAOSSuccess); 4160 ::Info(""TFile::Open"", ""waited %d millisec for asynchronous open"", toms - xtms);; 4161 else; 4162 ::Info(""TFile::Open"", ""timeout option not supported (requires asynchronous""; 4163 "" open support)"");; 4164 }; 4165 } else {; 4166 if (xtms <= 0); 4167 ::Error(""TFile::Open"", ""timeout expired while opening '%s'"", expandedUrl.Data()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:151645,TIMEOUT,TIMEOUT,151645,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['TIMEOUT'],['TIMEOUT']
Safety,") const override;  Compute safe distance from each of the points in the input array. ;  ; void SavePrimitive (std::ostream &out, Option_t *option="""") override;  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void SetPoints (Double_t *points) const override;  No mesh for assemblies. ;  ; void SetPoints (Float_t *points) const override;  No mesh for assemblies. ;  ; void SetSegsAndPols (TBuffer3D &buff) const override;  Fill TBuffer3D structure for segments and polygons. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TGeoBBox;  TGeoBBox ();  ;  TGeoBBox (const char *name, Double_t dx, Double_t dy, Double_t dz, Double_t *origin=nullptr);  ;  TGeoBBox (Double_t *param);  ;  TGeoBBox (Double_t dx, Double_t dy, Double_t dz, Double_t *origin=nullptr);  ;  ~TGeoBBox () override;  ; Double_t Capacity () const override;  ; Bool_t CouldBeCrossed (const Double_t *point, const Double_t *dir) const override;  ; const char * GetAxisName (Int_t iaxis) const override;  ; Double_t GetAxisRange (Int_t iaxis, Double_t &xlo, Double_t &xhi) const override;  ; void GetBoundingCylinder (Double_t *param) const override;  ; const TBuffer3D & GetBuffer3D (Int_t reqSections, Bool_t localFrame) const override;  Stub implementation to avoid forcing implementation at this stage. ;  ; Int_t GetByteCount () const override;  ; virtual Double_t GetDX () const;  ; virtual Double_t GetDY () const;  ; virtual Double_t GetDZ () const;  ; virtual Double_t GetFacetArea (Int_t index=0) const;  ; Int_t GetFittingBox (const TGeoBBox *parambox, TGeoMatrix *mat, Double_t &dx, Double_t &dy, Double_t &dz) const override;  ; virtual const Double_t * GetOrigin () const;  ; virtual Bool_t GetPointsOnFacet (Int_t index, Int_t npoints, Double_t *array) const;  ; Bool_t GetPointsOnSegments (Int_t npoints, Double_t *array) const override;  ; virtual Bool_t IsNul",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoShapeAssembly.html:5069,avoid,avoid,5069,doc/master/classTGeoShapeAssembly.html,https://root.cern,https://root.cern/doc/master/classTGeoShapeAssembly.html,1,['avoid'],['avoid']
Safety,") const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoShapeAssembly&operator=(const TGeoShapeAssembly&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); voidRecomputeBoxLast(); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidTGeoBBox::SetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetPoints(Double_t* points) const; virtual voidSetPoi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoShapeAssembly.html:8374,Safe,SafetyPhi,8374,root/html534/TGeoShapeAssembly.html,https://root.cern,https://root.cern/root/html534/TGeoShapeAssembly.html,1,['Safe'],['SafetyPhi']
Safety,") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); virtual Bool_tContains(const Double_t* point) const; static Bool_tContains(const Double_t* point, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin); virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tCouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistFromInside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* vo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoBBox.html:3963,safe,safe,3963,root/html534/TGeoBBox.html,https://root.cern,https://root.cern/root/html534/TGeoBBox.html,3,['safe'],['safe']
Safety,") const; voidRooAbsCollection::sort(Bool_t ascend = kTRUE); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; voidRooArgSet::writeToFile(const char* fileName) const; virtual voidRooArgSet::writeToStream(ostream& os, Bool_t compact, const char* section = 0) const. protected:. Bool_tRooAbsCollection::addServerClonesToList(const RooAbsArg& var); virtual voidRooAbsProxy::changeNormSet(const RooArgSet* newNormSet); virtual Bool_tchangePointer(const RooAbsCollection& newServerSet, Bool_t nameChange = kFALSE, Bool_t factoryInitMode = kFALSE); Bool_tRooArgSet::checkForDup(const RooAbsArg& arg, Bool_t silent) const; virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); voidRooAbsCollection::safeDeleteList(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. Bool_t_defShapeServer; Bool_t_defValueServer; TIterator*_iter! do not persist; RooLinkedListRooAbsCollection::_listActual object store; TStringRooAbsCollection::_nameOur name.; static Int_tRooPrintable::_nameLength; RooArgSet*RooAbsProxy::_nse",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooSetProxy.html:11428,safe,safeDeleteList,11428,root/html526/RooSetProxy.html,https://root.cern,https://root.cern/root/html526/RooSetProxy.html,2,['safe'],['safeDeleteList']
Safety,") const; { return fTopSessionTag; }. const char * GetSessionDir() const; { return fSessionDir; }. const char * GetPackageDir() const; { return fPackageDir; }. const char * GetDataDir() const; { return fDataDir; }. const char * GetDataDirOpts() const; { return fDataDirOpts; }. Int_t GetProtocol() const; { return fProtocol; }. const char * GetOrdinal() const; { return fOrdinal; }. Int_t GetGroupId() const; { return fGroupId; }. Int_t GetGroupSize() const; { return fGroupSize; }. Int_t GetLogLevel() const; { return fLogLevel; }. TSocket * GetSocket() const; { return fSocket; }. Float_t GetRealTime() const; { return fRealTime; }. Float_t GetCpuTime() const; { return fCpuTime; }. Int_t GetQuerySeqNum() const; { return fQuerySeqNum; }. Int_t GetTotSessions() const; { return fTotSessions; }. Int_t GetActSessions() const; { return fActSessions; }. Float_t GetEffSessions() const; { return fEffSessions; }. TList * GetEnabledPackages() const; { return fEnabledPackages; }. Long64_t GetMsgSizeHWM() const; { return fMsgSizeHWM; }. const char * GetPrefix() const; { return fPrefix; }. TProofLockPath * GetCacheLock(); { return fCacheLock; }. EQueryAction GetWorkers(TList* workers, Int_t& prioritychange, Bool_t resume = kFALSE). void HandleTermination(); { Terminate(0); }. void Interrupt(); { fInterrupt = kTRUE; }. Bool_t IsEndMaster() const; { return fEndMaster; }. Bool_t IsMaster() const; { return fMasterServ; }. Bool_t IsTopMaster() const; { return fOrdinal == ""0""; }. void ReleaseWorker(const char* ); { }. void DisableTimeout(); Disable / Enable read timeout. { }. void EnableTimeout(); { }. void LogToMaster(Bool_t on = kTRUE); Log control. { fSendLogToMaster = on; }. » Author: Fons Rademakers 16/02/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/proof:$Id$ » Last generated: 2015-06-02 16:30; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TProofServ.html:35684,timeout,timeout,35684,root/html604/TProofServ.html,https://root.cern,https://root.cern/root/html604/TProofServ.html,1,['timeout'],['timeout']
Safety,") const; { return fTopSessionTag; }. const char * GetSessionDir() const; { return fSessionDir; }. const char * GetPackageDir() const; { return fPackageDir; }. const char * GetDataDir() const; { return fDataDir; }. const char * GetDataDirOpts() const; { return fDataDirOpts; }. Int_t GetProtocol() const; { return fProtocol; }. const char * GetOrdinal() const; { return fOrdinal; }. Int_t GetGroupId() const; { return fGroupId; }. Int_t GetGroupSize() const; { return fGroupSize; }. Int_t GetLogLevel() const; { return fLogLevel; }. TSocket * GetSocket() const; { return fSocket; }. Float_t GetRealTime() const; { return fRealTime; }. Float_t GetCpuTime() const; { return fCpuTime; }. Int_t GetQuerySeqNum() const; { return fQuerySeqNum; }. Int_t GetTotSessions() const; { return fTotSessions; }. Int_t GetActSessions() const; { return fActSessions; }. Float_t GetEffSessions() const; { return fEffSessions; }. TList * GetEnabledPackages() const; { return fEnabledPackages; }. Long64_t GetMsgSizeHWM() const; { return fMsgSizeHWM; }. const char * GetPrefix() const; { return fPrefix; }. TProofLockPath * GetCacheLock(); { return fCacheLock; }. EQueryAction GetWorkers(TList* workers, Int_t& prioritychange, Bool_t resume = kFALSE). void HandleTermination(); { Terminate(0); }. void Interrupt(); { fInterrupt = kTRUE; }. Bool_t IsEndMaster() const; { return fEndMaster; }. Bool_t IsMaster() const; { return fMasterServ; }. Bool_t IsTopMaster() const; { return fOrdinal == ""0""; }. void ReleaseWorker(const char* ); { }. void DisableTimeout(); Disable / Enable read timeout. { }. void EnableTimeout(); { }. void LogToMaster(Bool_t on = kTRUE); Log control. { fSendLogToMaster = on; }. » Author: Fons Rademakers 16/02/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/proof:$Id$ » Last generated: 2015-06-30 15:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofServ.html:35682,timeout,timeout,35682,root/html602/TProofServ.html,https://root.cern,https://root.cern/root/html602/TProofServ.html,1,['timeout'],['timeout']
Safety,") const;  ; TClass * GetNewClass () const;  ; Int_t GetNewType () const;  ; Int_t GetOffset () const;  ; void GetSequenceType (TString &type) const;  Fill type with the string representation of sequence information including 'cached','repeat','write' or 'nodelete'. ;  ; TMemberStreamer * GetStreamer () const;  Return the local streamer object. ;  ; Int_t GetTObjectOffset () const;  ; Int_t GetType () const;  ; const char * GetTypeName () const;  ; const char * GetTypeNameBasic () const;  Return type name of this element in case the type name is not a standard basic type, return the basic type name known to CINT. ;  ; Double_t GetXmax () const;  ; Double_t GetXmin () const;  ; virtual Bool_t HasCounter () const;  ; virtual Bool_t IsaPointer () const;  ; virtual Bool_t IsBase () const;  Return kTRUE if the element represent a base class. ;  ; virtual Bool_t IsOldFormat (const char *newTypeName);  The early 3.00/00 and 3.01/01 versions used to store dm->GetTypeName instead of dm->GetFullTypename if this case is detected, the element type name is modified. ;  ; virtual Bool_t IsTransient () const;  Return kTRUE if the element represent an entity that is not written to the disk (transient members, cache allocator/deallocator, etc.) ;  ; void ls (Option_t *option="""") const override;  Print the content of the element. ;  ; virtual void SetArrayDim (Int_t dim);  Set number of array dimensions. ;  ; virtual void SetMaxIndex (Int_t dim, Int_t max);  set maximum index for array with dimension dim ;  ; virtual void SetNewClass (TClass *cl);  ; virtual void SetNewType (Int_t dtype);  ; virtual void SetOffset (Int_t offset);  ; virtual void SetSize (Int_t dsize);  ; virtual void SetStreamer (TMemberStreamer *streamer);  set pointer to Streamer function for this element ;  ; virtual void SetTObjectOffset (Int_t tobjoffset);  ; virtual void SetType (Int_t dtype);  ; virtual void SetTypeName (const char *name);  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTStreamerObject.html:3050,detect,detected,3050,doc/master/classTStreamerObject.html,https://root.cern,https://root.cern/doc/master/classTStreamerObject.html,2,['detect'],['detected']
Safety,") elist->SetDirectory(nullptr); //otherwise the file destructor will delete elist; }; }; }; ; ; void h1analysis::SlaveBegin(TTree *tree); {; // function called before starting the event loop; // -it performs some cleanup; // -it creates histograms; // -it sets some initialisation for the entry list; ; //initialize the Tree branch addresses; Init(tree);; ; //print the option specified in the Process function.; TString option = GetOption();; Info(""SlaveBegin"",; ""starting h1analysis with process option: %s (tree: %p)"", option.Data(), tree);; ; //create histograms; hdmd = new TH1F(""hdmd"",""dm_d"",40,0.13,0.17);; h2 = new TH2F(""h2"",""ptD0 vs dm_d"",30,0.135,0.165,30,-3,6);; ; fOutput->Add(hdmd);; fOutput->Add(h2);; ; // Entry list stuff (re-parse option because on PROOF only SlaveBegin is called); if (option.Contains(""fillList"")) {; fillList = kTRUE;; // Get the list; if (fInput) {; if ((elist = (TEntryList *) fInput->FindObject(""elist""))); // Need to clone to avoid problems when destroying the selector; elist = (TEntryList *) elist->Clone();; if (elist); fOutput->Add(elist);; else; fillList = kFALSE;; }; }; if (fillList) Info(""SlaveBegin"", ""creating an entry-list"");; if (option.Contains(""useList"")) useList = kTRUE;; }; ; ; Bool_t h1analysis::Process(Long64_t entry); {; // entry is the entry number in the current Tree; // Selection function to select D* and D0.; ; fProcessed++;; //in case one entry list is given in input, the selection has already been done.; if (!useList) {; // Read only the necessary branches to select entries.; // return as soon as a bad entry is detected; // to read complete event, call fChain->GetTree()->GetEntry(entry); b_md0_d->GetEntry(entry); if (TMath::Abs(md0_d-1.8646) >= 0.04) return kFALSE;; b_ptds_d->GetEntry(entry); if (ptds_d <= 2.5) return kFALSE;; b_etads_d->GetEntry(entry); if (TMath::Abs(etads_d) >= 1.5) return kFALSE;; b_ik->GetEntry(entry); ik--; //original ik used f77 convention starting at 1; b_ipi->GetEntry(entry); ipi--;; b_ntracks-",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/h1analysis_8C.html:8714,avoid,avoid,8714,doc/master/h1analysis_8C.html,https://root.cern,https://root.cern/doc/master/h1analysis_8C.html,1,['avoid'],['avoid']
Safety,") fCanvas->SetCursor(cursor);; 2914}; 2915 ; 2916////////////////////////////////////////////////////////////////////////////////; 2917/// Set double buffer mode ON or OFF.; 2918 ; 2919void TPad::SetDoubleBuffer(Int_t mode); 2920{; 2921 if (fCanvas) fCanvas->SetDoubleBuffer(mode);; 2922}; 2923 ; 2924////////////////////////////////////////////////////////////////////////////////; 2925/// Set selected.; 2926 ; 2927void TPad::SetSelected(TObject *obj); 2928{; 2929 if (fCanvas) fCanvas->SetSelected(obj);; 2930}; 2931 ; 2932////////////////////////////////////////////////////////////////////////////////; 2933/// Update pad.; 2934 ; 2935void TPad::Update(); 2936{; 2937 if (fCanvas) fCanvas->Update();; 2938}; 2939 ; 2940////////////////////////////////////////////////////////////////////////////////; 2941/// Asynchronous pad update.; 2942/// In case of web-based canvas triggers update of the canvas on the client side,; 2943/// but does not wait that real update is completed. Avoids blocking of caller thread.; 2944/// Have to be used if called from other web-based widget to avoid logical dead-locks.; 2945/// In case of normal canvas just canvas->Update() is performed.; 2946 ; 2947void TPad::UpdateAsync(); 2948{; 2949 if (fCanvas) fCanvas->UpdateAsync();; 2950}; 2951 ; 2952////////////////////////////////////////////////////////////////////////////////; 2953/// Get frame.; 2954 ; 2955TFrame *TPad::GetFrame(); 2956{; 2957 if (!fPrimitives) fPrimitives = new TList;; 2958 TFrame *frame = (TFrame*)GetListOfPrimitives()->FindObject(fFrame);; 2959 if (!frame) frame = (TFrame*)GetListOfPrimitives()->FindObject(""TFrame"");; 2960 fFrame = frame;; 2961 if (!fFrame) {; 2962 if (!frame) fFrame = new TFrame(0,0,1,1);; 2963 Int_t framecolor = GetFrameFillColor();; 2964 if (!framecolor) framecolor = GetFillColor();; 2965 fFrame->SetFillColor(framecolor);; 2966 fFrame->SetFillStyle(GetFrameFillStyle());; 2967 fFrame->SetLineColor(GetFrameLineColor());; 2968 fFrame->SetLineStyle(GetFrameLine",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TPad_8cxx_source.html:92902,Avoid,Avoids,92902,doc/master/TPad_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html,1,['Avoid'],['Avoids']
Safety,") only one thread will react; to activate a further thread another MyCondition.Signal() is required, etc.; If several threads wait for the signal from the same TCondition MyCondition, at MyCondition.Broadcast() all threads waiting for MyCondition are activated at once. In some tests of MyCondition using an internal mutex, Broadcast() activated only one thread (probably depending whether MyCondition had been signaled before). MyCondition.TimedWait(secs,nanosecs) waits for MyCondition until the absolute time in seconds and nanoseconds since beginning of the epoch (January, 1st, 1970) is reached; to use relative timeouts ‘‘delta’‘, it is required to calculate the absolute time at the beginning of waiting ‘‘now’’; for example:. Ulong_t now,then,delta; // seconds; TDatime myTime; // root daytime class; myTime.Set(); // myTime set to ""now""; now=myTime.Convert(); // to seconds since 1970. Return value wait of MyCondition.TimedWait should be 0, if MyCondition.Signal() was received, and should be nonzero, if timeout was reached. The conditions example shows how three threaded functions are synchronized using TCondition: a ROOT script condstart.C starts the threads, which are defined in a shared library (conditions.cxx, conditions.h).; 23.2.4.3 Xlib Connections; Usually Xlib is not thread safe. This means that calls to the X could fail, when it receives X-messages from different threads. The actual result depends strongly on which version of Xlib has been installed on your system. The only thing we can do here within ROOT is calling a special function XInitThreads()(which is part of the Xlib), which should (!) prepare the Xlib for the usage with threads.; To avoid further problems within ROOT some redefinition of the gPad pointer was done (that’s the main reason for the recompilation). When a thread creates a TCanvas, this object is actually created in the main thread; this should be transparent to the user. Actions on the canvas are controlled via a function, which returns a ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1110158,timeout,timeout,1110158,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['timeout'],['timeout']
Safety,") {; 17705 /* Request is directed to another server: It could be a; 17706 * substring; 17707 * like notmyserver.com */; 17708 return 0;; 17709 }; 17710 if (0; 17711 != memcmp(server_domain,; 17712 hostbegin + request_domain_len - server_domain_len,; 17713 server_domain_len)) {; 17714 /* Request is directed to another server:; 17715 * The server name is different. */; 17716 return 0;; 17717 }; 17718 }; 17719 }; 17720 ; 17721 return hostend;; 17722}; 17723 ; 17724 ; 17725static int; 17726get_message(struct mg_connection *conn, char *ebuf, size_t ebuf_len, int *err); 17727{; 17728 if (ebuf_len > 0) {; 17729 ebuf[0] = '\0';; 17730 }; 17731 *err = 0;; 17732 ; 17733 reset_per_request_attributes(conn);; 17734 ; 17735 if (!conn) {; 17736 mg_snprintf(conn,; 17737 NULL, /* No truncation check for ebuf */; 17738 ebuf,; 17739 ebuf_len,; 17740 ""%s"",; 17741 ""Internal error"");; 17742 *err = 500;; 17743 return 0;; 17744 }; 17745 ; 17746 /* Set the time the request was received. This value should be used for; 17747 * timeouts. */; 17748 clock_gettime(CLOCK_MONOTONIC, &(conn->req_time));; 17749 ; 17750 conn->request_len =; 17751 read_message(NULL, conn, conn->buf, conn->buf_size, &conn->data_len);; 17752 DEBUG_ASSERT(conn->request_len < 0 || conn->data_len >= conn->request_len);; 17753 if ((conn->request_len >= 0) && (conn->data_len < conn->request_len)) {; 17754 mg_snprintf(conn,; 17755 NULL, /* No truncation check for ebuf */; 17756 ebuf,; 17757 ebuf_len,; 17758 ""%s"",; 17759 ""Invalid message size"");; 17760 *err = 500;; 17761 return 0;; 17762 }; 17763 ; 17764 if ((conn->request_len == 0) && (conn->data_len == conn->buf_size)) {; 17765 mg_snprintf(conn,; 17766 NULL, /* No truncation check for ebuf */; 17767 ebuf,; 17768 ebuf_len,; 17769 ""%s"",; 17770 ""Message too large"");; 17771 *err = 413;; 17772 return 0;; 17773 }; 17774 ; 17775 if (conn->request_len <= 0) {; 17776 if (conn->data_len > 0) {; 17777 mg_snprintf(conn,; 17778 NULL, /* No truncation check for ebuf */; 17779 ebuf,; 17780 e",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:527410,timeout,timeouts,527410,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['timeout'],['timeouts']
Safety,") {; 17706 /* Request is directed to another server: It could be a; 17707 * substring; 17708 * like notmyserver.com */; 17709 return 0;; 17710 }; 17711 if (0; 17712 != memcmp(server_domain,; 17713 hostbegin + request_domain_len - server_domain_len,; 17714 server_domain_len)) {; 17715 /* Request is directed to another server:; 17716 * The server name is different. */; 17717 return 0;; 17718 }; 17719 }; 17720 }; 17721 ; 17722 return hostend;; 17723}; 17724 ; 17725 ; 17726static int; 17727get_message(struct mg_connection *conn, char *ebuf, size_t ebuf_len, int *err); 17728{; 17729 if (ebuf_len > 0) {; 17730 ebuf[0] = '\0';; 17731 }; 17732 *err = 0;; 17733 ; 17734 reset_per_request_attributes(conn);; 17735 ; 17736 if (!conn) {; 17737 mg_snprintf(conn,; 17738 NULL, /* No truncation check for ebuf */; 17739 ebuf,; 17740 ebuf_len,; 17741 ""%s"",; 17742 ""Internal error"");; 17743 *err = 500;; 17744 return 0;; 17745 }; 17746 ; 17747 /* Set the time the request was received. This value should be used for; 17748 * timeouts. */; 17749 clock_gettime(CLOCK_MONOTONIC, &(conn->req_time));; 17750 ; 17751 conn->request_len =; 17752 read_message(NULL, conn, conn->buf, conn->buf_size, &conn->data_len);; 17753 DEBUG_ASSERT(conn->request_len < 0 || conn->data_len >= conn->request_len);; 17754 if ((conn->request_len >= 0) && (conn->data_len < conn->request_len)) {; 17755 mg_snprintf(conn,; 17756 NULL, /* No truncation check for ebuf */; 17757 ebuf,; 17758 ebuf_len,; 17759 ""%s"",; 17760 ""Invalid message size"");; 17761 *err = 500;; 17762 return 0;; 17763 }; 17764 ; 17765 if ((conn->request_len == 0) && (conn->data_len == conn->buf_size)) {; 17766 mg_snprintf(conn,; 17767 NULL, /* No truncation check for ebuf */; 17768 ebuf,; 17769 ebuf_len,; 17770 ""%s"",; 17771 ""Message too large"");; 17772 *err = 413;; 17773 return 0;; 17774 }; 17775 ; 17776 if (conn->request_len <= 0) {; 17777 if (conn->data_len > 0) {; 17778 mg_snprintf(conn,; 17779 NULL, /* No truncation check for ebuf */; 17780 ebuf,; 17781 e",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:527443,timeout,timeouts,527443,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['timeout'],['timeouts']
Safety,") {; 351 Error(""TPad"", ""illegal height: %f"", yup-ylow);; 352 zombie = kTRUE;; 353 }; 354 ; 355 if (zombie) {; 356 // error in creating pad occurred, make this pad a zombie; 357 MakeZombie();; 358 return;; 359 }; 360 ; 361 ; 362 fLogx = gStyle->GetOptLogx();; 363 fLogy = gStyle->GetOptLogy();; 364 fLogz = gStyle->GetOptLogz();; 365 ; 366 fUxmin = fUymin = fUxmax = fUymax = 0;; 367 ; 368 // Set pad parameters and Compute conversion coefficients; 369 SetPad(name, title, xlow, ylow, xup, yup, color, bordersize, bordermode);; 370 Range(0, 0, 1, 1);; 371 SetBit(kMustCleanup);; 372 SetBit(kCanDelete);; 373}; 374 ; 375 ; 376////////////////////////////////////////////////////////////////////////////////; 377/// Pad destructor.; 378 ; 379TPad::~TPad(); 380{; 381 if (ROOT::Detail::HasBeenDeleted(this)) return;; 382 Close();; 383 CloseToolTip(fTip);; 384 DeleteToolTip(fTip);; 385 auto primitives = fPrimitives;; 386 // In some cases, fPrimitives has the kMustCleanup bit set which will lead; 387 // its destructor to call RecursiveRemove and since this pad is still; 388 // likely to be (indirectly) in the list of cleanups, we must set; 389 // fPrimitives to nullptr to avoid TPad::RecursiveRemove from calling; 390 // a member function of a partially destructed object.; 391 fPrimitives = nullptr;; 392 delete primitives;; 393 SafeDelete(fExecs);; 394 delete fViewer3D;; 395 ; 396 // Required since we overload TObject::Hash.; 397 ROOT::CallRecursiveRemoveIfNeeded(*this);; 398 if (this == gPad); 399 gPad = nullptr;; 400}; 401 ; 402////////////////////////////////////////////////////////////////////////////////; 403/// Add an object to list of primitives with speicified draw option; 404/// When \par modified set to kTRUE (default) pad will be marked as modified; 405/// Let avoid usage of gPad when drawing object(s) in canvas or in subpads.; 406///; 407/// ~~~{.cpp}; 408/// auto c1 = new TCanvas(""c1"",""Canvas with subpoads"", 600, 600);; 409/// c1->Divide(2,2);; 410///; 411/// for (Int_t n ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TPad_8cxx_source.html:11473,avoid,avoid,11473,doc/master/TPad_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html,1,['avoid'],['avoid']
Safety,") {; if (iev%1000==0) cout<<""Processing event ""<<iev<<""...""<<endl;; ; Float_t ea,eb;; gRandom->Rannor(ea,eb); // the two energies follow a gaus distribution; e->a.e=ea;; e->b.e=eb;; e->a.t=gRandom->Rndm(); // random; e->b.t=e->a.t + gRandom->Gaus(0.,.1); // identical to a.t but a gaussian; // 'resolution' was added with sigma .1; ; tree->Fill(); // fill the tree with the current event; }; ; // start the viewer; // here you can investigate the structure of your Event class; tree->StartViewer();; ; //gROOT->SetStyle(""Plain""); // uncomment to set a different style; ; // now draw some tree variables; TCanvas *c1 = new TCanvas();; c1->Divide(2,2);; c1->cd(1);; tree->Draw(""a.e""); //energy of det a; tree->Draw(""a.e"",""3*(-.2<b.e && b.e<.2)"",""same""); // same but with condition on energy b; scaled by 3; c1->cd(2);; tree->Draw(""b.e:a.e"","""",""colz""); // one energy against the other; c1->cd(3);; tree->Draw(""b.t"","""",""e""); // time of b with errorbars; tree->Draw(""a.t"","""",""same""); // overlay time of detector a; c1->cd(4);; tree->Draw(""b.t:a.t""); // plot time b again time a; ; cout<<endl;; cout<<""You can now examine the structure of your tree in the TreeViewer""<<endl;; cout<<endl;; }; ; b#define b(i)Definition RSha256.hxx:100; a#define a(i)Definition RSha256.hxx:99; Riostream.h; Int_tint Int_tDefinition RtypesCore.h:45; Float_tfloat Float_tDefinition RtypesCore.h:57; Double_tdouble Double_tDefinition RtypesCore.h:59; ClassImp#define ClassImp(name)Definition Rtypes.h:382; ClassDefOverride#define ClassDefOverride(name, id)Definition Rtypes.h:346; TCanvas.h; TRandom.h; gRandomR__EXTERN TRandom * gRandomDefinition TRandom.h:62; TStyle.h; TTree.h; TCanvasThe Canvas class.Definition TCanvas.h:23; TObjectMother of all ROOT objects.Definition TObject.h:41; TRandom::Gausvirtual Double_t Gaus(Double_t mean=0, Double_t sigma=1)Samples a random number from the standard Normal (Gaussian) Distribution with the given mean and sigm...Definition TRandom.cxx:275; TRandom::RndmDouble_t Rndm() overrideM",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tree0_8C.html:2747,detect,detector,2747,doc/master/tree0_8C.html,https://root.cern,https://root.cern/doc/master/tree0_8C.html,1,['detect'],['detector']
Safety,") || (n > fMaximum)) {; 4281 if (IsMissingCollection()) {; 4282 n = 0;; 4283 b.SetBufferOffset(b.Length()-sizeof(n));; 4284 } else {; 4285 Error(""ReadLeaves"", ""Incorrect size read for the container in %s\n\tThe size read is %d while the maximum is %d\n\tThe size is reset to 0 for this entry (%lld)"", GetName(), n, fMaximum, GetReadEntry());; 4286 n = 0;; 4287 }; 4288 }; 4289 fNdata = n;; 4290 ; 4291 R__PushCache onfileObject(((TBufferFile&)b),fOnfileObject,1);; 4292 ; 4293 // Note: Proxy-helper needs to ""embrace"" the entire; 4294 // streaming of this STL container if the container; 4295 // is a set/multiset/map/multimap (what we do not; 4296 // know here).; 4297 // For vector/list/deque Allocate == Resize; 4298 // and Commit == noop.; 4299 // TODO: Exception safety a la TPushPop; 4300 TVirtualCollectionProxy* proxy = GetCollectionProxy();; 4301 TVirtualCollectionProxy::TPushPop helper(proxy, fObject);; 4302 void* alternate = proxy->Allocate(fNdata, true);; 4303 if(fSTLtype != ROOT::kSTLvector && proxy->HasPointers() && fSplitLevel > TTree::kSplitCollectionOfPointers ) {; 4304 fPtrIterators->CreateIterators(alternate, proxy);; 4305 } else {; 4306 fIterators->CreateIterators(alternate, proxy);; 4307 }; 4308 ; 4309 Int_t nbranches = fBranches.GetEntriesFast();; 4310 switch (fSTLtype) {; 4311 case ROOT::kSTLset:; 4312 case ROOT::kSTLunorderedset:; 4313 case ROOT::kSTLunorderedmultiset:; 4314 case ROOT::kSTLmultiset:; 4315 case ROOT::kSTLmap:; 4316 case ROOT::kSTLmultimap:; 4317 case ROOT::kSTLunorderedmap:; 4318 case ROOT::kSTLunorderedmultimap:; 4319 for (Int_t i = 0; i < nbranches; ++i) {; 4320 TBranch *branch = (TBranch*) fBranches[i];; 4321 Int_t nb = branch->GetEntry(GetReadEntry(), 1);; 4322 if (nb < 0) {; 4323 // Give up on i/o failure.; 4324 // FIXME: We need an error message here.; 4325 break;; 4326 }; 4327 }; 4328 break;; 4329 default:; 4330 break;; 4331 }; 4332 //------------------------------------------------------------------------; 4333 // We have split thi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranchElement_8cxx_source.html:158942,safe,safety,158942,doc/master/TBranchElement_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html,1,['safe'],['safety']
Safety,")); , kHelixStraight = (1ULL << ( 17 )); , kHelixCircle = (1ULL << ( 18 )); };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  . Public Member Functions;  TGeoHelix ();  Dummy constructor. ;  ;  TGeoHelix (Double_t curvature, Double_t step, Int_t charge=1);  Normal constructor. ;  ;  ~TGeoHelix () override;  Destructor. ;  ; Double_t ComputeSafeStep (Double_t epsil=1E-6) const;  Compute safe linear step that can be made such that the error between linear-helix extrapolation is less than EPSIL. ;  ; const Double_t * GetCurrentDirection () const;  ; const Double_t * GetCurrentPoint () const;  ; Double_t GetStep () const;  ; Double_t GetTotalCurvature () const;  Compute helix total curvature. ;  ; Double_t GetXYcurvature () const;  ; void InitDirection (Double_t *dir, Bool_t is_normalized=kTRUE);  Initialize particle direction (tangent on the helix in initial point) ;  ; void InitDirection (Double_t dirx, Double_t diry, Double_t dirz, Bool_t is_normalized=kTRUE);  Initialize particle direction (tangent on the helix in initial point) ;  ; void InitPoint (Double_t *point);  Set initial point on the helix. ;  ; void InitPoint (Double_t x0, Double_t y0, Double_t z0);  Initialize coordinates of a point on the helix. ;  ; TClass * IsA () const override;  ; Bool_t IsRightHanded () const;  ; void ResetStep ();  Reset current point/direction to initial values. ;  ; void SetCharge (Int_t charge);  Po",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoHelix.html:2759,safe,safe,2759,doc/master/classTGeoHelix.html,https://root.cern,https://root.cern/doc/master/classTGeoHelix.html,1,['safe'],['safe']
Safety,")); 3647 return fBase;; 3648 }; 3649 }; 3650 // We test again on fCanLoadClassInfo has another thread may have executed it.; 3651 if (!fHasRootPcmInfo && fCanLoadClassInfo) {; 3652 LoadClassInfo();; 3653 }; 3654 }; 3655 if (!fClassInfo); 3656 return nullptr;; 3657 ; 3658 if (!gInterpreter); 3659 Fatal(""GetListOfBases"", ""gInterpreter not initialized"");; 3660 ; 3661 R__LOCKGUARD(gInterpreterMutex);; 3662 if (!fBase.load()) {; 3663 gInterpreter->CreateListOfBaseClasses(this);; 3664 }; 3665 }; 3666 return fBase;; 3667}; 3668 ; 3669////////////////////////////////////////////////////////////////////////////////; 3670/// Return a list containing the TEnums of a class.; 3671///; 3672/// The list returned is safe to use from multiple thread without explicitly; 3673/// taking the ROOT global lock.; 3674///; 3675/// In the case the TClass represents a namespace, the returned list will; 3676/// implicit take the ROOT global lock upon any access (see TListOfEnumsWithLock); 3677///; 3678/// In the case the TClass represents a class or struct and requestListLoading; 3679/// is true, the list is immutable (and thus safe to access from multiple thread; 3680/// without taking the global lock at all).; 3681///; 3682/// In the case the TClass represents a class or struct and requestListLoading; 3683/// is false, the list is mutable and thus we return a TListOfEnumsWithLock; 3684/// which will implicit take the ROOT global lock upon any access.; 3685 ; 3686TList *TClass::GetListOfEnums(Bool_t requestListLoading /* = kTRUE */); 3687{; 3688 auto temp = fEnums.load();; 3689 if (temp) {; 3690 if (requestListLoading) {; 3691 if (fProperty == -1) Property();; 3692 if (! ((kIsClass | kIsStruct | kIsUnion) & fProperty) ) {; 3693 R__LOCKGUARD(gROOTMutex);; 3694 temp->Load();; 3695 } else if ( temp->IsA() == TListOfEnumsWithLock::Class() ) {; 3696 // We have a class for which the list was not loaded fully at; 3697 // first use.; 3698 R__LOCKGUARD(gROOTMutex);; 3699 temp->Load();; 3700 }; 3701 }; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:139287,safe,safe,139287,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['safe'],['safe']
Safety,")); 3714 return fBase;; 3715 }; 3716 }; 3717 // We test again on fCanLoadClassInfo has another thread may have executed it.; 3718 if (!fHasRootPcmInfo && fCanLoadClassInfo) {; 3719 LoadClassInfo();; 3720 }; 3721 }; 3722 if (!fClassInfo); 3723 return nullptr;; 3724 ; 3725 if (!gInterpreter); 3726 Fatal(""GetListOfBases"", ""gInterpreter not initialized"");; 3727 ; 3728 R__LOCKGUARD(gInterpreterMutex);; 3729 if (!fBase.load()) {; 3730 gInterpreter->CreateListOfBaseClasses(this);; 3731 }; 3732 }; 3733 return fBase;; 3734}; 3735 ; 3736////////////////////////////////////////////////////////////////////////////////; 3737/// Return a list containing the TEnums of a class.; 3738///; 3739/// The list returned is safe to use from multiple thread without explicitly; 3740/// taking the ROOT global lock.; 3741///; 3742/// In the case the TClass represents a namespace, the returned list will; 3743/// implicit take the ROOT global lock upon any access (see TListOfEnumsWithLock); 3744///; 3745/// In the case the TClass represents a class or struct and requestListLoading; 3746/// is true, the list is immutable (and thus safe to access from multiple thread; 3747/// without taking the global lock at all).; 3748///; 3749/// In the case the TClass represents a class or struct and requestListLoading; 3750/// is false, the list is mutable and thus we return a TListOfEnumsWithLock; 3751/// which will implicit take the ROOT global lock upon any access.; 3752 ; 3753TList *TClass::GetListOfEnums(Bool_t requestListLoading /* = kTRUE */); 3754{; 3755 auto temp = fEnums.load();; 3756 if (temp) {; 3757 if (requestListLoading) {; 3758 if (fProperty == -1) Property();; 3759 if (! ((kIsClass | kIsStruct | kIsUnion) & fProperty) ) {; 3760 R__LOCKGUARD(gROOTMutex);; 3761 temp->Load();; 3762 } else if ( temp->IsA() == TListOfEnumsWithLock::Class() ) {; 3763 // We have a class for which the list was not loaded fully at; 3764 // first use.; 3765 R__LOCKGUARD(gROOTMutex);; 3766 temp->Load();; 3767 }; 3768 }; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:142038,safe,safe,142038,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['safe'],['safe']
Safety,")*.001;; 6137 ymax += dyy;; 6138 ymin -= dyy;; 6139 mnbins(ymin, ymax, maxny, ymin, ymax, ny, bwidy);; 6140 any = (Double_t) ny;; 6141 // if first point is blank, it is an 'origin'; 6142 if (chbest == ' ') goto L50;; 6143 xbest = (xmax + xmin)*.5;; 6144 ybest = (ymax + ymin)*.5;; 6145L50:; 6146 // find scale constants; 6147 ax = 1 / bwidx;; 6148 ay = 1 / bwidy;; 6149 bx = -ax*xmin + 2;; 6150 by = -ay*ymin - 2;; 6151 // convert points to grid positions; 6152 for (i = 1; i <= nxypt; ++i) {; 6153 xpt[i-1] = ax*xpt[i-1] + bx;; 6154 ypt[i-1] = any - ay*ypt[i-1] - by;; 6155 }; 6156 nxbest = Int_t((ax*xbest + bx));; 6157 nybest = Int_t((any - ay*ybest - by));; 6158 // print the points; 6159 ny += 2;; 6160 nx += 2;; 6161 isp1 = 1;; 6162 linodd = 1;; 6163 overpr = kFALSE;; 6164 for (i = 1; i <= ny; ++i) {; 6165 for (ibk = 1; ibk <= nx; ++ibk) { cline[ibk-1] = ' '; }; 6166 cline[nx] = '\0';; 6167 cline[nx+1] = '\0';; 6168 cline[0] = '.';; 6169 // not needed - but to avoid a wrongly reported compiler warning (see ROOT-6496); 6170 if (nx>0) cline[nx-1] = '.';; 6171 cline[nxbest-1] = '.';; 6172 if (i != 1 && i != nybest && i != ny) goto L320;; 6173 for (j = 1; j <= nx; ++j) { cline[j-1] = '.'; }; 6174L320:; 6175 yprt = ymax - Double_t(i-1)*bwidy;; 6176 if (isp1 > nxypt) goto L350;; 6177 // find the points to be plotted on this line; 6178 for (k = isp1; k <= nxypt; ++k) {; 6179 ks = Int_t(ypt[k-1]);; 6180 if (ks > i) goto L345;; 6181 ix = Int_t(xpt[k-1]);; 6182 if (cline[ix-1] == '.') goto L340;; 6183 if (cline[ix-1] == ' ') goto L340;; 6184 if (cline[ix-1] == chpt[k-1]) continue;; 6185 overpr = kTRUE;; 6186 // OVERPR is true if one or more positions contains more than; 6187 // one point; 6188 cline[ix-1] = '&';; 6189 continue;; 6190L340:; 6191 cline[ix-1] = chpt[k-1];; 6192 }; 6193 isp1 = nxypt + 1;; 6194 goto L350;; 6195L345:; 6196 isp1 = k;; 6197L350:; 6198 if (linodd == 1 || i == ny) goto L380;; 6199 linodd = 1;; 6200 ctemp = cline;; 6201 Printf("" %s"",(const char*)ctemp);; 62",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMinuit_8cxx_source.html:200131,avoid,avoid,200131,doc/master/TMinuit_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html,1,['avoid'],['avoid']
Safety,"). Change Theta - Polar3D coordinates only. { fCoordinates.SetTheta(ang); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetPhi(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar ang). Change Phi - Polar3D or CylindricalEta3D coordinates. { fCoordinates.SetPhi(ang); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetRho(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar rr). Change Rho - CylindricalEta3D coordinates only. { fCoordinates.SetRho(rr); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetEta(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar etaval). Change Eta - CylindricalEta3D coordinates only. { fCoordinates.SetEta(etaval); return *this;}. Scalar Dot(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>& v) const; ------ Operations combining two vectors ------; -- need to have the specialized version in order to avoid. Return the scalar (dot) product of two displacement vectors.; It is possible to perform the product for any type of vector coordinates,; 	 but they must have the same coordinate system tag. DisplacementVector3D Cross( const DisplacementVector3D<OtherCoords,Tag> & v). Return vector (cross) product of two displacement vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any type of vector coordinates,; 	 but they must have the same coordinate system tag. DisplacementVector3D Cross( const OtherVector & v). Return vector (cross) product of two vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any classes; implementing X(), Y() and Z() member functions. DisplacementVector3D & operator*=(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::D",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_double__-p1DefaultCoordinateSystemTag_.html:21263,avoid,avoid,21263,root/html528/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_double__-p1DefaultCoordinateSystemTag_.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_double__-p1DefaultCoordinateSystemTag_.html,3,['avoid'],['avoid']
Safety,"). Change Theta - Polar3D coordinates only. { fCoordinates.SetTheta(ang); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetPhi(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar ang). Change Phi - Polar3D or CylindricalEta3D coordinates. { fCoordinates.SetPhi(ang); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetRho(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar rr). Change Rho - CylindricalEta3D coordinates only. { fCoordinates.SetRho(rr); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetEta(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar etaval). Change Eta - CylindricalEta3D coordinates only. { fCoordinates.SetEta(etaval); return *this;}. Scalar Dot(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>& v) const; ------ Operations combining two vectors ------; -- need to have the specialized version in order to avoid. Return the scalar (dot) product of two displacement vectors.; It is possible to perform the product for any type of vector coordinates,; but they must have the same coordinate system tag. DisplacementVector3D Cross( const DisplacementVector3D<OtherCoords,Tag> & v). Return vector (cross) product of two displacement vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any type of vector coordinates,; but they must have the same coordinate system tag. DisplacementVector3D Cross( const OtherVector & v). Return vector (cross) product of two vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any classes; implementing X(), Y() and Z() member functions. DisplacementVector3D & operator*=(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::Defau",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_double__-p1DefaultCoordinateSystemTag_.html:20374,avoid,avoid,20374,root/html534/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_double__-p1DefaultCoordinateSystemTag_.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_double__-p1DefaultCoordinateSystemTag_.html,1,['avoid'],['avoid']
Safety,"). Compute DistFromInside and move the; point with bigger distance. Compute DistFromOutside back from new point.; Plot d-(d1+d2). void CheckGeometryFull(Int_t ntracks = 1000000, Double_t vx = 0., Double_t vy = 0., Double_t vz = 0., Option_t* option = ""ob""); Geometry checking.; - if option contains 'o': Optional overlap checkings (by sampling and by mesh).; - if option contains 'b': Optional boundary crossing check + timing per volume. STAGE 1: extensive overlap checking by sampling per volume. Stdout need to be; checked by user to get report, then TGeoVolume::CheckOverlaps(0.01, ""s"") can; be called for the suspicious volumes.; STAGE2 : normal overlap checking using the shapes mesh - fills the list of; overlaps.; STAGE3 : shooting NRAYS rays from VERTEX and counting the total number of; crossings per volume (rays propagated from boundary to boundary until; geometry exit). Timing computed and results stored in a histo.; STAGE4 : shooting 1 mil. random rays inside EACH volume and calling; FindNextBoundary() + Safety() for each call. The timing is normalized by the; number of crossings computed at stage 2 and presented as percentage.; One can get a picture on which are the most ""burned"" volumes during; transportation from geometry point of view. Another plot of the timing per; volume vs. number of daughters is produced. void CheckGeometry(Option_t* option = """"); Instanciate a TGeoChecker object and investigates the geometry according to; option. Not implemented yet.; check shapes first. void CheckOverlaps(Double_t ovlp = 0.1, Option_t* option = """"); Check all geometry for illegal overlaps within a limit OVLP. void PrintOverlaps() const; Prints the current list of overlaps. Double_t Weight(Double_t precision = 0.01, Option_t* option = ""va""); Estimate weight of volume VOL with a precision SIGMA(W)/W better than PRECISION.; Option can be ""v"" - verbose (default). ULong_t SizeOf(const TGeoNode* node, Option_t* option); computes the total size in bytes of the branch starting w",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoManager.html:65786,Safe,Safety,65786,root/html530/TGeoManager.html,https://root.cern,https://root.cern/root/html530/TGeoManager.html,2,['Safe'],['Safety']
Safety,"). Compute DistFromInside and move the; point with bigger distance. Compute DistFromOutside back from new point.; Plot d-(d1+d2). void CheckGeometryFull(Int_t ntracks = 1000000, Double_t vx = 0., Double_t vy = 0., Double_t vz = 0., Option_t* option = ""ob""); Geometry checking.; - if option contains 'o': Optional overlap checkings (by sampling and by mesh).; - if option contains 'b': Optional boundary crossing check + timing per volume. STAGE 1: extensive overlap checking by sampling per volume. Stdout need to be; checked by user to get report, then TGeoVolume::CheckOverlaps(0.01, ""s"") can; be called for the suspicious volumes.; STAGE2 : normal overlap checking using the shapes mesh - fills the list of; overlaps.; STAGE3 : shooting NRAYS rays from VERTEX and counting the total number of; crossings per volume (rays propagated from boundary to boundary until; geometry exit). Timing computed and results stored in a histo.; STAGE4 : shooting 1 mil. random rays inside EACH volume and calling; FindNextBoundary() + Safety() for each call. The timing is normalized by the; number of crossings computed at stage 2 and presented as percentage.; One can get a picture on which are the most ""burned"" volumes during; transportation from geometry point of view. Another plot of the timing per; volume vs. number of daughters is produced. void CheckGeometry(Option_t* option = """"); Perform last checks on the geometry. void CheckOverlaps(Double_t ovlp = 0.1, Option_t* option = """"); Check all geometry for illegal overlaps within a limit OVLP. void PrintOverlaps() const; Prints the current list of overlaps. Double_t Weight(Double_t precision = 0.01, Option_t* option = ""va""); Estimate weight of volume VOL with a precision SIGMA(W)/W better than PRECISION.; Option can be ""v"" - verbose (default). ULong_t SizeOf(const TGeoNode* node, Option_t* option); computes the total size in bytes of the branch starting with node.; The option can specify if all the branch has to be parsed or only the node. voi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoManager.html:68588,Safe,Safety,68588,root/html534/TGeoManager.html,https://root.cern,https://root.cern/root/html534/TGeoManager.html,1,['Safe'],['Safety']
Safety,"). Compute DistFromInside and move the; point with bigger distance. Compute DistFromOutside back from new point.; Plot d-(d1+d2). void CheckGeometryFull(Int_t ntracks = 1000000, Double_t vx = 0., Double_t vy = 0., Double_t vz = 0., Option_t* option = ""ob""); Geometry checking.; - if option contains 'o': Optional overlap checkings (by sampling and by mesh).; - if option contains 'b': Optional boundary crossing check + timing per volume. STAGE 1: extensive overlap checking by sampling per volume. Stdout need to be; checked by user to get report, then TGeoVolume::CheckOverlaps(0.01, ""s"") can; be called for the suspicious volumes.; STAGE2 : normal overlap checking using the shapes mesh - fills the list of; overlaps.; STAGE3 : shooting NRAYS rays from VERTEX and counting the total number of; crossings per volume (rays propagated from boundary to boundary until; geometry exit). Timing computed and results stored in a histo.; STAGE4 : shooting 1 mil. random rays inside EACH volume and calling; FindNextBoundary() + Safety() for each call. The timing is normalized by the; number of crossings computed at stage 2 and presented as percentage.; One can get a picture on which are the most ""burned"" volumes during; transportation from geometry point of view. Another plot of the timing per; volume vs. number of daughters is produced. void CheckGeometry(Option_t* option = """"); Perform last checks on the geometry. void CheckOverlaps(Double_t ovlp = 0.10000000000000001, Option_t* option = """"); Check all geometry for illegal overlaps within a limit OVLP. void PrintOverlaps() const; Prints the current list of overlaps. Double_t Weight(Double_t precision = 0.01, Option_t* option = ""va""); Estimate weight of volume VOL with a precision SIGMA(W)/W better than PRECISION.; Option can be ""v"" - verbose (default). ULong_t SizeOf(const TGeoNode* node, Option_t* option); computes the total size in bytes of the branch starting with node.; The option can specify if all the branch has to be parsed or on",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoManager.html:69099,Safe,Safety,69099,root/html602/TGeoManager.html,https://root.cern,https://root.cern/root/html602/TGeoManager.html,2,['Safe'],['Safety']
Safety,"). Int_t TGeoBBox::DistancetoPrimitive ; (; Int_t ; px, . Int_t ; py . ). overridevirtual . Computes distance from point (px,py) to the object. ; This member function must be implemented for each graphics primitive. This default function returns a big number (999999). ; Implements TGeoShape.; Reimplemented in TGeoTessellated, TGeoCompositeShape, TGeoCone, TGeoConeSeg, TGeoEltu, TGeoHalfSpace, TGeoHype, TGeoParaboloid, TGeoPcon, TGeoPgon, TGeoScaledShape, TGeoShapeAssembly, TGeoSphere, TGeoTorus, TGeoTube, TGeoTubeSeg, TGeoXtru, and TGeoVGShape. ◆ DistFromInside() [1/2]. static Double_t TGeoBBox::DistFromInside ; (; const Double_t * ; point, . const Double_t * ; dir, . Double_t ; dx, . Double_t ; dy, . Double_t ; dz, . const Double_t * ; origin, . Double_t ; stepmax = TGeoShape::Big() . ). static . ◆ DistFromInside() [2/2]. Double_t TGeoBBox::DistFromInside ; (; const Double_t * ; point, . const Double_t * ; dir, . Int_t ; iact = 1, . Double_t ; step = TGeoShape::Big(), . Double_t * ; safe = nullptr . ); const. overridevirtual . Implements TGeoShape.; Reimplemented in TGeoTrap, TGeoGtra, TGeoCompositeShape, TGeoCone, TGeoConeSeg, TGeoEltu, TGeoHalfSpace, TGeoHype, TGeoPara, TGeoParaboloid, TGeoPcon, TGeoPgon, TGeoScaledShape, TGeoShapeAssembly, TGeoSphere, TGeoTorus, TGeoTrd1, TGeoTrd2, TGeoTube, TGeoTubeSeg, TGeoCtub, TGeoXtru, and TGeoVGShape. ◆ DistFromInside_v(). void TGeoBBox::DistFromInside_v ; (; const Double_t * ; points, . const Double_t * ; dirs, . Double_t * ; dists, . Int_t ; vecsize, . Double_t * ; step . ); const. overridevirtual . Reimplemented from TGeoShape.; Reimplemented in TGeoTrap, TGeoGtra, TGeoCompositeShape, TGeoCone, TGeoConeSeg, TGeoEltu, TGeoHalfSpace, TGeoHype, TGeoPara, TGeoParaboloid, TGeoPcon, TGeoPgon, TGeoScaledShape, TGeoShapeAssembly, TGeoSphere, TGeoTorus, TGeoTrd1, TGeoTrd2, TGeoTube, TGeoTubeSeg, TGeoCtub, and TGeoXtru. ◆ DistFromOutside() [1/2]. static Double_t TGeoBBox::DistFromOutside ; (; const Double_t * ; point, . const Dou",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoBBox.html:26446,safe,safe,26446,doc/master/classTGeoBBox.html,https://root.cern,https://root.cern/doc/master/classTGeoBBox.html,1,['safe'],['safe']
Safety,"). Refresh the node pointers and re-voxelize. ; To be called mandatory in case re-alignment happened. ; Definition at line 198 of file TGeoParallelWorld.cxx. ◆ ResetOverlaps(). void TGeoParallelWorld::ResetOverlaps ; (; ); const. Reset overlapflag for all volumes in geometry. ; Definition at line 154 of file TGeoParallelWorld.cxx. ◆ Safety(). Double_t TGeoParallelWorld::Safety ; (; Double_t ; point[3], . Double_t ; safmax = 1.E30 . ). inline . Definition at line 118 of file TGeoParallelWorld.h. ◆ SafetyBVH(). double TGeoParallelWorld::SafetyBVH ; (; Double_t ; point[3], . Double_t ; safmax = 1.E30 . ). private . Compute safety for the parallel world (using pure BVH traversal, mainly for debugging/fallback since VoxelSafety should be faster) ; Definition at line 1027 of file TGeoParallelWorld.cxx. ◆ SafetyLoop(). Double_t TGeoParallelWorld::SafetyLoop ; (; Double_t ; point[3], . Double_t ; safmax = 1.E30 . ). private . Compute safety for the parallel world (trivial loop version for comparison/debugging) ; Definition at line 1207 of file TGeoParallelWorld.cxx. ◆ SafetyOrig(). Double_t TGeoParallelWorld::SafetyOrig ; (; Double_t ; point[3], . Double_t ; safmax = 1.E30 . ). private . Compute safety for the parallel world (original version based on TGeoVoxelFinder) ; Definition at line 1145 of file TGeoParallelWorld.cxx. ◆ SetAccelerationMode(). void TGeoParallelWorld::SetAccelerationMode ; (; AccelerationMode const & ; mode). inline . Definition at line 95 of file TGeoParallelWorld.h. ◆ SetUseOverlaps(). void TGeoParallelWorld::SetUseOverlaps ; (; Bool_t ; flag). inline . Definition at line 80 of file TGeoParallelWorld.h. ◆ Streamer(). void TGeoParallelWorld::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void TGeoParallelWorld::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 184 of file TGeoParallelWorld.h. ◆ TestVoxelGrid(). void TGeoPa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoParallelWorld.html:26282,safe,safety,26282,doc/master/classTGeoParallelWorld.html,https://root.cern,https://root.cern/doc/master/classTGeoParallelWorld.html,1,['safe'],['safety']
Safety,"). private:. virtual void*GetSender(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. private:. Bool_tfIsActivekTRUE if handler is active, kFALSE if not active. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Activate(); Activate a system event handler. All handlers are by default; activated. Use this method to activate a de-activated handler. void DeActivate(); De-activate a system event handler. Use this method to temporarily; disable an event handler to avoid it from being recursively called.; Use DeActivate() / Activate() instead of Remove() / Add() for this; purpose, since the Add() will add the handler back to the end of; the list of handlers and cause it to be called again for the same,; already handled, event. void * GetSender(); { return this; }. virtual ~TSysEvtHandler(); { }. Bool_t IsActive() const; { return fIsActive; }. void Add(). void Remove(). Bool_t Notify(). void Activated(); { Emit(""Activated()""); }. void DeActivated(); { Emit(""DeActivated()""); }. void Notified(); { Emit(""Notified()""); }. void Added(); { Emit(""Added()""); }. void Removed(); { Emit(""Removed()""); }. » Author: Fons Rademakers 16/09/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-03-14 16:50; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TSysEvtHandler.html:9470,avoid,avoid,9470,root/html534/TSysEvtHandler.html,https://root.cern,https://root.cern/root/html534/TSysEvtHandler.html,1,['avoid'],['avoid']
Safety,"). template<> . double TMVA::DNN::computeRegularization< EnumRegularization::L1 > ; (; double ; weight, . const double & ; factorWeightDecay . ). inline . Definition at line 219 of file NeuralNet.icc. ◆ computeRegularization< EnumRegularization::L2 >(). template<> . double TMVA::DNN::computeRegularization< EnumRegularization::L2 > ; (; double ; weight, . const double & ; factorWeightDecay . ). inline . Definition at line 226 of file NeuralNet.icc. ◆ crossEntropy(). template<typename ItProbability , typename ItTruth , typename ItDelta , typename ItInvActFnc > . double TMVA::DNN::crossEntropy ; (; ItProbability ; itProbabilityBegin, . ItProbability ; itProbabilityEnd, . ItTruth ; itTruthBegin, . ItTruth ; , . ItDelta ; itDelta, . ItDelta ; itDeltaEnd, . ItInvActFnc ; , . double ; patternWeight . ). cross entropy error function ; Definition at line 412 of file NeuralNet.icc. ◆ cudaError(). void TMVA::DNN::cudaError ; (; cudaError_t ; code, . const char * ; file, . int ; line, . bool ; abort = true . ). inline . Function to check cuda return code. ; Taken from http://stackoverflow.com/questions/14038589/ ; Definition at line 198 of file CudaMatrix.h. ◆ CurandInitializationKernel(). __global__ void TMVA::DNN::CurandInitializationKernel ; (; unsigned long long ; seed, . curandState_t * ; state . ). Definition at line 26 of file CudaMatrix.cu. ◆ debugTensor(). template<typename Architecture > . auto TMVA::DNN::debugTensor ; (; const typename Architecture::Tensor_t & ; A, . const std::string ; name = ""tensor"" . ); -> void. Definition at line 582 of file GeneralLayer.h. ◆ evaluate() [1/3]. template<typename Architecture_t > . auto TMVA::DNN::evaluate ; (; ELossFunction ; f, . const typename Architecture_t::Matrix_t & ; Y, . const typename Architecture_t::Matrix_t & ; output, . const typename Architecture_t::Matrix_t & ; weights . ); -> decltype(Architecture_t::CrossEntropy(Y, output, weights)). inline . Compute the value of the objective function f for given activations of t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceTMVA_1_1DNN.html:27452,abort,abort,27452,doc/master/namespaceTMVA_1_1DNN.html,https://root.cern,https://root.cern/doc/master/namespaceTMVA_1_1DNN.html,2,['abort'],['abort']
Safety,"). virtual Double_t TGeoTube::GetRmin ; (; ); const. inlinevirtual . Definition at line 72 of file TGeoTube.h. ◆ HasRmin(). Bool_t TGeoTube::HasRmin ; (; ); const. inline . Definition at line 75 of file TGeoTube.h. ◆ InspectShape(). void TGeoTube::InspectShape ; (; ); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoTubeSeg. ◆ IsA(). TClass * TGeoTube::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TGeoBBox.; Reimplemented in TGeoTubeSeg.; Definition at line 91 of file TGeoTube.h. ◆ IsCylType(). Bool_t TGeoTube::IsCylType ; (; ); const. inlineoverridevirtual . Reimplemented from TGeoBBox.; Definition at line 77 of file TGeoTube.h. ◆ MakeBuffer3D(). TBuffer3D * TGeoTube::MakeBuffer3D ; (; ); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoTubeSeg. ◆ operator=(). TGeoTube & TGeoTube::operator= ; (; const TGeoTube & ; ). protecteddelete . ◆ Safety(). Double_t TGeoTube::Safety ; (; const Double_t * ; point, . Bool_t ; in = kTRUE . ); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoTubeSeg. ◆ Safety_v(). void TGeoTube::Safety_v ; (; const Double_t * ; points, . const Bool_t * ; inside, . Double_t * ; safe, . Int_t ; vecsize . ); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoTubeSeg. ◆ SafetyS(). static Double_t TGeoTube::SafetyS ; (; const Double_t * ; point, . Bool_t ; in, . Double_t ; rmin, . Double_t ; rmax, . Double_t ; dz, . Int_t ; skipz = 0 . ). static . ◆ SavePrimitive(). void TGeoTube::SavePrimitive ; (; std::ostream & ; out, . Option_t * ; option = """" . ). overridevirtual . Save a primitive as a C++ statement(s) on output stream ""out"". ; Reimplemented from TGeoBBox.; Reimplemented in TGeoTubeSeg. ◆ SetDimensions(). void TGeoTube::SetDimensions ; (; Double_t * ; param). overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoTubeSeg. ◆ SetPoints() [1/2]. void TGeoTube::SetPoints ; (;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoTube.html:30487,Safe,Safety,30487,doc/master/classTGeoTube.html,https://root.cern,https://root.cern/doc/master/classTGeoTube.html,1,['Safe'],['Safety']
Safety,"). virtual void TVirtualPacketizer::MarkBad ; (; TSlave * ; , . TProofProgressStatus * ; , . TList ** ;  . ). inlinevirtual . Reimplemented in TPacketizerAdaptive, and TPacketizerMulti.; Definition at line 141 of file TVirtualPacketizer.h. ◆ operator=(). void TVirtualPacketizer::operator= ; (; const TVirtualPacketizer & ; ). protected . ◆ SetFailedPackets(). void TVirtualPacketizer::SetFailedPackets ; (; TList * ; list). inline . Definition at line 129 of file TVirtualPacketizer.h. ◆ SetInitTime(). void TVirtualPacketizer::SetInitTime ; (; ). virtual . Set the initialization time. ; Definition at line 429 of file TVirtualPacketizer.cxx. ◆ SetProgressStatus(). void TVirtualPacketizer::SetProgressStatus ; (; TProofProgressStatus * ; st). inline . Definition at line 145 of file TVirtualPacketizer.h. ◆ SetTotalEntries(). void TVirtualPacketizer::SetTotalEntries ; (; Long64_t ; ent). inline . Definition at line 146 of file TVirtualPacketizer.h. ◆ StopProcess(). void TVirtualPacketizer::StopProcess ; (; Bool_t ; abort, . Bool_t ; stoptimer = kFALSE . ). virtual . Stop process. ; Reimplemented in TPacketizerMulti.; Definition at line 243 of file TVirtualPacketizer.cxx. ◆ Streamer(). void TVirtualPacketizer::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void TVirtualPacketizer::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 152 of file TVirtualPacketizer.h. Member Data Documentation. ◆ fActWrksLast. Int_t TVirtualPacketizer::fActWrksLast. protected . Definition at line 90 of file TVirtualPacketizer.h. ◆ fAWLastFill. Bool_t TVirtualPacketizer::fAWLastFill. protected . Definition at line 94 of file TVirtualPacketizer.h. ◆ fCircN. Long_t TVirtualPacketizer::fCircN. protected . Definition at line 86 of file TVirtualPacketizer.h. ◆ fCircProg. TNtupleD* TVirtualPacketizer::fCircProg. protected . Definition at line 84 of file TVirtualPacketizer.h",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTVirtualPacketizer.html:20922,abort,abort,20922,doc/master/classTVirtualPacketizer.html,https://root.cern,https://root.cern/doc/master/classTVirtualPacketizer.html,1,['abort'],['abort']
Safety,").; Mode is the same as for the Unix access(2) function.; Attention, bizarre convention of return value!!. int Unlink(const char* path); Unlink 'path' on the remote server system.; Returns 0 on success, -1 otherwise. Bool_t IsOnline(const char* path); Check if the file defined by 'path' is ready to be used. Bool_t Prepare(const char* path, UChar_t opt = 8, UChar_t prio = 0); Issue a prepare request for file defined by 'path'. Int_t Prepare(TCollection* paths, UChar_t opt = 8, UChar_t prio = 0, TString* buf = 0); Issue a prepare request for a list of files defined by 'paths', which must; be of one of the following types: TFileInfo, TUrl, TObjString.; On output, bufout, if defined, points to a buffer form that can be used; with GetPathsInfo.; Return the number of paths found or -1 if any error occured. Bool_t GetPathsInfo(const char* paths, UChar_t* info); Retrieve status of a '\n'-separated list of files in 'paths'.; The information is returned as one UChar_t per file in 'info';; 'info' must be allocated by the caller. Bool_t IsPathLocal(const char* path); Returns TRUE if the url in 'path' points to the local file system.; This is used to avoid going through the NIC card for local operations. Int_t Locate(const char* path, TString& endurl); Get end-point url of a file. Info is returned in eurl.; The function returns 0 in case of success and 1 if the file could; not be stat'ed. XrdClientAdmin * GetClientAdmin(const char* url); Checks if an admin for 'url' exists already.; Avoid duplications. TString GetKey(const char* url); Build from uu a unique ID key used in hash tables. void * GetDirPtr() const; { return fDirp; }. virtual ~TXNetSystem(); { }. » Author: Frank Winklmeier, Fabrizio Furano » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/netx:$Id$ » Last generated: 2015-03-15 16:41; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TXNetSystem.html:23228,avoid,avoid,23228,root/html534/TXNetSystem.html,https://root.cern,https://root.cern/root/html534/TXNetSystem.html,2,"['Avoid', 'avoid']","['Avoid', 'avoid']"
Safety,").BeginsWith(""\\\\"")); 444 file->String().Prepend(""\\\\"");; 445 file->String().ReplaceAll(""\\"",""/"");; 446 const char *rfile = (const char*)file->String();; 447 Printf(""Attaching file %s as _file%d..."", rfile, nfile);; 448 snprintf(cmd, kMAXPATHLEN+50, ""TFile *_file%d = TFile::Open(\""%s\"")"", nfile++, rfile);; 449 } else {; 450 Printf(""Processing %s..."", (const char*)file->String());; 451 snprintf(cmd, kMAXPATHLEN+50, "".x %s"", (const char*)file->String());; 452 }; 453 }; 454 Getlinem(kCleanUp, nullptr);; 455 Gl_histadd(cmd);; 456 ; 457 // The ProcessLine might throw an 'exception'. In this case,; 458 // GetLinem(kInit,""Root >"") is called and we are jump back; 459 // to RETRY ... and we have to avoid the Getlinem(kInit, GetPrompt());; 460 needGetlinemInit = kFALSE;; 461 retval = ProcessLineNr(""ROOT_cli_"", cmd, &error);; 462 gCling->EndOfLineAction();; 463 fNcmd++;; 464 ; 465 // The ProcessLine has successfully completed and we need; 466 // to call Getlinem(kInit, GetPrompt());; 467 needGetlinemInit = kTRUE;; 468 ; 469 if (error != 0 || fCaughtSignal != -1) break;; 470 }; 471 } ENDTRY;; 472 ; 473 if (QuitOpt()) {; 474 if (retrn) return;; 475 if (error) {; 476 retval = error;; 477 } else if (fCaughtSignal != -1) {; 478 retval = fCaughtSignal + 128;; 479 }; 480 // Bring retval into sensible range, 0..255.; 481 if (retval < 0 || retval > 255); 482 retval = 255;; 483 Terminate(retval);; 484 }; 485 ; 486 // Allow end-of-file on the terminal to be noticed; 487 // after we finish processing the command line input files.; 488 fInputHandler->Activate();; 489 ; 490 ClearInputFiles();; 491 ; 492 if (needGetlinemInit) Getlinem(kInit, GetPrompt());; 493 }; 494 ; 495 if (QuitOpt()) {; 496 printf(""\n"");; 497 if (retrn) return;; 498 Terminate(fCaughtSignal != -1 ? fCaughtSignal + 128 : 0);; 499 }; 500 ; 501 TApplication::Run(retrn);; 502 ; 503 // Reset to happiness.; 504 fCaughtSignal = -1;; 505 ; 506 Getlinem(kCleanUp, nullptr);; 507}; 508 ; 509////////////////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TRint_8cxx_source.html:16121,avoid,avoid,16121,doc/master/TRint_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TRint_8cxx_source.html,1,['avoid'],['avoid']
Safety,"); 27 void *fWcsTitle{nullptr}; ///<!Used by TMathText; 28 ; 29public:; 30 // TText status bits; 31 enum {; 32 kTextNDC = BIT(14) ///< The text position is in the NDC space; 33 };; 34 ; 35 TText() {} // NOLINT: not allowed to use = default because of TObject::kIsOnHeap detection, see ROOT-10300; 36 TText(Double_t x, Double_t y, const char *text);; 37 TText(Double_t x, Double_t y, const wchar_t *text);; 38 TText(const TText &text);; 39 ~TText() override;; 40 ; 41 TText &operator=(const TText &src);; 42 ; 43 void Copy(TObject &text) const override;; 44 Int_t DistancetoPrimitive(Int_t px, Int_t py) override;; 45 virtual TText *DrawText(Double_t x, Double_t y, const char *text);; 46 virtual TText *DrawText(Double_t x, Double_t y, const wchar_t *text);; 47 virtual TText *DrawTextNDC(Double_t x, Double_t y, const char *text);; 48 virtual TText *DrawTextNDC(Double_t x, Double_t y, const wchar_t *text);; 49 void ExecuteEvent(Int_t event, Int_t px, Int_t py) override;; 50 ; 51 virtual void GetControlBox(Int_t x, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TText_8h_source.html:1252,detect,detection,1252,doc/master/TText_8h_source.html,https://root.cern,https://root.cern/doc/master/TText_8h_source.html,1,['detect'],['detection']
Safety,"); 36 ; 37Use option __entrylist__ to write the results of TTree::Draw and TChain::Draw into; 38an entry list. Example:; 39~~~ {.cpp}; 40 tree->Draw("">>elist"", ""x<0 && y>0"", ""entrylist"");; 41 TEntryList *elist = (TEntryList*)gDirectory->Get(""elist"");; 42~~~; 43## Example of Loop on TEntryList with a TChain; 44~~~ {.cpp}; 45 void loopChain() {; 46 TFile *fe = TFile::Open(""myelist.root"");; 47 TEntryList *myelist = (TEntryList*)fe->Get(""myelist"");; 48 TChain *chain = new TChain(""ntuple"");; 49 chain->Add(""hsimple.root"");; 50 chain->Add(""hsimple2.root"");; 51 Long64_t listEntries = myelist->GetN();; 52 Long64_t chainEntries = chain->GetEntries();; 53 Int_t treenum = 0;; 54 chain->SetEntryList(myelist);; 55 ; 56 for (entry=start;entry < end;entry++) {; 57 entryNumber = chain->GetEntryNumber(entry);; 58 if (entryNumber < 0) break;; 59 localEntry = chain->LoadTree(entryNumber);; 60 if (localEntry < 0) break;; 61 ....; 62 then either call; 63 branch->GetEntry(localEntry);; 64 or; 65 chain->GetEntry(entryNumber);; 66 In the later case the LoadTree is then somewhat redundant.; 67 ...; 68 }; 69 }; 70~~~; 71When using the TEntryList interface directly, you can get the 'tree number' and entry in; 72the current tree (i.e. value similar to the return value of LoadTree) from calling; 73TEntryList::GetEntryAndTree:; 74~~~ {.cpp}; 75 Long64_t treeEntry = myelist->GetEntryAndTree(el,treenum);; 76~~~; 77to obtain the entry number within the chain you need to add to it the value of; 78`treeEntry+ch->GetTreeOffset()[treenum]`; 79such that the loop in the previous example can also be written as:; 80~~~ {.cpp}; 81 for (Long64_t el = 0; el < listEntries; el++) {; 82 Long64_t treeEntry = myelist->GetEntryAndTree(el,treenum);; 83 Long64_t chainEntry = treeEntry+ch->GetTreeOffset()[treenum];; 84 printf(""el=%lld, treeEntry=%lld, chainEntry=%lld, treenum=%d\n"", el, treeEntry, chainEntry, treenum);; 85 ; 86 ch->LoadTree(chainEntry); // this also returns treeEntry; 87 needed_branch->GetEntry(treeEntr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TEntryList_8cxx_source.html:2806,redund,redundant,2806,doc/master/TEntryList_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TEntryList_8cxx_source.html,1,['redund'],['redundant']
Safety,"); Bool_tfPwHashkTRUE if fPasswd is a passwd hash; Int_tfRSAKeyType of RSA key used; TStringfRemoteremote host to which we want to connect; Bool_tfSRPPwdkTRUE if fPasswd is a SRP passwd; TRootSecContext*fSecContextpointer to relevant sec context; TAuthenticate::ESecurityfSecurityactual logon security level; TSocket*fSocketconnection to remote daemon; Int_tfTimeOuttimeout flag; TStringfUseruser to be authenticated; Int_tfVersion0,1,2, ... accordingly to remote daemon version; static TList*fgAuthInfo; static TStringfgAuthMeth[6]; static Bool_tfgAuthReUsekTRUE is ReUse required; static Int_tfgAuthTOif > 0, timeout in sec; static TStringfgDefaultUserDefault user information; static TDatimefgExpDateExpiring date for new security contexts; static GlobusAuth_tfgGlobusAuthHook; static Krb5Auth_tfgKrb5AuthHook; static TStringfgKrb5PrincipalPrincipal for Krb5 ticket; static TDatimefgLastAuthrcTime of last reading of fgRootAuthrc; static Int_tfgLastErrorLast error code processed by AuthError(); static TStringfgPasswd; static TPluginHandler*fgPasswdDialogPasswd dialog GUI plugin; static Int_tfgProcessIDID of the main thread as unique identifier; static Bool_tfgPromptUserkTRUE if user prompt required; static TList*fgProofAuthInfoSpecific lists of THostAuth fro proof; static Bool_tfgPwHashkTRUE if fgPasswd is a passwd hash; static Int_tfgRSAInit; static Int_tfgRSAKeyDefault type of RSA key to be tried; static rsa_KEYfgRSAPriKey; static rsa_KEY_exportfgRSAPubExport[2]; static rsa_KEYfgRSAPubKey; static Bool_tfgReadHomeAuthrckTRUE to look for $HOME/.rootauthrc; static TStringfgRootAuthrcPath to last rootauthrc-like file read; static Bool_tfgSRPPwdkTRUE if fgPasswd is a SRP passwd; static SecureAuth_tfgSecAuthHook; static TStringfgUser; static Bool_tfgUsrPwdCryptkTRUE if encryption for UsrPwd is required. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TAuthenticate(TSocket* sock, const char* remote, const char* proto, const char* user = """")",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TAuthenticate.html:9796,timeout,timeout,9796,root/html526/TAuthenticate.html,https://root.cern,https://root.cern/root/html526/TAuthenticate.html,7,['timeout'],['timeout']
Safety,"); RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TCanvasThe Canvas class.Definition TCanvas.h:23; RooFit::BinsRooCmdArg Bins(Int_t nbin)Definition RooGlobalFunc.cxx:547; RooFit::ShiftToZeroRooCmdArg ShiftToZero()Definition RooGlobalFunc.cxx:191; RooFit::LineColorRooCmdArg LineColor(Color_t color)Definition RooGlobalFunc.cxx:215; xDouble_t x[n]Definition legend1.C:17; RooFit::Detail::MathFuncs::nlldouble nll(double pdf, double weight, int binnedL, int doBinOffset)Definition MathFuncs.h:353; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf605_profilellDefinition rf605_profilell.py:1; xmlio::Titleconst char * TitleDefinition TXMLSetup.cxx:68; RangeTa Range(0, 0, 1, 1); ; [#0] WARNING:InputArguments -- The parameter 'sigma_g1' with range [-inf, inf] of the RooGaussian 'g1' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; Minuit2Minimizer: Minimize with max-calls 1500 convergence for edm < 1 strategy 1; Minuit2Minimizer : Valid minimum - status = 0; FVAL = 2659.73712858695399; Edm = 0.000190395763129910388; Nfcn = 60; frac = 0.62118 +/- 0.165788 (limited); mean = 0.00442366 +/- 0.109372 (limited); sigma_g2 = 4.10789 +/- 0.405468 (limited); [#1] INFO:Minimization -- RooProfileLL::evaluate(RooEvaluatorWrapper_Profile[frac]) Creating instance of MINUIT; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error l",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf605__profilell_8C.html:5829,safe,safe,5829,doc/master/rf605__profilell_8C.html,https://root.cern,https://root.cern/doc/master/rf605__profilell_8C.html,1,['safe'],['safe']
Safety,"); Used internally to compute the likelihood value. void FindPrediction(int bin, double& t_i, int& k_0, double& A_ki) const; Function used internally to obtain the template prediction in the individual bins; 'bin' <=> 'i' (paper); 'par' <=> 'j' (paper). Double_t GetChisquare() const; Return the likelihood ratio Chi-squared (chi2) for the fit.; The value is computed when the fit is executed successfully.; Chi2 calculation is based on the ""likelihood ratio"" lambda,; lambda = L(y;n) / L(m;n),; where L(y;n) is the likelihood of the fit result <y> describing the data <n>; and L(m;n) is the likelihood of an unknown ""true"" underlying distribution; <m> describing the data <n>. Since <m> is unknown, the data distribution is; used instead,; lambda = L(y;n) / L(n;n).; Note that this ratio is 1 if the fit is perfect. The chi2 value is then; computed according to; chi2 = -2*ln(lambda).; This parameter can be shown to follow a Chi-square distribution. See for; example S. Baker and R. Cousins, ""Clarification of the use of chi-square; and likelihood functions in fits to histograms"", Nucl. Instr. Meth. A221,; pp. 437-442 (1984). Int_t GetNDF() const; return the number of degrees of freedom in the fit; the fNDF parameter has been previously computed during a fit.; The number of degrees of freedom corresponds to the number of points; used in the fit minus the number of templates. Double_t GetProb() const; return the fit probability. void ComputeChisquareLambda(); Method used internally to compute the likelihood ratio chi2; See the function GetChisquare() for details. TH1* GetMCPrediction(Int_t parm) const; Return the adjusted MC template (Aji) for template (parm).; Note that the (Aji) times fractions only sum to the total prediction; of the fit if all weights are 1. » Last changed: root/hist:$Id$ » Last generated: 2015-03-13 19:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TFractionFitter.html:19691,predict,prediction,19691,root/html534/TFractionFitter.html,https://root.cern,https://root.cern/root/html534/TFractionFitter.html,1,['predict'],['prediction']
Safety,"); const. finalvirtual . Interface to cling function. ; Implements TInterpreter.; Definition at line 8085 of file TCling.cxx. ◆ CheckClassInfo(). TInterpreter::ECheckClassInfo TCling::CheckClassInfo ; (; const char * ; name, . Bool_t ; autoload, . Bool_t ; isClassOrNamespaceOnly = kFALSE . ). finalvirtual . Checks if an entity with the specified name is defined in Cling. ; Returns kUnknown if the entity is not defined. Returns kWithClassDefInline if the entity exists and has a ClassDefInline Returns kKnown if the entity is defined.; By default, structs, namespaces, classes, enums and unions are looked for. If the flag isClassOrNamespaceOnly is true, classes, structs and namespaces only are considered. I.e. if the name is an enum or a union, the returned value is false.; In the case where the class is not loaded and belongs to a namespace or is nested, looking for the full class name is outputting a lots of (expected) error messages. Currently the only way to avoid this is to specifically check that each level of nesting is already loaded. In case of templates the idea is that everything between the outer '<' and '>' has to be skipped, e.g.: aap<pippo<noot>::klaas>::a_class ; Implements TInterpreter.; Definition at line 4177 of file TCling.cxx. ◆ CheckClassTemplate(). Bool_t TCling::CheckClassTemplate ; (; const char * ; name). finalvirtual . Return true if there is a class template by the given name ... ; Implements TInterpreter.; Definition at line 4349 of file TCling.cxx. ◆ ClassInfo_ClassProperty(). Long_t TCling::ClassInfo_ClassProperty ; (; ClassInfo_t * ; info); const. finalvirtual . Reimplemented from TInterpreter.; Definition at line 8176 of file TCling.cxx. ◆ ClassInfo_Contains(). Bool_t TCling::ClassInfo_Contains ; (; ClassInfo_t * ; info, . DeclId_t ; declid . ); const. finalvirtual . Return true if the entity pointed to by 'declid' is declared in the context described by 'info'. ; If info is null, look into the global scope (translation unit scope). ; Im",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTCling.html:67352,avoid,avoid,67352,doc/master/classTCling.html,https://root.cern,https://root.cern/doc/master/classTCling.html,1,['avoid'],['avoid']
Safety,"); hh_model_3 = model_3.createHistogram(""hh_model_3"", x, Binning=50, YVar=dict(var=y, Binning=50)); hh_model_4 = model_4.createHistogram(""hh_model_4"", x, Binning=50, YVar=dict(var=y, Binning=50)); hh_model_1.SetLineColor(ROOT.kBlue); hh_model_2.SetLineColor(ROOT.kBlue); hh_model_3.SetLineColor(ROOT.kBlue); hh_model_4.SetLineColor(ROOT.kBlue); ; # Make canvas and draw ROOT.RooPlots; c = ROOT.TCanvas(""rf302_utilfuncs"", ""rf302_utilfuncs"", 800, 800); c.Divide(2, 2); c.cd(1); ROOT.gPad.SetLeftMargin(0.20); hh_model_1.GetZaxis().SetTitleOffset(2.5); hh_model_1.Draw(""surf""); c.cd(2); ROOT.gPad.SetLeftMargin(0.20); hh_model_2.GetZaxis().SetTitleOffset(2.5); hh_model_2.Draw(""surf""); c.cd(3); ROOT.gPad.SetLeftMargin(0.20); hh_model_3.GetZaxis().SetTitleOffset(2.5); hh_model_3.Draw(""surf""); c.cd(4); ROOT.gPad.SetLeftMargin(0.20); hh_model_4.GetZaxis().SetTitleOffset(2.5); hh_model_4.Draw(""surf""); ; c.SaveAs(""rf302_utilfuncs.png""); [#0] WARNING:InputArguments -- The parameter 'sigma' with range [-inf, inf] of the RooGaussian 'model_1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma' with range [-inf, inf] of the RooGaussian 'model_2' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma' with range [-inf, inf] of the RooGaussian 'model_3' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma' with range [-inf, inf] of the RooGaussian 'model_4' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_1_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_2_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_3_Int[x,y]) using numeric integrator RooIntegrator1D to calcula",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf302__utilfuncs_8py.html:3408,safe,safe,3408,doc/master/rf302__utilfuncs_8py.html,https://root.cern,https://root.cern/doc/master/rf302__utilfuncs_8py.html,1,['safe'],['safe']
Safety,"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); static voidComputeNormalS(Double_t* point, Double_t* dir, Double_t* norm, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t c1, Double_t s1, Double_t c2, Double_t s2); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistFromInsideS(Double_t* point, Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistFromOutsideS(Double_t* point, Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); static voidTGeoCone::DistToCone(Double_t* point, Double_t* dir, Double_t dz, Double_t r1, Double_t r2, Double_t& b, Double_t& delta); static Double_tDistToCons(Double_t* point, Double_t* dir, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Double_t phi1, Double_t phi2); static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Doub",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoConeSeg.html:2374,safe,safe,2374,root/html528/TGeoConeSeg.html,https://root.cern,https://root.cern/root/html528/TGeoConeSeg.html,2,['safe'],['safe']
Safety,"); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoBBox&operator=(const TGeoBBox&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidSetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetPoints(Double_t* points)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoBBox.html:9989,safe,safe,9989,root/html602/TGeoBBox.html,https://root.cern,https://root.cern/root/html602/TGeoBBox.html,2,['safe'],['safe']
Safety,"); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoCone&operator=(const TGeoCone&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tSafetyS(const Double_t* point, Bool_t in, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Int_t skipz = 0); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; voidSetConeDimensions(Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTOb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoCone.html:9014,safe,safe,9014,root/html602/TGeoCone.html,https://root.cern,https://root.cern/root/html602/TGeoCone.html,2,['safe'],['safe']
Safety,"); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoCtub&operator=(const TGeoCtub&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoTubeSeg::SafetyS(const Double_t* point, Bool_t in, Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2, Int_t skipz = 0); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; voidSetCtubDimensions(Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2, Double_t lx, Double_t ly, Double_t lz, Double_t tx, Double_t ty, Double_t tz); virtual voidSetDimensions(Double_t* par",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoCtub.html:9839,safe,safe,9839,root/html602/TGeoCtub.html,https://root.cern,https://root.cern/root/html602/TGeoCtub.html,2,['safe'],['safe']
Safety,"); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoEltu&operator=(const TGeoEltu&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoTube::SafetyS(const Double_t* point, Bool_t in, Double_t rmin, Double_t rmax, Double_t dz, Int_t skipz = 0); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetEltuDimensions(Double_t a, Double_t b, Double_t dz); voidTGeoShape::SetId(Int_t id); vi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoEltu.html:8857,safe,safe,8857,root/html602/TGeoEltu.html,https://root.cern,https://root.cern/root/html602/TGeoEltu.html,2,['safe'],['safe']
Safety,"); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoGtra&operator=(const TGeoGtra&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); Double_tTGeoArb8::SafetyToFace(const Double_t* point, Int_t iseg, Bool_t in) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoArb8::SetDz(Double_t dz); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoGtra.html:10017,safe,safe,10017,root/html602/TGeoGtra.html,https://root.cern,https://root.cern/root/html602/TGeoGtra.html,2,['safe'],['safe']
Safety,"); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoPara&operator=(const TGeoPara&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetPoin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoPara.html:8508,safe,safe,8508,root/html602/TGeoPara.html,https://root.cern,https://root.cern/root/html602/TGeoPara.html,2,['safe'],['safe']
Safety,"); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoTrap&operator=(const TGeoTrap&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); Double_tTGeoArb8::SafetyToFace(const Double_t* point, Int_t iseg, Bool_t in) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoArb8::SetDz(Double_t dz); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoTrap.html:9876,safe,safe,9876,root/html602/TGeoTrap.html,https://root.cern,https://root.cern/root/html602/TGeoTrap.html,2,['safe'],['safe']
Safety,"); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoTrd1&operator=(const TGeoTrd1&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetPoin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoTrd1.html:8469,safe,safe,8469,root/html602/TGeoTrd1.html,https://root.cern,https://root.cern/root/html602/TGeoTrd1.html,2,['safe'],['safe']
Safety,"); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoTrd2&operator=(const TGeoTrd2&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetPoin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoTrd2.html:8505,safe,safe,8505,root/html602/TGeoTrd2.html,https://root.cern,https://root.cern/root/html602/TGeoTrd2.html,2,['safe'],['safe']
Safety,"); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoTube&operator=(const TGeoTube&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tSafetyS(const Double_t* point, Bool_t in, Double_t rmin, Double_t rmax, Double_t dz, Int_t skipz = 0); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoTube.html:9311,safe,safe,9311,root/html602/TGeoTube.html,https://root.cern,https://root.cern/root/html602/TGeoTube.html,2,['safe'],['safe']
Safety,"); virtual intRecvBuf(int sock, void* buffer, int length); virtual intRecvRaw(int sock, void* buffer, int length, int flag); virtual Int_tRedirectOutput(const char* name, const char* mode = ""a"", RedirectHandle_t* h = 0); virtual TFileHandler*RemoveFileHandler(TFileHandler* fh); voidTSystem::RemoveOnExit(TObject* obj); virtual TSignalHandler*RemoveSignalHandler(TSignalHandler* sh); virtual TStdExceptionHandler*TSystem::RemoveStdExceptionHandler(TStdExceptionHandler* eh); virtual TTimer*RemoveTimer(TTimer* ti); virtual intRename(const char* from, const char* to); voidTObject::ResetBit(UInt_t f); static voidTSystem::ResetErrno(); virtual voidResetSignal(ESignals sig, Bool_t reset = kTRUE); virtual voidResetTimer(TTimer* ti); virtual voidTSystem::Run(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); virtual Int_tSelect(TList* active, Long_t timeout); virtual Int_tSelect(TFileHandler* fh, Long_t timeout); virtual intSendBuf(int sock, const void* buffer, int length); virtual intSendRaw(int sock, const void* buffer, int length, int flag); virtual voidTSystem::SetAclicMode(TSystem::EAclicMode mode); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTSystem::SetBuildDir(const char* build_dir, Bool_t isflat = kFALSE); virtual voidSetDisplay(); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetDynamicPath(const char* lib); virtual voidSetenv(const char* name, const char* value); voidTSystem::SetErrorStr(const char* errstr); virtual voidTSystem::SetFlagsDebug(const char*); virtual voidTSystem::SetFlagsOpt(const char*); virtual Int_tSetFPEMask(Int_t mask = kDefaultMask); virtual voidTSystem::SetIncludePath(const char* includePath); virtual voidTSystem::SetLinkdefSuffix(const char* suffix); virtual voidTSystem::SetLinkedLibs(con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TUnixSystem.html:10900,timeout,timeout,10900,root/html528/TUnixSystem.html,https://root.cern,https://root.cern/root/html528/TUnixSystem.html,1,['timeout'],['timeout']
Safety,"); virtual voidShowMembers(TMemberInspector& insp); RooAbsCollection*RooAbsCollection::snapshot(Bool_t deepCopy = kTRUE) const; Bool_tRooAbsCollection::snapshot(RooAbsCollection& output, Bool_t deepCopy = kTRUE) const; voidsort(Bool_t reverse = kFALSE); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; voidRooAbsCollection::takeOwnership(); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidwriteToStream(ostream& os, Bool_t compact). protected:. Bool_tRooAbsCollection::addServerClonesToList(const RooAbsArg& var); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); voidRooAbsCollection::safeDeleteList(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. Bool_tRooAbsCollection::_allRRVAll contents are RRV; RooLinkedListRooAbsCollection::_listActual object store; TStringRooAbsCollection::_nameOur name.; static Int_tRooPrintable::_nameLength; Bool_tRooAbsCollection::_ownContFlag to identify a list that owns its contents. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooArgList(); Def",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooArgList.html:11922,safe,safeDeleteList,11922,root/html532/RooArgList.html,https://root.cern,https://root.cern/root/html532/RooArgList.html,1,['safe'],['safeDeleteList']
Safety,"); virtual voidShowMembers(TMemberInspector& insp); RooAbsCollection*RooAbsCollection::snapshot(Bool_t deepCopy = kTRUE) const; Bool_tRooAbsCollection::snapshot(RooAbsCollection& output, Bool_t deepCopy = kTRUE) const; voidsort(Bool_t reverse = kFALSE); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; voidRooAbsCollection::takeOwnership(); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidwriteToStream(ostream& os, Bool_t compact). protected:. Bool_tRooAbsCollection::addServerClonesToList(const RooAbsArg& var); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); voidRooAbsCollection::safeDeleteList(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. RooLinkedListRooAbsCollection::_listActual object store; TStringRooAbsCollection::_nameOur name.; static Int_tRooPrintable::_nameLength; Bool_tRooAbsCollection::_ownContFlag to identify a list that owns its contents. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooArgList(); Default constructor. RooArgList(const RooArgSet& set); C",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooArgList.html:11860,safe,safeDeleteList,11860,root/html530/RooArgList.html,https://root.cern,https://root.cern/root/html530/RooArgList.html,1,['safe'],['safeDeleteList']
Safety,"); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); static voidTGeoTube::ComputeNormalS(Double_t* point, Double_t* dir, Double_t* norm, Double_t rmin, Double_t rmax, Double_t dz); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoTube::DistFromInsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoTube::DistFromOutsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); Int_tDistToHype(Double_t* point, Double_t* dir, Double_t* s, Bool_t inner) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); static voidTGeoTube::DistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoHype.html:2926,safe,safe,2926,root/html528/TGeoHype.html,https://root.cern,https://root.cern/root/html528/TGeoHype.html,1,['safe'],['safe']
Safety,"); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); static voidTGeoTube::ComputeNormalS(Double_t* point, Double_t* dir, Double_t* norm, Double_t rmin, Double_t rmax, Double_t dz); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoTube::DistFromInsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoTube::DistFromOutsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); static voidTGeoTube::DistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoEltu.html:1946,safe,safe,1946,root/html528/TGeoEltu.html,https://root.cern,https://root.cern/root/html528/TGeoEltu.html,1,['safe'],['safe']
Safety,"); virtual voidTProofPlayer::RemoveQueryResult(const char* ref); voidTObject::ResetBit(UInt_t f); virtual voidTProofPlayer::RestorePreviousQuery(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTProofPlayer::SetCurrentQuery(TQueryResult* q); virtual voidTProofPlayer::SetDispatchTimer(Bool_t on = kTRUE); virtual voidTProofPlayer::SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTProofPlayerRemote::SetInitTime(); virtual voidTProofPlayer::SetMaxDrawQueries(Int_t max); static voidTObject::SetObjectStat(Bool_t stat); voidTProofPlayer::SetProcessing(Bool_t on = kTRUE); virtual voidTProofPlayer::SetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidTProofPlayerRemote::StopProcess(Bool_t abort, Int_t timeout = -1); virtual voidTProofPlayerRemote::StoreFeedback(TObject* slave, TList* out); virtual voidTProofPlayerRemote::StoreOutput(TList* out); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTProofPlayer::UpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t buf",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofPlayerSuperMaster.html:10951,abort,abort,10951,root/html528/TProofPlayerSuperMaster.html,https://root.cern,https://root.cern/root/html528/TProofPlayerSuperMaster.html,1,['abort'],['abort']
Safety,"); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTFile::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTDirectoryFile::Purge(Short_t nkeep = 1); virtual voidTDirectory::pwd() const; virtual Int_tTObject::Read(const char* name); virtual voidTDirectoryFile::ReadAll(Option_t* option = """"); virtual Bool_tReadBuffer(char* buf, Int_t len); virtual Bool_tReadBuffer(char* buf, Long64_t pos, Int_t len); virtual Bool_tTFile::ReadBufferAsync(Long64_t offs, Int_t len); virtual Bool_tReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); virtual voidTFile::ReadFree(); virtual Int_tTDirectoryFile::ReadKeys(Bool_t forceRead = kTRUE); virtual TProcessID*TFile::ReadProcessID(UShort_t pidf); virtual voidTFile::ReadStreamerInfo(); virtual Int_tTDirectoryFile::ReadTObject(TObject* obj, const char* keyname); virtual Int_tTFile::Recover(); virtual voidTDirectory::RecursiveRemove(TObject* obj); virtual TObject*TDirectory::Remove(TObject*); virtual Int_tReOpen(Option_t* mode); virtual voidTDirectoryFile::ResetAfterMerge(TFileMergeInfo*); voidTObject::ResetBit(UInt_t f); virtual voidTFile::ResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidSeek(Long64_t offset, TFile::ERelativeTo pos = kBeg); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tTFile::SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRU",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TNetFile.html:12615,Recover,Recover,12615,root/html532/TNetFile.html,https://root.cern,https://root.cern/root/html532/TNetFile.html,4,['Recover'],['Recover']
Safety,"); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTFile::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTDirectoryFile::Purge(Short_t nkeep = 1); virtual voidTDirectory::pwd() const; virtual Int_tTObject::Read(const char* name); virtual voidTDirectoryFile::ReadAll(Option_t* option = """"); virtual Bool_tReadBuffer(char* buf, Int_t len); virtual Bool_tReadBuffer(char* buf, Long64_t pos, Int_t len); virtual Bool_tTFile::ReadBufferAsync(Long64_t offs, Int_t len); virtual Bool_tReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); virtual voidTFile::ReadFree(); virtual Int_tTDirectoryFile::ReadKeys(Bool_t forceRead = kTRUE); virtual TProcessID*TFile::ReadProcessID(UShort_t pidf); virtual voidTFile::ReadStreamerInfo(); virtual Int_tTDirectoryFile::ReadTObject(TObject* obj, const char* keyname); virtual Int_tTFile::Recover(); virtual voidTDirectory::RecursiveRemove(TObject* obj); virtual TObject*TDirectory::Remove(TObject*); virtual Int_tReOpen(Option_t* mode); voidTObject::ResetBit(UInt_t f); virtual voidTFile::ResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidSeek(Long64_t offset, TFile::ERelativeTo pos = kBeg); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tTFile::SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFAL",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TNetFile.html:12199,Recover,Recover,12199,root/html528/TNetFile.html,https://root.cern,https://root.cern/root/html528/TNetFile.html,1,['Recover'],['Recover']
Safety,"); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTFile::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTDirectoryFile::Purge(Short_t nkeep = 1); virtual voidTDirectory::pwd() const; virtual Int_tTObject::Read(const char* name); virtual voidTDirectoryFile::ReadAll(Option_t* option = """"); virtual Bool_tReadBuffer(char* buf, Int_t len); virtual Bool_tReadBuffer(char* buf, Long64_t pos, Int_t len); virtual Bool_tTFile::ReadBufferAsync(Long64_t offs, Int_t len); virtual Bool_tReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); virtual voidTFile::ReadFree(); virtual Int_tTDirectoryFile::ReadKeys(Bool_t forceRead = kTRUE); virtual TProcessID*TFile::ReadProcessID(UShort_t pidf); virtual voidTFile::ReadStreamerInfo(); virtual Int_tTDirectoryFile::ReadTObject(TObject* obj, const char* keyname); virtual Int_tTFile::Recover(); virtual voidTDirectory::RecursiveRemove(TObject* obj); virtual TObject*TDirectory::Remove(TObject*); virtual Int_tReOpen(Option_t* mode); voidTObject::ResetBit(UInt_t f); virtual voidTFile::ResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidSeek(Long64_t offset, TFile::ERelativeTo pos = kBeg); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tTFile::SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); virtual voidTFile::SetCach",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TNetFile.html:12388,Recover,Recover,12388,root/html530/TNetFile.html,https://root.cern,https://root.cern/root/html530/TNetFile.html,1,['Recover'],['Recover']
Safety,"); voidAddExpData(Double_t* sigExp, Double_t* bkgExp, Double_t* db, Int_t nbins, RooWorkspace* ws, const char* dsName = ""ExpectedNumberCountingData""); voidAddExpDataWithSideband(Double_t* sigExp, Double_t* bkgExp, Double_t* tau, Int_t nbins, RooWorkspace* ws, const char* dsName = ""NumberCountingData""); voidAddModel(Double_t* sigExp, Int_t nchan, RooWorkspace* ws, const char* pdfName = ""CombinedPdf"", const char* masterSignalName = ""masterSignal""); static TClass*Class(); virtual TClass*IsA() const; RooStats::NumberCountingPdfFactoryNumberCountingPdfFactory(); RooStats::NumberCountingPdfFactoryNumberCountingPdfFactory(const RooStats::NumberCountingPdfFactory&); RooStats::NumberCountingPdfFactory&operator=(const RooStats::NumberCountingPdfFactory&); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). private:. RooRealVar*SafeObservableCreation(RooWorkspace* ws, const char* varName, Double_t value); RooRealVar*SafeObservableCreation(RooWorkspace* ws, const char* varName, Double_t value, Double_t maximum). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; NumberCountingPdfFactory(); constructor. ~NumberCountingPdfFactory(); destructor. void AddModel(Double_t* sigExp, Int_t nchan, RooWorkspace* ws, const char* pdfName = ""CombinedPdf"", const char* masterSignalName = ""masterSignal""); This method produces a PDF for N channels with uncorrelated background; uncertainty. It relates the signal in each channel to a master signal strength times the; expected signal in each channel. For the future, perhaps this method should be extended to include the efficiency terms automatically. void AddExpData(Double_t* sigExp, Double_t* bkgExp, Double_t* db, Int_t nbins, RooWorkspace* ws, const char* dsName = ""ExpectedNumberCountingData""); Arguements are an array of expected signal, expected background, and relative; background uncertainty (eg. 0.1 for 10% uncertainty), ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStats__NumberCountingPdfFactory.html:2499,Safe,SafeObservableCreation,2499,root/html534/RooStats__NumberCountingPdfFactory.html,https://root.cern,https://root.cern/root/html534/RooStats__NumberCountingPdfFactory.html,2,['Safe'],['SafeObservableCreation']
Safety,");. TGeoEltu Class. 18.3.2.11 Hyperboloids - TGeoHype Class; A hyperboloid is represented as a solid limited by two planes perpendicular to the Z axis (top and bottom planes) and two hyperbolic surfaces of revolution about Z axis (inner and outer surfaces). The class describing hyperboloids is TGeoHype has 5 input parameters:; TGeoHype(Double_t rin,Double_t stin,Double_t rout,; Double_t stout,Double_t dz);. TGeoHype Class. The hyperbolic surface equation is taken in the form:; r2 - z2tan2() = r2min. r,z: cylindrical coordinates for a point on the surface; : stereo angle between the hyperbola asymptotic lines and Z axis; r2min: minimum distance between hyperbola and Z axis (at z=0). The input parameters represent:. rin, stin: minimum radius and tangent of stereo angle for inner surface; rout, stout: minimum radius and tangent of stereo angle for outer surface; dz: half length in Z (bounding planes positions at +/-dz). The following conditions are mandatory in order to avoid intersections between the inner and outer hyperbolic surfaces in the range +/-dz:. rin<rout; rout>0; rin2 + dz2*stin2 > rout2 + dz2*stout2. Particular cases:. rin=0, stin0: the inner surface is conical; stin=0 / stout=0: cylindrical surface(s). 18.3.2.12 Cones - TGeoCone Class; The cones are defined by 5 parameters:; TGeoCone(Double_t dz,Double_t rmin1,Double_t rmax1,; Double_t rmin2,Double_t rmax2);. rmin1: internal radius at Z is -dz; rmax1: external radius at Z is -dz; rmin2: internal radius at Z is +dz; rmax2: external radius at Z is +dz; dz: half length in Z (a cone ranges from -dz to +dz). A cone has Z-axis as its symmetry axis. TGeoCone Class. 18.3.2.13 Cone Segments - TGeoConeSeg Class; A cone segment is a cone having a range in phi. The cone segment class derives from TGeoCone, having two extra parameters: phi1 and phi2.; TGeoConeSeg(Double_t dz,Double_t rmin1,Double_t rmax1,; Double_t rmin2,Double_t rmax2,Double_t phi1,Double_t phi2);; Parametersphi1 and phi2 have the same meaning and co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:907214,avoid,avoid,907214,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['avoid'],['avoid']
Safety,");; 166 /// Report that this vector is already at maximum capacity. Throws; 167 /// std::length_error or calls report_fatal_error.; 168 static void report_at_maximum_capacity();; 169 ; 170 /// If false, the RVec is in ""memory adoption"" mode, i.e. it is acting as a view on a memory buffer it does not own.; 171 bool Owns() const { return fCapacity != -1; }; 172 ; 173public:; 174 size_t size() const { return fSize; }; 175 size_t capacity() const noexcept { return Owns() ? fCapacity : fSize; }; 176 ; 177 R__RVEC_NODISCARD bool empty() const { return !fSize; }; 178 ; 179 /// Set the array size to \p N, which the current array must have enough; 180 /// capacity for.; 181 ///; 182 /// This does not construct or destroy any elements in the vector.; 183 ///; 184 /// Clients can use this in conjunction with capacity() to write past the end; 185 /// of the buffer when they know that more elements are available, and only; 186 /// update the size later. This avoids the cost of value initializing elements; 187 /// which will only be overwritten.; 188 void set_size(size_t N); 189 {; 190 if (N > capacity()) {; 191 throw std::runtime_error(""Setting size to a value greater than capacity."");; 192 }; 193 fSize = N;; 194 }; 195};; 196 ; 197/// Used to figure out the offset of the first element of an RVec; 198template <class T>; 199struct SmallVectorAlignmentAndSize {; 200 alignas(SmallVectorBase) char Base[sizeof(SmallVectorBase)];; 201 alignas(T) char FirstEl[sizeof(T)];; 202};; 203 ; 204/// This is the part of SmallVectorTemplateBase which does not depend on whether the type T is a POD.; 205template <typename T>; 206class R__CLING_PTRCHECK(off) SmallVectorTemplateCommon : public SmallVectorBase {; 207 using Base = SmallVectorBase;; 208 ; 209 /// Find the address of the first element. For this pointer math to be valid; 210 /// with small-size of 0 for T with lots of alignment, it's important that; 211 /// SmallVectorStorage is properly-aligned even for small-size of 0.; 212 void *getFir",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RVec_8hxx_source.html:6162,avoid,avoids,6162,doc/master/RVec_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html,2,['avoid'],['avoids']
Safety,");; 291 /// TCanvas c(""c"",""x hist"");; 292 /// h.OnPartialResult(100, [&c](TH1D &h_) { c.cd(); h_.Draw(); c.Update(); });; 293 /// h->Draw(); // event loop runs here, this `Draw` is executed after the event loop is finished; 294 /// \endcode; 295 ///; 296 /// A value of 0 for everyNEvents indicates the callback must be executed only once, before running the event loop.; 297 /// A conveniece definition `kOnce` is provided to make this fact more expressive in user code (see snippet below).; 298 /// Multiple callbacks can be registered with the same RResultPtr (i.e. results of RDataFrame actions) and will; 299 /// be executed sequentially. Callbacks are executed in the order they were registered.; 300 /// The type of the value contained in a RResultPtr is also available as RResultPtr<T>::Value_t, e.g.; 301 /// \code{.cpp}; 302 /// auto h = tdf.Histo1D(""x"");; 303 /// // h.kOnce is 0; 304 /// // decltype(h)::Value_t is TH1D; 305 /// \endcode; 306 ///; 307 /// When implicit multi-threading is enabled, the callback:; 308 /// - will never be executed by multiple threads concurrently: it needs not be thread-safe. For example the snippet; 309 /// above that draws the partial histogram on a canvas works seamlessly in multi-thread event loops.; 310 /// - will always be executed ""everyNEvents"": partial results will ""contain"" that number of events more from; 311 /// one call to the next; 312 /// - might be executed by a different worker thread at different times: the value of `std::this_thread::get_id()`; 313 /// might change between calls; 314 ///; 315 /// To register a callback that is called by _each_ worker thread (concurrently) every N events one can use; 316 /// OnPartialResultSlot().; 317 // clang-format on; 318 RResultPtr<T> &OnPartialResult(ULong64_t everyNEvents, std::function<void(T &)> callback); 319 {; 320 ThrowIfNull();; 321 const auto nSlots = fLoopManager->GetNSlots();; 322 auto actionPtr = fActionPtr;; 323 auto c = [nSlots, actionPtr, callback](unsigned int slot) ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RResultPtr_8hxx_source.html:13218,safe,safe,13218,doc/master/RResultPtr_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RResultPtr_8hxx_source.html,1,['safe'],['safe']
Safety,");; 514 }; 515 // TSeqCollection *brlist = gROOT->GetListOfBrowsers();; 516 // TIter next(brlist);; 517 // TBrowser *browser = 0;; 518 // while ((browser=(TBrowser*)next())) browser->RecursiveRemove(this);; 519 ClearThreadsMap();; 520 ClearThreadData();; 521 delete TGeoBuilder::Instance(this);; 522 if (fBits); 523 delete[] fBits;; 524 SafeDelete(fNodes);; 525 SafeDelete(fTopNode);; 526 if (fOverlaps) {; 527 fOverlaps->Delete();; 528 SafeDelete(fOverlaps);; 529 }; 530 if (fRegions) {; 531 fRegions->Delete();; 532 SafeDelete(fRegions);; 533 }; 534 if (fMaterials) {; 535 fMaterials->Delete();; 536 SafeDelete(fMaterials);; 537 }; 538 SafeDelete(fElementTable);; 539 if (fMedia) {; 540 fMedia->Delete();; 541 SafeDelete(fMedia);; 542 }; 543 if (fHashVolumes) {; 544 fHashVolumes->Clear(""nodelete"");; 545 SafeDelete(fHashVolumes);; 546 }; 547 if (fHashGVolumes) {; 548 fHashGVolumes->Clear(""nodelete"");; 549 SafeDelete(fHashGVolumes);; 550 }; 551 if (fHashPNE) {; 552 fHashPNE->Delete();; 553 SafeDelete(fHashPNE);; 554 }; 555 if (fArrayPNE) {; 556 delete fArrayPNE;; 557 }; 558 if (fVolumes) {; 559 fVolumes->Delete();; 560 SafeDelete(fVolumes);; 561 }; 562 if (fShapes) {; 563 fShapes->Delete();; 564 SafeDelete(fShapes);; 565 }; 566 if (fPhysicalNodes) {; 567 fPhysicalNodes->Delete();; 568 SafeDelete(fPhysicalNodes);; 569 }; 570 if (fMatrices) {; 571 fMatrices->Delete();; 572 SafeDelete(fMatrices);; 573 }; 574 if (fTracks) {; 575 fTracks->Delete();; 576 SafeDelete(fTracks);; 577 }; 578 SafeDelete(fUniqueVolumes);; 579 if (fPdgNames) {; 580 fPdgNames->Delete();; 581 SafeDelete(fPdgNames);; 582 }; 583 if (fGDMLMatrices) {; 584 fGDMLMatrices->Delete();; 585 SafeDelete(fGDMLMatrices);; 586 }; 587 if (fOpticalSurfaces) {; 588 fOpticalSurfaces->Delete();; 589 SafeDelete(fOpticalSurfaces);; 590 }; 591 if (fSkinSurfaces) {; 592 fSkinSurfaces->Delete();; 593 SafeDelete(fSkinSurfaces);; 594 }; 595 if (fBorderSurfaces) {; 596 fBorderSurfaces->Delete();; 597 SafeDelete(fBorderSurfaces);; 598 }",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoManager_8cxx_source.html:22096,Safe,SafeDelete,22096,doc/master/TGeoManager_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html,1,['Safe'],['SafeDelete']
Safety,")` : return the sum of the value of the elements of the; 4217/// formula given as a parameter. For example the mean for all the elements in; 4218/// one entry can be calculated with: `Sum$(formula )/Length$(formula )`; 4219/// - `Min$(formula )` : return the minimum (within one TTree entry) of the value of the; 4220/// elements of the formula given as a parameter.; 4221/// - `Max$(formula )` : return the maximum (within one TTree entry) of the value of the; 4222/// elements of the formula given as a parameter.; 4223/// - `MinIf$(formula,condition)`; 4224/// - `MaxIf$(formula,condition)` : return the minimum (maximum) (within one TTree entry); 4225/// of the value of the elements of the formula given as a parameter; 4226/// if they match the condition. If no element matches the condition,; 4227/// the result is zero. To avoid the resulting peak at zero, use the; 4228/// pattern:; 4229/// ~~~ {.cpp}; 4230/// tree->Draw(""MinIf$(formula,condition)"",""condition"");; 4231/// ~~~; 4232/// which will avoid calculation `MinIf$` for the entries that have no match; 4233/// for the condition.; 4234/// - `Alt$(primary,alternate)` : return the value of ""primary"" if it is available; 4235/// for the current iteration otherwise return the value of ""alternate"".; 4236/// For example, with arr1[3] and arr2[2]; 4237/// ~~~ {.cpp}; 4238/// tree->Draw(""arr1+Alt$(arr2,0)"");; 4239/// ~~~; 4240/// will draw arr1[0]+arr2[0] ; arr1[1]+arr2[1] and arr1[2]+0; 4241/// Or with a variable size array arr3; 4242/// ~~~ {.cpp}; 4243/// tree->Draw(""Alt$(arr3[0],0)+Alt$(arr3[1],0)+Alt$(arr3[2],0)"");; 4244/// ~~~; 4245/// will draw the sum arr3 for the index 0 to min(2,actual_size_of_arr3-1); 4246/// As a comparison; 4247/// ~~~ {.cpp}; 4248/// tree->Draw(""arr3[0]+arr3[1]+arr3[2]"");; 4249/// ~~~; 4250/// will draw the sum arr3 for the index 0 to 2 only if the; 4251/// actual_size_of_arr3 is greater or equal to 3.; 4252/// Note that the array in 'primary' is flattened/linearized thus using; 4253/// `Alt$` wi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:170043,avoid,avoid,170043,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['avoid'],['avoid']
Safety,")b).PeekDataCache(),compinfo,i,i+1,narr,eoffset, arrayMode);; 159 }; 160 continue;; 161 } else {; 162 if (gDebug > 1) {; 163 printf(""WriteBuffer, class:%s, name=%s, fType[%d]=%d,""; 164 "" %s, bufpos=%d, arr=%p, eoffset=%d, not a write rule, skipping.\n"",; 165 fClass->GetName(),aElement->GetName(),i,compinfo[i]->fType,; 166 aElement->ClassName(),b.Length(),arr[0], eoffset);; 167 }; 168 // The rule was a cached element for a read, rule, the real offset is in the; 169 // next element (the one for the rule itself).; 170 if (aElement->TestBit(TStreamerElement::kRepeat)) continue;; 171 ioffset = eoffset+compinfo[i]->fOffset;; 172 continue;; 173 }; 174 }; 175 ; 176 if (gDebug > 1) {; 177 printf(""WriteBuffer, class:%s, name=%s, fType[%d]=%d, %s, ""; 178 ""bufpos=%d, arr=%p, offset=%d\n"",; 179 fClass->GetName(),aElement->GetName(),i,compinfo[i]->fType,aElement->ClassName(),; 180 b.Length(),arr[0],ioffset);; 181 }; 182 ; 183 switch (compinfo[i]->fType+typeOffset) {; 184 // In this switch we intentionally use 'continue' instead of; 185 // 'break' to avoid running the 2nd switch (see later in this; 186 // function).; 187 ; 188 case TStreamerInfo::kBool: WriteBasicType(Bool_t); continue;; 189 case TStreamerInfo::kChar: WriteBasicType(Char_t); continue;; 190 case TStreamerInfo::kShort: WriteBasicType(Short_t); continue;; 191 case TStreamerInfo::kInt: WriteBasicType(Int_t); continue;; 192 case TStreamerInfo::kLong: WriteBasicType(Long_t); continue;; 193 case TStreamerInfo::kLong64: WriteBasicType(Long64_t); continue;; 194 case TStreamerInfo::kFloat: WriteBasicType(Float_t); continue;; 195 case TStreamerInfo::kDouble: WriteBasicType(Double_t); continue;; 196 case TStreamerInfo::kUChar: WriteBasicType(UChar_t); continue;; 197 case TStreamerInfo::kUShort: WriteBasicType(UShort_t); continue;; 198 case TStreamerInfo::kUInt: WriteBasicType(UInt_t); continue;; 199 case TStreamerInfo::kULong: WriteBasicType(ULong_t); continue;; 200 case TStreamerInfo::kULong64: WriteBasicType(ULong64_t); con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfoWriteBuffer_8cxx_source.html:6251,avoid,avoid,6251,doc/master/TStreamerInfoWriteBuffer_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfoWriteBuffer_8cxx_source.html,1,['avoid'],['avoid']
Safety,")set window urlDefinition RWebDisplayArgs.hxx:128; ROOT::RWebDisplayHandle::Displaystatic std::unique_ptr< RWebDisplayHandle > Display(const RWebDisplayArgs &args)Create web display.Definition RWebDisplayHandle.cxx:757; . Definition at line 863 of file RWebDisplayHandle.cxx. ◆ FindCreator(). std::unique_ptr< RWebDisplayHandle::Creator > & RWebDisplayHandle::FindCreator ; (; const std::string & ; name, . const std::string & ; libname = """" . ). staticprotected . Search for specific browser creator If not found, try to add one. ; Parameters. name- creator name like ChromeCreator ; libname- shared library name where creator could be provided . Definition at line 71 of file RWebDisplayHandle.cxx. ◆ GetContent(). const std::string & ROOT::RWebDisplayHandle::GetContent ; (; ); const. inline . get content ; Definition at line 103 of file RWebDisplayHandle.hxx. ◆ GetImageFormat(). std::string RWebDisplayHandle::GetImageFormat ; (; const std::string & ; fname). static . Detect image format There is special handling of "".screenshot.pdf"" and "".screenshot.png"" extensions Creation of such files relies on headless browser functionality and fully supported only by Chrome browser. ; Definition at line 937 of file RWebDisplayHandle.cxx. ◆ GetMap(). std::map< std::string, std::unique_ptr< RWebDisplayHandle::Creator > > & RWebDisplayHandle::GetMap ; (; ). staticprotected . Static holder of registered creators of web displays. ; Definition at line 59 of file RWebDisplayHandle.cxx. ◆ GetUrl(). const std::string & ROOT::RWebDisplayHandle::GetUrl ; (; ); const. inline . returns url of start web display ; Definition at line 98 of file RWebDisplayHandle.hxx. ◆ NeedHttpServer(). bool RWebDisplayHandle::NeedHttpServer ; (; const RWebDisplayArgs & ; args). static . Check if http server required for display. ; Parameters. args- defines where and how to display web window . Definition at line 721 of file RWebDisplayHandle.cxx. ◆ ProduceImage(). bool RWebDisplayHandle::ProduceImage ; (; const std:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RWebDisplayHandle.html:7307,Detect,Detect,7307,doc/master/classROOT_1_1RWebDisplayHandle.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RWebDisplayHandle.html,1,['Detect'],['Detect']
Safety,"* 1/Norm_j ]; = sum_k [ ( delta_ik*delta_lk - delta_ik*A_lj - delta_lk*A_ij; + A_ij * A_lj ) * DB_kj / Norm_j^2 ]. introduce normalized errors: Rsq_kj = DB_kj / Norm_j^2; after summing over k:; delta_ik*delta_lk*Rsq_kj -> delta_il*Rsq_ij; delta_ik*A_lj*Rsq_kj -> A_lj*Rsq_ij; delta_lk*A_ij*Rsq_kj -> A_ij*Rsq_lj; A_ij*A_lj*Rsq_kj -> A_ij*A_lj*sum_k(Rsq_kj). introduce sum of normalized errors squared: SRsq_j = sum_k(Rsq_kj). Note: Rsq_ij is stored as fDAinRelSq (excludes extra indices of B); and SRsq_j is stored as fDAinColRelSq (sum includes all indices of B). Vxx_nm = sum_ijl [ (dX_m / dA_ij) * (dX_n / dA_lj); (delta_il*Rsq_ij - A_lj*Rsq_ij - A_ij*Rsq_lj + A_ij*A_lj *SRsq_j) ]. Vxx_nm = sum_j [ F_mj * F_nj * SRsq_j; - sum_j [ G_mj * F_nj ]; - sum_j [ F_mj * G_nj ]; + sum_ij [ (dX_m / dA_ij) * (dX_n / dA_lj) * Rsq_ij ]. where:; F_mj = sum_i [ (dX_m / dA_ij) * A_ij ]; G_mj = sum_i [ (dX_m / dA_ij) * Rsq_ij ]. In order to avoid explicitly calculating the 3-dimensional tensor; (dX_m/dA_ij) the sums are evaluated further, using; dX_k / dA_ij = M0_kj * Z0_i - M1_ki * Z1_j. F_mj = M0_mj * (A# Z0)_j - (M1 A)_mj Z1_j; G_mj = M0_mj * (Rsq# Z0)_j - (M1 Rsq)_mj Z1_j. and. sum_ij [ (dX_m/dA_ij) * (dX_n/dA_ij) * Rsq_ij ] =; sum_j [ M0_mj * M0_nj * [ sum_i (Z0_i)^2 * Rsq_ij ] ]; + sum_i [ M1_mi * M1_ni * [ sum_j (Z1_j)^2 * Rsq_ij ] ]; - sum_i [ M1_mi * H_ni + M1_ni * H_mi]; where:; H_mi = Z0_i * sum_j [ M0_mj * Z1_j * Rsq_ij ]. collect all contributions:; Vxx_nm = r0 -r1 -r2 +r3 +r4 -r5 -r6; r0 = sum_j [ F_mj * F_nj * SRsq_j ]; r1 = sum_j [ G_mj * F_nj ]; r2 = sum_j [ F_mj * G_nj ]; r3 = sum_j [ M0_mj * M0_nj * [ sum_i (Z0_i)^2 * Rsq_ij ] ]; r4 = sum_i [ M1_mi * M1_ni * [ sum_j (Z1_j)^2 * Rsq_ij ] ]; r5 = sum_i [ M1_mi * H_ni ]; r6 = sum_i [ M1_ni * H_mi ]. calculate contributions containing matrices F and G; r0,r1,r2. void SetTauError(Double_t delta_tau); set uncertainty on tau. void GetDeltaSysSource(TH1* hist_delta, const char* source, const Int_t* binMap = 0); calculate systemat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TUnfoldSys.html:23402,avoid,avoid,23402,root/html528/TUnfoldSys.html,https://root.cern,https://root.cern/root/html528/TUnfoldSys.html,3,['avoid'],['avoid']
Safety,"* Canvas(const TCanvas* canvas); static: return the TQtWidget backend for TCanvas *canvas object. TQtWidget * Canvas(Int_t id); static: return TQtWidget by TCanvas id. TApplication * InitRint(Bool_t prompt = kFALSE, const char* appClassName = ""QtRint"", int* argc = 0, char** argv = 0, void* options = 0, int numOptions = 0, Bool_t noLogo = kTRUE). Instantiate ROOT from within Qt application if needed; Return the TRint pointer; Most parametrs are passed to TRint class ctor. Bool_t prompt = kTRUE; Instantiate ROOT with ROOT command prompt; kFALSE; No ROOT prompt. The default for Qt GUI applications. The prompt option can be defined via ROOT parameter file "".rootrc""; .rootrc:; . . .; Gui.Prompt yes. void Erase(); Erases the entire widget and its double buffer. void cd(); [slot] to make this embedded canvas the current one. void cd(int subpadnumber); [slot] to make this embedded canvas / pad the current one. void Disconnect(); [slot] Disconnect the Qt widget from TCanvas object before deleting; to avoid the dead lock; one has to set CanvasID = 0 to disconnect things properly. void Refresh(); [slot] to allow Qt signal refreshing the ROOT TCanvas if needed; use the permanent single shot timer to eliminate; the redundand refreshing for the sake of the performance. void RefreshCB(); [slot] to allow Qt signal refreshing the ROOT TCanvas if needed. void SetCanvas(TCanvas* c); remember my host TCanvas and adopt its name. customEvent(QEvent* ); The custom response to the special WIN32 events; These events are not present with X11 systems. void contextMenuEvent(QContextMenuEvent* ); The custom response to the Qt QContextMenuEvent; Map QContextMenuEvent to the ROOT kButton3Down = 3 event. void focusInEvent(QFocusEvent* ); The custom response to the Qt QFocusEvent ""in""; this imposes an extra protection to avoid TObject interaction with; mouse event accidently. void focusOutEvent(QFocusEvent* ); The custom response to the Qt QFocusEvent ""out""; this imposes an extra protection to avoid",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TQtWidget.html:24933,avoid,avoid,24933,root/html602/TQtWidget.html,https://root.cern,https://root.cern/root/html602/TQtWidget.html,2,['avoid'],['avoid']
Safety,"* Canvas(const TCanvas* canvas); static: return the TQtWidget backend for TCanvas *canvas object. TQtWidget * Canvas(Int_t id); static: return TQtWidget by TCanvas id. TApplication * InitRint(Bool_t prompt = kFALSE, const char* appClassName = ""QtRint"", int* argc = 0, char** argv = 0, void* options = 0, int numOptions = 0, Bool_t noLogo = kTRUE). Instantiate ROOT from within Qt application if needed; Return the TRint pointer; Most parametrs are passed to TRint class ctor. Bool_t prompt = kTRUE; Instantiate ROOT with ROOT command prompt; kFALSE; No ROOT prompt. The default for Qt GUI applications. The prompt option can be defined via ROOT parameter file "".rootrc""; .rootrc:; . . .; Gui.Prompt yes. void Erase(); Erases the entire widget and its double buffer. void cd(); [slot] to make this embedded canvas the current one. void cd(int subpadnumber); [slot] to make this embedded canvas / pad the current one. void Disconnect(); [slot] Disconnect the Qt widget from TCanvas object before deleting; to avoid the dead lock; one has to set CanvasID = 0 to disconnect things properly. void Refresh(); [slot] to allow Qt signal refreshing the ROOT TCanvas if needed; use the permanent single shot timer to eliminate; the redundand refreshing for the sake of the performance. void SetCanvas(TCanvas* c); remember my host TCanvas and adopt its name. customEvent(QEvent* ); The custom response to the special WIN32 events; These events are not present with X11 systems. void contextMenuEvent(QContextMenuEvent* ); The custom response to the Qt QContextMenuEvent; Map QContextMenuEvent to the ROOT kButton3Down = 3 event. void focusInEvent(QFocusEvent* ); The custom response to the Qt QFocusEvent ""in""; this imposes an extra protection to avoid TObject interaction with; mouse event accidently. void focusOutEvent(QFocusEvent* ); The custom response to the Qt QFocusEvent ""out""; this imposes an extra protection to avoid TObject interaction with; mouse event accidently. void mousePressEvent(QMouseEvent",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQtWidget.html:8324,avoid,avoid,8324,root/html528/TQtWidget.html,https://root.cern,https://root.cern/root/html528/TQtWidget.html,3,['avoid'],['avoid']
Safety,"* buf, UInt_t len); static Int_tWriteChecksum(const char* file, const TMD5* md5). private:. voidDecode(UInt_t* out, const UChar_t* in, UInt_t len); voidEncode(UChar_t* out, const UInt_t* in, UInt_t len); voidTransform(UInt_t* buf, const UChar_t* in). Data Members; private:. UInt_tfBits[2]!temp buffer; UInt_tfBuf[4]!temp buffer; UChar_tfDigest[16]message digest; Bool_tfFinalizedtrue if message digest has been finalized; UChar_tfIn[64]!temp buffer; Char_tfString[33]!string representation of digest. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMD5(); Create TMD5 object. Set bit count to 0 and buffer to mysterious; initialization constants. TMD5(const UChar_t* digest); Create finalized TMD5 object containing passed in 16 byte digest. TMD5(const TMD5& md5); MD5 copy ctor. Special copy ctor avoids copying unnecessary; temp arrays when finalized. TMD5 & operator=(const TMD5& rhs); MD5 assignment operator. Special assignment operator avoids; copying unnecessary temp arrays when finalized. void Update(const UChar_t* buf, UInt_t len); Update TMD5 object to reflect the concatenation of another buffer full; of bytes. void Final(UChar_t* digest); MD5 finalization, ends an MD5 message-digest operation, writing the; the message digest and zeroizing the context.; Returns digest. void Final(); MD5 finalization, ends an MD5 message-digest operation, writing the; the message digest and zeroizing the context. void Print() const; Print digest in ascii hex form. const char * AsString() const; Return message digest as string. Returns """" in case Final() has; not yet been called. void Encode(UChar_t* out, const UInt_t* in, UInt_t len); Encodes input into output. Assumes len is a multiple of 4. void Decode(UInt_t* out, const UChar_t* in, UInt_t len); Decodes input into output. Assumes len is a multiple of 4. void Transform(UInt_t* buf, const UChar_t* in); The core of the MD5 algorithm, this alters an existing MD5 hash to; reflect the addition of",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMD5.html:2527,avoid,avoids,2527,root/html534/TMD5.html,https://root.cern,https://root.cern/root/html534/TMD5.html,1,['avoid'],['avoids']
Safety,"* method) const; static voidTGeoShape::NormalPhi(const Double_t* point, const Double_t* dir, Double_t* norm, Double_t c1, Double_t s1, Double_t c2, Double_t s2); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tTGeoBBox::Safety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidTGeoBBox::Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTGeoBBox::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidTGeoBBox::SetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetFromFaceSet(TGLFaceSet* fs); voidTGeoShape::SetId(Int",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEveGeoPolyShape.html:8623,Safe,Safety,8623,root/html602/TEveGeoPolyShape.html,https://root.cern,https://root.cern/root/html602/TEveGeoPolyShape.html,2,['Safe'],['Safety']
Safety,"* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tTGeoBBox::Safety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidTGeoBBox::Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTGeoBBox::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidTGeoBBox::SetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetFromFaceSet(TGLFaceSet* fs); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTGeoBBo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEveGeoPolyShape.html:8868,Safe,SafetyPhi,8868,root/html534/TEveGeoPolyShape.html,https://root.cern,https://root.cern/root/html534/TEveGeoPolyShape.html,1,['Safe'],['SafetyPhi']
Safety,"* motherDir) : TNamed(); 176{; 177 Build(motherDir, """", pointer);; 178 ; 179 fSeekKey = pointer;; 180 fNbytes = nbytes;; 181 fBuffer = new char[nbytes];; 182 keyAbsNumber++; SetUniqueID(keyAbsNumber);; 183}; 184 ; 185////////////////////////////////////////////////////////////////////////////////; 186/// Create a TKey object with the specified name, title for the given class.; 187///; 188/// WARNING: in name avoid special characters like '^','$','.' that are used; 189/// by the regular expression parser (see TRegexp).; 190 ; 191TKey::TKey(const char *name, const char *title, const TClass *cl, Int_t nbytes, TDirectory* motherDir); 192 : TNamed(name,title); 193{; 194 Build(motherDir, cl->GetName(), -1);; 195 ; 196 fKeylen = Sizeof();; 197 fObjlen = nbytes;; 198 Create(nbytes);; 199}; 200 ; 201////////////////////////////////////////////////////////////////////////////////; 202/// Create a TKey object with the specified name, title for the given class.; 203///; 204/// WARNING: in name avoid special characters like '^','$','.' that are used; 205/// by the regular expression parser (see TRegexp).; 206 ; 207TKey::TKey(const TString &name, const TString &title, const TClass *cl, Int_t nbytes, TDirectory* motherDir); 208 : TNamed(name,title); 209{; 210 Build(motherDir, cl->GetName(), -1);; 211 ; 212 fKeylen = Sizeof();; 213 fObjlen = nbytes;; 214 Create(nbytes);; 215}; 216 ; 217////////////////////////////////////////////////////////////////////////////////; 218/// Create a TKey object for a TObject* and fill output buffer; 219///; 220/// WARNING: in name avoid special characters like '^','$','.' that are used; 221/// by the regular expression parser (see TRegexp).; 222 ; 223TKey::TKey(const TObject *obj, const char *name, Int_t bufsize, TDirectory* motherDir); 224 : TNamed(name, obj->GetTitle()); 225{; 226 R__ASSERT(obj);; 227 ; 228 if (!obj->IsA()->HasDefaultConstructor()) {; 229 Warning(""TKey"", ""since %s has no public constructor\n""; 230 ""\twhich can be called without ar",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TKey_8cxx_source.html:7072,avoid,avoid,7072,doc/master/TKey_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TKey_8cxx_source.html,1,['avoid'],['avoid']
Safety,"* norm); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; Test if point is inside the torus.; check phi range. Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute closest distance from point px,py to each vertex. Double_t Daxis(const Double_t* pt, const Double_t* dir, Double_t t) const; Computes distance to axis of the torus from point pt + t*dir;. Double_t DDaxis(const Double_t* pt, const Double_t* dir, Double_t t) const; Computes derivative w.r.t. t of the distance to axis of the torus from point pt + t*dir;. Double_t DDDaxis(const Double_t* pt, const Double_t* dir, Double_t t) const; Second derivative of distance to torus axis w.r.t t. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the torus. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the torus. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this torus shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. const char * GetAxisName(Int_t iaxis) const; Returns name of axis IAXIS. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2, dZ. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; Create a shape fitting the mother. void InspectShape() const; print shape parameters. TBuffer3D * MakeBuffer3D() const; Creates a TBuffer3D describing *this* shape.; Coordinates are in local reference frame. void SetS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoTorus.html:14672,safe,safe,14672,root/html534/TGeoTorus.html,https://root.cern,https://root.cern/root/html534/TGeoTorus.html,3,['safe'],['safe']
Safety,"* option = """"); static Double_tBig(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidCheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tCouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidDraw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tEpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoShape.html:7798,safe,safe,7798,root/html532/TGeoShape.html,https://root.cern,https://root.cern/root/html532/TGeoShape.html,1,['safe'],['safe']
Safety,"* out); Register TFileCollections in 'out' as datasets according to the rules in 'in'. void HandleQueryList(TMessage* mess); Handle request for list of queries. void HandleRemove(TMessage* mess, TString* slb = 0); Handle remove request. void HandleRetrieve(TMessage* mess, TString* slb = 0); Handle retrieve request. void HandleLibIncPath(TMessage* mess); Handle lib, inc search paths modification request. void HandleCheckFile(TMessage* mess, TString* slb = 0); Handle file checking request. Int_t HandleCache(TMessage* mess, TString* slb = 0); Handle here all cache and package requests. Int_t HandleWorkerLists(TMessage* mess); Handle here all requests to modify worker lists. FILE * SetErrorHandlerFile(FILE* ferr); Set the file stream where to log (default stderr).; If ferr == 0 the default is restored.; Returns current setting. void ErrorHandler(Int_t level, Bool_t abort, const char* location, const char* msg); The PROOF error handler function. It prints the message on fgErrorHandlerFile and; if abort is set it aborts the application. Int_t CopyFromCache(const char* name, Bool_t cpbin); Retrieve any files related to 'macro' from the cache directory.; If 'cpbin' is true, the associated binaries are retrieved as well.; Returns 0 on success, -1 otherwise. Int_t CopyToCache(const char* name, Int_t opt = 0); Copy files related to 'macro' to the cache directory.; Action depends on 'opt':. opt = 0 copy 'macro' to cache and delete from cache any binary; related to name; e.g. if macro = bla.C, the binaries are; bla_C.so, bla_C.rootmap, ...; opt = 1 copy the binaries related to macro to the cache. Returns 0 on success, -1 otherwise. void MakePlayer(); Make player instance. void DeletePlayer(); Delete player instance. Int_t GetPriority(); Get the processing priority for the group the user belongs too. This; priority is a number (0 - 100) determined by a scheduler (third; party process) based on some basic priority the group has, e.g.; we might want to give users in a specific grou",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TProofServ.html:26988,abort,abort,26988,root/html532/TProofServ.html,https://root.cern,https://root.cern/root/html532/TProofServ.html,2,['abort'],"['abort', 'aborts']"
Safety,"* out); Register TFileCollections in 'out' as datasets according to the rules in 'in'. void HandleQueryList(TMessage* mess); Handle request for list of queries. void HandleRemove(TMessage* mess, TString* slb = 0); Handle remove request. void HandleRetrieve(TMessage* mess, TString* slb = 0); Handle retrieve request. void HandleLibIncPath(TMessage* mess); Handle lib, inc search paths modification request. void HandleCheckFile(TMessage* mess, TString* slb = 0); Handle file checking request. Int_t HandleCache(TMessage* mess, TString* slb = 0); Handle here all cache and package requests. Int_t HandleWorkerLists(TMessage* mess); Handle here all requests to modify worker lists. FILE * SetErrorHandlerFile(FILE* ferr); Set the file stream where to log (default stderr).; If ferr == 0 the default is restored.; Returns current setting. void ErrorHandler(Int_t level, Bool_t abort, const char* location, const char* msg); The PROOF error handler function. It prints the message on fgErrorHandlerFile and; if abort is set it aborts the application. Int_t CopyFromCache(const char* name, Bool_t cpbin); Retrieve any files related to 'macro' from the cache directory.; If 'cpbin' is true, the associated binaries are retrieved as well.; Returns 0 on success, -1 otherwise. Int_t CopyToCache(const char* name, Int_t opt = 0); Copy files related to 'macro' to the cache directory.; Action depends on 'opt':. opt = 0 copy 'macro' to cache and delete from cache any binary; related to name; e.g. if macro = bla.C, the binaries are; bla_C.so, bla_C.rootmap, ...; opt = 1 copy the binaries related to macro to the cache. Returns 0 on success, -1 otherwise. void MakePlayer(); Make player instance. void DeletePlayer(); Delete player instance. Int_t GetPriority(); Get the processing priority for the group the user belongs too. This; prioroty is a number (0 - 100) determined by a scheduler (third; party process) based on some basic priority the group has, e.g.; we might want to give users in a specific grou",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProofServ.html:26988,abort,abort,26988,root/html530/TProofServ.html,https://root.cern,https://root.cern/root/html530/TProofServ.html,2,['abort'],"['abort', 'aborts']"
Safety,"* point, Double_t* dir, Double_t* norm); static voidTGeoTubeSeg::ComputeNormalS(Double_t* point, Double_t* dir, Double_t* norm, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoTubeSeg::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoTubeSeg::DistFromInsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoTubeSeg::DistFromOutsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); static voidTGeoTube::DistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoCtub.html:3041,safe,safe,3041,root/html528/TGeoCtub.html,https://root.cern,https://root.cern/root/html528/TGeoCtub.html,3,['safe'],['safe']
Safety,"* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoHype&operator=(const TGeoHype&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; Double_tRadiusHypeSq(Double_t z, Bool_t inner) const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoTube::SafetyS(const Double_t* point, Bool_t in, Double_t rmin, Double_t rmax, Double_t dz, Int_t skipz = 0); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); Double_tSafetyToHype(const Double_t* point, Bool_t inner, Bool_t in) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetHypeDimensions(Double_t rin, Double_t stin, Double_t rout, Double_t stout, Double_t dz); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoHype.html:10063,Safe,SafetyS,10063,root/html602/TGeoHype.html,https://root.cern,https://root.cern/root/html602/TGeoHype.html,2,['Safe'],['SafetyS']
Safety,"*******************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#ifndef ROOT_TTimer; 13#define ROOT_TTimer; 14 ; 15 ; 16//////////////////////////////////////////////////////////////////////////; 17// //; 18// TTimer //; 19// //; 20// Handles synchronous and a-synchronous timer events. You can use //; 21// this class in one of the following ways: //; 22// - Sub-class TTimer and override the Notify() method. //; 23// - Re-implement the TObject::HandleTimer() method in your class //; 24// and pass a pointer to this object to timer, see the SetObject() //; 25// method. //; 26// - Pass an interpreter command to timer, see SetCommand() method. //; 27// - Create a TTimer, connect its Timeout() signal to the //; 28// appropriate methods. Then when the time is up it will emit a //; 29// Timeout() signal and call connected slots. //; 30// //; 31// Minimum timeout interval is defined in TSystem::ESysConstants as //; 32// kItimerResolution (currently 10 ms). //; 33// //; 34// Signal/slots example: //; 35// TTimer *timer = new TTimer(); //; 36// timer->Connect(""Timeout()"", ""myObjectClassName"", //; 37// myObject, ""TimerDone()""); //; 38// timer->Start(2000, kTRUE); // 2 seconds single-shot //; 39// //; 40// // Timeout signal is emitted repeadetly with minimum timeout //; 41// // timer->Start(0, kFALSE); //; 42// //; 43//////////////////////////////////////////////////////////////////////////; 44 ; 45#include ""TSysEvtHandler.h""; 46#include ""TTime.h""; 47#include ""TString.h""; 48 ; 49 ; 50 ; 51class TTimer : public TSysEvtHandler {; 52 ; 53protected:; 54 TTime fTime; // time out time in ms; 55 TTime fAbsTime; // absolute time out time in ms; 56 Bool_t fTimeout; // true if timer has ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTimer_8h_source.html:1241,Timeout,Timeout,1241,doc/master/TTimer_8h_source.html,https://root.cern,https://root.cern/doc/master/TTimer_8h_source.html,1,['Timeout'],['Timeout']
Safety,"***************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#ifndef ROOT_TEnv; 13#define ROOT_TEnv; 14 ; 15 ; 16//////////////////////////////////////////////////////////////////////////; 17// //; 18// TEnv //; 19// //; 20// The TEnv class reads config files, by default named .rootrc. Three //; 21// types of config files are read: global, user and local files. The //; 22// global file is $ROOTSYS/etc/system<name> (or ROOTETCDIR/system<name>)//; 23// the user file is $HOME/<name> and the local file is ./<name>. //; 24// By setting the shell variable ROOTENV_NO_HOME=1 the reading of //; 25// the $HOME/<name> resource file will be skipped. This might be useful //; 26// in case the home directory resides on an automounted remote file //; 27// system and one wants to avoid this file system from being mounted. //; 28// //; 29// The format of the .rootrc file is similar to the .Xdefaults format: //; 30// //; 31// [+]<SystemName>.<RootName|ProgName>.<name>[(type)]: <value> //; 32// //; 33// Where <SystemName> is either Unix, WinNT, MacOS or Vms, //; 34// <RootName> the name as given in the TApplication ctor (or ""RootApp"" //; 35// in case no explicit TApplication derived object was created), //; 36// <ProgName> the current program name and <name> the resource name, //; 37// with optionally a type specification. <value> can be either a //; 38// string, an integer, a float/double or a boolean with the values //; 39// TRUE, FALSE, ON, OFF, YES, NO, OK, NOT. Booleans will be returned as //; 40// an integer 0 or 1. The options [+] allows the concatenation of //; 41// values to the same resouce name. //; 42// //; 43// E.g.: //; 44// //; 45// Unix.Rint.Root.DynamicPath: .:$ROOTSYS/lib:~/lib //; 46// myapp.Root.Debug:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TEnv_8h_source.html:1327,avoid,avoid,1327,doc/master/TEnv_8h_source.html,https://root.cern,https://root.cern/doc/master/TEnv_8h_source.html,1,['avoid'],['avoid']
Safety,"*************/; 11 ; 12#include ""THttpServer.h""; 13 ; 14#include ""TThread.h""; 15#include ""TTimer.h""; 16#include ""TSystem.h""; 17#include ""TROOT.h""; 18#include ""TUrl.h""; 19#include ""TEnv.h""; 20#include ""TError.h""; 21#include ""TClass.h""; 22#include ""RConfigure.h""; 23#include ""TRegexp.h""; 24#include ""TObjArray.h""; 25 ; 26#include ""THttpEngine.h""; 27#include ""THttpLongPollEngine.h""; 28#include ""THttpWSHandler.h""; 29#include ""TRootSniffer.h""; 30#include ""TRootSnifferStore.h""; 31#include ""TCivetweb.h""; 32#include ""TFastCgi.h""; 33 ; 34#include <chrono>; 35#include <cstdlib>; 36#include <cstring>; 37#include <fstream>; 38#include <memory>; 39#include <string>; 40#include <thread>; 41 ; 42class THttpTimer : public TTimer {; 43 Long_t fNormalTmout{0};; 44 Bool_t fSlow{kFALSE};; 45 Int_t fSlowCnt{0};; 46 ; 47public:; 48 THttpServer &fServer; ///!< server processing requests; 49 ; 50 /// constructor; 51 THttpTimer(Long_t milliSec, Bool_t mode, THttpServer &serv) : TTimer(milliSec, mode), fNormalTmout(milliSec), fServer(serv) {}; 52 ; 53 void SetSlow(Bool_t flag); 54 {; 55 fSlow = flag;; 56 fSlowCnt = 0;; 57 Long_t ms = fNormalTmout;; 58 if (fSlow) {; 59 if (ms < 100); 60 ms = 500;; 61 else if (ms < 500); 62 ms = 3000;; 63 else; 64 ms = 10000;; 65 }; 66 ; 67 SetTime(ms);; 68 }; 69 Bool_t IsSlow() const { return fSlow; }; 70 ; 71 /// timeout handler; 72 /// used to process http requests in main ROOT thread; 73 void Timeout() override; 74 {; 75 Int_t nprocess = fServer.ProcessRequests();; 76 ; 77 if (nprocess > 0) {; 78 fSlowCnt = 0;; 79 if (IsSlow()); 80 SetSlow(kFALSE);; 81 } else if (!IsSlow() && (fSlowCnt++ > 10)) {; 82 SetSlow(kTRUE);; 83 }; 84 }; 85};; 86 ; 87 ; 88/** \class THttpServer; 89\ingroup http; 90 ; 91Online http server for arbitrary ROOT application; 92 ; 93Idea of THttpServer - provide remote http access to running; 94ROOT application and enable HTML/JavaScript user interface.; 95Any registered object can be requested and displayed in the browser.; 96There are man",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THttpServer_8cxx_source.html:1934,timeout,timeout,1934,doc/master/THttpServer_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THttpServer_8cxx_source.html,2,"['Timeout', 'timeout']","['Timeout', 'timeout']"
Safety,"*-*-*-*-*-*-*. Creates the main histogram structure:; name : name of histogram (avoid blanks); title : histogram title; if title is of the form ""stringt;stringx;stringy;stringz""; the histogram title is set to stringt,; the x axis title to stringy, the y axis title to stringy, etc.; nbins : number of bins; xlow : low edge of first bin; xup : upper edge of last bin (not included in last bin). When an histogram is created, it is automatically added to the list; of special objects in the current directory.; To find the pointer to this histogram in the current directory; by its name, do:; TH1F *h1 = (TH1F*)gDirectory->FindObject(name);. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. TH1(const char* name, const char* title, Int_t nbinsx, const Float_t* xbins); -*-*-*-*-*Normal constructor for variable bin size histograms*-*-*-*-*-*-*. Creates the main histogram structure:; name : name of histogram (avoid blanks); title : histogram title; if title is of the form ""stringt;stringx;stringy;stringz""; the histogram title is set to stringt,; the x axis title to stringx, the y axis title to stringy, etc.; nbins : number of bins; xbins : array of low-edges for each bin; This is an array of size nbins+1. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. TH1(const char* name, const char* title, Int_t nbinsx, const Double_t* xbins); -*-*-*-*-*Normal constructor for variable bin size histograms*-*-*-*-*-*-*. Creates the main histogram structure:; name : name of histogram (avoid blanks); title : histogram title; if title is of the form ""stringt;stringx;stringy;stringz""; the histogram title is set to stringt,; the x axis title to stringx, the y axis title to stringy, etc.; nbins : number of bins; xbins : array of low-edges for each bin; This is an array of size nbins+1. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. TH1(const TH1& ); Copy constructor.; The list of functions is not copied. (Use Clone if needed).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TH1.html:38130,avoid,avoid,38130,root/html528/TH1.html,https://root.cern,https://root.cern/root/html528/TH1.html,4,['avoid'],['avoid']
Safety,"*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; vector<Int_t>fRegulatorIdxindex to different priors from every synapses; vector<Double_t>fRegulatorsthe priors as regulator; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class; TObjArray*fSynapsesarray of pointers to synapses, no structural data; boolfUseRegulatorzjh; TRandom3*frgenrandom number generator for various uses. private:. TObjArray*fInputLayercache this for fast access; TStringfLayerSpeclayout specification option; vector<TMVA::TNeuron*>fOutputNeuronscache this for fast access; static const Bool_tfgDEBUGdebug flag. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodANNBase(const TString& jobName, TMVA::Types::EMVA methodType, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption, TDirectory* theTargetDir); standard constructor; Note: Right now it is an option to choose the neuron input function,; but only the input function ""sum"" leads to weight convergence --; otherwise the weights go to nan and lead to an ABORT. MethodANNBase(TMVA::Types::EMVA methodType, TMVA::DataSetInfo& theData, const TString& theWeightFile, TDirectory* theTargetDir); construct the Method from the weight file. void DeclareOptions(); define the options (their key words) that can be set in the option string; here the options valid for ALL MVA methods are declared.; know options: NCycles=xx :the number of training cycles; Normalize=kTRUE,kFALSe :if normalised in put variables should be used; HiddenLayser=""N-1,N-2"" :the specification of the hidden layers; NeuronType=sigmoid,tanh,radial,linar : the type of activation function; used at the neuronn. void ProcessOptions(); do nothing specific at this moment. std::vector<Int_t>* ParseLayoutString(TString layerSpec); parse layout specification string and return a vector, each ent",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__MethodANNBase.html:20626,ABORT,ABORT,20626,root/html602/TMVA__MethodANNBase.html,https://root.cern,https://root.cern/root/html602/TMVA__MethodANNBase.html,2,['ABORT'],['ABORT']
Safety,"*fDirdirectory containing the objects or the TTree; TDSetElement*fElemCurrent Element; Long64_tfElemCurcurrent entry for this element; Long64_tfElemFirstfirst entry to process for this element; Long64_tfElemNumnumber of entries to process for this element; TEntryList*fEntryList! entry list for processing; Long64_tfEntryListPos! current position in the entrylist; TEventList*fEventList! eventList for processing; Int_tfEventListPos! current position in the eventList; TFile*fFileCurrent file; TStringfFilenameName of the current file; Long64_tfFirstfirst entry to process; Long64_tfNumnumber of entries to process; Long64_tfOldBytesReadlast reported number of bytes read; TList*fPacketslist of packets processed packets; TStringfPathPath to current TDirectory; TSelector*fSelselector to be used; Bool_tfStoptermination of run requested. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEventIter(); Default constructor. TEventIter(TDSet* dset, TSelector* sel, Long64_t first, Long64_t num); Constructor. ~TEventIter(); Destructor. void InvalidatePacket(); Invalidated the current packet (if any) by setting the TDSetElement::kCorrupted bit. void StopProcess(Bool_t abort); Set flag to stop the process. TEventIter * Create(TDSet* dset, TSelector* sel, Long64_t first, Long64_t num); Create and instance of the appropriate iterator. Int_t LoadDir(); Load directory. TEventIter(). Long64_t GetCacheSize(). Int_t GetLearnEntries(). Long64_t GetNextEvent(). Int_t GetNextPacket(Long64_t& first, Long64_t& num, TEntryList** enl = 0, TEventList** evl = 0). void PreProcessEvent(Long64_t ). TList * GetPackets(); { return fPackets; }. » Author: Maarten Ballintijn 07/01/02 » Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *; » Last changed: root/proofplayer:$Id$ » Last generated: 2015-06-04 09:58; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TEventIter.html:7617,abort,abort,7617,root/html604/TEventIter.html,https://root.cern,https://root.cern/root/html604/TEventIter.html,1,['abort'],['abort']
Safety,"*fDirdirectory containing the objects or the TTree; TDSetElement*fElemCurrent Element; Long64_tfElemCurcurrent entry for this element; Long64_tfElemFirstfirst entry to process for this element; Long64_tfElemNumnumber of entries to process for this element; TEntryList*fEntryList! entry list for processing; Long64_tfEntryListPos! current position in the entrylist; TEventList*fEventList! eventList for processing; Int_tfEventListPos! current position in the eventList; TFile*fFileCurrent file; TStringfFilenameName of the current file; Long64_tfFirstfirst entry to process; Long64_tfNumnumber of entries to process; Long64_tfOldBytesReadlast reported number of bytes read; TList*fPacketslist of packets processed packets; TStringfPathPath to current TDirectory; TSelector*fSelselector to be used; Bool_tfStoptermination of run requested. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEventIter(); Default constructor. TEventIter(TDSet* dset, TSelector* sel, Long64_t first, Long64_t num); Constructor. ~TEventIter(); Destructor. void InvalidatePacket(); Invalidated the current packet (if any) by setting the TDSetElement::kCorrupted bit. void StopProcess(Bool_t abort); Set flag to stop the process. TEventIter * Create(TDSet* dset, TSelector* sel, Long64_t first, Long64_t num); Create and instance of the appropriate iterator. Int_t LoadDir(); Load directory. TEventIter(). Long64_t GetCacheSize(). Int_t GetLearnEntries(). Long64_t GetNextEvent(). Int_t GetNextPacket(Long64_t& first, Long64_t& num, TEntryList** enl = 0, TEventList** evl = 0). void PreProcessEvent(Long64_t ). TList * GetPackets(); { return fPackets; }. » Author: Maarten Ballintijn 07/01/02 » Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *; » Last changed: root/proofplayer:$Id$ » Last generated: 2015-06-30 14:48; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEventIter.html:7617,abort,abort,7617,root/html602/TEventIter.html,https://root.cern,https://root.cern/root/html602/TEventIter.html,1,['abort'],['abort']
Safety,"*h1 = (TH1F*)gDirectory->FindObject(name);. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. TH1(const char* name, const char* title, Int_t nbinsx, const Float_t* xbins); -*-*-*-*-*Normal constructor for variable bin size histograms*-*-*-*-*-*-*. Creates the main histogram structure:; name : name of histogram (avoid blanks); title : histogram title; if title is of the form ""stringt;stringx;stringy;stringz""; the histogram title is set to stringt,; the x axis title to stringx, the y axis title to stringy, etc.; nbins : number of bins; xbins : array of low-edges for each bin; This is an array of size nbins+1. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. TH1(const char* name, const char* title, Int_t nbinsx, const Double_t* xbins); -*-*-*-*-*Normal constructor for variable bin size histograms*-*-*-*-*-*-*. Creates the main histogram structure:; name : name of histogram (avoid blanks); title : histogram title; if title is of the form ""stringt;stringx;stringy;stringz""; the histogram title is set to stringt,; the x axis title to stringx, the y axis title to stringy, etc.; nbins : number of bins; xbins : array of low-edges for each bin; This is an array of size nbins+1. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. TH1(const TH1& ); Copy constructor.; The list of functions is not copied. (Use Clone if needed). Bool_t AddDirectoryStatus(); static function: cannot be inlined on Windows/NT. void Browse(TBrowser* b); Browe the Histogram object. void Build(); -*-*-*-*-*-*-*-*Creates histogram basic data structure*-*-*-*-*-*-*-*-*-*. Bool_t Add(TF1* h1, Double_t c1 = 1, Option_t* option = """"); Performs the operation: this = this + c1*f1; if errors are defined (see TH1::Sumw2), errors are also recalculated. By default, the function is computed at the centre of the bin.; if option ""I"" is specified (1-d histogram only), the integral of the; function in each bin is used instead of the value of the functi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TH1.html:40390,avoid,avoid,40390,root/html534/TH1.html,https://root.cern,https://root.cern/root/html534/TH1.html,1,['avoid'],['avoid']
Safety,"*h1 = (TH1F*)gDirectory->FindObject(name);. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. TH1(const char* name, const char* title, Int_t nbinsx, const Float_t* xbins); -*-*-*-*-*Normal constructor for variable bin size histograms*-*-*-*-*-*-*. Creates the main histogram structure:; name : name of histogram (avoid blanks); title : histogram title; if title is of the form ""stringt;stringx;stringy;stringz""; the histogram title is set to stringt,; the x axis title to stringx, the y axis title to stringy, etc.; nbins : number of bins; xbins : array of low-edges for each bin; This is an array of size nbins+1. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. TH1(const char* name, const char* title, Int_t nbinsx, const Double_t* xbins); -*-*-*-*-*Normal constructor for variable bin size histograms*-*-*-*-*-*-*. Creates the main histogram structure:; name : name of histogram (avoid blanks); title : histogram title; if title is of the form ""stringt;stringx;stringy;stringz""; the histogram title is set to stringt,; the x axis title to stringx, the y axis title to stringy, etc.; nbins : number of bins; xbins : array of low-edges for each bin; This is an array of size nbins+1. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. TH1(const TH1& ); Copy constructor.; The list of functions is not copied. (Use Clone if needed). Bool_t AddDirectoryStatus(); static function: cannot be inlined on Windows/NT. void Browse(TBrowser* b); Browe the Histogram object. void Build(); -*-*-*-*-*-*-*-*Creates histogram basic data structure*-*-*-*-*-*-*-*-*-*. void Add(TF1* h1, Double_t c1 = 1, Option_t* option = """"); Performs the operation: this = this + c1*f1; if errors are defined (see TH1::Sumw2), errors are also recalculated. By default, the function is computed at the centre of the bin.; if option ""I"" is specified (1-d histogram only), the integral of the; function in each bin is used instead of the value of the function",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TH1.html:38726,avoid,avoid,38726,root/html528/TH1.html,https://root.cern,https://root.cern/root/html528/TH1.html,3,['avoid'],['avoid']
Safety,"*notmergeable = nullptr;; 205 Bool_t mergeable = kTRUE;; 206 while ((object = nextobject())) { // loop objects in this collection; 207 mergeable = kTRUE;; 208 // If current object has not dictionary just add it; 209 if (!object->IsA()) {; 210 mergeable = kFALSE;; 211 } else {; 212 // If current object is not mergeable just add it; 213 callEnv.InitWithPrototype(object->IsA(), ""Merge"", ""TCollection*"");; 214 if (!callEnv.IsValid()) mergeable = kFALSE;; 215 }; 216 if (mergeable) {; 217 // Current object mergeable - get corresponding objects in input lists; 218 templist = (TSeqCollection*)IsA()->New();; 219 // Make sure original objects are not deleted; some containers, e.g. TSelectorList, maybe owners; 220 templist->SetOwner(kFALSE);; 221 } else {; 222 templist = nullptr;; 223 }; 224 nextlist.Reset();; 225 Int_t indcoll = 0;; 226 while ((collcrt = nextlist())) { // loop input lists; 227 if (!collcrt->InheritsFrom(TSeqCollection::Class())) {; 228 Error(""Merge"", ""some objects in the input list are not collections - merging aborted"");; 229 SafeDelete(templist);; 230 return 0;; 231 }; 232 if (indobj > ((TSeqCollection*)collcrt)->LastIndex()) {; 233 // We reached the end of this collection.; 234 continue;; 235 }; 236 // The next object to be merged with is a collection; 237 // the iterator skips the 'holes' the collections, we also need to do so.; 238 objtomerge = ((TSeqCollection*)collcrt)->At(indobj);; 239 if (!objtomerge) {; 240 Warning(""Merge"", ""object of type %s (position %d in list) not found in list %d. Continuing..."",; 241 object->ClassName(), indobj, indcoll);; 242 continue;; 243 }; 244/*; 245 // Dangerous - may try to merge non-corresponding histograms (A.G); 246 while (objtomerge == 0; 247 && indobj < ((TSeqCollection*)collcrt)->LastIndex(); 248 ) {; 249 ++indobj;; 250 objtomerge = ((TSeqCollection*)collcrt)->At(indobj);; 251 }; 252*/; 253 if (object->IsA() != objtomerge->IsA()) {; 254 Error(""Merge"", ""object of type %s at index %d not matching object of type %s in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSeqCollection_8cxx_source.html:7833,abort,aborted,7833,doc/master/TSeqCollection_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSeqCollection_8cxx_source.html,2,"['Safe', 'abort']","['SafeDelete', 'aborted']"
Safety,"+ Progress bar would be better.; [#9292] - Integer overflow in TTreeCache::FillBuffer; [#8959] - ninja clean does not remove modules.idx; [#8952] - Make hadd return a non-zero exit code when encountering a corrupted file; [#8942] - cannot buid the dependent project; [#8794] - [TGNumberEntry] centiseconds; [#8720] - Apply TChain::SetImplicitMT() to underlying trees; [#8639] - (RDataFrame) AsNumpy returns Boolean branches as ‘object’ dtype numpy arrays; [#8582] - TThreadTimer behavior; [#8581] - [ntuple] RNTupleModel columns ownership issue; [#8517] - Add integer support to TVectorT; [#8494] - cling crashes on conditional parameter in template; [#8260] - Build system cannot detect version of oneTBB; [#8148] - Document TMethodCall class limitations; [#7950] - Assertion exception including header file with GaudiPython module; [#7900] - Support spectator variables in RReader; [#7872] - TExecutorCRTP::Map() should support void; [#7871] - Usability of TExecutor::MapReduce; [#7845] - Improve TMatrix reference documentation; [#7805] - Inconsistent and unintuitive behaviour of TFormula::SetParNames and TFormula::SetParameters; [#7774] - Unreasonably slow behaviour of CompileMacro; [#7699] - [VecOps] Make free functions in VecOps better visible; [#7686] - PyROOT Segfault when creating proxy to derived class with multiple overloads; [#7669] - Inconsistent behaviour in wildcard import; [#7644] - Provide in the cmake configuration the C++ standard which was used to compile ROOT; [#7627] - Fix TMVA group links; [#7159] - TNetXNGFile::Open fails with double slash (//) in path; [#7128] - Cannot build ROOT if another ROOT at /usr/local; [#6900] - mathmore: invalid roots for a quartic polynomial; [#6811] - Bug displaying several 3D objects such as TGraph2D on the same canvas; [#6755] - Greek letter epsilon not rendered correctly using TLatex with OpenGL.CanvasPreferGL option, segmentation fault.; [#6753] - CMake dependency on Python: use targets; [#6616] - hadd writes files with unspe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/release-notes.html:37340,detect,detect,37340,doc/v632/release-notes.html,https://root.cern,https://root.cern/doc/v632/release-notes.html,1,['detect'],['detect']
Safety,"+ statement(s) on output stream out. ;  ; virtual void SetMarkerAttributes ();  Invoke the DialogCanvas Marker attributes. ;  ; virtual void SetMarkerColor (Color_t mcolor=1);  Set the marker color. ;  ; virtual void SetMarkerColorAlpha (Color_t mcolor, Float_t malpha);  Set a transparent marker color. ;  ; virtual void SetMarkerSize (Size_t msize=1);  Set the marker size. ;  ; virtual void SetMarkerStyle (Style_t mstyle=1);  Set the marker style. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TF1; static void AbsValue (Bool_t reject=kTRUE);  Static function: set the fgAbsValue flag. ;  ; static void CalcGaussLegendreSamplingPoints (Int_t num, Double_t *x, Double_t *w, Double_t eps=3.0e-11);  Type safe interface (static method) The number of sampling points are taken from the TGraph. ;  ; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Bool_t DefaultAddToGlobalList (Bool_t on=kTRUE);  Static method to add/avoid to add automatically functions to the global list (gROOT->GetListOfFunctions() ) After having called this static method, all the functions created afterwards will follow the desired behaviour. ;  ; static Double_t DerivativeError ();  Static function returning the error of the last call to the of Derivative's functions. ;  ; static TF1 * GetCurrent ();  Static function returning the current function being processed. ;  ; static void InitStandardFunctions ();  Create the basic function objects. ;  ; static Bool_t RejectedPoint ();  See TF1::RejectPoint above. ;  ; static void RejectPoint (Bool_t reject=kTRUE);  Static function to set the global flag to reject points the fgRejectPoint global flag i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTF12.html:32211,safe,safe,32211,doc/master/classTF12.html,https://root.cern,https://root.cern/doc/master/classTF12.html,2,['safe'],['safe']
Safety,"++ interpreter we decided to reuse existing code. Code that we can still influence, but that's nevertheless production-grade. We expected that this will solve the maintenance and correctness issues. And because it's correct we don't need Reflex, but can instead use one central, fast (compiler!) reflection database.; So yes, this is a major overhaul of ROOT and the dictionaries. We will signal that with a new major ROOT version number. But we expect it to solve the correctness, stability, memory and CPU-consumption as well as the maintenance issues we currently have. The current implementation of cling (which is not yet complete) uses a mere 5000 lines of custom code developed by HEP; everything else is provided through LLVM and clang.; And regarding PyROOT: I am sure Wim will make good use of the new JIT power that comes with cling! Just like we expect the JIT to leave traces e.g. in TFormula, and the real reflection database in the I/O, THtml etc. It gets us unstuck, flexible and future-safe in many central areas of ROOT. O the places you'll go!; Cheers,. Axel Naumann's blog. Comments. Submitted by Anonymous (not verified) on Thu, 07/23/2015 - 21:48 Permalink . Other Python bindings . I noticed that there are multiple other ways to call C++ code from Python, one of them being included in the Boost library. What would it do to the complexity (and dependencies) to use an interface that doesn't build on top of CINT/Reflex?. Submitted by Anonymous (not verified) on Thu, 07/23/2015 - 21:49 Permalink . Re: Other Python bindings . Hi Bram,; Thanks for your question. The main issue about the boost binding is that it is - as far as I understand - completely static and intrusive. PyROOT on the other hand is based on refection data, and it has features that e.g. the Boost binding doesn't offer (e.g. the mapping of concepts). Other bindings (e.g. SWIG-based ones) are difficult to maintain, not compatible with C++, and don't offer PyROOT's features either. So the cost is both o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/blog/do-we-need-yet-another-custom-c-interpreter.html:5147,safe,safe,5147,d/blog/do-we-need-yet-another-custom-c-interpreter.html,https://root.cern,https://root.cern/d/blog/do-we-need-yet-another-custom-c-interpreter.html,1,['safe'],['safe']
Safety,"++i); 1885 // xInput.emplace_back(Matrix_t(n1,n2));; 1886 ; 1887 // create pointer to output matrix used for the predictions; 1888 Matrix_t yHat(deepNet.GetBatchSize(), deepNet.GetOutputWidth() );; 1889 ; 1890 // use timer; 1891 Timer timer( nEvents, GetName(), kTRUE );; 1892 ; 1893 if (logProgress); 1894 Log() << kHEADER << Form(""[%s] : "",DataInfo().GetName()); 1895 << ""Evaluation of "" << GetMethodName() << "" on ""; 1896 << (Data()->GetCurrentType() == Types::kTraining ? ""training"" : ""testing""); 1897 << "" sample ("" << nEvents << "" events)"" << Endl;; 1898 ; 1899 ; 1900 // eventg loop; 1901 std::vector<double> mvaValues(nEvents);; 1902 ; 1903 ; 1904 for ( Long64_t ievt = firstEvt; ievt < lastEvt; ievt+=batchSize) {; 1905 ; 1906 Long64_t ievt_end = ievt + batchSize;; 1907 // case of batch prediction for; 1908 if (ievt_end <= lastEvt) {; 1909 ; 1910 if (ievt == firstEvt) {; 1911 Data()->SetCurrentEvent(ievt);; 1912 size_t nVariables = GetEvent()->GetNVariables();; 1913 ; 1914 if (n1 == batchSize && n0 == 1) {; 1915 if (n2 != nVariables) {; 1916 Log() << kFATAL << ""Input Event variable dimensions are not compatible with the built network architecture""; 1917 << "" n-event variables "" << nVariables << "" expected input matrix "" << n1 << "" x "" << n2; 1918 << Endl;; 1919 }; 1920 } else {; 1921 if (n1*n2 != nVariables || n0 != batchSize) {; 1922 Log() << kFATAL << ""Input Event variable dimensions are not compatible with the built network architecture""; 1923 << "" n-event variables "" << nVariables << "" expected input tensor "" << n0 << "" x "" << n1 << "" x "" << n2; 1924 << Endl;; 1925 }; 1926 }; 1927 }; 1928 ; 1929 auto batch = testData.GetTensorBatch();; 1930 auto inputTensor = batch.GetInput();; 1931 ; 1932 auto xInput = batch.GetInput();; 1933 // make the prediction; 1934 deepNet.Prediction(yHat, xInput, fOutputFunction);; 1935 for (size_t i = 0; i < batchSize; ++i) {; 1936 double value = yHat(i,0);; 1937 mvaValues[ievt + i] = (TMath::IsNaN(value)) ? -999. : value;; 1938 }; 1939 }",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDL_8cxx_source.html:76158,predict,prediction,76158,doc/master/MethodDL_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDL_8cxx_source.html,1,['predict'],['prediction']
Safety,"+2*sizeof(Short_t)+2*sizeof(Long64_t);; 803 } else {; 804 buffer_keyloc += 2*sizeof(Int_t)+2*sizeof(Short_t)+2*sizeof(Int_t);; 805 }; 806 TString cname;; 807 cname.ReadBuffer(buffer_keyloc);; 808 cname.ReadBuffer(buffer_keyloc); // fName.ReadBuffer(buffer); file may have been renamed; 809 fTitle.ReadBuffer(buffer_keyloc);; 810 delete [] header;; 811 if (fNbytesName < 10 || fNbytesName > 10000) {; 812 Error(""Init"",""cannot read directory info of file %s"", GetName());; 813 goto zombie;; 814 }; 815 ; 816 //*-* -------------Check if file is truncated; 817 Long64_t size;; 818 if ((size = GetSize()) == -1) { // NOLINT: silence clang-tidy warnings; 819 Error(""Init"", ""cannot stat the file %s"", GetName());; 820 goto zombie;; 821 }; 822 ; 823 //*-* -------------Check if, in case of inconsistencies, we are requested to; 824 //*-* -------------attempt recovering the file; 825 Bool_t tryrecover = (gEnv->GetValue(""TFile.Recover"", 1) == 1) ? kTRUE : kFALSE;; 826 ; 827 //*-* -------------Check if we need to enable forward compatible with version; 828 //*-* -------------prior to v6.30; 829 if (gEnv->GetValue(""TFile.v630forwardCompatibility"", 0) == 1); 830 SetBit(k630forwardCompatibility);; 831 ; 832 //*-* -------------Read keys of the top directory; 833 if (fSeekKeys > fBEGIN && fEND <= size) {; 834 //normal case. Recover only if file has no keys; 835 TDirectoryFile::ReadKeys(kFALSE);; 836 gDirectory = this;; 837 if (!GetNkeys()) {; 838 if (tryrecover) {; 839 Recover(); // NOLINT: silence clang-tidy warnings; 840 } else {; 841 Error(""Init"", ""file %s has no keys"", GetName());; 842 goto zombie;; 843 }; 844 }; 845 } else if ((fBEGIN+nbytes == fEND) && (fEND == size)) {; 846 //the file might be open by another process and nothing written to the file yet; 847 Warning(""Init"",""file %s has no keys"", GetName());; 848 gDirectory = this;; 849 } else {; 850 //something had been written to the file. Trailer is missing, must recover; 851 if (fEND > size) {; 852 if (tryrecover) {; 853 Error(""Init"",",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:30147,Recover,Recover,30147,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['Recover'],['Recover']
Safety,"+= contLevel->GetSize();; }. nGraphs = 0;. TCanvas* c1 = new TCanvas(""c1"",""Contour List"",610,0,600,600);; c1->SetTopMargin(0.15);; TH2F *hr = new TH2F(""hr"",; ""#splitline{Negative contours are returned first (highest to lowest). Positive contours are returned from}{lowest to highest. On this plot Negative contours are drawn in red and positive contours in blue.}"",; 2, -2, 2, 2, 0, 6.5);. hr->Draw();; Double_t x0, y0, z0;; TLatex l;; l.SetTextSize(0.03);; char val[20];. for(i = 0; i < TotalConts; i++){; contLevel = (TList*)conts->At(i);; if (i<3) z0 = contours[2-i];; else z0 = contours[i];; printf(""Z-Level Passed in as: Z = %f\n"", z0);. // Get first graph from list on curves on this level; curv = (TGraph*)contLevel->First();; for(j = 0; j < contLevel->GetSize(); j++){; curv->GetPoint(0, x0, y0);; if (z0<0) curv->SetLineColor(kRed);; if (z0>0) curv->SetLineColor(kBlue);; nGraphs ++;; printf(""\tGraph: %d -- %d Elements\n"", nGraphs,curv->GetN());. 	 // Draw clones of the graphs to avoid deletions in case the 1st; 	 // pad is redrawn.; gc = (TGraph*)curv->Clone();; gc->Draw(""C"");. sprintf(val,""%g"",z0);; l.DrawLatex(x0,y0,val);; curv = (TGraph*)contLevel->After(curv); // Get Next graph; }; }; c1->Update();; printf(""\n\n\tExtracted %d Contours and %d Graphs \n"", TotalConts, nGraphs );; gStyle->SetTitleW(0.);; gStyle->SetTitleH(0.);; return c1;; }. Double_t SawTooth(Double_t x, Double_t WaveLen){. // This function is specific to a sawtooth function with period; // WaveLen, symmetric about x = 0, and with amplitude = 1. Each segment; // is 1/4 of the wavelength.; //; // |; // /\ |; // / \ |; // / \ |; // / \; // /--------\--------/------------; // |\ /; // | \ /; // | \ /; // | \/; //. Double_t y;; if ( (x < -WaveLen/2) || (x > WaveLen/2)) y = -99999999; // Error X out of bounds; if (x <= -WaveLen/4) {; y = x + 2.0;; } else if ((x > -WaveLen/4) && (x <= WaveLen/4)) {; y = -x ;; } else if (( x > WaveLen/4) && (x <= WaveLen/2)) {; y = x - 2.0;; }; return y;; }; The following op",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/THistPainter.html:39610,avoid,avoid,39610,root/html528/THistPainter.html,https://root.cern,https://root.cern/root/html528/THistPainter.html,3,['avoid'],['avoid']
Safety,"+it) {; 2293#endif; 2294 Int_t stop = *it;; 2295 if (stop - 1 >= start + 1) {; 2296 TString tok = (*this)(start+1, stop-start-1);; 2297 TObjString *objstr = new TObjString(tok);; 2298 arr->Add(objstr);; 2299 }; 2300 start = stop;; 2301 }; 2302 ; 2303 return arr;; 2304}; 2305 ; 2306////////////////////////////////////////////////////////////////////////////////; 2307/// Formats a string using a printf style format descriptor.; 2308/// Existing string contents will be overwritten.; 2309 ; 2310void TString::FormImp(const char *fmt, va_list ap); 2311{; 2312 Ssiz_t buflen = 20 + 20 * strlen(fmt); // pick a number, any strictly positive number; 2313 buflen = Clobber(buflen); // Update buflen, as Clobber clamps length to MaxSize (if Fatal does not abort); 2314 ; 2315 va_list sap;; 2316 R__VA_COPY(sap, ap);; 2317 ; 2318 int n, vc = 0;; 2319again:; 2320 n = vsnprintf(GetPointer(), buflen, fmt, ap);; 2321 // old vsnprintf's return -1 if string is truncated new ones return; 2322 // total number of characters that would have been written; 2323 if (n == -1 || n >= buflen) {; 2324 if (n == -1); 2325 buflen *= 2;; 2326 else; 2327 buflen = n+1;; 2328 buflen = Clobber(buflen);; 2329 va_end(ap);; 2330 R__VA_COPY(ap, sap);; 2331 vc = 1;; 2332 goto again;; 2333 }; 2334 va_end(sap);; 2335 if (vc); 2336 va_end(ap);; 2337 ; 2338 SetSize(strlen(Data()));; 2339}; 2340 ; 2341////////////////////////////////////////////////////////////////////////////////; 2342/// Formats a string using a printf style format descriptor.; 2343/// Existing string contents will be overwritten.; 2344/// See also the static version TString::Format; 2345/// ~~~ {.cpp}; 2346/// TString formatted;; 2347/// formatted.Form(""%s in <%s>: %s"", type, location, msg);; 2348///; 2349/// lines.emplace_back(TString::Format(""Welcome to ROOT %s%%shttp://root.cern"",; 2350/// gROOT->GetVersion()));; 2351/// ~~~; 2352///; 2353/// Note: this is not to be confused with ::Format and ::Form (in the global namespace); 2354/// which return",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TString_8cxx_source.html:74376,abort,abort,74376,doc/master/TString_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html,1,['abort'],['abort']
Safety,", ""w"");; 1608 if (!to) {; 1609 fclose(from);; 1610 return -1;; 1611 }; 1612 ; 1613 const int bufsize = 1024;; 1614 char buf[bufsize];; 1615 int ret = 0;; 1616 while (!ret && !feof(from)) {; 1617 size_t numread = fread (buf, sizeof(char), bufsize, from);; 1618 size_t numwritten = fwrite(buf, sizeof(char), numread, to);; 1619 if (numread != numwritten); 1620 ret = -3;; 1621 }; 1622 ; 1623 fclose(from);; 1624 fclose(to);; 1625 ; 1626 return ret;; 1627}; 1628 ; 1629////////////////////////////////////////////////////////////////////////////////; 1630/// Rename a file. Returns 0 when successful, -1 in case of failure.; 1631 ; 1632int TUnixSystem::Rename(const char *f, const char *t); 1633{; 1634 int ret = ::rename(f, t);; 1635 GetLastErrorString() = GetError();; 1636 return ret;; 1637}; 1638 ; 1639////////////////////////////////////////////////////////////////////////////////; 1640/// Returns TRUE if the url in 'path' points to the local file system.; 1641/// This is used to avoid going through the NIC card for local operations.; 1642 ; 1643Bool_t TUnixSystem::IsPathLocal(const char *path); 1644{; 1645 TSystem *helper = FindHelper(path);; 1646 if (helper); 1647 return helper->IsPathLocal(path);; 1648 ; 1649 return TSystem::IsPathLocal(path);; 1650}; 1651 ; 1652////////////////////////////////////////////////////////////////////////////////; 1653/// Get info about a file. Info is returned in the form of a FileStat_t; 1654/// structure (see TSystem.h).; 1655/// The function returns 0 in case of success and 1 if the file could; 1656/// not be stat'ed.; 1657 ; 1658int TUnixSystem::GetPathInfo(const char *path, FileStat_t &buf); 1659{; 1660 TSystem *helper = FindHelper(path);; 1661 if (helper); 1662 return helper->GetPathInfo(path, buf);; 1663 ; 1664 return UnixFilestat(path, buf);; 1665}; 1666 ; 1667////////////////////////////////////////////////////////////////////////////////; 1668/// Get info about a file system: id, bsize, bfree, blocks.; 1669/// Id is file system type",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TUnixSystem_8cxx_source.html:50247,avoid,avoid,50247,doc/master/TUnixSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html,1,['avoid'],['avoid']
Safety,", &skey); seekkey = (Long64_t)skey;; 1631 frombuf(buffer, &sdir); seekpdir = (Long64_t)sdir;; 1632 }; 1633 frombuf(buffer, &nwhc);; 1634 if ( ((buffer-header) + nwhc) > nwheader ) // Don't read past the end of the part of the key we have read.; 1635 nwhc = nwheader - (buffer-header);; 1636 for (int i = 0;i < nwhc; i++) frombuf(buffer, &classname[i]);; 1637 classname[(int)nwhc] = '\0'; //cast to avoid warning with gcc3.4; 1638 if (idcur == fSeekFree) strlcpy(classname,""FreeSegments"",512);; 1639 if (idcur == fSeekInfo) strlcpy(classname,""StreamerInfo"",512);; 1640 if (idcur == fSeekKeys) strlcpy(classname,""KeysList"",512);; 1641 ; 1642 if (extended) {; 1643 if ( (buffer-header) >= nwheader ); 1644 nwhc = 0;; 1645 else {; 1646 frombuf(buffer, &nwhc);; 1647 if (nwhc < 0); 1648 nwhc = 0;; 1649 else if ( ((buffer-header) + nwhc) > nwheader ) // Don't read past the end of the part of the key we have read.; 1650 nwhc = nwheader - (buffer-header);; 1651 }; 1652 for (int i = 0;i < nwhc; i++) frombuf(buffer, &keyname[i]);; 1653 keyname[(int)nwhc] = '\0'; //cast to avoid warning with gcc3.4; 1654 ; 1655 if ( (buffer-header) >= nwheader ); 1656 nwhc = 0;; 1657 else {; 1658 frombuf(buffer, &nwhc);; 1659 if (nwhc < 0); 1660 nwhc = 0;; 1661 else if ( ((buffer-header) + nwhc) > nwheader ) // Don't read past the end of the part of the key we have read.; 1662 nwhc = nwheader - (buffer-header);; 1663 }; 1664 for (int i = 0;i < nwhc; i++) frombuf(buffer, &keytitle[i]);; 1665 keytitle[(int)nwhc] = '\0'; //cast to avoid warning with gcc3.4; 1666 ; 1667 extrainfo.Form("" name: %-16s title: %s"", keyname, keytitle);; 1668 }; 1669 ; 1670 TDatime::GetDateTime(datime, date, time);; 1671 if (!forComp) {; 1672 if (objlen != nbytes - keylen) {; 1673 Float_t cx = Float_t(objlen + keylen) / Float_t(nbytes);; 1674 Printf(""%d/%06d At:%-*lld N=%-8d %-14s CX = %5.2f %s"", date, time, nDigits + 1, idcur, nbytes, classname,; 1675 cx, extrainfo.Data());; 1676 } else {; 1677 Printf(""%d/%06d At:%-*lld N=%-8d %-14",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:60287,avoid,avoid,60287,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['avoid'],['avoid']
Safety,", -15, 15); a1 = ROOT.RooRealVar(""a1"", ""a1"", -0.5, -10.0, 20.0); a2 = ROOT.RooRealVar(""a2"", ""a2"", 0.2, -10.0, 20.0); a3 = ROOT.RooRealVar(""a3"", ""a3"", 0.01); pdf = ROOT.RooPolynomial(""pol3"", ""c + a1 * x + a2 * x*x + 0.01 * x*x*x"", x, [a1, a2, a3]); ; # Create toy data with all-positive coefficients:; data = pdf.generate(x, 10000); ; # For plotting.; # We create pointers to the plotted objects. We want these objects to leak out of the function,; # so we can still see them after it returns.; c = ROOT.TCanvas(); frame = x.frame(); data.plotOn(frame, Name=""data""); ; # Plotting a PDF with disallowed parameters doesn't work. We would get a lot of error messages.; # Therefore, we disable plotting messages in RooFit's message streams:; ROOT.RooMsgService.instance().getStream(0).removeTopic(ROOT.RooFit.Plotting); ROOT.RooMsgService.instance().getStream(1).removeTopic(ROOT.RooFit.Plotting); ; ; # RooFit before ROOT 6.24; # --------------------------------; # Before 6.24, RooFit wasn't able to recover from invalid parameters. The minimiser just errs around; # the starting values of the parameters without finding any improvement.; ; # Set up the parameters such that the PDF would come out negative. The PDF is now undefined.; a1.setVal(10.0); a2.setVal(-1.0); ; # Perform a fit:; fitWithoutRecovery = pdf.fitTo(; data,; Save=True,; RecoverFromUndefinedRegions=0.0, # This is how RooFit behaved prior to ROOT 6.24; PrintEvalErrors=-1, # We are expecting a lot of evaluation errors. -1 switches off printing.; PrintLevel=-1,; ); ; pdf.plotOn(frame, LineColor=""r"", Name=""noRecovery""); ; ; # RooFit since ROOT 6.24; # --------------------------------; # The minimiser gets information about the ""badness"" of the violation of the function definition. It uses this; # to find its way out of the disallowed parameter regions.; print(""\n\n\n-------------- Starting second fit ---------------\n\n""); ; # Reset the parameters such that the PDF is again undefined.; a1.setVal(10.0); a2.setVal(-1.0); ; # F",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html:2051,recover,recover,2051,doc/master/rf612__recoverFromInvalidParameters_8py.html,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html,1,['recover'],['recover']
Safety,", . Int_t & ; npols . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ GetNhigh(). const Double_t * TGeoCtub::GetNhigh ; (; ); const. inline . Definition at line 214 of file TGeoTube.h. ◆ GetNlow(). const Double_t * TGeoCtub::GetNlow ; (; ); const. inline . Definition at line 213 of file TGeoTube.h. ◆ GetNmeshVertices(). Int_t TGeoCtub::GetNmeshVertices ; (; ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ GetPointsOnSegments(). Bool_t TGeoCtub::GetPointsOnSegments ; (; Int_t ; npoints, . Double_t * ; array . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ GetZcoord(). Double_t TGeoCtub::GetZcoord ; (; Double_t ; xc, . Double_t ; yc, . Double_t ; zc . ); const. ◆ InspectShape(). void TGeoCtub::InspectShape ; (; ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ IsA(). TClass * TGeoCtub::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TGeoBBox.; Definition at line 226 of file TGeoTube.h. ◆ Safety(). Double_t TGeoCtub::Safety ; (; const Double_t * ; point, . Bool_t ; in = kTRUE . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ Safety_v(). void TGeoCtub::Safety_v ; (; const Double_t * ; points, . const Bool_t * ; inside, . Double_t * ; safe, . Int_t ; vecsize . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ SavePrimitive(). void TGeoCtub::SavePrimitive ; (; std::ostream & ; out, . Option_t * ; option = """" . ). overridevirtual . Save a primitive as a C++ statement(s) on output stream ""out"". ; Reimplemented from TGeoBBox. ◆ SetCtubDimensions(). void TGeoCtub::SetCtubDimensions ; (; Double_t ; rmin, . Double_t ; rmax, . Double_t ; dz, . Double_t ; phi1, . Double_t ; phi2, . Double_t ; lx, . Double_t ; ly, . Double_t ; lz, . Double_t ; tx, . Double_t ; ty, . Double_t ; tz . ). ◆ SetDimensions(). void TGeoCtub::SetDimensions ; (; Double_t * ; param). overridevirtual . Reimplemented from TGeoBBox. ◆ SetPoints() [1/2]. void TGeoCtub::SetPoints ; (; Double_t * ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoCtub.html:33461,Safe,Safety,33461,doc/master/classTGeoCtub.html,https://root.cern,https://root.cern/doc/master/classTGeoCtub.html,1,['Safe'],['Safety']
Safety,", . bool ; doOffset = false . ); const. Return the extended likelihood term ( \( N_\mathrm{expect} - N_\mathrm{observed} \cdot \log(N_\mathrm{expect} \)) of this PDF for the given number of observed events. ; For successful operation, the PDF implementation must indicate that it is extendable by overloading canBeExtended(), and must implement the expectedEvents() function.; Parameters. [in]sumEntriesThe number of observed events. ; [in]nsetThe normalization set when asking the pdf for the expected number of events. ; [in]observedSumW2The number of observed events when weighting with squared weights. If non-zero, the weight-squared error correction is applied to the extended term. ; [in]doOffsetOffset the extended term by a counterterm where the expected number of events equals the observed number of events. This constant shift results in a term closer to zero that is approximately chi-square distributed. It is useful to do this also when summing multiple NLL terms to avoid numeric precision loss that happens if you sum multiple terms of different orders of magnitude. The weight-squared error correction works as follows: adjust poisson such that estimate of \(N_\mathrm{expect}\) stays at the same value, but has a different variance, rescale both the observed and expected count of the Poisson with a factor \( \sum w_{i} / \sum w_{i}^2 \) (the effective weight of the Poisson term), i.e., change \(\mathrm{Poisson}(N_\mathrm{observed} = \sum w_{i} | N_\mathrm{expect} )\) to \( \mathrm{Poisson}(\sum w_{i} \cdot \sum w_{i} / \sum w_{i}^2 | N_\mathrm{expect} \cdot \sum w_{i} / \sum w_{i}^2 ) \), weighted by the effective weight \( \sum w_{i}^2 / \sum w_{i} \) in the likelihood. Since here we compute the likelihood with the weight square, we need to multiply by the square of the effective weight:; \( W_\mathrm{expect} = N_\mathrm{expect} \cdot \sum w_{i} / \sum w_{i}^2 \) : effective expected entries; \( W_\mathrm{observed} = \sum w_{i} \cdot \sum w_{i} / \sum w_{i}^2 \) : e",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsPdf.html:100123,avoid,avoid,100123,doc/master/classRooAbsPdf.html,https://root.cern,https://root.cern/doc/master/classRooAbsPdf.html,1,['avoid'],['avoid']
Safety,", 10000); dh = d.binnedClone(); ; # Construct a chi^2 of the data and the model.; # When a p.d.f. is used in a chi^2 fit, probability density scaled; # by the number of events in the dataset to obtain the fit function; # If model is an extended p.d.f, expected number events is used; # instead of the observed number of events.; ll = ROOT.RooLinkedList(); model.chi2FitTo(dh, ll); ; # NB: It is also possible to fit a ROOT.RooAbsReal function to a ROOT.RooDataHist; # using chi2FitTo().; ; # Note that entries with zero bins are _not_ allowed; # for a proper chi^2 calculation and will give error; # messages; dsmall = d.reduce(ROOT.RooFit.EventRange(1, 100)); dhsmall = dsmall.binnedClone(); chi2_lowstat = model.createChi2(dhsmall); print(chi2_lowstat.getVal()); [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- The following expressions have been identified as constant and will be precalculated and cached: (sig1,sig2); [#1] INFO:Minimization -- The following expressions will be evaluated in cache-and-track mode: (bkg); Minuit2Minimizer: Minimize with max-calls 2000 convergence for edm < 1 strategy 1; Minuit2Minimizer : Valid minimum - status = 0; FVAL = 104.639633447510988; Edm = 0.000778057047730882148; Nfcn = 70; a0 = 0.501526 +/- 0.0229096 (limited); a1 = 0.158456 +/- 0.0368354 (limited); bkgfrac = 0.506609 +/- 0.011349 (limited); sig1frac = 0.815448 +/- 0.0373695 (limited); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; 90.86495991394004; DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C version) ; Definition in ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf602__chi2fit_8py.html:2670,safe,safe,2670,doc/master/rf602__chi2fit_8py.html,https://root.cern,https://root.cern/doc/master/rf602__chi2fit_8py.html,1,['safe'],['safe']
Safety,", Bool_t cross = kTRUE); Make a rectiliniar step of length fStep from current point (fPoint) on current; direction (fDirection). If the step is imposed by geometry, is_geom flag; must be true (default). The cross flag specifies if the boundary should be; crossed in case of a geometry step (default true). Returns new node after step.; Set also on boundary condition. Int_t GetVirtualLevel(); Find level of virtuality of current overlapping node (number of levels; up having the same tracking media. Bool_t GotoSafeLevel(); Go upwards the tree until a non-overlaping node. Int_t GetSafeLevel() const; Go upwards the tree until a non-overlaping node. void InspectState() const; Inspects path and all flags for the current state. Bool_t IsSameLocation(Double_t x, Double_t y, Double_t z, Bool_t change = kFALSE); Checks if point (x,y,z) is still in the current node.; check if this is an overlapping node. Bool_t IsSafeStep(Double_t proposed, Double_t& newsafety) const; In case a previous safety value was computed, check if the safety region is; still safe for the current point and proposed step. Return value changed only; if proposed distance is safe. Bool_t IsSamePoint(Double_t x, Double_t y, Double_t z) const; Check if a new point with given coordinates is the same as the last located one. void DoBackupState(); Backup the current state without affecting the cache stack. void DoRestoreState(); Restore a backed-up state without affecting the cache stack. TGeoHMatrix * GetHMatrix(); Return stored current matrix (global matrix of the next touched node). const char * GetPath() const; Get path to the current node in the form /node0/node1/... void MasterToTop(const Double_t* master, Double_t* top) const; Convert coordinates from master volume frame to top. void TopToMaster(const Double_t* top, Double_t* master) const; Convert coordinates from top volume frame to master. void ResetAll(); Reset the navigator. Int_t GetNmany() const; --- geometry queries. {return fNmany;}. const Double_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoNavigator.html:18397,safe,safety,18397,root/html528/TGeoNavigator.html,https://root.cern,https://root.cern/root/html528/TGeoNavigator.html,18,['safe'],"['safe', 'safety']"
Safety,", Bool_t in = kTRUE) const; Computes the closest distance from given point to this shape. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetDimensions(Double_t* param); Set all arb8 params in one step.; param[0] = dz; param[1] = theta; param[2] = phi; param[3] = h1; param[4] = bl1; param[5] = tl1; param[6] = alpha1; param[7] = h2; param[8] = bl2; param[9] = tl2; param[10] = alpha2. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoArb8& operator=(const TGeoTrap& ). TGeoTrap(); constructors. Double_t GetTheta() const; {return fTheta;}. Double_t GetPhi() const; {return fPhi;}. Double_t GetH1() const; {return fH1;}. Double_t GetBl1() const; {return fBl1;}. Double_t GetTl1() const; {return fTl1;}. Double_t GetAlpha1() const; {return fAlpha1;}. Double_t GetH2() const; {return fH2;}. Double_t GetBl2() const; {return fBl2;}. Double_t GetTl2() const; {return fTl2;}. Double_t GetAlpha2() const; {return fAlpha2;}. » Author: Andrei Gheata 24/10/01 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-06-02 16:03; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGeoTrap.html:19740,Safe,Safety,19740,root/html604/TGeoTrap.html,https://root.cern,https://root.cern/root/html604/TGeoTrap.html,1,['Safe'],['Safety']
Safety,", Bool_t in = kTRUE) const; Computes the closest distance from given point to this shape. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetDimensions(Double_t* param); Set all arb8 params in one step.; param[0] = dz; param[1] = theta; param[2] = phi; param[3] = h1; param[4] = bl1; param[5] = tl1; param[6] = alpha1; param[7] = h2; param[8] = bl2; param[9] = tl2; param[10] = alpha2. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoArb8& operator=(const TGeoTrap& ). TGeoTrap(); constructors. Double_t GetTheta() const; {return fTheta;}. Double_t GetPhi() const; {return fPhi;}. Double_t GetH1() const; {return fH1;}. Double_t GetBl1() const; {return fBl1;}. Double_t GetTl1() const; {return fTl1;}. Double_t GetAlpha1() const; {return fAlpha1;}. Double_t GetH2() const; {return fH2;}. Double_t GetBl2() const; {return fBl2;}. Double_t GetTl2() const; {return fTl2;}. Double_t GetAlpha2() const; {return fAlpha2;}. » Author: Andrei Gheata 24/10/01 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-06-30 15:03; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoTrap.html:19740,Safe,Safety,19740,root/html602/TGeoTrap.html,https://root.cern,https://root.cern/root/html602/TGeoTrap.html,1,['Safe'],['Safety']
Safety,", CERN/SFT,; Rene Brun, CERN/SFT,; Philippe Canal, FNAL,; Cristina Cristescu, CERN/SFT,; Olivier Couet, CERN/SFT,; Kyle Cranmer, NYU, RooStats,; Aurelie Flandi, CERN/SFT,; Gerri Ganis, CERN/SFT,; Andrei Gheata, CERN/Alice,; Lukasz Janyst, CERN/IT,; Christopher Jones, Fermilab, CMS,; Wim Lavrijsen, LBNL, PyRoot,; Sergey Linev, GSI, http,; Pere Mato, CERN/SFT,; Lorenzo Moneta, CERN/SFT,; Axel Naumann, CERN/SFT,; Danilo Piparo, CERN/SFT,; Timur Pocheptsov, CERN/SFT,; Fons Rademakers, CERN/SFT,; Enric Tejedor Saavedra, CERN/SFT,; Liza Sakellari, CERN/SFT,; Manuel Tobias Schiller,; David Smith, CERN/IT,; Matevz Tadel, UCSD/CMS, Eve,; Vassil Vassilev, CERN/SFT; Wouter Verkerke, NIKHEF/Atlas, RooFit,; Yue Shi Lai, MIT,; Maciej Zimnoch, GSOC; Core Libraries; General; Platform support; ROOT now works on linuxarm64 / AArch64 / ARMv8 64-bit - thanks, David Abdurachmanov!; ROOT supports GCC 5.0 (using the GCC4 ABI) and XCode 6.3, Mac OSX 10.10.3; Thread-Safety; A lot of effort went into improving the thread-safety of Core and Meta classes / functions. A special thanks to Chris Jones from CMS!; std::string_view; Introduce a preview of C++17’s std::string_view. To take advantage of this new class use:; #include ""RStringView.h""; The documentation of this can be found at http://en.cppreference.com/w/cpp/experimental/basic_string_view The implementation provided is extracted from libcxx. Whenever the current compiler and standard library provide an implmentation, it is used.; The type string_view describes an object that can refer to a constant contiguous sequence of char-like objects with the first element of the sequence at position zero.; This type is used throughout the ROOT code to avoid copying strings when a sub-string is needed and to extent interfaces that uses to take a const char* to take a std::string_view as thus be able to be directly directly passed a TString, a std::string or a std::string_view. Usage example:; // With SetName(std::string_view); std::string str; …; ob",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v604/release-notes.html:2827,Safe,Safety,2827,doc/v604/release-notes.html,https://root.cern,https://root.cern/doc/v604/release-notes.html,2,"['Safe', 'safe']","['Safety', 'safety']"
Safety,", Double_t c2, Double_t s2); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoBBox&operator=(const TGeoBBox&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(Double_t* point, Bool_t in = kTRUE) const; static Double_tTGeoShape::SafetyPhi(Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidSetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetPoints(Double_t* points) const; virtual voidSetPoints(Float_t* points) const; voidTGeoShape::SetRuntime(Bool_t flag = kTRUE); virtual voidSetSegsAndPols(TBuffer3D& buffer) const; voidTGeoShape::SetShapeBit(UInt_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoBBox.html:9495,Safe,SafetyPhi,9495,root/html530/TGeoBBox.html,https://root.cern,https://root.cern/root/html530/TGeoBBox.html,2,['Safe'],['SafetyPhi']
Safety,", Double_t c2, Double_t s2); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoCone&operator=(const TGeoCone&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(Double_t* point, Bool_t in = kTRUE) const; static Double_tTGeoShape::SafetyPhi(Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tSafetyS(Double_t* point, Bool_t in, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Int_t skipz = 0); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; voidSetConeDimensions(Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoCone.html:8505,Safe,SafetyPhi,8505,root/html530/TGeoCone.html,https://root.cern,https://root.cern/root/html530/TGeoCone.html,2,['Safe'],['SafetyPhi']
Safety,", Double_t c2, Double_t s2); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoCtub&operator=(const TGeoCtub&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(Double_t* point, Bool_t in = kTRUE) const; static Double_tTGeoShape::SafetyPhi(Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoTubeSeg::SafetyS(Double_t* point, Bool_t in, Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2, Int_t skipz = 0); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; voidSetCtubDimensions(Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2, Double_t lx, Double_t ly, Double_t lz, Double_t tx, Double_t ty, Double_t tz); virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoCtub.html:9378,Safe,SafetyPhi,9378,root/html530/TGeoCtub.html,https://root.cern,https://root.cern/root/html530/TGeoCtub.html,2,['Safe'],['SafetyPhi']
Safety,", Double_t c2, Double_t s2); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoEltu&operator=(const TGeoEltu&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(Double_t* point, Bool_t in = kTRUE) const; static Double_tTGeoShape::SafetyPhi(Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoTube::SafetyS(Double_t* point, Bool_t in, Double_t rmin, Double_t rmax, Double_t dz, Int_t skipz = 0); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetEltuDimensions(Double_t a, Double_t b, Double_t dz); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetPoints(Doub",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoEltu.html:8280,Safe,SafetyPhi,8280,root/html530/TGeoEltu.html,https://root.cern,https://root.cern/root/html530/TGeoEltu.html,2,['Safe'],['SafetyPhi']
Safety,", Double_t c2, Double_t s2); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoPara&operator=(const TGeoPara&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(Double_t* point, Bool_t in = kTRUE) const; static Double_tTGeoShape::SafetyPhi(Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetPoints(Double_t* points) const; virtual voidSetPoints(Float_t* points) const; voidTGeoShape::SetRuntime(Bool_t flag = kTRUE); virtual voidTGeoBBox::SetSegsAndPols(TBuffer3D& buffer) const; void",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoPara.html:8062,Safe,SafetyPhi,8062,root/html530/TGeoPara.html,https://root.cern,https://root.cern/root/html530/TGeoPara.html,2,['Safe'],['SafetyPhi']
Safety,", Double_t c2, Double_t s2); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoTrd1&operator=(const TGeoTrd1&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(Double_t* point, Bool_t in = kTRUE) const; static Double_tTGeoShape::SafetyPhi(Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetPoints(Double_t* points) const; virtual voidSetPoints(Float_t* points) const; voidTGeoShape::SetRuntime(Bool_t flag = kTRUE); virtual voidTGeoBBox::SetSegsAndPols(TBuffer3D& buffer) const; void",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoTrd1.html:7950,Safe,SafetyPhi,7950,root/html530/TGeoTrd1.html,https://root.cern,https://root.cern/root/html530/TGeoTrd1.html,2,['Safe'],['SafetyPhi']
Safety,", Double_t c2, Double_t s2); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoTrd2&operator=(const TGeoTrd2&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(Double_t* point, Bool_t in = kTRUE) const; static Double_tTGeoShape::SafetyPhi(Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetPoints(Double_t* points) const; virtual voidSetPoints(Float_t* points) const; voidTGeoShape::SetRuntime(Bool_t flag = kTRUE); virtual voidTGeoBBox::SetSegsAndPols(TBuffer3D& buffer) const; void",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoTrd2.html:8016,Safe,SafetyPhi,8016,root/html530/TGeoTrd2.html,https://root.cern,https://root.cern/root/html530/TGeoTrd2.html,2,['Safe'],['SafetyPhi']
Safety,", Double_t c2, Double_t s2); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoTube&operator=(const TGeoTube&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(Double_t* point, Bool_t in = kTRUE) const; static Double_tTGeoShape::SafetyPhi(Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tSafetyS(Double_t* point, Bool_t in, Double_t rmin, Double_t rmax, Double_t dz, Int_t skipz = 0); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetPoints(Double_t* points) const; virtual voidSetPoints(Float_t* points) const; voi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoTube.html:8636,Safe,SafetyPhi,8636,root/html530/TGeoTube.html,https://root.cern,https://root.cern/root/html530/TGeoTube.html,2,['Safe'],['SafetyPhi']
Safety,", Double_t dz); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoTube::DistFromInsideS(const Double_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoTube::DistFromOutsideS(const Double_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); Int_tDistToHype(const Double_t* point, const Double_t* dir, Double_t* s, Bool_t inner, Bool_t in) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); static voidTGeoTube::DistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoHype.html:3808,safe,safe,3808,root/html534/TGeoHype.html,https://root.cern,https://root.cern/root/html534/TGeoHype.html,3,['safe'],['safe']
Safety,", Double_t dz); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoTube::DistFromInsideS(const Double_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoTube::DistFromOutsideS(const Double_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); static voidTGeoTube::DistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoEltu.html:2828,safe,safe,2828,root/html534/TGeoEltu.html,https://root.cern,https://root.cern/root/html534/TGeoEltu.html,3,['safe'],['safe']
Safety,", Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; in case shape has some negative parameters, these has to be computed; in order to fit the mother. void InspectShape() const; print shape parameters. TBuffer3D * MakeBuffer3D() const; Creates a TBuffer3D describing *this* shape.; Coordinates are in local reference frame. void SetSegsAndPols(TBuffer3D& buff) const; Fill TBuffer3D structure for segments and polygons. Double_t Safety(const Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point InitTrigonometry();to this shape, according; to option. The matching point on the shape is stored in spoint. Double_t SafetyS(const Double_t* point, Bool_t in, Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2, Int_t skipz = 0); Static method to compute the closest distance from given point to this shape. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetTubsDimensions(Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2); Set dimensions of the tube segment.; The segment will be from phiStart to phiEnd expressed in degree. void SetDimensions(Double_t* param); Set dimensions of the tube segment starting from a list. Bool_t GetPointsOnSegments(Int_t npoints, Double_t* array) const; Fills array with n random points located on the line segments of the shape mesh.; The output array must be provided with a length of minimum 3*npoints. Returns; true if operation is implemented. void SetPoints(Double_t* points) const; Create tube segment mesh points. void SetPoints(Float_t* points) const; Create tube segment mesh points. void GetMeshNumbers(Int_t& nvert, Int_t& nsegs, Int_t& npols) const; R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoTubeSeg.html:18772,Safe,SafetyS,18772,root/html534/TGeoTubeSeg.html,https://root.cern,https://root.cern/root/html534/TGeoTubeSeg.html,3,['Safe'],['SafetyS']
Safety,", Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; in case shape has some negative parameters, these has to be computed; in order to fit the mother. void InspectShape() const; print shape parameters. TBuffer3D * MakeBuffer3D() const; Creates a TBuffer3D describing *this* shape.; Coordinates are in local reference frame. void SetSegsAndPols(TBuffer3D& buffer) const; Fill TBuffer3D structure for segments and polygons. Double_t Safety(const Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape, according; to option. The matching point on the shape is stored in spoint. Double_t SafetyS(const Double_t* point, Bool_t in, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t phi1, Double_t phi2, Int_t skipz = 0); Static method to compute the closest distance from given point to this shape. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetConsDimensions(Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t phi1, Double_t phi2); Set dimensions of the cone segment. void SetDimensions(Double_t* param); Set dimensions of the cone segment from an array. void SetPoints(Double_t* points) const; Create cone segment mesh points. void SetPoints(Float_t* points) const; Create cone segment mesh points. void GetMeshNumbers(Int_t& nvert, Int_t& nsegs, Int_t& npols) const; Returns numbers of vertices, segments and polygons composing the shape mesh. Int_t GetNmeshVertices() const; Return number of vertices of the mesh representation. void Sizeof3D() const; fill size of this 3-D object; TVirtualGeoPainter *painter = gGeoManager->GetGeomPainter();; if (!p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoConeSeg.html:19168,Safe,SafetyS,19168,root/html534/TGeoConeSeg.html,https://root.cern,https://root.cern/root/html534/TGeoConeSeg.html,3,['Safe'],['SafetyS']
Safety,", Int_t netopt = 0); Open ROOT TFile by the name provided;; This TFile is to be deleted by the TFileIter alone. TFileIter(const TFileIter& ); Copy ctor can be used with the ""read only"" files only.; the next statement is illegal, spotted by coverity ""Dereferencing pointer ""this->fRootFile"". (Deref happens because this is a virtual function call.); assert(!fRootFile->IsWritable());. ~TFileIter(); TFileIter dtor. void Initialize(); to be documented. Bool_t IsOpen() const; Check whether the associated ROOT TFile was open; and TFile object is healthy. TKey * GetCurrentKey() const; return the pointer to the current TKey. Int_t GetDepth() const; return the current number of the nested subdirectroies;; = 0 - means there is no subdirectories. const char * GetKeyName() const; return the name of the current TKey. TObject * GetObject() const; read the object from TFile defined by the current TKey. ATTENTION: memory leak danger !!!. This method does create a new object and it is the end-user; code responsibility to take care about this object; to avoid memory leak. Int_t GetObjlen() const; Returns the uncompressed length of the current object. Int_t TotalKeys() const; The total number of the TKey keys in the current TDirectory only; Usually this means the total number of different objects; those can be read one by one.; It does NOT count the nested sub-TDirectory.; It is too costly and it can be abused. TObject * Next(Int_t nSkip); return the pointer to the object defined by next TKey; This method is not recommended. It was done for the sake; of the compatibility with TListIter. void PurgeKeys(TList* listOfKeys); Remove the TKey duplication,; leave the keys with highest cycle number only; Sort if first. void Reset(); Reset the status of the iterator. void SetCursorPosition(const char* keyNameToFind); Find the key by the name provided. TKey * SkipObjects(Int_t nSkip = 1). Returns the TKey pointer to the nSkip TKey object from the current one; nSkip = 0; the state of the iterator i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFileIter.html:8124,avoid,avoid,8124,root/html528/TFileIter.html,https://root.cern,https://root.cern/root/html528/TFileIter.html,6,['avoid'],['avoid']
Safety,", Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tCouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidDraw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tEpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoShape.html:7939,safe,safe,7939,root/html532/TGeoShape.html,https://root.cern,https://root.cern/root/html532/TGeoShape.html,1,['safe'],['safe']
Safety,", Int_t recurse=1) const;  Print the collection header and its elements that match the regexp. ;  ; void Print (Option_t *option="""") const override;  Default print for collections, calls Print(option, 1). ;  ; void RecursiveRemove (TObject *obj) override;  Remove object from this collection and recursively remove the object from all other objects (and collections). ;  ; virtual TObject * Remove (TObject *obj)=0;  ; void RemoveAll ();  ; virtual void RemoveAll (TCollection *col);  Remove all objects in collection col from this collection. ;  ; void SetCurrentCollection ();  Set this collection to be the globally accessible collection. ;  ; void SetName (const char *name);  ; virtual void SetOwner (Bool_t enable=kTRUE);  Set whether this collection is the owner (enable==true) of its content. ;  ; void Streamer (TBuffer &) override;  Stream all objects in the collection to or from the I/O buffer. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual bool UseRWLock (Bool_t enable=true);  Set this collection to use a RW lock upon access, making it thread safe. ;  ; Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const override;  Write all objects in this collection. ;  ; Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) override;  Write all objects in this collection. ;  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTCollection.html:6286,safe,safe,6286,doc/v632/classTCollection.html,https://root.cern,https://root.cern/doc/v632/classTCollection.html,2,['safe'],['safe']
Safety,", Int_t vecsize) override;  ; void ComputeTwist ();  ; Bool_t Contains (const Double_t *point) const override;  ; void Contains_v (const Double_t *points, Bool_t *inside, Int_t vecsize) const override;  ; Double_t DistToPlane (const Double_t *point, const Double_t *dir, Int_t ipl, Bool_t in) const;  ; Double_t GetAxisRange (Int_t iaxis, Double_t &xlo, Double_t &xhi) const override;  ; void GetBoundingCylinder (Double_t *param) const override;  ; Int_t GetByteCount () const override;  ; Double_t GetClosestEdge (const Double_t *point, Double_t *vert, Int_t &isegment) const;  ; Double_t GetDz () const;  ; Int_t GetFittingBox (const TGeoBBox *parambox, TGeoMatrix *mat, Double_t &dx, Double_t &dy, Double_t &dz) const override;  ; Bool_t GetPointsOnFacet (Int_t, Int_t, Double_t *) const override;  ; Double_t GetTwist (Int_t iseg) const;  ; Double_t * GetVertices ();  ; void InspectShape () const override;  ; Bool_t IsCylType () const override;  ; Bool_t IsTwisted () const;  ; Double_t SafetyToFace (const Double_t *point, Int_t iseg, Bool_t in) const;  ; void SetDz (Double_t dz);  ; void SetPlaneVertices (Double_t zpl, Double_t *vertices) const;  ; void SetPoints (Double_t *points) const override;  ; void SetPoints (Float_t *points) const override;  ; virtual void SetVertex (Int_t vnum, Double_t x, Double_t y);  ; void Sizeof3D () const override;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TGeoBBox;  TGeoBBox ();  ;  TGeoBBox (const char *name, Double_t dx, Double_t dy, Double_t dz, Double_t *origin=nullptr);  ;  TGeoBBox (Double_t *param);  ;  TGeoBBox (Double_t dx, Double_t dy, Double_t dz, Double_t *origin=nullptr);  ;  ~TGeoBBox () override;  ; Double_t Capacity () const override;  ; void ComputeBBox () override;  ; void ComputeNormal (const Double_t *point, const Double_t *dir, Double_t *norm) override;  ; void ComputeNormal_v (const Double_t *points, const Double_t *dirs, Double_t *norms, Int_t vecsize) o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoGtra.html:5693,Safe,SafetyToFace,5693,doc/master/classTGeoGtra.html,https://root.cern,https://root.cern/doc/master/classTGeoGtra.html,2,['Safe'],['SafetyToFace']
Safety,", Layer_t >::Loss ; (; const Matrix_t & ; groundTruth, . const Matrix_t & ; weights, . bool ; includeRegularization = true . ); const. Function for evaluating the loss, based on the activations stored in the last layer. ; Definition at line 1263 of file DeepNet.h. ◆ Loss() [2/2]. template<typename Architecture_t , typename Layer_t > . auto TMVA::DNN::TDeepNet< Architecture_t, Layer_t >::Loss ; (; Tensor_t & ; input, . const Matrix_t & ; groundTruth, . const Matrix_t & ; weights, . bool ; inTraining = false, . bool ; includeRegularization = true . ). Function for evaluating the loss, based on the propagation of the given input. ; Definition at line 1279 of file DeepNet.h. ◆ Prediction() [1/2]. template<typename Architecture_t , typename Layer_t > . auto TMVA::DNN::TDeepNet< Architecture_t, Layer_t >::Prediction ; (; Matrix_t & ; predictions, . EOutputFunction ; f . ); const. Prediction based on activations stored in the last layer. ; Definition at line 1303 of file DeepNet.h. ◆ Prediction() [2/2]. template<typename Architecture_t , typename Layer_t > . auto TMVA::DNN::TDeepNet< Architecture_t, Layer_t >::Prediction ; (; Matrix_t & ; predictions, . Tensor_t & ; input, . EOutputFunction ; f . ). Prediction for the given inputs, based on what network learned. ; Definition at line 1311 of file DeepNet.h. ◆ Print(). template<typename Architecture_t , typename Layer_t > . auto TMVA::DNN::TDeepNet< Architecture_t, Layer_t >::Print. Print the Deep Net Info. ; Definition at line 1321 of file DeepNet.h. ◆ RegularizationTerm(). template<typename Architecture_t , typename Layer_t > . auto TMVA::DNN::TDeepNet< Architecture_t, Layer_t >::RegularizationTerm. Function for computing the regularizaton term to be added to the loss function . Definition at line 1289 of file DeepNet.h. ◆ ResetTraining(). template<typename Architecture_t , typename Layer_t > . auto TMVA::DNN::TDeepNet< Architecture_t, Layer_t >::ResetTraining. Function that reset some training flags after looping all the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TDeepNet.html:24730,Predict,Prediction,24730,doc/master/classTMVA_1_1DNN_1_1TDeepNet.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TDeepNet.html,1,['Predict'],['Prediction']
Safety,", N2 where N1 and N2 are the dimension of the sub-matrix (SubMatrix::kRows and SubMatrix::kCols ) Condition row0+N1 <= D1 && col0+N2 <=D2 ;  ; SVector< T, D1 > Diagonal () const;  return diagonal elements of a matrix as a Vector. ;  ; template<class Vector > ; void SetDiagonal (const Vector &v);  Set the diagonal elements from a Vector Require that vector implements SVector::kSize since a check (statically) is done on diagonal size == vector size. ;  ; T Trace () const;  return the trace of a matrix Sum of the diagonal elements ;  ; SVector< T, D1 *(D2+1)/2 > UpperBlock () const;  return the upper Triangular block of the matrices (including the diagonal) as a vector of sizes N = D1 * (D1 + 1)/2. ;  ; SVector< T, D1 *(D2+1)/2 > LowerBlock () const;  return the lower Triangular block of the matrices (including the diagonal) as a vector of sizes N = D1 * (D1 + 1)/2. ;  ; — Other Functions —; bool IsInUse (const T *p) const;  Function to check if a matrix is sharing same memory location of the passed pointer This function is used by the expression templates to avoid the alias problem during expression evaluation. ;  ; std::ostream & Print (std::ostream &os) const;  Print: used by operator<<() ;  . Public Attributes; — Data Member —; R fRep;  Matrix Storage Object containing matrix data. ;  . #include <Math/SMatrix.h>; Member Typedef Documentation. ◆ const_iterator. template<class T , unsigned int D1, unsigned int D2 = D1, class R = MatRepStd<T, D1, D2>> . typedef const T* ROOT::Math::SMatrix< T, D1, D2, R >::const_iterator. STL const_iterator interface. ; Definition at line 115 of file SMatrix.h. ◆ iterator. template<class T , unsigned int D1, unsigned int D2 = D1, class R = MatRepStd<T, D1, D2>> . typedef T* ROOT::Math::SMatrix< T, D1, D2, R >::iterator. STL iterator interface. ; Definition at line 112 of file SMatrix.h. ◆ rep_type. template<class T , unsigned int D1, unsigned int D2 = D1, class R = MatRepStd<T, D1, D2>> . typedef R ROOT::Math::SMatrix< T, D1, D2, R >::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1SMatrix.html:12001,avoid,avoid,12001,doc/master/classROOT_1_1Math_1_1SMatrix.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1SMatrix.html,1,['avoid'],['avoid']
Safety,", UInt_t len); static Int_tWriteChecksum(const char* file, const TMD5* md5). private:. voidDecode(UInt_t* out, const UChar_t* in, UInt_t len); voidEncode(UChar_t* out, const UInt_t* in, UInt_t len); voidTransform(UInt_t[4] buf, const UChar_t[64] in). Data Members; private:. UInt_tfBits[2]!temp buffer; UInt_tfBuf[4]!temp buffer; UChar_tfDigest[16]message digest; Bool_tfFinalizedtrue if message digest has been finalized; UChar_tfIn[64]!temp buffer; Char_tfString[33]!string representation of digest. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMD5(); Create TMD5 object. Set bit count to 0 and buffer to mysterious; initialization constants. TMD5(const UChar_t* digest); Create finalized TMD5 object containing passed in 16 byte digest. TMD5(const TMD5& md5); MD5 copy ctor. Special copy ctor avoids copying unnecessary; temp arrays when finalized. TMD5 & operator=(const TMD5& rhs); MD5 assignment operator. Special assignment operator avoids; copying unnecessary temp arrays when finalized. void Update(const UChar_t* buf, UInt_t len); Update TMD5 object to reflect the concatenation of another buffer full; of bytes. void Final(UChar_t[16] digest); MD5 finalization, ends an MD5 message-digest operation, writing the; the message digest and zeroizing the context.; Returns digest. void Final(); MD5 finalization, ends an MD5 message-digest operation, writing the; the message digest and zeroizing the context. void Print() const; Print digest in ascii hex form. const char * AsString() const; Return message digest as string. Returns """" in case Final() has; not yet been called. void Encode(UChar_t* out, const UInt_t* in, UInt_t len); Encodes input into output. Assumes len is a multiple of 4. void Decode(UInt_t* out, const UChar_t* in, UInt_t len); Decodes input into output. Assumes len is a multiple of 4. void Transform(UInt_t[4] buf, const UChar_t[64] in); The core of the MD5 algorithm, this alters an existing MD5 hash to; reflect the add",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMD5.html:2549,avoid,avoids,2549,root/html602/TMD5.html,https://root.cern,https://root.cern/root/html602/TMD5.html,2,['avoid'],['avoids']
Safety,", column contain class version; *:object - other object, column contain object id; *:rawdata - raw data, column contains id of raw data from _streamer_ table; *:Int_t - column with integer value; Use TSQLFile::SetUseSuffixes(kFALSE) to disable suffixes usage. This and several other options can be changed only when; TSQLFile created with options ""CREATE"" or ""RECREATE"" and only before; first write operation. These options are:; SetUseSuffixes() - suffix usage in column names (default - on); SetArrayLimit() - defines maximum array size, which can; has column for each element (default 21); SetTablesType() - table type name in MySQL database (default ""InnoDB""); SetUseIndexes() - usage of indexes in database (default kIndexesBasic); Normally these functions should be called immidiately after TSQLFile constructor. When objects data written to database, by default START TRANSACTION/COMMIT; SQL commands are used before and after data storage. If TSQLFile detects; any problems, ROLLBACK command will be used to restore; previous state of data base. If transactions not supported by SQL server,; they can be disabled by SetUseTransactions(kTransactionsOff). Or user; can take responsibility to use transactions function to hime. By default only indexes for basic tables are created.; In most cases usage of indexes increase perfomance to data reading,; but it also can increase time of writing data to database.; There are several modes of index usage available in SetUseIndexes() method. There is MakeSelectQuery(TClass*) method, which; produces SELECT statement to get objects data of specified class.; Difference from simple statement like:; mysql> SELECT * FROM TH1I_ver1; that not only data for that class, but also data from parent classes; will be extracted from other tables and combined in single result table.; Such select query can be usufull for external access to objects data. Up to now MySQL 4.1 and Oracle 9i were tested.; Some extra work is required for other SQL databases.; Hop",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TSQLFile.html:4365,detect,detects,4365,root/html530/TSQLFile.html,https://root.cern,https://root.cern/root/html530/TSQLFile.html,5,['detect'],['detects']
Safety,", const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override;  ; Double_t DistFromOutside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override;  ; void DistFromOutside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override;  ; TGeoVolume * Divide (TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) override;  ; const char * GetAxisName (Int_t iaxis) const override;  ; Double_t GetAxisRange (Int_t iaxis, Double_t &xlo, Double_t &xhi) const override;  ; void GetBoundingCylinder (Double_t *param) const override;  ; Int_t GetByteCount () const override;  ; virtual Double_t GetDX () const;  ; virtual Double_t GetDY () const;  ; virtual Double_t GetDZ () const;  ; virtual Double_t GetFacetArea (Int_t index=0) const;  ; Int_t GetFittingBox (const TGeoBBox *parambox, TGeoMatrix *mat, Double_t &dx, Double_t &dy, Double_t &dz) const override;  ; TGeoShape * GetMakeRuntimeShape (TGeoShape *mother, TGeoMatrix *mat) const override;  ; virtual const Double_t * GetOrigin () const;  ; virtual Bool_t GetPointsOnFacet (Int_t index, Int_t npoints, Double_t *array) const;  ; Bool_t GetPointsOnSegments (Int_t npoints, Double_t *array) const override;  ; Bool_t IsCylType () const override;  ; virtual Bool_t IsNullBox () const;  ; Bool_t IsValidBox () const override;  ; Double_t Safety (const Double_t *point, Bool_t in=kTRUE) const override;  ; void Safety_v (const Double_t *points, const Bool_t *inside, Double_t *safe, Int_t vecsize) const override;  ; void SetBoxDimensions (Double_t dx, Double_t dy, Double_t dz, Double_t *origin=nullptr);  ; void SetBoxPoints (Double_t *points) const;  ; void SetDimensions (Double_t *param) override;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TGeoShape;  TGeoShape ();  Default constructor.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoTessellated.html:8082,Safe,Safety,8082,doc/master/classTGeoTessellated.html,https://root.cern,https://root.cern/doc/master/classTGeoTessellated.html,2,"['Safe', 'safe']","['Safety', 'safe']"
Safety,", const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidCreateThreadData(Int_t nthreads); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoCompositeShape.html:8516,safe,safe,8516,root/html534/TGeoCompositeShape.html,https://root.cern,https://root.cern/root/html534/TGeoCompositeShape.html,3,['safe'],['safe']
Safety,", from start position with the given step. Returns pointer; to created division cell volume. In case a wrong division axis is supplied,; returns pointer to volume to be divided. void ComputeBBox(); Compute bounding box - nothing to do in this case. Bool_t Contains(const Double_t* point) const; Test if point is inside this shape. Bool_t Contains(const Double_t* point, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin); Static method to check if point[3] is located inside a box of having dx, dy, dz; as half-lengths. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the box.; Boundary safe algorithm. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); Compute distance from inside point to surface of the box.; Boundary safe algorithm. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the box.; Boundary safe algorithm. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); Compute distance from outside point to surface of the box.; Boundary safe algorithm. const char * GetAxisName(Int_t iaxis) const; Returns name of axis IAXIS. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. Double_t GetFacetArea(Int_t index = 0) const; Get area in internal units of the facet with a given index.; Possible index values:; 0 - all facets togeather",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoBBox.html:16222,safe,safe,16222,root/html534/TGeoBBox.html,https://root.cern,https://root.cern/root/html534/TGeoBBox.html,3,['safe'],['safe']
Safety,", kGeoHalfSpace = (1ULL << ( 29 )); , ;   kGeoHype = (1ULL << ( 30 )); , kGeoSavePrimitive = (1ULL << ( 20 )). };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Public Attributes inherited from TGeoBBox; static Bool_t DO NOT USE !The overlap detection does not work for all cases;  ; static Bool_t DEPRECATED;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TGeoBBox;  TGeoBBox (const TGeoBBox &)=delete;  ; void FillBuffer3D (TBuffer3D &buffer, Int_t reqSections, Bool_t localFrame) const override;  Fill the supplied buffer, with sections in desired frame See TBuffer3D.h for explanation of sections, frame etc. ;  ; TGeoBBox & operator= (const TGeoBBox &)=delete;  ;  Protected Member Functions inherited from TGeoShape; Int_t GetBasicColor () const;  Get the basic color (0-7). ;  ; void SetOnBoundary (Bool_t);  ; void TransformPoints (Double_t *points, UInt_t NbPoints) const;  Tranform a set of points (LocalToMaster) ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . #include <TGeoScaledShape.h>. Inheritance diagram for TGeoScaledShape:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoScaledShape.html:22552,detect,detection,22552,doc/master/classTGeoScaledShape.html,https://root.cern,https://root.cern/doc/master/classTGeoScaledShape.html,1,['detect'],['detection']
Safety,", kGeoHalfSpace = (1ULL << ( 29 )); , ;   kGeoHype = (1ULL << ( 30 )); , kGeoSavePrimitive = (1ULL << ( 20 )). };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Public Attributes inherited from TGeoBBox; static Bool_t DO NOT USE !The overlap detection does not work for all cases;  ; static Bool_t DEPRECATED;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TGeoBBox;  TGeoBBox (const TGeoBBox &)=delete;  ; void FillBuffer3D (TBuffer3D &buffer, Int_t reqSections, Bool_t localFrame) const override;  Fill the supplied buffer, with sections in desired frame See TBuffer3D.h for explanation of sections, frame etc. ;  ; TGeoBBox & operator= (const TGeoBBox &)=delete;  ;  Protected Member Functions inherited from TGeoShape; Int_t GetBasicColor () const;  Get the basic color (0-7). ;  ; void SetOnBoundary (Bool_t);  ; void TransformPoints (Double_t *points, UInt_t NbPoints) const;  Tranform a set of points (LocalToMaster) ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . #include <TGeoShapeAssembly.h>. Inheritance diagram for TGeoShapeAssembly:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constru",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoShapeAssembly.html:22121,detect,detection,22121,doc/master/classTGeoShapeAssembly.html,https://root.cern,https://root.cern/doc/master/classTGeoShapeAssembly.html,1,['detect'],['detection']
Safety,", kGeoHalfSpace = (1ULL << ( 29 )); , ;   kGeoHype = (1ULL << ( 30 )); , kGeoSavePrimitive = (1ULL << ( 20 )). };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Public Attributes inherited from TGeoBBox; static Bool_t DO NOT USE !The overlap detection does not work for all cases;  ; static Bool_t DEPRECATED;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TGeoBBox;  TGeoBBox (const TGeoBBox &)=delete;  ; void FillBuffer3D (TBuffer3D &buffer, Int_t reqSections, Bool_t localFrame) const override;  Fill the supplied buffer, with sections in desired frame See TBuffer3D.h for explanation of sections, frame etc. ;  ; TGeoBBox & operator= (const TGeoBBox &)=delete;  ;  Protected Member Functions inherited from TGeoShape; Int_t GetBasicColor () const;  Get the basic color (0-7). ;  ; void SetOnBoundary (Bool_t);  ; void TransformPoints (Double_t *points, UInt_t NbPoints) const;  Tranform a set of points (LocalToMaster) ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Attributes inherited from TGeoBBox; Double_t fDX;  ; Double_t fDY;  ; Double_t fDZ;  ; Double_t fOrigin [3];  ;  Protected Attributes inherited from TGeoShape; UInt_t f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoHalfSpace.html:22330,detect,detection,22330,doc/master/classTGeoHalfSpace.html,https://root.cern,https://root.cern/doc/master/classTGeoHalfSpace.html,3,['detect'],['detection']
Safety,", s.Data(), TMath::Min(s.Length(), n2)); }. TString & ReplaceAll(const TString& s1, const TString& s2); { return ReplaceAll(s1.Data(), s1.Length(), s2.Data(), s2.Length()) ; }. TString & ReplaceAll(const TString& s1, const char* s2); { return ReplaceAll(s1.Data(), s1.Length(), s2, s2 ? strlen(s2) : 0); }. TString & ReplaceAll(const char* s1, const TString& s2); { return ReplaceAll(s1, s1 ? strlen(s1) : 0, s2.Data(), s2.Length()); }. TString & ReplaceAll(const char* s1, const char* s2); { return ReplaceAll(s1, s1 ? strlen(s1) : 0, s2, s2 ? strlen(s2) : 0); }. char & operator()(Ssiz_t i); { return GetPointer()[i]; }. char operator()(Ssiz_t i) const; { return GetPointer()[i]; }. char & operator[](Ssiz_t i); { AssertElement(i); return GetPointer()[i]; }. char operator[](Ssiz_t i) const; { AssertElement(i); return GetPointer()[i]; }. char & operator()(Ssiz_t i). char operator()(Ssiz_t i) const. const char * Data() const. Ssiz_t Length() const; { return fExtent; }. Bool_t IsNull() const; For detecting null substrings. { return fBegin == kNPOS; }. Ssiz_t Align(Ssiz_t s); { return (s + (kAlignment-1)) & ~(kAlignment-1); }. Ssiz_t Recommend(Ssiz_t s); { return (s < kMinCap ? kMinCap : Align(s+1)) - 1; }. Bool_t IsLong() const; { return Bool_t(fRep.fShort.fSize & kShortMask); }. void SetShortSize(Ssiz_t s); { fRep.fShort.fSize = (unsigned char)(s << 1); }. Ssiz_t GetShortSize() const; { return fRep.fShort.fSize >> 1; }. void SetLongSize(Ssiz_t s); { fRep.fLong.fSize = s; }. Ssiz_t GetLongSize() const; { return fRep.fLong.fSize; }. void SetSize(Ssiz_t s); { IsLong() ? SetLongSize(s) : SetShortSize(s); }. void SetLongCap(Ssiz_t s); { fRep.fLong.fCap = kLongMask | s; }. Ssiz_t GetLongCap() const; { return fRep.fLong.fCap & ~kLongMask; }. void SetLongPointer(char* p); { fRep.fLong.fData = p; }. char * GetLongPointer(); { return fRep.fLong.fData; }. const char * GetLongPointer() const; { return fRep.fLong.fData; }. char * GetShortPointer(); { return fRep.fShort.fData; }. const cha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TString.html:22551,detect,detecting,22551,root/html532/TString.html,https://root.cern,https://root.cern/root/html532/TString.html,2,['detect'],['detecting']
Safety,", s.Data(), TMath::Min(s.Length(), n2)); }. TString & ReplaceAll(const TString& s1, const TString& s2); { return ReplaceAll(s1.Data(), s1.Length(), s2.Data(), s2.Length()) ; }. TString & ReplaceAll(const TString& s1, const char* s2); { return ReplaceAll(s1.Data(), s1.Length(), s2, s2 ? strlen(s2) : 0); }. TString & ReplaceAll(const char* s1, const TString& s2); { return ReplaceAll(s1, s1 ? strlen(s1) : 0, s2.Data(), s2.Length()); }. TString & ReplaceAll(const char* s1, const char* s2); { return ReplaceAll(s1, s1 ? strlen(s1) : 0, s2, s2 ? strlen(s2) : 0); }. char & operator()(Ssiz_t i); { return GetPointer()[i]; }. char operator()(Ssiz_t i) const; { return GetPointer()[i]; }. char & operator[](Ssiz_t i); { AssertElement(i); return GetPointer()[i]; }. char operator[](Ssiz_t i) const; { AssertElement(i); return GetPointer()[i]; }. char & operator()(Ssiz_t i). char operator()(Ssiz_t i) const. const char * Data() const. Ssiz_t Length() const; { return fExtent; }. Bool_t IsNull() const; For detecting null substrings. { return fBegin == kNPOS; }. TString(const char* a1, Ssiz_t n1, const char* a2, Ssiz_t n2); Special concatenation constructor. Ssiz_t Align(Ssiz_t s); { return (s + (kAlignment-1)) & ~(kAlignment-1); }. Ssiz_t Recommend(Ssiz_t s); { return (s < kMinCap ? kMinCap : Align(s+1)) - 1; }. Bool_t IsLong() const; { return Bool_t(fRep.fShort.fSize & kShortMask); }. void SetShortSize(Ssiz_t s); { fRep.fShort.fSize = (unsigned char)(s << 1); }. Ssiz_t GetShortSize() const; { return fRep.fShort.fSize >> 1; }. void SetLongSize(Ssiz_t s); { fRep.fLong.fSize = s; }. Ssiz_t GetLongSize() const; { return fRep.fLong.fSize; }. void SetSize(Ssiz_t s); { IsLong() ? SetLongSize(s) : SetShortSize(s); }. void SetLongCap(Ssiz_t s); { fRep.fLong.fCap = kLongMask | s; }. Ssiz_t GetLongCap() const; { return fRep.fLong.fCap & ~kLongMask; }. void SetLongPointer(char* p); { fRep.fLong.fData = p; }. char * GetLongPointer(); { return fRep.fLong.fData; }. const char * GetLongPointer() const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TString.html:22489,detect,detecting,22489,root/html530/TString.html,https://root.cern,https://root.cern/root/html530/TString.html,1,['detect'],['detecting']
Safety,", stderr) to the specified file. ;  ; TFileHandler * RemoveFileHandler (TFileHandler *fh) override;  Remove a file handler from the list of file handlers. ;  ; TSignalHandler * RemoveSignalHandler (TSignalHandler *sh) override;  Remove a signal handler from list of signal handlers. ;  ; TTimer * RemoveTimer (TTimer *ti) override;  Remove timer from list of system timers. ;  ; int Rename (const char *from, const char *to) override;  Rename a file. Returns 0 when successful, -1 in case of failure. ;  ; void ResetSignal (ESignals sig, Bool_t reset=kTRUE) override;  If reset is true reset the signal handler for the specified signal to the default handler, else restore previous behaviour. ;  ; void ResetSignals () override;  Reset signals handlers to previous behaviour. ;  ; Int_t Select (TFileHandler *fh, Long_t timeout) override;  Select on the file descriptor related to file handler h. ;  ; Int_t Select (TList *active, Long_t timeout) override;  Select on file descriptors. The timeout to is in millisec. ;  ; int SendBuf (int sock, const void *buffer, int length) override;  Send a buffer headed by a length indicator. ;  ; int SendRaw (int sock, const void *buffer, int length, int flag) override;  Send exactly length bytes from buffer. ;  ; void SetDynamicPath (const char *path) override;  Set the dynamic path to a new value. ;  ; void Setenv (const char *name, const char *value) override;  Set environment variable. ;  ; Int_t SetFPEMask (Int_t mask=kDefaultMask) override;  Set which conditions trigger a floating point exception. ;  ; void SetGUIThreadMsgHandler (ThreadMsgFunc_t func);  Set the (static part of) the event handler func for GUI messages. ;  ; int SetNonBlock (int fd);  Make descriptor fd non-blocking. ;  ; void SetProgname (const char *name) override;  Set the application name (from command line, argv[0]) and copy it in gProgName. ;  ; int SetSockOpt (int sock, int opt, int val) override;  Set socket option. ;  ; void Sleep (UInt_t milliSec) override;  Slee",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTWinNTSystem.html:11428,timeout,timeout,11428,doc/master/classTWinNTSystem.html,https://root.cern,https://root.cern/doc/master/classTWinNTSystem.html,1,['timeout'],['timeout']
Safety,", these has to be computed in order to fit the mother ;  ; void GetMeshNumbers (Int_t &nvert, Int_t &nsegs, Int_t &npols) const override;  Returns numbers of vertices, segments and polygons composing the shape mesh. ;  ; Int_t GetNmeshVertices () const override;  ; TGeoScale * GetScale () const;  ; TGeoShape * GetShape () const;  ; void InspectShape () const override;  print shape parameters ;  ; TClass * IsA () const override;  ; Bool_t IsAssembly () const override;  Returns true if the scaled shape is an assembly. ;  ; Bool_t IsCylType () const override;  ; Bool_t IsReflected () const override;  Check if the scale transformation is a reflection. ;  ; TBuffer3D * MakeBuffer3D () const override;  Creates a TBuffer3D describing this shape. ;  ; Double_t Safety (const Double_t *point, Bool_t in=kTRUE) const override;  computes the closest distance from given point to this shape, according to option. ;  ; void Safety_v (const Double_t *points, const Bool_t *inside, Double_t *safe, Int_t vecsize) const override;  Compute safe distance from each of the points in the input array. ;  ; void SavePrimitive (std::ostream &out, Option_t *option="""") override;  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void SetPoints (Double_t *points) const override;  Mesh points for scaled shapes. ;  ; void SetPoints (Float_t *points) const override;  Mesh points for scaled shapes. ;  ; void SetScale (TGeoScale *scale);  ; void SetSegsAndPols (TBuffer3D &buffer) const override;  Fill TBuffer3D structure for segments and polygons. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TGeoBBox;  TGeoBBox ();  ;  TGeoBBox (const char *name, Double_t dx, Double_t dy, Double_t dz, Double_t *origin=nullptr);  ;  TGeoBBox (Double_t *param);  ;  TGeoBBox (Double_t dx, Double_t dy, Double_t dz, Double_t *origin=nullptr);  ;  ~TGeoBBox () override",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoScaledShape.html:4070,safe,safe,4070,doc/master/classTGeoScaledShape.html,https://root.cern,https://root.cern/doc/master/classTGeoScaledShape.html,2,['safe'],['safe']
Safety,",-2,2);; 2819 f3->SetClippingBoxOn(0,0,0);; 2820 f3->SetFillColor(30);; 2821 f3->SetLineColor(15);; 2822 f3->Draw(""FBBB"");; 2823}; 2824End_Macro; 2825 ; 2826 ; 2827\anchor HP28; 2828### Associated functions drawing; 2829 ; 2830 ; 2831An associated function is created by `TH1::Fit`. More than on fitted; 2832function can be associated with one histogram (see `TH1::Fit`).; 2833 ; 2834A `TF1` object `f1` can be added to the list of associated; 2835functions of an histogram `h` without calling `TH1::Fit`; 2836simply doing:; 2837 ; 2838 h->GetListOfFunctions()->Add(f1);; 2839 ; 2840or; 2841 ; 2842 h->GetListOfFunctions()->Add(f1,someoption);; 2843 ; 2844To retrieve a function by name from this list, do:; 2845 ; 2846 TF1 *f1 = (TF1*)h->GetListOfFunctions()->FindObject(name);; 2847 ; 2848or; 2849 ; 2850 TF1 *f1 = h->GetFunction(name);; 2851 ; 2852Associated functions are automatically painted when an histogram is drawn.; 2853To avoid the painting of the associated functions the option `HIST`; 2854should be added to the list of the options used to paint the histogram.; 2855 ; 2856 ; 2857\anchor HP29; 2858### Drawing using OpenGL; 2859 ; 2860 ; 2861The class `TGLHistPainter` allows to paint data set using the OpenGL 3D; 2862graphics library. The plotting options start with `GL` keyword.; 2863In addition, in order to inform canvases that OpenGL should be used to render; 28643D representations, the following option should be set:; 2865 ; 2866 gStyle->SetCanvasPreferGL(true);; 2867 ; 2868 ; 2869\anchor HP29a; 2870#### General information: plot types and supported options; 2871 ; 2872The following types of plots are provided:; 2873 ; 2874For lego plots the supported options are:; 2875 ; 2876| Option | Description |; 2877|----------|-------------------------------------------------------------------|; 2878| ""GLLEGO"" | Draw a lego plot. It works also for `TH2Poly`.|; 2879| ""GLLEGO2""| Bins with color levels.|; 2880| ""GLLEGO3""| Cylindrical bars.|; 2881 ; 2882 ; 2883 ; 2884Lego painte",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THistPainter_8cxx_source.html:113533,avoid,avoid,113533,doc/master/THistPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html,1,['avoid'],['avoid']
Safety,",; 19944 config_options[DOCUMENT_ROOT].name,; 19945 ebuf);; 19946 }; 19947 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 19948 ; 19949 free_context(ctx);; 19950 pthread_setspecific(sTlsKey, NULL);; 19951 return NULL;; 19952 }; 19953 ; 19954 /* state remains valid */; 19955 ctx->lua_background_state = (void *)state;; 19956 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 19957 ; 19958 } else {; 19959 ctx->lua_background_state = 0;; 19960 }; 19961#endif; 19962 ; 19963 /* Step by step initialization of ctx - depending on build options */; 19964#if !defined(NO_FILESYSTEMS); 19965 if (!set_gpass_option(ctx, NULL)) {; 19966 const char *err_msg = ""Invalid global password file"";; 19967 /* Fatal error - abort start. */; 19968 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 19969 ; 19970 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19971 mg_snprintf(NULL,; 19972 NULL, /* No truncation check for error buffers */; 19973 error->text,; 19974 error->text_buffer_size,; 19975 ""%s"",; 19976 err_msg);; 19977 }; 19978 free_context(ctx);; 19979 pthread_setspecific(sTlsKey, NULL);; 19980 return NULL;; 19981 }; 19982#endif; 19983 ; 19984#if defined(USE_MBEDTLS); 19985 if (!mg_sslctx_init(ctx, NULL)) {; 19986 const char *err_msg = ""Error initializing SSL context"";; 19987 /* Fatal error - abort start. */; 19988 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 19989 ; 19990 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19991 mg_snprintf(NULL,; 19992 NULL, /* No truncation check for error buffers */; 19993 error->text,; 19994 error->text_buffer_size,; 19995 ""%s"",; 19996 err_msg);; 19997 }; 19998 free_context(ctx);; 19999 pthread_setspecific(sTlsKey, NULL);; 20000 return NULL;; 20001 }; 20002 ; 20003#elif !defined(NO_SSL); 20004 if (!init_ssl_ctx(ctx, NULL)) {; 20005 const char *err_msg = ""Error initializing SSL context"";; 20006 /* Fatal error - abort start. */; 20007 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20008 ; 20009 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20010 mg_snpri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:597280,abort,abort,597280,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['abort'],['abort']
Safety,",; 19945 config_options[DOCUMENT_ROOT].name,; 19946 ebuf);; 19947 }; 19948 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 19949 ; 19950 free_context(ctx);; 19951 pthread_setspecific(sTlsKey, NULL);; 19952 return NULL;; 19953 }; 19954 ; 19955 /* state remains valid */; 19956 ctx->lua_background_state = (void *)state;; 19957 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 19958 ; 19959 } else {; 19960 ctx->lua_background_state = 0;; 19961 }; 19962#endif; 19963 ; 19964 /* Step by step initialization of ctx - depending on build options */; 19965#if !defined(NO_FILESYSTEMS); 19966 if (!set_gpass_option(ctx, NULL)) {; 19967 const char *err_msg = ""Invalid global password file"";; 19968 /* Fatal error - abort start. */; 19969 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 19970 ; 19971 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19972 mg_snprintf(NULL,; 19973 NULL, /* No truncation check for error buffers */; 19974 error->text,; 19975 error->text_buffer_size,; 19976 ""%s"",; 19977 err_msg);; 19978 }; 19979 free_context(ctx);; 19980 pthread_setspecific(sTlsKey, NULL);; 19981 return NULL;; 19982 }; 19983#endif; 19984 ; 19985#if defined(USE_MBEDTLS); 19986 if (!mg_sslctx_init(ctx, NULL)) {; 19987 const char *err_msg = ""Error initializing SSL context"";; 19988 /* Fatal error - abort start. */; 19989 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 19990 ; 19991 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19992 mg_snprintf(NULL,; 19993 NULL, /* No truncation check for error buffers */; 19994 error->text,; 19995 error->text_buffer_size,; 19996 ""%s"",; 19997 err_msg);; 19998 }; 19999 free_context(ctx);; 20000 pthread_setspecific(sTlsKey, NULL);; 20001 return NULL;; 20002 }; 20003 ; 20004#elif !defined(NO_SSL); 20005 if (!init_ssl_ctx(ctx, NULL)) {; 20006 const char *err_msg = ""Error initializing SSL context"";; 20007 /* Fatal error - abort start. */; 20008 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20009 ; 20010 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20011 mg_snpri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:597313,abort,abort,597313,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['abort'],['abort']
Safety,",py to each corner. Double_t DistFromInsideS(const Double_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); Compute distance from inside point to surface of the tube segment (static); Boundary safe algorithm.; Do Z. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the tube segment; Boundary safe algorithm. Double_t DistFromOutsideS(const Double_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); Static method to compute distance to arbitrary tube segment from outside point; Boundary safe algorithm. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube segment; fist localize point w.r.t tube. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this tube segment shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. Returns pointer; to created division cell volume in case of Z divisions. For radialdivision; creates all volumes with different shapes and returns pointer to volume that; was divided. In case a wrong division axis is supplied, returns pointer to; volume that was divided. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoTubeSeg.html:17177,safe,safe,17177,root/html534/TGeoTubeSeg.html,https://root.cern,https://root.cern/root/html534/TGeoTubeSeg.html,3,['safe'],['safe']
Safety,"- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. void InspectShape() const; Inspect the PGON parameters. TBuffer3D * MakeBuffer3D() const; Creates a TBuffer3D describing *this* shape.; Coordinates are in local reference frame. void SetSegsAndPols(TBuffer3D& buff) const; Fill TBuffer3D structure for segments and polygons. Double_t Rpg(Double_t z, Int_t ipl, Bool_t inner, Double_t& a, Double_t& b) const; Computes projected pgon radius (inner or outer) corresponding to a given Z; value. Fills corresponding coefficients of:; Rpg(z) = a + b*z; Note: ipl must be in range [0,fNz-2]. Double_t Rproj(Double_t z, Double_t* point, Double_t* dir, Double_t cphi, Double_t sphi, Double_t& a, Double_t& b) const; Computes projected distance at a given Z for a given ray inside a given sector; and fills coefficients:; Rproj = a + b*z. Double_t SafetyToSegment(Double_t* point, Int_t ipl, Int_t iphi, Bool_t in, Double_t safphi, Double_t safmin = TGeoShape::Big()) const; Compute safety from POINT to segment between planes ipl, ipl+1 within safmin. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape, according; to option. The matching point on the shape is stored in spoint. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetDimensions(Double_t* param); Set PGON dimensions starting from an array. void SetPoints(Double_t* points) const; create polygone mesh points. void SetPoints(Float_t* points) const; create polygone mesh points. void GetMeshNumbers(Int_t& nvert, Int_t& nsegs, Int_t& npols) const; Returns numbers of vertices, segments and polygons composing the shape mesh. Int_t GetNmeshVertices() const; Return number of vertices of the mesh representation. void Sizeof3D() const; fill size of this 3-D object; TVirtualGeoPainter *painter = gGeoManager->GetGeomPainter();; if (!painte",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoPgon.html:17990,Safe,SafetyToSegment,17990,root/html528/TGeoPgon.html,https://root.cern,https://root.cern/root/html528/TGeoPgon.html,6,"['Safe', 'safe']","['SafetyToSegment', 'safety']"
Safety,"-----------------------------------------------------------------------; ; # Construct a simultaneous pdf using category sample as index: associate model; # with the physics state and model_ctl with the control state; simPdf = ROOT.RooSimultaneous(""simPdf"", ""simultaneous pdf"", {""physics"": model, ""control"": model_ctl}, sample); ; # Perform a simultaneous fit; # ---------------------------------------------------; ; # Perform simultaneous fit of model to data and model_ctl to data_ctl; fitResult = simPdf.fitTo(combData, PrintLevel=-1, Save=True); fitResult.Print(); ; # Plot model slices on data slices; # ----------------------------------------------------------------; ; # Make a frame for the physics sample; frame1 = x.frame(Title=""Physics sample""); ; # Plot all data tagged as physics sample; combData.plotOn(frame1, Cut=""sample==sample::physics""); ; # Plot ""physics"" slice of simultaneous pdf.; # NB: You *must* project the sample index category with data using ProjWData as; # a RooSimultaneous makes no prediction on the shape in the index category and; # can thus not be integrated. In other words: Since the PDF doesn't know the; # number of events in the different category states, it doesn't know how much; # of each component it has to project out. This info is read from the data.; simPdf.plotOn(frame1, Slice=(sample, ""physics""), ProjWData=(sample, combData)); simPdf.plotOn(frame1, Slice=(sample, ""physics""), Components=""px"", ProjWData=(sample, combData), LineStyle=""--""); ; # The same plot for the control sample slice. We do this with a different; # approach this time, for illustration purposes. Here, we are slicing the; # dataset and then use the data slice for the projection, because then the; # RooFit::Slice() becomes unnecessary. This approach is more general,; # because you can plot sums of slices by using logical or in the Cut(); # command.; frame2 = x.frame(Title=""Control sample""); slicedData = combData.reduce(Cut=""sample==sample::control""); slicedData.plotOn(fr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf501__simultaneouspdf_8py.html:3536,predict,prediction,3536,doc/master/rf501__simultaneouspdf_8py.html,https://root.cern,https://root.cern/doc/master/rf501__simultaneouspdf_8py.html,1,['predict'],['prediction']
Safety,"-------------------------------------------------------; ; # Read parameters from file; params.readFromFile(""rf505_asciicfg_example.txt""); params.Print(""v""); ; configFile = ROOT.gROOT.GetTutorialDir().Data() + ""/roofit/rf505_asciicfg.txt""; ; # Read parameters from section 'Section2' of file; params.readFromFile(configFile, """", ""Section2""); params.Print(""v""); ; # Read parameters from section 'Section3' of file. Mark all; # variables that were processed with the ""READ"" attribute; params.readFromFile(configFile, ""READ"", ""Section3""); ; # Print the list of parameters that were not read from Section3; print(""The following parameters of the were _not_ read from Section3: "", params.selectByAttrib(""READ"", False)); ; # Read parameters from section 'Section4' of file, contains; # 'include file' statement of rf505_asciicfg_example.txt; # so that we effective read the same; params.readFromFile(configFile, """", ""Section4""); params.Print(""v""); [#0] WARNING:InputArguments -- The parameter 's' with range [-10, 10] of the RooGaussian 'g' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; 1) 0x803b610 RooRealVar:: f = 0.50733 +/- 0.020971 L(0 - 1) ""f""; 2) 0x79b4c50 RooRealVar:: m = 0.0064018 +/- 0.053686 L(-10 - 10) ""m""; 3) 0x7f83920 RooRealVar:: p0 = 0.0073509 +/- 0.0078312 L(0 - 1) ""p0""; 4) 0x47c4aa0 RooRealVar:: s = 0.96516 +/- 0.047052 L(-10 - 10) ""s""; [#1] INFO:InputArguments -- RooArgSet::readFromStream(parameters): processing include file rf505_asciicfg_examp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf505__asciicfg_8py.html:2359,safe,safe,2359,doc/master/rf505__asciicfg_8py.html,https://root.cern,https://root.cern/doc/master/rf505__asciicfg_8py.html,1,['safe'],['safe']
Safety,"--------------; ; # Construct a simultaneous pdf with the following form; #; # model_run1(x) = f*gauss_run1(x,m_run1,s) + (1-f)*poly; # model_run2(x) = f*gauss_run2(x,m_run2,s) + (1-f)*poly; # simpdf(x,c) = model_run1(x) if c==""run1""; # = model_run2(x) if c==""run2""; #; # Returned pdf is owned by the workspace; model_sim = sct.build(""model_sim"", ""model"", SplitParam=(""m"", ""c"")); ; # Print tree structure of model; model_sim.Print(""t""); ; # Adjust model_sim parameters in workspace; w.var(""m_run1"").setVal(-3); w.var(""m_run2"").setVal(+3); ; # Print contents of workspace; w.Print(""v""); ; # Build a simultaneous model with product split; # -----------------------------------------------------------------------------------------; ; # Build another simultaneous pdf using a composite split in states c X d; model_sim2 = sct.build(""model_sim2"", ""model"", SplitParam=(""p0"", ""c,d"")); ; # Print tree structure of self model; model_sim2.Print(""t""); [#0] WARNING:InputArguments -- The parameter 's' with range [-10, 10] of the RooGaussian 'g' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooCategory::d; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooAddPdf::model; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooGaussian::g; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::x; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::m; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::s; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::f; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooPolynomial::p; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::p0; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooCategory::c; Splitrule for p.d.f model with state list ; parameter m is split with constraint in categories (c); [#1] INFO:ObjectHandl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf504__simwstool_8py.html:2631,safe,safe,2631,doc/master/rf504__simwstool_8py.html,https://root.cern,https://root.cern/doc/master/rf504__simwstool_8py.html,1,['safe'],['safe']
Safety,"---------; ; # Construct sum of models on one go using recursive fraction interpretations; #; # model2 = bkg + (sig1 + sig2); #; model2 = ROOT.RooAddPdf(""model"", ""g1+g2+a"", [bkg, sig1, sig2], [bkgfrac, sig1frac], True); ; # NB: Each coefficient is interpreted as the fraction of the; # left-hand component of the i-th recursive sum, i.e.; #; # sum4 = A + ( B + ( C + D) with fraction fA, and fC expands to; #; # sum4 = fA*A + (1-fA)*(fB*B + (1-fB)*(fC*C + (1-fC)*D)); ; # Plot recursive addition model; # ---------------------------------------------------------; model2.plotOn(xframe, LineColor=""r"", LineStyle=""--""); model2.plotOn(xframe, Components={bkg, sig2}, LineColor=""r"", LineStyle=""--""); model2.Print(""t""); ; # Draw the frame on the canvas; c = ROOT.TCanvas(""rf201_composite"", ""rf201_composite"", 600, 600); ROOT.gPad.SetLeftMargin(0.15); xframe.GetYaxis().SetTitleOffset(1.4); xframe.Draw(); ; c.SaveAs(""rf201_composite.png""); [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) indirectly selected PDF components: (); [#1] INFO:Plotting -- RooAbsPdf::plotOn(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf201__composite_8py.html:3607,safe,safe,3607,doc/master/rf201__composite_8py.html,https://root.cern,https://root.cern/doc/master/rf201__composite_8py.html,1,['safe'],['safe']
Safety,"-----; ; # Plot single background component specified by name; model.plotOn(xframe2, Components=""bkg"", LineColor=""c""); ; # Plot multiple background components specified by name; model.plotOn(xframe2, Components=""bkg1,sig2"", LineStyle="":"", LineColor=""c""); ; # Plot multiple background components specified by regular expression on; # name; model.plotOn(xframe2, Components=""sig*"", LineStyle=""--"", LineColor=""c""); ; # Plot multiple background components specified by multiple regular; # expressions on name; model.plotOn(xframe2, Invisible=True, Components=""bkg1,sig*"", LineStyle=""--"", LineColor=""y""); ; # Draw the frame on the canvas; c = ROOT.TCanvas(""rf205_compplot"", ""rf205_compplot"", 800, 400); c.Divide(2); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); xframe.GetYaxis().SetTitleOffset(1.4); xframe.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); xframe2.GetYaxis().SetTitleOffset(1.4); xframe2.Draw(); ; c.SaveAs(""rf205_compplot.png""); [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) indirectly selected PDF components: (bkg1,bkg2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) indirectly selected PDF components: (bkg); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg,sig2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) indirectly selected PDF components: (bkg1,bkg2,sig); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) indirectly selected PDF components: (bkg1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf205__compplot_8py.html:4167,safe,safe,4167,doc/master/rf205__compplot_8py.html,https://root.cern,https://root.cern/doc/master/rf205__compplot_8py.html,1,['safe'],['safe']
Safety,"-32-00"");; 1596 return 15;; 1597}; 1598 ; 1599////////////////////////////////////////////////////////////////////////////////; 1600/// Set default resize increment for all TStrings. Default is 16.; 1601 ; 1602Ssiz_t TString::ResizeIncrement(Ssiz_t); 1603{; 1604 ::Obsolete(""TString::ResizeIncrement"", ""v5-30-00"", ""v5-32-00"");; 1605 return 16;; 1606}; 1607 ; 1608////////////////////////////////////////////////////////////////////////////////; 1609/// Set maximum space that may be wasted in a string before doing a resize.; 1610/// Default is 15.; 1611 ; 1612Ssiz_t TString::MaxWaste(Ssiz_t); 1613{; 1614 ::Obsolete(""TString::MaxWaste"", ""v5-30-00"", ""v5-32-00"");; 1615 return 15;; 1616}; 1617 ; 1618/** \class TSubString; 1619A zero length substring is legal. It can start; 1620at any character. It is considered to be ""pointing""; 1621to just before the character.; 1622 ; 1623A ""null"" substring is a zero length substring that; 1624starts with the nonsense index kNPOS. It can; 1625be detected with the member function IsNull().; 1626*/; 1627 ; 1628////////////////////////////////////////////////////////////////////////////////; 1629/// Private constructor.; 1630 ; 1631TSubString::TSubString(const TString &str, Ssiz_t start, Ssiz_t nextent); 1632 : fStr((TString&)str), fBegin(start), fExtent(nextent); 1633{; 1634}; 1635 ; 1636////////////////////////////////////////////////////////////////////////////////; 1637/// Return sub-string of string starting at start with length len.; 1638 ; 1639TSubString TString::operator()(Ssiz_t start, Ssiz_t len) const; 1640{; 1641 if (start < Length() && len > 0) {; 1642 if (start+len > Length()); 1643 len = Length() - start;; 1644 } else {; 1645 start = kNPOS;; 1646 len = 0;; 1647 }; 1648 return TSubString(*this, start, len);; 1649}; 1650 ; 1651////////////////////////////////////////////////////////////////////////////////; 1652/// Returns a substring matching ""pattern"", or the null substring; 1653/// if there is no such match. It would be nice if",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TString_8cxx_source.html:49478,detect,detected,49478,doc/master/TString_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html,1,['detect'],['detected']
Safety,"->AddLast(fVolumes->At(i));; 1545 }; 1546 fClosed = kTRUE;; 1547 if (fParallelWorld) {; 1548 if (fgVerboseLevel > 0); 1549 Info(""CloseGeometry"", ""Recreating parallel world %s ..."", fParallelWorld->GetName());; 1550 fParallelWorld->CloseGeometry();; 1551 }; 1552 ; 1553 if (fgVerboseLevel > 0); 1554 Info(""CloseGeometry"", ""%i nodes/ %i volume UID's in %s"", fNNodes, fUniqueVolumes->GetEntriesFast() - 1,; 1555 GetTitle());; 1556 if (fgVerboseLevel > 0); 1557 Info(""CloseGeometry"", ""----------------modeler ready----------------"");; 1558 return;; 1559 }; 1560 ; 1561 // Create a geometry navigator if not present; 1562 if (!GetCurrentNavigator()); 1563 fCurrentNavigator = AddNavigator();; 1564 nnavigators = GetListOfNavigators()->GetEntriesFast();; 1565 SelectTrackingMedia();; 1566 CheckGeometry();; 1567 if (fgVerboseLevel > 0); 1568 Info(""CloseGeometry"", ""Counting nodes..."");; 1569 fNNodes = CountNodes();; 1570 fNLevel = fMasterVolume->CountNodes(1, 3) + 1;; 1571 if (fNLevel < 30); 1572 fNLevel = 100;; 1573 ; 1574 // BuildIdArray();; 1575 // avoid voxelization if requested to speed up geometry startup; 1576 if (!opt.Contains(""nv"")) {; 1577 Voxelize(""ALL"");; 1578 } else {; 1579 TGeoVolume *vol;; 1580 TIter next(fVolumes);; 1581 while ((vol = (TGeoVolume *)next())) {; 1582 vol->SortNodes();; 1583 }; 1584 }; 1585 if (fgVerboseLevel > 0); 1586 Info(""CloseGeometry"", ""Building cache..."");; 1587 CountLevels();; 1588 for (Int_t i = 0; i < nnavigators; i++) {; 1589 nav = (TGeoNavigator *)GetListOfNavigators()->At(i);; 1590 nav->GetCache()->BuildInfoBranch();; 1591 if (nodeid); 1592 nav->GetCache()->BuildIdArray();; 1593 }; 1594 fClosed = kTRUE;; 1595 if (fgVerboseLevel > 0) {; 1596 Info(""CloseGeometry"", ""%i nodes/ %i volume UID's in %s"", fNNodes, fUniqueVolumes->GetEntriesFast() - 1,; 1597 GetTitle());; 1598 Info(""CloseGeometry"", ""----------------modeler ready----------------"");; 1599 }; 1600}; 1601 ; 1602////////////////////////////////////////////////////////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoManager_8cxx_source.html:58564,avoid,avoid,58564,doc/master/TGeoManager_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html,1,['avoid'],['avoid']
Safety,"->GetD() and/or using pseudo-experiments. ; Covariance matrices on the measured spectrum (for either the total uncertainties or individual sources of uncertainties) can be propagated to covariance matrices using the GetUnfoldCovMatrix method, which uses pseudo experiments for the propagation. In addition, GetAdetCovMatrix allows for the propagation of the statistical uncertainties on the response matrix using pseudo experiments. The covariance matrix corresponding to Bcov is also computed as described in Nucl. Instrum. Meth. A372, 469 (1996) [hep-ph/9509307] and can be obtained from tsvdunf->GetXtau() and its (regularisation independent) inverse from tsvdunf->GetXinv(). The distribution of singular values can be retrieved using tsvdunf->GetSV(). ; See also the tutorial for a toy example. ; Definition at line 46 of file TSVDUnfold.h. Public Member Functions;  TSVDUnfold (const TH1D *bdat, const TH1D *bini, const TH1D *xini, const TH2D *Adet);  Alternative constructor User provides data and MC test spectra, as well as detector response matrix, diagonal covariance matrix of measured spectrum built from the uncertainties on measured spectrum. ;  ;  TSVDUnfold (const TH1D *bdat, TH2D *Bcov, const TH1D *bini, const TH1D *xini, const TH2D *Adet);  Default constructor Initialisation of TSVDUnfold User provides data and MC test spectra, as well as detector response matrix and the covariance matrix of the measured distribution. ;  ;  TSVDUnfold (const TSVDUnfold &other);  Copy constructor. ;  ;  ~TSVDUnfold () override;  Destructor. ;  ; Double_t ComputeChiSquared (const TH1D &truspec, const TH1D &unfspec);  Helper routine to compute chi-squared between distributions using the computed inverse of the covariance matrix for the unfolded spectrum as given in paper. ;  ; TH2D * GetAdetCovMatrix (Int_t ntoys, Int_t seed=1);  Determine covariance matrix of unfolded spectrum from finite statistics in response matrix using pseudo experiments ""ntoys"" - number of pseudo experiments use",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSVDUnfold.html:3578,detect,detector,3578,doc/master/classTSVDUnfold.html,https://root.cern,https://root.cern/doc/master/classTSVDUnfold.html,1,['detect'],['detector']
Safety,"->GetListOfGeometries()->Remove(this);; 513 gROOT->GetListOfBrowsables()->Remove(this);; 514 }; 515 // TSeqCollection *brlist = gROOT->GetListOfBrowsers();; 516 // TIter next(brlist);; 517 // TBrowser *browser = 0;; 518 // while ((browser=(TBrowser*)next())) browser->RecursiveRemove(this);; 519 ClearThreadsMap();; 520 ClearThreadData();; 521 delete TGeoBuilder::Instance(this);; 522 if (fBits); 523 delete[] fBits;; 524 SafeDelete(fNodes);; 525 SafeDelete(fTopNode);; 526 if (fOverlaps) {; 527 fOverlaps->Delete();; 528 SafeDelete(fOverlaps);; 529 }; 530 if (fRegions) {; 531 fRegions->Delete();; 532 SafeDelete(fRegions);; 533 }; 534 if (fMaterials) {; 535 fMaterials->Delete();; 536 SafeDelete(fMaterials);; 537 }; 538 SafeDelete(fElementTable);; 539 if (fMedia) {; 540 fMedia->Delete();; 541 SafeDelete(fMedia);; 542 }; 543 if (fHashVolumes) {; 544 fHashVolumes->Clear(""nodelete"");; 545 SafeDelete(fHashVolumes);; 546 }; 547 if (fHashGVolumes) {; 548 fHashGVolumes->Clear(""nodelete"");; 549 SafeDelete(fHashGVolumes);; 550 }; 551 if (fHashPNE) {; 552 fHashPNE->Delete();; 553 SafeDelete(fHashPNE);; 554 }; 555 if (fArrayPNE) {; 556 delete fArrayPNE;; 557 }; 558 if (fVolumes) {; 559 fVolumes->Delete();; 560 SafeDelete(fVolumes);; 561 }; 562 if (fShapes) {; 563 fShapes->Delete();; 564 SafeDelete(fShapes);; 565 }; 566 if (fPhysicalNodes) {; 567 fPhysicalNodes->Delete();; 568 SafeDelete(fPhysicalNodes);; 569 }; 570 if (fMatrices) {; 571 fMatrices->Delete();; 572 SafeDelete(fMatrices);; 573 }; 574 if (fTracks) {; 575 fTracks->Delete();; 576 SafeDelete(fTracks);; 577 }; 578 SafeDelete(fUniqueVolumes);; 579 if (fPdgNames) {; 580 fPdgNames->Delete();; 581 SafeDelete(fPdgNames);; 582 }; 583 if (fGDMLMatrices) {; 584 fGDMLMatrices->Delete();; 585 SafeDelete(fGDMLMatrices);; 586 }; 587 if (fOpticalSurfaces) {; 588 fOpticalSurfaces->Delete();; 589 SafeDelete(fOpticalSurfaces);; 590 }; 591 if (fSkinSurfaces) {; 592 fSkinSurfaces->Delete();; 593 SafeDelete(fSkinSurfaces);; 594 }; 595 if (fBorde",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoManager_8cxx_source.html:22011,Safe,SafeDelete,22011,doc/master/TGeoManager_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html,1,['Safe'],['SafeDelete']
Safety,"->IsCmdThread()) {; 2516 // Why do we have this (which uses the interpreter to funnel the Update(); 2517 // through the main thread) when the gThreadXAR mechanism does seemingly; 2518 // the same?; 2519 gInterpreter->Execute(this, IsA(), ""Update"", """");; 2520 return;; 2521 }; 2522 ; 2523 R__LOCKGUARD(gROOTMutex);; 2524 ; 2525 fUpdating = kTRUE;; 2526 ; 2527 if (!fCanvasImp->PerformUpdate(kFALSE)) {; 2528 ; 2529 if (!IsBatch()) FeedbackMode(kFALSE); // Goto double buffer mode; 2530 ; 2531 if (!UseGL() || fGLDevice == -1) PaintModified(); // Repaint all modified pad's; 2532 ; 2533 Flush(); // Copy all pad pixmaps to the screen; 2534 ; 2535 SetCursor(kCross);; 2536 }; 2537 ; 2538 fUpdating = kFALSE;; 2539}; 2540 ; 2541////////////////////////////////////////////////////////////////////////////////; 2542/// Asynchronous pad update.; 2543/// In case of web-based canvas triggers update of the canvas on the client side,; 2544/// but does not wait that real update is completed. Avoids blocking of caller thread.; 2545/// Have to be used if called from other web-based widget to avoid logical dead-locks.; 2546/// In case of normal canvas just canvas->Update() is performed.; 2547 ; 2548void TCanvas::UpdateAsync(); 2549{; 2550 fUpdated = kTRUE;; 2551 ; 2552 if (IsWeb()); 2553 fCanvasImp->PerformUpdate(kTRUE);; 2554 else; 2555 Update();; 2556}; 2557 ; 2558////////////////////////////////////////////////////////////////////////////////; 2559/// Used by friend class TCanvasImp.; 2560 ; 2561void TCanvas::DisconnectWidget(); 2562{; 2563 fCanvasID = 0;; 2564 fContextMenu = nullptr;; 2565}; 2566 ; 2567////////////////////////////////////////////////////////////////////////////////; 2568/// Check whether this canvas is to be drawn in grayscale mode.; 2569 ; 2570Bool_t TCanvas::IsGrayscale(); 2571{; 2572 return TestBit(kIsGrayscale);; 2573}; 2574 ; 2575////////////////////////////////////////////////////////////////////////////////; 2576/// Set whether this canvas should be painted in gra",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCanvas_8cxx_source.html:82497,Avoid,Avoids,82497,doc/master/TCanvas_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCanvas_8cxx_source.html,1,['Avoid'],['Avoids']
Safety,"->Update();; // picture 2; ps->NewPage();; c1->cd(1);; hpxpy->Draw();; c1->cd(2);; ntuple->Draw(""px"");; c1->Update();; ps->Close();; // invoke Postscript viewer; gSystem->Exec(""gs file.ps"");; }. Making several pictures in the same Postscript file: case 3; This is the recommended way. If the Postscript file name finishes with; ""("", the file remains opened (it is not closed). If the Postscript file name; finishes with "")"" and the file has been opened with ""("", the file is closed.; Example:. {; TCanvas c1(""c1"");; h1.Draw();; c1.Print(""c1.ps(""); // write canvas and keep the ps file open; h2.Draw();; c1.Print(""c1.ps""); // canvas is added to ""c1.ps""; h3.Draw();; c1.Print(""c1.ps)""); // canvas is added to ""c1.ps"" and ps file is closed; }. The TCanvas::Print(""file.ps("") mechanism is very useful, but it can; be a little inconvenient to have the action of opening/closing a file being; atomic with printing a page. Particularly if pages are being generated in some; loop one needs to detect the special cases of first and last page and then; munge the argument to Print() accordingly.; The ""["" and ""]"" can be used instead of ""("" and "")"" as shown below.; Example:. c1.Print(""file.ps[""); // No actual print, just open file.ps; for (int i=0; i<10; ++i) {; // fill canvas for context i; // ...; c1.Print(""file.ps""); // Actually print canvas to the file; }; c1.Print(""file.ps]""); // No actual print, just close the file. Color Model; TPostScript support two color model RGB and CMYK. CMY and CMYK models are; subtractive color models unlike RGB which is an additive. They are mainly; used for printing purposes. CMY means Cyan Magenta Yellow to convert RGB; to CMY it is enough to do: C=1-R, M=1-G and Y=1-B. CMYK has one more; component K (black). The conversion from RGB to CMYK is:. Double_t Black = TMath::Min(TMath::Min(1-Red,1-Green),1-Blue);; Double_t Cyan = (1-Red-Black)/(1-Black);; Double_t Magenta = (1-Green-Black)/(1-Black);; Double_t Yellow = (1-Blue-Black)/(1-Black);. CMYK add the black c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPostScript.html:5858,detect,detect,5858,root/html528/TPostScript.html,https://root.cern,https://root.cern/root/html528/TPostScript.html,3,['detect'],['detect']
Safety,"->host_name) {; 15713 SSL_set_tlsext_host_name(conn->ssl, client_options->host_name);; 15714 }; 15715 }; 15716 ; 15717 /* Reuse the request timeout for the SSL_Accept/SSL_connect timeout */; 15718 if (conn->dom_ctx->config[REQUEST_TIMEOUT]) {; 15719 /* NOTE: The loop below acts as a back-off, so we can end; 15720 * up sleeping for more (or less) than the REQUEST_TIMEOUT. */; 15721 int to = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]);; 15722 if (to >= 0) {; 15723 timeout = (unsigned)to;; 15724 }; 15725 }; 15726 ; 15727 /* SSL functions may fail and require to be called again:; 15728 * see https://www.openssl.org/docs/manmaster/ssl/SSL_get_error.html; 15729 * Here ""func"" could be SSL_connect or SSL_accept. */; 15730 for (i = 0; i <= timeout; i += 50) {; 15731 ERR_clear_error();; 15732 /* conn->dom_ctx may be changed here (see ssl_servername_callback) */; 15733 ret = func(conn->ssl);; 15734 if (ret != 1) {; 15735 err = SSL_get_error(conn->ssl, ret);; 15736 if ((err == SSL_ERROR_WANT_CONNECT); 15737 || (err == SSL_ERROR_WANT_ACCEPT); 15738 || (err == SSL_ERROR_WANT_READ) || (err == SSL_ERROR_WANT_WRITE); 15739 || (err == SSL_ERROR_WANT_X509_LOOKUP)) {; 15740 if (!STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 15741 /* Don't wait if the server is going to be stopped. */; 15742 break;; 15743 }; 15744 if (err == SSL_ERROR_WANT_X509_LOOKUP) {; 15745 /* Simply retry the function call. */; 15746 mg_sleep(50);; 15747 } else {; 15748 /* Need to retry the function call ""later"".; 15749 * See https://linux.die.net/man/3/ssl_get_error; 15750 * This is typical for non-blocking sockets. */; 15751 struct mg_pollfd pfd;; 15752 int pollres;; 15753 pfd.fd = conn->client.sock;; 15754 pfd.events = ((err == SSL_ERROR_WANT_CONNECT); 15755 || (err == SSL_ERROR_WANT_WRITE)); 15756 ? POLLOUT; 15757 : POLLIN;; 15758 pollres =; 15759 mg_poll(&pfd, 1, 50, &(conn->phys_ctx->stop_flag));; 15760 if (pollres < 0) {; 15761 /* Break if error occured (-1); 15762 * or server shutdown (-2) */; 15763 br",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:464876,timeout,timeout,464876,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety,"->host_name) {; 15714 SSL_set_tlsext_host_name(conn->ssl, client_options->host_name);; 15715 }; 15716 }; 15717 ; 15718 /* Reuse the request timeout for the SSL_Accept/SSL_connect timeout */; 15719 if (conn->dom_ctx->config[REQUEST_TIMEOUT]) {; 15720 /* NOTE: The loop below acts as a back-off, so we can end; 15721 * up sleeping for more (or less) than the REQUEST_TIMEOUT. */; 15722 int to = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]);; 15723 if (to >= 0) {; 15724 timeout = (unsigned)to;; 15725 }; 15726 }; 15727 ; 15728 /* SSL functions may fail and require to be called again:; 15729 * see https://www.openssl.org/docs/manmaster/ssl/SSL_get_error.html; 15730 * Here ""func"" could be SSL_connect or SSL_accept. */; 15731 for (i = 0; i <= timeout; i += 50) {; 15732 ERR_clear_error();; 15733 /* conn->dom_ctx may be changed here (see ssl_servername_callback) */; 15734 ret = func(conn->ssl);; 15735 if (ret != 1) {; 15736 err = SSL_get_error(conn->ssl, ret);; 15737 if ((err == SSL_ERROR_WANT_CONNECT); 15738 || (err == SSL_ERROR_WANT_ACCEPT); 15739 || (err == SSL_ERROR_WANT_READ) || (err == SSL_ERROR_WANT_WRITE); 15740 || (err == SSL_ERROR_WANT_X509_LOOKUP)) {; 15741 if (!STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 15742 /* Don't wait if the server is going to be stopped. */; 15743 break;; 15744 }; 15745 if (err == SSL_ERROR_WANT_X509_LOOKUP) {; 15746 /* Simply retry the function call. */; 15747 mg_sleep(50);; 15748 } else {; 15749 /* Need to retry the function call ""later"".; 15750 * See https://linux.die.net/man/3/ssl_get_error; 15751 * This is typical for non-blocking sockets. */; 15752 struct mg_pollfd pfd;; 15753 int pollres;; 15754 pfd.fd = conn->client.sock;; 15755 pfd.events = ((err == SSL_ERROR_WANT_CONNECT); 15756 || (err == SSL_ERROR_WANT_WRITE)); 15757 ? POLLOUT; 15758 : POLLIN;; 15759 pollres =; 15760 mg_poll(&pfd, 1, 50, &(conn->phys_ctx->stop_flag));; 15761 if (pollres < 0) {; 15762 /* Break if error occured (-1); 15763 * or server shutdown (-2) */; 15764 br",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:464909,timeout,timeout,464909,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety,"-activated handler. ; Definition at line 32 of file TSysEvtHandler.cxx. ◆ Activated(). virtual void TSysEvtHandler::Activated ; (; ). inlinevirtual . Definition at line 47 of file TSysEvtHandler.h. ◆ Add(). virtual void TSysEvtHandler::Add ; (; ). pure virtual . Implemented in TFileHandler, TSignalHandler, TStdExceptionHandler, and TTimer. ◆ Added(). virtual void TSysEvtHandler::Added ; (; ). inlinevirtual . Definition at line 50 of file TSysEvtHandler.h. ◆ Class(). static TClass * TSysEvtHandler::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TSysEvtHandler::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TSysEvtHandler::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 53 of file TSysEvtHandler.h. ◆ DeActivate(). void TSysEvtHandler::DeActivate ; (; ). De-activate a system event handler. ; Use this method to temporarily disable an event handler to avoid it from being recursively called. Use DeActivate() / Activate() instead of Remove() / Add() for this purpose, since the Add() will add the handler back to the end of the list of handlers and cause it to be called again for the same, already handled, event. ; Definition at line 46 of file TSysEvtHandler.cxx. ◆ DeActivated(). virtual void TSysEvtHandler::DeActivated ; (; ). inlinevirtual . Definition at line 48 of file TSysEvtHandler.h. ◆ DeclFileName(). static const char * TSysEvtHandler::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 53 of file TSysEvtHandler.h. ◆ GetSender(). void * TSysEvtHandler::GetSender ; (; ). inlineoverrideprivatevirtual . Reimplemented from TQObject.; Definition at line 33 of file TSysEvtHandler.h. ◆ IsA(). TClass * TSysEvtHandler::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Reimplemented in TTimer.; Definiti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSysEvtHandler.html:16507,avoid,avoid,16507,doc/master/classTSysEvtHandler.html,https://root.cern,https://root.cern/doc/master/classTSysEvtHandler.html,1,['avoid'],['avoid']
Safety,"-blocking mode (kNoBlock) -4 means EWOULDBLOCK. Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET). ; Reimplemented in TServerSocket, TPSocket, and TSSLSocket.; Definition at line 898 of file TSocket.cxx. ◆ RecvStreamerInfos(). Bool_t TSocket::RecvStreamerInfos ; (; TMessage * ; mess). protected . Receive a message containing streamer infos. ; In case the message contains streamer infos they are imported, the message will be deleted and the method returns kTRUE. ; Definition at line 928 of file TSocket.cxx. ◆ Select(). Int_t TSocket::Select ; (; Int_t ; interest = kRead, . Long_t ; timeout = -1 . ). virtual . Waits for this socket to change status. ; If interest=kRead, the socket will be watched to see if characters become available for reading; if interest=kWrite the socket will be watched to see if a write will not block. The argument 'timeout' specifies a maximum time to wait in millisec. Default no timeout. Returns 1 if a change of status of interest has been detected within timeout; 0 in case of timeout; < 0 if an error occured. ; Definition at line 443 of file TSocket.cxx. ◆ Send() [1/4]. Int_t TSocket::Send ; (; const char * ; str, . Int_t ; kind = kMESS_STRING . ). virtual . Send a character string buffer. ; Use kind to set the TMessage ""what"" field. Returns the number of bytes in the string str that were sent and -1 in case of error. In case the kind has been or'ed with kMESS_ACK, the call will only return after having received an acknowledgement, making the sending process synchronous. ; Reimplemented in TServerSocket, TPSocket, and TSSLSocket.; Definition at line 500 of file TSocket.cxx. ◆ Send() [2/4]. Int_t TSocket::Send ; (; const TMessage & ; mess). virtual . Send a TMessage object. ; Returns the number of bytes in the TMessage that were sent and -1 in case of error. In case the TMessage::What has been or'ed with kMESS_ACK, the call will only return after having received an acknowledgement, making the sending process synchronous. Returns ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSocket.html:34650,detect,detected,34650,doc/master/classTSocket.html,https://root.cern,https://root.cern/doc/master/classTSocket.html,3,"['detect', 'timeout']","['detected', 'timeout']"
Safety,"-traced Images; A ray-traced view can be clipped with any shape known by the modeller. This means that the region inside the clipping shape is subtracted from the current drawn geometry (become invisible). In order to activate clipping, one has to first define the clipping shape(s):; 1. TGeoShape *clip1, *clip2, ...; One might switch between several clipping shapes. Note that these shapes are considered defined in the current MARS. Composite shapes may be used.; 2. gGeoManager->SetClippingShape(clip1);; One can activate or deactivate clipping at any time: gGeoManager->SetClipping(flag);. Perform ray-tracing:gGeoManager->GetTopVolume()->Raytrace();. One can redo the steps 2-3 as many times as needed. Let us look how the rootgeom example looks clipped with a tube. Ray-tracing example with box-clipping. 18.8 Representing Misalignments of the Ideal Geometry; The ideal positioning of a detector does not match its position in the experimental hall. This generally happens not only for the detector modules, but also for their components. The accurate knowledge of the detector real misalignments can be extremely important for getting close to its designed resolution and the expected tracking efficiency. TGeo offers tools for representing positioning misalignments, applying them to the ideal geometry and performing navigation under these conditions. Detector tracking algorithms can then directly query the geometry for navigation purposes or for retrieving actual misalignment information.; 18.8.1 Physical Nodes; Physical nodes are the actual “touchable” objects in the geometry, representing actually a path of positioned volumes starting with the top node: path=/TOP/A_1/B_4/C_3 , where A, B, C represent names of volumes. The number of physical nodes is given by the total number of possible of branches in the geometry hierarchy. In case of detector geometries and specially for calorimeters this number can be of the order 106-109, therefore it is impossible to create all physical ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1013182,detect,detector,1013182,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['detect'],['detector']
Safety,". ). finalvirtual . WriteFastArray SQL implementation. ; NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Reimplemented from TBufferFile.; Definition at line 486 of file TBufferSQL.cxx. ◆ WriteFastArray() [10/15]. void TBufferSQL::WriteFastArray ; (; const UInt_t * ; ui, . Long64_t ; n . ). finalvirtual . WriteFastArray SQL implementation. ; NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Reimplemented from TBufferFile.; Definition at line 568 of file TBufferSQL.cxx. ◆ WriteFastArray() [11/15]. void TBufferSQL::WriteFastArray ; (; const ULong64_t * ; ul, . Long64_t ; n . ). finalvirtual . WriteFastArray SQL implementation. ; NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Reimplemented from TBufferFile.; Definition at line 648 of file TBufferSQL.cxx. ◆ WriteFastArray() [12/15]. void TBufferSQL::WriteFastArray ; (; const ULong_t * ; ul, . Long64_t ; n . ). finalvirtual . WriteFastArray SQL implementation. ; NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Reimplemented from TBufferFile.; Definition at line 608 of file TBufferSQL.cxx. ◆ WriteFastArray() [13/15]. void TBufferSQL::WriteFastArray ; (; const UShort_t * ; us, . Long64_t ; n . ). finalvirtual . WriteFastArray SQL implementation. ; NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBufferSQL.html:55129,abort,aborts,55129,doc/master/classTBufferSQL.html,https://root.cern,https://root.cern/doc/master/classTBufferSQL.html,1,['abort'],['aborts']
Safety,". ). finalvirtual . WriteFastArray SQL implementation. ; NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Reimplemented from TBufferFile.; Definition at line 648 of file TBufferSQL.cxx. ◆ WriteFastArray() [12/15]. void TBufferSQL::WriteFastArray ; (; const ULong_t * ; ul, . Long64_t ; n . ). finalvirtual . WriteFastArray SQL implementation. ; NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Reimplemented from TBufferFile.; Definition at line 608 of file TBufferSQL.cxx. ◆ WriteFastArray() [13/15]. void TBufferSQL::WriteFastArray ; (; const UShort_t * ; us, . Long64_t ; n . ). finalvirtual . WriteFastArray SQL implementation. ; NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Reimplemented from TBufferFile.; Definition at line 527 of file TBufferSQL.cxx. ◆ WriteFastArray() [14/15]. Int_t TBufferSQL::WriteFastArray ; (; void ** ; startp, . const TClass * ; cl, . Long64_t ; n = 1, . bool ; isPreAlloc = false, . TMemberStreamer * ; s = nullptr . ). finalvirtual . WriteFastArray SQL implementation. ; Reimplemented from TBufferFile.; Definition at line 717 of file TBufferSQL.cxx. ◆ WriteFastArray() [15/15]. void TBufferSQL::WriteFastArray ; (; void * ; start, . const TClass * ; cl, . Long64_t ; n = 1, . TMemberStreamer * ; s = nullptr . ). finalvirtual . WriteFastArray SQL implementation. ; Reimplemented from TBufferFile.; Definition at line 708 of file TBufferSQL.cxx. ◆ WriteFastArrayString(). void TBufferSQL::WriteFastArrayString ; (; const Char_t * ; c, . Long64_t ; n . ). finalvirtual . WriteFastArray SQL implementation. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBufferSQL.html:56010,abort,aborts,56010,doc/master/classTBufferSQL.html,https://root.cern,https://root.cern/doc/master/classTBufferSQL.html,1,['abort'],['aborts']
Safety,". ). private . Pases the layer string and creates the appropriate max pool layer. ; Definition at line 768 of file MethodDL.cxx. ◆ ParseRecurrentLayer(). template<typename Architecture_t , typename Layer_t > . void TMVA::MethodDL::ParseRecurrentLayer ; (; ERecurrentLayerType ; type, . DNN::TDeepNet< Architecture_t, Layer_t > & ; deepNet, . std::vector< DNN::TDeepNet< Architecture_t, Layer_t > > & ; nets, . TString ; layerString, . TString ; delim . ). private . Pases the layer string and creates the appropriate rnn layer. ; Definition at line 931 of file MethodDL.cxx. ◆ ParseReshapeLayer(). template<typename Architecture_t , typename Layer_t > . void TMVA::MethodDL::ParseReshapeLayer ; (; DNN::TDeepNet< Architecture_t, Layer_t > & ; deepNet, . std::vector< DNN::TDeepNet< Architecture_t, Layer_t > > & ; nets, . TString ; layerString, . TString ; delim . ). private . Pases the layer string and creates the appropriate reshape layer. ; Definition at line 829 of file MethodDL.cxx. ◆ PredictDeepNet(). template<typename Architecture_t > . std::vector< Double_t > TMVA::MethodDL::PredictDeepNet ; (; Long64_t ; firstEvt, . Long64_t ; lastEvt, . size_t ; batchSize, . Bool_t ; logProgress . ). private . perform prediction of the deep neural network using batches (called by GetMvaValues) ; Evaluate the DeepNet on a vector of input values stored in the TMVA Event class. ; Definition at line 1828 of file MethodDL.cxx. ◆ ProcessOptions(). void TMVA::MethodDL::ProcessOptions ; (; ). privatevirtual . Implements TMVA::MethodBase.; Definition at line 219 of file MethodDL.cxx. ◆ ReadWeightsFromStream() [1/3]. void TMVA::MethodDL::ReadWeightsFromStream ; (; std::istream & ; ). virtual . Implements TMVA::MethodBase.; Definition at line 2330 of file MethodDL.cxx. ◆ ReadWeightsFromStream() [2/3]. virtual void TMVA::MethodBase::ReadWeightsFromStream ; (; std::istream & ; ). virtual . Methods for writing and reading weights. ; Implements TMVA::MethodBase. ◆ ReadWeightsFromStream() [3/3]. virt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodDL.html:47546,Predict,PredictDeepNet,47546,doc/master/classTMVA_1_1MethodDL.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodDL.html,1,['Predict'],['PredictDeepNet']
Safety,". ; This method is not adequate for being called inside tight loops as it implies a lookup in a mapping between the threadIDs and the slot indices. A good practice consists in copying the pointer onto the stack and proceed with the loop as shown in this work item (psudo-code) which will be sent to different threads: auto workItem = [](){; auto objPtr = tthreadedObject.Get();; for (auto i : ROOT::TSeqI(1000)) {; // tthreadedObject->FastMethod(i); // don't do this! Inefficient!; objPtr->FastMethod(i);; }; }; ROOT::TSeqA pseudo container class which is a generator of indices.Definition TSeq.hxx:67; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4. Definition at line 280 of file TThreadedObject.hxx. ◆ GetAtSlot(). template<class T > . std::shared_ptr< T > ROOT::TThreadedObject< T >::GetAtSlot ; (; unsigned ; i). inline . Access a particular processing slot. ; This method is thread-safe as long as concurrent calls request different slots (i.e. pass a different argument) and no thread accesses slot i via the arrow operator, so mixing usage of GetAtSlot with usage of the arrow operator can be dangerous. ; Definition at line 202 of file TThreadedObject.hxx. ◆ GetAtSlotRaw(). template<class T > . T * ROOT::TThreadedObject< T >::GetAtSlotRaw ; (; unsigned ; i); const. inline . Access a particular slot which corresponds to a single thread. ; This overload is faster than the GetAtSlotUnchecked method but the caller is responsible to make sure that the slot exists, to check that the contained object is initialized and that the returned pointer will not outlive the TThreadedObject that returned it, which maintains ownership of the actual object. ; Definition at line 260 of file TThreadedObject.hxx. ◆ GetAtSlotUnchecked(). template<class T > . std::shared_ptr< T > ROOT::TThreadedObject< T >::GetAtSlotUnchecked ; (; unsigned ; i); const. inline . Access a particular slot which corresponds to",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1TThreadedObject.html:5846,safe,safe,5846,doc/v632/classROOT_1_1TThreadedObject.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1TThreadedObject.html,2,['safe'],['safe']
Safety,". ;  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Attributes; char * fBuffer;  [fBufferSize] buffer of contiguous prefetched blocks ;  ; Int_t fBufferSize;  Allocated size of fBuffer. ;  ; TFile * fFile;  Pointer to file. ;  ; Int_t fNtot;  Total size of cached blocks. ;  ; Bool_t fRecursive;  flag to avoid recursive calls ;  ; Long64_t fSeekStart;  Seek value of first block in cache. ;  . Private Member Functions;  TFileCacheWrite (const TFileCacheWrite &)=delete;  ; TFileCacheWrite & operator= (const TFileCacheWrite &)=delete;  . Additional Inherited Members;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inheri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFileCacheWrite.html:10264,avoid,avoid,10264,doc/master/classTFileCacheWrite.html,https://root.cern,https://root.cern/doc/master/classTFileCacheWrite.html,1,['avoid'],['avoid']
Safety,". ;  ; static Bool_t ConnectToClass (TQObject *sender, const char *signal, TClass *receiver_class, void *receiver, const char *slot);  Create connection between sender and receiver. ;  ;  Protected Attributes inherited from TTimer; TTime fAbsTime;  ; TString fCommand;  ; Bool_t fIntSyscalls;  ; TObject * fObject;  ; Bool_t fSync;  ; TTime fTime;  ; UInt_t fTimeID;  ; Bool_t fTimeout;  ;  Protected Attributes inherited from TQObject; TList * fListOfConnections;  list of signals from this object ;  ; TList * fListOfSignals;  ; Bool_t fSignalsBlocked;  list of connections to this object ;  ;  Static Protected Attributes inherited from TQObject; static Bool_t fgAllSignalsBlocked = kFALSE;  flag used for suppression of signals ;  . Inheritance diagram for TStopTimer:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TStopTimer(). TStopTimer::TStopTimer ; (; TProofPlayer * ; p, . Bool_t ; abort, . Int_t ; to . ). Constructor for the timer to stop/abort processing. ; The 'timeout' is in seconds. Make sure that 'to' make sense, i.e. not larger than 10 days; the minimum value is 10 ms (0 does not seem to start the timer ...). ; Definition at line 186 of file TProofPlayer.cxx. Member Function Documentation. ◆ Notify(). Bool_t TStopTimer::Notify ; (; ). overridevirtual . Handle the signal coming from the expiration of the timer associated with an abort or stop request. ; We raise an exception which will be processed in the event loop. ; Implements TSysEvtHandler.; Definition at line 205 of file TProofPlayer.cxx. Member Data Documentation. ◆ fAbort. Bool_t TStopTimer::fAbort. private . Definition at line 171 of file TProofPlayer.cxx. ◆ fPlayer. TProofPlayer* TStopTimer::fPlayer. private . Definition at line 172 of file TProofPlayer.cxx. proof/proofplayer/src/TProofPlayer.cxx. TStopTimer. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:44:33 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTStopTimer.html:17545,abort,abort,17545,doc/master/classTStopTimer.html,https://root.cern,https://root.cern/doc/master/classTStopTimer.html,3,"['abort', 'timeout']","['abort', 'timeout']"
Safety,". ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Private Attributes; TArrayC * fClassSent;  ; TMessage fMessage;  ; Int_t fServerIdx;  ; TUrl fServerLocation;  ; Int_t fServerVersion;  ; TSocket * fSocket;  . Additional Inherited Members;  Public Types inherited from TMemFile; using ExternalDataPtr_t = std::shared_ptr< const std::vector< char > >;  ;  Public Types inherited from TFile; enum  { kStartBigFile = 2000000000; };  ; enum  EAsyncOpenStatus { kAOSNotAsync = -1; , kAOSFailure = 0; , kAOSInProgress = 1; , kAOSSuccess = 2; };  Asynchronous open request status. More...;  ; enum  ECacheAction { kDisconnect = 0; , kDoNotDisconnect = 1; };  TTreeCache flushing semantics. More...;  ; enum  EFileType { ;   kDefault = 0; , kLocal = 1; , kNet = 2; , kWeb = 3; , ;   kFile = 4; , kMerge = 5. };  File type. More...;  ; enum  EOpenTimeOut { kInstantTimeout = 0; , kEternalTimeout = 999999999; };  Open timeout constants. More...;  ; enum  ERelativeTo { kBeg = 0; , kCur = 1; , kEnd = 2; };  ; enum  EStatusBits { ;   k630forwardCompatibility = (1ULL << ( 2 )); , kRecovered = (1ULL << ( 10 )); , kHasReferences = (1ULL << ( 11 )); , kDevNull = (1ULL << ( 12 )); , ;   kWriteError = (1ULL << ( 14 )); , kBinaryFile = (1ULL << ( 15 )); , kRedirected = (1ULL << ( 16 )); , kReproducible = (1ULL << ( 17 )). };  TFile status bits. BIT(13) is taken up by TObject. More...;  ;  Public Types inherited from TDirectoryFile; enum  EStatusBits { kCloseDirectory = (1ULL << ( 7 )); };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTParallelMergingFile.html:31541,timeout,timeout,31541,doc/master/classTParallelMergingFile.html,https://root.cern,https://root.cern/doc/master/classTParallelMergingFile.html,1,['timeout'],['timeout']
Safety,". Bool_t TGeoNavigator::IsEntering ; (; ); const. inline . Definition at line 140 of file TGeoNavigator.h. ◆ IsExiting(). Bool_t TGeoNavigator::IsExiting ; (; ); const. inline . Definition at line 141 of file TGeoNavigator.h. ◆ IsNullStep(). Bool_t TGeoNavigator::IsNullStep ; (; ); const. inline . Definition at line 146 of file TGeoNavigator.h. ◆ IsOnBoundary(). Bool_t TGeoNavigator::IsOnBoundary ; (; ); const. inline . Definition at line 145 of file TGeoNavigator.h. ◆ IsOutside(). Bool_t TGeoNavigator::IsOutside ; (; ); const. inline . Definition at line 144 of file TGeoNavigator.h. ◆ IsPWSafetyCaching(). static Bool_t TGeoNavigator::IsPWSafetyCaching ; (; ). inlinestatic . Definition at line 232 of file TGeoNavigator.h. ◆ IsSafeStep(). Bool_t TGeoNavigator::IsSafeStep ; (; Double_t ; proposed, . Double_t & ; newsafety . ); const. In case a previous safety value was computed, check if the safety region is still safe for the current point and proposed step. ; Return value changed only if proposed distance is safe. ; Definition at line 2609 of file TGeoNavigator.cxx. ◆ IsSameLocation() [1/2]. Bool_t TGeoNavigator::IsSameLocation ; (; ); const. inline . Definition at line 133 of file TGeoNavigator.h. ◆ IsSameLocation() [2/2]. Bool_t TGeoNavigator::IsSameLocation ; (; Double_t ; x, . Double_t ; y, . Double_t ; z, . Bool_t ; change = kFALSE . ). Checks if point (x,y,z) is still in the current node. ; check if this is an overlapping node ; Definition at line 2446 of file TGeoNavigator.cxx. ◆ IsSamePoint(). Bool_t TGeoNavigator::IsSamePoint ; (; Double_t ; x, . Double_t ; y, . Double_t ; z . ); const. Check if a new point with given coordinates is the same as the last located one. ; Definition at line 2634 of file TGeoNavigator.cxx. ◆ IsStartSafe(). Bool_t TGeoNavigator::IsStartSafe ; (; ); const. inline . Definition at line 135 of file TGeoNavigator.h. ◆ IsStepEntering(). Bool_t TGeoNavigator::IsStepEntering ; (; ); const. inline . Definition at line 142 of file TGeoNavi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoNavigator.html:37646,safe,safe,37646,doc/master/classTGeoNavigator.html,https://root.cern,https://root.cern/doc/master/classTGeoNavigator.html,1,['safe'],['safe']
Safety,". Bool_t TGeoNavigator::PopPoint ; (; ). inline . Definition at line 264 of file TGeoNavigator.h. ◆ PopPoint() [2/2]. Bool_t TGeoNavigator::PopPoint ; (; Int_t ; index). inline . Definition at line 272 of file TGeoNavigator.h. ◆ PushPath(). Int_t TGeoNavigator::PushPath ; (; Int_t ; startlevel = 0). inline . Definition at line 246 of file TGeoNavigator.h. ◆ PushPoint(). Int_t TGeoNavigator::PushPoint ; (; Int_t ; startlevel = 0). inline . Definition at line 263 of file TGeoNavigator.h. ◆ ResetAll(). void TGeoNavigator::ResetAll ; (; ). Reset the navigator. ; Definition at line 2708 of file TGeoNavigator.cxx. ◆ ResetState(). void TGeoNavigator::ResetState ; (; ). Reset current state flags. ; Definition at line 1643 of file TGeoNavigator.cxx. ◆ Safety(). Double_t TGeoNavigator::Safety ; (; Bool_t ; inside = kFALSE). Compute safe distance from the current point. ; This represent the distance from POINT to the closest boundary. ; Definition at line 1689 of file TGeoNavigator.cxx. ◆ SafetyOverlaps(). void TGeoNavigator::SafetyOverlaps ; (; ). protected . Compute safe distance from the current point within an overlapping node. ; Definition at line 1846 of file TGeoNavigator.cxx. ◆ SearchNode(). TGeoNode * TGeoNavigator::SearchNode ; (; Bool_t ; downwards = kFALSE, . const TGeoNode * ; skipnode = nullptr . ). Returns the deepest node containing fPoint, which must be set a priori. ; Check if parallel world navigation is enabled ; Definition at line 1924 of file TGeoNavigator.cxx. ◆ SetCheckingOverlaps(). void TGeoNavigator::SetCheckingOverlaps ; (; Bool_t ; flag = kTRUE). inline . Definition at line 147 of file TGeoNavigator.h. ◆ SetCldirChecked(). void TGeoNavigator::SetCldirChecked ; (; Double_t * ; dir). inline . Definition at line 193 of file TGeoNavigator.h. ◆ SetCurrentDirection() [1/2]. void TGeoNavigator::SetCurrentDirection ; (; const Double_t * ; dir). inline . Definition at line 185 of file TGeoNavigator.h. ◆ SetCurrentDirection() [2/2]. void TGeoNavigator::SetCu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoNavigator.html:41543,Safe,SafetyOverlaps,41543,doc/master/classTGeoNavigator.html,https://root.cern,https://root.cern/doc/master/classTGeoNavigator.html,1,['Safe'],['SafetyOverlaps']
Safety,". Definition at line 538 of file RuleFitParams.cxx. ◆ MakeGradientVector(). void TMVA::RuleFitParams::MakeGradientVector ; (; ). protected . make gradient vector ; Definition at line 1375 of file RuleFitParams.cxx. ◆ MakeTstGradientVector(). void TMVA::RuleFitParams::MakeTstGradientVector ; (; ). protected . make test gradient vector for all tau same algorithm as MakeGradientVector() ; Definition at line 1259 of file RuleFitParams.cxx. ◆ Optimism(). Double_t TMVA::RuleFitParams::Optimism ; (; ). protected . implementation of eq. ; 7.17 in Hastie,Tibshirani & Friedman book this is the covariance between the estimated response yhat and the true value y. NOT REALLY SURE IF THIS IS CORRECT! — THIS IS NOT USED — ; Definition at line 925 of file RuleFitParams.cxx. ◆ Penalty(). Double_t TMVA::RuleFitParams::Penalty ; (; ); const. This is the ""lasso"" penalty To be used for regression. ; — NOT USED — ; Definition at line 356 of file RuleFitParams.cxx. ◆ Risk() [1/2]. Double_t TMVA::RuleFitParams::Risk ; (; UInt_t ; ind1, . UInt_t ; ind2, . Double_t ; neff . ); const. risk assessment ; Definition at line 314 of file RuleFitParams.cxx. ◆ Risk() [2/2]. Double_t TMVA::RuleFitParams::Risk ; (; UInt_t ; ind1, . UInt_t ; ind2, . Double_t ; neff, . UInt_t ; itau . ); const. risk assessment for tau model <itau> ; Definition at line 334 of file RuleFitParams.cxx. ◆ RiskPath(). Double_t TMVA::RuleFitParams::RiskPath ; (; ); const. inline . Definition at line 108 of file RuleFitParams.h. ◆ RiskPerf() [1/2]. Double_t TMVA::RuleFitParams::RiskPerf ; (; ); const. inline . Definition at line 109 of file RuleFitParams.h. ◆ RiskPerf() [2/2]. Double_t TMVA::RuleFitParams::RiskPerf ; (; UInt_t ; itau); const. inline . Definition at line 110 of file RuleFitParams.h. ◆ RiskPerfTst(). UInt_t TMVA::RuleFitParams::RiskPerfTst ; (; ). Estimates the error rate with the current set of parameters. ; using the <Perf> subsample. Return the tau index giving the lowest error ; Definition at line 1201 of file",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1RuleFitParams.html:16495,Risk,Risk,16495,doc/master/classTMVA_1_1RuleFitParams.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1RuleFitParams.html,1,['Risk'],['Risk']
Safety,". Definition at line 74 of file TGDoubleSlider.h. Member Function Documentation. ◆ ChangeCursor(). void TGDoubleSlider::ChangeCursor ; (; Event_t * ; event). protected . Change the cursor shape depending on the slider area. ; Definition at line 176 of file TGDoubleSlider.cxx. ◆ Class(). static TClass * TGDoubleSlider::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TGDoubleSlider::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TGDoubleSlider::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 166 of file TGDoubleSlider.h. ◆ DeclFileName(). static const char * TGDoubleSlider::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 166 of file TGDoubleSlider.h. ◆ FixBounds(). void TGDoubleSlider::FixBounds ; (; Double_t & ; min, . Double_t & ; max . ). staticprotected . Avoid boundaries to be equal. ; Definition at line 126 of file TGDoubleSlider.cxx. ◆ GetMaxPosition(). virtual Float_t TGDoubleSlider::GetMaxPosition ; (; ); const. inlinevirtual . Definition at line 103 of file TGDoubleSlider.h. ◆ GetMaxPositionD(). virtual Double_t TGDoubleSlider::GetMaxPositionD ; (; ); const. inlinevirtual . Definition at line 147 of file TGDoubleSlider.h. ◆ GetMaxPositionL(). virtual Long64_t TGDoubleSlider::GetMaxPositionL ; (; ); const. inlinevirtual . Definition at line 109 of file TGDoubleSlider.h. ◆ GetMinPosition(). virtual Float_t TGDoubleSlider::GetMinPosition ; (; ); const. inlinevirtual . Definition at line 100 of file TGDoubleSlider.h. ◆ GetMinPositionD(). virtual Double_t TGDoubleSlider::GetMinPositionD ; (; ); const. inlinevirtual . Definition at line 143 of file TGDoubleSlider.h. ◆ GetMinPositionL(). virtual Long64_t TGDoubleSlider::GetMinPositionL ; (; ); const. inlinevirtual . Definition at line 106 of file TGDoubleSlider.h. ◆ GetPosition() [1/6]. virtual void T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGDoubleSlider.html:33365,Avoid,Avoid,33365,doc/master/classTGDoubleSlider.html,https://root.cern,https://root.cern/doc/master/classTGDoubleSlider.html,1,['Avoid'],['Avoid']
Safety,". Double_t Safety(const Double_t* point, Bool_t in = kTRUE) const; Computes the closest distance from given point to this shape. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetDimensions(Double_t* param); Set all arb8 params in one step.; param[0] = dz; param[1] = theta; param[2] = phi; param[3] = h1; param[4] = bl1; param[5] = tl1; param[6] = alpha1; param[7] = h2; param[8] = bl2; param[9] = tl2; param[10] = alpha2. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoTrap(); constructors. Double_t GetTheta() const; {return fTheta;}. Double_t GetPhi() const; {return fPhi;}. Double_t GetH1() const; {return fH1;}. Double_t GetBl1() const; {return fBl1;}. Double_t GetTl1() const; {return fTl1;}. Double_t GetAlpha1() const; {return fAlpha1;}. Double_t GetH2() const; {return fH2;}. Double_t GetBl2() const; {return fBl2;}. Double_t GetTl2() const; {return fTl2;}. Double_t GetAlpha2() const; {return fAlpha2;}. » Author: Andrei Gheata 24/10/01 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-03-14 16:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoTrap.html:17759,safe,safe,17759,root/html534/TGeoTrap.html,https://root.cern,https://root.cern/root/html534/TGeoTrap.html,3,"['Safe', 'safe']","['Safety', 'safe']"
Safety,". EGeoBoolType TGeoUnion::GetBooleanOperator ; (; ); const. inlineoverridevirtual . Implements TGeoBoolNode.; Definition at line 118 of file TGeoBoolNode.h. ◆ GetNpoints(). Int_t TGeoUnion::GetNpoints ; (; ). overridevirtual . Returns number of vertices for the composite shape described by this union. ; Implements TGeoBoolNode.; Definition at line 778 of file TGeoBoolNode.cxx. ◆ IsA(). TClass * TGeoUnion::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TGeoBoolNode.; Definition at line 128 of file TGeoBoolNode.h. ◆ MakeClone(). TGeoBoolNode * TGeoUnion::MakeClone ; (; ); const. overridevirtual . Make a clone of this. Pointers are preserved. ; Implements TGeoBoolNode.; Definition at line 432 of file TGeoBoolNode.cxx. ◆ Paint(). void TGeoUnion::Paint ; (; Option_t * ; option). overridevirtual . Paint method. ; Reimplemented from TGeoBoolNode.; Definition at line 440 of file TGeoBoolNode.cxx. ◆ Safety(). Double_t TGeoUnion::Safety ; (; const Double_t * ; point, . Bool_t ; in = kTRUE . ); const. overridevirtual . Compute safety distance for a union node;. ; Implements TGeoBoolNode.; Definition at line 822 of file TGeoBoolNode.cxx. ◆ SavePrimitive(). void TGeoUnion::SavePrimitive ; (; std::ostream & ; out, . Option_t * ; option = """" . ). overridevirtual . Save a primitive as a C++ statement(s) on output stream ""out"". ; Reimplemented from TGeoBoolNode.; Definition at line 846 of file TGeoBoolNode.cxx. ◆ Sizeof3D(). void TGeoUnion::Sizeof3D ; (; ); const. overridevirtual . Register 3D size of this shape. ; Reimplemented from TGeoBoolNode.; Definition at line 865 of file TGeoBoolNode.cxx. ◆ Streamer(). void TGeoUnion::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TGeoBoolNode. ◆ StreamerNVirtual(). void TGeoUnion::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 128 of file TGeoBoolNode.h. Libraries for TGeoUnion:. [",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoUnion.html:18082,Safe,Safety,18082,doc/master/classTGeoUnion.html,https://root.cern,https://root.cern/doc/master/classTGeoUnion.html,1,['Safe'],['Safety']
Safety,". Go to the documentation of this file. 1// @(#)root/base:$Id$; 2// Author: Anna Kreshuk 10/04/2006; 3 ; 4#ifndef ROOT_TVirtualFFT; 5#define ROOT_TVirtualFFT; 6 ; 7//////////////////////////////////////////////////////////////////////////; 8//; 9// TVirtualFFT; 10//; 11// TVirtualFFT is an interface class for Fast Fourier Transforms.; 12//; 13//; 14//; 15// The default FFT library is FFTW. To use it, FFTW3 library should already; 16// be installed, and ROOT should be have fftw3 module enabled, with the directories; 17// of fftw3 include file and library specified (see installation instructions).; 18// Function SetDefaultFFT() allows to change the default library.; 19//; 20// Available transform types:; 21// FFT:; 22// - ""C2CFORWARD"" - a complex input/output discrete Fourier transform (DFT); 23// in one or more dimensions, -1 in the exponent; 24// - ""C2CBACKWARD""- a complex input/output discrete Fourier transform (DFT); 25// in one or more dimensions, +1 in the exponent; 26// - ""R2C"" - a real-input/complex-output discrete Fourier transform (DFT); 27// in one or more dimensions,; 28// - ""C2R"" - inverse transforms to ""R2C"", taking complex input; 29// (storing the non-redundant half of a logically Hermitian array); 30// to real output; 31// - ""R2HC"" - a real-input DFT with output in ""halfcomplex"" format,; 32// i.e. real and imaginary parts for a transform of size n stored as; 33// r0, r1, r2, ..., rn/2, i(n+1)/2-1, ..., i2, i1; 34// - ""HC2R"" - computes the reverse of FFTW_R2HC, above; 35// - ""DHT"" - computes a discrete Hartley transform; 36//; 37// Sine/cosine transforms:; 38// Different types of transforms are specified by parameter kind of the SineCosine() static; 39// function. 4 different kinds of sine and cosine transforms are available; 40// DCT-I (REDFT00 in FFTW3 notation)- kind=0; 41// DCT-II (REDFT10 in FFTW3 notation)- kind=1; 42// DCT-III(REDFT01 in FFTW3 notation)- kind=2; 43// DCT-IV (REDFT11 in FFTW3 notation)- kind=3; 44// DST-I (RODFT00 in FFTW3 notation",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TVirtualFFT_8h_source.html:1326,redund,redundant,1326,doc/master/TVirtualFFT_8h_source.html,https://root.cern,https://root.cern/doc/master/TVirtualFFT_8h_source.html,1,['redund'],['redundant']
Safety,". If NN is omitted the delay between subimages is zero. For an animation that stops after last subimage is reached, one has to write the last image as .gif+ (zero delay of last image) or .gif+NN (NN*10ms delay of last image).; For repeated animation (looping), the last subimage must be specified as:; ""myfile.gif++NN++"" if you want an infinite looping gif with NN*10ms delay of the last image.; ""myfile.gif++"" for an infinite loop with zero delay of last image.; ""myfile.gif+NN++RR"" if you want a finite looping gif with NN*10ms delay of the last image and the animation to be stopped after RR repeats. RR is not restricted to two digits. A deprecated version for saving the last subimage of a looping gif animation is:; ""myfile.gif++NN"" for a finite loop where NN is number of repetitions and NN*10ms the delay of last image. (No separate control of repeats and delay). Note: If the file ""myfile.gif"" already exists, the new frames are appended at the end of the file. To avoid this, delete it first with gSystem->Unlink(myfile.gif);. The following macro creates animated gif from jpeg images with names; imageNN.jpg, where 1<= NN <= 10; The delays are set to 10*10ms. {; TImage *img = 0;; gSystem->Unlink(""anim.gif""); // delete existing file; ; for (int i = 1; i <= 10; i++) {; delete img; // delete previous image; ; // Read image data. Image can be in any format, e.g. png, gif, etc.; img = TImage::Open(Form(""image%d.jpg"", i));; ; if (i < 10) {; img->WriteImage(""anim.gif+10""); // 10 centiseconds delay; } else { // the last image written. ""++"" stands for infinit animation.; img->WriteImage(""anim.gif++10++""); // 10 centiseconds delay of last image; }; }; }; Formchar * Form(const char *fmt,...)Formats a string in a circular formatting buffer.Definition TString.cxx:2489; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; TImage::WriteImagevirtual void WriteImage(const char *, EImageFileTypes=TImage::kUnknown)Definition TImage.h:115; TSystem::Unlinkvirtual int Unlink(const char *",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTASImage.html:80233,avoid,avoid,80233,doc/master/classTASImage.html,https://root.cern,https://root.cern/doc/master/classTASImage.html,1,['avoid'],['avoid']
Safety,". Implements TGeoShape.; Reimplemented in TGeoCompositeShape, TGeoCone, TGeoEltu, TGeoHalfSpace, TGeoHype, TGeoPara, TGeoParaboloid, TGeoPcon, TGeoScaledShape, TGeoShapeAssembly, TGeoSphere, TGeoTorus, TGeoTrd1, TGeoTrd2, TGeoTube, and TGeoVGShape.; Definition at line 84 of file TGeoBBox.h. ◆ IsNullBox(). virtual Bool_t TGeoBBox::IsNullBox ; (; ); const. inlinevirtual . Definition at line 86 of file TGeoBBox.h. ◆ IsValidBox(). Bool_t TGeoBBox::IsValidBox ; (; ); const. inlineoverridevirtual . Implements TGeoShape.; Reimplemented in TGeoVGShape.; Definition at line 85 of file TGeoBBox.h. ◆ MakeBuffer3D(). TBuffer3D * TGeoBBox::MakeBuffer3D ; (; ); const. overridevirtual . Reimplemented from TGeoShape.; Reimplemented in TGeoCone, TGeoConeSeg, TGeoHype, TGeoParaboloid, TGeoPcon, TGeoPgon, TGeoScaledShape, TGeoSphere, TGeoTessellated, TGeoTorus, TGeoTube, TGeoTubeSeg, TGeoXtru, and TGeoVGShape. ◆ operator=(). TGeoBBox & TGeoBBox::operator= ; (; const TGeoBBox & ; ). protecteddelete . ◆ Safety(). Double_t TGeoBBox::Safety ; (; const Double_t * ; point, . Bool_t ; in = kTRUE . ); const. overridevirtual . Implements TGeoShape.; Reimplemented in TGeoTrap, TGeoGtra, TGeoCompositeShape, TGeoCone, TGeoConeSeg, TGeoEltu, TGeoHalfSpace, TGeoHype, TGeoPara, TGeoParaboloid, TGeoPcon, TGeoPgon, TGeoScaledShape, TGeoShapeAssembly, TGeoSphere, TGeoTorus, TGeoTrd1, TGeoTrd2, TGeoTube, TGeoTubeSeg, TGeoCtub, TGeoXtru, and TGeoVGShape. ◆ Safety_v(). void TGeoBBox::Safety_v ; (; const Double_t * ; points, . const Bool_t * ; inside, . Double_t * ; safe, . Int_t ; vecsize . ); const. overridevirtual . Reimplemented from TGeoShape.; Reimplemented in TGeoTrap, TGeoGtra, TGeoCompositeShape, TGeoCone, TGeoConeSeg, TGeoEltu, TGeoHalfSpace, TGeoHype, TGeoPara, TGeoParaboloid, TGeoPcon, TGeoPgon, TGeoScaledShape, TGeoShapeAssembly, TGeoSphere, TGeoTorus, TGeoTrd1, TGeoTrd2, TGeoTube, TGeoTubeSeg, TGeoCtub, and TGeoXtru. ◆ SavePrimitive(). void TGeoBBox::SavePrimitive ; (; std::ostream & ; out, . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoBBox.html:35835,Safe,Safety,35835,doc/master/classTGeoBBox.html,https://root.cern,https://root.cern/doc/master/classTGeoBBox.html,1,['Safe'],['Safety']
Safety,". Index of CINT. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. ROOT; » CINT. Index of CINT; CINT - The C++ Interpreter; The CINT package consists of. CINT; the current CINT core: interpreter, parser, etc.; CINT7; the new CINT core, using Reflex instead of arrays of C structures; Reflex; A C++ library for reflection data, i.e. to store information about available types, members, their sizes, etc.; Cintex; An interface between Reflex and the current CINT version. More information can be obtained from the CINT website.; The main area of work is currently getting CINT7 to work as well as the old CINT.; Once this merge with Reflex is finished, CINT will be a lot easier to maintain, use less memory, and also run faster than the current CINT.; You can watch our progress in the nightly test status for the rows labeled new.; The next major overhaul will convert CINT into a true C++ layout and make it thread-safe, with >= one interpreter per thread.; We have a draft proposal for the new layout written as C++ headers; a document describing this will follow.; For now you can peek at the subversion repository containing the set of headers.; Further Reading; bytecode; cint; cintapi; extlib; ifdef; limitati; limitnum; makecint; message; ref; List of Classes; CINT Modules; REFLEX. » Last changed: 2009-12-14 18:22 » Last generated: 2009-12-14 18:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/CINT_Index.html:933,safe,safe,933,root/html526/CINT_Index.html,https://root.cern,https://root.cern/root/html526/CINT_Index.html,1,['safe'],['safe']
Safety,". Index of CINT. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. ROOT; » CINT. Index of CINT; CINT - The C++ Interpreter; The CINT package consists of. CINT; the current CINT core: interpreter, parser, etc.; CINT7; the new CINT core, using Reflex instead of arrays of C structures; Reflex; A C++ library for reflection data, i.e. to store information about available types, members, their sizes, etc.; Cintex; An interface between Reflex and the current CINT version. More information can be obtained from the CINT website.; The main area of work is currently getting CINT7 to work as well as the old CINT.; Once this merge with Reflex is finished, CINT will be a lot easier to maintain, use less memory, and also run faster than the current CINT.; You can watch our progress in the nightly test status for the rows labeled new.; The next major overhaul will convert CINT into a true C++ layout and make it thread-safe, with >= one interpreter per thread.; We have a draft proposal for the new layout written as C++ headers; a document describing this will follow.; For now you can peek at the subversion repository containing the set of headers.; Further Reading; bytecode; cint; cintapi; extlib; ifdef; limitati; limitnum; makecint; message; ref; List of Classes; CINT Modules; REFLEX. » Last changed: 2010-12-15 15:10 » Last generated: 2010-12-15 15:10; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/CINT_Index.html:933,safe,safe,933,root/html528/CINT_Index.html,https://root.cern,https://root.cern/root/html528/CINT_Index.html,1,['safe'],['safe']
Safety,". Int_t TBufferFile::WriteFastArray ; (; void ** ; start, . const TClass * ; cl, . Long64_t ; n = 1, . Bool_t ; isPreAlloc = kFALSE, . TMemberStreamer * ; streamer = nullptr . ). overridevirtual . Write an array of object starting at the address '*start' and of length 'n' the objects in the array are of class 'cl' 'isPreAlloc' indicates whether the data member is marked with '->' Return: . 0: success; 2: truncated success (i.e actual class is missing. Only ptrClass saved.); -1: underflow, operation skipped . Implements TBuffer.; Reimplemented in TBufferSQL.; Definition at line 2435 of file TBufferFile.cxx. ◆ WriteFastArray() [15/15]. void TBufferFile::WriteFastArray ; (; void * ; start, . const TClass * ; cl, . Long64_t ; n = 1, . TMemberStreamer * ; streamer = nullptr . ). overridevirtual . Write an array of object starting at the address 'start' and of length 'n' the objects in the array are assumed to be of class 'cl'. ; NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Implements TBuffer.; Reimplemented in TBufferSQL.; Definition at line 2404 of file TBufferFile.cxx. ◆ WriteFastArrayDouble32(). void TBufferFile::WriteFastArrayDouble32 ; (; const Double_t * ; d, . Long64_t ; n, . TStreamerElement * ; elem = nullptr . ). overridevirtual . Write array of n doubles (as float) into the I/O buffer. ; see comments about Double32_t encoding at TBufferFile::WriteDouble32 NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Implements TBuffer.; Definition at line 2331 of file TBufferFile.cxx. ◆ WriteFastArrayFloat16(). void TBufferFile::WriteFastArrayFloat16 ; (; const Float_t * ; f, . Long64_t ; n, . TStreamerElement * ; elem = nullptr . ). overridevirtual . Write array of n fl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBufferFile.html:87042,abort,aborts,87042,doc/master/classTBufferFile.html,https://root.cern,https://root.cern/doc/master/classTBufferFile.html,1,['abort'],['aborts']
Safety,". Int_t TSlave::GetSlaveType ; (; ); const. inline . Definition at line 139 of file TSlave.h. ◆ GetSocket(). TSocket * TSlave::GetSocket ; (; ); const. inline . Definition at line 134 of file TSlave.h. ◆ GetStatus(). Int_t TSlave::GetStatus ; (; ); const. inline . Definition at line 140 of file TSlave.h. ◆ GetUser(). const char * TSlave::GetUser ; (; ); const. inline . Definition at line 128 of file TSlave.h. ◆ GetWorkDir(). const char * TSlave::GetWorkDir ; (; ); const. inline . Definition at line 127 of file TSlave.h. ◆ Init() [1/2]. void TSlave::Init ; (; const char * ; host, . Int_t ; port, . Int_t ; stype . ). private . Init a PROOF slave object. ; Called via the TSlave ctor. The Init method is technology specific and is overwritten by derived classes. ; Definition at line 87 of file TSlave.cxx. ◆ Init() [2/2]. void TSlave::Init ; (; TSocket * ; s, . Int_t ; stype . ). protected . Init a PROOF slave object using the connection opened via s. ; Used to avoid double opening when an attempt via TXSlave found a remote proofd. ; Definition at line 259 of file TSlave.cxx. ◆ Interrupt(). void TSlave::Interrupt ; (; Int_t ; type). protectedvirtual . Send interrupt OOB byte to master or slave servers. ; Returns 0 if ok, -1 in case of error ; Definition at line 510 of file TSlave.cxx. ◆ IsA(). TClass * TSlave::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Reimplemented in TSlaveLite.; Definition at line 167 of file TSlave.h. ◆ IsSortable(). Bool_t TSlave::IsSortable ; (; ); const. inlineoverridevirtual . Reimplemented from TObject.; Definition at line 122 of file TSlave.h. ◆ IsValid(). virtual Bool_t TSlave::IsValid ; (; ); const. inlinevirtual . Definition at line 150 of file TSlave.h. ◆ OldAuthSetup(). Int_t TSlave::OldAuthSetup ; (; Bool_t ; master, . TString ; wconf . ). private . Setup authentication related stuff for old versions. ; Provided for backward compatibility. ; Definition at line 403 of fi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSlave.html:19831,avoid,avoid,19831,doc/master/classTSlave.html,https://root.cern,https://root.cern/doc/master/classTSlave.html,1,['avoid'],['avoid']
Safety,". Masters always shutdown the remote counterpart. ; Definition at line 1798 of file TProof.cxx. ◆ CloseProgressDialog(). void TProof::CloseProgressDialog ; (; ). Close progress dialog. ; Definition at line 9283 of file TProof.cxx. ◆ Collect() [1/4]. Int_t TProof::Collect ; (; const TSlave * ; sl, . Long_t ; timeout = -1, . Int_t ; endtype = -1, . Bool_t ; deactonfail = kFALSE . ). private . Collect responses from slave sl. ; Returns the number of slaves that responded (=1). If timeout >= 0, wait at most timeout seconds (timeout = -1 by default, which means wait forever). If defined (>= 0) endtype is the message that stops this collection. ; Definition at line 2669 of file TProof.cxx. ◆ Collect() [2/4]. Int_t TProof::Collect ; (; ESlaves ; list = kActive, . Long_t ; timeout = -1, . Int_t ; endtype = -1, . Bool_t ; deactonfail = kFALSE . ). protected . Collect responses from the slave servers. ; Returns the number of slaves that responded. If timeout >= 0, wait at most timeout seconds (timeout = -1 by default, which means wait forever). If defined (>= 0) endtype is the message that stops this collection. ; Definition at line 2727 of file TProof.cxx. ◆ Collect() [3/4]. Int_t TProof::Collect ; (; TList * ; slaves, . Long_t ; timeout = -1, . Int_t ; endtype = -1, . Bool_t ; deactonfail = kFALSE . ). protected . Collect responses from the slave servers. ; Returns the number of slaves that responded. If timeout >= 0, wait at most timeout seconds (timeout = -1 by default, which means wait forever). If defined (>= 0) endtype is the message that stops this collection. ; Definition at line 2696 of file TProof.cxx. ◆ Collect() [4/4]. Int_t TProof::Collect ; (; TMonitor * ; mon, . Long_t ; timeout = -1, . Int_t ; endtype = -1, . Bool_t ; deactonfail = kFALSE . ). private . Collect responses from the slave servers. ; Returns the number of messages received. Can be 0 if there are no active slaves. If timeout >= 0, wait at most timeout seconds (timeout = -1 by default, which means w",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:77635,timeout,timeout,77635,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,3,['timeout'],['timeout']
Safety,". Minuit 2; 1 Foreword; 1.1 What M is intended to do; 1.2 What M is not intended to do; 1.3 Further remarks. 2 Introduction: M basic concepts; 2.1 The organization of M; 2.2 Design aspects of M in; 2.3 Internal and external parameters; 2.3.1 The transformation for parameters with limits. 2.4 M strategy; 2.5 Parameter errors; 2.5.1 \(\mbox{FCN}\) normalization and the error definition; 2.5.2 The error matrix; 2.5.3 \(\mbox{MINOS}\) errors; 2.5.4 \(\mbox{CONTOURS}\) plotting. 3 M installation; 3.1 M releases; 3.2 Install M using autoconf/make; 3.3 CVS code repository; 3.4 Create a tar.gz from CVS; 3.5 M versions; 3.5.1 From to; 3.5.2 Memory allocation and thread safety; 3.5.3 M parameters. 3.6 Interference with other packages; 3.7 Floating-point precision. 4 How to use M; 4.1 The \(\mbox{FCN}\) Function; 4.1.1 FCNBase::operator()(const std::vector\(<\)double\(>\)&); 4.1.2 FCNBase::up(); 4.1.3 \(\mbox{FCN}\) function with gradient. 4.2 M parameters; 4.2.1 Minimal required interface; 4.2.2 MnUserParameters; 4.2.3 MnUserCovariance; 4.2.4 MnUserParameterState. 4.3 Input to M; 4.3.1 What the user must supply; 4.3.2 What the user can supply. 4.4 Running a M minimization; 4.4.1 Direct usage of minimizers; 4.4.2 Using an application (MnMigrad); 4.4.3 Subsequent minimizations; 4.4.4 M fails to find a minimum. 4.5 The output from minimization; 4.5.1 The FunctionMinimum; 4.5.2 User representable format: MnUserParameterState; 4.5.3 Access values, errors, covariance; 4.5.4 Printout of the result; 4.5.5 Global correlation coefficients. 5 M application programming interface (API); 5.1 FunctionMinimum; 5.1.1 isValid(); 5.1.2 fval(), edm(), nfcn(). 5.2 MnContours; 5.2.1 MnContours(const FCNBase&, const FunctionMinimum&); 5.2.2 operator(); 5.2.3 contour(…). 5.3 MnEigen; 5.3.1 MnEigen(); 5.3.2 operator(). 5.4 MnHesse; 5.4.1 MnHesse(); 5.4.2 operator(). 5.5 MnMachinePrecision; 5.5.1 MnMachinePrecision(); 5.5.2 setPrecision(double eps). 5.6 MnMigrad and VariableMetricMinimizer; 5.6.1 MnMig",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/minuit2/Minuit2.html:669,safe,safety,669,root/html534/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/html534/guides/minuit2/Minuit2.html,1,['safe'],['safety']
Safety,". Only used for testing. */; 172 TCudaDeviceReference<AFloat> operator()(size_t i, size_t j) const;; 173 ; 174 void Print() const {; 175 TMatrixT<AFloat> mat(*this);; 176 mat.Print();; 177 }; 178 ; 179 void Zero() {; 180 cudaMemset(GetDataPointer(), 0, sizeof(AFloat) * GetNoElements());; 181 }; 182 ; 183 ; 184private:; 185 ; 186 /** Initializes all shared devices resource and makes sure that a sufficient; 187 * number of curand states are allocated on the device and initialized as; 188 * well as that the one-vector for the summation over columns has the right; 189 * size. */; 190 void InitializeCuda();; 191 void InitializeCurandStates();; 192 ; 193};; 194 ; 195//; 196// Inline Functions.; 197//______________________________________________________________________________; 198inline void cudaError(cudaError_t code, const char *file, int line, bool abort); 199{; 200 if (code != cudaSuccess); 201 {; 202 fprintf(stderr,""CUDA Error: %s %s %d\n"", cudaGetErrorString(code), file, line);; 203 if (abort) exit(code);; 204 }; 205}; 206 ; 207//______________________________________________________________________________; 208template<typename AFloat>; 209TCudaDeviceReference<AFloat>::TCudaDeviceReference(AFloat * devicePointer); 210 : fDevicePointer(devicePointer); 211{; 212 // Nothing to do here.; 213}; 214 ; 215//______________________________________________________________________________; 216template<typename AFloat>; 217TCudaDeviceReference<AFloat>::operator AFloat(); 218{; 219 AFloat buffer;; 220 cudaMemcpy(& buffer, fDevicePointer, sizeof(AFloat),; 221 cudaMemcpyDeviceToHost);; 222 return buffer;; 223}; 224 ; 225//______________________________________________________________________________; 226template<typename AFloat>; 227void TCudaDeviceReference<AFloat>::operator=(const TCudaDeviceReference &other); 228{; 229 cudaMemcpy(fDevicePointer, other.fDevicePointer, sizeof(AFloat),; 230 cudaMemcpyDeviceToDevice);; 231}; 232 ; 233//_____________________________________________",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/CudaMatrix_8h_source.html:7839,abort,abort,7839,doc/master/CudaMatrix_8h_source.html,https://root.cern,https://root.cern/doc/master/CudaMatrix_8h_source.html,2,['abort'],['abort']
Safety,". ROOT Version 6.06 Release Notes. ROOT Version 6.06 Release Notes; 2015-12-10. Introduction; ROOT reference manual; Core Libraries; Dictionary generation; Thread safety and thread awareness; TDirectory::TContext; Collections; Global resources.; Code Cleanups. Interpreter; I/O Libraries; hadd; Command line utilities; TBufferFile.; I/O New functionalities. TTree Libraries; Improvement of handling of default number of entries; MakeSelector. Histogram Libraries; TH1; TGraph; TGraph2D; Fitting; TFormula. Math Libraries; Random numbers. R Interface; TMVA; RooFit Libraries; 2D Graphics Libraries; THistPainter; TTeXDump; TLatex; TColor; TMultiGraph; TASImage; TCreatePrimitives; TCanvas; Cocoa Backend; freetype library. 3D Graphics Libraries; Geometry Libraries; Database Libraries; Networking Libraries; THttpServer; TNetXNGFileStager; TWebFile. GUI Libraries; Montecarlo Libraries; Multi-processing; Language Bindings; Notebooks. JavaScript ROOT; Class Reference Guide; Tutorials; Build, Configuration and Testing Infrastructure; Patch Releases; Release 6.06/02; Core; Dictionaries; Interpreter; Meta Library; TTree; Histogram Libraries; Math; TColor; PyROOT; Bug Fixes and Tasks. Release 6.06/04; General; Dictionaries; Interpreter Library; I/O; Meta; Core; Minuit; Bug fixes. Release 6.06/06; Cling; Core; Dictionaries; TTree; Bugs fixed in this release. Release 6.06/08; Core; Hist. Bugs fixed in this release; HEAD of the v6-06-00-patches branch. Introduction; ROOT version 6.06/00 was released on December 10, 2015.; For more information, see:; http://root.cern.ch; The following people have contributed to this new version:; David Abdurachmanov, CERN, CMS,; Bertrand Bellenot, CERN/SFT,; Rene Brun, CERN/SFT,; Philippe Canal, FNAL,; Cristina Cristescu, CERN/SFT,; Olivier Couet, CERN/SFT,; Kyle Cranmer, NYU, RooStats,; Gerri Ganis, CERN/SFT,; Andrei Gheata, CERN/SFT,; Enrico Guiraud, CERN/SFT,; Burt Holzman, Fermilab, CMS,; Lukasz Janyst, CERN/IT,; Christopher Jones, Fermilab, CMS,; Wim ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v606/release-notes.html:163,safe,safety,163,doc/v606/release-notes.html,https://root.cern,https://root.cern/doc/v606/release-notes.html,1,['safe'],['safety']
Safety,". ROOT Version 6.24 Release Notes. ROOT Version 6.24 Release Notes; 2022-09-29. Introduction; General; Deprecation and Removal; Header Dependency Reduction. Core Libraries; Dynamic Path: ROOT_LIBRARY_PATH; Interpreter; Multithreading. I/O Libraries; TTree Libraries; RDataFrame; New features; Behavior changes; Notable bug fixes and improvements; Distributed computing with RDataFrame. Histogram Libraries; Math Libraries; Minuit2. TMVA; RooFit Libraries; Massive speed up of RooFit’s BatchMode on CPUs with vector extensions; Unbiased binned fits; More accurate residual and pull distributions; Improved recovery from invalid parameters; Modernised RooDataHist; New fully parametrised Crystal Ball shape class. 2D Graphics Libraries; Networking Libraries; Multithreaded support for FastCGI; Better security for THttpServer with webgui; Enabled WLCG Bearer Tokens support in RDavix; Xrootd client support. GUI Libraries; RBrowser improvements. JavaScript ROOT; Major JSROOT update to version 6. Class Reference Guide; Build, Configuration and Testing Infrastructure; PyROOT; Bugs and Issues fixed in this release; Release 6.24/02; RDataFrame; Bugs and Issues fixed in this release. Release 6.24/04; Bugs and Issues fixed in this release. Release 6.24/06; Bugs and Issues fixed in this release. Release 6.24/08; Bugs and Issues fixed in this release. HEAD of the v6-24-00-patches branch. Introduction; ROOT version 6.24/00 was released on April 14, 2022.; For more information, see:; http://root.cern; The following people have contributed to this new version:; Guilherme Amadio, CERN/SFT,; Bertrand Bellenot, CERN/SFT,; Josh Bendavid, CERN/CMS,; Jakob Blomer, CERN/SFT,; Rene Brun, CERN/SFT,; Philippe Canal, FNAL,; Olivier Couet, CERN/SFT,; Anirudh Dagar, CERN-SFT/GSOC,; Hans Dembinski, TU Dortmund/LHCb,; Massimiliano Galli, CERN/SFT,; Andrei Gheata, CERN/SFT,; Hadrien Grasland, IJCLab/LAL,; Enrico Guiraud, CERN/SFT,; Claire Guyot, CERN/SFT,; Jonas Hahnfeld, CERN/SFT,; Emmanouil Michalainas, CER",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v624/release-notes.html:605,recover,recovery,605,doc/v624/release-notes.html,https://root.cern,https://root.cern/doc/v624/release-notes.html,1,['recover'],['recovery']
Safety,". ROOT Version 6.32 Release Notes. ROOT Version 6.32 Release Notes; 2024-05-26. Introduction; Deprecation and Removal; Core Libraries; I/O Libraries; hadd respects compression settings. TTree Libraries; Add files from subdirectories with TChain::Add globbing; Improved efficiency of TTree friends with indices. RNTuple; Histogram Libraries; Parallelism; RooFit Libraries; New CPU likelihood evaluation backend by default; Asymptotically correct uncertainties for extended unbinned likelihood fits; Compile your code with memory safe interfaces; Removal of some memory-unsafe interfaces; Deprecation of legacy iterators; Deprecation of legacy test statistics classes in public interface; Change of RooParamHistFunc; Renaming of some RooFit classes. RDataFrame; Graphics backends; 2D Graphics Libraries; 3D Graphics Libraries; REve. PROOF Libraries; PyROOT; Different representation of std::string; No more implicit conversion of static size char buffer to Python strings; Deprecate the attribute pythonization of TDirectory in favor of item-getting syntax; Removal of Python 2 support; More usage of the public cppyy API. Class Reference Guide; Build, Configuration and Testing Infrastructure; Bugs and Issues fixed in this release; Release 6.32.02; Items addressed in this release. Release 6.32.04; Items addressed in this release. Release 6.32.06; Items addressed in this release. HEAD of the v6-32-00-patches branch. Introduction; ROOT version 6.32.00 was released on 28 May 2024. This release is a long term support one, ideal for inclusion in production or data taking software stacks of experiments.; For more information, see:; http://root.cern; The following people have contributed to this new version:; Anton Alkin, Sungkyunkwan University; Guilherme Amadio, CERN/IT,; Abhigyan Acherjee, University of Cincinnati,; Bertrand Bellenot, CERN/EP-SFT,; Jakob Blomer, CERN/EP-SFT,; Rene Brun,; Carsten Burgard, DESY; Will Buttinger, RAL,; Philippe Canal, FNAL,; Jolly Chen, CERN/EP-SFT,; Olivier Co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/release-notes.html:528,safe,safe,528,doc/v632/release-notes.html,https://root.cern,https://root.cern/doc/v632/release-notes.html,2,"['safe', 'unsafe']","['safe', 'unsafe']"
Safety,. ROOT: Basic 3D graphics. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes ; Basic 3D graphics.Graphics » 3D Graphics. ; The basic 3D classes. . Shapes.; TPolyMarker3D example. . Classes; class  TAxis3D;  The 3D axis painter class. More...;  ; class  TBRIK;  A box with faces perpendicular to the axes. More...;  ; class  TCONE;  A conical tube. More...;  ; class  TCONS;  A segment of a conical tube. More...;  ; class  TCTUB;  A cut tube with 11 parameters. More...;  ; class  TELTU;  A cylinder with an elliptical section. More...;  ; class  TGeometry;  TGeometry description. More...;  ; class  TGTRA;  A general twisted trapezoid. More...;  ; class  THelix;  THelix has two different constructors. More...;  ; class  THYPE;  An hyperboloid (not implemented) More...;  ; class  TMarker3DBox;  A special 3-D marker designed for event display. More...;  ; class  TMaterial;  Manages a detector material. More...;  ; class  TMixture;  Manages a detector mixture. More...;  ; class  TNode;  TNode description. More...;  ; class  TNodeDiv;  Description of parameters to divide a 3-D geometry object. More...;  ; class  TPARA;  A parallelepiped. More...;  ; class  TPCON;  A polycone. More...;  ; class  TPGON;  A polygon. More...;  ; class  TPoints3DABC;  Abstract class to define Arrays of 3D points. More...;  ; class  TPointSet3D;  TPolyMarker3D using TPointSet3DGL for direct OpenGL rendering. More...;  ; class  TPolyLine3D;  A 3-dimensional polyline. More...;  ; class  TPolyMarker3D;  A 3D polymarker. More...;  ; class  TRotMatrix;  Manages a detector rotation matrix. More...;  ; class  TShape;  This is the base class for all geometry shapes. More...;  ; class  TSPHE;  A Sphere. More...;  ; class  TTRAP;  A general trapezoid. More...;  ; class  TTRD1;  A trapezoid with the x dimension varying along z. More...;  ; class  TTRD2;  A trapezoid with both x and y dimensions varying along z. More...;  ; class  TTUBE;  A tube. More...;  ; class  TTUBS; ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__g3d.html:928,detect,detector,928,doc/master/group__g3d.html,https://root.cern,https://root.cern/doc/master/group__g3d.html,2,['detect'],['detector']
Safety,". ROOT: Event display tutorials. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Files ; Event display tutorialsTutorials. ; Examples showing the ""Event display classes"" usage. . Files; file  alice_esd.C;  Complex example showing ALICE ESD track visualization. ;  ; file  alice_esd_html_summary.C;  Html table and event summary for alice_esd.C. ;  ; file  alice_esd_split.C;  Complex example showing ALICE ESD visualization in several views. ;  ; file  alice_vsd.C;  Complex example showing ALICE VSD visualization. ;  ; file  annotation.C;  Demonstrates usage of TGLAnnotation class. ;  ; file  arrow.C;  Demonstrates usage of TEveArrow class. ;  ; file  arrow_standalone.C;  How to use EVE without the standard window. ;  ; file  assembly.C;  Geometry detector assembly example. ;  ; file  box.C;  Demonstrates usage of TEveBox class. ;  ; file  box.C;  Demonstrates usage of TEveBox class. ;  ; file  boxset.C;  Demonstrates usage of TEveBoxSet class. ;  ; file  boxset.C;  Demonstrates usage of REveBoxSet class. ;  ; file  boxset_cones.C;  Demonstrates usage of 'cone' mode in TEveBoxSet class. ;  ; file  boxset_cones.C;  Demonstrates usage of 'cone' mode in REveBoxSet class. ;  ; file  calo_detail.C;  Calorimeter detailed view by using TEveCaloDataVec as data-source. ;  ; file  calorimeters.C;  Demonstrates usage of EVE calorimetry classes. ;  ; file  camera_restore.C;  ; file  compound.C;  Demonstrates usage of EVE compound objects - class TEveCompound. ;  ; file  csgdemo.C;  Combinatorial Solid Geometry example. ;  ; file  geom_alias.C;  Demonstrates usage of geometry aliases - merge ALICE ITS with ATLAS MUON. ;  ; file  geom_alice_its.C;  Shows geometry of ALICE ITS. ;  ; file  geom_alice_tpc.C;  Shows geometry of ALICE TPC. ;  ; file  geom_atlas.C;  Shows ATLAS geometry. ;  ; file  geom_atlas_playback.C;  Plays back event-recording of a root session running geom_atlas.C tutorial. ;  ; file  geom_cms.C;  Shows CMS geometry. ;  ; file  geom_cm",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__tutorial__eve.html:787,detect,detector,787,doc/master/group__tutorial__eve.html,https://root.cern,https://root.cern/doc/master/group__tutorial__eve.html,1,['detect'],['detector']
Safety,". ROOT: Fit Tutorials. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Files ; Fit TutorialsTutorials. ; These tutorials illustrate the main fitting features. Their names are related to the aspect which is treated in the code. . Files; file  combinedFit.C;   Combined (simultaneous) fit of two histogram with separate functions and some common parameters ;  ; file  combinedFit.py;   Combined (simultaneous) fit of two histogram with separate functions and some common parameters ;  ; file  ConfidenceIntervals.C;   Illustrates TVirtualFitter::GetConfidenceIntervals This method computes confidence intervals for the fitted function ;  ; file  ErrorIntegral.C;   Estimate the error in the integral of a fitted function taking into account the errors in the parameters resulting from the fit. ;  ; file  exampleFit3D.C;   example of fitting a 3D function Typical multidimensional parametric regression where the predictor depends on 3 variables ;  ; file  fit1.C;   Simple fitting example (1-d histogram with an interpreted function) ;  ; file  fit2.C;   Fitting a 2-D histogram This tutorial illustrates : ;  ; file  fit2a.C;   Fitting a 2-D histogram (a variant) This tutorial illustrates : ;  ; file  fit2d.C;   Example illustrating how to fit a 2-d histogram of type y=f(x) ;  ; file  fit2dHist.C;   Example to fit two histograms at the same time via the Fitter class. ;  ; file  fitCircle.C;   Generate points distributed with some errors around a circle Fit a circle through the points and draw To run the script, do, eg ;  ; file  fitcont.C;   Example illustrating how to draw the n-sigma contour of a Minuit fit. ;  ; file  fitConvolution.C;   Tutorial for convolution of two functions ;  ; file  fitConvolution.py;   Tutorial for convolution of two functions ;  ; file  fitExclude.C;   Illustrates how to fit excluding points in a given range. ;  ; file  fithist.C;   Example of fit where the model is histogram + function ;  ; file  fitLinear.C;   Example of ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__tutorial__fit.html:944,predict,predictor,944,doc/master/group__tutorial__fit.html,https://root.cern,https://root.cern/doc/master/group__tutorial__fit.html,1,['predict'],['predictor']
Safety,". ROOT: Geometry tutorials. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Files ; Geometry tutorialsTutorials. ; Various ROOT geometry package examples. . Files; file  assembly.C;  Geometry detector assembly example. ;  ; file  building.C;  Drawing a building where Dept. ;  ; file  cheongwadae.C;  Drawing the Cheongwadae building which is the Presidential Residence of the Republic of Korea, using ROOT geometry class. ;  ; file  csgdemo.C;  Combinatorial Solid Geometry example. ;  ; file  geodemo.C;  GUI to draw the geometry shapes. ;  ; file  geomAlice.C;  Script drawing a detector geometry (here ALICE). ;  ; file  geomAlice_itsv.C;  Script drawing a detector geometry (here ITSV from Alice). ;  ; file  geomAtlas.C;  Script drawing a detector geometry (here ATLAS). ;  ; file  geomBrahms.C;  Script drawing a detector geometry (here BRAHMS). ;  ; file  geomD0.C;  Script drawing a detector geometry (here D0). ;  ; file  geometry.C;  Example of the old geometry package (now obsolete) ;  ; file  lego.C;  Drawing a figure, made of lego block, using ROOT geometry class. ;  ; file  mp3player.C;  Drawing a mp3 type music player, using ROOT geometry class. ;  ; file  na49.C;  This file has been generated automatically via the root utility toroot from an interactive version of GEANT (see ROOT class TGeometry header for an example of use) This shows an example of the old geometry package (now obsolete) ;  ; file  na49geomfile.C;  Before executing this macro, the file makegeometry.C must have been executed. ;  ; file  na49view.C;  This macro generates with 2 views of the NA49 detector using the old obsolete geometry package. ;  ; file  parallel_world.C;  Misaligning geometry generate in many cases overlaps, due to the idealization of the design and the fact that in real life movements of the geometry volumes have constraints and are correlated. ;  ; file  RadioNuclides.C;  Macro that demonstrates usage of radioactive elements/materials/mixtures w",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__tutorial__geom.html:225,detect,detector,225,doc/master/group__tutorial__geom.html,https://root.cern,https://root.cern/doc/master/group__tutorial__geom.html,6,['detect'],['detector']
Safety,". ROOT: JetEvent Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Private Attributes |; Static Private Attributes |; List of all members ; JetEvent Class Reference. . Definition at line 64 of file JetEvent.h. Public Member Functions;  JetEvent ();  Create a JetEvent object. ;  ;  ~JetEvent () override;  ; Hit * AddHitA ();  Add a new hit to the list of hits in detector A. ;  ; Hit * AddHitB ();  Add a new hit to the list of hits in detector B. ;  ; Jet * AddJet ();  Add a new Jet to the list of tracks for this event. ;  ; Track * AddTrack ();  Add a new track to the list of tracks for this event. ;  ; void Build (Int_t jetm=3, Int_t trackm=10, Int_t hitam=100, Int_t hitbm=10);  Build one event. ;  ; void Clear (Option_t *option="""") override;  ; TClonesArray * GetJets () const;  ; Int_t GetNhitA () const;  ; Int_t GetNhitB () const;  ; Int_t GetNjet () const;  ; Int_t GetNtrack () const;  ; void Reset (Option_t *option="""");  Static function to reset all static objects for this event. ;  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual TObject * Clone (const char *newname="""") const;  Make a clone of an object using the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classJetEvent.html:462,detect,detector,462,doc/master/classJetEvent.html,https://root.cern,https://root.cern/doc/master/classJetEvent.html,2,['detect'],['detector']
Safety,". ROOT: Multicore tutorials. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Files ; Multicore tutorialsTutorials. ; These examples aim to illustrate the multicore features of ROOT, such as thread awareness and safety, multithreading and multiprocessing. . Files; file  imt001_parBranchProcessing.C;   Demonstrate how to activate and use the implicit parallelisation of TTree::GetEntry. ;  ; file  imt101_parTreeProcessing.C;   Illustrate the usage of the TTreeProcessorMT::Process method. ;  ; file  mp001_fillHistos.C;   Fill histograms in parallel and write them on file. ;  ; file  mp101_fillNtuples.C;   Fill n-tuples in distinct workers. ;  ; file  mp102_readNtuplesFillHistosAndFit.C;   Read n-tuples in distinct workers, fill histograms, merge them and fit. ;  ; file  mp103_processSelector.C;   Illustrate the usage of the multiproc TSelector interfaces with the h1 analysis example. ;  ; file  mp104_processH1.C;   Illustrate the usage of the multiproc to process the H1 analysis example. ;  ; file  mp105_processEntryList.C;   Illustrate the usage of the multiproc to process TEntryList with the H1 analysis example. ;  ; file  mp201_parallelHistoFill.C;   Parallel fill of a histogram This tutorial shows how a histogram can be filled in parallel with a multiprocess approach. ;  ; file  mp_H1_lambdas.C;   Lambdas used to check and fit the result of the H1 analysis. ;  ; file  mt001_fillHistos.C;   Fill histograms in parallel and write them on file. ;  ; file  mt101_fillNtuples.C;   Fill n-tuples in distinct workers. ;  ; file  mt102_readNtuplesFillHistosAndFit.C;   Read n-tuples in distinct workers, fill histograms, merge them and fit. ;  ; file  mt103_fillNtupleFromMultipleThreads.C;   Fill the same TNtuple from different threads. ;  ; file  mt201_parallelHistoFill.C;   Parallel fill of a histogram. ;  ; file  mt301_TTaskGroupSimple.C;   Shows how to run items of work asynchronously with a TTaskGroup. ;  ; file  mt304_fillHistos.C;   Fill hi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__tutorial__multicore.html:244,safe,safety,244,doc/master/group__tutorial__multicore.html,https://root.cern,https://root.cern/doc/master/group__tutorial__multicore.html,1,['safe'],['safety']
Safety,". ROOT: RNTuple Introduction. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. RNTuple Introduction. RNTuple (for n-tuple and nested tuple) is the experimental evolution of TTree columnar data storage. RNTuple introduces new interfaces that aim to be more robust. In particular, the new interfaces are type-safe through the use of templates, and the ownership is well-defined through the use of smart pointers. For instance tree->Branch(""px"", &Category, ""px/F"");; becomes auto px = model->MakeField<float>(""px"");; // px is std::shared_ptr<float>; The physical layout changes slightly from big endian to little endian so that it matches the in-memory layout on most modern architectures. Combined with a clear separation of offset/index data and payload data for collections, uncompressed RNTuple data can be directly mapped to memory without further copies. Goals; RNTuple shall investigate improvements of the TTree I/O in the following ways. More speed; Improve mapping to vectorized and parallel hardware; For types known at compile / JIT time: generate optimized code; Optimized for simple types (float, int, and vectors of them); Better memory control: work with a fixed budget of pre-defined I/O buffers; Naturally thread-safe and asynchronous interfaces. More robust interfaces; Compile-time type safety by default; Decomposition into layers: logical layer, primitives layer, storage layer; Separation of data model and live data; Self-contained I/O code to support creation of a standalone I/O library. Concepts; At the logical layer, the user defines a data model using the RNTupleModel class. The data model is a collection of serializable C++ types with associated names, similar to branches in a TTree. The data model can contain (nested) collections, e.g., a type can be std::vector<std::vector<float>>.; Each serializable type is represented by a field, concretely by a templated version of RField, e.g. RField<double>. A field can generate or adopt an as",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/md_tree_2ntuple_2v7_2doc_2README.html:339,safe,safe,339,doc/master/md_tree_2ntuple_2v7_2doc_2README.html,https://root.cern,https://root.cern/doc/master/md_tree_2ntuple_2v7_2doc_2README.html,1,['safe'],['safe']
Safety,". ROOT: ROOT::Experimental::RFieldBase Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Classes |; Public Types |; Public Member Functions |; Static Public Member Functions |; Static Public Attributes |; Protected Member Functions |; Static Protected Member Functions |; Protected Attributes |; Private Types |; Private Member Functions |; Private Attributes |; Friends |; List of all members ; ROOT::Experimental::RFieldBase Class ReferenceabstractNTuple-related classes. ; A field translates read and write calls from/to underlying columns to/from tree values. ; A field is a serializable C++ type or a container for a collection of sub fields. The RFieldBase and its type-safe descendants provide the object to column mapper. They map C++ objects to primitive columns. The mapping is trivial for simple types such as 'double'. Complex types resolve to multiple primitive columns. The field knows based on its type and the field name the type(s) and name(s) of the columns.; Note: the class hierarchy starting at RFieldBase is not meant to be extended by user-provided child classes. This is and can only be partially enforced through C++. ; Definition at line 67 of file RFieldBase.hxx. Classes; class  RBulk;  Similar to RValue but manages an array of consecutive values. More...;  ; struct  RBulkSpec;  ; struct  RCheckResult;  Used in the return value of the Check() method. More...;  ; class  RColumnRepresentations;  Some fields have multiple possible column representations, e.g. More...;  ; struct  RCreateObjectDeleter;  ; struct  RCreateObjectDeleter< void >;  ; class  RDeleter;  A functor to release the memory acquired by CreateValue (memory and constructor). More...;  ; class  RSchemaIteratorTemplate;  Iterates over the sub tree of fields in depth-first search order. More...;  ; struct  RSharedPtrDeleter;  ; class  RTypedDeleter;  A deleter for templated RFieldBase descendents where the value type is known. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RFieldBase.html:747,safe,safe,747,doc/master/classROOT_1_1Experimental_1_1RFieldBase.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RFieldBase.html,1,['safe'],['safe']
Safety,". ROOT: ROOT::Internal::RConcurrentHashColl Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Classes |; Public Member Functions |; Static Public Member Functions |; Private Attributes |; List of all members ; ROOT::Internal::RConcurrentHashColl Class Reference. ; This class is a thread-safe associative collection connecting a 256 bits digest/hash to a collection of uid (integer) This is used in the handling of the StreamerInfo record in TFile. ; Definition at line 30 of file RConcurrentHashColl.hxx. Classes; class  HashValue;  . Public Member Functions;  RConcurrentHashColl ();  ;  ~RConcurrentHashColl ();  ; const RUidColl * Find (const HashValue &hash) const;  Return the collection of UID corresponding to the hash if the hash has already been seen or nullptr otherwise. ;  ; bool Insert (const HashValue &hash, RUidColl &&coll) const;  If the hash is there, return false. ;  . Static Public Member Functions; static HashValue Hash (char *buf, int len);  Return the hash object corresponding to the buffer. ;  . Private Attributes; std::unique_ptr< RHashMap > fHashMap;  ; std::unique_ptr< ROOT::TRWSpinLock > fRWLock;  . #include <ROOT/RConcurrentHashColl.hxx>; Constructor & Destructor Documentation. ◆ RConcurrentHashColl(). ROOT::Internal::RConcurrentHashColl::RConcurrentHashColl ; (; ). Definition at line 41 of file RConcurrentHashColl.cxx. ◆ ~RConcurrentHashColl(). ROOT::Internal::RConcurrentHashColl::~RConcurrentHashColl ; (; ). default . Member Function Documentation. ◆ Find(). const RUidColl * ROOT::Internal::RConcurrentHashColl::Find ; (; const HashValue & ; hash); const. Return the collection of UID corresponding to the hash if the hash has already been seen or nullptr otherwise. ; Definition at line 46 of file RConcurrentHashColl.cxx. ◆ Hash(). RConcurrentHashColl::HashValue ROOT::Internal::RConcurrentHashColl::Hash ; (; char * ; buf, . int ; len . ). static . Return the hash object correspond",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Internal_1_1RConcurrentHashColl.html:359,safe,safe,359,doc/master/classROOT_1_1Internal_1_1RConcurrentHashColl.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Internal_1_1RConcurrentHashColl.html,1,['safe'],['safe']
Safety,". ROOT: ROOT::Internal::RDF Namespace Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces |; Classes |; Typedefs |; Functions |; Variables ; ROOT::Internal::RDF Namespace Reference. Namespaces; namespace  GraphDrawing;  . Classes; class  ArrayPtrVisitor;  ; struct  CallGuaranteedOrder;  Struct to wrap the call to a function with a guaranteed order of execution of its arguments. More...;  ; struct  ColumnType;  ; struct  ColumnType< ROOT::RVec< ROOT::RVec< T > >, false >;  ; struct  ColumnType< ROOT::RVec< T >, true >;  ; struct  Disjunction;  ; struct  Disjunction< B1 >;  ; struct  Disjunction< B1, Bn... >;  ; class  DisplayHelper;  ; struct  IsDataContainer;  Check for container traits. More...;  ; struct  IsDataContainer< ROOT::VecOps::RVec< bool > >;  ; struct  IsDataContainer< std::span< T > >;  ; struct  IsDataContainer< std::vector< bool > >;  ; struct  IsVector_t;  Detect whether a type is an instantiation of vector<T,A> More...;  ; struct  IsVector_t< std::vector< T, A > >;  ; class  PassAsVecHelper;  ; class  PassAsVecHelper< std::index_sequence< N... >, T, F >;  ; class  RAction;  A RDataFrame node that produces a result. More...;  ; class  RActionBase;  ; class  RCallback;  ; struct  RColumnReadersInfo;  This type aggregates some of the arguments passed to GetColumnReaders. More...;  ; class  RColumnRegister;  A binder for user-defined columns, variations and aliases. More...;  ; class  RDefineReader;  Column reader for defined columns. More...;  ; class  RDefinesWithReaders;  A helper type that keeps track of RDefine objects and their corresponding RDefineReaders. More...;  ; class  RDisplayElement;  Helper class to let Display print compact tabular representations of the events. More...;  ; class  RDSColumnReader;  Column reader type that deals with values read from RDataSources. More...;  ; struct  RemoveFirstParameterIf;  type is TypeList if MustRemove is false, otherwise it is a TypeList with the firs",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Internal_1_1RDF.html:936,Detect,Detect,936,doc/master/namespaceROOT_1_1Internal_1_1RDF.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Internal_1_1RDF.html,1,['Detect'],['Detect']
Safety,". ROOT: ROOT::Internal::RDF::RColumnRegister Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Private Types |; Private Member Functions |; Private Attributes |; List of all members ; ROOT::Internal::RDF::RColumnRegister Class ReferenceDataframe. ; A binder for user-defined columns, variations and aliases. ; The storage is copy-on-write and shared between all instances of the class that have the same values.; Several components of an RDF computation graph make use of a column register. It keeps track of which columns have been defined, varied or aliased at each point of the computation graph. In many cases, the contents of the different column register instances are the same or only differ by a single extra defined/varied/aliased column. For this reason, in order to avoid unnecessary data duplication, fDefines, fAliases, fVariations and fColumnNames are all shared_ptr<const T> that (whenever possible) are shared across RColumnRegister instances that are part of the same computation graph. If a new column, alias or variation is added between one node and the next, then the new node contains a new instance of a RColumnRegister that shares all data members with the previous instance except for the one data member that needed updating, which is replaced with a new updated instance.; The contents of the collections that keep track of other objects of the computation graph are not owned by the RColumnRegister object. They are registered centrally by the RLoopManager and only accessed via reference in the RColumnRegister. ; Definition at line 68 of file RColumnRegister.hxx. Public Member Functions;  RColumnRegister (ROOT::Detail::RDF::RLoopManager *lm);  ; void AddAlias (std::string_view alias, std::string_view colName);  Add a new alias to the ledger. ;  ; void AddDefine (std::shared_ptr< RDFDetail::RDefineBase > column);  Add a new defined column. ;  ; void AddVariation (std:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Internal_1_1RDF_1_1RColumnRegister.html:875,avoid,avoid,875,doc/master/classROOT_1_1Internal_1_1RDF_1_1RColumnRegister.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Internal_1_1RDF_1_1RColumnRegister.html,1,['avoid'],['avoid']
Safety,". ROOT: ROOT::Math::Assign< T, D1, D2, A, MatRepSym< T, D1 >, MatRepStd< T, D1, D2 > > Struct Template Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Static Public Member Functions |; List of all members ; ROOT::Math::Assign< T, D1, D2, A, MatRepSym< T, D1 >, MatRepStd< T, D1, D2 > > Struct Template Reference. ; template<class T, unsigned int D1, unsigned int D2, class A>; struct ROOT::Math::Assign< T, D1, D2, A, MatRepSym< T, D1 >, MatRepStd< T, D1, D2 > >Dummy Structure which flags an error to avoid assignment from expression based on a general matrix to a symmetric matrix. ; Definition at line 131 of file HelperOps.h. Static Public Member Functions; static void Evaluate (SMatrix< T, D1, D2, MatRepSym< T, D1 > > &, const Expr< A, T, D1, D2, MatRepStd< T, D1, D2 > > &);  . #include <Math/HelperOps.h>; Member Function Documentation. ◆ Evaluate(). template<class T , unsigned int D1, unsigned int D2, class A > . static void ROOT::Math::Assign< T, D1, D2, A, MatRepSym< T, D1 >, MatRepStd< T, D1, D2 > >::Evaluate ; (; SMatrix< T, D1, D2, MatRepSym< T, D1 > > & ; , . const Expr< A, T, D1, D2, MatRepStd< T, D1, D2 > > & ;  . ). inlinestatic . Definition at line 133 of file HelperOps.h. The documentation for this struct was generated from the following file:; math/smatrix/inc/Math/HelperOps.h. ROOTMathAssign< T, D1, D2, A, MatRepSym< T, D1 >, MatRepStd< T, D1, D2 > >. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:19 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/structROOT_1_1Math_1_1Assign_3_01T_00_01D1_00_01D2_00_01A_00_01MatRepSym_3_01T_00_01D1_01_4_00_062d5e865199fb0af80bca6cc0f9059e9.html:569,avoid,avoid,569,doc/master/structROOT_1_1Math_1_1Assign_3_01T_00_01D1_00_01D2_00_01A_00_01MatRepSym_3_01T_00_01D1_01_4_00_062d5e865199fb0af80bca6cc0f9059e9.html,https://root.cern,https://root.cern/doc/master/structROOT_1_1Math_1_1Assign_3_01T_00_01D1_00_01D2_00_01A_00_01MatRepSym_3_01T_00_01D1_01_4_00_062d5e865199fb0af80bca6cc0f9059e9.html,1,['avoid'],['avoid']
Safety,". ROOT: ROOT::Math::IBaseParam Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; List of all members ; ROOT::Math::IBaseParam Class ReferenceabstractMath » MathCore » Function Classes and Interfaces » Parametric Function Evaluation Interfaces. ; Documentation for the abstract class IBaseParam. ; It defines the interface for dealing with the function parameters This is used only for internal convenience, to avoid redefining the Parameter API for the one and the multi-dim functions. Concrete class should derive from ROOT::Math::IParamFunction and not from this class. ; Definition at line 51 of file IParamFunction.h. Public Member Functions; virtual ~IBaseParam ();  Virtual Destructor (no operations) ;  ; virtual unsigned int NPar () const =0;  Return the number of Parameters. ;  ; virtual std::string ParameterName (unsigned int i) const;  Return the name of the i-th parameter (starting from zero) Overwrite if want to avoid the default name (""Par_0, Par_1, ..."") ;  ; virtual const double * Parameters () const =0;  Access the parameter values. ;  ; virtual void SetParameters (const double *p)=0;  Set the parameter values. ;  . #include <Math/IParamFunction.h>. Inheritance diagram for ROOT::Math::IBaseParam:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ ~IBaseParam(). virtual ROOT::Math::IBaseParam::~IBaseParam ; (; ). inlinevirtual . Virtual Destructor (no operations) ; Definition at line 59 of file IParamFunction.h. Member Function Documentation. ◆ NPar(). virtual unsigned int ROOT::Math::IBaseParam::NPar ; (; ); const. pure virtual . Return the number of Parameters. ; Implemented in ROOT::Math::ParamFunction< IParamGradFunction >, ROOT::Math::WrappedMultiTF1Templ< T >, ROOT::Math::WrappedTF1, ROOT::Math::MultiDimParamFunctionAdapter, ROOT::Math::MultiDimParamGradFunctionAdapter, RO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1IBaseParam.html:508,avoid,avoid,508,doc/master/classROOT_1_1Math_1_1IBaseParam.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1IBaseParam.html,2,['avoid'],['avoid']
Safety,". ROOT: ROOT::Math::MinusEquals< T, D1, D2, A, MatRepSym< T, D1 >, MatRepSym< T, D1 > > Struct Template Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Static Public Member Functions |; List of all members ; ROOT::Math::MinusEquals< T, D1, D2, A, MatRepSym< T, D1 >, MatRepSym< T, D1 > > Struct Template Reference. ; template<class T, unsigned int D1, unsigned int D2, class A>; struct ROOT::Math::MinusEquals< T, D1, D2, A, MatRepSym< T, D1 >, MatRepSym< T, D1 > >Specialization for symmetric matrices. ; Evaluate the expression performing a -= operation for symmetric matrices Need to have a separate functions to avoid to modify two times the off-diagonal elements (i.e applying two times the expression) Need to check whether creating a temporary object with the expression result (like in op: A -= A + B ) ; Definition at line 315 of file HelperOps.h. Static Public Member Functions; static void Evaluate (SMatrix< T, D1, D2, MatRepSym< T, D1 > > &lhs, const Expr< A, T, D1, D2, MatRepSym< T, D1 > > &rhs);  . #include <Math/HelperOps.h>; Member Function Documentation. ◆ Evaluate(). template<class T , unsigned int D1, unsigned int D2, class A > . static void ROOT::Math::MinusEquals< T, D1, D2, A, MatRepSym< T, D1 >, MatRepSym< T, D1 > >::Evaluate ; (; SMatrix< T, D1, D2, MatRepSym< T, D1 > > & ; lhs, . const Expr< A, T, D1, D2, MatRepSym< T, D1 > > & ; rhs . ). inlinestatic . Definition at line 317 of file HelperOps.h. The documentation for this struct was generated from the following file:; math/smatrix/inc/Math/HelperOps.h. ROOTMathMinusEquals< T, D1, D2, A, MatRepSym< T, D1 >, MatRepSym< T, D1 > >. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:22 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/structROOT_1_1Math_1_1MinusEquals_3_01T_00_01D1_00_01D2_00_01A_00_01MatRepSym_3_01T_00_01D1_01_430c9cf3013fba6ff738c698e3426727e.html:683,avoid,avoid,683,doc/master/structROOT_1_1Math_1_1MinusEquals_3_01T_00_01D1_00_01D2_00_01A_00_01MatRepSym_3_01T_00_01D1_01_430c9cf3013fba6ff738c698e3426727e.html,https://root.cern,https://root.cern/doc/master/structROOT_1_1Math_1_1MinusEquals_3_01T_00_01D1_00_01D2_00_01A_00_01MatRepSym_3_01T_00_01D1_01_430c9cf3013fba6ff738c698e3426727e.html,1,['avoid'],['avoid']
Safety,". ROOT: ROOT::Math::PlusEquals< T, D1, D2, A, MatRepSym< T, D1 >, MatRepSym< T, D1 > > Struct Template Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Static Public Member Functions |; List of all members ; ROOT::Math::PlusEquals< T, D1, D2, A, MatRepSym< T, D1 >, MatRepSym< T, D1 > > Struct Template Reference. ; template<class T, unsigned int D1, unsigned int D2, class A>; struct ROOT::Math::PlusEquals< T, D1, D2, A, MatRepSym< T, D1 >, MatRepSym< T, D1 > >Specialization for symmetric matrices Evaluate the expression performing a += operation for symmetric matrices Need to have a separate functions to avoid to modify two times the off-diagonal elements (i.e applying two times the expression) Need to check whether creating a temporary object with the expression result (like in op: A += A * B ) ; Definition at line 232 of file HelperOps.h. Static Public Member Functions; static void Evaluate (SMatrix< T, D1, D2, MatRepSym< T, D1 > > &lhs, const Expr< A, T, D1, D2, MatRepSym< T, D1 > > &rhs);  . #include <Math/HelperOps.h>; Member Function Documentation. ◆ Evaluate(). template<class T , unsigned int D1, unsigned int D2, class A > . static void ROOT::Math::PlusEquals< T, D1, D2, A, MatRepSym< T, D1 >, MatRepSym< T, D1 > >::Evaluate ; (; SMatrix< T, D1, D2, MatRepSym< T, D1 > > & ; lhs, . const Expr< A, T, D1, D2, MatRepSym< T, D1 > > & ; rhs . ). inlinestatic . Definition at line 234 of file HelperOps.h. The documentation for this struct was generated from the following file:; math/smatrix/inc/Math/HelperOps.h. ROOTMathPlusEquals< T, D1, D2, A, MatRepSym< T, D1 >, MatRepSym< T, D1 > >. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:23 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/structROOT_1_1Math_1_1PlusEquals_3_01T_00_01D1_00_01D2_00_01A_00_01MatRepSym_3_01T_00_01D1_01_4_ab389af18e6c21fe987654dcf40e7fea.html:677,avoid,avoid,677,doc/master/structROOT_1_1Math_1_1PlusEquals_3_01T_00_01D1_00_01D2_00_01A_00_01MatRepSym_3_01T_00_01D1_01_4_ab389af18e6c21fe987654dcf40e7fea.html,https://root.cern,https://root.cern/doc/master/structROOT_1_1Math_1_1PlusEquals_3_01T_00_01D1_00_01D2_00_01A_00_01MatRepSym_3_01T_00_01D1_01_4_ab389af18e6c21fe987654dcf40e7fea.html,1,['avoid'],['avoid']
Safety,". ROOT: ROOT::Math::PxPyPzM4D< ScalarType > Class Template Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Types |; Public Member Functions |; Static Public Attributes |; Private Member Functions |; Private Attributes |; List of all members ; ROOT::Math::PxPyPzM4D< ScalarType > Class Template ReferenceMath » Physics Vectors. ; template<class ScalarType = double>; class ROOT::Math::PxPyPzM4D< ScalarType >Class describing a 4D coordinate system or momentum-energy vectors stored as (Px, Py, Pz, M). ; This system is useful to describe ultra-relativistic particles (like electrons at LHC) to avoid numerical errors evaluating the mass when E >>> m The metric used is (-,-,-,+) Spacelike particles (M2 < 0) are described with negative mass values, but in this case m2 must always be less than P2 to preserve a positive value of E2; See alsoOverview of the physics vector library ; Definition at line 49 of file PxPyPzM4D.h. Public Types; typedef ScalarType Scalar;  . Public Member Functions;  PxPyPzM4D ();  Default constructor with x=y=z=m=0. ;  ; template<class CoordSystem > ; constexpr PxPyPzM4D (const CoordSystem &v);  construct from any 4D coordinate system class implementing X(), Y(), X() and M() ;  ;  PxPyPzM4D (const PxPyPzM4D &v);  copy constructor ;  ;  PxPyPzM4D (Scalar px, Scalar py, Scalar pz, Scalar m);  Constructor from x, y , z , m values. ;  ; Scalar E () const;  Energy. ;  ; Scalar E2 () const;  energy squared ;  ; Scalar Et () const;  transverse energy ;  ; Scalar Et2 () const;  transverse energy squared ;  ; Scalar Eta () const;  pseudorapidity ;  ; void GetCoordinates (Scalar &px, Scalar &py, Scalar &pz, Scalar &m) const;  get internal data into 4 Scalar numbers ;  ; void GetCoordinates (Scalar dest[]) const;  get internal data into an array of 4 Scalar numbers ;  ; Scalar M () const;  ; Scalar M2 () const;  vector magnitude squared (or mass squared) In case of negative mass (spacelike pa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1PxPyPzM4D.html:667,avoid,avoid,667,doc/master/classROOT_1_1Math_1_1PxPyPzM4D.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1PxPyPzM4D.html,1,['avoid'],['avoid']
Safety,. ROOT: ROOT::Math::Util Namespace Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Functions ; ROOT::Math::Util Namespace Reference. namespace defining Utility functions needed by mathcore ; More... Functions; template<class T > ; T EvalLog (T x);  safe evaluation of log(x) with a protections against negative or zero argument to the log smooth linear extrapolation below function values smaller than epsilon (better than a simple cut-off) ;  ; template<class T > ; std::string ToString (const T &val);  Utility function for conversion to strings. ;  . Detailed Description; namespace defining Utility functions needed by mathcore ; Function Documentation. ◆ EvalLog(). template<class T > . T ROOT::Math::Util::EvalLog ; (; T ; x). inline . safe evaluation of log(x) with a protections against negative or zero argument to the log smooth linear extrapolation below function values smaller than epsilon (better than a simple cut-off) ; Definition at line 64 of file Util.h. ◆ ToString(). template<class T > . std::string ROOT::Math::Util::ToString ; (; const T & ; val). Utility function for conversion to strings. ; Definition at line 50 of file Util.h. ROOTMathUtil. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:25 (GVA Time) using Doxygen 1.9.8   ; . ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Math_1_1Util.html:293,safe,safe,293,doc/master/namespaceROOT_1_1Math_1_1Util.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Math_1_1Util.html,2,['safe'],['safe']
Safety,". ROOT: ROOT::Math::WrappedFunction< Func > Class Template Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Private Member Functions |; Private Attributes |; List of all members ; ROOT::Math::WrappedFunction< Func > Class Template ReferenceMath » MathCore » Function Classes and Interfaces » Generic Function Evaluation Interfaces. ; template<typename Func = FreeFunctionPtr>; class ROOT::Math::WrappedFunction< Func >Template class to wrap any C++ callable object which takes one argument i.e. ; implementing operator() (double x) in a One-dimensional function interface. It provides a ROOT::Math::IGenFunction-like signature; Note: If you want to wrap just the reference (to avoid copying) you need to use Func& or const Func & as template parameter. The former should be used when the operator() is not a const method of Func ; Definition at line 45 of file WrappedFunction.h. Public Member Functions;  WrappedFunction (Func f);  construct from the pointer to the object and the member function ;  ; WrappedFunction * Clone () const override;  clone (required by the interface) ;  ;  Public Member Functions inherited from ROOT::Math::IBaseFunctionOneDim; virtual ~IBaseFunctionOneDim ()=default;  ; virtual bool HasGradient () const;  ; double operator() (const double *x) const;  Evaluate the function at a point x[]. ;  ; double operator() (double x) const;  Evaluate the function at a point x. ;  . Private Member Functions; double DoEval (double x) const override;  implementation of the evaluation function. Must be implemented by derived classes ;  . Private Attributes; Func fFunc;  . Additional Inherited Members;  Public Types inherited from ROOT::Math::IBaseFunctionOneDim; typedef IBaseFunctionOneDim BaseFunc;  . #include <Math/WrappedFunction.h>. Inheritance diagram for ROOT::Math::WrappedFunction< Func >:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instea",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1WrappedFunction.html:770,avoid,avoid,770,doc/master/classROOT_1_1Math_1_1WrappedFunction.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1WrappedFunction.html,1,['avoid'],['avoid']
Safety,". ROOT: ROOT::Math::WrappedMultiFunction< Func > Class Template Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Private Member Functions |; Private Attributes |; List of all members ; ROOT::Math::WrappedMultiFunction< Func > Class Template ReferenceMath » MathCore » Function Classes and Interfaces » Generic Function Evaluation Interfaces. ; template<typename Func = FreeMultiFunctionPtr>; class ROOT::Math::WrappedMultiFunction< Func >Template class to wrap any C++ callable object implementing operator() (const double * x) in a multi-dimensional function interface. ; It provides a ROOT::Math::IGenMultiFunction-like signature; Note: If you want to wrap just the reference (to avoid copying) you need to use Func& or const Func & as template parameter. The former should be used when the operator() is not a const method of Func ; Definition at line 143 of file WrappedFunction.h. Public Member Functions;  WrappedMultiFunction (Func f, unsigned int dim=1);  construct from the pointer to the object and the member function ;  ; WrappedMultiFunction * Clone () const override;  clone (required by the interface) ;  ; unsigned int NDim () const override;  Retrieve the dimension of the function. ;  ;  Public Member Functions inherited from ROOT::Math::IBaseFunctionMultiDimTempl< T >; virtual ~IBaseFunctionMultiDimTempl ()=default;  ; virtual bool HasGradient () const;  ; T operator() (const T *x) const;  Evaluate the function at a point x[]. ;  . Private Member Functions; double DoEval (const double *x) const override;  . Private Attributes; unsigned int fDim;  ; Func fFunc;  . Additional Inherited Members;  Public Types inherited from ROOT::Math::IBaseFunctionMultiDimTempl< T >; typedef T BackendType;  ; typedef IBaseFunctionMultiDimTempl< T > BaseFunc;  . #include <Math/WrappedFunction.h>. Inheritance diagram for ROOT::Math::WrappedMultiFunction< Func >:. This browser is not able to show ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1WrappedMultiFunction.html:775,avoid,avoid,775,doc/master/classROOT_1_1Math_1_1WrappedMultiFunction.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1WrappedMultiFunction.html,1,['avoid'],['avoid']
Safety,". ROOT: ROOT::RBrowserTimer Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Public Attributes |; List of all members ; ROOT::RBrowserTimer Class Reference. . Definition at line 47 of file RBrowser.cxx. Public Member Functions;  RBrowserTimer (Long_t milliSec, Bool_t mode, RBrowser &br);  !< browser processing postponed requests ;  ; void Timeout () override;  timeout handler used to process postponed requests in main ROOT thread ;  ;  Public Member Functions inherited from TTimer;  TTimer (const char *command, Long_t milliSec, Bool_t mode=kTRUE);  Create timer that times out in ms milliseconds. ;  ;  TTimer (Long_t milliSec=0, Bool_t mode=kTRUE);  Create timer that times out in ms milliseconds. ;  ;  TTimer (TObject *obj, Long_t milliSec, Bool_t mode=kTRUE);  Create timer that times out in ms milliseconds. ;  ; virtual ~TTimer ();  ; void Add () override;  ; Bool_t CheckTimer (const TTime &now);  Check if timer timed out. ;  ; TTime GetAbsTime () const;  ; const char * GetCommand () const;  ; TObject * GetObject ();  ; TTime GetTime () const;  ; UInt_t GetTimerID ();  ; Bool_t HasTimedOut () const;  ; TClass * IsA () const override;  ; Bool_t IsAsync () const;  ; Bool_t IsInterruptingSyscalls () const;  ; Bool_t IsRunning ();  This function checks if the timer is running within gSystem (Has been started and did not finish yet). ;  ; Bool_t IsSync () const;  ; Bool_t Notify () override;  Notify when timer times out. ;  ; void Remove () override;  ; void Reset ();  Reset the timer. ;  ; void SetCommand (const char *command);  Set the interpreter command to be executed at time out. ;  ; void SetInterruptSyscalls (Bool_t set=kTRUE);  When the argument is true the a-synchronous timer (SIGALRM) signal handler is set so that interrupted syscalls will not be restarted by the kernel. ;  ; void SetObject (TObject *object);  Set the object to be notified at time out. ;  ; void Se",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RBrowserTimer.html:440,Timeout,Timeout,440,doc/master/classROOT_1_1RBrowserTimer.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RBrowserTimer.html,2,"['Timeout', 'timeout']","['Timeout', 'timeout']"
Safety,". ROOT: ROOT::RBrowserTimer Class Reference. ; ROOT  ; . v6-32. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Public Attributes |; List of all members ; ROOT::RBrowserTimer Class Reference. . Definition at line 47 of file RBrowser.cxx. Public Member Functions;  RBrowserTimer (Long_t milliSec, Bool_t mode, RBrowser &br);  !< browser processing postponed requests ;  ; void Timeout () override;  timeout handler used to process postponed requests in main ROOT thread ;  ;  Public Member Functions inherited from TTimer;  TTimer (const char *command, Long_t milliSec, Bool_t mode=kTRUE);  Create timer that times out in ms milliseconds. ;  ;  TTimer (Long_t milliSec=0, Bool_t mode=kTRUE);  Create timer that times out in ms milliseconds. ;  ;  TTimer (TObject *obj, Long_t milliSec, Bool_t mode=kTRUE);  Create timer that times out in ms milliseconds. ;  ; virtual ~TTimer ();  ; void Add () override;  ; Bool_t CheckTimer (const TTime &now);  Check if timer timed out. ;  ; TTime GetAbsTime () const;  ; const char * GetCommand () const;  ; TObject * GetObject ();  ; TTime GetTime () const;  ; UInt_t GetTimerID ();  ; Bool_t HasTimedOut () const;  ; TClass * IsA () const override;  ; Bool_t IsAsync () const;  ; Bool_t IsInterruptingSyscalls () const;  ; Bool_t IsRunning ();  This function checks if the timer is running within gSystem (Has been started and did not finish yet). ;  ; Bool_t IsSync () const;  ; Bool_t Notify () override;  Notify when timer times out. ;  ; void Remove () override;  ; void Reset ();  Reset the timer. ;  ; void SetCommand (const char *command);  Set the interpreter command to be executed at time out. ;  ; void SetInterruptSyscalls (Bool_t set=kTRUE);  When the argument is true the a-synchronous timer (SIGALRM) signal handler is set so that interrupted syscalls will not be restarted by the kernel. ;  ; void SetObject (TObject *object);  Set the object to be notified at time out. ;  ; void Set",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RBrowserTimer.html:439,Timeout,Timeout,439,doc/v632/classROOT_1_1RBrowserTimer.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RBrowserTimer.html,2,"['Timeout', 'timeout']","['Timeout', 'timeout']"
Safety,". ROOT: ROOT::RRangeCast< T, isDynamic, Range_t > Class Template Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Types |; Public Member Functions |; Private Attributes |; List of all members ; ROOT::RRangeCast< T, isDynamic, Range_t > Class Template Reference. ; template<typename T, bool isDynamic, typename Range_t>; class ROOT::RRangeCast< T, isDynamic, Range_t >Wraps any collection that can be used in range-based loops and applies static_cast<T> or dynamic_cast<T> to each element. ; Template Parameters. TThe new type to convert to. ; isDynamicIf true, dynamic_cast is used, otherwise static_cast is used. ; Range_tThe type of the input range, which should be usually a reference type to avoid copying. . Definition at line 135 of file RRangeCast.hxx. Public Types; using const_iterator = Internal::TypedIter< T, decltype(std::cbegin(std::declval< Range_t >())), isDynamic >;  ; using iterator = Internal::TypedIter< T, decltype(std::begin(std::declval< Range_t >())), isDynamic >;  . Public Member Functions;  RRangeCast (Range_t &&inputRange);  ; iterator begin ();  ; const_iterator begin () const;  ; iterator end ();  ; const_iterator end () const;  . Private Attributes; Range_t fInputRange;  . #include <ROOT/RRangeCast.hxx>. Inheritance diagram for ROOT::RRangeCast< T, isDynamic, Range_t >:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Typedef Documentation. ◆ const_iterator. template<typename T , bool isDynamic, typename Range_t > . using ROOT::RRangeCast< T, isDynamic, Range_t >::const_iterator = Internal::TypedIter<T, decltype(std::cbegin(std::declval<Range_t>())), isDynamic>. Definition at line 144 of file RRangeCast.hxx. ◆ iterator. template<typename T , bool isDynamic, typename Range_t > . using ROOT::RRangeCast< T, isDynamic, Range_t >::iterator = Internal::TypedIter<T, decltype(std::begin(std::declval<Range_t>())), isDynamic>. Definit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RRangeCast.html:769,avoid,avoid,769,doc/master/classROOT_1_1RRangeCast.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RRangeCast.html,1,['avoid'],['avoid']
Safety,". ROOT: ROOT::RRangeCast< T, isDynamic, Range_t > Class Template Reference. ; ROOT  ; . v6-32. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Types |; Public Member Functions |; Private Attributes |; List of all members ; ROOT::RRangeCast< T, isDynamic, Range_t > Class Template Reference. ; template<typename T, bool isDynamic, typename Range_t>; class ROOT::RRangeCast< T, isDynamic, Range_t >Wraps any collection that can be used in range-based loops and applies static_cast<T> or dynamic_cast<T> to each element. ; Template Parameters. TThe new type to convert to. ; isDynamicIf true, dynamic_cast is used, otherwise static_cast is used. ; Range_tThe type of the input range, which should be usually a reference type to avoid copying. . Definition at line 135 of file RRangeCast.hxx. Public Types; using const_iterator = Internal::TypedIter< T, decltype(std::cbegin(std::declval< Range_t >())), isDynamic >;  ; using iterator = Internal::TypedIter< T, decltype(std::begin(std::declval< Range_t >())), isDynamic >;  . Public Member Functions;  RRangeCast (Range_t &&inputRange);  ; iterator begin ();  ; const_iterator begin () const;  ; iterator end ();  ; const_iterator end () const;  . Private Attributes; Range_t fInputRange;  . #include <ROOT/RRangeCast.hxx>. Inheritance diagram for ROOT::RRangeCast< T, isDynamic, Range_t >:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Typedef Documentation. ◆ const_iterator. template<typename T , bool isDynamic, typename Range_t > . using ROOT::RRangeCast< T, isDynamic, Range_t >::const_iterator = Internal::TypedIter<T, decltype(std::cbegin(std::declval<Range_t>())), isDynamic>. Definition at line 144 of file RRangeCast.hxx. ◆ iterator. template<typename T , bool isDynamic, typename Range_t > . using ROOT::RRangeCast< T, isDynamic, Range_t >::iterator = Internal::TypedIter<T, decltype(std::begin(std::declval<Range_t>())), isDynamic>. Definiti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RRangeCast.html:768,avoid,avoid,768,doc/v632/classROOT_1_1RRangeCast.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RRangeCast.html,1,['avoid'],['avoid']
Safety,". ROOT: ROOT::RTreeDrawInvokeTimer Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Public Attributes |; List of all members ; ROOT::RTreeDrawInvokeTimer Class Reference. . Definition at line 86 of file RTreeViewer.cxx. Public Member Functions;  RTreeDrawInvokeTimer (Long_t milliSec, bool mode, RTreeViewer &viewer);  constructor ;  ; void Timeout () override;  timeout handler used to process postponed requests in main ROOT thread ;  ;  Public Member Functions inherited from TTimer;  TTimer (const char *command, Long_t milliSec, Bool_t mode=kTRUE);  Create timer that times out in ms milliseconds. ;  ;  TTimer (Long_t milliSec=0, Bool_t mode=kTRUE);  Create timer that times out in ms milliseconds. ;  ;  TTimer (TObject *obj, Long_t milliSec, Bool_t mode=kTRUE);  Create timer that times out in ms milliseconds. ;  ; virtual ~TTimer ();  ; void Add () override;  ; Bool_t CheckTimer (const TTime &now);  Check if timer timed out. ;  ; TTime GetAbsTime () const;  ; const char * GetCommand () const;  ; TObject * GetObject ();  ; TTime GetTime () const;  ; UInt_t GetTimerID ();  ; Bool_t HasTimedOut () const;  ; TClass * IsA () const override;  ; Bool_t IsAsync () const;  ; Bool_t IsInterruptingSyscalls () const;  ; Bool_t IsRunning ();  This function checks if the timer is running within gSystem (Has been started and did not finish yet). ;  ; Bool_t IsSync () const;  ; Bool_t Notify () override;  Notify when timer times out. ;  ; void Remove () override;  ; void Reset ();  Reset the timer. ;  ; void SetCommand (const char *command);  Set the interpreter command to be executed at time out. ;  ; void SetInterruptSyscalls (Bool_t set=kTRUE);  When the argument is true the a-synchronous timer (SIGALRM) signal handler is set so that interrupted syscalls will not be restarted by the kernel. ;  ; void SetObject (TObject *object);  Set the object to be notified at time out. ;  ; void Se",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RTreeDrawInvokeTimer.html:440,Timeout,Timeout,440,doc/master/classROOT_1_1RTreeDrawInvokeTimer.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RTreeDrawInvokeTimer.html,2,"['Timeout', 'timeout']","['Timeout', 'timeout']"
Safety,". ROOT: ROOT::RTreeDrawInvokeTimer Class Reference. ; ROOT  ; . v6-32. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Public Attributes |; List of all members ; ROOT::RTreeDrawInvokeTimer Class Reference. . Definition at line 86 of file RTreeViewer.cxx. Public Member Functions;  RTreeDrawInvokeTimer (Long_t milliSec, bool mode, RTreeViewer &viewer);  constructor ;  ; void Timeout () override;  timeout handler used to process postponed requests in main ROOT thread ;  ;  Public Member Functions inherited from TTimer;  TTimer (const char *command, Long_t milliSec, Bool_t mode=kTRUE);  Create timer that times out in ms milliseconds. ;  ;  TTimer (Long_t milliSec=0, Bool_t mode=kTRUE);  Create timer that times out in ms milliseconds. ;  ;  TTimer (TObject *obj, Long_t milliSec, Bool_t mode=kTRUE);  Create timer that times out in ms milliseconds. ;  ; virtual ~TTimer ();  ; void Add () override;  ; Bool_t CheckTimer (const TTime &now);  Check if timer timed out. ;  ; TTime GetAbsTime () const;  ; const char * GetCommand () const;  ; TObject * GetObject ();  ; TTime GetTime () const;  ; UInt_t GetTimerID ();  ; Bool_t HasTimedOut () const;  ; TClass * IsA () const override;  ; Bool_t IsAsync () const;  ; Bool_t IsInterruptingSyscalls () const;  ; Bool_t IsRunning ();  This function checks if the timer is running within gSystem (Has been started and did not finish yet). ;  ; Bool_t IsSync () const;  ; Bool_t Notify () override;  Notify when timer times out. ;  ; void Remove () override;  ; void Reset ();  Reset the timer. ;  ; void SetCommand (const char *command);  Set the interpreter command to be executed at time out. ;  ; void SetInterruptSyscalls (Bool_t set=kTRUE);  When the argument is true the a-synchronous timer (SIGALRM) signal handler is set so that interrupted syscalls will not be restarted by the kernel. ;  ; void SetObject (TObject *object);  Set the object to be notified at time out. ;  ; void Set",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RTreeDrawInvokeTimer.html:439,Timeout,Timeout,439,doc/v632/classROOT_1_1RTreeDrawInvokeTimer.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RTreeDrawInvokeTimer.html,2,"['Timeout', 'timeout']","['Timeout', 'timeout']"
Safety,". ROOT: ROOT::TMetaUtils::TClingLookupHelper Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Types |; Public Member Functions |; Private Member Functions |; Private Attributes |; List of all members ; ROOT::TMetaUtils::TClingLookupHelper Class Reference. . Definition at line 160 of file TClingUtils.h. Public Types; typedef bool(* AutoParse_t) (const char *name);  ; typedef bool(* ExistingTypeCheck_t) (const std::string &tname, std::string &result);  . Public Member Functions;  TClingLookupHelper (cling::Interpreter &interpreter, TNormalizedCtxt &normCtxt, ExistingTypeCheck_t existingTypeCheck, AutoParse_t autoParse, bool *shuttingDownPtr, const int *pgDebug=nullptr);  ; virtual ~TClingLookupHelper ();  ; bool ExistingTypeCheck (const std::string &tname, std::string &result) override;  Helper routine to ry hard to avoid looking up in the Cling database as this could enduce an unwanted autoparsing. ;  ; void GetPartiallyDesugaredName (std::string &nameLong) override;  ; bool GetPartiallyDesugaredNameWithScopeHandling (const std::string &tname, std::string &result, bool dropstd=true) override;  We assume that we have a simple type: [const] typename[*&][const]. ;  ; bool IsAlreadyPartiallyDesugaredName (const std::string &nondef, const std::string &nameLong) override;  ; bool IsDeclaredScope (const std::string &base, bool &isInlined) override;  ; void ShuttingDownSignal () override;  ;  Public Member Functions inherited from TClassEdit::TInterpreterLookupHelper;  TInterpreterLookupHelper ();  ; virtual ~TInterpreterLookupHelper ();  . Private Member Functions; bool WantDiags () const;  . Private Attributes; AutoParse_t fAutoParse;  ; ExistingTypeCheck_t fExistingTypeCheck;  ; cling::Interpreter * fInterpreter;  ; bool * fInterpreterIsShuttingDownPtr;  ; TNormalizedCtxt * fNormalizedCtxt;  ; const int * fPDebug;  . #include </home/sftnight/build/workspace/root-makedoc-master/rootspi/rdoc/src/m",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1TMetaUtils_1_1TClingLookupHelper.html:905,avoid,avoid,905,doc/master/classROOT_1_1TMetaUtils_1_1TClingLookupHelper.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1TMetaUtils_1_1TClingLookupHelper.html,1,['avoid'],['avoid']
Safety,". ROOT: RooGenContext Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Static Public Member Functions |; Protected Member Functions |; Protected Attributes |; List of all members ; RooGenContext Class ReferenceRooFit » RooFit Core. ; Implements a universal generator context for all RooAbsPdf classes that do not have or need a specialized generator context. ; This generator context queries the input p.d.f which observables it can generate internally and delegates generation of those observables to the p.d.f if it deems that safe. The other observables are generated use a RooAcceptReject sampling technique. ; Definition at line 29 of file RooGenContext.h. Public Member Functions;  RooGenContext (const RooAbsPdf &model, const RooArgSet &vars, const RooDataSet *prototype=nullptr, const RooArgSet *auxProto=nullptr, bool verbose=false, const RooArgSet *forceDirect=nullptr);  Initialize a new context for generating events with the specified variables, using the specified PDF model. ;  ;  ~RooGenContext () override;  ; void attach (const RooArgSet &params) override;  Attach the cloned model to the event buffer we will be filling. ;  ; TClass * IsA () const override;  ; void printMultiline (std::ostream &os, Int_t content, bool verbose=false, TString indent="""") const override;  Printing interface. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from RooAbsGenContext;  RooAbsGenContext (const RooAbsPdf &model, const RooArgSet &vars, const RooDataSet *prototype=nullptr, const RooArgSet *auxProto=nullptr, bool _verbose=false);  Constructor. ;  ; Int_t defaultPrintContents (Option_t *opt) const override;  Define default contents when printing. ;  ; StyleOption defaultPrintStyle (Option_t *opt) const override;  Define default print style. ;  ; virtual ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooGenContext.html:628,safe,safe,628,doc/master/classRooGenContext.html,https://root.cern,https://root.cern/doc/master/classRooGenContext.html,1,['safe'],['safe']
Safety,". ROOT: RooHelpers::WrapIntoTObject< T > Struct Template Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Public Attributes |; List of all members ; RooHelpers::WrapIntoTObject< T > Struct Template Reference. ; template<typename T>; struct RooHelpers::WrapIntoTObject< T >Wrap an object into a TObject. Sometimes needed to avoid reinterpret_cast or enable RTTI. ; Definition at line 57 of file RooHelpers.h. Public Member Functions;  WrapIntoTObject (T &obj);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Clear (Option_t *="""");  ; virtual TObject * Clone (const char *newname="""") const;  Make a clone of an object using the Streamer facility. ;  ; virtual Int_t Compare (const TObject *obj) const;  Compare abstract method. ;  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/structRooHelpers_1_1WrapIntoTObject.html:416,avoid,avoid,416,doc/master/structRooHelpers_1_1WrapIntoTObject.html,https://root.cern,https://root.cern/doc/master/structRooHelpers_1_1WrapIntoTObject.html,1,['avoid'],['avoid']
Safety,". ROOT: RooStats::MarkovChain Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Static Public Member Functions |; Protected Attributes |; List of all members ; RooStats::MarkovChain Class ReferenceRooFit » RooStats. ; Stores the steps in a Markov Chain of points. ; Allows user to access the weight and NLL value (if applicable) with which a point was added to the MarkovChain. ; Definition at line 33 of file MarkovChain.h. Public Member Functions;  MarkovChain ();  ;  MarkovChain (const char *name, const char *title, RooArgSet &parameters);  ;  MarkovChain (RooArgSet &parameters);  ;  ~MarkovChain () override;  ; virtual void Add (MarkovChain &otherChain, double discardEntries=0.0);  add another markov chain ;  ; virtual void Add (RooArgSet &entry, double nllValue, double weight=1.0);  safely add an entry to the chain ;  ; virtual void AddFast (RooArgSet &entry, double nllValue, double weight=1.0);  add an entry to the chain ONLY IF you have constructed with parameters or called SetParameters ;  ; virtual void AddWithBurnIn (MarkovChain &otherChain, Int_t burnIn=0);  add another markov chain ;  ; virtual const RooArgSet * Get () const;  get the entry at the current position ;  ; virtual const RooArgSet * Get (Int_t i) const;  get the entry at position i ;  ; virtual const RooDataSet * GetAsConstDataSet () const;  ; virtual RooFit::OwningPtr< RooDataHist > GetAsDataHist (const RooCmdArg &arg1, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}) const R__DEPRECATED(6;  Get a clone of the markov chain on which this interval is based as a RooDataHist. ;  ; virtual RooFit::OwningPtr< RooDataHist > GetAsDataHist (RooArgSet *whichVars=nullptr) const;  get this MarkovChain as a RooDataHist whose entries contain the values of whichVars. ;  ; virtual RooF",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooStats_1_1MarkovChain.html:893,safe,safely,893,doc/master/classRooStats_1_1MarkovChain.html,https://root.cern,https://root.cern/doc/master/classRooStats_1_1MarkovChain.html,1,['safe'],['safely']
Safety,". ROOT: Shapes. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Modules |; Classes ; ShapesThe Geometry Package. ; Shapes are geometrical objects that provide the basic modeling functionality. . Primitive Shapes; Navigation Methods Performed By Shapes; Creating Shapes; Dividing Shapes; Parametric Shapes. The ""shapes"" provide the definition of the local coordinate system of the volume. Any volume must have a shape. Any shape recognized by the modeller has to derive from the base **TGeoShape** class, providing methods for:. Finding out if a point defined in their local frame is contained or not by the shape;; Computing the distance to enter/exit the shape from a local point, given a known direction;; Computing the maximum distance in any direction from a local point that does NOT result in a boundary crossing of the shape (safe distance);; Computing the cosines of the normal vector to the crossed shape surface, given a starting local point and an ongoing direction. All the features above are globally managed by the modeller in order to provide navigation functionality. In addition to those, shapes have also to implement additional specific abstract methods:. Computation of the minimal box bounding the shape, given that this box have to be aligned with the local coordinates;; Algorithms for dividing the shape along a given axis. The modeller currently provides a set of 20 basic shapes, which we will call primitives. It also provides a special class allowing the creation of shapes as a result of Boolean operations between primitives. These are called composite shapes and the composition operation can be recursive (combined composites). This allows the creation of a quite large number of different shape topologies and combinations. You can have a look and run the tutorial: geodemo.C. Primitive Shapes - the general inheritance scheme; Shapes are named objects and all primitives have constructors like:; TGeoXXX(const char *name,<type> param1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Shapes__classes.html:866,safe,safe,866,doc/master/group__Shapes__classes.html,https://root.cern,https://root.cern/doc/master/group__Shapes__classes.html,1,['safe'],['safe']
Safety,". ROOT: TCefTimer Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; List of all members ; TCefTimer Class Reference. . Definition at line 33 of file RCefWebDisplayHandle.cxx. Public Member Functions;  TCefTimer (Long_t milliSec, Bool_t mode);  ; void Timeout () override;  ;  Public Member Functions inherited from TTimer;  TTimer (const char *command, Long_t milliSec, Bool_t mode=kTRUE);  Create timer that times out in ms milliseconds. ;  ;  TTimer (Long_t milliSec=0, Bool_t mode=kTRUE);  Create timer that times out in ms milliseconds. ;  ;  TTimer (TObject *obj, Long_t milliSec, Bool_t mode=kTRUE);  Create timer that times out in ms milliseconds. ;  ; virtual ~TTimer ();  ; void Add () override;  ; Bool_t CheckTimer (const TTime &now);  Check if timer timed out. ;  ; TTime GetAbsTime () const;  ; const char * GetCommand () const;  ; TObject * GetObject ();  ; TTime GetTime () const;  ; UInt_t GetTimerID ();  ; Bool_t HasTimedOut () const;  ; TClass * IsA () const override;  ; Bool_t IsAsync () const;  ; Bool_t IsInterruptingSyscalls () const;  ; Bool_t IsRunning ();  This function checks if the timer is running within gSystem (Has been started and did not finish yet). ;  ; Bool_t IsSync () const;  ; Bool_t Notify () override;  Notify when timer times out. ;  ; void Remove () override;  ; void Reset ();  Reset the timer. ;  ; void SetCommand (const char *command);  Set the interpreter command to be executed at time out. ;  ; void SetInterruptSyscalls (Bool_t set=kTRUE);  When the argument is true the a-synchronous timer (SIGALRM) signal handler is set so that interrupted syscalls will not be restarted by the kernel. ;  ; void SetObject (TObject *object);  Set the object to be notified at time out. ;  ; void SetTime (Long_t milliSec);  ; void SetTimerID (UInt_t id=0);  ; virtual void Start (Long_t milliSec=-1, Bool_t singleShot=kFALSE);  Starts the timer with a milliSec ti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTCefTimer.html:349,Timeout,Timeout,349,doc/master/classTCefTimer.html,https://root.cern,https://root.cern/doc/master/classTCefTimer.html,1,['Timeout'],['Timeout']
Safety,". ROOT: TClassTable Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Classes |; Public Types |; Public Member Functions |; Static Public Member Functions |; Private Types |; Private Member Functions |; Static Private Member Functions |; Static Private Attributes |; Friends |; List of all members ; TClassTable Class ReferenceCore ROOT classes » Containers. ; This class registers for all classes their name, id and dictionary function in a hash table. ; Classes are automatically added by the ctor of a special init class when a global of this init class is initialized when the program starts (see the ClassImp macro).; All functions in TClassTable are thread-safe. ; Definition at line 37 of file TClassTable.h. Classes; class  NormalizeThenLock;  . Public Types; enum  { ;   kNoStreamer = 0x01; , kNoInputOperator = 0x02; , kAutoStreamer = 0x04; , kHasVersion = 0x08; , ;   kHasCustomStreamerMember = 0x10; , kNtplForceNativeMode = 0x20; , kNtplForceStreamerMode = 0x40. };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  . Public Member Functions;  ~TClassTable ();  TClassTable singleton is deleted in Terminate(). ;  ; int Classes ();  ; TClass * IsA () const override;  ; void Print (Option_t *option="""") const override;  Print the class table. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; voi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClassTable.html:734,safe,safe,734,doc/master/classTClassTable.html,https://root.cern,https://root.cern/doc/master/classTClassTable.html,1,['safe'],['safe']
Safety,". ROOT: TDirectory::TContext Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Private Member Functions |; Private Attributes |; Friends |; List of all members ; TDirectory::TContext Class ReferenceCore ROOT classes » Base ROOT classes. ; TDirectory::TContext keeps track and restore the current directory. ; With this tool C++ exceptions will be guaranteed to properly restore the current directory pointer.; For example code like:; TDirectory *sav = gDirectory;; mydirectory->cd();; if (...) {; ....; sav->cd();; return;; } else if (...) {; ....; sav->cd();; return;; }; sav->cd;; return;; gDirectory#define gDirectoryDefinition TDirectory.h:384; TDirectoryDescribe directory structure in memory.Definition TDirectory.h:45; TDirectory::cdvirtual Bool_t cd()Change current directory to ""this"" directory.Definition TDirectory.cxx:538; can be replaced with the simpler and exception safe:; TDirectory::TContext context(gDirectory, mydirectory);; if (...) {; ....; return;; } else if (...) {; ....; return;; }; return;; TDirectory::TContextTDirectory::TContext keeps track and restore the current directory.Definition TDirectory.h:89. PyROOT; The functionality offered by TContext can be used in PyROOT with a context manager. Here are a few examples: import ROOT; from ROOT import TDirectory; ; with TDirectory.TContext():; # Open some file here; file = ROOT.TFile(...); # Retrieve contents from the file; histo = file.Get(""myhisto""); ; # After the 'with' statement, the current directory is restored to ROOT.gROOT; ; import ROOT; from ROOT import TDirectory; ; file1 = ROOT.TFile(""file1.root"", ""recreate""); #...; file2 = ROOT.TFile(""file2.root"", ""recreate""); #...; file3 = ROOT.TFile(""file3.root"", ""recreate""); ; # Before the 'with' statement, the current directory is file3 (the last file opened); with TDirectory.TContext(file1):; # Inside the statement, the current directory is file1; histo = ROOT.T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDirectory_1_1TContext.html:980,safe,safe,980,doc/master/classTDirectory_1_1TContext.html,https://root.cern,https://root.cern/doc/master/classTDirectory_1_1TContext.html,1,['safe'],['safe']
Safety,". ROOT: TEnv Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Static Public Member Functions |; Private Member Functions |; Private Attributes |; List of all members ; TEnv Class ReferenceCore ROOT classes » Base ROOT classes. ; The TEnv class reads config files, by default named .rootrc. ; Three types of config files are read: global, user and local files. The global file is $ROOTSYS/etc/system<name> (or ROOTETCDIR/system<name>) the user file is $HOME/<name> and the local file is ./<name>. By setting the shell variable ROOTENV_NO_HOME=1 the reading of the $HOME/<name> resource file will be skipped. This might be useful in case the home directory resides on an auto-mounted remote file system and one wants to avoid this file system from being mounted.; The format of the .rootrc file is similar to the .Xdefaults format: [+]<SystemName>.<RootName|ProgName>.<name>[(type)]: <value>; valueOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void valueDefinition TGWin32VirtualXProxy.cxx:142; typeOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t typeDefinition TGW",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEnv.html:817,avoid,avoid,817,doc/master/classTEnv.html,https://root.cern,https://root.cern/doc/master/classTEnv.html,1,['avoid'],['avoid']
Safety,". ROOT: TFFTComplexReal Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Static Public Member Functions |; Protected Member Functions |; Protected Attributes |; List of all members ; TFFTComplexReal Class Reference. ; One of the interface classes to the FFTW package, can be used directly or via the TVirtualFFT class. ; Only the basic interface of FFTW is implemented.; Computes the inverse of the real-to-complex transforms (class TFFTRealComplex) taking complex input (storing the non-redundant half of a logically Hermitian array) to real output (see FFTW manual for more details); How to use it:; Create an instance of TFFTComplexReal - this will allocate input and output arrays (unless an in-place transform is specified); Run the Init() function with the desired flags and settings; Set the data (via SetPoints(), SetPoint() or SetPointComplex() functions); Run the Transform() function; Get the output (via GetPoints(), GetPoint() or GetPointReal() functions); Repeat steps 3)-5) as needed. For a transform of the same size, but with different flags, rerun the Init() function and continue with steps 3)-5); NOTE:; running Init() function will overwrite the input array! Don't set any data before running the Init() function; FFTW computes unnormalized transform, so doing a transform followed by its inverse will lead to the original array scaled by the transform size; In Complex to Real transform the input array is destroyed. It cannot then be retrieved when using the Get's methods. . Definition at line 21 of file TFFTComplexReal.h. Public Member Functions;  TFFTComplexReal ();  default ;  ;  TFFTComplexReal (Int_t n, Bool_t inPlace);  For 1d transforms Allocates memory for the input array, and, if inPlace = kFALSE, for the output array. ;  ;  TFFTComplexReal (Int_t ndim, Int_t *n, Bool_t inPlace);  For ndim-dimensional transforms Second argument contains sizes of the transform in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFFTComplexReal.html:587,redund,redundant,587,doc/master/classTFFTComplexReal.html,https://root.cern,https://root.cern/doc/master/classTFFTComplexReal.html,1,['redund'],['redundant']
Safety,". ROOT: TFileCacheRead Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Static Public Member Functions |; Protected Member Functions |; Protected Attributes |; Private Member Functions |; List of all members ; TFileCacheRead Class ReferenceInput/Output Library. ; A cache when reading files over the network. ; A caching system to speed up network I/O, i.e. when there is no operating system caching support (like the buffer cache for local disk I/O). The cache makes sure that every I/O is done with a (large) fixed length buffer thereby avoiding many small I/O's. Currently the read cache system is used by the classes TNetFile, TNetXNGFile and TWebFile (via TFile::ReadBuffers()). When processing TTree, TChain, a specialized class TTreeCache that derives from this class is automatically created. ; Definition at line 22 of file TFileCacheRead.h. Public Member Functions;  TFileCacheRead ();  Default Constructor. ;  ;  TFileCacheRead (TFile *file, Int_t buffersize, TObject *tree=nullptr);  Creates a TFileCacheRead data structure. ;  ;  ~TFileCacheRead () override;  Destructor. ;  ; virtual Int_t AddBranch (const char *, Bool_t=kFALSE);  ; virtual Int_t AddBranch (TBranch *, Bool_t=kFALSE);  ; virtual void AddNoCacheBytesRead (Long64_t len);  ; virtual void AddNoCacheReadCalls (Int_t reads);  ; virtual void Close (Option_t *option="""");  Close out any threads or asynchronous fetches used by the underlying implementation. ;  ; virtual Int_t GetBufferSize () const;  ; virtual Long64_t GetBytesRead () const;  ; virtual Long64_t GetBytesReadExtra () const;  ; TFile * GetFile () const;  ; virtual Long64_t GetNoCacheBytesRead () const;  ; virtual Int_t GetNoCacheReadCalls () const;  ; Int_t GetNseek () const;  ; Int_t GetNtot () const;  ; Long64_t GetPrefetchedBlocks () const;  ; virtual TFilePrefetch * GetPrefetchObj ();  ; virtual Int_t GetReadCalls () const;  ; virtual Int_t GetUnzip",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFileCacheRead.html:638,avoid,avoiding,638,doc/master/classTFileCacheRead.html,https://root.cern,https://root.cern/doc/master/classTFileCacheRead.html,1,['avoid'],['avoiding']
Safety,". ROOT: TFileCacheWrite Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Static Public Member Functions |; Protected Attributes |; Private Member Functions |; List of all members ; TFileCacheWrite Class ReferenceInput/Output Library. ; A cache when writing files over the network. ; A caching system to speed up network I/O, i.e. when there is no operating system caching support (like the buffer cache for local disk I/O). The cache makes sure that every I/O is done with a (large) fixed length buffer thereby avoiding many small I/O's. Currently the write cache system is used by the classes TNetFile, TNetXNGFile and TWebFile (via TFile::WriteBuffers()).; The write cache is automatically created when writing a remote file (created in TFile::Open()). ; Definition at line 19 of file TFileCacheWrite.h. Public Member Functions;  TFileCacheWrite ();  Default Constructor. ;  ;  TFileCacheWrite (TFile *file, Int_t buffersize);  Creates a TFileCacheWrite data structure. ;  ;  ~TFileCacheWrite () override;  Destructor. ;  ; virtual Bool_t Flush ();  Flush the current write buffer to the file. ;  ; virtual Int_t GetBytesInCache () const;  ; TClass * IsA () const override;  ; void Print (Option_t *option="""") const override;  Print class internal structure. ;  ; virtual Int_t ReadBuffer (char *buf, Long64_t pos, Int_t len);  Called by the read cache to check if the requested data is not in the write cache buffer. ;  ; virtual void SetFile (TFile *file);  Set the file using this cache. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual Int_t WriteBuffer (const char *buf, Long64_t pos, Int_t len);  Write buffer at position pos in the write buffer. ;  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFileCacheWrite.html:610,avoid,avoiding,610,doc/master/classTFileCacheWrite.html,https://root.cern,https://root.cern/doc/master/classTFileCacheWrite.html,1,['avoid'],['avoiding']
Safety,". ROOT: TFractionFitter Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Static Public Member Functions |; Protected Attributes |; Private Member Functions |; List of all members ; TFractionFitter Class Reference. ; Fits MC fractions to data histogram. ; A la HMCMLL, see R. Barlow and C. Beeston, Comp. Phys. Comm. 77 (1993) 219-228, and http://www.hep.man.ac.uk/~roger/hfrac.f; The virtue of this fit is that it takes into account both data and Monte Carlo statistical uncertainties. The way in which this is done is through a standard likelihood fit using Poisson statistics; however, the template (MC) predictions are also varied within statistics, leading to additional contributions to the overall likelihood. This leads to many more fit parameters (one per bin per template), but the minimisation with respect to these additional parameters is done analytically rather than introducing them as formal fit parameters. Some special care needs to be taken in the case of bins with zero content. For more details please see the original publication cited above.; An example application of this fit is given below. For a TH1* histogram (""data"") fitted as the sum of three Monte Carlo sources (""mc""):; {; TH1F *data; //data histogram; TH1F *mc0; // first MC histogram; TH1F *mc1; // second MC histogram; TH1F *mc2; // third MC histogram; .... // retrieve histograms; TObjArray *mc = new TObjArray(3); // MC histograms are put in this array; mc->Add(mc0);; mc->Add(mc1);; mc->Add(mc2);; TFractionFitter* fit = new TFractionFitter(data, mc); // initialise; fit->Constrain(1,0.0,1.0); // constrain fraction 1 to be between 0 and 1; fit->SetRangeX(1,15); // use only the first 15 bins in the fit; Int_t status = fit->Fit(); // perform the fit; std::cout << ""fit status: "" << status << std::endl;; if (status == 0) { // check on fit status; TH1F* result = (TH1F*) fit->GetPlot();; data->Draw(""Ep"");; result",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFractionFitter.html:705,predict,predictions,705,doc/master/classTFractionFitter.html,https://root.cern,https://root.cern/doc/master/classTFractionFitter.html,1,['predict'],['predictions']
Safety,". ROOT: TGContainerScrollTimer Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Private Attributes |; List of all members ; TGContainerScrollTimer Class Reference. . Definition at line 114 of file TGCanvas.cxx. Public Member Functions;  TGContainerScrollTimer (TGContainer *t);  ; Bool_t Notify () override;  on-timeout ;  ;  Public Member Functions inherited from TTimer;  TTimer (const char *command, Long_t milliSec, Bool_t mode=kTRUE);  Create timer that times out in ms milliseconds. ;  ;  TTimer (Long_t milliSec=0, Bool_t mode=kTRUE);  Create timer that times out in ms milliseconds. ;  ;  TTimer (TObject *obj, Long_t milliSec, Bool_t mode=kTRUE);  Create timer that times out in ms milliseconds. ;  ; virtual ~TTimer ();  ; void Add () override;  ; Bool_t CheckTimer (const TTime &now);  Check if timer timed out. ;  ; TTime GetAbsTime () const;  ; const char * GetCommand () const;  ; TObject * GetObject ();  ; TTime GetTime () const;  ; UInt_t GetTimerID ();  ; Bool_t HasTimedOut () const;  ; TClass * IsA () const override;  ; Bool_t IsAsync () const;  ; Bool_t IsInterruptingSyscalls () const;  ; Bool_t IsRunning ();  This function checks if the timer is running within gSystem (Has been started and did not finish yet). ;  ; Bool_t IsSync () const;  ; Bool_t Notify () override;  Notify when timer times out. ;  ; void Remove () override;  ; void Reset ();  Reset the timer. ;  ; void SetCommand (const char *command);  Set the interpreter command to be executed at time out. ;  ; void SetInterruptSyscalls (Bool_t set=kTRUE);  When the argument is true the a-synchronous timer (SIGALRM) signal handler is set so that interrupted syscalls will not be restarted by the kernel. ;  ; void SetObject (TObject *object);  Set the object to be notified at time out. ;  ; void SetTime (Long_t milliSec);  ; void SetTimerID (UInt_t id=0);  ; virtual void Start (Long_t milliSec=-1, Bool_t singl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGContainerScrollTimer.html:411,timeout,timeout,411,doc/master/classTGContainerScrollTimer.html,https://root.cern,https://root.cern/doc/master/classTGContainerScrollTimer.html,1,['timeout'],['timeout']
Safety,". ROOT: TGFont Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Static Public Member Functions |; Protected Member Functions |; Private Attributes |; Friends |; List of all members ; TGFont Class ReferenceGUI » Low level GUI widgets. ; Encapsulate fonts used in the GUI system. ; Definition at line 140 of file TGFont.h. Public Member Functions;  ~TGFont () override;  Delete font. ;  ; TGTextLayout * ComputeTextLayout (const char *string, Int_t numChars, Int_t wrapLength, Int_t justify, Int_t flags, UInt_t *width, UInt_t *height) const;  Computes the amount of screen space needed to display a multi-line, justified string of text. ;  ; void DrawChars (Drawable_t dst, GContext_t gc, const char *source, Int_t numChars, Int_t x, Int_t y) const;  Perform a quick sanity check to ensure we won't overflow the X coordinate space. ;  ; void DrawCharsExp (Drawable_t dst, GContext_t gc, const char *source, Int_t numChars, Int_t x, Int_t y) const;  Draw a string of characters on the screen. ;  ; FontAttributes_t GetFontAttributes () const;  ; FontH_t GetFontHandle () const;  ; void GetFontMetrics (FontMetrics_t *m) const;  Get font metrics. ;  ; FontStruct_t GetFontStruct () const;  ; TClass * IsA () const override;  ; Int_t MeasureChars (const char *source, Int_t numChars, Int_t maxLength, Int_t flags, Int_t *length) const;  Determine the number of characters from the string that will fit in the given horizontal span. ;  ; FontStruct_t operator() () const;  Not inline due to a bug in g++ 2.96 20000731 (Red Hat Linux 7.0) ;  ; Int_t PostscriptFontName (TString *dst) const;  Return the name of the corresponding Postscript font for this TGFont. ;  ; void Print (Option_t *option="""") const override;  Print font info. ;  ; void SavePrimitive (std::ostream &out, Option_t *="""") override;  Save the used font as a C++ statement(s) on output stream out. ;  ; void Streamer (TBuffer &) override; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGFont.html:865,sanity check,sanity check,865,doc/master/classTGFont.html,https://root.cern,https://root.cern/doc/master/classTGFont.html,1,['sanity check'],['sanity check']
Safety,". ROOT: TGL5DDataSetEditor Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Classes |; Public Member Functions |; Static Public Member Functions |; Private Member Functions |; Private Attributes |; List of all members ; TGL5DDataSetEditor Class ReferenceGraphics » 3D Graphics » OpenGL rendering. ; GUI editor for OpenGL 5D Painter. ; Exception safety and ROOT's GUI are two mutually exclusive things. So, only ROOT's GUI here. ; Definition at line 30 of file TGL5DDataSetEditor.h. Classes; class  TGL5DEditorPrivate;  . Public Member Functions;  TGL5DDataSetEditor (const TGWindow *p=nullptr, Int_t width=140, Int_t height=30, UInt_t options=kChildFrame, Pixel_t back=GetDefaultFrameBackground());  ;  ~TGL5DDataSetEditor () override;  ; void AddNewSurface ();  Add new iso-surface. ;  ; void AlphaChanged ();  Slot connected to the Alpha entry. ;  ; void AlphaChanged (Int_t alpha);  Change transparency of selected surface. ;  ; void ApplyAlpha ();  Slot connected to the ""Apply"" button for alpha value. ;  ; void ApplyGridParameters ();  ""Apply"" button was pressed in a ""Grid"" tab. ;  ; void ApplyPlanes ();  Slot connected to the Apply Planes button. ;  ; void BoxCutToggled ();  Slot connected to the Show BoxCut check button. ;  ; void ColorChanged (Pixel_t pixelColor);  Change the color of the selected surface. ;  ; void GridParametersChanged ();  Some of controls in a ""Grid"" tab was modified. ;  ; void HighlightClicked ();  Check, if selected surface must be highlighted. ;  ; TClass * IsA () const override;  ; void NContoursChanged ();  Slot connected to the Number of Planes value-entry. ;  ; void RemoveSurface ();  Remove selected surface. ;  ; void RollbackGridParameters ();  ""Cancel"" button was pressed in a ""Grid"" tab. ;  ; void SetModel (TObject *obj) override;  Set model or disables/hides viewer. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TB",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGL5DDataSetEditor.html:417,safe,safety,417,doc/master/classTGL5DDataSetEditor.html,https://root.cern,https://root.cern/doc/master/classTGL5DDataSetEditor.html,1,['safe'],['safety']
Safety,". ROOT: TGRecorder Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Static Public Member Functions |; Private Member Functions |; Private Attributes |; Static Private Attributes |; List of all members ; TGRecorder Class ReferenceGUI » Events recorder. ; Provides GUI for TRecorder class. ; Definition at line 630 of file TRecorder.h. Public Member Functions;  TGRecorder (const TGWindow *p=nullptr, UInt_t w=230, UInt_t h=150);  The GUI for the recorder. ;  ;  ~TGRecorder () override;  Destructor. Cleanup the GUI. ;  ; TClass * IsA () const override;  ; void Replay ();  Handles push of fReplay button according to the current recorder state. ;  ; void StartStop ();  Handles push of the fStartStop button according to the current recorder state. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void Update ();  Called when fTimer timeouts (every 0.025 second) Updates GUI of recorder. ;  ;  Public Member Functions inherited from TGMainFrame;  TGMainFrame (const TGWindow *p=nullptr, UInt_t w=1, UInt_t h=1, UInt_t options=kVerticalFrame);  Create a top level main frame. ;  ;  ~TGMainFrame () override;  TGMainFrame destructor. ;  ; virtual Bool_t BindKey (const TGWindow *w, Int_t keycode, Int_t modifier) const;  Bind key to a window. ;  ; virtual void CloseWindow ();  Close and delete main frame. ;  ; void DontCallClose ();  Typically call this method in the slot connected to the CloseWindow() signal to prevent the calling of the default or any derived CloseWindow() methods to prevent premature or double deletion of this window. ;  ; TList * GetBindList () const;  ; void GetClassHints (const char *&className, const char *&resourceName) const;  ; const char * GetIconName () const override;  Returns mime type name of object. ;  ; const char * GetIconPixmap () const;  ; void GetMWMHints (",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGRecorder.html:1031,timeout,timeouts,1031,doc/master/classTGRecorder.html,https://root.cern,https://root.cern/doc/master/classTGRecorder.html,1,['timeout'],['timeouts']
Safety,". ROOT: TGeoManager Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Types |; Public Member Functions |; Static Public Member Functions |; Protected Member Functions |; Static Protected Attributes |; Private Types |; Private Member Functions |; Private Attributes |; Static Private Attributes |; List of all members ; TGeoManager Class ReferenceThe Geometry Package » Geometry classes. ; The manager class for any TGeo geometry. ; Provides user interface for geometry creation, navigation, state querying, visualization, IO, geometry checking and other utilities. General architecture; The ROOT geometry package is a tool designed for building, browsing, tracking and visualizing a detector geometry. The code is independent from other external MC for simulation, therefore it does not contain any constraints related to physics. However, the package defines a number of hooks for tracking, such as media, materials, magnetic field or track state flags, in order to allow interfacing to tracking MC's. The final goal is to be able to use the same geometry for several purposes, such as tracking, reconstruction or visualization, taking advantage of the ROOT features related to bookkeeping, I/O, histogramming, browsing and GUI's.; The geometrical modeler is the most important component of the package and it provides answers to the basic questions like ""Where am I ?"" or ""How far; from the next boundary ?"", but also to more complex ones like ""How far from; the closest surface ?"" or ""Which is the next crossing along a helix ?"".; The architecture of the modeler is a combination between a GEANT-like containment scheme and a normal CSG binary tree at the level of shapes. An important common feature of all detector geometry descriptions is the mother-daughter concept. This is the most natural approach when tracking is concerned and imposes a set of constraints to the way geometry is defined. Constructive solid geom",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoManager.html:761,detect,detector,761,doc/master/classTGeoManager.html,https://root.cern,https://root.cern/doc/master/classTGeoManager.html,1,['detect'],['detector']
Safety,". ROOT: TGeoParallelWorld Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Classes |; Public Types |; Public Member Functions |; Static Public Member Functions |; Protected Member Functions |; Protected Attributes |; Private Member Functions |; List of all members ; TGeoParallelWorld Class ReferenceThe Geometry Package » Geometry classes. ; Base class for a flat parallel geometry. ; The parallel geometry can be composed by both normal volumes added using the AddNode interface (not implemented yet) or by physical nodes which will use as position their actual global matrix with respect to the top volume of the main geometry.; All these nodes are added as daughters to the ""top"" volume of the parallel world which acts as a navigation helper in this parallel world. The parallel world has to be closed before calling any navigation method. ; Definition at line 23 of file TGeoParallelWorld.h. Classes; struct  SafetyVoxelInfo;  . Public Types; enum class  AccelerationMode { kVoxelFinder; , kBVH; };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  . Public Member Functions;  TGeoParallelWorld ();  ;  TGeoParallelWorld (const char *name, TGeoManager *mgr);  Default constructor. ;  ;  ~TGeoParallelWorld () override;  Destructor. ;  ; void AddNode (const char *path);  Add a node normally to this world. Overlapping nodes not allowe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoParallelWorld.html:987,Safe,SafetyVoxelInfo,987,doc/master/classTGeoParallelWorld.html,https://root.cern,https://root.cern/doc/master/classTGeoParallelWorld.html,1,['Safe'],['SafetyVoxelInfo']
Safety,". ROOT: TGeoPhysicalNode Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Types |; Public Member Functions |; Static Public Member Functions |; Protected Member Functions |; Protected Attributes |; List of all members ; TGeoPhysicalNode Class ReferenceThe Geometry Package » Geometry classes. ; Physical nodes are the actual 'touchable' objects in the geometry, representing a path of positioned volumes starting with the top node: path=/TOP/A_1/B_4/C_3 , where A, B, C represent names of volumes. ; The number of physical nodes is given by the total number of possible of branches in the geometry hierarchy. In case of detector geometries and specially for calorimeters this number can be of the order 1e6-1e9, therefore it is impossible to create all physical nodes as objects in memory. In TGeo, physical nodes are represented by the class TGeoPhysicalNode and can be created on demand for alignment purposes:; TGeoPhysicalNode *pn = new TGeoPhysicalNode(""path_to_object""); TGeoPhysicalNodePhysical nodes are the actual 'touchable' objects in the geometry, representing a path of positioned ...Definition TGeoPhysicalNode.h:35; TGeoPhysicalNode::TGeoPhysicalNodeTGeoPhysicalNode()Default constructor.Definition TGeoPhysicalNode.cxx:77; Once created, a physical node can be misaligned, meaning that its position or even shape can be changed:; pn->Align(TGeoMatrix* newmat, TGeoShape* newshape, Bool_t check=kFALSE); kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; TGeoMatrixGeometrical transformation package.Definition TGeoMatrix.h:38; TGeoPhysicalNode::AlignBool_t Align(TGeoMatrix *newmat=nullptr, TGeoShape *newshape=nullptr, Bool_t check=kFALSE, Double_t ovlp=0.001)Align a physical node with a new relative matrix/shape.Definition TGeoPhysicalNode.cxx:135; TGeoShapeBase abstract class for all shapes.Definition TGeoShape.h:25; bool. Definition at line 35 of file TGeoPhysicalNode.h. Public Types; enum  {",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoPhysicalNode.html:699,detect,detector,699,doc/master/classTGeoPhysicalNode.html,https://root.cern,https://root.cern/doc/master/classTGeoPhysicalNode.html,1,['detect'],['detector']
Safety,". ROOT: TGeoPolygon Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Types |; Public Member Functions |; Static Public Member Functions |; Protected Attributes |; Private Member Functions |; List of all members ; TGeoPolygon Class ReferenceThe Geometry Package » Shapes. ; An arbitrary polygon defined by vertices. ; The vertices have to be defined CLOCKWISE in the XY plane, making either a convex or concave polygon. No test for malformed polygons is performed.; A polygon is a 2D shape defined by vertices in the XY plane. It is used by TGeoXtru class for computing Contains() and Safety(). Only the pointers to the actual lists of XY values are used - these are not owned by the class.; To check if a point in XY plane is contained by a polygon, this is split into an outscribed convex polygon and the remaining polygons of its subtraction from the outscribed one. A point is INSIDE if it is contained by the outscribed polygon but NOT by the remaining ones. Since these can also be arbitrary polygons at their turn, a tree structure is formed:; P = Pconvex - (Pconvex-P) where (-) means 'subtraction'; Pconvex-P = P1 + P2 + ... where (+) means 'union'; Note that P1, P2, ... do not intersect each other and they are defined by subsets of the list of vertices of P. They can be split in the same way as P*; Therefore, if C(P) represents the Boolean : 'does P contains a given point?', then:; C(P) = C(Pconvex) .and. not(C(P1) | C(P2) | ...); For creating a polygon without TGeoXtru class, one has to call the constructor TGeoPolygon(nvert) and then SetXY(Double_t *x, Double_t *y) providing the arrays of X and Y vertex positions (defined clockwise) that have to 'live' longer than the polygon they will describe. This complication is due to efficiency reasons. At the end one has to call the FinishPolygon() method. ; Definition at line 19 of file TGeoPolygon.h. Public Types; enum  { kGeoConvex = (1ULL << ( 9 )); , ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoPolygon.html:663,Safe,Safety,663,doc/master/classTGeoPolygon.html,https://root.cern,https://root.cern/doc/master/classTGeoPolygon.html,1,['Safe'],['Safety']
Safety,". ROOT: TGeoShape Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Types |; Public Member Functions |; Static Public Member Functions |; Protected Member Functions |; Protected Attributes |; Static Private Attributes |; List of all members ; TGeoShape Class ReferenceabstractThe Geometry Package » Shapes. ; Base abstract class for all shapes. ; Shapes are geometrical objects that provide the basic modelling functionality. They provide the definition of the LOCAL frame of coordinates, with respect to which they are defined. Any implementation of a shape deriving from the base TGeoShape class has to provide methods for :. finding out if a point defined in their local frame is or not contained inside;; computing the distance from a local point to getting outside/entering the shape, given a known direction;; computing the maximum distance in any direction from a local point that does NOT result in a boundary crossing of the shape (safe distance);; computing the cosines of the normal vector to the crossed shape surface, given a starting local point and an ongoing direction. All the features above are globally managed by the modeller in order to provide navigation functionality. In addition to those, shapes have also to implement additional specific abstract methods :; computation of the minimal box bounding the shape, given that this box have to be aligned with the local coordinates;; algorithms for dividing the shape along a given axis and producing resulting divisions volumes. The modeler currently provides a set of 16 basic shapes, which we will call primitives. It also provides a special class allowing the creation of shapes made as a result of boolean operations between primitives. These are called composite shapes and the composition operation can be recursive (composition of composites). This allows the creation of a quite large number of different shape topologies and combinations.; Name",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoShape.html:1019,safe,safe,1019,doc/master/classTGeoShape.html,https://root.cern,https://root.cern/doc/master/classTGeoShape.html,1,['safe'],['safe']
Safety,". ROOT: TGeoVolumeAssembly Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Classes |; Public Member Functions |; Static Public Member Functions |; Protected Attributes |; Private Member Functions |; List of all members ; TGeoVolumeAssembly Class ReferenceThe Geometry Package » Geometry classes. ; Volume assemblies. ; Assemblies a volumes that have neither a shape or a material/medium. Assemblies behave exactly like normal volumes grouping several daughters together, but the daughters can never extrude the assembly since this has no shape. However, a bounding box and a voxelization structure are built for assemblies as for normal volumes, so that navigation is still optimized. Assemblies are useful for grouping hierarchically volumes which are otherwise defined in a flat manner, but also to avoid clashes between container shapes. To define an assembly one should just input a name, then start adding other volumes (or volume assemblies) as content. ; Definition at line 316 of file TGeoVolume.h. Classes; struct  ThreadData_t;  . Public Member Functions;  TGeoVolumeAssembly ();  Default constructor. ;  ;  TGeoVolumeAssembly (const char *name);  Constructor. ;  ;  ~TGeoVolumeAssembly () override;  Destructor. The assembly is owner of its ""shape"". ;  ; TGeoNode * AddNode (TGeoVolume *vol, Int_t copy_no, TGeoMatrix *mat=nullptr, Option_t *option="""") override;  Add a component to the assembly. ;  ; void AddNodeOverlap (TGeoVolume *vol, Int_t copy_no, TGeoMatrix *mat, Option_t *option) override;  Add an overlapping node - not allowed for assemblies. ;  ; void ClearThreadData () const override;  ; TGeoVolume * CloneVolume () const override;  Clone this volume. ;  ; void CreateThreadData (Int_t nthreads) override;  ; TGeoVolume * Divide (const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step, Int_t numed=0, Option_t *option="""") override;  Division makes no sense for assemblies. ;  ; TGe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoVolumeAssembly.html:874,avoid,avoid,874,doc/master/classTGeoVolumeAssembly.html,https://root.cern,https://root.cern/doc/master/classTGeoVolumeAssembly.html,1,['avoid'],['avoid']
Safety,". ROOT: TGeometry Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Static Public Member Functions |; Protected Member Functions |; Private Attributes |; List of all members ; TGeometry Class ReferenceGraphics » 3D Graphics » Basic 3D graphics. ; TGeometry description. ; The Geometry class describes the geometry of a detector. The current implementation supports the GEANT3 style description. A special program provided in the ROOT utilities (toroot) can be used to automatically translate a GEANT detector geometry into a ROOT geometry.; a Geometry object is entered into the list of geometries into the ROOT main object (see TROOT description) when the TGeometry constructor is invoked. Several geometries may coexist in memory. / A Geometry object consist of the following linked lists:. the TMaterial list (material definition only).; the TRotmatrix list (Rotation matrices definition only).; the TShape list (volume definition only).; the TNode list assembling all detector elements. Only the Build and Draw functions for a geometry are currently supported.; The conversion program from Geant to Root has been added in the list of utilities in utils directory.(see g2root) The executable module of g2root can be found in $ROOTSYS/bin/g2root.; To use this conversion program, type the shell command:; g2root geant_rzfile macro_name; for example; g2root na49.geom na49.C; will convert the GEANT RZ file na49.geom into a ROOT macro na49.C; To generate the Geometry structure within Root, do:; Root > .x na49.C; Root > na49.Draw(); Root > wh.x3d() (this invokes the 3-d Root viewer); Root > TFile gna49(""na49.root"",""NEW"") //open a new root file; Root > na49.Write() //Write the na49 geometry structure; Root > gna49.Write() //Write all keys (in this case only one); d#define d(i)Definition RSha256.hxx:102; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeometry.html:417,detect,detector,417,doc/master/classTGeometry.html,https://root.cern,https://root.cern/doc/master/classTGeometry.html,2,['detect'],['detector']
Safety,". ROOT: TGondzioSolver Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Static Public Member Functions |; Protected Attributes |; List of all members ; TGondzioSolver Class Reference. ; Derived class of TQpSolverBase implementing Gondzio-correction version of Mehrotra's original predictor-corrector algorithm. ; Definition at line 56 of file TGondzioSolver.h. Public Member Functions;  TGondzioSolver ();  Default constructor. ;  ;  TGondzioSolver (const TGondzioSolver &another);  Copy constructor. ;  ;  TGondzioSolver (TQpProbBase *of, TQpDataBase *prob, Int_t verbose=0);  Constructor. ;  ;  ~TGondzioSolver () override;  Deconstructor. ;  ; void DefMonitor (TQpDataBase *data, TQpVar *vars, TQpResidual *resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, Int_t status_code, Int_t level) override;  Print information about the optimization process and monitor the convergence status of thye algorithm. ;  ; TClass * IsA () const override;  ; TGondzioSolver & operator= (const TGondzioSolver &source);  Assignment operator. ;  ; virtual void Reset_parameters ();  ; Int_t Solve (TQpDataBase *prob, TQpVar *iterate, TQpResidual *resid) override;  Solve the quadratic programming problem as formulated through prob, store the final solution in iterate->fX . ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TQpSolverBase;  TQpSolverBase ();  Default constructor. ;  ;  TQpSolverBase (const TQpSolverBase &another);  Copy constructor. ;  ;  ~TQpSolverBase () override;  Deconstructor. ;  ; Double_t DataNorm ();  ; virtual void DefStart (TQpProbBase *formulation, TQpVar *iterate, TQpDataBase *prob, TQpResidual *resid, TQpVar *step);  Default starting point. ;  ; virtual Int_t DefStatus (TQpDataBase *data, TQpVar *vars, TQpResidual *resids, Int_t i,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGondzioSolver.html:379,predict,predictor-corrector,379,doc/master/classTGondzioSolver.html,https://root.cern,https://root.cern/doc/master/classTGondzioSolver.html,1,['predict'],['predictor-corrector']
Safety,". ROOT: THttpTimer Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Public Attributes |; Private Attributes |; List of all members ; THttpTimer Class Reference. . Definition at line 42 of file THttpServer.cxx. Public Member Functions;  THttpTimer (Long_t milliSec, Bool_t mode, THttpServer &serv);  !< server processing requests ;  ; Bool_t IsSlow () const;  ; void SetSlow (Bool_t flag);  ; void Timeout () override;  timeout handler used to process http requests in main ROOT thread ;  ;  Public Member Functions inherited from TTimer;  TTimer (const char *command, Long_t milliSec, Bool_t mode=kTRUE);  Create timer that times out in ms milliseconds. ;  ;  TTimer (Long_t milliSec=0, Bool_t mode=kTRUE);  Create timer that times out in ms milliseconds. ;  ;  TTimer (TObject *obj, Long_t milliSec, Bool_t mode=kTRUE);  Create timer that times out in ms milliseconds. ;  ; virtual ~TTimer ();  ; void Add () override;  ; Bool_t CheckTimer (const TTime &now);  Check if timer timed out. ;  ; TTime GetAbsTime () const;  ; const char * GetCommand () const;  ; TObject * GetObject ();  ; TTime GetTime () const;  ; UInt_t GetTimerID ();  ; Bool_t HasTimedOut () const;  ; TClass * IsA () const override;  ; Bool_t IsAsync () const;  ; Bool_t IsInterruptingSyscalls () const;  ; Bool_t IsRunning ();  This function checks if the timer is running within gSystem (Has been started and did not finish yet). ;  ; Bool_t IsSync () const;  ; Bool_t Notify () override;  Notify when timer times out. ;  ; void Remove () override;  ; void Reset ();  Reset the timer. ;  ; void SetCommand (const char *command);  Set the interpreter command to be executed at time out. ;  ; void SetInterruptSyscalls (Bool_t set=kTRUE);  When the argument is true the a-synchronous timer (SIGALRM) signal handler is set so that interrupted syscalls will not be restarted by the kernel. ;  ; void SetObject (TObject *object);  Set ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHttpTimer.html:496,Timeout,Timeout,496,doc/master/classTHttpTimer.html,https://root.cern,https://root.cern/doc/master/classTHttpTimer.html,2,"['Timeout', 'timeout']","['Timeout', 'timeout']"
Safety,". ROOT: TMVA::LossFunctionEventInfo Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Public Attributes |; List of all members ; TMVA::LossFunctionEventInfo Class Reference. . Definition at line 48 of file LossFunction.h. Public Member Functions;  LossFunctionEventInfo ();  ;  LossFunctionEventInfo (Double_t trueValue_, Double_t predictedValue_, Double_t weight_);  ;  ~LossFunctionEventInfo ();  . Public Attributes; Double_t predictedValue;  ; Double_t trueValue;  ; Double_t weight;  . #include <TMVA/LossFunction.h>; Constructor & Destructor Documentation. ◆ LossFunctionEventInfo() [1/2]. TMVA::LossFunctionEventInfo::LossFunctionEventInfo ; (; ). inline . Definition at line 51 of file LossFunction.h. ◆ LossFunctionEventInfo() [2/2]. TMVA::LossFunctionEventInfo::LossFunctionEventInfo ; (; Double_t ; trueValue_, . Double_t ; predictedValue_, . Double_t ; weight_ . ). inline . Definition at line 56 of file LossFunction.h. ◆ ~LossFunctionEventInfo(). TMVA::LossFunctionEventInfo::~LossFunctionEventInfo ; (; ). inline . Definition at line 61 of file LossFunction.h. Member Data Documentation. ◆ predictedValue. Double_t TMVA::LossFunctionEventInfo::predictedValue. Definition at line 64 of file LossFunction.h. ◆ trueValue. Double_t TMVA::LossFunctionEventInfo::trueValue. Definition at line 63 of file LossFunction.h. ◆ weight. Double_t TMVA::LossFunctionEventInfo::weight. Definition at line 65 of file LossFunction.h. Libraries for TMVA::LossFunctionEventInfo:. [legend]; The documentation for this class was generated from the following file:; tmva/tmva/inc/TMVA/LossFunction.h. TMVALossFunctionEventInfo. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:33 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1LossFunctionEventInfo.html:527,predict,predictedValue,527,doc/master/classTMVA_1_1LossFunctionEventInfo.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1LossFunctionEventInfo.html,3,['predict'],['predictedValue']
Safety,". ROOT: TMacOSXSystem Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Private Member Functions |; Private Attributes |; Friends |; List of all members ; TMacOSXSystem Class Reference. . Definition at line 39 of file TMacOSXSystem.h. Public Member Functions;  TMacOSXSystem ();  ;  ~TMacOSXSystem ();  ; bool CocoaInitialized () const;  ; void DispatchOneEvent (Bool_t pendingOnly);  Dispatch a single event. ;  ;  Public Member Functions inherited from TUnixSystem;  TUnixSystem ();  ; virtual ~TUnixSystem ();  Reset to original state. ;  ; void Abort (int code=0) override;  Abort the application. ;  ; int AcceptConnection (int sock) override;  Accept a connection. ;  ; Bool_t AccessPathName (const char *path, EAccessMode mode=kFileExists) override;  Returns FALSE if one can access a file using the specified access mode. ;  ; void AddDynamicPath (const char *lib) override;  Add a new directory to the dynamic path. ;  ; void AddFileHandler (TFileHandler *fh) override;  Add a file handler to the list of system file handlers. ;  ; void AddSignalHandler (TSignalHandler *sh) override;  Add a signal handler to list of system signal handlers. ;  ; void AddTimer (TTimer *ti) override;  Add timer to list of system timers. ;  ; int AnnounceTcpService (int port, Bool_t reuse, int backlog, int tcpwindowsize=-1) override;  Announce TCP/IP service. ;  ; int AnnounceUdpService (int port, int backlog) override;  Announce UDP service. ;  ; int AnnounceUnixService (const char *sockpath, int backlog) override;  Announce unix domain service on path 'sockpath'. ;  ; int AnnounceUnixService (int port, int backlog) override;  Announce unix domain service on path ""kServerPath/<port>"". ;  ; Bool_t ChangeDirectory (const char *path) override;  Change directory. Returns kTRUE in case of success, kFALSE otherwise. ;  ; void CheckChilds ();  Check if children have finished. ;  ; Bool_t CheckDescriptors",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMacOSXSystem.html:647,Abort,Abort,647,doc/master/classTMacOSXSystem.html,https://root.cern,https://root.cern/doc/master/classTMacOSXSystem.html,2,['Abort'],['Abort']
Safety,". ROOT: TMaterial Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Static Public Member Functions |; Protected Attributes |; List of all members ; TMaterial Class ReferenceGraphics » 3D Graphics » Basic 3D graphics. ; Manages a detector material. ; See class TGeometry ; Definition at line 28 of file TMaterial.h. Public Member Functions;  TMaterial ();  Material default constructor. ;  ;  TMaterial (const char *name, const char *title, Float_t a, Float_t z, Float_t density);  Material normal constructor. ;  ;  TMaterial (const char *name, const char *title, Float_t a, Float_t z, Float_t density, Float_t radl, Float_t inter);  Material normal constructor. ;  ;  ~TMaterial () override;  Material default destructor. ;  ; virtual Float_t GetA () const;  ; virtual Float_t GetDensity () const;  ; virtual Float_t GetInterLength () const;  ; virtual Int_t GetNumber () const;  ; virtual Float_t GetRadLength () const;  ; virtual Float_t GetZ () const;  ; TClass * IsA () const override;  ; void Streamer (TBuffer &) override;  Stream an object of class TMaterial. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMaterial.html:327,detect,detector,327,doc/master/classTMaterial.html,https://root.cern,https://root.cern/doc/master/classTMaterial.html,1,['detect'],['detector']
Safety,". ROOT: TMehrotraSolver Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Static Public Member Functions |; Protected Attributes |; List of all members ; TMehrotraSolver Class Reference. ; Derived class of TQpSolverBase implementing the original Mehrotra predictor-corrector algorithm. ; Definition at line 55 of file TMehrotraSolver.h. Public Member Functions;  TMehrotraSolver ();  Default constructor. ;  ;  TMehrotraSolver (const TMehrotraSolver &another);  Copy constructor. ;  ;  TMehrotraSolver (TQpProbBase *of, TQpDataBase *prob, Int_t verbose=0);  Constructor. ;  ;  ~TMehrotraSolver () override;  Deconstructor. ;  ; void DefMonitor (TQpDataBase *data, TQpVar *vars, TQpResidual *resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, Int_t status_code, Int_t level) override;  Print information about the optimization process and monitor the convergence status of thye algorithm. ;  ; TClass * IsA () const override;  ; TMehrotraSolver & operator= (const TMehrotraSolver &source);  Assignment operator. ;  ; Int_t Solve (TQpDataBase *prob, TQpVar *iterate, TQpResidual *resid) override;  Solve the quadratic programming problem as formulated through prob, store the final solution in iterate->fX . ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TQpSolverBase;  TQpSolverBase ();  Default constructor. ;  ;  TQpSolverBase (const TQpSolverBase &another);  Copy constructor. ;  ;  ~TQpSolverBase () override;  Deconstructor. ;  ; Double_t DataNorm ();  ; virtual void DefStart (TQpProbBase *formulation, TQpVar *iterate, TQpDataBase *prob, TQpResidual *resid, TQpVar *step);  Default starting point. ;  ; virtual Int_t DefStatus (TQpDataBase *data, TQpVar *vars, TQpResidual *resids, Int_t i, Double_t mu, Int_t level);  Default status method. ;  ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMehrotraSolver.html:353,predict,predictor-corrector,353,doc/master/classTMehrotraSolver.html,https://root.cern,https://root.cern/doc/master/classTMehrotraSolver.html,1,['predict'],['predictor-corrector']
Safety,". ROOT: TMixture Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Static Public Member Functions |; Protected Attributes |; List of all members ; TMixture Class ReferenceGraphics » 3D Graphics » Basic 3D graphics. ; Manages a detector mixture. ; See class TGeometry. ; Definition at line 27 of file TMixture.h. Public Member Functions;  TMixture ();  Mixture default constructor. ;  ;  TMixture (const char *name, const char *title, Int_t nmixt);  Mixture normal constructor. ;  ;  ~TMixture () override;  Mixture default destructor. ;  ; virtual void DefineElement (Int_t n, Float_t a, Float_t z, Float_t w);  Define one mixture element. ;  ; Float_t * GetAmixt () const;  ; Int_t GetNmixt () const;  ; Float_t * GetWmixt () const;  ; Float_t * GetZmixt () const;  ; TClass * IsA () const override;  ; void Streamer (TBuffer &) override;  Stream a class object. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TMaterial;  TMaterial ();  Material default constructor. ;  ;  TMaterial (const char *name, const char *title, Float_t a, Float_t z, Float_t density);  Material normal constructor. ;  ;  TMaterial (const char *name, const char *title, Float_t a, Float_t z, Float_t density, Float_t radl, Float_t inter);  Material normal constructor. ;  ;  ~TMaterial () override;  Material default destructor. ;  ; virtual Float_t GetA () const;  ; virtual Float_t GetDensity () const;  ; virtual Float_t GetInterLength () const;  ; virtual Int_t GetNumber () const;  ; virtual Float_t GetRadLength () const;  ; virtual Float_t GetZ () const;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMixture.html:325,detect,detector,325,doc/master/classTMixture.html,https://root.cern,https://root.cern/doc/master/classTMixture.html,1,['detect'],['detector']
Safety,". ROOT: TObjectSpy Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Static Public Member Functions |; Protected Attributes |; Private Member Functions |; List of all members ; TObjectSpy Class ReferenceCore ROOT classes » Base ROOT classes. ; Monitors objects for deletion and reflects the deletion by reverting the internal pointer to zero. ; When this pointer is zero we know the object has been deleted. This avoids the unsafe TestBit(kNotDeleted) hack. The spied object must have the kMustCleanup bit set otherwise you will get an error. ; Definition at line 30 of file TObjectSpy.h. Public Member Functions;  TObjectSpy (TObject *obj=nullptr, Bool_t fixMustCleanupBit=kTRUE);  Register the object that must be spied. ;  ; virtual ~TObjectSpy ();  Cleanup. ;  ; TObject * GetObject () const;  ; TClass * IsA () const override;  ; void RecursiveRemove (TObject *obj) override;  Sets the object pointer to zero if the object is deleted in the RecursiveRemove() operation. ;  ; void SetObject (TObject *obj, Bool_t fixMustCleanupBit=kTRUE);  Set obj as the spy target. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTObjectSpy.html:511,avoid,avoids,511,doc/master/classTObjectSpy.html,https://root.cern,https://root.cern/doc/master/classTObjectSpy.html,2,"['avoid', 'unsafe']","['avoids', 'unsafe']"
Safety,". ROOT: TPad Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Types |; Public Member Functions |; Static Public Member Functions |; Protected Member Functions |; Protected Attributes |; Static Protected Attributes |; Private Member Functions |; Private Attributes |; Friends |; List of all members ; TPad Class ReferenceGraphics » 2D Graphics » Graphics pad. ; The most important graphics class in the ROOT system. ; A Pad is contained in a Canvas.; A Pad may contain other pads (unlimited pad hierarchy).; A pad is a linked list of primitives of any type (graphics objects, histograms, detectors, tracks, etc.).; Adding a new element into a pad is in general performed by the Draw member function of the object classes.; It is important to realize that the pad is a linked list of references to the original object. For example, in case of a histogram, the histogram.Draw() operation only stores a reference to the histogram object and not a graphical representation of this histogram. When the mouse is used to change (say the bin content), the bin content of the original histogram is changed.; The convention used in ROOT is that a Draw operation only adds a reference to the object. The effective drawing is performed when the canvas receives a signal to be painted. This signal is generally sent when typing carriage return in the command input or when a graphical operation has been performed on one of the pads of this canvas. When a Canvas/Pad is repainted, the member function Paint for all objects in the Pad linked list is invoked. When the mouse is moved on the Pad, The member function DistancetoPrimitive is called for all the elements in the pad. DistancetoPrimitive returns the distance in pixels to this object.; When the object is within the distance window, the member function ExecuteEvent is called for this object.; In ExecuteEvent, move, changes can be performed on the object.; For examples of Dis",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPad.html:666,detect,detectors,666,doc/master/classTPad.html,https://root.cern,https://root.cern/doc/master/classTPad.html,1,['detect'],['detectors']
Safety,". ROOT: TParticle Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Static Public Member Functions |; Protected Attributes |; List of all members ; TParticle Class ReferenceMonte Carlo » EG. ; Description of the dynamic properties of a particle. ; A dynamic particle class created by event generators and used during the propagation in detectors. The static attributes of a TParticle are described by TParticlePDG.; Int_t fPdgCode; // PDG code of the particle; Int_t fStatusCode; // generation status code; Int_t fMother[2]; // Indices of the mother particles; Int_t fDaughter[2]; // Indices of the daughter particles; Float_t fWeight; // particle weight. Double_t fCalcMass; // Calculated mass. Double_t fPx; // x component of momentum; Double_t fPy; // y component of momentum; Double_t fPz; // z component of momentum; Double_t fE; // Energy. Double_t fVx; // x of production vertex; Double_t fVy; // y of production vertex; Double_t fVz; // z of production vertex; Double_t fVt; // t of production vertex. Double_t fPolarTheta; // Polar angle of polarisation; Double_t fPolarPhi; // azymutal angle of polarisation. TParticlePDG* fParticlePDG; //! reference to the particle record in PDG database. Definition at line 26 of file TParticle.h. Public Member Functions;  TParticle ();  reference to the particle record in PDG database ;  ;  TParticle (const TParticle &part);  copy constructor ;  ;  TParticle (Int_t pdg, Int_t status, Int_t mother1, Int_t mother2, Int_t daughter1, Int_t daughter2, const TLorentzVector &p, const TLorentzVector &v);  constructor ;  ;  TParticle (Int_t pdg, Int_t status, Int_t mother1, Int_t mother2, Int_t daughter1, Int_t daughter2, Double_t px, Double_t py, Double_t pz, Double_t etot, Double_t vx, Double_t vy, Double_t vz, Double_t time);  constructor ;  ;  ~TParticle () override;  destructor ;  ; Int_t Beauty () const;  Return beauty quantum number. ;  ; Int_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTParticle.html:434,detect,detectors,434,doc/master/classTParticle.html,https://root.cern,https://root.cern/doc/master/classTParticle.html,1,['detect'],['detectors']
Safety,". ROOT: TQt5Timer Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; List of all members ; TQt5Timer Class ReferenceWeb Display » QT5 Web Display. . Definition at line 70 of file rootqt5.cpp. Public Member Functions;  TQt5Timer (Long_t milliSec, Bool_t mode);  ; void Timeout () override;  timeout handler used to process all qt5 events in main ROOT thread ;  ;  Public Member Functions inherited from TTimer;  TTimer (const char *command, Long_t milliSec, Bool_t mode=kTRUE);  Create timer that times out in ms milliseconds. ;  ;  TTimer (Long_t milliSec=0, Bool_t mode=kTRUE);  Create timer that times out in ms milliseconds. ;  ;  TTimer (TObject *obj, Long_t milliSec, Bool_t mode=kTRUE);  Create timer that times out in ms milliseconds. ;  ; virtual ~TTimer ();  ; void Add () override;  ; Bool_t CheckTimer (const TTime &now);  Check if timer timed out. ;  ; TTime GetAbsTime () const;  ; const char * GetCommand () const;  ; TObject * GetObject ();  ; TTime GetTime () const;  ; UInt_t GetTimerID ();  ; Bool_t HasTimedOut () const;  ; TClass * IsA () const override;  ; Bool_t IsAsync () const;  ; Bool_t IsInterruptingSyscalls () const;  ; Bool_t IsRunning ();  This function checks if the timer is running within gSystem (Has been started and did not finish yet). ;  ; Bool_t IsSync () const;  ; Bool_t Notify () override;  Notify when timer times out. ;  ; void Remove () override;  ; void Reset ();  Reset the timer. ;  ; void SetCommand (const char *command);  Set the interpreter command to be executed at time out. ;  ; void SetInterruptSyscalls (Bool_t set=kTRUE);  When the argument is true the a-synchronous timer (SIGALRM) signal handler is set so that interrupted syscalls will not be restarted by the kernel. ;  ; void SetObject (TObject *object);  Set the object to be notified at time out. ;  ; void SetTime (Long_t milliSec);  ; void SetTimerID (UInt_t id=0);  ; virtual void Star",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQt5Timer.html:365,Timeout,Timeout,365,doc/master/classTQt5Timer.html,https://root.cern,https://root.cern/doc/master/classTQt5Timer.html,2,"['Timeout', 'timeout']","['Timeout', 'timeout']"
Safety,". ROOT: TQt6Timer Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; List of all members ; TQt6Timer Class ReferenceWeb Display » QT6 Web Display. . Definition at line 49 of file rootqt6.cpp. Public Member Functions;  TQt6Timer (Long_t milliSec, Bool_t mode);  ; void Timeout () override;  timeout handler used to process all qt6 events in main ROOT thread ;  ;  Public Member Functions inherited from TTimer;  TTimer (const char *command, Long_t milliSec, Bool_t mode=kTRUE);  Create timer that times out in ms milliseconds. ;  ;  TTimer (Long_t milliSec=0, Bool_t mode=kTRUE);  Create timer that times out in ms milliseconds. ;  ;  TTimer (TObject *obj, Long_t milliSec, Bool_t mode=kTRUE);  Create timer that times out in ms milliseconds. ;  ; virtual ~TTimer ();  ; void Add () override;  ; Bool_t CheckTimer (const TTime &now);  Check if timer timed out. ;  ; TTime GetAbsTime () const;  ; const char * GetCommand () const;  ; TObject * GetObject ();  ; TTime GetTime () const;  ; UInt_t GetTimerID ();  ; Bool_t HasTimedOut () const;  ; TClass * IsA () const override;  ; Bool_t IsAsync () const;  ; Bool_t IsInterruptingSyscalls () const;  ; Bool_t IsRunning ();  This function checks if the timer is running within gSystem (Has been started and did not finish yet). ;  ; Bool_t IsSync () const;  ; Bool_t Notify () override;  Notify when timer times out. ;  ; void Remove () override;  ; void Reset ();  Reset the timer. ;  ; void SetCommand (const char *command);  Set the interpreter command to be executed at time out. ;  ; void SetInterruptSyscalls (Bool_t set=kTRUE);  When the argument is true the a-synchronous timer (SIGALRM) signal handler is set so that interrupted syscalls will not be restarted by the kernel. ;  ; void SetObject (TObject *object);  Set the object to be notified at time out. ;  ; void SetTime (Long_t milliSec);  ; void SetTimerID (UInt_t id=0);  ; virtual void Star",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQt6Timer.html:365,Timeout,Timeout,365,doc/master/classTQt6Timer.html,https://root.cern,https://root.cern/doc/master/classTQt6Timer.html,2,"['Timeout', 'timeout']","['Timeout', 'timeout']"
Safety,". ROOT: TRef Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Static Public Member Functions |; Protected Attributes |; Static Protected Attributes |; Friends |; List of all members ; TRef Class ReferenceCore ROOT classes » Base ROOT classes. ; Persistent Reference link to a TObject A TRef is a lightweight object pointing to any TObject. ; This object can be used instead of normal C++ pointers in case. the referenced object R and the pointer P are not written to the same file; P is read before R; R and P are written to different Tree branches. When a top level object (eg Event *event) is a tree/graph of many objects, the normal ROOT Streaming mechanism ensures that only one copy of each object in the tree/graph is written to the output buffer to avoid circular dependencies.; However if the object event is split into several files or into several branches of one or more Trees, normal C++ pointers cannot be used because each I/O operation will write the referenced objects.; When a TRef is used to point to a TObject *robj, for example in a class with TRef fRef;; TRefPersistent Reference link to a TObject A TRef is a lightweight object pointing to any TObject.Definition TRef.h:32; one can do: fRef = robj; //to set the pointer; This TRef and robj can be written with two different I/O calls in the same or different files, in the same or different branches of a Tree.; If the TRef is read and the referenced object has not yet been read, the TRef will return a null pointer. As soon as the referenced object will be read, the TRef will point to it. If the referenced object is contained in a TTree it can be auto-loaded using the TBranchRef mechanism, which is set up by simply calling TTree::BranchRef().; TRef also supports the complex situation where a TFile is updated multiple times on the same machine or a different machine. How does it work; A TRef is itself a TObject with an ad",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTRef.html:855,avoid,avoid,855,doc/master/classTRef.html,https://root.cern,https://root.cern/doc/master/classTRef.html,1,['avoid'],['avoid']
Safety,". ROOT: TRotMatrix Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Types |; Public Member Functions |; Static Public Member Functions |; Protected Attributes |; Private Member Functions |; List of all members ; TRotMatrix Class ReferenceGraphics » 3D Graphics » Basic 3D graphics. ; Manages a detector rotation matrix. ; See class TGeometry. ; Definition at line 28 of file TRotMatrix.h. Public Types; enum  { kReflection = (1ULL << ( 23 )); };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  . Public Member Functions;  TRotMatrix ();  RotMatrix default constructor. ;  ;  TRotMatrix (const char *name, const char *title, Double_t *matrix);  RotMatrix normal constructor. ;  ;  TRotMatrix (const char *name, const char *title, Double_t theta, Double_t phi, Double_t psi);  RotMatrix normal constructor. ;  ;  TRotMatrix (const char *name, const char *title, Double_t theta1, Double_t phi1, Double_t theta2, Double_t phi2, Double_t theta3, Double_t phi3);  RotMatrix normal constructor defined a la GEANT. ;  ;  ~TRotMatrix () override;  RotMatrix default destructor. ;  ; virtual Double_t Determinant () const;  Returns the value of the determinant of this matrix. ;  ; virtual Double_t * GetGLMatrix (Double_t *rGLMatrix) const;  Convert this matrix to the OpenGL [4x4]. ;  ; virtual Double_t * GetMatrix ();  ; virtual Int_t Ge",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTRotMatrix.html:373,detect,detector,373,doc/master/classTRotMatrix.html,https://root.cern,https://root.cern/doc/master/classTRotMatrix.html,1,['detect'],['detector']
Safety,". ROOT: TSessionQueryFrame Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Static Public Member Functions |; Private Types |; Private Attributes |; List of all members ; TSessionQueryFrame Class Reference. . Definition at line 377 of file TSessionViewer.h. Public Member Functions;  TSessionQueryFrame (TGWindow *parent, Int_t w, Int_t h);  Constructor. ;  ;  ~TSessionQueryFrame () override;  Destructor. ;  ; void Build (TSessionViewer *gui);  Build query information frame. ;  ; void Feedback (TList *objs);  Feedback function connected to Feedback signal. ;  ; TEditQueryFrame * GetQueryEditFrame () const;  ; TCanvas * GetStatsCanvas () const;  ; TGTab * GetTab () const;  ; void IndicateStop (Bool_t aborted);  Indicate that Cancel or Stop was clicked. ;  ; TClass * IsA () const override;  ; void Modified (Bool_t mod=kTRUE);  Notify changes in query editor settings. ;  ; void OnBtnAbort ();  Abort processing query. ;  ; void OnBtnFinalize ();  Finalize query. ;  ; void OnBtnRetrieve ();  Retrieve query. ;  ; void OnBtnShowLog ();  Show query log. ;  ; void OnBtnStop ();  Stop processing query. ;  ; void OnBtnSubmit ();  Submit query. ;  ; void Progress (Long64_t total, Long64_t processed);  Update progress bar and status labels. ;  ; void Progress (Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti);  ; void Progress (Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti, Int_t actw, Int_t tses, Float_t eses);  New version of Progress (just forward to the old version for the time being). ;  ; void ProgressLocal (Long64_t total, Long64_t processed);  Update progress bar and status labels. ;  ; void ResetProgressDialog (const char *selec, Int_t files, Long64_t first, Long64_t entries);  Reset progress frame information fields. ;  ; void S",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSessionQueryFrame.html:806,abort,aborted,806,doc/master/classTSessionQueryFrame.html,https://root.cern,https://root.cern/doc/master/classTSessionQueryFrame.html,2,"['Abort', 'abort']","['Abort', 'aborted']"
Safety,". ROOT: TStopTimer Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Private Attributes |; List of all members ; TStopTimer Class Reference. . Definition at line 169 of file TProofPlayer.cxx. Public Member Functions;  TStopTimer (TProofPlayer *p, Bool_t abort, Int_t to);  Constructor for the timer to stop/abort processing. ;  ; Bool_t Notify () override;  Handle the signal coming from the expiration of the timer associated with an abort or stop request. ;  ;  Public Member Functions inherited from TTimer;  TTimer (const char *command, Long_t milliSec, Bool_t mode=kTRUE);  Create timer that times out in ms milliseconds. ;  ;  TTimer (Long_t milliSec=0, Bool_t mode=kTRUE);  Create timer that times out in ms milliseconds. ;  ;  TTimer (TObject *obj, Long_t milliSec, Bool_t mode=kTRUE);  Create timer that times out in ms milliseconds. ;  ; virtual ~TTimer ();  ; void Add () override;  ; Bool_t CheckTimer (const TTime &now);  Check if timer timed out. ;  ; TTime GetAbsTime () const;  ; const char * GetCommand () const;  ; TObject * GetObject ();  ; TTime GetTime () const;  ; UInt_t GetTimerID ();  ; Bool_t HasTimedOut () const;  ; TClass * IsA () const override;  ; Bool_t IsAsync () const;  ; Bool_t IsInterruptingSyscalls () const;  ; Bool_t IsRunning ();  This function checks if the timer is running within gSystem (Has been started and did not finish yet). ;  ; Bool_t IsSync () const;  ; Bool_t Notify () override;  Notify when timer times out. ;  ; void Remove () override;  ; void Reset ();  Reset the timer. ;  ; void SetCommand (const char *command);  Set the interpreter command to be executed at time out. ;  ; void SetInterruptSyscalls (Bool_t set=kTRUE);  When the argument is true the a-synchronous timer (SIGALRM) signal handler is set so that interrupted syscalls will not be restarted by the kernel. ;  ; void SetObject (TObject *object);  Set the object to be notified at",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTStopTimer.html:352,abort,abort,352,doc/master/classTStopTimer.html,https://root.cern,https://root.cern/doc/master/classTStopTimer.html,3,['abort'],['abort']
Safety,". ROOT: TTimer Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Static Public Member Functions |; Protected Attributes |; Private Member Functions |; List of all members ; TTimer Class ReferenceCore ROOT classes » Base ROOT classes. ; Handles synchronous and a-synchronous timer events. . synchronous timer is registered into TSystem and is processed within the standard ROOT event-loop.; asynchronous timer is passed to the operating system which sends an external signal to ROOT and thus interrupts its event-loop. You can use this class in one of the following ways:; Sub-class TTimer and override the Notify() method.; Re-implement the TObject::HandleTimer() method in your class and pass a pointer to this object to timer, see the SetObject() method.; Pass an interpreter command to timer, see SetCommand() method.; Create a TTimer, connect its Timeout() signal to the appropriate methods. Then when the time is up it will emit a Timeout() signal and call connected slots. Minimum timeout interval is defined in TSystem::ESysConstants as kItimerResolution (currently 10 ms).; Signal/slots example: TTimer *timer = new TTimer();; timer->Connect(""Timeout()"", ""myObjectClassName"",; myObject, ""TimerDone()"");; timer->Start(2000, kTRUE); // 2 seconds single-shot; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; TQObject::ConnectBool_t Connect(const char *signal, const char *receiver_class, void *receiver, const char *slot)Non-static method is used to connect from the signal of this object to the receiver slot.Definition TQObject.cxx:869; TTimerHandles synchronous and a-synchronous timer events.Definition TTimer.h:51; TTimer::Startvirtual void Start(Long_t milliSec=-1, Bool_t singleShot=kFALSE)Starts the timer with a milliSec timeout.Definition TTimer.cxx:213; To emit the Timeout signal repeatedly with minimum timeout: timer->Start(0, kFALSE);; kFALSEconstexpr Bool_t kFALSEDefinition ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTimer.html:949,Timeout,Timeout,949,doc/master/classTTimer.html,https://root.cern,https://root.cern/doc/master/classTTimer.html,1,['Timeout'],['Timeout']
Safety,". ROOT: TTreeReaderValue< T > Class Template Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Types |; Public Member Functions |; Protected Member Functions |; List of all members ; TTreeReaderValue< T > Class Template ReferencefinalTreePlayer Library. ; template<typename T>; class TTreeReaderValue< T >An interface for reading values stored in ROOT columnar datasets. ; The TTreeReaderValue is a type-safe tool to be used in association with a TTreeReader to access the values stored in TTree, TNtuple and TChain datasets. TTreeReaderValue can be also used to access collections such as std::vectors or TClonesArray stored in columnar datasets but it is recommended to use TTreeReaderArray instead as it offers several advantages.; See the documentation of TTreeReader for more details and examples. ; Definition at line 174 of file TTreeReaderValue.h. Public Types; using NonConstT_t = typename std::remove_const< T >::type;  ;  Public Types inherited from ROOT::Internal::TTreeReaderValueBase; typedef bool(ROOT::Detail::TBranchProxy::* BranchProxyRead_t) ();  ; enum  EReadStatus { kReadSuccess = 0; , kReadNothingYet; , kReadError; };  ; enum  ESetupStatus { ;   kSetupNotSetup = -7; , kSetupTreeDestructed = -8; , kSetupMakeClassModeMismatch = -9; , kSetupMissingCounterBranch = -6; , ;   kSetupMissingBranch = -5; , kSetupInternalError = -4; , kSetupMissingDictionary = -3; , kSetupMismatch = -2; , ;   kSetupNotACollection = -1; , kSetupMatch = 0; , kSetupMatchBranch = 7; , kSetupNoCheck = 5; , ;   kSetupMatchLeaf = 6. };  Status flags, 0 is good. More...;  . Public Member Functions;  TTreeReaderValue ()=delete;  ;  TTreeReaderValue (TTreeReader &tr, const char *branchname);  ; T * Get ();  Return a pointer to the value of the current entry. ;  ; T & operator* ();  Return a reference to the value of the current entry. ;  ; T * operator-> ();  Return a pointer to the value of the current entry. ;  ;  Public Mem",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeReaderValue.html:476,safe,safe,476,doc/master/classTTreeReaderValue.html,https://root.cern,https://root.cern/doc/master/classTTreeReaderValue.html,1,['safe'],['safe']
Safety,". ROOT: TUnfold Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Types |; Public Member Functions |; Static Public Member Functions |; Protected Member Functions |; Static Protected Member Functions |; Protected Attributes |; Private Member Functions |; Private Attributes |; List of all members ; TUnfold Class Reference. ; An algorithm to unfold distributions from detector to truth level. ; TUnfold is used to decompose a measurement y into several sources x, given the measurement uncertainties and a matrix of migrations A. The method can be applied to a large number of problems, where the measured distribution y is a linear superposition of several Monte Carlo shapes. Beyond such a simple template fit, TUnfold has an adjustable regularisation term and also supports an optional constraint on the total number of events.; For most applications, it is better to use the derived class TUnfoldDensity instead of TUnfold. TUnfoldDensity adds various features to TUnfold, such as: background subtraction, propagation of systematic uncertainties, complex multidimensional arrangements of the bins. For innocent users, the most notable improvement of TUnfoldDensity over TUnfold are the getter functions. For TUnfold, histograms have to be booked by the user and the getter functions fill the histogram bins. TUnfoldDensity simply returns a new, already filled histogram.; If you use this software, please consider the following citation ; S.Schmitt, JINST 7 (2012) T10003 [arXiv:1205.6201] ; Detailed documentation and updates are available on http://www.desy.de/~sschmitt; Brief recipy to use TUnfold: . a matrix (truth,reconstructed) is given as a two-dimensional histogram as argument to the constructor of TUnfold . a vector of measurements is given as one-dimensional histogram using the SetInput() method . The unfolding is performed . either once with a fixed parameter tau, method DoUnfold(tau) . or multiple ti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnfold.html:446,detect,detector,446,doc/master/classTUnfold.html,https://root.cern,https://root.cern/doc/master/classTUnfold.html,1,['detect'],['detector']
Safety,". ROOT: TUnfold classes. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes ; TUnfold classesHistogram Library. ; An algorithm to unfold distributions from detector to truth level.; AuthorStefan Schmitt DESY . Classes; class  TUnfoldSys;  An algorithm to unfold distributions from detector to truth level, with background subtraction and propagation of systematic uncertainties. More...;  . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:33 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Unfold.html:194,detect,detector,194,doc/master/group__Unfold.html,https://root.cern,https://root.cern/doc/master/group__Unfold.html,2,['detect'],['detector']
Safety,". ROOT: TUnfoldDensity Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Types |; Public Member Functions |; Static Public Member Functions |; Protected Member Functions |; Protected Attributes |; List of all members ; TUnfoldDensity Class Reference. ; An algorithm to unfold distributions from detector to truth level. ; TUnfoldDensity is used to decompose a measurement y into several sources x, given the measurement uncertainties, background b and a matrix of migrations A. The method can be applied to a large number of problems, where the measured distribution y is a linear superposition of several Monte Carlo shapes. Beyond such a simple template fit, TUnfoldDensity has an adjustable regularisation term and also supports an optional constraint on the total number of events. Background sources can be specified, with a normalisation constant and normalisation uncertainty. In addition, variants of the response matrix may be specified, these are taken to determine systematic uncertainties. Complex, multidimensional arrangements of signal and background bins are managed with the help of the class TUnfoldBinning.; If you use this software, please consider the following citation ; S.Schmitt, JINST 7 (2012) T10003 [arXiv:1205.6201] ; Detailed documentation and updates are available on http://www.desy.de/~sschmitt; Brief recipy to use TUnfoldSys:. Set up binning schemes for the truth and measured distributions. The binning schemes may be coded in the XML language, for reading use TUnfoldBinningXML. . A matrix (truth,reconstructed) is given as a two-dimensional histogram as argument to the constructor of TUnfold . A vector of measurements is given as one-dimensional histogram using the SetInput() method . Repeated calls to SubtractBackground() to specify background sources . Repeated calls to AddSysError() to specify systematic uncertainties . The unfolding is performed . either once with a fixed pa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnfoldDensity.html:373,detect,detector,373,doc/master/classTUnfoldDensity.html,https://root.cern,https://root.cern/doc/master/classTUnfoldDensity.html,1,['detect'],['detector']
Safety,". ROOT: TUnfoldSys Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Types |; Public Member Functions |; Static Public Member Functions |; Protected Member Functions |; Protected Attributes |; Private Member Functions |; List of all members ; TUnfoldSys Class ReferenceHistogram Library » TUnfold classes. ; An algorithm to unfold distributions from detector to truth level, with background subtraction and propagation of systematic uncertainties. ; TUnfoldSys is used to decompose a measurement y into several sources x, given the measurement uncertainties, background b and a matrix of migrations A. The method can be applied to a large number of problems, where the measured distribution y is a linear superposition of several Monte Carlo shapes. Beyond such a simple template fit, TUnfoldSys has an adjustable regularisation term and also supports an optional constraint on the total number of events. Background sources can be specified, with a normalisation constant and normalisation uncertainty. In addition, variants of the response matrix may be specified, these are taken to determine systematic uncertainties.; For most applications, it is better to use the derived class TUnfoldDensity instead of TUnfoldSys. TUnfoldDensity adds features to TUnfoldSys, related to possible complex multidimensional arrangements of bins. For innocent users, the most notable improvement of TUnfoldDensity over TUnfoldSys are the getter functions. For TUnfoldSys, histograms have to be booked by the user and the getter functions fill the histogram bins. TUnfoldDensity simply returns a new, already filled histogram.; If you use this software, please consider the following citation; S.Schmitt, JINST 7 (2012) T10003 [arXiv:1205.6201]; Detailed documentation and updates are available on http://www.desy.de/~sschmitt; Brief recipy to use TUnfoldSys: . a matrix (truth,reconstructed) is given as a two-dimensional histogram as ar",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnfoldSys.html:428,detect,detector,428,doc/master/classTUnfoldSys.html,https://root.cern,https://root.cern/doc/master/classTUnfoldSys.html,1,['detect'],['detector']
Safety,". ROOT: TUnixSystem Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Static Public Member Functions |; Protected Member Functions |; Static Protected Member Functions |; Private Member Functions |; List of all members ; TUnixSystem Class Reference. . Definition at line 32 of file TUnixSystem.h. Public Member Functions;  TUnixSystem ();  ; virtual ~TUnixSystem ();  Reset to original state. ;  ; void Abort (int code=0) override;  Abort the application. ;  ; int AcceptConnection (int sock) override;  Accept a connection. ;  ; Bool_t AccessPathName (const char *path, EAccessMode mode=kFileExists) override;  Returns FALSE if one can access a file using the specified access mode. ;  ; void AddDynamicPath (const char *lib) override;  Add a new directory to the dynamic path. ;  ; void AddFileHandler (TFileHandler *fh) override;  Add a file handler to the list of system file handlers. ;  ; void AddSignalHandler (TSignalHandler *sh) override;  Add a signal handler to list of system signal handlers. ;  ; void AddTimer (TTimer *ti) override;  Add timer to list of system timers. ;  ; int AnnounceTcpService (int port, Bool_t reuse, int backlog, int tcpwindowsize=-1) override;  Announce TCP/IP service. ;  ; int AnnounceUdpService (int port, int backlog) override;  Announce UDP service. ;  ; int AnnounceUnixService (const char *sockpath, int backlog) override;  Announce unix domain service on path 'sockpath'. ;  ; int AnnounceUnixService (int port, int backlog) override;  Announce unix domain service on path ""kServerPath/<port>"". ;  ; Bool_t ChangeDirectory (const char *path) override;  Change directory. Returns kTRUE in case of success, kFALSE otherwise. ;  ; void CheckChilds ();  Check if children have finished. ;  ; Bool_t CheckDescriptors ();  Check if there is activity on some file descriptors and call their Notify() member. ;  ; Bool_t CheckSignals (Bool_t sync);  Check if some s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnixSystem.html:501,Abort,Abort,501,doc/master/classTUnixSystem.html,https://root.cern,https://root.cern/doc/master/classTUnixSystem.html,2,['Abort'],['Abort']
Safety,". ROOT: TVectorT< Element > Class Template Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Static Public Member Functions |; Protected Types |; Protected Member Functions |; Protected Attributes |; List of all members ; TVectorT< Element > Class Template ReferenceMath » Matrix Linear Algebra. ; template<class Element>; class TVectorT< Element >TVectorT. ; Template class of Vectors in the linear algebra package.; See the Matrix Linear Algebra page for the documentation of the linear algebra package; Unless otherwise specified, vector indices always start with 0, spanning up to the specified limit-1.; For (n) vectors where n <= kSizeMax (5 currently) storage space is available on the stack, thus avoiding expensive allocation/ deallocation of heap space . However, this introduces of course kSizeMax overhead for each vector object . If this is an issue recompile with a new appropriate value (>=0) for kSizeMax; Another way to assign and store vector data is through Use see for instance stressLinear.cxx file .; Note that Constructors/assignments exists for all different matrix views; For usage examples see $ROOTSYS/test/stressLinear.cxx ; Definition at line 27 of file TVectorT.h. Public Member Functions;  TVectorT ();  ;  TVectorT (const TMatrixTColumn_const< Element > &mc);  Constructor : create vector from matrix column. ;  ;  TVectorT (const TMatrixTDiag_const< Element > &md);  Constructor : create vector from matrix diagonal. ;  ;  TVectorT (const TMatrixTRow_const< Element > &mr);  Constructor : create vector from matrix row. ;  ;  TVectorT (const TVectorT< Element > &another);  Copy constructor. ;  ; template<class Element2 > ;  TVectorT (const TVectorT< Element2 > &another);  ;  TVectorT (Int_t lwb, Int_t upb);  Constructor [lwb..upb]-vector. ;  ;  TVectorT (Int_t lwb, Int_t upb, const Element *elements);  Constructor [lwb..upb]-vector with data copied from array elements. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTVectorT.html:797,avoid,avoiding,797,doc/master/classTVectorT.html,https://root.cern,https://root.cern/doc/master/classTVectorT.html,1,['avoid'],['avoiding']
Safety,". ROOT: TVirtualFFT Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Static Public Member Functions |; Static Protected Attributes |; List of all members ; TVirtualFFT Class ReferenceabstractCore ROOT classes » Base ROOT classes. ; TVirtualFFT is an interface class for Fast Fourier Transforms. ; The default FFT library is FFTW. To use it, FFTW3 library should already be installed, and ROOT should be have fftw3 module enabled, with the directories of fftw3 include file and library specified (see installation instructions). Function SetDefaultFFT() allows to change the default library. Available transform types:; FFT:; ""C2CFORWARD"" - a complex input/output discrete Fourier transform (DFT) in one or more dimensions, -1 in the exponent; ""C2CBACKWARD""- a complex input/output discrete Fourier transform (DFT) in one or more dimensions, +1 in the exponent; ""R2C"" - a real-input/complex-output discrete Fourier transform (DFT) in one or more dimensions,; ""C2R"" - inverse transforms to ""R2C"", taking complex input (storing the non-redundant half of a logically Hermitian array) to real output; ""R2HC"" - a real-input DFT with output in ¡Èhalfcomplex¡É format, i.e. real and imaginary parts for a transform of size n stored as r0, r1, r2, ..., rn/2, i(n+1)/2-1, ..., i2, i1; ""HC2R"" - computes the reverse of FFTW_R2HC, above; ""DHT"" - computes a discrete Hartley transform. Sine/cosine transforms:; Different types of transforms are specified by parameter kind of the SineCosine() static function. 4 different kinds of sine and cosine transforms are available. DCT-I (REDFT00 in FFTW3 notation)- kind=0; DCT-II (REDFT01 in FFTW3 notation)- kind=1; DCT-III(REDFT10 in FFTW3 notation)- kind=2; DCT-IV (REDFT11 in FFTW3 notation)- kind=3; DST-I (RODFT00 in FFTW3 notation)- kind=4; DST-II (RODFT01 in FFTW3 notation)- kind=5; DST-III(RODFT10 in FFTW3 notation)- kind=6; DST-IV (RODFT11 in FFTW3 notation)- ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTVirtualFFT.html:1132,redund,redundant,1132,doc/master/classTVirtualFFT.html,https://root.cern,https://root.cern/doc/master/classTVirtualFFT.html,1,['redund'],['redundant']
Safety,". ROOT: TVirtualMutex Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Static Public Member Functions |; List of all members ; TVirtualMutex Class ReferenceabstractCore ROOT classes » Base ROOT classes. ; This class implements a mutex interface. ; The actual work is done via TMutex which is available as soon as the thread library is loaded.; and; TLockGuard; This class provides mutex resource management in a guaranteed and exception safe way. Use like this: {; TLockGuard guard(mutex);; ... // do something; }; TLockGuardDefinition TVirtualMutex.h:70; when guard goes out of scope the mutex is unlocked in the TLockGuard destructor. The exception mechanism takes care of calling the dtors of local objects so it is exception safe. ; Definition at line 32 of file TVirtualMutex.h. Public Member Functions;  TVirtualMutex (Bool_t=kFALSE);  ; virtual ~TVirtualMutex ();  ; Int_t Acquire ();  ; virtual Int_t CleanUp ()=0;  ; virtual TVirtualMutex * Factory (Bool_t=kFALSE)=0;  ; virtual TClass * IsA () const;  ; virtual Int_t Lock ()=0;  ; Int_t Release ();  ; virtual void Streamer (TBuffer &);  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual Int_t TryLock ()=0;  ; virtual Int_t UnLock ()=0;  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  . #include <TVirtualMutex.h>. Inheritance diagram for TVirtualMutex:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TVirtualMutex(). TVirtualMutex::TVirtualMutex ; (; Bool_t ; = kFALSE). inline . Definition at line 35 of file TVirtualMutex.h. ◆ ~TVirtualMutex(). virtual TVirtualMutex::~TVirtualMutex ; (; ). inlinevirtual . Definition at line 36 of file TVirtualMutex.h. Member Function Documentat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTVirtualMutex.html:536,safe,safe,536,doc/master/classTVirtualMutex.html,https://root.cern,https://root.cern/doc/master/classTVirtualMutex.html,2,['safe'],['safe']
Safety,". ROOT: TWebCanvasTimer Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Private Attributes |; List of all members ; TWebCanvasTimer Class Reference. . Definition at line 67 of file TWebCanvas.cxx. Public Member Functions;  TWebCanvasTimer (TWebCanvas &canv);  ; Bool_t IsSlow () const;  ; void SetSlow (Bool_t slow=kTRUE);  ; void Timeout () override;  used to send control messages to clients ;  ;  Public Member Functions inherited from TTimer;  TTimer (const char *command, Long_t milliSec, Bool_t mode=kTRUE);  Create timer that times out in ms milliseconds. ;  ;  TTimer (Long_t milliSec=0, Bool_t mode=kTRUE);  Create timer that times out in ms milliseconds. ;  ;  TTimer (TObject *obj, Long_t milliSec, Bool_t mode=kTRUE);  Create timer that times out in ms milliseconds. ;  ; virtual ~TTimer ();  ; void Add () override;  ; Bool_t CheckTimer (const TTime &now);  Check if timer timed out. ;  ; TTime GetAbsTime () const;  ; const char * GetCommand () const;  ; TObject * GetObject ();  ; TTime GetTime () const;  ; UInt_t GetTimerID ();  ; Bool_t HasTimedOut () const;  ; TClass * IsA () const override;  ; Bool_t IsAsync () const;  ; Bool_t IsInterruptingSyscalls () const;  ; Bool_t IsRunning ();  This function checks if the timer is running within gSystem (Has been started and did not finish yet). ;  ; Bool_t IsSync () const;  ; Bool_t Notify () override;  Notify when timer times out. ;  ; void Remove () override;  ; void Reset ();  Reset the timer. ;  ; void SetCommand (const char *command);  Set the interpreter command to be executed at time out. ;  ; void SetInterruptSyscalls (Bool_t set=kTRUE);  When the argument is true the a-synchronous timer (SIGALRM) signal handler is set so that interrupted syscalls will not be restarted by the kernel. ;  ; void SetObject (TObject *object);  Set the object to be notified at time out. ;  ; void SetTime (Long_t milliSec);  ; void SetTim",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTWebCanvasTimer.html:431,Timeout,Timeout,431,doc/master/classTWebCanvasTimer.html,https://root.cern,https://root.cern/doc/master/classTWebCanvasTimer.html,1,['Timeout'],['Timeout']
Safety,". ROOT: The Geometry Package. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Modules ; The Geometry Package. ; The ROOT geometry package is a tool for building, browsing, navigating and visualizing detector geometries. The code works standalone with respect to any tracking Monte-Carlo engine; therefore, it does not contain any constraints related to physics. However, the navigation features provided by the package are designed to optimize particle transport through complex geometries, working in correlation with simulation packages such as GEANT3, GEANT4 and FLUKA. Quick Start: Creating the world; Example 1: Creating the World; Example 2: A Geometrical Hierarchy Look and Feel. Selecting the System of Units in ROOT; Geometry Creation; The Volume Hierarchy; Creating and Positioning Volumes; Making Volumes; Example of Volume Creation; Positioned Volumes (Nodes); Virtual Containers and Assemblies of Volumes; Examples of Volume Positioning; Overlapping Volumes; Replicating Volumes; Volume Families; Dividing Volumes; Volume Assemblies. Geometrical Transformations; Matrix Creation Example; Rule for Creation of Transformations; Available Geometrical Transformations. Ownership of Geometry Objects. Navigation and Tracking; TGeoNavigator Class; Initializing the Starting Point; Initializing the Direction; Initializing the State; Checking the Current State; Saving and Restoring the Current State; Navigation Queries; Finding If Current State Is Changed For a New Point; Finding the Distance to the Next Boundary; Computing the Safe Radius; Making a Step; The Normal Vector to the Next Crossed Surface at Crossing Point. Creating and Visualizing Tracks. Checking the Geometry; The Overlap Checker; Graphical Checking Methods. The Drawing Package; Drawing Volumes and Hierarchies of Volumes; Visualization Settings and Attributes; Colors and Line Styles; Visibility Settings. Ray Tracing; Clipping Ray-traced Images. Representing Misalignments of the Ideal Ge",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:232,detect,detector,232,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['detect'],['detector']
Safety,". ROOT: core/cont/src/TClassTable.cxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TClassTable.cxx. Go to the documentation of this file. 1// @(#)root/cont:$Id$; 2// Author: Fons Rademakers 11/08/95; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12/** \class TClassTable; 13\ingroup Containers; 14This class registers for all classes their name, id and dictionary; 15function in a hash table. Classes are automatically added by the; 16ctor of a special init class when a global of this init class is; 17initialized when the program starts (see the ClassImp macro).; 18 ; 19All functions in TClassTable are thread-safe.; 20*/; 21 ; 22#include ""TClassTable.h""; 23 ; 24#include ""TClass.h""; 25#include ""TClassEdit.h""; 26#include ""TProtoClass.h""; 27#include ""TList.h""; 28#include ""TROOT.h""; 29#include ""TString.h""; 30#include ""TError.h""; 31#include ""TRegexp.h""; 32 ; 33#include ""TObjString.h""; 34#include ""TMap.h""; 35 ; 36#include ""TInterpreter.h""; 37 ; 38#include <map>; 39#include <memory>; 40#include <typeinfo>; 41#include <cstdlib>; 42#include <string>; 43#include <mutex>; 44 ; 45using namespace ROOT;; 46 ; 47TClassTable *gClassTable;; 48 ; 49TClassAlt **TClassTable::fgAlternate;; 50TClassRec **TClassTable::fgTable;; 51TClassRec **TClassTable::fgSortedTable;; 52UInt_t TClassTable::fgSize;; 53std::atomic<UInt_t> TClassTable::fgTally;; 54Bool_t TClassTable::fgSorted;; 55UInt_t TClassTable::fgCursor;; 56TClassTable::IdMap_t *TClassTable::fgIdMap;; 57 ; 58ClassImp(TClassTable);; 59 ; 60static std::mutex &GetClassTableMutex(); 61{; 62 static std::mutex sMutex;; 63 return sMutex;; 64}; 65 ; 66// RAII to first no",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClassTable_8cxx_source.html:997,safe,safe,997,doc/master/TClassTable_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClassTable_8cxx_source.html,1,['safe'],['safe']
Safety,". ROOT: core/cont/src/TClassTable.cxx Source File. ; ROOT  ; . v6-32. Reference Guide ; .  . Loading...; Searching...; No Matches. TClassTable.cxx. Go to the documentation of this file. 1// @(#)root/cont:$Id$; 2// Author: Fons Rademakers 11/08/95; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12/** \class TClassTable; 13\ingroup Containers; 14This class registers for all classes their name, id and dictionary; 15function in a hash table. Classes are automatically added by the; 16ctor of a special init class when a global of this init class is; 17initialized when the program starts (see the ClassImp macro).; 18 ; 19All functions in TClassTable are thread-safe.; 20*/; 21 ; 22#include ""TClassTable.h""; 23 ; 24#include ""TClass.h""; 25#include ""TClassEdit.h""; 26#include ""TProtoClass.h""; 27#include ""TList.h""; 28#include ""TROOT.h""; 29#include ""TString.h""; 30#include ""TError.h""; 31#include ""TRegexp.h""; 32 ; 33#include ""TObjString.h""; 34#include ""TMap.h""; 35 ; 36#include ""TInterpreter.h""; 37 ; 38#include <map>; 39#include <memory>; 40#include <typeinfo>; 41#include <cstdlib>; 42#include <string>; 43#include <mutex>; 44 ; 45using namespace ROOT;; 46 ; 47TClassTable *gClassTable;; 48 ; 49TClassAlt **TClassTable::fgAlternate;; 50TClassRec **TClassTable::fgTable;; 51TClassRec **TClassTable::fgSortedTable;; 52UInt_t TClassTable::fgSize;; 53std::atomic<UInt_t> TClassTable::fgTally;; 54Bool_t TClassTable::fgSorted;; 55UInt_t TClassTable::fgCursor;; 56TClassTable::IdMap_t *TClassTable::fgIdMap;; 57 ; 58ClassImp(TClassTable);; 59 ; 60static std::mutex &GetClassTableMutex(); 61{; 62 static std::mutex sMutex;; 63 return sMutex;; 64}; 65 ; 66// RAII to first nor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClassTable_8cxx_source.html:996,safe,safe,996,doc/v632/TClassTable_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClassTable_8cxx_source.html,1,['safe'],['safe']
Safety,". ROOT: geom/geom/src/TGeoManager.cxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TGeoManager.cxx. Go to the documentation of this file. 1// @(#)root/geom:$Id$; 2// Author: Andrei Gheata 25/10/01; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12/** \class TGeoManager; 13\ingroup Geometry_classes; 14 ; 15The manager class for any TGeo geometry. Provides user; 16interface for geometry creation, navigation, state querying,; 17visualization, IO, geometry checking and other utilities.; 18 ; 19## General architecture; 20 ; 21 The ROOT geometry package is a tool designed for building, browsing,; 22tracking and visualizing a detector geometry. The code is independent from; 23other external MC for simulation, therefore it does not contain any; 24constraints related to physics. However, the package defines a number of; 25hooks for tracking, such as media, materials, magnetic field or track state flags,; 26in order to allow interfacing to tracking MC's. The final goal is to be; 27able to use the same geometry for several purposes, such as tracking,; 28reconstruction or visualization, taking advantage of the ROOT features; 29related to bookkeeping, I/O, histogramming, browsing and GUI's.; 30 ; 31 The geometrical modeler is the most important component of the package and; 32it provides answers to the basic questions like ""Where am I ?"" or ""How far; 33from the next boundary ?"", but also to more complex ones like ""How far from; 34the closest surface ?"" or ""Which is the next crossing along a helix ?"".; 35 ; 36 The architecture of the modeler is a combination between a GEANT-like; 37containment scheme and ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoManager_8cxx_source.html:1010,detect,detector,1010,doc/master/TGeoManager_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html,1,['detect'],['detector']
Safety,". ROOT: hist/hist/inc/HFitInterface.h Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. HFitInterface.h. Go to the documentation of this file. 1// @(#)root/hist:$Id$; 2// Author: L. Moneta Thu Aug 31 10:40:20 2006; 3 ; 4/**********************************************************************; 5 * *; 6 * Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; 7 * *; 8 * *; 9 **********************************************************************/; 10 ; 11// Header file for class HFitInterface; 12// set of free functions used to couple the ROOT data object with the fitting classes; 13 ; 14// avoid including this file when running CINT since free functions cannot be re-defined; 15 ; 16#ifndef ROOT_HFitInterface; 17#define ROOT_HFitInterface; 18 ; 19 ; 20class TH1;; 21class THnBase;; 22class TF1;; 23class TF2;; 24class TGraph;; 25class TGraphErrors;; 26class TGraph2D;; 27class TMultiGraph;; 28struct Foption_t;; 29 ; 30#include ""TFitResultPtr.h""; 31 ; 32namespace ROOT {; 33 ; 34 namespace Math {; 35 class MinimizerOptions;; 36 }; 37 ; 38 namespace Fit {; 39 ; 40 //class BinData;; 41 ; 42 class FitResult;; 43 class DataRange;; 44 class BinData;; 45 class UnBinData;; 46 class SparseData;; 47 ; 48 enum class EFitObjectType {; 49 kHistogram,; 50 kGraph; 51 };; 52 ; 53 enum class EChisquareType {; 54 kNeyman = 0,; 55 kPLikeRatio,; 56 kPearson; 57 };; 58 ; 59 ; 60 ; 61 /**; 62 Decode list of options into fitOption; 63 */; 64 void FitOptionsMake(EFitObjectType type, const char *option, Foption_t &fitOption);; 65 ; 66 /**; 67 fitting function for a TH1 (called from TH1::Fit); 68 */; 69 TFitResultPtr FitObject(TH1 * h1, TF1 *f1, Foption_t & option, const ROOT::Math::MinimizerOptions & moption, const char *goption, ROOT::Fit::DataRange & range);; 70 ; 71 /**; 72 fitting function for a TGraph (called from TGraph::Fit); 73 */; 74 TFitResultPtr FitObject(TGraph * gr, TF1 *f1 , Foption_t & option , const ROOT::Math::MinimizerOptions & moption, co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/HFitInterface_8h_source.html:637,avoid,avoid,637,doc/master/HFitInterface_8h_source.html,https://root.cern,https://root.cern/doc/master/HFitInterface_8h_source.html,1,['avoid'],['avoid']
Safety,". ROOT: tmva/pymva/src/PyMethodBase.cxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. PyMethodBase.cxx. Go to the documentation of this file. 1// @(#)root/tmva/pymva $Id$; 2// Authors: Omar Zapata, Lorenzo Moneta, Sergei Gleyzer 2015, Stefan Wunsch 2017; 3 ; 4/**********************************************************************************; 5 * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; 6 * Package: TMVA *; 7 * Class : PyMethodBase *; 8 * *; 9 * Description: *; 10 * Virtual base class for all MVA method based on python *; 11 * *; 12 **********************************************************************************/; 13 ; 14#include <Python.h> // Needs to be included first to avoid redefinition of _POSIX_C_SOURCE; 15#include <TMVA/PyMethodBase.h>; 16 ; 17#include ""TMVA/DataSet.h""; 18#include ""TMVA/DataSetInfo.h""; 19#include ""TMVA/MsgLogger.h""; 20#include ""TMVA/Results.h""; 21#include ""TMVA/Timer.h""; 22#include ""TMVA/Tools.h""; 23 ; 24#include ""TSystem.h""; 25 ; 26#define NPY_NO_DEPRECATED_API NPY_1_7_API_VERSION; 27#include <numpy/arrayobject.h>; 28 ; 29using namespace TMVA;; 30 ; 31namespace TMVA {; 32namespace Internal {; 33class PyGILRAII {; 34 PyGILState_STATE m_GILState;; 35 ; 36public:; 37 PyGILRAII() : m_GILState(PyGILState_Ensure()) {}; 38 ~PyGILRAII() { PyGILState_Release(m_GILState); }; 39};; 40} // namespace Internal; 41 ; 42/// get current Python executable used by ROOT; 43TString Python_Executable() {; 44 TString python_version = gSystem->GetFromPipe(""root-config --python-version"");; 45 if (python_version.IsNull()) {; 46 TMVA::gTools().Log() << kFATAL << ""Can't find a valid Python version used to build ROOT"" << Endl;; 47 return nullptr;; 48 }; 49#ifdef _MSC_VER; 50 // on Windows there is a space before the version and the executable is python.exe; 51 // for both versions of Python; 52 python_version.ReplaceAll("" "", """");; 53 if (python_version[0] == '2' || python_version[0] == ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/PyMethodBase_8cxx_source.html:767,avoid,avoid,767,doc/master/PyMethodBase_8cxx_source.html,https://root.cern,https://root.cern/doc/master/PyMethodBase_8cxx_source.html,1,['avoid'],['avoid']
Safety,". ROOT: tutorials/dataframe/df103_NanoAODHiggsAnalysis.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. df103_NanoAODHiggsAnalysis.C File ReferenceTutorials » Dataframe tutorials. Detailed Description; An example of complex analysis with RDataFrame: reconstructing the Higgs boson. ; This tutorial is a simplified but yet complex example of an analysis reconstructing the Higgs boson decaying to two Z bosons from events with four leptons. The data and simulated events are taken from CERN OpenData representing a subset of the data recorded in 2012 with the CMS detector at the LHC. The tutorials follows the Higgs to four leptons analysis published on CERN Open Data portal (10.7483/OPENDATA.CMS.JKB8.RR42). The resulting plots show the invariant mass of the selected four lepton systems in different decay modes (four muons, four electrons and two of each kind) and in a combined plot indicating the decay of the Higgs boson with a mass of about 125 GeV.; The following steps are performed for each sample with data and simulated events in order to reconstruct the Higgs boson from the selected muons and electrons:; Select interesting events with multiple cuts on event properties, e.g., number of leptons, kinematics of the leptons and quality of the tracks.; Reconstruct two Z bosons of which only one on the mass shell from the selected events and apply additional cuts on the reconstructed objects.; Reconstruct the Higgs boson from the remaining Z boson candidates and calculate its invariant mass. The tutorial has the fast mode enabled by default, which reads the data from already skimmed datasets with a total size of only 51MB. If the fast mode is disabled, the tutorial runs over the full dataset with a size of 12GB. ; #include ""ROOT/RDataFrame.hxx""; #include ""ROOT/RDFHelpers.hxx""; #include ""ROOT/RVec.hxx""; #include ""ROOT/RDF/RInterface.hxx""; #include ""TCanvas.h""; #include ""TH1D.h""; #include ""TLatex.h""; #include ""TLegend.h""; #inclu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/df103__NanoAODHiggsAnalysis_8C.html:613,detect,detector,613,doc/master/df103__NanoAODHiggsAnalysis_8C.html,https://root.cern,https://root.cern/doc/master/df103__NanoAODHiggsAnalysis_8C.html,1,['detect'],['detector']
Safety,". ROOT: tutorials/dataframe/df103_NanoAODHiggsAnalysis.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; df103_NanoAODHiggsAnalysis.py File ReferenceTutorials » Dataframe tutorials. Detailed Description; An example of complex analysis with RDataFrame: reconstructing the Higgs boson. ; This tutorial is a simplified but yet complex example of an analysis reconstructing the Higgs boson decaying to two Z bosons from events with four leptons. The data and simulated events are taken from CERN OpenData representing a subset of the data recorded in 2012 with the CMS detector at the LHC. The tutorials follows the Higgs to four leptons analysis published on CERN Open Data portal (10.7483/OPENDATA.CMS.JKB8.RR42). The resulting plots show the invariant mass of the selected four lepton systems in different decay modes (four muons, four electrons and two of each kind) and in a combined plot indicating the decay of the Higgs boson with a mass of about 125 GeV.; The following steps are performed for each sample with data and simulated events in order to reconstruct the Higgs boson from the selected muons and electrons:; Select interesting events with multiple cuts on event properties, e.g., number of leptons, kinematics of the leptons and quality of the tracks.; Reconstruct two Z bosons of which only one on the mass shell from the selected events and apply additional cuts on the reconstructed objects.; Reconstruct the Higgs boson from the remaining Z boson candidates and calculate its invariant mass. Another aim of this version of the tutorial is to show a way to blend C++ and Python code. All the functions that make computations on data to define new columns or filter existing ones in a precise way, better suited to be written in C++, have been moved to a header that is then declared to the ROOT C++ interpreter. The functions that instead create nodes of the computational graph (e.g. Filter, Define) remain inside the ma",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/df103__NanoAODHiggsAnalysis_8py.html:628,detect,detector,628,doc/master/df103__NanoAODHiggsAnalysis_8py.html,https://root.cern,https://root.cern/doc/master/df103__NanoAODHiggsAnalysis_8py.html,1,['detect'],['detector']
Safety,". ROOT: tutorials/dataframe/df104_HiggsToTwoPhotons.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; df104_HiggsToTwoPhotons.py File ReferenceTutorials » Dataframe tutorials. Detailed Description; The Higgs to two photons analysis from the ATLAS Open Data 2020 release, with RDataFrame. ; This tutorial is the Higgs to two photons analysis from the ATLAS Open Data release in 2020 (http://opendata.atlas.cern/release/2020/documentation/). The data was taken with the ATLAS detector during 2016 at a center-of-mass energy of 13 TeV. Although the Higgs to two photons decay is very rare, the contribution of the Higgs can be seen as a narrow peak around 125 GeV because of the excellent reconstruction and identification efficiency of photons at the ATLAS experiment.; The analysis is translated to a RDataFrame workflow processing 1.7 GB of simulated events and data. ; import ROOT; import os; ; # Enable multi-threading; ROOT.ROOT.EnableImplicitMT(); ; # Create a ROOT dataframe for each dataset; path = ""root://eospublic.cern.ch//eos/opendata/atlas/OutreachDatasets/2020-01-22""; df = {}; df[""data""] = ROOT.RDataFrame(""mini"", (os.path.join(path, ""GamGam/Data/data_{}.GamGam.root"".format(x)) for x in (""A"", ""B"", ""C"", ""D""))); df[""ggH""] = ROOT.RDataFrame(""mini"", os.path.join(path, ""GamGam/MC/mc_343981.ggH125_gamgam.GamGam.root"")); df[""VBF""] = ROOT.RDataFrame(""mini"", os.path.join(path, ""GamGam/MC/mc_345041.VBFH125_gamgam.GamGam.root"")); processes = list(df.keys()); ; # Apply scale factors and MC weight for simulated events and a weight of 1 for the data; for p in [""ggH"", ""VBF""]:; df[p] = df[p].Define(""weight"",; ""scaleFactor_PHOTON * scaleFactor_PhotonTRIGGER * scaleFactor_PILEUP * mcWeight"");; df[""data""] = df[""data""].Define(""weight"", ""1.0""); ; # Select the events for the analysis; for p in processes:; # Apply preselection cut on photon trigger; df[p] = df[p].Filter(""trigP""); ; # Find two good muons with tight ID, pt > 25 GeV an",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/df104__HiggsToTwoPhotons_8py.html:537,detect,detector,537,doc/master/df104__HiggsToTwoPhotons_8py.html,https://root.cern,https://root.cern/doc/master/df104__HiggsToTwoPhotons_8py.html,1,['detect'],['detector']
Safety,". ROOT: tutorials/dataframe/df105_WBosonAnalysis.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; df105_WBosonAnalysis.py File ReferenceTutorials » Dataframe tutorials. Detailed Description; The W boson mass analysis from the ATLAS Open Data release of 2020, with RDataFrame. ; This tutorial is the analysis of the W boson mass taken from the ATLAS Open Data release in 2020 (http://opendata.atlas.cern/release/2020/documentation/). The data was recorded with the ATLAS detector during 2016 at a center-of-mass energy of 13 TeV. W bosons are produced frequently at the LHC and are an important background to studies of Standard Model processes, for example the Higgs boson analyses.; The analysis is translated to a RDataFrame workflow processing up to 60 GB of simulated events and data. By default the analysis runs on a preskimmed dataset to reduce the runtime. The full dataset can be used with the –full-dataset argument and you can also run only on a fraction of the original dataset using the argument –lumi-scale.; See the corresponding spec json file. ; import ROOT; import sys; import json; import argparse; import os; ; # Argument parsing; parser = argparse.ArgumentParser(); parser.add_argument(""--lumi-scale"", type=float, default=0.001,; help=""Run only on a fraction of the total available 10 fb^-1 (only usable together with --full-dataset)""); parser.add_argument(""--full-dataset"", action=""store_true"", default=False,; help=""Use the full dataset (use --lumi-scale to run only on a fraction of it)""); parser.add_argument(""-b"", action=""store_true"", default=False, help=""Use ROOT batch mode""); parser.add_argument(""-t"", action=""store_true"", default=False, help=""Use implicit multi threading (for the full dataset only possible with --lumi-scale 1.0)""); if 'df105_WBosonAnalysis.py' in sys.argv[0]:; # Script; args = parser.parse_args(); else:; # Notebook; args = parser.parse_args(args=[]); ; if args.b: ROOT.gROOT.SetBatch(Tr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/df105__WBosonAnalysis_8py.html:534,detect,detector,534,doc/master/df105__WBosonAnalysis_8py.html,https://root.cern,https://root.cern/doc/master/df105__WBosonAnalysis_8py.html,1,['detect'],['detector']
Safety,". ROOT: tutorials/dataframe/df106_HiggsToFourLeptons.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. df106_HiggsToFourLeptons.C File ReferenceTutorials » Dataframe tutorials. Detailed Description; The Higgs to four lepton analysis from the ATLAS Open Data release of 2020, with RDataFrame. ; This tutorial is the Higgs to four lepton analysis from the ATLAS Open Data release in 2020 (http://opendata.atlas.cern/release/2020/documentation/). The data was taken with the ATLAS detector during 2016 at a center-of-mass energy of 13 TeV. The decay of the Standard Model Higgs boson to two Z bosons and subsequently to four leptons is called the ""golden channel"". The selection leads to a narrow invariant mass peak on top a relatively smooth and small background, revealing the Higgs at 125 GeV. The analysis is translated to an RDataFrame workflow processing about 300 MB of simulated events and data.; Lepton selection efficiency corrections (""scale factors"") are applied to simulated samples to correct for the differences in the trigger, reconstruction, and identification efficiencies in simulation compared to real data. Systematic uncertainties for those scale factors are evaluated and the Vary function of RDataFrame is used to propagate the variations to the final four leptons mass distribution.; See the corresponding spec json file.; ; #include ""TInterpreter.h""; #include <Math/Vector4D.h>; #include <ROOT/RDFHelpers.hxx>; #include <ROOT/RDataFrame.hxx>; #include <ROOT/RVec.hxx>; #include <TCanvas.h>; #include <TGraph.h>; #include <TH1D.h>; #include <THStack.h>; #include <TLatex.h>; #include <TLegend.h>; #include <TProfile.h>; #include <TStyle.h>; ; using namespace ROOT::VecOps;; using PtEtaPhiEVectorF = ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<float>>;; using ROOT::RVecF;; using ROOT::RDF::RSampleInfo;; using namespace ROOT::RDF::Experimental;; ; // Define functions needed in the analysis; // Select events for the analys",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/df106__HiggsToFourLeptons_8C.html:527,detect,detector,527,doc/master/df106__HiggsToFourLeptons_8C.html,https://root.cern,https://root.cern/doc/master/df106__HiggsToFourLeptons_8C.html,1,['detect'],['detector']
Safety,". ROOT: tutorials/dataframe/df106_HiggsToFourLeptons.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; df106_HiggsToFourLeptons.py File ReferenceTutorials » Dataframe tutorials. Detailed Description; The Higgs to four lepton analysis from the ATLAS Open Data release of 2020, with RDataFrame. ; This tutorial is the Higgs to four lepton analysis from the ATLAS Open Data release in 2020 (http://opendata.atlas.cern/release/2020/documentation/). The data was taken with the ATLAS detector during 2016 at a center-of-mass energy of 13 TeV. The decay of the Standard Model Higgs boson to two Z bosons and subsequently to four leptons is called the ""golden channel"". The selection leads to a narrow invariant mass peak on top a relatively smooth and small background, revealing the Higgs at 125 GeV. Systematic errors for the MC scale factors are computed and the Vary function of RDataFrame is used for plotting. The analysis is translated to an RDataFrame workflow processing about 300 MB of simulated events and data.; See the corresponding spec json file. ; import ROOT; import os; ; # Enable Multi-threaded mode; ROOT.EnableImplicitMT(); ; # Create the RDataFrame from the spec json file. The df106_HiggsToFourLeptons_spec.json is provided in the same folder as this tutorial; dataset_spec = os.path.join(ROOT.gROOT.GetTutorialsDir(), ""dataframe"", ""df106_HiggsToFourLeptons_spec.json""); df = ROOT.RDF.Experimental.FromSpec(dataset_spec) # Creates a single dataframe for all the samples; ; # Add the ProgressBar feature; ROOT.RDF.Experimental.AddProgressBar(df); ; # Access metadata information that is stored in the JSON config file of the RDataFrame.; # The metadata contained in the JSON file is accessible within a `DefinePerSample` call, through the `RSampleInfo` class.; df = df.DefinePerSample(""xsecs"", 'rdfsampleinfo_.GetD(""xsecs"")'); df = df.DefinePerSample(""lumi"", 'rdfsampleinfo_.GetD(""lumi"")'); df = df.DefinePerSample(""sumws""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/df106__HiggsToFourLeptons_8py.html:542,detect,detector,542,doc/master/df106__HiggsToFourLeptons_8py.html,https://root.cern,https://root.cern/doc/master/df106__HiggsToFourLeptons_8py.html,1,['detect'],['detector']
Safety,". ROOT: tutorials/dataframe/df106_HiggsToFourLeptons.py Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. df106_HiggsToFourLeptons.py. Go to the documentation of this file. 1## \file; 2## \ingroup tutorial_dataframe; 3## \notebook -draw; 4## The Higgs to four lepton analysis from the ATLAS Open Data release of 2020, with RDataFrame.; 5##; 6## This tutorial is the Higgs to four lepton analysis from the ATLAS Open Data release in 2020; 7## (http://opendata.atlas.cern/release/2020/documentation/). The data was taken with the ATLAS detector; 8## during 2016 at a center-of-mass energy of 13 TeV. The decay of the Standard Model Higgs boson; 9## to two Z bosons and subsequently to four leptons is called the ""golden channel"". The selection leads; 10## to a narrow invariant mass peak on top a relatively smooth and small background, revealing; 11## the Higgs at 125 GeV.; 12## Systematic errors for the MC scale factors are computed and the Vary function of RDataFrame is used for plotting.; 13## The analysis is translated to an RDataFrame workflow processing about 300 MB of simulated events and data.; 14##; 15## See the [corresponding spec json file](https://github.com/root-project/root/blob/master/tutorials/dataframe/df106_HiggsToFourLeptons_spec.json).; 16##; 17## \macro_image; 18## \macro_code; 19## \macro_output; 20##; 21## \date March 2020, August 2022, August 2023; 22## \authors Stefan Wunsch (KIT, CERN), Julia Mathe (CERN), Marta Czurylo (CERN); 23 ; 24import ROOT; 25import os; 26 ; 27# Enable Multi-threaded mode; 28ROOT.EnableImplicitMT(); 29 ; 30# Create the RDataFrame from the spec json file. The df106_HiggsToFourLeptons_spec.json is provided in the same folder as this tutorial; 31dataset_spec = os.path.join(ROOT.gROOT.GetTutorialsDir(), ""dataframe"", ""df106_HiggsToFourLeptons_spec.json""); 32df = ROOT.RDF.Experimental.FromSpec(dataset_spec) # Creates a single dataframe for all the samples; 33 ; 34# Add the ProgressBar feature;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/df106__HiggsToFourLeptons_8py_source.html:578,detect,detector,578,doc/master/df106__HiggsToFourLeptons_8py_source.html,https://root.cern,https://root.cern/doc/master/df106__HiggsToFourLeptons_8py_source.html,1,['detect'],['detector']
Safety,". ROOT: tutorials/dataframe/df107_SingleTopAnalysis.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; df107_SingleTopAnalysis.py File ReferenceTutorials » Dataframe tutorials. Detailed Description; A single top analysis using the ATLAS Open Data release of 2020, with RDataFrame. ; This tutorial is the analysis of single top production adapted from the ATLAS Open Data release in 2020 (http://opendata.atlas.cern/release/2020/documentation/). The data was recorded with the ATLAS detector during 2016 at a center-of-mass energy of 13 TeV. Top quarks with a mass of about 172 GeV are mostly produced in pairs but also appear alone, dominantly from the decays of a W boson in association with a light jet.; The analysis is translated to a RDataFrame workflow processing up to 60 GB of simulated events and data. By default the analysis runs on a preskimmed dataset to reduce the runtime. The full dataset can be used with the –full-dataset argument and you can also run only on a fraction of the original dataset using the argument –lumi-scale.; See the corresponding spec json file. ; import ROOT; import sys; import json; import argparse; import os; ; # Argument parsing; parser = argparse.ArgumentParser(); parser.add_argument(""--lumi-scale"", type=float, default=0.05,; help=""Run only on a fraction of the total available 10 fb^-1 (only usable together with --full-dataset)""); parser.add_argument(""--full-dataset"", action=""store_true"", default=False,; help=""Use the full dataset (use --lumi-scale to run only on a fraction of it)""); parser.add_argument(""-b"", action=""store_true"", default=False, help=""Use ROOT batch mode""); parser.add_argument(""-t"", action=""store_true"", default=False, help=""Use implicit multi threading (for the full dataset only possible with --lumi-scale 1.0)""); if 'df107_SingleTopAnalysis.py' in sys.argv[0]:; # Script; args = parser.parse_args(); else:; # Notebook; args = parser.parse_args(args=[]); ; if args.b:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/df107__SingleTopAnalysis_8py.html:544,detect,detector,544,doc/master/df107__SingleTopAnalysis_8py.html,https://root.cern,https://root.cern/doc/master/df107__SingleTopAnalysis_8py.html,1,['detect'],['detector']
Safety,". ROOT: tutorials/fit Directory Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. fit Directory Reference. Directory dependency graph for fit:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Files;  combinedFit.C;   Combined (simultaneous) fit of two histogram with separate functions and some common parameters ;  ;  combinedFit.py;   Combined (simultaneous) fit of two histogram with separate functions and some common parameters ;  ;  ConfidenceIntervals.C;   Illustrates TVirtualFitter::GetConfidenceIntervals This method computes confidence intervals for the fitted function ;  ;  ErrorIntegral.C;   Estimate the error in the integral of a fitted function taking into account the errors in the parameters resulting from the fit. ;  ;  exampleFit3D.C;   example of fitting a 3D function Typical multidimensional parametric regression where the predictor depends on 3 variables ;  ;  fit1.C;   Simple fitting example (1-d histogram with an interpreted function) ;  ;  fit2.C;   Fitting a 2-D histogram This tutorial illustrates : ;  ;  fit2a.C;   Fitting a 2-D histogram (a variant) This tutorial illustrates : ;  ;  fit2d.C;   Example illustrating how to fit a 2-d histogram of type y=f(x) ;  ;  fit2dHist.C;   Example to fit two histograms at the same time via the Fitter class. ;  ;  fitCircle.C;   Generate points distributed with some errors around a circle Fit a circle through the points and draw To run the script, do, eg ;  ;  fitcont.C;   Example illustrating how to draw the n-sigma contour of a Minuit fit. ;  ;  fitConvolution.C;   Tutorial for convolution of two functions ;  ;  fitConvolution.py;   Tutorial for convolution of two functions ;  ;  fitEllipseTGraphDLSF.cxx;  ;  fitEllipseTGraphRMM.cxx;  ;  fitExclude.C;   Illustrates how to fit excluding points in a given range. ;  ;  fithist.C;   Example of fit where the model is histogram + function ;  ;  FitHistoInFile.C;   ;  ;  fitLinear.C;   Ex",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/dir_a29432302a7afdbe7cd0744ed0070754.html:928,predict,predictor,928,doc/master/dir_a29432302a7afdbe7cd0744ed0070754.html,https://root.cern,https://root.cern/doc/master/dir_a29432302a7afdbe7cd0744ed0070754.html,1,['predict'],['predictor']
Safety,". ROOT: tutorials/fit/exampleFit3D.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. exampleFit3D.C File ReferenceTutorials » Fit Tutorials. Detailed Description; example of fitting a 3D function Typical multidimensional parametric regression where the predictor depends on 3 variables ; In the case of 1 or 2D one can use the TGraph classes but since no TGraph3D class exists this tutorial provide an example of fitting 3D points; ; ****************************************; Minimizer is Minuit2 / Migrad; Chi2 = 993.065; NDf = 997; Edm = 2.2677e-24; NCalls = 7; p0 = 0.993546 +/- 0.00475134 ; p1 = 0.99397 +/- 0.00434249 ; p2 = 0.997895 +/- 0.000545663 ; Good fit : p-value = 0.529221; ; ; #include ""TRandom2.h""; #include ""TF3.h""; #include ""TError.h""; #include ""Fit/BinData.h""; #include ""Fit/Fitter.h""; #include ""Math/WrappedMultiTF1.h""; ; void exampleFit3D() {; ; const int n = 1000;; double x[n], y[n], z[n], v[n];; double ev = 0.1;; ; // generate the data; TRandom2 r;; for (int i = 0; i < n; ++i) {; x[i] = r.Uniform(0,10);; y[i] = r.Uniform(0,10);; z[i] = r.Uniform(0,10);; v[i] = sin(x[i] ) + cos(y[i]) + z[i] + r.Gaus(0,ev);; }; ; // create a 3d binned data structure; ROOT::Fit::BinData data(n,3);; double xx[3];; for(int i = 0; i < n; ++i) {; xx[0] = x[i];; xx[1] = y[i];; xx[2] = z[i];; // add the 3d-data coordinate, the predictor value (v[i]) and its errors; data.Add(xx, v[i], ev);; }; ; TF3 * f3 = new TF3(""f3"",""[0] * sin(x) + [1] * cos(y) + [2] * z"",0,10,0,10,0,10);; f3->SetParameters(2,2,2);; ROOT::Fit::Fitter fitter;; // wrapped the TF1 in a IParamMultiFunction interface for the Fitter class; ROOT::Math::WrappedMultiTF1 wf(*f3,3);; fitter.SetFunction(wf);; //; bool ret = fitter.Fit(data);; if (ret) {; const ROOT::Fit::FitResult & res = fitter.Result();; // print result (should be around 1); res.Print(std::cout);; // copy all fit result info (values, chi2, etc..) in TF3; f3->SetFitResult(res);; // test fit p-value (chi2 prob",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/exampleFit3D_8C.html:302,predict,predictor,302,doc/master/exampleFit3D_8C.html,https://root.cern,https://root.cern/doc/master/exampleFit3D_8C.html,1,['predict'],['predictor']
Safety,". ROOT: tutorials/geom/assembly.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. assembly.C File ReferenceTutorials » Geometry tutorials. Detailed Description; Geometry detector assembly example. ; ��A2␏V ; void assembly(); {; //--- Definition of a simple geometry; TGeoManager *geom = new TGeoManager(""Assemblies"",; ""Geometry using assemblies"");; Int_t i;; //--- define some materials; TGeoMaterial *matVacuum = new TGeoMaterial(""Vacuum"", 0,0,0);; TGeoMaterial *matAl = new TGeoMaterial(""Al"", 26.98,13,2.7);; // //--- define some media; TGeoMedium *Vacuum = new TGeoMedium(""Vacuum"",1, matVacuum);; TGeoMedium *Al = new TGeoMedium(""Aluminium"",2, matAl);; ; //--- make the top container volume; TGeoVolume *top = geom->MakeBox(""TOP"", Vacuum, 1000., 1000., 100.);; geom->SetTopVolume(top);; ; // Make the elementary assembly of the whole structure; TGeoVolume *tplate = new TGeoVolumeAssembly(""TOOTHPLATE"");; ; Int_t ntooth = 5;; Double_t xplate = 25;; Double_t yplate = 50;; Double_t xtooth = 10;; Double_t ytooth = 0.5*yplate/ntooth;; Double_t dshift = 2.*xplate + xtooth;; Double_t xt,yt;; ; TGeoVolume *plate = geom->MakeBox(""PLATE"", Al, xplate,yplate,1);; plate->SetLineColor(kBlue);; TGeoVolume *tooth = geom->MakeBox(""TOOTH"", Al, xtooth,ytooth,1);; tooth->SetLineColor(kBlue);; tplate->AddNode(plate,1);; for (i=0; i<ntooth; i++) {; xt = xplate+xtooth;; yt = -yplate + (4*i+1)*ytooth;; tplate->AddNode(tooth, i+1, new TGeoTranslation(xt,yt,0));; xt = -xplate-xtooth;; yt = -yplate + (4*i+3)*ytooth;; tplate->AddNode(tooth, ntooth+i+1, new TGeoTranslation(xt,yt,0));; }; ; TGeoRotation *rot1 = new TGeoRotation();; rot1->RotateX(90);; TGeoRotation *rot;; // Make a hexagone cell out of 6 tooth plates. These can zip together; // without generating overlaps (they are self-contained); TGeoVolume *cell = new TGeoVolumeAssembly(""CELL"");; for (i=0; i<6; i++) {; Double_t phi = 60.*i;; Double_t phirad = phi*TMath::DegToRad();; Double_t xp = dshift*TM",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/geom_2assembly_8C.html:219,detect,detector,219,doc/master/geom_2assembly_8C.html,https://root.cern,https://root.cern/doc/master/geom_2assembly_8C.html,1,['detect'],['detector']
Safety,". ROOT: tutorials/geom/geomAlice.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. geomAlice.C File ReferenceTutorials » Geometry tutorials. Detailed Description; Script drawing a detector geometry (here ALICE). ; by default the geometry is drawn using the GL viewer Using the TBrowser, you can select other components if the file containing the geometry is not found in the local directory, it is automatically read from the ROOT web site. ; void geomAlice(); {; TGeoManager::Import(""http://root.cern/files/alice2.root"");; gGeoManager->DefaultColors();; // gGeoManager->SetVisLevel(4);; gGeoManager->GetVolume(""HALL"")->InvisibleAll();; gGeoManager->GetVolume(""ZDCC"")->InvisibleAll();; gGeoManager->GetVolume(""ZDCA"")->InvisibleAll();; gGeoManager->GetVolume(""L3MO"")->InvisibleAll();; gGeoManager->GetVolume(""YOUT1"")->InvisibleAll();; gGeoManager->GetVolume(""YOUT2"")->InvisibleAll();; gGeoManager->GetVolume(""YSAA"")->InvisibleAll();; gGeoManager->GetVolume(""RB24"")->InvisibleAll();; gGeoManager->GetVolume(""RB26Pipe"")->InvisibleAll();; gGeoManager->GetVolume(""DDIP"")->InvisibleAll();; gGeoManager->GetVolume(""DCM0"")->InvisibleAll();; // gGeoManager->GetVolume(""PPRD"")->InvisibleAll();; gGeoManager->GetVolume(""BRS1"")->InvisibleAll();; gGeoManager->GetVolume(""BRS4"")->InvisibleAll();; // gGeoManager->GetVolume(""Dipole"")->InvisibleAll();; gGeoManager->GetVolume(""ZN1"")->InvisibleAll();; gGeoManager->GetVolume(""Q13T"")->InvisibleAll();; gGeoManager->GetVolume(""ZP1"")->InvisibleAll();; gGeoManager->GetVolume(""QTD1"")->InvisibleAll();; gGeoManager->GetVolume(""QTD2"")->InvisibleAll();; gGeoManager->GetVolume(""QBS7"")->InvisibleAll();; gGeoManager->GetVolume(""QA07"")->InvisibleAll();; gGeoManager->GetVolume(""MD1V"")->InvisibleAll();; gGeoManager->GetVolume(""QTD3"")->InvisibleAll();; gGeoManager->GetVolume(""QTD4"")->InvisibleAll();; gGeoManager->GetVolume(""QTD5"")->InvisibleAll();; gGeoManager->GetVolume(""QBS3"")->InvisibleAll();; gGeoManager->GetVolume(""QBS4""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/geomAlice_8C.html:229,detect,detector,229,doc/master/geomAlice_8C.html,https://root.cern,https://root.cern/doc/master/geomAlice_8C.html,1,['detect'],['detector']
Safety,". ROOT: tutorials/geom/geomAlice_itsv.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. geomAlice_itsv.C File ReferenceTutorials » Geometry tutorials. Detailed Description; Script drawing a detector geometry (here ITSV from Alice). ; By default the geometry is drawn using the GL viewer Using the TBrowser, you can select other components if the file containing the geometry is not found in the local directory, it is automatically read from the ROOT web site. ; void geomAlice_itsv() {; TGeoManager::Import(""http://root.cern/files/alice2.root"");; gGeoManager->DefaultColors();; gGeoManager->GetVolume(""ITSV"")->Draw(""ogl"");; new TBrowser;; }; gGeoManagerR__EXTERN TGeoManager * gGeoManagerDefinition TGeoManager.h:608; TBrowserUsing a TBrowser one can browse all ROOT objects.Definition TBrowser.h:37; TGeoManager::Importstatic TGeoManager * Import(const char *filename, const char *name="""", Option_t *option="""")static function Import a geometry from a gdml or ROOT fileDefinition TGeoManager.cxx:4096; TGeoManager::GetVolumeTGeoVolume * GetVolume(const char *name) constSearch for a named volume. All trailing blanks stripped.Definition TGeoManager.cxx:2942; TGeoManager::DefaultColorsvoid DefaultColors()Set default volume colors according to A of material.Definition TGeoManager.cxx:2259; TGeoVolume::Drawvoid Draw(Option_t *option="""") overridedraw top volume according to optionDefinition TGeoVolume.cxx:1206; AuthorRene Brun ; Definition in file geomAlice_itsv.C. tutorialsgeomgeomAlice_itsv.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/geomAlice__itsv_8C.html:239,detect,detector,239,doc/master/geomAlice__itsv_8C.html,https://root.cern,https://root.cern/doc/master/geomAlice__itsv_8C.html,1,['detect'],['detector']
Safety,". ROOT: tutorials/geom/geomAtlas.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. geomAtlas.C File ReferenceTutorials » Geometry tutorials. Detailed Description; Script drawing a detector geometry (here ATLAS). ; by default the geometry is drawn using the GL viewer Using the TBrowser, you can select other components if the file containing the geometry is not found in the local directory, it is automatically read from the ROOT web site. ; void geomAtlas() {; TGeoManager::Import(""http://root.cern/files/atlas.root"");; //gGeoManager->DefaultColors();; gGeoManager->SetMaxVisNodes(5000);; //gGeoManager->SetVisLevel(4);; gGeoManager->GetVolume(""ATLS"")->Draw(""ogl"");; new TBrowser;; }; gGeoManagerR__EXTERN TGeoManager * gGeoManagerDefinition TGeoManager.h:608; TBrowserUsing a TBrowser one can browse all ROOT objects.Definition TBrowser.h:37; TGeoManager::Importstatic TGeoManager * Import(const char *filename, const char *name="""", Option_t *option="""")static function Import a geometry from a gdml or ROOT fileDefinition TGeoManager.cxx:4096; TGeoManager::GetVolumeTGeoVolume * GetVolume(const char *name) constSearch for a named volume. All trailing blanks stripped.Definition TGeoManager.cxx:2942; TGeoManager::SetMaxVisNodesvoid SetMaxVisNodes(Int_t maxnodes=10000)set the maximum number of visible nodes.Definition TGeoManager.cxx:2380; TGeoVolume::Drawvoid Draw(Option_t *option="""") overridedraw top volume according to optionDefinition TGeoVolume.cxx:1206; AuthorRene Brun ; Definition in file geomAtlas.C. tutorialsgeomgeomAtlas.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/geomAtlas_8C.html:229,detect,detector,229,doc/master/geomAtlas_8C.html,https://root.cern,https://root.cern/doc/master/geomAtlas_8C.html,1,['detect'],['detector']
Safety,". ROOT: tutorials/geom/geomBrahms.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. geomBrahms.C File ReferenceTutorials » Geometry tutorials. Detailed Description; Script drawing a detector geometry (here BRAHMS). ; by default the geometry is drawn using the GL viewer Using the TBrowser, you can select other components if the file containing the geometry is not found in the local directory, it is automatically read from the ROOT web site. ; void geomBrahms() {; TGeoManager::Import(""http://root.cern/files/brahms.root"");; gGeoManager->GetVolume(""CAVE"")->Draw(""ogl"");; new TBrowser;; }; gGeoManagerR__EXTERN TGeoManager * gGeoManagerDefinition TGeoManager.h:608; TBrowserUsing a TBrowser one can browse all ROOT objects.Definition TBrowser.h:37; TGeoManager::Importstatic TGeoManager * Import(const char *filename, const char *name="""", Option_t *option="""")static function Import a geometry from a gdml or ROOT fileDefinition TGeoManager.cxx:4096; TGeoManager::GetVolumeTGeoVolume * GetVolume(const char *name) constSearch for a named volume. All trailing blanks stripped.Definition TGeoManager.cxx:2942; TGeoVolume::Drawvoid Draw(Option_t *option="""") overridedraw top volume according to optionDefinition TGeoVolume.cxx:1206; AuthorRene Brun ; Definition in file geomBrahms.C. tutorialsgeomgeomBrahms.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/geomBrahms_8C.html:231,detect,detector,231,doc/master/geomBrahms_8C.html,https://root.cern,https://root.cern/doc/master/geomBrahms_8C.html,1,['detect'],['detector']
Safety,". ROOT: tutorials/geom/geomD0.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. geomD0.C File ReferenceTutorials » Geometry tutorials. Detailed Description; Script drawing a detector geometry (here D0). ; by default the geometry is drawn using the GL viewer Using the TBrowser, you can select other components if the file containing the geometry is not found in the local directory, it is automatically read from the ROOT web site.; run with .x geomD0.C top level detectors are transparent; or .x geomD0.C(1) top level detectors are visible. ; void RecursiveInvisible(TGeoVolume *vol);; void RecursiveTransparency(TGeoVolume *vol, Int_t transp);; ; void geomD0(Int_t allVisible=0) {; TGeoManager::Import(""http://root.cern/files/d0.root"");; gGeoManager->DefaultColors();; gGeoManager->SetMaxVisNodes(40000);; //gGeoManager->SetVisLevel(4);; if (!allVisible) {; RecursiveInvisible(gGeoManager->GetVolume(""D0-""));; RecursiveInvisible(gGeoManager->GetVolume(""D0+""));; RecursiveInvisible(gGeoManager->GetVolume(""D0WZ""));; RecursiveInvisible(gGeoManager->GetVolume(""D0WL""));; RecursiveTransparency(gGeoManager->GetVolume(""MUON""), 90);; }; ; gGeoManager->GetVolume(""D0"")->Draw(""ogl"");; }; ; void RecursiveInvisible(TGeoVolume *vol); {; vol->InvisibleAll();; Int_t nd = vol->GetNdaughters();; for (Int_t i=0; i<nd; i++) {; RecursiveInvisible(vol->GetNode(i)->GetVolume());; }; }; ; void RecursiveTransparency(TGeoVolume *vol, Int_t transp); {; vol->SetTransparency(transp);; Int_t nd = vol->GetNdaughters();; for (Int_t i=0; i<nd; i++) {; RecursiveTransparency(vol->GetNode(i)->GetVolume(), transp);; }; }; Int_tint Int_tDefinition RtypesCore.h:45; gGeoManagerR__EXTERN TGeoManager * gGeoManagerDefinition TGeoManager.h:608; TGeoManager::Importstatic TGeoManager * Import(const char *filename, const char *name="""", Option_t *option="""")static function Import a geometry from a gdml or ROOT fileDefinition TGeoManager.cxx:4096; TGeoManager::GetVolumeTGeoVolume *",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/geomD0_8C.html:223,detect,detector,223,doc/master/geomD0_8C.html,https://root.cern,https://root.cern/doc/master/geomD0_8C.html,3,['detect'],"['detector', 'detectors']"
Safety,". ROOT: tutorials/geom/na49view.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. na49view.C File ReferenceTutorials » Geometry tutorials. Detailed Description; This macro generates with 2 views of the NA49 detector using the old obsolete geometry package. . ; void na49view() {; TCanvas *c1 = new TCanvas(""c1"",""The NA49 canvas"",200,10,700,780);; ; gBenchmark->Start(""na49view"");; ; TPad *all = new TPad(""all"",""A Global view of NA49"",0.02,0.02,0.48,0.82,28);; TPad *tof = new TPad(""tof"",""One Time Of Flight element"",0.52,0.02,0.98,0.82,28);; all->Draw();; tof->Draw();; TPaveLabel *na49title = new TPaveLabel(0.04,0.86,0.96,0.98,""Two views of the NA49 detector"");; na49title->SetFillColor(32);; na49title->Draw();; //; TFile *nageom = new TFile(""na49.root"");; if (!nageom || nageom->IsZombie()) return;; TGeometry *n49 =(TGeometry*)gROOT->FindObject(""na49"");; n49->SetBomb(1.2);; n49->cd(); //Set current geometry; all->cd(); //Set current pad; n49->Draw();; c1->Update();; tof->cd();; TNode *TOFR1 = n49->GetNode(""TOFR1"");; TOFR1->Draw();; c1->Update();; ; gBenchmark->Show(""na49view"");; ; // To have a better and dynamic view of any of these pads,; // you can click with the middle button of your mouse to select it.; // Then select ""View with x3d"" in the VIEW menu of the Canvas.; // Once in x3d, you are in wireframe mode by default.; // You can switch to:; // - Hidden Line mode by typing E; // - Solid mode by typing R; // - Wireframe mode by typing W; // - Stereo mode by clicking S (and you need special glasses); // - To leave x3d type Q; }; gBenchmarkR__EXTERN TBenchmark * gBenchmarkDefinition TBenchmark.h:59; gROOT#define gROOTDefinition TROOT.h:406; TAttFill::SetFillColorvirtual void SetFillColor(Color_t fcolor)Set the fill area color.Definition TAttFill.h:37; TBenchmark::Startvirtual void Start(const char *name)Starts Benchmark with the specified name.Definition TBenchmark.cxx:172; TBenchmark::Showvirtual void Show(const char *name",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/na49view_8C.html:256,detect,detector,256,doc/master/na49view_8C.html,https://root.cern,https://root.cern/doc/master/na49view_8C.html,2,['detect'],['detector']
Safety,". ROOT: tutorials/graphics/framework.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. framework.C File ReferenceTutorials » Graphics tutorials. Detailed Description; An example with basic graphics illustrating the Object Oriented User Interface of ROOT. . ; void framework() {; TCanvas *c1 = new TCanvas(""c1"",""The ROOT Framework"",200,10,700,500);; c1->Range(0,0,19,12);; //; TPavesText *rootf = new TPavesText(0.4,0.6,18,2.3,20,""tr"");; rootf->AddText(""ROOT Framework"");; rootf->SetFillColor(42);; rootf->Draw();; //; TPavesText *eventg = new TPavesText(0.99,2.66,3.29,5.67,4,""tr"");; eventg->SetFillColor(38);; eventg->AddText(""Event"");; eventg->AddText(""Generators"");; eventg->Draw();; //; TPavesText *simul = new TPavesText(3.62,2.71,6.15,7.96,7,""tr"");; simul->SetFillColor(41);; simul->AddText(""Detector"");; simul->AddText(""Simulation"");; simul->Draw();; //; TPavesText *recon = new TPavesText(6.56,2.69,10.07,10.15,11,""tr"");; recon->SetFillColor(48);; recon->AddText(""Event"");; recon->AddText(""Reconstruction"");; recon->Draw();; //; TPavesText *daq = new TPavesText(10.43,2.74,14.0,10.81,11,""tr"");; daq->AddText(""Data"");; daq->AddText(""Acquisition"");; daq->Draw();; //; TPavesText *anal = new TPavesText(14.55,2.72,17.9,10.31,11,""tr"");; anal->SetFillColor(42);; anal->AddText(""Data"");; anal->AddText(""Analysis"");; anal->Draw();; c1->Update();; }; TAttFill::SetFillColorvirtual void SetFillColor(Color_t fcolor)Set the fill area color.Definition TAttFill.h:37; TCanvasThe Canvas class.Definition TCanvas.h:23; TPaveText::AddTextvirtual TText * AddText(Double_t x1, Double_t y1, const char *label)Add a new Text line to this pavetext at given coordinates.Definition TPaveText.cxx:191; TPavesTextA PaveText (see TPaveText) with several stacked paves.Definition TPavesText.h:18; TPavesText::Drawvoid Draw(Option_t *option="""") overrideDraw this pavestext with its current attributes.Definition TPavesText.cxx:80; c1return c1Definition legend1.C:41; Auth",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/framework_8C.html:847,Detect,Detector,847,doc/master/framework_8C.html,https://root.cern,https://root.cern/doc/master/framework_8C.html,1,['Detect'],['Detector']
Safety,". ROOT: tutorials/graphics/gaxis.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. gaxis.C File ReferenceTutorials » Graphics tutorials. Detailed Description; Simple example illustrating how to draw TGaxis objects in various formats. . ; void gaxis(){; auto c1 = new TCanvas(""c1"",""Examples of TGaxis"",10,10,700,500);; c1->Range(-10,-1,10,1);; ; auto axis1 = new TGaxis(-4.5,-0.2,5.5,-0.2,-6,8,510,"""");; axis1->Draw();; ; auto axis2 = new TGaxis(-4.5,0.2,5.5,0.2,0.001,10000,510,""G"");; axis2->Draw();; ; auto axis3 = new TGaxis(-9,-0.8,-9,0.8,-8,8,50510,"""");; axis3->SetTitle(""axis3"");; axis3->SetTitleOffset(0.5);; axis3->Draw();; ; auto axis4 = new TGaxis(-7,-0.8,-7,0.8,1,10000,50510,""G"");; axis4->SetTitle(""axis4"");; axis4->Draw();; ; auto axis5 = new TGaxis(-4.5,-0.6,5.5,-0.6,1.2,1.32,80506,""-+"");; axis5->SetLabelSize(0.03);; axis5->SetTextFont(72);; axis5->Draw();; ; auto axis6 = new TGaxis(-4.5,0.5,5.5,0.5,100,900,50510,""-"");; axis6->Draw();; ; auto axis7 = new TGaxis(-5.5,0.85,5.5,0.85,0,4.3e-6,510,"""");; axis7->Draw();; ; auto axis8 = new TGaxis(8,-0.8,8,0.8,0,9000,50510,""+L"");; axis8->Draw();; ; // One can make a vertical axis going top->bottom. However the two x values should be; // slightly different to avoid labels overlapping.; auto axis9 = new TGaxis(6.5,0.8,6.499,-0.8,0,90,50510,""-"");; axis9->Draw();; }; TCanvasThe Canvas class.Definition TCanvas.h:23; TGaxisThe axis painter class.Definition TGaxis.h:24; c1return c1Definition legend1.C:41; AuthorsRene Brun, Olivier Couet ; Definition in file gaxis.C. tutorialsgraphicsgaxis.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:29 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/gaxis_8C.html:1272,avoid,avoid,1272,doc/master/gaxis_8C.html,https://root.cern,https://root.cern/doc/master/gaxis_8C.html,1,['avoid'],['avoid']
Safety,". ROOT: tutorials/graphics/mass_spectrum.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. mass_spectrum.C File ReferenceTutorials » Graphics tutorials. Detailed Description; This macro makes use of some basic graphics primitives such as line, arrow and text. ; It has been written using the TCanvas ToolBar to produce a first draft and was then modified for fine adjustments. Note also the use of C functions. They allow to simplify the macro reading and editing by avoiding code repetition or defining some graphics attributes in one single place. This technique to generate drawings may appear not very user friendly compare to all the ""wysiwyg"" graphics editors available. In some cases it can be more powerful than a GUI interface because it allows to generate very precise drawing and using computation to generate them. ; void hline (Double_t x, Double_t y); {; Double_t dx = 0.1;; TLine *l = new TLine(x,y,x+dx,y);; l->Draw();; l->SetLineWidth(4);; }; ; void DrawArrow (Double_t x1, Double_t y1, Double_t x2, Double_t y2, Int_t ls); {; TArrow *arr = new TArrow(x1,y1,x2,y2,0.025,""|>"");; arr->SetFillColor(1);; arr->SetFillStyle(1001);; arr->SetLineStyle(ls);; arr->SetAngle(19);; arr->Draw();; }; ; void mass_spectrum(); {; TCanvas *C = new TCanvas(""C"",""C"",800,500);; ; hline (0.10,0.25);; hline (0.10,0.80);; hline (0.30,0.90);; hline (0.30,0.35);; hline (0.45,0.60);; hline (0.58,0.68);; hline (0.73,0.70);; hline (0.89,0.75);; ; DrawArrow(0.32, 0.90, 0.32, 0.35, 1);; DrawArrow(0.34, 0.90, 0.34, 0.35, 1);; DrawArrow(0.36, 0.90, 0.36, 0.60, 1);; DrawArrow(0.38, 0.90, 0.38, 0.70, 1);; ; DrawArrow(0.30, 0.90, 0.18, 0.25, 1);; DrawArrow(0.30, 0.35, 0.19, 0.25, 1);; DrawArrow(0.40, 0.90, 0.47, 0.61, 1);; ; DrawArrow(0.15, 0.25, 0.15, 0.19, 1);; DrawArrow(0.15, 0.80, 0.15, 0.74, 1);; ; DrawArrow(0.50, 0.60, 0.50, 0.54, 1);; DrawArrow(0.60, 0.68, 0.60, 0.62, 1);; DrawArrow(0.94, 0.75, 0.94, 0.69, 1);; ; DrawArrow(0.32, 0.35, 0.32, 0.19, 1)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/mass__spectrum_8C.html:516,avoid,avoiding,516,doc/master/mass__spectrum_8C.html,https://root.cern,https://root.cern/doc/master/mass__spectrum_8C.html,1,['avoid'],['avoiding']
Safety,". ROOT: tutorials/graphics/saveall.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. saveall.C File ReferenceTutorials » Graphics tutorials. Detailed Description; Creates many canvases and save as images or pdf. ; This macro creates 100 canvases and store them in different images files using TCanvas::SaveAll() method. Demonstrated how different output format can be used in batch mode.; ; void saveall(); {; gROOT->SetBatch(kTRUE); // enforce batch mode to avoid appearance of multiple canvas windows; ; std::vector<TPad *> pads;; ; for(int n = 0; n < 100; ++n) {; auto c = new TCanvas(TString::Format(""canvas%d"", n), ""Canvas with histogram"");; ; auto h1 = new TH1I(TString::Format(""hist%d"", n), ""Histogram with random data"", 100, -5., 5);; h1->SetDirectory(nullptr);; h1->FillRandom(""gaus"", 10000);; ; h1->Draw();; ; pads.push_back(c);; }; ; TCanvas::SaveAll(pads, ""image%03d.png""); // create 100 PNG images; ; TCanvas::SaveAll(pads, ""image.svg""); // create 100 SVG images, %d pattern will be automatically append; ; TCanvas::SaveAll(pads, ""images.root""); // create single ROOT file with all canvases; ; TCanvas::SaveAll(); // save all existing canvases in allcanvases.pdf file; }; c#define c(i)Definition RSha256.hxx:101; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; gROOT#define gROOTDefinition TROOT.h:406; TCanvasThe Canvas class.Definition TCanvas.h:23; TCanvas::SaveAllstatic Bool_t SaveAll(const std::vector< TPad * > &={}, const char *filename="""", Option_t *option="""")Save provided pads/canvases into the image file(s) Filename can include printf argument for image num...Definition TCanvas.cxx:2654; TH1I1-D histogram with an int per channel (see TH1 documentation)Definition TH1.h:540; TH1::SetDirectoryvirtual void SetDirectory(TDirectory *dir)By default, when a histogram is created, it is added to the list of histogram objects in the current ...Definition TH1.cxx:8937; TH1::FillRandomvirtual void FillRandom(const char *fnam",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/saveall_8C.html:508,avoid,avoid,508,doc/master/saveall_8C.html,https://root.cern,https://root.cern/doc/master/saveall_8C.html,1,['avoid'],['avoid']
Safety,". ROOT: tutorials/graphs/zdemo.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. zdemo.C File ReferenceTutorials » Graphs tutorials. Detailed Description; This macro is an example of graphs in log scales with annotations. ; The presented results are predictions of invariant cross-section of Direct Photons produced at RHIC energies, based on the universality of scaling function H(z).; These Figures were published in JINR preprint E2-98-64, Dubna, 1998 and submitted to CPC.; Note that the way greek symbols, super/subscripts are obtained illustrate the current limitations of Root in this area. ; #include ""TCanvas.h""; #include ""TPad.h""; #include ""TPaveLabel.h""; #include ""TLatex.h""; #include ""TGraph.h""; #include ""TFrame.h""; ; #ifdef HZ; #undef HZ; #endif; ; const Int_t NMAX = 20;; Int_t NLOOP;; Float_t Z[NMAX], HZ[NMAX], PT[NMAX], INVSIG[NMAX];; ; void hz_calc(Float_t, Float_t, Float_t, Float_t, Float_t, Float_t);; ; //__________________________________________________________________; void zdemo(); {; ; Float_t energ;; Float_t dens;; Float_t tgrad;; Float_t ptmin;; Float_t ptmax;; Float_t delp;; ; // Create a new canvas.; TCanvas *c1 = new TCanvas(""zdemo"",; ""Monte Carlo Study of Z scaling"",10,40,800,600);; c1->Range(0,0,25,18);; c1->SetFillColor(40);; ; TPaveLabel *pl = new TPaveLabel(1,16.3,24,17.5,""Z-scaling of \; Direct Photon Productions in pp Collisions at RHIC Energies"",""br"");; pl->SetFillColor(18);; pl->SetTextFont(32);; pl->SetTextColor(49);; pl->Draw();; ; TLatex t0;; t0.SetTextFont(32);; t0.SetTextColor(1);; t0.SetTextSize(0.03);; t0.SetTextAlign(12);; t0.DrawLatex(3.1,15.5,""M.Tokarev, E.Potrebenikova "");; t0.DrawLatex(14.,15.5,""JINR preprint E2-98-64, Dubna, 1998 "");; ; TPad *pad1 = new TPad(""pad1"",""This is pad1"",0.02,0.02,0.48,0.83,33);; TPad *pad2 = new TPad(""pad2"",""This is pad2"",0.52,0.02,0.98,0.83,33);; ; pad1->Draw();; pad2->Draw();; ; //; // Cross-section of direct photon production in pp collisions; // at",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/zdemo_8C.html:299,predict,predictions,299,doc/master/zdemo_8C.html,https://root.cern,https://root.cern/doc/master/zdemo_8C.html,1,['predict'],['predictions']
Safety,". ROOT: tutorials/hist/tprofile2polyRealisticModuleError.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. tprofile2polyRealisticModuleError.C File ReferenceTutorials » Histograms tutorials. Detailed Description; Simulate faulty detector panel w.r.t. ; particle charge. ; #include <iostream>; #include <fstream>; #include <vector>; ; void tprofile2polyRealisticModuleError(Int_t numEvents = 1000000); {; TCanvas *c1 = new TCanvas(""c1"", ""4 Malfunctioning Panels"", 800, 400);; c1->Divide(3, 1);; ; // -------------------- Construct detector bins ------------------------; auto th2p = new TH2Poly();; auto avg = new TProfile2Poly();; auto err = new TProfile2Poly();; ; std::ifstream infile;; TString dir = gROOT->GetTutorialDir();; dir.Append(""/hist/data/tprofile2poly_tutorial.data"");; infile.open(dir.Data());; ; if (!infile) // Verify that the file was open successfully; {; std::cerr << dir.Data() << std::endl; // Report error; std::cerr << ""Error code: "" << std::strerror(errno) << std::endl; // Get some info as to why; return;; }; ; std::vector<std::pair<Double_t, Double_t>> allCoords;; Double_t a, b;; while (infile >> a >> b) ; allCoords.emplace_back(a, b);; ; if (allCoords.size() % 3 != 0) {; std::cout << ""[ERROR] Bad file"" << std::endl;; return;; }; ; Double_t x[3], y[3];; for (Int_t i = 0; i < allCoords.size(); i += 3) {; x[0] = allCoords[i + 0].first;; y[0] = allCoords[i + 0].second;; x[1] = allCoords[i + 1].first;; y[1] = allCoords[i + 1].second;; x[2] = allCoords[i + 2].first;; y[2] = allCoords[i + 2].second;; th2p->AddBin(3, x, y);; avg->AddBin(3, x, y);; err->AddBin(3, x, y);; }; ; // -------------------- Generate particles ------------------------; TRandom ran;; for (int j = 0; j < numEvents; ++j) {; Double_t r1 = ran.Gaus(0, 10);; Double_t r2 = ran.Gaus(0, 8);; Double_t rok = ran.Gaus(20, 2);; Double_t rbad1 = ran.Gaus(1, 2);; Double_t rbad2 = ran.Gaus(2, 0);; ; Double_t val = rok;; // -------------------- Malfunctioni",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tprofile2polyRealisticModuleError_8C.html:278,detect,detector,278,doc/master/tprofile2polyRealisticModuleError_8C.html,https://root.cern,https://root.cern/doc/master/tprofile2polyRealisticModuleError_8C.html,2,['detect'],['detector']
Safety,". ROOT: tutorials/pyroot/hsimple.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; hsimple.py File ReferenceTutorials » PyRoot tutorials. Detailed Description; This program creates : . a one dimensional histogram; a two dimensional histogram; a profile histogram; a memory-resident ntuple. These objects are filled with some random numbers and saved on a file. ; from ROOT import TCanvas, TFile, TProfile, TNtuple, TH1F, TH2F; from ROOT import gROOT, gBenchmark, gRandom, gSystem; import ctypes; ; # Create a new canvas, and customize it.; c1 = TCanvas( 'c1', 'Dynamic Filling Example', 200, 10, 700, 500 ); c1.SetFillColor( 42 ); c1.GetFrame().SetFillColor( 21 ); c1.GetFrame().SetBorderSize( 6 ); c1.GetFrame().SetBorderMode( -1 ); ; # Create a new ROOT binary machine independent file.; # Note that this file may contain any kind of ROOT objects, histograms,; # pictures, graphics objects, detector geometries, tracks, events, etc..; # This file is now becoming the current directory.; ; hfile = gROOT.FindObject( 'py-hsimple.root' ); if hfile:; hfile.Close(); hfile = TFile( 'py-hsimple.root', 'RECREATE', 'Demo ROOT file with histograms' ); ; # Create some histograms, a profile histogram and an ntuple; hpx = TH1F( 'hpx', 'This is the px distribution', 100, -4, 4 ); hpxpy = TH2F( 'hpxpy', 'py vs px', 40, -4, 4, 40, -4, 4 ); hprof = TProfile( 'hprof', 'Profile of pz versus px', 100, -4, 4, 0, 20 ); ntuple = TNtuple( 'ntuple', 'Demo ntuple', 'px:py:pz:random:i' ); ; # Set canvas/frame attributes.; hpx.SetFillColor( 48 ); ; gBenchmark.Start( 'hsimple' ); ; # Initialize random number generator.; gRandom.SetSeed(); rannor, rndm = gRandom.Rannor, gRandom.Rndm; ; # For speed, bind and cache the Fill member functions,; histos = [ 'hpx', 'hpxpy', 'hprof', 'ntuple' ]; for name in histos:; exec('%sFill = %s.Fill' % (name,name)); ; # Fill histograms randomly.; px_ref, py_ref = ctypes.c_double(), ctypes.c_double(); kUPDATE = 1000; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/hsimple_8py.html:956,detect,detector,956,doc/master/hsimple_8py.html,https://root.cern,https://root.cern/doc/master/hsimple_8py.html,1,['detect'],['detector']
Safety,". ROOT: tutorials/pyroot/na49view.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; na49view.py File ReferenceTutorials » PyRoot tutorials. Detailed Description; This macro generates two views of the NA49 detector. ; To have a better and dynamic view of any of these pads, you can click with the middle button of your mouse to select it. Then select ""View with x3d"" in the VIEW menu of the Canvas. Once in x3d, you are in wireframe mode by default. You can switch to:; Hidden Line mode by typing E; Solid mode by typing R; Wireframe mode by typing W; Stereo mode by clicking S (and you need special glasses); To leave x3d type Q. ; import ROOT; ; c1 = ROOT.TCanvas( 'c1', 'The NA49 canvas', 200, 10, 700, 780 ); ; ROOT.gBenchmark.Start( 'na49view' ); ; all = ROOT.TPad( 'all', 'A Global view of NA49', 0.02, 0.02, 0.48, 0.82, 28 ); tof = ROOT.TPad( 'tof', 'One Time Of Flight element', 0.52, 0.02, 0.98, 0.82, 28 ); all.Draw();; tof.Draw();; na49title = ROOT.TPaveLabel( 0.04, 0.86, 0.96, 0.98, 'Two views of the NA49 detector' ); na49title.SetFillColor( 32 ); na49title.Draw(); #; nageom = ROOT.TFile( 'py-na49.root' ); n49 = ROOT.gROOT.FindObject( 'na49' ); n49.SetBomb( 1.2 ); n49.cd() # Set current geometry; all.cd() # Set current pad; n49.Draw(); c1.Update(); tof.cd(); TOFR1 = n49.GetNode( 'TOFR1' ); TOFR1.Draw(); c1.Update(); ; ROOT.gBenchmark.Show( 'na49view' ); AuthorWim Lavrijsen ; Definition in file na49view.py. tutorialspyrootna49view.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/na49view_8py.html:268,detect,detector,268,doc/master/na49view_8py.html,https://root.cern,https://root.cern/doc/master/na49view_8py.html,2,['detect'],['detector']
Safety,". ROOT: tutorials/pyroot/pyroot006_tcontext_context_manager.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; pyroot006_tcontext_context_manager.py File ReferenceTutorials » PyRoot tutorials. Detailed Description; This tutorial demonstrates the usage of the TContext class as a Python context manager. ; This functionality is related with how TFile works, so it is suggested to also take a look at the pyroot005 tutorial.; import os; ; import ROOT; from ROOT import TDirectory, TFile; ; # Sometimes it is useful to have multiple open files at once. In such cases,; # the current directory will always be the file that was open last.; file_1 = TFile(""pyroot006_file_1.root"", ""recreate""); file_2 = TFile(""pyroot006_file_2.root"", ""recreate""); print(""Current directory: '{}'.\n"".format(ROOT.gDirectory.GetName())); # Changing directory into another file can be safely done through a TContext; # context manager.; with TDirectory.TContext(file_1):; # Inside the statement, the current directory is file_1; print(""Current directory: '{}'.\n"".format(ROOT.gDirectory.GetName())); histo_1 = ROOT.TH1F(""histo_1"", ""histo_1"", 10, 0, 10); file_1.WriteObject(histo_1, ""my_histogram""); ; # After the context, the current directory is restored back to file_2. Also, the; # two files are kept open. This means that objects read, written or modified; # inside the context are still available afterwards.; print(""Current directory: '{}'.\n"".format(ROOT.gDirectory.GetName())); if file_1.IsOpen() and file_2.IsOpen():; print(""'{}' and '{}' are open.\n"".format(file_1.GetName(), file_2.GetName())); ; # TContext and TFile context managers can also be used in conjunction, allowing; # for safely:; # - Opening a file, creating, modifying, writing and reading objects in it.; # - Closing the file, storing it on disk.; # - Restoring the previous value of gDirectory to the latest file opened before; # this context, rather than to the global ROOT.gROOT; # Remem",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/pyroot006__tcontext__context__manager_8py.html:920,safe,safely,920,doc/master/pyroot006__tcontext__context__manager_8py.html,https://root.cern,https://root.cern/doc/master/pyroot006__tcontext__context__manager_8py.html,1,['safe'],['safely']
Safety,". ROOT: tutorials/pyroot/zdemo.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; zdemo.py File ReferenceTutorials » PyRoot tutorials. Detailed Description; This macro is an example of graphs in log scales with annotations. ; The presented results are predictions of invariant cross-section of Direct Photons produced at RHIC energies, based on the universality of scaling function H(z).; These Figures were published in JINR preprint E2-98-64, Dubna, 1998 and submitted to CPC. ; import ROOT; from array import array; ; NMAX = 20; Z = array( 'f', [0.]*NMAX ); HZ = array( 'f', [0.]*NMAX ); PT = array( 'f', [0.]*NMAX ); INVSIG = array( 'f', [0.]*NMAX ); ; NLOOP = 0; saves = {}; ; #_______________________________________________________________________________; def hz_calc( ENERG, DENS, TGRAD, PTMIN, PTMAX, DELP ):; from math import sin, cos, sqrt; global NLOOP; global Z, HZ, PT, INVSIG; ; CSEFT= 1.; GM1 = 0.00001; GM2 = 0.00001; A1 = 1.; A2 = 1.; ALX = 2.; BETA = 1.; KF1 = 8.E-7; KF2 = 5.215; ; MN = 0.9383; DEGRAD=0.01745329; ; # print 'ENR= %f DENS= %f PTMIN= %f PTMAX= %f DELP= %f ' % (ENERG,DENS,PTMIN,PTMAX,DELP); ; DNDETA= DENS; MB1 = MN*A1; MB2 = MN*A2; EB1 = ENERG/2.*A1; EB2 = ENERG/2.*A2; M1 = GM1; M2 = GM2; THET = TGRAD*DEGRAD; NLOOP = int((PTMAX-PTMIN)/DELP); ; for I in range(NLOOP):; PT[I]=PTMIN+I*DELP; PTOT = PT[I]/sin(THET); ; ETOT = sqrt(M1*M1 + PTOT*PTOT); PB1 = sqrt(EB1*EB1 - MB1*MB1); PB2 = sqrt(EB2*EB2 - MB2*MB2); P2P3 = EB2*ETOT+PB2*PTOT*cos(THET); P1P2 = EB2*EB1+PB2*PB1; P1P3 = EB1*ETOT-PB1*PTOT*cos(THET); ; X1 = P2P3/P1P2; X2 = P1P3/P1P2; Y1 = X1+sqrt(X1*X2*(1.-X1)/(1.-X2)); Y2 = X2+sqrt(X1*X2*(1.-X2)/(1.-X1)); ; S = (MB1*MB1)+2.*P1P2+(MB2*MB2); SMIN = 4.*((MB1*MB1)*(X1*X1) +2.*X1*X2*P1P2+(MB2*MB2)*(X2*X2)); SX1 = 4.*( 2*(MB1*MB1)*X1+2*X2*P1P2); SX2 = 4.*( 2*(MB2*MB2)*X2+2*X1*P1P2); SX1X2= 4.*(2*P1P2); DELM = pow((1.-Y1)*(1.-Y2),ALX); ; Z[I] = sqrt(SMIN)/DELM/pow(DNDETA,BETA); ; Y1X1 = 1. +X2*(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/zdemo_8py.html:314,predict,predictions,314,doc/master/zdemo_8py.html,https://root.cern,https://root.cern/doc/master/zdemo_8py.html,1,['predict'],['predictions']
Safety,". ROOT: tutorials/roofit/rf204b_extendedLikelihood_rangedFit.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf204b_extendedLikelihood_rangedFit.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; This macro demonstrates how to set up a fit in two ranges for plain likelihoods and extended likelihoods. . 1. Shape fits (plain likelihood); If you fit a non-extended pdf in two ranges, e.g. pdf->fitTo(data,Range(""Range1,Range2"")), it will fit the shapes in the two selected ranges and also take into account the relative predicted yields in those ranges.; This is useful for example to represent a full-range fit, but with a blinded signal region inside it. 2. Shape+rate fits (extended likelihood); If your pdf is extended, i.e. measuring both the distribution in the observable as well as the event count in the fitted region, some intervention is needed to make fits in ranges work in a way that corresponds to intuition.; If an extended fit is performed in a sub-range, the observed yield is only that of the subrange, hence the expected event count will converge to a number that is smaller than what's visible in a plot. In such cases, it is often preferred to interpret the extended term with respect to the full range that's plotted, i.e., apply a correction to the extended likelihood term in such a way that the interpretation of the expected event count remains that of the full range. This can be done by applying a correcion factor (equal to the fraction of the pdf that is contained in the fitted range) in the Poisson term that represents the extended likelihood term.; If an extended likelihood fit is performed over two sub-ranges, this correction is even more important: without it, each component likelihood would have a different interpretation of the expected event count (each corresponding to the count in its own region), and a joint fit of these regions with different interpretations of the same model paramet",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf204b__extendedLikelihood__rangedFit_8C.html:587,predict,predicted,587,doc/master/rf204b__extendedLikelihood__rangedFit_8C.html,https://root.cern,https://root.cern/doc/master/rf204b__extendedLikelihood__rangedFit_8C.html,1,['predict'],['predicted']
Safety,". ROOT: tutorials/roofit/rf204b_extendedLikelihood_rangedFit.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf204b_extendedLikelihood_rangedFit.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; This macro demonstrates how to set up a fit in two ranges for plain likelihoods and extended likelihoods. . 1. Shape fits (plain likelihood); If you fit a non-extended pdf in two ranges, e.g. pdf.fitTo(data,Range=""Range1,Range2""), it will fit the shapes in the two selected ranges and also take into account the relative predicted yields in those ranges.; This is useful for example to represent a full-range fit, but with a blinded signal region inside it. 2. Shape+rate fits (extended likelihood); If your pdf is extended, i.e. measuring both the distribution in the observable as well as the event count in the fitted region, some intervention is needed to make fits in ranges work in a way that corresponds to intuition.; If an extended fit is performed in a sub-range, the observed yield is only that of the subrange, hence the expected event count will converge to a number that is smaller than what's visible in a plot. In such cases, it is often preferred to interpret the extended term with respect to the full range that's plotted, i.e., apply a correction to the extended likelihood term in such a way that the interpretation of the expected event count remains that of the full range. This can be done by applying a correcion factor (equal to the fraction of the pdf that is contained in the fitted range) in the Poisson term that represents the extended likelihood term.; If an extended likelihood fit is performed over two sub-ranges, this correction is even more important: without it, each component likelihood would have a different interpretation of the expected event count (each corresponding to the count in its own region), and a joint fit of these regions with different interpretations of the same ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf204b__extendedLikelihood__rangedFit_8py.html:600,predict,predicted,600,doc/master/rf204b__extendedLikelihood__rangedFit_8py.html,https://root.cern,https://root.cern/doc/master/rf204b__extendedLikelihood__rangedFit_8py.html,1,['predict'],['predicted']
Safety,". ROOT: tutorials/roofit/rf612_recoverFromInvalidParameters.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf612_recoverFromInvalidParameters.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Likelihood and minimization: Recover from regions where the function is not defined. ; We demonstrate improved recovery from disallowed parameters. For this, we use a polynomial PDF of the form ; \[; \mathrm{Pol2} = \mathcal{N} \left( c + a_1 \cdot x + a_2 \cdot x^2 + 0.01 \cdot x^3 \right),; \]. where \( \mathcal{N} \) is a normalisation factor. Unless the parameters are chosen carefully, this function can be negative, and hence, it cannot be used as a PDF. In this case, RooFit passes an error to the minimiser, which might try to recover.; Before ROOT 6.24, RooFit always passed the highest function value that was encountered during the minimisation to the minimiser. If a parameter is far in a disallowed region, the minimiser has to blindly test various values of the parameters. It might find the correct values by chance, but often be unable to recover from bad starting values. Here, we use a model with such bad values.; Starting with ROOT 6.24, the minimiser receives more information. For example, when a PDF is negative, the magnitude of the ""undershoot"" is passed to the minimiser. The minimiser can use this to compute a gradient, which will eventually lead it out of the disallowed region. The steepness of this gradient can be chosen using RooFit::RecoverFromUndefinedRegions(double). A value of zero is equivalent to RooFit before ROOT 6.24. Positive values activate the recovery. Values between 1. and 10. were found to be a good default. If no argument is passed, RooFit uses 10.; ; #include <RooRealVar.h>; #include <RooPolynomial.h>; #include <RooPlot.h>; #include <RooDataSet.h>; #include <RooGlobalFunc.h>; #include <RooFitResult.h>; #include <RooMsgService.h>; ; #include <TCanvas.h>; #include <TLegend.h>; ; v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html:291,Recover,Recover,291,doc/master/rf612__recoverFromInvalidParameters_8C.html,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html,3,"['Recover', 'recover']","['Recover', 'recover', 'recovery']"
Safety,". ROOT: tutorials/roofit/rf612_recoverFromInvalidParameters.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf612_recoverFromInvalidParameters.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Likelihood and minimization: Recover from regions where the function is not defined. ; We demonstrate improved recovery from disallowed parameters. For this, we use a polynomial PDF of the form ; \[; \mathrm{Pol2} = \mathcal{N} \left( c + a_1 \cdot x + a_2 \cdot x^2 + 0.01 \cdot x^3 \right),; \]. where \( \mathcal{N} \) is a normalisation factor. Unless the parameters are chosen carefully, this function can be negative, and hence, it cannot be used as a PDF. In this case, RooFit passes an error to the minimiser, which might try to recover.; ; import ROOT; ; ; # Create a fit model:; # The polynomial is notoriously unstable, because it can quickly go negative.; # Since PDFs need to be positive, one often ends up with an unstable fit model.; x = ROOT.RooRealVar(""x"", ""x"", -15, 15); a1 = ROOT.RooRealVar(""a1"", ""a1"", -0.5, -10.0, 20.0); a2 = ROOT.RooRealVar(""a2"", ""a2"", 0.2, -10.0, 20.0); a3 = ROOT.RooRealVar(""a3"", ""a3"", 0.01); pdf = ROOT.RooPolynomial(""pol3"", ""c + a1 * x + a2 * x*x + 0.01 * x*x*x"", x, [a1, a2, a3]); ; # Create toy data with all-positive coefficients:; data = pdf.generate(x, 10000); ; # For plotting.; # We create pointers to the plotted objects. We want these objects to leak out of the function,; # so we can still see them after it returns.; c = ROOT.TCanvas(); frame = x.frame(); data.plotOn(frame, Name=""data""); ; # Plotting a PDF with disallowed parameters doesn't work. We would get a lot of error messages.; # Therefore, we disable plotting messages in RooFit's message streams:; ROOT.RooMsgService.instance().getStream(0).removeTopic(ROOT.RooFit.Plotting); ROOT.RooMsgService.instance().getStream(1).removeTopic(ROOT.RooFit.Plotting); ; ; # RooFit before ROOT 6.24; # ---------------------",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html:306,Recover,Recover,306,doc/master/rf612__recoverFromInvalidParameters_8py.html,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html,3,"['Recover', 'recover']","['Recover', 'recover', 'recovery']"
Safety,". ROOT: tutorials/tmva/tmva101_Training.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; tmva101_Training.py File ReferenceTutorials » TMVA tutorials. Detailed Description; This tutorial show how you can train a machine learning model with any package reading the training data directly from ROOT files. ; Using XGBoost, we illustrate how you can convert an externally trained model in a format serializable and readable with the fast tree inference engine offered by TMVA.; ; # XGBoost has to be imported before ROOT to avoid crashes because of clashing; # std::regexp symbols that are exported by cppyy.; # See also: https://github.com/wlav/cppyy/issues/227; from xgboost import XGBClassifier; ; import ROOT; import numpy as np; ; from tmva100_DataPreparation import variables; ; ; def load_data(signal_filename, background_filename):; # Read data from ROOT files; data_sig = ROOT.RDataFrame(""Events"", signal_filename).AsNumpy(); data_bkg = ROOT.RDataFrame(""Events"", background_filename).AsNumpy(); ; # Convert inputs to format readable by machine learning tools; x_sig = np.vstack([data_sig[var] for var in variables]).T; x_bkg = np.vstack([data_bkg[var] for var in variables]).T; x = np.vstack([x_sig, x_bkg]); ; # Create labels; num_sig = x_sig.shape[0]; num_bkg = x_bkg.shape[0]; y = np.hstack([np.ones(num_sig), np.zeros(num_bkg)]); ; # Compute weights balancing both classes; num_all = num_sig + num_bkg; w = np.hstack([np.ones(num_sig) * num_all / num_sig, np.ones(num_bkg) * num_all / num_bkg]); ; return x, y, w; ; if __name__ == ""__main__"":; # Load data; x, y, w = load_data(""train_signal.root"", ""train_background.root""); ; # Fit xgboost model; bdt = XGBClassifier(max_depth=3, n_estimators=500); bdt.fit(x, y, sample_weight=w); ; # Save model in TMVA format; print(""Training done on "",x.shape[0],""events. Saving model in tmva101.root""); ROOT.TMVA.Experimental.SaveXGBoost(bdt, ""myBDT"", ""tmva101.root"", num_inputs=x.shape[1])",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva101__Training_8py.html:585,avoid,avoid,585,doc/master/tmva101__Training_8py.html,https://root.cern,https://root.cern/doc/master/tmva101__Training_8py.html,1,['avoid'],['avoid']
Safety,". ROOT: tutorials/tmva/tmva101_Training.py Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. tmva101_Training.py. Go to the documentation of this file. 1## \file; 2## \ingroup tutorial_tmva; 3## \notebook -nodraw; 4## This tutorial show how you can train a machine learning model with any package; 5## reading the training data directly from ROOT files. Using XGBoost, we illustrate; 6## how you can convert an externally trained model in a format serializable and readable; 7## with the fast tree inference engine offered by TMVA.; 8##; 9## \macro_code; 10## \macro_output; 11##; 12## \date August 2019; 13## \author Stefan Wunsch; 14 ; 15# XGBoost has to be imported before ROOT to avoid crashes because of clashing; 16# std::regexp symbols that are exported by cppyy.; 17# See also: https://github.com/wlav/cppyy/issues/227; 18from xgboost import XGBClassifier; 19 ; 20import ROOT; 21import numpy as np; 22 ; 23from tmva100_DataPreparation import variables; 24 ; 25 ; 26def load_data(signal_filename, background_filename):; 27 # Read data from ROOT files; 28 data_sig = ROOT.RDataFrame(""Events"", signal_filename).AsNumpy(); 29 data_bkg = ROOT.RDataFrame(""Events"", background_filename).AsNumpy(); 30 ; 31 # Convert inputs to format readable by machine learning tools; 32 x_sig = np.vstack([data_sig[var] for var in variables]).T; 33 x_bkg = np.vstack([data_bkg[var] for var in variables]).T; 34 x = np.vstack([x_sig, x_bkg]); 35 ; 36 # Create labels; 37 num_sig = x_sig.shape[0]; 38 num_bkg = x_bkg.shape[0]; 39 y = np.hstack([np.ones(num_sig), np.zeros(num_bkg)]); 40 ; 41 # Compute weights balancing both classes; 42 num_all = num_sig + num_bkg; 43 w = np.hstack([np.ones(num_sig) * num_all / num_sig, np.ones(num_bkg) * num_all / num_bkg]); 44 ; 45 return x, y, w; 46 ; 47if __name__ == ""__main__"":; 48 # Load data; 49 x, y, w = load_data(""train_signal.root"", ""train_background.root""); 50 ; 51 # Fit xgboost model; 52 bdt = XGBClassifier(max_depth=3, n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva101__Training_8py_source.html:728,avoid,avoid,728,doc/master/tmva101__Training_8py_source.html,https://root.cern,https://root.cern/doc/master/tmva101__Training_8py_source.html,1,['avoid'],['avoid']
Safety,". ROOT: tutorials/tmva/tmva102_Testing.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; tmva102_Testing.py File ReferenceTutorials » TMVA tutorials. Detailed Description; This tutorial illustrates how you can test a trained BDT model using the fast tree inference engine offered by TMVA and external tools such as scikit-learn. ; ; import ROOT; import pickle; ; from tmva100_DataPreparation import variables; from tmva101_Training import load_data; ; ; # Load data; x, y_true, w = load_data(""test_signal.root"", ""test_background.root""); ; # Load trained model; File = ""tmva101.root""; if (ROOT.gSystem.AccessPathName(File)) :; ROOT.Info(""tmva102_Testing.py"", File+""does not exist""); exit(); ; bdt = ROOT.TMVA.Experimental.RBDT(""myBDT"", File); ; # Make prediction; y_pred = bdt.Compute(x); ; # Compute ROC using sklearn; from sklearn.metrics import roc_curve, auc; false_positive_rate, true_positive_rate, _ = roc_curve(y_true, y_pred, sample_weight=w); score = auc(false_positive_rate, true_positive_rate); ; # Plot ROC; c = ROOT.TCanvas(""roc"", """", 600, 600); g = ROOT.TGraph(len(false_positive_rate), false_positive_rate, true_positive_rate); g.SetTitle(""AUC = {:.2f}"".format(score)); g.SetLineWidth(3); g.SetLineColor(ROOT.kRed); g.Draw(""AC""); g.GetXaxis().SetRangeUser(0, 1); g.GetYaxis().SetRangeUser(0, 1); g.GetXaxis().SetTitle(""False-positive rate""); g.GetYaxis().SetTitle(""True-positive rate""); c.Draw(); lenOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva102__Testing_8py.html:814,predict,prediction,814,doc/master/tmva102__Testing_8py.html,https://root.cern,https://root.cern/doc/master/tmva102__Testing_8py.html,1,['predict'],['prediction']
Safety,". ROOT: tutorials/v7/ntuple/ntpl001_staff.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. ntpl001_staff.C File ReferenceTutorials » ROOT 7 tutorials » ROOT 7 ntuple tutorials. Detailed Description; Write and read tabular data with RNTuple. ; Adapted from the cernbuild and cernstaff tree tutorials. Illustrates the type-safe ntuple model interface, which is used to define a data model that is in a second step taken by an ntuple reader or writer. ; // NOTE: The RNTuple classes are experimental at this point.; // Functionality, interface, and data format is still subject to changes.; // Do not use for real data!; ; #include <ROOT/RNTupleModel.hxx>; #include <ROOT/RNTupleReader.hxx>; #include <ROOT/RNTupleWriter.hxx>; ; #include <TCanvas.h>; #include <TH1I.h>; #include <TROOT.h>; #include <TString.h>; ; #include <cassert>; #include <cstdio>; #include <fstream>; #include <iostream>; #include <memory>; #include <string>; #include <sstream>; #include <utility>; ; // Import classes from experimental namespace for the time being; using RNTupleModel = ROOT::Experimental::RNTupleModel;; using RNTupleReader = ROOT::Experimental::RNTupleReader;; using RNTupleWriter = ROOT::Experimental::RNTupleWriter;; ; constexpr char const* kNTupleFileName = ""ntpl001_staff.root"";; ; void Ingest() {; // The input file cernstaff.dat is a copy of the CERN staff data base from 1988; ifstream fin(gROOT->GetTutorialDir() + ""/tree/cernstaff.dat"");; assert(fin.is_open());; ; // We create a unique pointer to an empty data model; auto model = RNTupleModel::Create();; ; // To define the data model, we create fields with a given C++ type and name. Fields are roughly TTree branches.; // MakeField returns a shared pointer to a memory location that we can populate to fill the ntuple with data; auto fldCategory = model->MakeField<int>(""Category"");; auto fldFlag = model->MakeField<unsigned int>(""Flag"");; auto fldAge = model->MakeField<int>(""Age"");; auto fldServi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/ntpl001__staff_8C.html:371,safe,safe,371,doc/master/ntpl001__staff_8C.html,https://root.cern,https://root.cern/doc/master/ntpl001__staff_8C.html,1,['safe'],['safe']
Safety,". ROOT: tutorials/v7/ntuple/ntpl001_staff.C Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. ntpl001_staff.C. Go to the documentation of this file. 1/// \file; 2/// \ingroup tutorial_ntuple; 3/// \notebook; 4/// Write and read tabular data with RNTuple. Adapted from the cernbuild and cernstaff tree tutorials.; 5/// Illustrates the type-safe ntuple model interface, which is used to define a data model that is in a second step; 6/// taken by an ntuple reader or writer.; 7///; 8/// \macro_image; 9/// \macro_code; 10///; 11/// \date April 2019; 12/// \author The ROOT Team; 13 ; 14// NOTE: The RNTuple classes are experimental at this point.; 15// Functionality, interface, and data format is still subject to changes.; 16// Do not use for real data!; 17 ; 18#include <ROOT/RNTupleModel.hxx>; 19#include <ROOT/RNTupleReader.hxx>; 20#include <ROOT/RNTupleWriter.hxx>; 21 ; 22#include <TCanvas.h>; 23#include <TH1I.h>; 24#include <TROOT.h>; 25#include <TString.h>; 26 ; 27#include <cassert>; 28#include <cstdio>; 29#include <fstream>; 30#include <iostream>; 31#include <memory>; 32#include <string>; 33#include <sstream>; 34#include <utility>; 35 ; 36// Import classes from experimental namespace for the time being; 37using RNTupleModel = ROOT::Experimental::RNTupleModel;; 38using RNTupleReader = ROOT::Experimental::RNTupleReader;; 39using RNTupleWriter = ROOT::Experimental::RNTupleWriter;; 40 ; 41constexpr char const* kNTupleFileName = ""ntpl001_staff.root"";; 42 ; 43void Ingest() {; 44 // The input file cernstaff.dat is a copy of the CERN staff data base from 1988; 45 ifstream fin(gROOT->GetTutorialDir() + ""/tree/cernstaff.dat"");; 46 assert(fin.is_open());; 47 ; 48 // We create a unique pointer to an empty data model; 49 auto model = RNTupleModel::Create();; 50 ; 51 // To define the data model, we create fields with a given C++ type and name. Fields are roughly TTree branches.; 52 // MakeField returns a shared pointer to a memory location th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/ntpl001__staff_8C_source.html:383,safe,safe,383,doc/master/ntpl001__staff_8C_source.html,https://root.cern,https://root.cern/doc/master/ntpl001__staff_8C_source.html,1,['safe'],['safe']
Safety,". ROOT::Fit::FitData. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Fit::FitData. class ROOT::Fit::FitData. Function Members (Methods); public:. virtual~FitData(); ROOT::Fit::FitDataFitData(); ROOT::Fit::FitDataFitData(const ROOT::Fit::DataOptions& opt); ROOT::Fit::FitDataFitData(const ROOT::Fit::DataRange& range); ROOT::Fit::FitDataFitData(const ROOT::Fit::FitData&); ROOT::Fit::FitDataFitData(const ROOT::Fit::DataOptions& opt, const ROOT::Fit::DataRange& range); static unsigned intMaxSize(); ROOT::Fit::FitData&operator=(const ROOT::Fit::FitData&); const ROOT::Fit::DataOptions&Opt() const; ROOT::Fit::DataOptions&Opt(); const ROOT::Fit::DataRange&Range() const. Data Members; private:. ROOT::Fit::DataOptionsfOptions; ROOT::Fit::DataRangefRange. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; FitData(); construct with default option and data range. {}. virtual ~FitData(); dummy virtual destructor. {}. FitData(const DataOptions & opt); construct passing options and default data range. {}. FitData(const DataRange & range); construct passing range and default options. {}. FitData(const ROOT::Fit::DataOptions& opt, const ROOT::Fit::DataRange& range); construct passing options and data range. {}. unsigned int MaxSize(); range cannot be modified afterwards; since fit method functions use all data. define a max size to avoid allocating too large arrays. » Author: L. Moneta Wed Aug 30 11:15:23 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id: DataVector.h 28946 2009-06-11 15:39:14Z moneta $ » Last generated: 2009-12-07 13:43; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Fit__FitData.html:1543,avoid,avoid,1543,root/html526/ROOT__Fit__FitData.html,https://root.cern,https://root.cern/root/html526/ROOT__Fit__FitData.html,1,['avoid'],['avoid']
Safety,". ROOT::Fit::FitData. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Fit::FitData. class ROOT::Fit::FitData. Function Members (Methods); public:. virtual~FitData(); ROOT::Fit::FitDataFitData(); ROOT::Fit::FitDataFitData(const ROOT::Fit::DataOptions& opt); ROOT::Fit::FitDataFitData(const ROOT::Fit::DataRange& range); ROOT::Fit::FitDataFitData(const ROOT::Fit::FitData&); ROOT::Fit::FitDataFitData(const ROOT::Fit::DataOptions& opt, const ROOT::Fit::DataRange& range); static unsigned intMaxSize(); ROOT::Fit::FitData&operator=(const ROOT::Fit::FitData&); const ROOT::Fit::DataOptions&Opt() const; ROOT::Fit::DataOptions&Opt(); const ROOT::Fit::DataRange&Range() const. Data Members; private:. ROOT::Fit::DataOptionsfOptions; ROOT::Fit::DataRangefRange. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; FitData(); construct with default option and data range. {}. virtual ~FitData(); dummy virtual destructor. {}. FitData(const DataOptions & opt); construct passing options and default data range. {}. FitData(const DataRange & range); construct passing range and default options. {}. FitData(const ROOT::Fit::DataOptions& opt, const ROOT::Fit::DataRange& range); construct passing options and data range. {}. unsigned int MaxSize(); range cannot be modified afterwards; since fit method functions use all data. define a max size to avoid allocating too large arrays. » Author: L. Moneta Wed Aug 30 11:15:23 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id: DataVector.h 28946 2009-06-11 15:39:14Z moneta $ » Last generated: 2010-09-23 19:55; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Fit__FitData.html:1543,avoid,avoid,1543,root/html528/ROOT__Fit__FitData.html,https://root.cern,https://root.cern/root/html528/ROOT__Fit__FitData.html,1,['avoid'],['avoid']
Safety,". ROOT::Fit::FitData. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Fit::FitData. class ROOT::Fit::FitData. Function Members (Methods); public:. virtual~FitData(); ROOT::Fit::FitDataFitData(); ROOT::Fit::FitDataFitData(const ROOT::Fit::DataOptions& opt); ROOT::Fit::FitDataFitData(const ROOT::Fit::DataRange& range); ROOT::Fit::FitDataFitData(const ROOT::Fit::FitData&); ROOT::Fit::FitDataFitData(const ROOT::Fit::DataOptions& opt, const ROOT::Fit::DataRange& range); static unsigned intMaxSize(); ROOT::Fit::FitData&operator=(const ROOT::Fit::FitData&); const ROOT::Fit::DataOptions&Opt() const; ROOT::Fit::DataOptions&Opt(); const ROOT::Fit::DataRange&Range() const. Data Members; private:. ROOT::Fit::DataOptionsfOptions; ROOT::Fit::DataRangefRange. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; FitData(); construct with default option and data range. {}. virtual ~FitData(); dummy virtual destructor. {}. FitData(const DataOptions & opt); construct passing options and default data range. {}. FitData(const DataRange & range); construct passing range and default options. {}. FitData(const ROOT::Fit::DataOptions& opt, const ROOT::Fit::DataRange& range); construct passing options and data range. {}. unsigned int MaxSize(); range cannot be modified afterwards; since fit method functions use all data. define a max size to avoid allocating too large arrays. » Author: L. Moneta Wed Aug 30 11:15:23 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id$ » Last generated: 2015-06-30 14:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Fit__FitData.html:1545,avoid,avoid,1545,root/html602/ROOT__Fit__FitData.html,https://root.cern,https://root.cern/root/html602/ROOT__Fit__FitData.html,1,['avoid'],['avoid']
Safety,". ROOT::Fit::FitData. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Fit::FitData. class ROOT::Fit::FitData. Function Members (Methods); public:. virtual~FitData(); ROOT::Fit::FitDataFitData(); ROOT::Fit::FitDataFitData(const ROOT::Fit::DataOptions& opt); ROOT::Fit::FitDataFitData(const ROOT::Fit::DataRange& range); ROOT::Fit::FitDataFitData(const ROOT::Fit::FitData&); ROOT::Fit::FitDataFitData(const ROOT::Fit::DataOptions& opt, const ROOT::Fit::DataRange& range); static unsigned intMaxSize(); ROOT::Fit::FitData&operator=(const ROOT::Fit::FitData&); const ROOT::Fit::DataOptions&Opt() const; ROOT::Fit::DataOptions&Opt(); const ROOT::Fit::DataRange&Range() const. Data Members; private:. ROOT::Fit::DataOptionsfOptions; ROOT::Fit::DataRangefRange. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; FitData(); construct with default option and data range. {}. virtual ~FitData(); dummy virtual destructor. {}. FitData(const DataOptions & opt); construct passing options and default data range. {}. FitData(const DataRange & range); construct passing range and default options. {}. FitData(const ROOT::Fit::DataOptions& opt, const ROOT::Fit::DataRange& range); construct passing options and data range. {}. unsigned int MaxSize(); range cannot be modified afterwards; since fit method functions use all data. define a max size to avoid allocating too large arrays. » Author: L. Moneta Wed Aug 30 11:15:23 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id$ » Last generated: 2015-09-08 16:58; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Fit__FitData.html:1545,avoid,avoid,1545,root/html534/ROOT__Fit__FitData.html,https://root.cern,https://root.cern/root/html534/ROOT__Fit__FitData.html,1,['avoid'],['avoid']
Safety,". ROOT::Fit::FitData. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Fit::FitData. class ROOT::Fit::FitData. Function Members (Methods); public:. virtual~FitData(); ROOT::Fit::FitDataFitData(); ROOT::Fit::FitDataFitData(const ROOT::Fit::DataOptions& opt); ROOT::Fit::FitDataFitData(const ROOT::Fit::DataRange& range); ROOT::Fit::FitDataFitData(const ROOT::Fit::FitData&); ROOT::Fit::FitDataFitData(const ROOT::Fit::DataOptions& opt, const ROOT::Fit::DataRange& range); static unsigned intMaxSize(); ROOT::Fit::FitData&operator=(const ROOT::Fit::FitData&); const ROOT::Fit::DataOptions&Opt() const; ROOT::Fit::DataOptions&Opt(); const ROOT::Fit::DataRange&Range() const. Data Members; private:. ROOT::Fit::DataOptionsfOptions; ROOT::Fit::DataRangefRange. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; FitData(); construct with default option and data range. {}. virtual ~FitData(); dummy virtual destructor. {}. FitData(const DataOptions & opt); construct passing options and default data range. {}. FitData(const DataRange & range); construct passing range and default options. {}. FitData(const ROOT::Fit::DataOptions& opt, const ROOT::Fit::DataRange& range); construct passing options and data range. {}. unsigned int MaxSize(); range cannot be modified afterwards; since fit method functions use all data. define a max size to avoid allocating too large arrays. » Author: L. Moneta Wed Aug 30 11:15:23 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id$ » Last generated: 2015-09-08 17:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/ROOT__Fit__FitData.html:1545,avoid,avoid,1545,root/html604/ROOT__Fit__FitData.html,https://root.cern,https://root.cern/root/html604/ROOT__Fit__FitData.html,1,['avoid'],['avoid']
Safety,". ROOT::Fit::FitData. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Fit::FitData. class ROOT::Fit::FitData. Function Members (Methods); public:. virtual~FitData(); ROOT::Fit::FitDataFitData(); ROOT::Fit::FitDataFitData(const ROOT::Fit::DataOptions& opt); ROOT::Fit::FitDataFitData(const ROOT::Fit::DataRange& range); ROOT::Fit::FitDataFitData(const ROOT::Fit::FitData&); ROOT::Fit::FitDataFitData(const ROOT::Fit::DataOptions& opt, const ROOT::Fit::DataRange& range); static unsigned intMaxSize(); ROOT::Fit::FitData&operator=(const ROOT::Fit::FitData&); const ROOT::Fit::DataOptions&Opt() const; ROOT::Fit::DataOptions&Opt(); const ROOT::Fit::DataRange&Range() const. Data Members; private:. ROOT::Fit::DataOptionsfOptions; ROOT::Fit::DataRangefRange. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; FitData(); construct with default option and data range. {}. virtual ~FitData(); dummy virtual destructor. {}. FitData(const DataOptions & opt); construct passing options and default data range. {}. FitData(const DataRange & range); construct passing range and default options. {}. FitData(const ROOT::Fit::DataOptions& opt, const ROOT::Fit::DataRange& range); construct passing options and data range. {}. unsigned int MaxSize(); range cannot be modified afterwards; since fit method functions use all data. define a max size to avoid allocating too large arrays. » Author: L. Moneta Wed Aug 30 11:15:23 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id: DataVector.h 28946 2009-06-11 15:39:14Z moneta $ » Last generated: 2011-07-04 15:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ROOT__Fit__FitData.html:1545,avoid,avoid,1545,root/html530/ROOT__Fit__FitData.html,https://root.cern,https://root.cern/root/html530/ROOT__Fit__FitData.html,1,['avoid'],['avoid']
Safety,". ROOT::Fit::FitData. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Fit::FitData. class ROOT::Fit::FitData. Function Members (Methods); public:. virtual~FitData(); ROOT::Fit::FitDataFitData(); ROOT::Fit::FitDataFitData(const ROOT::Fit::DataOptions& opt); ROOT::Fit::FitDataFitData(const ROOT::Fit::DataRange& range); ROOT::Fit::FitDataFitData(const ROOT::Fit::FitData&); ROOT::Fit::FitDataFitData(const ROOT::Fit::DataOptions& opt, const ROOT::Fit::DataRange& range); static unsigned intMaxSize(); ROOT::Fit::FitData&operator=(const ROOT::Fit::FitData&); const ROOT::Fit::DataOptions&Opt() const; ROOT::Fit::DataOptions&Opt(); const ROOT::Fit::DataRange&Range() const. Data Members; private:. ROOT::Fit::DataOptionsfOptions; ROOT::Fit::DataRangefRange. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; FitData(); construct with default option and data range. {}. virtual ~FitData(); dummy virtual destructor. {}. FitData(const DataOptions & opt); construct passing options and default data range. {}. FitData(const DataRange & range); construct passing range and default options. {}. FitData(const ROOT::Fit::DataOptions& opt, const ROOT::Fit::DataRange& range); construct passing options and data range. {}. unsigned int MaxSize(); range cannot be modified afterwards; since fit method functions use all data. define a max size to avoid allocating too large arrays. » Author: L. Moneta Wed Aug 30 11:15:23 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id: DataVector.h 28946 2009-06-11 15:39:14Z moneta $ » Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ROOT__Fit__FitData.html:1545,avoid,avoid,1545,root/html532/ROOT__Fit__FitData.html,https://root.cern,https://root.cern/root/html532/ROOT__Fit__FitData.html,1,['avoid'],['avoid']
Safety,". ROOT::Math::IBaseParam. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::IBaseParam. class ROOT::Math::IBaseParam. Documentation for the abstract class IBaseParam.; It defines the interface for dealing with the function parameters; This is used only for internal convinience, to avoid redefining the Parameter API; for the one and the multi-dim functions.; Concrete class should derive from ROOT::Math::IParamFunction and not from this class. @ingroup ParamFunc. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IBaseParam(); virtual unsigned intNPar() const; ROOT::Math::IBaseParam&operator=(const ROOT::Math::IBaseParam&); virtual stringParameterName(unsigned int i) const; virtual const double*Parameters() const; virtual voidSetParameters(const double* p). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~IBaseParam(). Virtual Destructor (no operations). {}. const double * Parameters() const. Access the parameter values. void SetParameters(const double* p). Set the parameter values; @param p vector of doubles containing the parameter values. to be defined: can user change number of params ? At the moment no. unsigned int NPar() const. Return the number of Parameters. std::string ParameterName(unsigned int i) const. Return the name of the i-th parameter (starting from zero); Overwrite if want to avoid the default name (""Par_0, Par_1, ...""). » Author: L. Moneta Tue Nov 14 14:20:07 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id: IParamFunction.h 27272 2009-01-28 09:03:03Z moneta $ » Last generated: 2009-12-07 13:43; This page has been automatically generated. For comments or suggestio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__IBaseParam.html:453,avoid,avoid,453,root/html526/ROOT__Math__IBaseParam.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__IBaseParam.html,1,['avoid'],['avoid']
Safety,". ROOT::Math::IBaseParam. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::IBaseParam. class ROOT::Math::IBaseParam. Documentation for the abstract class IBaseParam.; It defines the interface for dealing with the function parameters; This is used only for internal convinience, to avoid redefining the Parameter API; for the one and the multi-dim functions.; Concrete class should derive from ROOT::Math::IParamFunction and not from this class. @ingroup ParamFunc. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IBaseParam(); virtual unsigned intNPar() const; ROOT::Math::IBaseParam&operator=(const ROOT::Math::IBaseParam&); virtual stringParameterName(unsigned int i) const; virtual const double*Parameters() const; virtual voidSetParameters(const double* p). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~IBaseParam(). Virtual Destructor (no operations). {}. const double * Parameters() const. Access the parameter values. void SetParameters(const double* p). Set the parameter values; @param p vector of doubles containing the parameter values. to be defined: can user change number of params ? At the moment no. unsigned int NPar() const. Return the number of Parameters. std::string ParameterName(unsigned int i) const. Return the name of the i-th parameter (starting from zero); Overwrite if want to avoid the default name (""Par_0, Par_1, ...""). » Author: L. Moneta Tue Nov 14 14:20:07 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id: IParamFunction.h 32583 2010-03-12 09:57:42Z moneta $ » Last generated: 2010-09-23 19:56; This page has been automatically generated. For comments or suggestio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__IBaseParam.html:453,avoid,avoid,453,root/html528/ROOT__Math__IBaseParam.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__IBaseParam.html,1,['avoid'],['avoid']
Safety,". ROOT::Math::IBaseParam. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::IBaseParam. class ROOT::Math::IBaseParam. Documentation for the abstract class IBaseParam.; It defines the interface for dealing with the function parameters; This is used only for internal convinience, to avoid redefining the Parameter API; for the one and the multi-dim functions.; Concrete class should derive from ROOT::Math::IParamFunction and not from this class. @ingroup ParamFunc. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IBaseParam(); ROOT::Math::IBaseParamIBaseParam(); ROOT::Math::IBaseParamIBaseParam(const ROOT::Math::IBaseParam&); virtual unsigned intNPar() const; ROOT::Math::IBaseParam&operator=(const ROOT::Math::IBaseParam&); virtual stringParameterName(unsigned int i) const; virtual const double*Parameters() const; virtual voidSetParameters(const double* p). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~IBaseParam(). Virtual Destructor (no operations). {}. const double * Parameters() const. Access the parameter values. void SetParameters(const double* p). Set the parameter values; @param p vector of doubles containing the parameter values. to be defined: can user change number of params ? At the moment no. unsigned int NPar() const. Return the number of Parameters. std::string ParameterName(unsigned int i) const. Return the name of the i-th parameter (starting from zero); Overwrite if want to avoid the default name (""Par_0, Par_1, ...""). » Author: L. Moneta Tue Nov 14 14:20:07 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id$ » Last generated: 2015-06-30 14:22; This page has been ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__IBaseParam.html:455,avoid,avoid,455,root/html602/ROOT__Math__IBaseParam.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__IBaseParam.html,1,['avoid'],['avoid']
Safety,". ROOT::Math::IBaseParam. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::IBaseParam. class ROOT::Math::IBaseParam. Documentation for the abstract class IBaseParam.; It defines the interface for dealing with the function parameters; This is used only for internal convinience, to avoid redefining the Parameter API; for the one and the multi-dim functions.; Concrete class should derive from ROOT::Math::IParamFunction and not from this class. @ingroup ParamFunc. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IBaseParam(); ROOT::Math::IBaseParamIBaseParam(); ROOT::Math::IBaseParamIBaseParam(const ROOT::Math::IBaseParam&); virtual unsigned intNPar() const; ROOT::Math::IBaseParam&operator=(const ROOT::Math::IBaseParam&); virtual stringParameterName(unsigned int i) const; virtual const double*Parameters() const; virtual voidSetParameters(const double* p). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~IBaseParam(). Virtual Destructor (no operations). {}. const double * Parameters() const. Access the parameter values. void SetParameters(const double* p). Set the parameter values; @param p vector of doubles containing the parameter values. to be defined: can user change number of params ? At the moment no. unsigned int NPar() const. Return the number of Parameters. std::string ParameterName(unsigned int i) const. Return the name of the i-th parameter (starting from zero); Overwrite if want to avoid the default name (""Par_0, Par_1, ...""). » Author: L. Moneta Tue Nov 14 14:20:07 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id$ » Last generated: 2015-09-08 17:34; This page has been ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/ROOT__Math__IBaseParam.html:455,avoid,avoid,455,root/html604/ROOT__Math__IBaseParam.html,https://root.cern,https://root.cern/root/html604/ROOT__Math__IBaseParam.html,1,['avoid'],['avoid']
Safety,". ROOT::Math::IBaseParam. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::IBaseParam. class ROOT::Math::IBaseParam. Documentation for the abstract class IBaseParam.; It defines the interface for dealing with the function parameters; This is used only for internal convinience, to avoid redefining the Parameter API; for the one and the multi-dim functions.; Concrete class should derive from ROOT::Math::IParamFunction and not from this class. @ingroup ParamFunc. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IBaseParam(); virtual unsigned intNPar() const; ROOT::Math::IBaseParam&operator=(const ROOT::Math::IBaseParam&); virtual stringParameterName(unsigned int i) const; virtual const double*Parameters() const; virtual voidSetParameters(const double* p). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~IBaseParam(). Virtual Destructor (no operations). {}. const double * Parameters() const. Access the parameter values. void SetParameters(const double* p). Set the parameter values; @param p vector of doubles containing the parameter values. to be defined: can user change number of params ? At the moment no. unsigned int NPar() const. Return the number of Parameters. std::string ParameterName(unsigned int i) const. Return the name of the i-th parameter (starting from zero); Overwrite if want to avoid the default name (""Par_0, Par_1, ...""). » Author: L. Moneta Tue Nov 14 14:20:07 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id$ » Last generated: 2015-09-08 16:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__IBaseParam.html:455,avoid,avoid,455,root/html534/ROOT__Math__IBaseParam.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__IBaseParam.html,1,['avoid'],['avoid']
Safety,". ROOT::Math::IBaseParam. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::IBaseParam. class ROOT::Math::IBaseParam. Documentation for the abstract class IBaseParam.; It defines the interface for dealing with the function parameters; This is used only for internal convinience, to avoid redefining the Parameter API; for the one and the multi-dim functions.; Concrete class should derive from ROOT::Math::IParamFunction and not from this class. @ingroup ParamFunc. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IBaseParam(); virtual unsigned intNPar() const; ROOT::Math::IBaseParam&operator=(const ROOT::Math::IBaseParam&); virtual stringParameterName(unsigned int i) const; virtual const double*Parameters() const; virtual voidSetParameters(const double* p). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~IBaseParam(). Virtual Destructor (no operations). {}. const double * Parameters() const. Access the parameter values. void SetParameters(const double* p). Set the parameter values; @param p vector of doubles containing the parameter values. to be defined: can user change number of params ? At the moment no. unsigned int NPar() const. Return the number of Parameters. std::string ParameterName(unsigned int i) const. Return the name of the i-th parameter (starting from zero); Overwrite if want to avoid the default name (""Par_0, Par_1, ...""). » Author: L. Moneta Tue Nov 14 14:20:07 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id: IParamFunction.h 32583 2010-03-12 09:57:42Z moneta $ » Last generated: 2011-07-04 15:19; This page has been automatically generated. For comments or suggest",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ROOT__Math__IBaseParam.html:455,avoid,avoid,455,root/html530/ROOT__Math__IBaseParam.html,https://root.cern,https://root.cern/root/html530/ROOT__Math__IBaseParam.html,1,['avoid'],['avoid']
Safety,". ROOT::Math::IBaseParam. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::IBaseParam. class ROOT::Math::IBaseParam. Documentation for the abstract class IBaseParam.; It defines the interface for dealing with the function parameters; This is used only for internal convinience, to avoid redefining the Parameter API; for the one and the multi-dim functions.; Concrete class should derive from ROOT::Math::IParamFunction and not from this class. @ingroup ParamFunc. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IBaseParam(); virtual unsigned intNPar() const; ROOT::Math::IBaseParam&operator=(const ROOT::Math::IBaseParam&); virtual stringParameterName(unsigned int i) const; virtual const double*Parameters() const; virtual voidSetParameters(const double* p). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~IBaseParam(). Virtual Destructor (no operations). {}. const double * Parameters() const. Access the parameter values. void SetParameters(const double* p). Set the parameter values; @param p vector of doubles containing the parameter values. to be defined: can user change number of params ? At the moment no. unsigned int NPar() const. Return the number of Parameters. std::string ParameterName(unsigned int i) const. Return the name of the i-th parameter (starting from zero); Overwrite if want to avoid the default name (""Par_0, Par_1, ...""). » Author: L. Moneta Tue Nov 14 14:20:07 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id: IParamFunction.h 32583 2010-03-12 09:57:42Z moneta $ » Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggest",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ROOT__Math__IBaseParam.html:455,avoid,avoid,455,root/html532/ROOT__Math__IBaseParam.html,https://root.cern,https://root.cern/root/html532/ROOT__Math__IBaseParam.html,1,['avoid'],['avoid']
Safety,". ROOT::Math::IParametricFunctionMultiDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::IParametricFunctionMultiDim. class ROOT::Math::IParametricFunctionMultiDim: public ROOT::Math::IBaseFunctionMultiDim, public ROOT::Math::IBaseParam. Documentation for the abstract class IBaseParam.; It defines the interface for dealing with the function parameters; This is used only for internal convinience, to avoid redefining the Parameter API; for the one and the multi-dim functions.; Concrete class should derive from ROOT::Math::IParamFunction and not from this class. @ingroup ParamFunc. This class is also known as (typedefs to this class)ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction, ROOT::Fit::Chi2FCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction, ROOT::Math::IParamMultiFunction, ROOT::Fit::Fitter::IModelFunction, ROOT::Math::IParametricGradFunctionMultiDim::BaseParamFunc, ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction, ROOT::Fit::FitResult::IModelFunction, ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction, ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction, ROOT::Fit::Chi2FCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. ~IParametricFunctionMultiDim(); virtual ROOT::Math::IBaseFunctionMultiDim*ROOT::Math::IBaseFunctionMultiDim::Clone() const; virtual unsigned intROOT::Math::IBaseFunctionMultiDim::NDim() const; virtual unsigned intROOT::Math::IBaseParam::NPar() const; doubleoperator()(const double* x, const double* p) const; ROOT::Math::IParametricFunctionMultiDim&operator=(const ROOT::M",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__IParametricFunctionMultiDim.html:577,avoid,avoid,577,root/html528/ROOT__Math__IParametricFunctionMultiDim.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__IParametricFunctionMultiDim.html,1,['avoid'],['avoid']
Safety,". ROOT::Math::IParametricFunctionMultiDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::IParametricFunctionMultiDim. class ROOT::Math::IParametricFunctionMultiDim: public ROOT::Math::IBaseFunctionMultiDim, public ROOT::Math::IBaseParam. Documentation for the abstract class IBaseParam.; It defines the interface for dealing with the function parameters; This is used only for internal convinience, to avoid redefining the Parameter API; for the one and the multi-dim functions.; Concrete class should derive from ROOT::Math::IParamFunction and not from this class. @ingroup ParamFunc. This class is also known as (typedefs to this class)ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction, ROOT::Fit::Chi2FCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction, ROOT::Fit::Fitter::IModelFunction, ROOT::Fit::FitResult::IModelFunction, ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction, ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction, ROOT::Math::IParametricGradFunctionMultiDim::BaseParamFunc, ROOT::Math::IParamMultiFunction, ROOT::Fit::Chi2FCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction, ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. ~IParametricFunctionMultiDim(); virtual ROOT::Math::IBaseFunctionMultiDim*ROOT::Math::IBaseFunctionMultiDim::Clone() const; virtual unsigned intROOT::Math::IBaseFunctionMultiDim::NDim() const; virtual unsigned intROOT::Math::IBaseParam::NPar() const; doubleoperator()(const double* x, const double* p) const; ROOT::Math::IParametricFunctionMultiDim&operator=(const ROOT::M",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__IParametricFunctionMultiDim.html:577,avoid,avoid,577,root/html526/ROOT__Math__IParametricFunctionMultiDim.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__IParametricFunctionMultiDim.html,1,['avoid'],['avoid']
Safety,". ROOT::Math::IParametricFunctionMultiDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::IParametricFunctionMultiDim. class ROOT::Math::IParametricFunctionMultiDim: public ROOT::Math::IBaseFunctionMultiDim, public ROOT::Math::IBaseParam. Documentation for the abstract class IBaseParam.; It defines the interface for dealing with the function parameters; This is used only for internal convinience, to avoid redefining the Parameter API; for the one and the multi-dim functions.; Concrete class should derive from ROOT::Math::IParamFunction and not from this class. @ingroup ParamFunc. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IParametricFunctionMultiDim(); virtual ROOT::Math::IBaseFunctionMultiDim*ROOT::Math::IBaseFunctionMultiDim::Clone() const; ROOT::Math::IBaseFunctionMultiDimROOT::Math::IBaseFunctionMultiDim::IBaseFunctionMultiDim(); ROOT::Math::IBaseFunctionMultiDimROOT::Math::IBaseFunctionMultiDim::IBaseFunctionMultiDim(const ROOT::Math::IBaseFunctionMultiDim&); ROOT::Math::IBaseParamROOT::Math::IBaseParam::IBaseParam(); ROOT::Math::IBaseParamROOT::Math::IBaseParam::IBaseParam(const ROOT::Math::IBaseParam&); ROOT::Math::IParametricFunctionMultiDimIParametricFunctionMultiDim(); ROOT::Math::IParametricFunctionMultiDimIParametricFunctionMultiDim(ROOT::Math::IParametricFunctionMultiDim&&); ROOT::Math::IParametricFunctionMultiDimIParametricFunctionMultiDim(const ROOT::Math::IParametricFunctionMultiDim&); virtual unsigned intROOT::Math::IBaseFunctionMultiDim::NDim() const; virtual unsigned intROOT::Math::IBaseParam::NPar() const; doubleoperator()(const double* x, const double* p) const; ROOT::Math::IParametricFunctionMultiDim&operator=(const ROOT::Math::IParametricFun",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__IParametricFunctionMultiDim.html:579,avoid,avoid,579,root/html602/ROOT__Math__IParametricFunctionMultiDim.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__IParametricFunctionMultiDim.html,2,['avoid'],['avoid']
Safety,". ROOT::Math::IParametricFunctionMultiDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::IParametricFunctionMultiDim. class ROOT::Math::IParametricFunctionMultiDim: public ROOT::Math::IBaseFunctionMultiDim, public ROOT::Math::IBaseParam. Documentation for the abstract class IBaseParam.; It defines the interface for dealing with the function parameters; This is used only for internal convinience, to avoid redefining the Parameter API; for the one and the multi-dim functions.; Concrete class should derive from ROOT::Math::IParamFunction and not from this class. @ingroup ParamFunc. This class is also known as (typedefs to this class)ROOT::Fit::Chi2FCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction, ROOT::Math::IParamMultiFunction, ROOT::Fit::Fitter::IModelFunction, ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction, ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction, ROOT::Math::IParametricGradFunctionMultiDim::BaseParamFunc, ROOT::Fit::Chi2FCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction, ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction, ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction, ROOT::Fit::FitResult::IModelFunction. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. ~IParametricFunctionMultiDim(); virtual ROOT::Math::IBaseFunctionMultiDim*ROOT::Math::IBaseFunctionMultiDim::Clone() const; virtual unsigned intROOT::Math::IBaseFunctionMultiDim::NDim() const; virtual unsigned intROOT::Math::IBaseParam::NPar() const; doubleoperator()(const double* x, const double* p) const; ROOT::Math::IParametricFunctionMultiDim&operator=(const ROOT:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ROOT__Math__IParametricFunctionMultiDim.html:579,avoid,avoid,579,root/html530/ROOT__Math__IParametricFunctionMultiDim.html,https://root.cern,https://root.cern/root/html530/ROOT__Math__IParametricFunctionMultiDim.html,1,['avoid'],['avoid']
Safety,". ROOT::Math::IParametricFunctionMultiDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::IParametricFunctionMultiDim. class ROOT::Math::IParametricFunctionMultiDim: public ROOT::Math::IBaseFunctionMultiDim, public ROOT::Math::IBaseParam. Documentation for the abstract class IBaseParam.; It defines the interface for dealing with the function parameters; This is used only for internal convinience, to avoid redefining the Parameter API; for the one and the multi-dim functions.; Concrete class should derive from ROOT::Math::IParamFunction and not from this class. @ingroup ParamFunc. This class is also known as (typedefs to this class)ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction, ROOT::Fit::Chi2FCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction, ROOT::Math::IParamMultiFunction, ROOT::Fit::Fitter::IModelFunction, ROOT::Math::IParametricGradFunctionMultiDim::BaseParamFunc, ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction, ROOT::Fit::FitResult::IModelFunction, ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction, ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction, ROOT::Fit::Chi2FCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. ~IParametricFunctionMultiDim(); virtual ROOT::Math::IBaseFunctionMultiDim*ROOT::Math::IBaseFunctionMultiDim::Clone() const; virtual unsigned intROOT::Math::IBaseFunctionMultiDim::NDim() const; virtual unsigned intROOT::Math::IBaseParam::NPar() const; doubleoperator()(const double* x, const double* p) const; ROOT::Math::IParametricFunctionMultiDim&operator=(const ROOT:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ROOT__Math__IParametricFunctionMultiDim.html:579,avoid,avoid,579,root/html532/ROOT__Math__IParametricFunctionMultiDim.html,https://root.cern,https://root.cern/root/html532/ROOT__Math__IParametricFunctionMultiDim.html,1,['avoid'],['avoid']
Safety,". ROOT::Math::IParametricFunctionMultiDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::IParametricFunctionMultiDim. class ROOT::Math::IParametricFunctionMultiDim: public ROOT::Math::IBaseFunctionMultiDim, public ROOT::Math::IBaseParam. Documentation for the abstract class IBaseParam.; It defines the interface for dealing with the function parameters; This is used only for internal convinience, to avoid redefining the Parameter API; for the one and the multi-dim functions.; Concrete class should derive from ROOT::Math::IParamFunction and not from this class. @ingroup ParamFunc. This class is also known as (typedefs to this class)ROOT::Math::IParamMultiFunction, ROOT::Fit::Fitter::IModelFunction, ROOT::Fit::FitResult::IModelFunction, ROOT::Math::IParametricGradFunctionMultiDim::BaseParamFunc, ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction, ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction, ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction, ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction, ROOT::Fit::Chi2FCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction, ROOT::Fit::Chi2FCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. ~IParametricFunctionMultiDim(); virtual ROOT::Math::IBaseFunctionMultiDim*ROOT::Math::IBaseFunctionMultiDim::Clone() const; virtual unsigned intROOT::Math::IBaseFunctionMultiDim::NDim() const; virtual unsigned intROOT::Math::IBaseParam::NPar() const; doubleoperator()(const double* x, const double* p) const; ROOT::Math::IParametricFunctionMultiDim&operator=(const ROOT:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__IParametricFunctionMultiDim.html:579,avoid,avoid,579,root/html534/ROOT__Math__IParametricFunctionMultiDim.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__IParametricFunctionMultiDim.html,1,['avoid'],['avoid']
Safety,". ROOT::Math::IParametricFunctionOneDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::IParametricFunctionOneDim. class ROOT::Math::IParametricFunctionOneDim: public ROOT::Math::IBaseFunctionOneDim, public ROOT::Math::IBaseParam. Documentation for the abstract class IBaseParam.; It defines the interface for dealing with the function parameters; This is used only for internal convinience, to avoid redefining the Parameter API; for the one and the multi-dim functions.; Concrete class should derive from ROOT::Math::IParamFunction and not from this class. @ingroup ParamFunc. This class is also known as (typedefs to this class)ROOT::Fit::Fitter::IModel1DFunction, ROOT::Math::IParametricGradFunctionOneDim::BaseParamFunc, ROOT::Math::IParamFunction. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. ~IParametricFunctionOneDim(); virtual ROOT::Math::IBaseFunctionOneDim*ROOT::Math::IBaseFunctionOneDim::Clone() const; virtual unsigned intROOT::Math::IBaseParam::NPar() const; doubleoperator()(double x, const double* p) const; doubleoperator()(const double* x, const double* p) const; ROOT::Math::IParametricFunctionOneDim&operator=(const ROOT::Math::IParametricFunctionOneDim&); virtual stringROOT::Math::IBaseParam::ParameterName(unsigned int i) const; virtual const double*ROOT::Math::IBaseParam::Parameters() const; virtual voidROOT::Math::IBaseParam::SetParameters(const double* p). private:. virtual doubleDoEval(double x) const; virtual doubleDoEvalPar(double x, const double* p) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; double operator()(const double* x, const double* p) const. Evaluate function at a point x and for given parameters p.; T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__IParametricFunctionOneDim.html:569,avoid,avoid,569,root/html528/ROOT__Math__IParametricFunctionOneDim.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__IParametricFunctionOneDim.html,1,['avoid'],['avoid']
Safety,". ROOT::Math::IParametricFunctionOneDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::IParametricFunctionOneDim. class ROOT::Math::IParametricFunctionOneDim: public ROOT::Math::IBaseFunctionOneDim, public ROOT::Math::IBaseParam. Documentation for the abstract class IBaseParam.; It defines the interface for dealing with the function parameters; This is used only for internal convinience, to avoid redefining the Parameter API; for the one and the multi-dim functions.; Concrete class should derive from ROOT::Math::IParamFunction and not from this class. @ingroup ParamFunc. This class is also known as (typedefs to this class)ROOT::Fit::Fitter::IModel1DFunction, ROOT::Math::IParametricGradFunctionOneDim::BaseParamFunc, ROOT::Math::IParamFunction. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. ~IParametricFunctionOneDim(); virtual ROOT::Math::IBaseFunctionOneDim*ROOT::Math::IBaseFunctionOneDim::Clone() const; virtual unsigned intROOT::Math::IBaseParam::NPar() const; doubleoperator()(double x, const double* p) const; doubleoperator()(const double* x, const double* p); ROOT::Math::IParametricFunctionOneDim&operator=(const ROOT::Math::IParametricFunctionOneDim&); virtual stringROOT::Math::IBaseParam::ParameterName(unsigned int i) const; virtual const double*ROOT::Math::IBaseParam::Parameters() const; virtual voidROOT::Math::IBaseParam::SetParameters(const double* p). private:. virtual doubleDoEval(double x) const; virtual doubleDoEvalPar(double x, const double* p) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; double operator()(const double * x, const double * p ). Evaluate function at a point x and for given parameters p.; This metho",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__IParametricFunctionOneDim.html:569,avoid,avoid,569,root/html526/ROOT__Math__IParametricFunctionOneDim.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__IParametricFunctionOneDim.html,1,['avoid'],['avoid']
Safety,". ROOT::Math::IParametricFunctionOneDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::IParametricFunctionOneDim. class ROOT::Math::IParametricFunctionOneDim: public ROOT::Math::IBaseFunctionOneDim, public ROOT::Math::IBaseParam. Documentation for the abstract class IBaseParam.; It defines the interface for dealing with the function parameters; This is used only for internal convinience, to avoid redefining the Parameter API; for the one and the multi-dim functions.; Concrete class should derive from ROOT::Math::IParamFunction and not from this class. @ingroup ParamFunc. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IParametricFunctionOneDim(); virtual ROOT::Math::IBaseFunctionOneDim*ROOT::Math::IBaseFunctionOneDim::Clone() const; ROOT::Math::IBaseFunctionOneDimROOT::Math::IBaseFunctionOneDim::IBaseFunctionOneDim(); ROOT::Math::IBaseFunctionOneDimROOT::Math::IBaseFunctionOneDim::IBaseFunctionOneDim(const ROOT::Math::IBaseFunctionOneDim&); ROOT::Math::IBaseParamROOT::Math::IBaseParam::IBaseParam(); ROOT::Math::IBaseParamROOT::Math::IBaseParam::IBaseParam(const ROOT::Math::IBaseParam&); ROOT::Math::IParametricFunctionOneDimIParametricFunctionOneDim(); ROOT::Math::IParametricFunctionOneDimIParametricFunctionOneDim(ROOT::Math::IParametricFunctionOneDim&&); ROOT::Math::IParametricFunctionOneDimIParametricFunctionOneDim(const ROOT::Math::IParametricFunctionOneDim&); virtual unsigned intROOT::Math::IBaseParam::NPar() const; doubleoperator()(double x, const double* p) const; doubleoperator()(const double* x, const double* p) const; ROOT::Math::IParametricFunctionOneDim&operator=(const ROOT::Math::IParametricFunctionOneDim&); ROOT::Math::IParametricFunctionOneDim&operator=(R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__IParametricFunctionOneDim.html:571,avoid,avoid,571,root/html602/ROOT__Math__IParametricFunctionOneDim.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__IParametricFunctionOneDim.html,2,['avoid'],['avoid']
Safety,". ROOT::Math::IParametricFunctionOneDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::IParametricFunctionOneDim. class ROOT::Math::IParametricFunctionOneDim: public ROOT::Math::IBaseFunctionOneDim, public ROOT::Math::IBaseParam. Documentation for the abstract class IBaseParam.; It defines the interface for dealing with the function parameters; This is used only for internal convinience, to avoid redefining the Parameter API; for the one and the multi-dim functions.; Concrete class should derive from ROOT::Math::IParamFunction and not from this class. @ingroup ParamFunc. This class is also known as (typedefs to this class)ROOT::Fit::Fitter::IModel1DFunction, ROOT::Math::IParametricGradFunctionOneDim::BaseParamFunc, ROOT::Math::IParamFunction. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. ~IParametricFunctionOneDim(); virtual ROOT::Math::IBaseFunctionOneDim*ROOT::Math::IBaseFunctionOneDim::Clone() const; virtual unsigned intROOT::Math::IBaseParam::NPar() const; doubleoperator()(double x, const double* p) const; doubleoperator()(const double* x, const double* p) const; ROOT::Math::IParametricFunctionOneDim&operator=(const ROOT::Math::IParametricFunctionOneDim&); virtual stringROOT::Math::IBaseParam::ParameterName(unsigned int i) const; virtual const double*ROOT::Math::IBaseParam::Parameters() const; virtual voidROOT::Math::IBaseParam::SetParameters(const double* p). private:. virtual doubleDoEval(double x) const; virtual doubleDoEvalPar(double x, const double* p) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; double operator()(const double* x, const double* p) const. Evaluate function at a point x and for given parameters p.;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ROOT__Math__IParametricFunctionOneDim.html:571,avoid,avoid,571,root/html530/ROOT__Math__IParametricFunctionOneDim.html,https://root.cern,https://root.cern/root/html530/ROOT__Math__IParametricFunctionOneDim.html,2,['avoid'],['avoid']
Safety,". ROOT::Math::IParametricFunctionOneDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::IParametricFunctionOneDim. class ROOT::Math::IParametricFunctionOneDim: public ROOT::Math::IBaseFunctionOneDim, public ROOT::Math::IBaseParam. Documentation for the abstract class IBaseParam.; It defines the interface for dealing with the function parameters; This is used only for internal convinience, to avoid redefining the Parameter API; for the one and the multi-dim functions.; Concrete class should derive from ROOT::Math::IParamFunction and not from this class. @ingroup ParamFunc. This class is also known as (typedefs to this class)ROOT::Math::IParamFunction, ROOT::Math::IParametricGradFunctionOneDim::BaseParamFunc, ROOT::Fit::Fitter::IModel1DFunction. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. ~IParametricFunctionOneDim(); virtual ROOT::Math::IBaseFunctionOneDim*ROOT::Math::IBaseFunctionOneDim::Clone() const; virtual unsigned intROOT::Math::IBaseParam::NPar() const; doubleoperator()(double x, const double* p) const; doubleoperator()(const double* x, const double* p) const; ROOT::Math::IParametricFunctionOneDim&operator=(const ROOT::Math::IParametricFunctionOneDim&); virtual stringROOT::Math::IBaseParam::ParameterName(unsigned int i) const; virtual const double*ROOT::Math::IBaseParam::Parameters() const; virtual voidROOT::Math::IBaseParam::SetParameters(const double* p). private:. virtual doubleDoEval(double x) const; virtual doubleDoEvalPar(double x, const double* p) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; double operator()(const double* x, const double* p) const. Evaluate function at a point x and for given parameters p.;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__IParametricFunctionOneDim.html:571,avoid,avoid,571,root/html534/ROOT__Math__IParametricFunctionOneDim.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__IParametricFunctionOneDim.html,1,['avoid'],['avoid']
Safety,". ROOT::Math::IParametricGradFunctionMultiDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::IParametricGradFunctionMultiDim. class ROOT::Math::IParametricGradFunctionMultiDim: public ROOT::Math::IParametricFunctionMultiDim. Documentation for the abstract class IBaseParam.; It defines the interface for dealing with the function parameters; This is used only for internal convinience, to avoid redefining the Parameter API; for the one and the multi-dim functions.; Concrete class should derive from ROOT::Math::IParamFunction and not from this class. @ingroup ParamFunc. This class is also known as (typedefs to this class)ROOT::Math::IParamMultiGradFunction, ROOT::Math::WrappedMultiTF1::BaseParamFunc, ROOT::Fit::Fitter::IGradModelFunction. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IParametricGradFunctionMultiDim(); virtual ROOT::Math::IBaseFunctionMultiDim*ROOT::Math::IBaseFunctionMultiDim::Clone() const; virtual unsigned intROOT::Math::IBaseFunctionMultiDim::NDim() const; virtual unsigned intROOT::Math::IBaseParam::NPar() const; doubleROOT::Math::IParametricFunctionMultiDim::operator()(const double* x, const double* p) const; ROOT::Math::IParametricGradFunctionMultiDim&operator=(const ROOT::Math::IParametricGradFunctionMultiDim&); doubleParameterDerivative(const double* x, unsigned int ipar = 0) const; doubleParameterDerivative(const double* x, const double* p, unsigned int ipar = 0) const; voidParameterGradient(const double* x, double* grad) const; virtual voidParameterGradient(const double* x, const double* p, double* grad) const; virtual stringROOT::Math::IBaseParam::ParameterName(unsigned int i) const; virtual const double*ROOT::Math::IBaseParam::Parameters() cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__IParametricGradFunctionMultiDim.html:564,avoid,avoid,564,root/html526/ROOT__Math__IParametricGradFunctionMultiDim.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__IParametricGradFunctionMultiDim.html,2,['avoid'],['avoid']
Safety,". ROOT::Math::IParametricGradFunctionMultiDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::IParametricGradFunctionMultiDim. class ROOT::Math::IParametricGradFunctionMultiDim: public ROOT::Math::IParametricFunctionMultiDim. Documentation for the abstract class IBaseParam.; It defines the interface for dealing with the function parameters; This is used only for internal convinience, to avoid redefining the Parameter API; for the one and the multi-dim functions.; Concrete class should derive from ROOT::Math::IParamFunction and not from this class. @ingroup ParamFunc. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IParametricGradFunctionMultiDim(); virtual ROOT::Math::IBaseFunctionMultiDim*ROOT::Math::IBaseFunctionMultiDim::Clone() const; ROOT::Math::IBaseFunctionMultiDimROOT::Math::IBaseFunctionMultiDim::IBaseFunctionMultiDim(); ROOT::Math::IBaseFunctionMultiDimROOT::Math::IBaseFunctionMultiDim::IBaseFunctionMultiDim(const ROOT::Math::IBaseFunctionMultiDim&); ROOT::Math::IBaseParamROOT::Math::IBaseParam::IBaseParam(); ROOT::Math::IBaseParamROOT::Math::IBaseParam::IBaseParam(const ROOT::Math::IBaseParam&); ROOT::Math::IParametricFunctionMultiDimROOT::Math::IParametricFunctionMultiDim::IParametricFunctionMultiDim(); ROOT::Math::IParametricFunctionMultiDimROOT::Math::IParametricFunctionMultiDim::IParametricFunctionMultiDim(ROOT::Math::IParametricFunctionMultiDim&&); ROOT::Math::IParametricFunctionMultiDimROOT::Math::IParametricFunctionMultiDim::IParametricFunctionMultiDim(const ROOT::Math::IParametricFunctionMultiDim&); ROOT::Math::IParametricGradFunctionMultiDimIParametricGradFunctionMultiDim(); ROOT::Math::IParametricGradFunctionMultiDimIParametricGradFunctionMultiDim(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__IParametricGradFunctionMultiDim.html:566,avoid,avoid,566,root/html602/ROOT__Math__IParametricGradFunctionMultiDim.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__IParametricGradFunctionMultiDim.html,2,['avoid'],['avoid']
Safety,". ROOT::Math::IParametricGradFunctionMultiDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::IParametricGradFunctionMultiDim. class ROOT::Math::IParametricGradFunctionMultiDim: public ROOT::Math::IParametricFunctionMultiDim. Documentation for the abstract class IBaseParam.; It defines the interface for dealing with the function parameters; This is used only for internal convinience, to avoid redefining the Parameter API; for the one and the multi-dim functions.; Concrete class should derive from ROOT::Math::IParamFunction and not from this class. @ingroup ParamFunc. This class is also known as (typedefs to this class)ROOT::Fit::Fitter::IGradModelFunction, ROOT::Math::IParamMultiGradFunction, ROOT::Math::WrappedMultiTF1::BaseParamFunc. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IParametricGradFunctionMultiDim(); virtual ROOT::Math::IBaseFunctionMultiDim*ROOT::Math::IBaseFunctionMultiDim::Clone() const; virtual unsigned intROOT::Math::IBaseFunctionMultiDim::NDim() const; virtual unsigned intROOT::Math::IBaseParam::NPar() const; doubleROOT::Math::IParametricFunctionMultiDim::operator()(const double* x, const double* p) const; ROOT::Math::IParametricGradFunctionMultiDim&operator=(const ROOT::Math::IParametricGradFunctionMultiDim&); doubleParameterDerivative(const double* x, unsigned int ipar = 0) const; doubleParameterDerivative(const double* x, const double* p, unsigned int ipar = 0) const; voidParameterGradient(const double* x, double* grad) const; virtual voidParameterGradient(const double* x, const double* p, double* grad) const; virtual stringROOT::Math::IBaseParam::ParameterName(unsigned int i) const; virtual const double*ROOT::Math::IBaseParam::Parameters() co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ROOT__Math__IParametricGradFunctionMultiDim.html:566,avoid,avoid,566,root/html530/ROOT__Math__IParametricGradFunctionMultiDim.html,https://root.cern,https://root.cern/root/html530/ROOT__Math__IParametricGradFunctionMultiDim.html,1,['avoid'],['avoid']
Safety,". ROOT::Math::IParametricGradFunctionMultiDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::IParametricGradFunctionMultiDim. class ROOT::Math::IParametricGradFunctionMultiDim: public ROOT::Math::IParametricFunctionMultiDim. Documentation for the abstract class IBaseParam.; It defines the interface for dealing with the function parameters; This is used only for internal convinience, to avoid redefining the Parameter API; for the one and the multi-dim functions.; Concrete class should derive from ROOT::Math::IParamFunction and not from this class. @ingroup ParamFunc. This class is also known as (typedefs to this class)ROOT::Math::IParamMultiGradFunction, ROOT::Fit::Fitter::IGradModelFunction, ROOT::Math::WrappedMultiTF1::BaseParamFunc. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IParametricGradFunctionMultiDim(); virtual ROOT::Math::IBaseFunctionMultiDim*ROOT::Math::IBaseFunctionMultiDim::Clone() const; virtual unsigned intROOT::Math::IBaseFunctionMultiDim::NDim() const; virtual unsigned intROOT::Math::IBaseParam::NPar() const; doubleROOT::Math::IParametricFunctionMultiDim::operator()(const double* x, const double* p) const; ROOT::Math::IParametricGradFunctionMultiDim&operator=(const ROOT::Math::IParametricGradFunctionMultiDim&); doubleParameterDerivative(const double* x, unsigned int ipar = 0) const; doubleParameterDerivative(const double* x, const double* p, unsigned int ipar = 0) const; voidParameterGradient(const double* x, double* grad) const; virtual voidParameterGradient(const double* x, const double* p, double* grad) const; virtual stringROOT::Math::IBaseParam::ParameterName(unsigned int i) const; virtual const double*ROOT::Math::IBaseParam::Parameters() co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__IParametricGradFunctionMultiDim.html:566,avoid,avoid,566,root/html534/ROOT__Math__IParametricGradFunctionMultiDim.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__IParametricGradFunctionMultiDim.html,1,['avoid'],['avoid']
Safety,". ROOT::Math::IParametricGradFunctionMultiDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::IParametricGradFunctionMultiDim. class ROOT::Math::IParametricGradFunctionMultiDim: public ROOT::Math::IParametricFunctionMultiDim. Documentation for the abstract class IBaseParam.; It defines the interface for dealing with the function parameters; This is used only for internal convinience, to avoid redefining the Parameter API; for the one and the multi-dim functions.; Concrete class should derive from ROOT::Math::IParamFunction and not from this class. @ingroup ParamFunc. This class is also known as (typedefs to this class)ROOT::Math::IParamMultiGradFunction, ROOT::Math::WrappedMultiTF1::BaseParamFunc, ROOT::Fit::Fitter::IGradModelFunction. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IParametricGradFunctionMultiDim(); virtual ROOT::Math::IBaseFunctionMultiDim*ROOT::Math::IBaseFunctionMultiDim::Clone() const; virtual unsigned intROOT::Math::IBaseFunctionMultiDim::NDim() const; virtual unsigned intROOT::Math::IBaseParam::NPar() const; doubleROOT::Math::IParametricFunctionMultiDim::operator()(const double* x, const double* p) const; ROOT::Math::IParametricGradFunctionMultiDim&operator=(const ROOT::Math::IParametricGradFunctionMultiDim&); doubleParameterDerivative(const double* x, unsigned int ipar = 0) const; doubleParameterDerivative(const double* x, const double* p, unsigned int ipar = 0) const; voidParameterGradient(const double* x, double* grad) const; virtual voidParameterGradient(const double* x, const double* p, double* grad) const; virtual stringROOT::Math::IBaseParam::ParameterName(unsigned int i) const; virtual const double*ROOT::Math::IBaseParam::Parameters() co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ROOT__Math__IParametricGradFunctionMultiDim.html:566,avoid,avoid,566,root/html532/ROOT__Math__IParametricGradFunctionMultiDim.html,https://root.cern,https://root.cern/root/html532/ROOT__Math__IParametricGradFunctionMultiDim.html,1,['avoid'],['avoid']
Safety,". ROOT::Math::IParametricGradFunctionOneDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::IParametricGradFunctionOneDim. class ROOT::Math::IParametricGradFunctionOneDim: public ROOT::Math::IParametricFunctionOneDim. Documentation for the abstract class IBaseParam.; It defines the interface for dealing with the function parameters; This is used only for internal convinience, to avoid redefining the Parameter API; for the one and the multi-dim functions.; Concrete class should derive from ROOT::Math::IParamFunction and not from this class. @ingroup ParamFunc. This class is also known as (typedefs to this class)ROOT::Math::ParamFunction<ROOT::Math::IParametricGradFunctionOneDim>::BaseParFunc, ROOT::Fit::Fitter::IGradModel1DFunction, ROOT::Math::WrappedTF1::BaseGradFunc, ROOT::Math::IParamGradFunction. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IParametricGradFunctionOneDim(); virtual ROOT::Math::IBaseFunctionOneDim*ROOT::Math::IBaseFunctionOneDim::Clone() const; virtual unsigned intROOT::Math::IBaseParam::NPar() const; doubleROOT::Math::IParametricFunctionOneDim::operator()(double x, const double* p) const; doubleROOT::Math::IParametricFunctionOneDim::operator()(const double* x, const double* p) const; ROOT::Math::IParametricGradFunctionOneDim&operator=(const ROOT::Math::IParametricGradFunctionOneDim&); doubleParameterDerivative(double x, unsigned int ipar = 0) const; doubleParameterDerivative(const double* x, unsigned int ipar = 0) const; doubleParameterDerivative(double x, const double* p, unsigned int ipar = 0) const; doubleParameterDerivative(const double* x, const double* p, unsigned int ipar = 0) const; voidParameterGradient(double x, double* grad) const; voidP",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__IParametricGradFunctionOneDim.html:556,avoid,avoid,556,root/html528/ROOT__Math__IParametricGradFunctionOneDim.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__IParametricGradFunctionOneDim.html,1,['avoid'],['avoid']
Safety,". ROOT::Math::IParametricGradFunctionOneDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::IParametricGradFunctionOneDim. class ROOT::Math::IParametricGradFunctionOneDim: public ROOT::Math::IParametricFunctionOneDim. Documentation for the abstract class IBaseParam.; It defines the interface for dealing with the function parameters; This is used only for internal convinience, to avoid redefining the Parameter API; for the one and the multi-dim functions.; Concrete class should derive from ROOT::Math::IParamFunction and not from this class. @ingroup ParamFunc. This class is also known as (typedefs to this class)ROOT::Math::WrappedTF1::BaseGradFunc, ROOT::Math::ParamFunction<ROOT::Math::IParametricGradFunctionOneDim>::BaseParFunc, ROOT::Math::IParamGradFunction, ROOT::Fit::Fitter::IGradModel1DFunction. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IParametricGradFunctionOneDim(); virtual ROOT::Math::IBaseFunctionOneDim*ROOT::Math::IBaseFunctionOneDim::Clone() const; virtual unsigned intROOT::Math::IBaseParam::NPar() const; doubleROOT::Math::IParametricFunctionOneDim::operator()(double x, const double* p) const; doubleROOT::Math::IParametricFunctionOneDim::operator()(const double* x, const double* p); ROOT::Math::IParametricGradFunctionOneDim&operator=(const ROOT::Math::IParametricGradFunctionOneDim&); doubleParameterDerivative(double x, unsigned int ipar = 0) const; doubleParameterDerivative(const double* x, unsigned int ipar = 0) const; doubleParameterDerivative(double x, const double* p, unsigned int ipar = 0) const; doubleParameterDerivative(const double* x, const double* p, unsigned int ipar = 0) const; voidParameterGradient(double x, double* grad) const; voidParamet",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__IParametricGradFunctionOneDim.html:556,avoid,avoid,556,root/html526/ROOT__Math__IParametricGradFunctionOneDim.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__IParametricGradFunctionOneDim.html,1,['avoid'],['avoid']
Safety,". ROOT::Math::IParametricGradFunctionOneDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::IParametricGradFunctionOneDim. class ROOT::Math::IParametricGradFunctionOneDim: public ROOT::Math::IParametricFunctionOneDim. Documentation for the abstract class IBaseParam.; It defines the interface for dealing with the function parameters; This is used only for internal convinience, to avoid redefining the Parameter API; for the one and the multi-dim functions.; Concrete class should derive from ROOT::Math::IParamFunction and not from this class. @ingroup ParamFunc. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IParametricGradFunctionOneDim(); virtual ROOT::Math::IBaseFunctionOneDim*ROOT::Math::IBaseFunctionOneDim::Clone() const; ROOT::Math::IBaseFunctionOneDimROOT::Math::IBaseFunctionOneDim::IBaseFunctionOneDim(); ROOT::Math::IBaseFunctionOneDimROOT::Math::IBaseFunctionOneDim::IBaseFunctionOneDim(const ROOT::Math::IBaseFunctionOneDim&); ROOT::Math::IBaseParamROOT::Math::IBaseParam::IBaseParam(); ROOT::Math::IBaseParamROOT::Math::IBaseParam::IBaseParam(const ROOT::Math::IBaseParam&); ROOT::Math::IParametricFunctionOneDimROOT::Math::IParametricFunctionOneDim::IParametricFunctionOneDim(); ROOT::Math::IParametricFunctionOneDimROOT::Math::IParametricFunctionOneDim::IParametricFunctionOneDim(ROOT::Math::IParametricFunctionOneDim&&); ROOT::Math::IParametricFunctionOneDimROOT::Math::IParametricFunctionOneDim::IParametricFunctionOneDim(const ROOT::Math::IParametricFunctionOneDim&); ROOT::Math::IParametricGradFunctionOneDimIParametricGradFunctionOneDim(); ROOT::Math::IParametricGradFunctionOneDimIParametricGradFunctionOneDim(const ROOT::Math::IParametricGradFunctionOneDim&); virtual",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__IParametricGradFunctionOneDim.html:558,avoid,avoid,558,root/html602/ROOT__Math__IParametricGradFunctionOneDim.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__IParametricGradFunctionOneDim.html,2,['avoid'],['avoid']
Safety,". ROOT::Math::IParametricGradFunctionOneDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::IParametricGradFunctionOneDim. class ROOT::Math::IParametricGradFunctionOneDim: public ROOT::Math::IParametricFunctionOneDim. Documentation for the abstract class IBaseParam.; It defines the interface for dealing with the function parameters; This is used only for internal convinience, to avoid redefining the Parameter API; for the one and the multi-dim functions.; Concrete class should derive from ROOT::Math::IParamFunction and not from this class. @ingroup ParamFunc. This class is also known as (typedefs to this class)ROOT::Math::ParamFunction<ROOT::Math::IParametricGradFunctionOneDim>::BaseParFunc, ROOT::Fit::Fitter::IGradModel1DFunction, ROOT::Math::WrappedTF1::BaseGradFunc, ROOT::Math::IParamGradFunction. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IParametricGradFunctionOneDim(); virtual ROOT::Math::IBaseFunctionOneDim*ROOT::Math::IBaseFunctionOneDim::Clone() const; virtual unsigned intROOT::Math::IBaseParam::NPar() const; doubleROOT::Math::IParametricFunctionOneDim::operator()(double x, const double* p) const; doubleROOT::Math::IParametricFunctionOneDim::operator()(const double* x, const double* p) const; ROOT::Math::IParametricGradFunctionOneDim&operator=(const ROOT::Math::IParametricGradFunctionOneDim&); doubleParameterDerivative(double x, unsigned int ipar = 0) const; doubleParameterDerivative(const double* x, unsigned int ipar = 0) const; doubleParameterDerivative(double x, const double* p, unsigned int ipar = 0) const; doubleParameterDerivative(const double* x, const double* p, unsigned int ipar = 0) const; voidParameterGradient(double x, double* grad) const; voi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ROOT__Math__IParametricGradFunctionOneDim.html:558,avoid,avoid,558,root/html532/ROOT__Math__IParametricGradFunctionOneDim.html,https://root.cern,https://root.cern/root/html532/ROOT__Math__IParametricGradFunctionOneDim.html,1,['avoid'],['avoid']
Safety,". ROOT::Math::IParametricGradFunctionOneDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::IParametricGradFunctionOneDim. class ROOT::Math::IParametricGradFunctionOneDim: public ROOT::Math::IParametricFunctionOneDim. Documentation for the abstract class IBaseParam.; It defines the interface for dealing with the function parameters; This is used only for internal convinience, to avoid redefining the Parameter API; for the one and the multi-dim functions.; Concrete class should derive from ROOT::Math::IParamFunction and not from this class. @ingroup ParamFunc. This class is also known as (typedefs to this class)ROOT::Math::ParamFunction<ROOT::Math::IParametricGradFunctionOneDim>::BaseParFunc, ROOT::Math::IParamGradFunction, ROOT::Math::WrappedTF1::BaseGradFunc, ROOT::Fit::Fitter::IGradModel1DFunction. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IParametricGradFunctionOneDim(); virtual ROOT::Math::IBaseFunctionOneDim*ROOT::Math::IBaseFunctionOneDim::Clone() const; virtual unsigned intROOT::Math::IBaseParam::NPar() const; doubleROOT::Math::IParametricFunctionOneDim::operator()(double x, const double* p) const; doubleROOT::Math::IParametricFunctionOneDim::operator()(const double* x, const double* p) const; ROOT::Math::IParametricGradFunctionOneDim&operator=(const ROOT::Math::IParametricGradFunctionOneDim&); doubleParameterDerivative(double x, unsigned int ipar = 0) const; doubleParameterDerivative(const double* x, unsigned int ipar = 0) const; doubleParameterDerivative(double x, const double* p, unsigned int ipar = 0) const; doubleParameterDerivative(const double* x, const double* p, unsigned int ipar = 0) const; voidParameterGradient(double x, double* grad) const; voi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ROOT__Math__IParametricGradFunctionOneDim.html:558,avoid,avoid,558,root/html530/ROOT__Math__IParametricGradFunctionOneDim.html,https://root.cern,https://root.cern/root/html530/ROOT__Math__IParametricGradFunctionOneDim.html,1,['avoid'],['avoid']
Safety,". ROOT::Math::IParametricGradFunctionOneDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::IParametricGradFunctionOneDim. class ROOT::Math::IParametricGradFunctionOneDim: public ROOT::Math::IParametricFunctionOneDim. Documentation for the abstract class IBaseParam.; It defines the interface for dealing with the function parameters; This is used only for internal convinience, to avoid redefining the Parameter API; for the one and the multi-dim functions.; Concrete class should derive from ROOT::Math::IParamFunction and not from this class. @ingroup ParamFunc. This class is also known as (typedefs to this class)ROOT::Math::WrappedTF1::BaseGradFunc, ROOT::Math::IParamGradFunction, ROOT::Fit::Fitter::IGradModel1DFunction, ROOT::Math::ParamFunction<ROOT::Math::IParametricGradFunctionOneDim>::BaseParFunc. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IParametricGradFunctionOneDim(); virtual ROOT::Math::IBaseFunctionOneDim*ROOT::Math::IBaseFunctionOneDim::Clone() const; virtual unsigned intROOT::Math::IBaseParam::NPar() const; doubleROOT::Math::IParametricFunctionOneDim::operator()(double x, const double* p) const; doubleROOT::Math::IParametricFunctionOneDim::operator()(const double* x, const double* p) const; ROOT::Math::IParametricGradFunctionOneDim&operator=(const ROOT::Math::IParametricGradFunctionOneDim&); doubleParameterDerivative(double x, unsigned int ipar = 0) const; doubleParameterDerivative(const double* x, unsigned int ipar = 0) const; doubleParameterDerivative(double x, const double* p, unsigned int ipar = 0) const; doubleParameterDerivative(const double* x, const double* p, unsigned int ipar = 0) const; voidParameterGradient(double x, double* grad) const; voi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__IParametricGradFunctionOneDim.html:558,avoid,avoid,558,root/html534/ROOT__Math__IParametricGradFunctionOneDim.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__IParametricGradFunctionOneDim.html,1,['avoid'],['avoid']
Safety,". ROOT::Math::PxPyPzM4D<Double32_t>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » GENVECTOR; » ROOT::Math::PxPyPzM4D<Double32_t>. class ROOT::Math::PxPyPzM4D<Double32_t>. Class describing a 4D coordinate system; or momentum-energy vectors stored as (Px, Py, Pz, M).; This system is useful to describe ultra-relativistic particles; (like electrons at LHC) to avoid numerical errors evaluating the mass; when E >>> m; The metric used is (-,-,-,+); Spacelike particles (M2 < 0) are described with negative mass values,; but in this case m2 must alwasy be less than P2 to preserve a positive value of E2. @ingroup GenVector. This class is also known as (typedefs to this class)ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<Double32_t> >::CoordinateType. Function Members (Methods); public:. ~PxPyPzM4D<Double32_t>(); ROOT::Math::PxPyPzM4D<Double32_t>::ScalarE() const; ROOT::Math::PxPyPzM4D<Double32_t>::ScalarE2() const; ROOT::Math::PxPyPzM4D<Double32_t>::ScalarEt() const; ROOT::Math::PxPyPzM4D<Double32_t>::ScalarEt2() const; ROOT::Math::PxPyPzM4D<Double32_t>::ScalarEta() const; voidGetCoordinates(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar* dest) const; voidGetCoordinates(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar& px, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar& py, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar& pz, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar& m) const; ROOT::Math::PxPyPzM4D<Double32_t>::ScalarM() const; ROOT::Math::PxPyPzM4D<Double32_t>::ScalarM2() const; ROOT::Math::PxPyPzM4D<Double32_t>::ScalarMag() const; ROOT::Math::PxPyPzM4D<Double32_t>::ScalarMag2() const; ROOT::Math::PxPyPzM4D<Double32_t>::ScalarMt() const; ROOT::Math::PxPyPzM4D<Double32_t>::ScalarMt2() const; voidNegate(); booloperator!=(const ROOT::Math::PxPyPzM4D<Double32_t>& rhs) const; ROOT::Math::PxPyPzM4D<Double32_t>&operator=(const ROOT::Math::PxPyPzM4D<Doubl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__PxPyPzM4D_Double32_t_.html:510,avoid,avoid,510,root/html526/ROOT__Math__PxPyPzM4D_Double32_t_.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__PxPyPzM4D_Double32_t_.html,2,['avoid'],['avoid']
Safety,". ROOT::Math::PxPyPzM4D<Double32_t>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » GENVECTOR; » ROOT::Math::PxPyPzM4D<Double32_t>. class ROOT::Math::PxPyPzM4D<Double32_t>. Class describing a 4D coordinate system; or momentum-energy vectors stored as (Px, Py, Pz, M).; This system is useful to describe ultra-relativistic particles; (like electrons at LHC) to avoid numerical errors evaluating the mass; when E >>> m; The metric used is (-,-,-,+); Spacelike particles (M2 < 0) are described with negative mass values,; but in this case m2 must alwasy be less than P2 to preserve a positive value of E2. @ingroup GenVector. This class is also known as (typedefs to this class)ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<Double32_t> >::CoordinateType. Function Members (Methods); public:. ~PxPyPzM4D<Double32_t>(); ROOT::Math::PxPyPzM4D<Double32_t>::ScalarE() const; ROOT::Math::PxPyPzM4D<Double32_t>::ScalarE2() const; ROOT::Math::PxPyPzM4D<Double32_t>::ScalarEt() const; ROOT::Math::PxPyPzM4D<Double32_t>::ScalarEt2() const; ROOT::Math::PxPyPzM4D<Double32_t>::ScalarEta() const; voidGetCoordinates(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar* dest) const; voidGetCoordinates(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar& px, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar& py, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar& pz, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar& m) const; ROOT::Math::PxPyPzM4D<Double32_t>::ScalarM() const; ROOT::Math::PxPyPzM4D<Double32_t>::ScalarM2() const; ROOT::Math::PxPyPzM4D<Double32_t>::ScalarMag() const; ROOT::Math::PxPyPzM4D<Double32_t>::ScalarMag2() const; ROOT::Math::PxPyPzM4D<Double32_t>::ScalarMt() const; ROOT::Math::PxPyPzM4D<Double32_t>::ScalarMt2() const; voidNegate(); booloperator!=(const ROOT::Math::PxPyPzM4D<Double32_t>& rhs) const; ROOT::Math::PxPyPzM4D<Double32_t>&operator=(const ROOT::Math::PxPyPzM4D<Dou",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ROOT__Math__PxPyPzM4D_Double32_t_.html:512,avoid,avoid,512,root/html530/ROOT__Math__PxPyPzM4D_Double32_t_.html,https://root.cern,https://root.cern/root/html530/ROOT__Math__PxPyPzM4D_Double32_t_.html,3,['avoid'],['avoid']
Safety,". ROOT::Math::PxPyPzM4D<double>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » GENVECTOR; » ROOT::Math::PxPyPzM4D<double>. class ROOT::Math::PxPyPzM4D<double>. Class describing a 4D coordinate system; or momentum-energy vectors stored as (Px, Py, Pz, M).; This system is useful to describe ultra-relativistic particles; (like electrons at LHC) to avoid numerical errors evaluating the mass; when E >>> m; The metric used is (-,-,-,+); Spacelike particles (M2 < 0) are described with negative mass values,; but in this case m2 must alwasy be less than P2 to preserve a positive value of E2. @ingroup GenVector. This class is also known as (typedefs to this class)ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::CoordinateType. Function Members (Methods); public:. ~PxPyPzM4D<double>(); ROOT::Math::PxPyPzM4D<double>::ScalarE() const; ROOT::Math::PxPyPzM4D<double>::ScalarE2() const; ROOT::Math::PxPyPzM4D<double>::ScalarEt() const; ROOT::Math::PxPyPzM4D<double>::ScalarEt2() const; ROOT::Math::PxPyPzM4D<double>::ScalarEta() const; voidGetCoordinates(ROOT::Math::PxPyPzM4D<double>::Scalar* dest) const; voidGetCoordinates(ROOT::Math::PxPyPzM4D<double>::Scalar& px, ROOT::Math::PxPyPzM4D<double>::Scalar& py, ROOT::Math::PxPyPzM4D<double>::Scalar& pz, ROOT::Math::PxPyPzM4D<double>::Scalar& m) const; ROOT::Math::PxPyPzM4D<double>::ScalarM() const; ROOT::Math::PxPyPzM4D<double>::ScalarM2() const; ROOT::Math::PxPyPzM4D<double>::ScalarMag() const; ROOT::Math::PxPyPzM4D<double>::ScalarMag2() const; ROOT::Math::PxPyPzM4D<double>::ScalarMt() const; ROOT::Math::PxPyPzM4D<double>::ScalarMt2() const; voidNegate(); booloperator!=(const ROOT::Math::PxPyPzM4D<double>& rhs) const; ROOT::Math::PxPyPzM4D<double>&operator=(const ROOT::Math::PxPyPzM4D<double>& v); booloperator==(const ROOT::Math::PxPyPzM4D<double>& rhs) const; ROOT::Math::PxPyPzM4",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__PxPyPzM4D_double_.html:498,avoid,avoid,498,root/html526/ROOT__Math__PxPyPzM4D_double_.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__PxPyPzM4D_double_.html,2,['avoid'],['avoid']
Safety,". ROOT::Math::PxPyPzM4D<double>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » GENVECTOR; » ROOT::Math::PxPyPzM4D<double>. class ROOT::Math::PxPyPzM4D<double>. Class describing a 4D coordinate system; or momentum-energy vectors stored as (Px, Py, Pz, M).; This system is useful to describe ultra-relativistic particles; (like electrons at LHC) to avoid numerical errors evaluating the mass; when E >>> m; The metric used is (-,-,-,+); Spacelike particles (M2 < 0) are described with negative mass values,; but in this case m2 must alwasy be less than P2 to preserve a positive value of E2. @ingroup GenVector. This class is also known as (typedefs to this class)ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::CoordinateType. Function Members (Methods); public:. ~PxPyPzM4D<double>(); ROOT::Math::PxPyPzM4D<double>::ScalarE() const; ROOT::Math::PxPyPzM4D<double>::ScalarE2() const; ROOT::Math::PxPyPzM4D<double>::ScalarEt() const; ROOT::Math::PxPyPzM4D<double>::ScalarEt2() const; ROOT::Math::PxPyPzM4D<double>::ScalarEta() const; voidGetCoordinates(ROOT::Math::PxPyPzM4D<double>::Scalar* dest) const; voidGetCoordinates(ROOT::Math::PxPyPzM4D<double>::Scalar& px, ROOT::Math::PxPyPzM4D<double>::Scalar& py, ROOT::Math::PxPyPzM4D<double>::Scalar& pz, ROOT::Math::PxPyPzM4D<double>::Scalar& m) const; ROOT::Math::PxPyPzM4D<double>::ScalarM() const; ROOT::Math::PxPyPzM4D<double>::ScalarM2() const; ROOT::Math::PxPyPzM4D<double>::ScalarMag() const; ROOT::Math::PxPyPzM4D<double>::ScalarMag2() const; ROOT::Math::PxPyPzM4D<double>::ScalarMt() const; ROOT::Math::PxPyPzM4D<double>::ScalarMt2() const; voidNegate(); booloperator!=(const ROOT::Math::PxPyPzM4D<double>& rhs) const; ROOT::Math::PxPyPzM4D<double>&operator=(const ROOT::Math::PxPyPzM4D<double>& v); booloperator==(const ROOT::Math::PxPyPzM4D<double>& rhs) const; ROOT::Math::PxPyPz",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ROOT__Math__PxPyPzM4D_double_.html:500,avoid,avoid,500,root/html530/ROOT__Math__PxPyPzM4D_double_.html,https://root.cern,https://root.cern/root/html530/ROOT__Math__PxPyPzM4D_double_.html,3,['avoid'],['avoid']
Safety,". ROOT::Minuit2::MinuitParameter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MINUIT2; » ROOT::Minuit2::MinuitParameter. class ROOT::Minuit2::MinuitParameter. class for the individual Minuit Parameter with Name and number;; contains the input numbers for the minimization or the output result; from minimization;; possible interactions: Fix/release, set/remove limits, set Value/error;. From version 5.20: use string to store the name to avoid limitation of; name length of 20 characters. Function Members (Methods); public:. ~MinuitParameter(); doubleError() const; voidFix(); const string&GetName() const; boolHasLimits() const; boolHasLowerLimit() const; boolHasUpperLimit() const; boolIsConst() const; boolIsFixed() const; doubleLowerLimit() const; ROOT::Minuit2::MinuitParameterMinuitParameter(const ROOT::Minuit2::MinuitParameter& par); ROOT::Minuit2::MinuitParameterMinuitParameter(unsigned int num, const string& name, double val); ROOT::Minuit2::MinuitParameterMinuitParameter(unsigned int num, const string& name, double val, double err); ROOT::Minuit2::MinuitParameterMinuitParameter(unsigned int num, const string& name, double val, double err, double min, double max); const char*Name() const; unsigned intNumber() const; ROOT::Minuit2::MinuitParameter&operator=(const ROOT::Minuit2::MinuitParameter& par); voidRelease(); voidRemoveLimits(); voidSetError(double err); voidSetLimits(double low, double up); voidSetLowerLimit(double low); voidSetUpperLimit(double up); voidSetValue(double val); doubleUpperLimit() const; doubleValue() const. Data Members; private:. boolfConst; doublefError; boolfFix; boolfLoLimValid; doublefLoLimit; stringfName; unsigned intfNum; boolfUpLimValid; doublefUpLimit; doublefValue. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MinuitParameter(unsigned int num,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Minuit2__MinuitParameter.html:591,avoid,avoid,591,root/html526/ROOT__Minuit2__MinuitParameter.html,https://root.cern,https://root.cern/root/html526/ROOT__Minuit2__MinuitParameter.html,2,['avoid'],['avoid']
Safety,". ROOT::Minuit2::MinuitParameter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MINUIT2; » ROOT::Minuit2::MinuitParameter. class ROOT::Minuit2::MinuitParameter. class for the individual Minuit Parameter with Name and number;; contains the input numbers for the minimization or the output result; from minimization;; possible interactions: Fix/release, set/remove limits, set Value/error;. From version 5.20: use string to store the name to avoid limitation of; name length of 20 characters. Function Members (Methods); public:. ~MinuitParameter(); doubleError() const; voidFix(); const string&GetName() const; boolHasLimits() const; boolHasLowerLimit() const; boolHasUpperLimit() const; boolIsConst() const; boolIsFixed() const; doubleLowerLimit() const; ROOT::Minuit2::MinuitParameterMinuitParameter(); ROOT::Minuit2::MinuitParameterMinuitParameter(const ROOT::Minuit2::MinuitParameter& par); ROOT::Minuit2::MinuitParameterMinuitParameter(unsigned int num, const string& name, double val); ROOT::Minuit2::MinuitParameterMinuitParameter(unsigned int num, const string& name, double val, double err); ROOT::Minuit2::MinuitParameterMinuitParameter(unsigned int num, const string& name, double val, double err, double min, double max); const char*Name() const; unsigned intNumber() const; ROOT::Minuit2::MinuitParameter&operator=(const ROOT::Minuit2::MinuitParameter& par); voidRelease(); voidRemoveLimits(); voidSetError(double err); voidSetLimits(double low, double up); voidSetLowerLimit(double low); voidSetName(const string& name); voidSetUpperLimit(double up); voidSetValue(double val); doubleUpperLimit() const; doubleValue() const. Data Members; private:. boolfConst; doublefError; boolfFix; boolfLoLimValid; doublefLoLimit; stringfName; unsigned intfNum; boolfUpLimValid; doublefUpLimit; doublefValue. Class Charts. Inheritance; Inherited Mem",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Minuit2__MinuitParameter.html:593,avoid,avoid,593,root/html602/ROOT__Minuit2__MinuitParameter.html,https://root.cern,https://root.cern/root/html602/ROOT__Minuit2__MinuitParameter.html,2,['avoid'],['avoid']
Safety,". ROOT::Minuit2::MinuitParameter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MINUIT2; » ROOT::Minuit2::MinuitParameter. class ROOT::Minuit2::MinuitParameter. class for the individual Minuit Parameter with Name and number;; contains the input numbers for the minimization or the output result; from minimization;; possible interactions: Fix/release, set/remove limits, set Value/error;. From version 5.20: use string to store the name to avoid limitation of; name length of 20 characters. This class is also known as (typedefs to this class)vector<ROOT::Minuit2::MinuitParameter,allocator<ROOT::Minuit2::MinuitParameter> >::value_type. Function Members (Methods); public:. ~MinuitParameter(); doubleError() const; voidFix(); const string&GetName() const; boolHasLimits() const; boolHasLowerLimit() const; boolHasUpperLimit() const; boolIsConst() const; boolIsFixed() const; doubleLowerLimit() const; ROOT::Minuit2::MinuitParameterMinuitParameter(); ROOT::Minuit2::MinuitParameterMinuitParameter(const ROOT::Minuit2::MinuitParameter& par); ROOT::Minuit2::MinuitParameterMinuitParameter(unsigned int num, const string& name, double val); ROOT::Minuit2::MinuitParameterMinuitParameter(unsigned int num, const string& name, double val, double err); ROOT::Minuit2::MinuitParameterMinuitParameter(unsigned int num, const string& name, double val, double err, double min, double max); const char*Name() const; unsigned intNumber() const; ROOT::Minuit2::MinuitParameter&operator=(const ROOT::Minuit2::MinuitParameter& par); voidRelease(); voidRemoveLimits(); voidSetError(double err); voidSetLimits(double low, double up); voidSetLowerLimit(double low); voidSetName(const string& name); voidSetUpperLimit(double up); voidSetValue(double val); doubleUpperLimit() const; doubleValue() const. Data Members; private:. boolfConst; doublefError; boolfFix; bool",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Minuit2__MinuitParameter.html:593,avoid,avoid,593,root/html534/ROOT__Minuit2__MinuitParameter.html,https://root.cern,https://root.cern/root/html534/ROOT__Minuit2__MinuitParameter.html,1,['avoid'],['avoid']
Safety,". ROOT::Minuit2::MinuitParameter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MINUIT2; » ROOT::Minuit2::MinuitParameter. class ROOT::Minuit2::MinuitParameter. class for the individual Minuit Parameter with Name and number;; contains the input numbers for the minimization or the output result; from minimization;; possible interactions: Fix/release, set/remove limits, set Value/error;. From version 5.20: use string to store the name to avoid limitation of; name length of 20 characters. This class is also known as (typedefs to this class)vector<ROOT::Minuit2::MinuitParameter,allocator<ROOT::Minuit2::MinuitParameter> >::value_type. Function Members (Methods); public:. ~MinuitParameter(); doubleError() const; voidFix(); const string&GetName() const; boolHasLimits() const; boolHasLowerLimit() const; boolHasUpperLimit() const; boolIsConst() const; boolIsFixed() const; doubleLowerLimit() const; ROOT::Minuit2::MinuitParameterMinuitParameter(); ROOT::Minuit2::MinuitParameterMinuitParameter(const ROOT::Minuit2::MinuitParameter& par); ROOT::Minuit2::MinuitParameterMinuitParameter(unsigned int num, const string& name, double val); ROOT::Minuit2::MinuitParameterMinuitParameter(unsigned int num, const string& name, double val, double err); ROOT::Minuit2::MinuitParameterMinuitParameter(unsigned int num, const string& name, double val, double err, double min, double max); const char*Name() const; unsigned intNumber() const; ROOT::Minuit2::MinuitParameter&operator=(const ROOT::Minuit2::MinuitParameter& par); voidRelease(); voidRemoveLimits(); voidSetError(double err); voidSetLimits(double low, double up); voidSetLowerLimit(double low); voidSetUpperLimit(double up); voidSetValue(double val); doubleUpperLimit() const; doubleValue() const. Data Members; private:. boolfConst; doublefError; boolfFix; boolfLoLimValid; doublefLoLimit; stri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ROOT__Minuit2__MinuitParameter.html:593,avoid,avoid,593,root/html530/ROOT__Minuit2__MinuitParameter.html,https://root.cern,https://root.cern/root/html530/ROOT__Minuit2__MinuitParameter.html,2,['avoid'],['avoid']
Safety,". RooDirItem. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooDirItem. class RooDirItem. RooDirItem is a utility base class for RooFit objects that are to be attached; to ROOT directories. Concrete classes inherit the appendToDir and removeToDir; methods that can be used to safely attach and detach one self from a TDirectory; . Function Members (Methods); public:. RooDirItem(); RooDirItem(const RooDirItem& other); virtual~RooDirItem(); static TClass*Class(); virtual TClass*IsA() const; RooDirItem&operator=(const RooDirItem&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. voidappendToDir(TObject* obj, Bool_t forceMemoryResident = kFALSE); voidremoveFromDir(TObject* obj). Data Members; protected:. TDirectory*_dir! Associated directory. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooDirItem(); Default constructor. RooDirItem(const RooDirItem& other); Copy constructor. ~RooDirItem(); Destructor. void removeFromDir(TObject* obj); Remove object from directory it was added to. void appendToDir(TObject* obj, Bool_t forceMemoryResident = kFALSE); Append object to directory. If forceMemoryResident is; true, force addition to ROOT memory directory if that; is not the current directory. » Last changed: Mon Jul 4 15:22:39 2011 » Last generated: 2011-07-04 15:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooDirItem.html:469,safe,safely,469,root/html530/RooDirItem.html,https://root.cern,https://root.cern/root/html530/RooDirItem.html,1,['safe'],['safely']
Safety,". RooDirItem. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooDirItem. class RooDirItem. RooDirItem is a utility base class for RooFit objects that are to be attached; to ROOT directories. Concrete classes inherit the appendToDir and removeToDir; methods that can be used to safely attach and detach one self from a TDirectory; . Function Members (Methods); public:. RooDirItem(); RooDirItem(const RooDirItem& other); virtual~RooDirItem(); static TClass*Class(); virtual TClass*IsA() const; RooDirItem&operator=(const RooDirItem&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. voidappendToDir(TObject* obj, Bool_t forceMemoryResident = kFALSE); voidremoveFromDir(TObject* obj). Data Members; protected:. TDirectory*_dir! Associated directory. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooDirItem(); Default constructor. RooDirItem(const RooDirItem& other); Copy constructor. ~RooDirItem(); Destructor. void removeFromDir(TObject* obj); Remove object from directory it was added to. void appendToDir(TObject* obj, Bool_t forceMemoryResident = kFALSE); Append object to directory. If forceMemoryResident is; true, force addition to ROOT memory directory if that; is not the current directory. » Last changed: Thu Nov 3 20:07:58 2011 » Last generated: 2011-11-03 20:07; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooDirItem.html:469,safe,safely,469,root/html532/RooDirItem.html,https://root.cern,https://root.cern/root/html532/RooDirItem.html,1,['safe'],['safely']
Safety,". RooDirItem. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooDirItem. class RooDirItem. RooDirItem is a utility base class for RooFit objects that are to be attached; to ROOT directories. Concrete classes inherit the appendToDir and removeToDir; methods that can be used to safely attach and detach one self from a TDirectory; . Function Members (Methods); public:. RooDirItem(); RooDirItem(const RooDirItem& other); virtual~RooDirItem(); static TClass*Class(); virtual TClass*IsA() const; RooDirItem&operator=(const RooDirItem&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. voidappendToDir(TObject* obj, Bool_t forceMemoryResident = kFALSE); voidremoveFromDir(TObject* obj). Data Members; protected:. TDirectory*_dir! Associated directory. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooDirItem(); Default constructor. RooDirItem(const RooDirItem& other); Copy constructor. ~RooDirItem(); Destructor. void removeFromDir(TObject* obj); Remove object from directory it was added to. void appendToDir(TObject* obj, Bool_t forceMemoryResident = kFALSE); Append object to directory. If forceMemoryResident is; true, force addition to ROOT memory directory if that; is not the current directory. » Last changed: Thu Sep 23 19:59:29 2010 » Last generated: 2010-09-23 19:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooDirItem.html:469,safe,safely,469,root/html528/RooDirItem.html,https://root.cern,https://root.cern/root/html528/RooDirItem.html,1,['safe'],['safely']
Safety,". RooDirItem. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooDirItem. class RooDirItem. RooDirItem is a utility base class for RooFit objects that are to be attached; to ROOT directories. Concrete classes inherit the appendToDir and removeToDir; methods that can be used to safely attach and detach one self from a TDirectory; . Function Members (Methods); public:. RooDirItem(); RooDirItem(const RooDirItem& other); virtual~RooDirItem(); static TClass*Class(); virtual TClass*IsA() const; RooDirItem&operator=(const RooDirItem&); virtual voidShowMembers(TMemberInspector& insp, char* parent); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. voidappendToDir(TObject* obj, Bool_t forceMemoryResident = kFALSE); voidremoveFromDir(TObject* obj). Data Members; protected:. TDirectory*_dir! Associated directory. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooDirItem(); Default constructor. RooDirItem(const RooDirItem& other); Copy constructor. ~RooDirItem(); Destructor. void removeFromDir(TObject* obj); Remove object from directory it was added to. void appendToDir(TObject* obj, Bool_t forceMemoryResident = kFALSE); Append object to directory. If forceMemoryResident is; true, force addition to ROOT memory directory if that; is not the current directory. » Last changed: Mon Dec 7 13:47:24 2009 » Last generated: 2009-12-07 13:47; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooDirItem.html:469,safe,safely,469,root/html526/RooDirItem.html,https://root.cern,https://root.cern/root/html526/RooDirItem.html,1,['safe'],['safely']
Safety,". RooDirItem. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooDirItem. class RooDirItem. RooDirItem is a utility base class for RooFit objects that are to be attached; to ROOT directories. Concrete classes inherit the appendToDir and removeToDir; methods that can be used to safely attach and detach one self from a TDirectory; . Function Members (Methods); public:. RooDirItem(); RooDirItem(const RooDirItem& other); virtual~RooDirItem(); static TClass*Class(); virtual TClass*IsA() const; RooDirItem&operator=(const RooDirItem&); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). protected:. voidappendToDir(TObject* obj, Bool_t forceMemoryResident = kFALSE); voidremoveFromDir(TObject* obj). Data Members; protected:. TDirectory*_dir! Associated directory. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooDirItem(); Default constructor. RooDirItem(const RooDirItem& other); Copy constructor. ~RooDirItem(); Destructor. void removeFromDir(TObject* obj); Remove object from directory it was added to. void appendToDir(TObject* obj, Bool_t forceMemoryResident = kFALSE); Append object to directory. If forceMemoryResident is; true, force addition to ROOT memory directory if that; is not the current directory. » Last changed: Tue Mar 10 17:16:16 2015 » Last generated: 2015-03-10 17:16; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooDirItem.html:469,safe,safely,469,root/html534/RooDirItem.html,https://root.cern,https://root.cern/root/html534/RooDirItem.html,1,['safe'],['safely']
Safety,". RooDirItem. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooDirItem. class RooDirItem. RooDirItem is a utility base class for RooFit objects that are to be attached; to ROOT directories. Concrete classes inherit the appendToDir and removeToDir; methods that can be used to safely attach and detach one self from a TDirectory; . Function Members (Methods); public:. virtual~RooDirItem(); static TClass*Class(); virtual TClass*IsA() const; RooDirItem&operator=(const RooDirItem&); RooDirItem(); RooDirItem(const RooDirItem& other); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). protected:. voidappendToDir(TObject* obj, Bool_t forceMemoryResident = kFALSE); voidremoveFromDir(TObject* obj). Data Members; protected:. TDirectory*_dir! Associated directory. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooDirItem(); Default constructor. RooDirItem(const RooDirItem& other); Copy constructor. ~RooDirItem(); Destructor. void removeFromDir(TObject* obj); Remove object from directory it was added to. void appendToDir(TObject* obj, Bool_t forceMemoryResident = kFALSE); Append object to directory. If forceMemoryResident is; true, force addition to ROOT memory directory if that; is not the current directory. » Last changed: Tue Jun 2 15:30:26 2015 » Last generated: 2015-06-02 15:30; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooDirItem.html:469,safe,safely,469,root/html604/RooDirItem.html,https://root.cern,https://root.cern/root/html604/RooDirItem.html,1,['safe'],['safely']
Safety,". RooDirItem. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooDirItem. class RooDirItem. RooDirItem is a utility base class for RooFit objects that are to be attached; to ROOT directories. Concrete classes inherit the appendToDir and removeToDir; methods that can be used to safely attach and detach one self from a TDirectory; . Function Members (Methods); public:. virtual~RooDirItem(); static TClass*Class(); virtual TClass*IsA() const; RooDirItem&operator=(const RooDirItem&); RooDirItem(); RooDirItem(const RooDirItem& other); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). protected:. voidappendToDir(TObject* obj, Bool_t forceMemoryResident = kFALSE); voidremoveFromDir(TObject* obj). Data Members; protected:. TDirectory*_dir! Associated directory. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooDirItem(); Default constructor. RooDirItem(const RooDirItem& other); Copy constructor. ~RooDirItem(); Destructor. void removeFromDir(TObject* obj); Remove object from directory it was added to. void appendToDir(TObject* obj, Bool_t forceMemoryResident = kFALSE); Append object to directory. If forceMemoryResident is; true, force addition to ROOT memory directory if that; is not the current directory. » Last changed: Tue Jun 30 14:32:36 2015 » Last generated: 2015-06-30 14:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooDirItem.html:469,safe,safely,469,root/html602/RooDirItem.html,https://root.cern,https://root.cern/root/html602/RooDirItem.html,1,['safe'],['safely']
Safety,". RooGenContext. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooGenContext. class RooGenContext: public RooAbsGenContext. Class RooGenContext implement a universal generator context for all; RooAbsPdf classes that do not have or need a specialized generator; context. This generator context queries the input p.d.f which observables; it can generate internally and delegates generation of those observables; to the p.d.f if it deems that safe. The other observables are generated; use a RooAcceptReject sampling technique.; . Function Members (Methods); public:. RooGenContext(const RooGenContext&); RooGenContext(const RooAbsPdf& model, const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE, const RooArgSet* forceDirect = 0); virtual~RooGenContext(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidattach(const RooArgSet& params); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tRooAbsGenContext::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooAbsGenContext::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMEN",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooGenContext.html:633,safe,safe,633,root/html526/RooGenContext.html,https://root.cern,https://root.cern/root/html526/RooGenContext.html,5,['safe'],['safe']
Safety,". RooGenContext. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooGenContext. class RooGenContext: public RooAbsGenContext. Class RooGenContext implement a universal generator context for all; RooAbsPdf classes that do not have or need a specialized generator; context. This generator context queries the input p.d.f which observables; it can generate internally and delegates generation of those observables; to the p.d.f if it deems that safe. The other observables are generated; use a RooAcceptReject sampling technique.; . Function Members (Methods); public:. virtual~RooGenContext(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidattach(const RooArgSet& params); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tRooAbsGenContext::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooAbsGenContext::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObj",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooGenContext.html:633,safe,safe,633,root/html602/RooGenContext.html,https://root.cern,https://root.cern/root/html602/RooGenContext.html,2,['safe'],['safe']
Safety,". RooListProxy. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooListProxy. class RooListProxy: public RooArgList, public RooAbsProxy. RooListProxy is the concrete proxy for RooArgList objects.; A RooListProxy is the only safe mechanism to store a RooArgList; with RooAbsArg contents in another RooAbsArg.; ; The list proxy has the semantic of a RooArgList but also ; takes care of all bookkeeping required when composite objects; are clone and client-server links need to be redirected.; . Function Members (Methods); public:. RooListProxy(); RooListProxy(const RooListProxy&); RooListProxy(const char* name, RooAbsArg* owner, const RooListProxy& other); RooListProxy(const char* name, const char* desc, RooAbsArg* owner, Bool_t defValueServer = kTRUE, Bool_t defShapeServer = kFALSE); virtual~RooListProxy(); voidTObject::AbstractMethod(const char* method) const; virtual Bool_tadd(const RooAbsArg& var, Bool_t silent = kFALSE); virtual Bool_tadd(const RooAbsCollection& list, Bool_t silent = kFALSE); virtual Bool_tadd(const RooAbsArg& var, Bool_t valueServer, Bool_t shapeServer, Bool_t silent); virtual RooAbsArg*RooAbsCollection::addClone(const RooAbsArg& var, Bool_t silent = kFALSE); virtual voidRooAbsCollection::addClone(const RooAbsCollection& list, Bool_t silent = kFALSE); virtual Bool_taddOwned(RooAbsArg& var, Bool_t silent = kFALSE); virtual Bool_taddOwned(const RooAbsCollection& list, Bool_t silent = kFALSE); Bool_tRooAbsCollection::allInRange(const char* rangeSpec) const; virtual voidTObject::AppendPad(Option_t* option = """"); RooAbsCollection&RooAbsCollection::assignFast(const RooAbsCollection& other); RooAbsCollection&RooAbsCollection::assignValueOnly(const RooAbsCollection& other); RooAbsArg*RooArgList::at(Int_t idx) const; virtual voidTObject::Browse(TBrowser* b); static TClass*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooListProxy.html:415,safe,safe,415,root/html526/RooListProxy.html,https://root.cern,https://root.cern/root/html526/RooListProxy.html,2,['safe'],['safe']
Safety,". RooListProxy. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooListProxy. class RooListProxy: public RooArgList, public RooAbsProxy. RooListProxy is the concrete proxy for RooArgList objects.; A RooListProxy is the only safe mechanism to store a RooArgList; with RooAbsArg contents in another RooAbsArg.; ; The list proxy has the semantic of a RooArgList but also ; takes care of all bookkeeping required when composite objects; are clone and client-server links need to be redirected.; . Function Members (Methods); public:. RooListProxy(); RooListProxy(const RooListProxy&); RooListProxy(const char* name, RooAbsArg* owner, const RooListProxy& other); RooListProxy(const char* name, const char* desc, RooAbsArg* owner, Bool_t defValueServer = kTRUE, Bool_t defShapeServer = kFALSE); virtual~RooListProxy(); voidTObject::AbstractMethod(const char* method) const; virtual Bool_tadd(const RooAbsArg& var, Bool_t silent = kFALSE); virtual Bool_tadd(const RooAbsCollection& list, Bool_t silent = kFALSE); virtual Bool_tadd(const RooAbsArg& var, Bool_t valueServer, Bool_t shapeServer, Bool_t silent); virtual RooAbsArg*RooAbsCollection::addClone(const RooAbsArg& var, Bool_t silent = kFALSE); virtual voidRooAbsCollection::addClone(const RooAbsCollection& list, Bool_t silent = kFALSE); virtual Bool_taddOwned(RooAbsArg& var, Bool_t silent = kFALSE); virtual Bool_taddOwned(const RooAbsCollection& list, Bool_t silent = kFALSE); Bool_tRooAbsCollection::allInRange(const char* rangeSpec) const; virtual voidTObject::AppendPad(Option_t* option = """"); RooAbsCollection&RooAbsCollection::assignFast(const RooAbsCollection& other); RooAbsCollection&RooAbsCollection::assignValueOnly(const RooAbsCollection& other, Bool_t oneSafe = kFALSE); RooAbsArg*RooArgList::at(Int_t idx) const; virtual voidTObject::Browse(TBr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooListProxy.html:415,safe,safe,415,root/html530/RooListProxy.html,https://root.cern,https://root.cern/root/html530/RooListProxy.html,1,['safe'],['safe']
Safety,". RooListProxy. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooListProxy. class RooListProxy: public RooArgList, public RooAbsProxy. RooListProxy is the concrete proxy for RooArgList objects.; A RooListProxy is the only safe mechanism to store a RooArgList; with RooAbsArg contents in another RooAbsArg.; ; The list proxy has the semantic of a RooArgList but also ; takes care of all bookkeeping required when composite objects; are clone and client-server links need to be redirected.; . Function Members (Methods); public:. RooListProxy(); RooListProxy(const RooListProxy&); RooListProxy(const char* name, RooAbsArg* owner, const RooListProxy& other); RooListProxy(const char* name, const char* desc, RooAbsArg* owner, Bool_t defValueServer = kTRUE, Bool_t defShapeServer = kFALSE); virtual~RooListProxy(); voidTObject::AbstractMethod(const char* method) const; virtual Bool_tadd(const RooAbsArg& var, Bool_t silent = kFALSE); virtual Bool_tadd(const RooAbsCollection& list, Bool_t silent = kFALSE); virtual Bool_tadd(const RooAbsArg& var, Bool_t valueServer, Bool_t shapeServer, Bool_t silent); virtual RooAbsArg*RooAbsCollection::addClone(const RooAbsArg& var, Bool_t silent = kFALSE); virtual voidRooAbsCollection::addClone(const RooAbsCollection& list, Bool_t silent = kFALSE); virtual Bool_taddOwned(RooAbsArg& var, Bool_t silent = kFALSE); virtual Bool_taddOwned(const RooAbsCollection& list, Bool_t silent = kFALSE); Bool_tRooAbsCollection::allInRange(const char* rangeSpec) const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsCollection::assignFast(const RooAbsCollection& other, Bool_t setValDirty = kTRUE); RooAbsCollection&RooAbsCollection::assignValueOnly(const RooAbsCollection& other, Bool_t oneSafe = kFALSE); RooAbsArg*RooArgList::at(Int_t idx) const; virtual voidTObj",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooListProxy.html:415,safe,safe,415,root/html532/RooListProxy.html,https://root.cern,https://root.cern/root/html532/RooListProxy.html,2,['safe'],['safe']
Safety,". RooListProxy. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooListProxy. class RooListProxy: public RooArgList, public RooAbsProxy. RooListProxy is the concrete proxy for RooArgList objects.; A RooListProxy is the only safe mechanism to store a RooArgList; with RooAbsArg contents in another RooAbsArg.; ; The list proxy has the semantic of a RooArgList but also ; takes care of all bookkeeping required when composite objects; are clone and client-server links need to be redirected.; . Function Members (Methods); public:. virtual~RooListProxy(); voidTObject::AbstractMethod(const char* method) const; virtual Bool_tadd(const RooAbsArg& var, Bool_t silent = kFALSE); virtual Bool_tadd(const RooAbsCollection& list, Bool_t silent = kFALSE); virtual Bool_tadd(const RooAbsArg& var, Bool_t valueServer, Bool_t shapeServer, Bool_t silent); virtual RooAbsArg*RooAbsCollection::addClone(const RooAbsArg& var, Bool_t silent = kFALSE); virtual voidRooAbsCollection::addClone(const RooAbsCollection& list, Bool_t silent = kFALSE); virtual Bool_taddOwned(RooAbsArg& var, Bool_t silent = kFALSE); virtual Bool_taddOwned(const RooAbsCollection& list, Bool_t silent = kFALSE); Bool_tRooAbsCollection::allInRange(const char* rangeSpec) const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsCollection::assignFast(const RooAbsCollection& other, Bool_t setValDirty = kTRUE); RooAbsCollection&RooAbsCollection::assignValueOnly(const RooAbsCollection& other, Bool_t oneSafe = kFALSE); RooAbsArg*RooArgList::at(Int_t idx) const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*RooArgList::clone(const char* newname) const; virtual TObject*RooAbsCollection::Clone(const char* newna",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooListProxy.html:415,safe,safe,415,root/html602/RooListProxy.html,https://root.cern,https://root.cern/root/html602/RooListProxy.html,2,['safe'],['safe']
Safety,". RooNormSetCache. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooNormSetCache. class RooNormSetCache. Class RooNormSet cache manage the bookkeeping of multiple instances; of sets of integration and normalization observables that effectively; have the same definition. In complex function expression many; RooArgSets with the same contents may be passed to an object that; caches intermediate results dependent on the normalization/integration set; To avoid unnecessary cache faulting, This class tracks all instances; with the same contents and reports to the owner if the present nset/iset; is truely different from the current reference. Class RooNormSet only; evaluates each RooArgSet pointer once, it therefore assumes that; RooArgSets with normalization and/or integration sets are not changes; during their lifetime. ; . Function Members (Methods); public:. RooNormSetCache(Int_t regSize = 10); RooNormSetCache(const RooNormSetCache& other); virtual~RooNormSetCache(); voidadd(const RooArgSet* set1, const RooArgSet* set2 = 0); Bool_tautoCache(const RooAbsArg* self, const RooArgSet* set1, const RooArgSet* set2 = 0, const TNamed* set2RangeName = 0, Bool_t autoRefill = kTRUE); static TClass*Class(); voidclear(); Bool_tcontains(const RooArgSet* set1, const RooArgSet* set2 = 0, const TNamed* set2RangeName = 0); Bool_tcontainsSet1(const RooArgSet* set1); Int_tentries() const; Int_tindex(const RooArgSet* set1, const RooArgSet* set2 = 0, const TNamed* set2RangeName = 0); voidinitialize(const RooNormSetCache& other); virtual TClass*IsA() const; const RooArgSet*lastSet1() const; const RooArgSet*lastSet2() const; const RooNameSet&nameSet1() const; const RooNameSet&nameSet2() const; RooNormSetCache&operator=(const RooNormSetCache&); virtual voidShowMembers(TMemberInspector& insp); virtual voidSt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooNormSetCache.html:647,avoid,avoid,647,root/html528/RooNormSetCache.html,https://root.cern,https://root.cern/root/html528/RooNormSetCache.html,1,['avoid'],['avoid']
Safety,". RooNormSetCache. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooNormSetCache. class RooNormSetCache. Class RooNormSet cache manage the bookkeeping of multiple instances; of sets of integration and normalization observables that effectively; have the same definition. In complex function expression many; RooArgSets with the same contents may be passed to an object that; caches intermediate results dependent on the normalization/integration set; To avoid unnecessary cache faulting, This class tracks all instances; with the same contents and reports to the owner if the present nset/iset; is truely different from the current reference. Class RooNormSet only; evaluates each RooArgSet pointer once, it therefore assumes that; RooArgSets with normalization and/or integration sets are not changes; during their lifetime. ; . Function Members (Methods); public:. RooNormSetCache(Int_t regSize = 10); RooNormSetCache(const RooNormSetCache& other); virtual~RooNormSetCache(); voidadd(const RooArgSet* set1, const RooArgSet* set2 = 0); Bool_tautoCache(const RooAbsArg* self, const RooArgSet* set1, const RooArgSet* set2 = 0, const TNamed* set2RangeName = 0, Bool_t autoRefill = kTRUE); static TClass*Class(); voidclear(); Bool_tcontains(const RooArgSet* set1, const RooArgSet* set2 = 0, const TNamed* set2RangeName = 0); Bool_tcontainsSet1(const RooArgSet* set1); Int_tentries() const; Int_tindex(const RooArgSet* set1, const RooArgSet* set2 = 0, const TNamed* set2RangeName = 0); voidinitialize(const RooNormSetCache& other); virtual TClass*IsA() const; const RooArgSet*lastSet1() const; const RooArgSet*lastSet2() const; const RooNameSet&nameSet1() const; const RooNameSet&nameSet2() const; RooNormSetCache&operator=(const RooNormSetCache&); virtual voidShowMembers(TMemberInspector& insp, char* parent); ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooNormSetCache.html:647,avoid,avoid,647,root/html526/RooNormSetCache.html,https://root.cern,https://root.cern/root/html526/RooNormSetCache.html,1,['avoid'],['avoid']
Safety,". RooNormSetCache. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooNormSetCache. class RooNormSetCache. Class RooNormSet cache manage the bookkeeping of multiple instances; of sets of integration and normalization observables that effectively; have the same definition. In complex function expression many; RooArgSets with the same contents may be passed to an object that; caches intermediate results dependent on the normalization/integration set; To avoid unnecessary cache faulting, This class tracks all instances; with the same contents and reports to the owner if the present nset/iset; is truely different from the current reference. Class RooNormSet only; evaluates each RooArgSet pointer once, it therefore assumes that; RooArgSets with normalization and/or integration sets are not changes; during their lifetime. ; . Function Members (Methods); public:. RooNormSetCache(Int_t regSize = 64); RooNormSetCache(const RooNormSetCache& other); virtual~RooNormSetCache(); voidadd(const RooArgSet* set1, const RooArgSet* set2 = 0); Bool_tautoCache(const RooAbsArg* self, const RooArgSet* set1, const RooArgSet* set2 = 0, const TNamed* set2RangeName = 0, Bool_t autoRefill = kTRUE); static TClass*Class(); voidclear(); Bool_tcontains(const RooArgSet* set1, const RooArgSet* set2 = 0, const TNamed* set2RangeName = 0); Bool_tcontainsSet1(const RooArgSet* set1); Int_tentries() const; Int_tindex(const RooArgSet* set1, const RooArgSet* set2 = 0, const TNamed* set2RangeName = 0); voidinitialize(const RooNormSetCache& other); virtual TClass*IsA() const; const RooArgSet*lastSet1() const; const RooArgSet*lastSet2() const; const RooNameSet&nameSet1() const; const RooNameSet&nameSet2() const; RooNormSetCache&operator=(const RooNormSetCache&); virtual voidShowMembers(TMemberInspector& insp); virtual voidSt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooNormSetCache.html:647,avoid,avoid,647,root/html530/RooNormSetCache.html,https://root.cern,https://root.cern/root/html530/RooNormSetCache.html,2,['avoid'],['avoid']
Safety,". RooNormSetCache. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooNormSetCache. class RooNormSetCache. Class RooNormSet cache manage the bookkeeping of multiple instances; of sets of integration and normalization observables that effectively; have the same definition. In complex function expression many; RooArgSets with the same contents may be passed to an object that; caches intermediate results dependent on the normalization/integration set; To avoid unnecessary cache faulting, This class tracks all instances; with the same contents and reports to the owner if the present nset/iset; is truely different from the current reference. Class RooNormSet only; evaluates each RooArgSet pointer once, it therefore assumes that; RooArgSets with normalization and/or integration sets are not changes; during their lifetime. ; . Function Members (Methods); public:. RooNormSetCache(ULong_t max = 32); RooNormSetCache(const RooNormSetCache&); virtual~RooNormSetCache(); voidadd(const RooArgSet* set1, const RooArgSet* set2 = 0); Bool_tautoCache(const RooAbsArg* self, const RooArgSet* set1, const RooArgSet* set2 = 0, const TNamed* set2RangeName = 0, Bool_t autoRefill = kTRUE); static TClass*Class(); voidclear(); Bool_tcontains(const RooArgSet* set1, const RooArgSet* set2 = 0, const TNamed* set2RangeName = 0); Bool_tcontainsSet1(const RooArgSet* set1); Int_tentries() const; Int_tindex(const RooArgSet* set1, const RooArgSet* set2 = 0, const TNamed* set2RangeName = 0); voidinitialize(const RooNormSetCache& other); virtual TClass*IsA() const; const RooArgSet*lastSet1() const; const RooArgSet*lastSet2() const; const RooNameSet&nameSet1() const; const RooNameSet&nameSet2() const; RooNormSetCache&operator=(const RooNormSetCache&); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooNormSetCache.html:647,avoid,avoid,647,root/html534/RooNormSetCache.html,https://root.cern,https://root.cern/root/html534/RooNormSetCache.html,1,['avoid'],['avoid']
Safety,". RooNormSetCache. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooNormSetCache. class RooNormSetCache. Class RooNormSet cache manage the bookkeeping of multiple instances; of sets of integration and normalization observables that effectively; have the same definition. In complex function expression many; RooArgSets with the same contents may be passed to an object that; caches intermediate results dependent on the normalization/integration set; To avoid unnecessary cache faulting, This class tracks all instances; with the same contents and reports to the owner if the present nset/iset; is truely different from the current reference. Class RooNormSet only; evaluates each RooArgSet pointer once, it therefore assumes that; RooArgSets with normalization and/or integration sets are not changes; during their lifetime. ; . Function Members (Methods); public:. virtual~RooNormSetCache(); voidadd(const RooArgSet* set1, const RooArgSet* set2 = 0); Bool_tautoCache(const RooAbsArg* self, const RooArgSet* set1, const RooArgSet* set2 = 0, const TNamed* set2RangeName = 0, Bool_t autoRefill = kTRUE); static TClass*Class(); voidclear(); Bool_tcontains(const RooArgSet* set1, const RooArgSet* set2 = 0, const TNamed* set2RangeName = 0); Bool_tcontainsSet1(const RooArgSet* set1); Int_tentries() const; Int_tindex(const RooArgSet* set1, const RooArgSet* set2 = 0, const TNamed* set2RangeName = 0); voidinitialize(const RooNormSetCache& other); virtual TClass*IsA() const; const RooArgSet*lastSet1() const; const RooArgSet*lastSet2() const; const RooNameSet&nameSet1() const; const RooNameSet&nameSet2() const; RooNormSetCache&operator=(const RooNormSetCache&); RooNormSetCache(ULong_t max = 32); RooNormSetCache(const RooNormSetCache&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStre",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooNormSetCache.html:647,avoid,avoid,647,root/html602/RooNormSetCache.html,https://root.cern,https://root.cern/root/html602/RooNormSetCache.html,2,['avoid'],['avoid']
Safety,. RooSentinel. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooSentinel. class RooSentinel. RooSentinel is a special purposes singleton class that terminates; all other RooFit singleton services when the process exists. ; All function RooFit singleton services are created on the heap with; a static wrapper function to avoid the 'static initialization order fiasco'; but are not automatically destroyed at the end of the session. This class; installs an atexit() function that takes care of this; . Function Members (Methods); public:. ~RooSentinel(); static voidactivate(); RooSentinel&operator=(const RooSentinel&). protected:. RooSentinel(); RooSentinel(const RooSentinel&). Data Members; protected:. static Bool_t_active. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void activate(); Install atexit handler that calls CleanupRooFitAtExit(); on program termination. RooSentinel(); {}. RooSentinel(const RooSentinel& ); {}. » Last changed: Tue Jun 30 14:35:37 2015 » Last generated: 2015-06-30 14:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooSentinel.html:514,avoid,avoid,514,root/html602/RooSentinel.html,https://root.cern,https://root.cern/root/html602/RooSentinel.html,1,['avoid'],['avoid']
Safety,. RooSentinel. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooSentinel. class RooSentinel. RooSentinel is a special purposes singleton class that terminates; all other RooFit singleton services when the process exists. ; All function RooFit singleton services are created on the heap with; a static wrapper function to avoid the 'static initialization order fiasco'; but are not automatically destroyed at the end of the session. This class; installs an atexit() function that takes care of this; . Function Members (Methods); public:. ~RooSentinel(); static voidactivate(); RooSentinel&operator=(const RooSentinel&). protected:. RooSentinel(); RooSentinel(const RooSentinel&). Data Members; protected:. static Bool_t_active. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void activate(); Install atexit handler that calls CleanupRooFitAtExit(); on program termination. RooSentinel(); {}. RooSentinel(const RooSentinel& ); {}. » Last changed: Tue Sep 8 17:42:26 2015 » Last generated: 2015-09-08 17:42; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooSentinel.html:514,avoid,avoid,514,root/html604/RooSentinel.html,https://root.cern,https://root.cern/root/html604/RooSentinel.html,1,['avoid'],['avoid']
Safety,". See https://github.com/root-project/root/issues/6734 for more details. ; Reimplemented from TBufferFile.; Definition at line 527 of file TBufferSQL.cxx. ◆ WriteFastArray() [14/15]. Int_t TBufferSQL::WriteFastArray ; (; void ** ; startp, . const TClass * ; cl, . Long64_t ; n = 1, . bool ; isPreAlloc = false, . TMemberStreamer * ; s = nullptr . ). finalvirtual . WriteFastArray SQL implementation. ; Reimplemented from TBufferFile.; Definition at line 717 of file TBufferSQL.cxx. ◆ WriteFastArray() [15/15]. void TBufferSQL::WriteFastArray ; (; void * ; start, . const TClass * ; cl, . Long64_t ; n = 1, . TMemberStreamer * ; s = nullptr . ). finalvirtual . WriteFastArray SQL implementation. ; Reimplemented from TBufferFile.; Definition at line 708 of file TBufferSQL.cxx. ◆ WriteFastArrayString(). void TBufferSQL::WriteFastArrayString ; (; const Char_t * ; c, . Long64_t ; n . ). finalvirtual . WriteFastArray SQL implementation. ; NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Reimplemented from TBufferFile.; Definition at line 467 of file TBufferSQL.cxx. ◆ WriteFloat(). void TBufferSQL::WriteFloat ; (; Float_t ; f). finalvirtual . Operator<<. ; Reimplemented from TBufferFile.; Definition at line 202 of file TBufferSQL.cxx. ◆ WriteInt(). void TBufferSQL::WriteInt ; (; Int_t ; i). finalvirtual . Operator<<. ; Reimplemented from TBufferFile.; Definition at line 182 of file TBufferSQL.cxx. ◆ WriteLong(). void TBufferSQL::WriteLong ; (; Long_t ; l). finalvirtual . Operator<<. ; Reimplemented from TBufferFile.; Definition at line 192 of file TBufferSQL.cxx. ◆ WriteLong64(). void TBufferSQL::WriteLong64 ; (; Long64_t ; l). finalvirtual . Operator<<. ; Reimplemented from TBufferFile.; Definition at line 395 of file TBufferSQL.cxx. ◆ WriteShort(). void TBufferSQL::WriteShort ; (; Short_t ; s). finalvirtual . Operator<<. ; Reimple",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBufferSQL.html:57074,abort,aborts,57074,doc/master/classTBufferSQL.html,https://root.cern,https://root.cern/doc/master/classTBufferSQL.html,1,['abort'],['aborts']
Safety,". Set the automatic delete bit. ; This bit is used by TBranchObject::ReadBasket to decide if an object referenced by a TBranchObject must be deleted or not before reading a new entry.; If autodel is true, this existing object will be deleted, a new object created by the default constructor, then read from disk by the streamer.; If autodel is false, the existing object is not deleted. Root assumes that the user is taking care of deleting any internal object or array (this can be done in the streamer). ; Reimplemented in TBranchObject.; Definition at line 2716 of file TBranch.cxx. ◆ SetBasketSize(). void TBranch::SetBasketSize ; (; Int_t ; buffsize). virtual . Set the basket size The function makes sure that the basket size is greater than fEntryOffsetlen. ; Reimplemented in TBranchClones, TBranchElement, and TBranchObject.; Definition at line 2729 of file TBranch.cxx. ◆ SetBufferAddress(). void TBranch::SetBufferAddress ; (; TBuffer * ; buf). virtual . Set address of this branch directly from a TBuffer to avoid streaming. ; Note: We do not take ownership of the buffer. ; Definition at line 2745 of file TBranch.cxx. ◆ SetCompressionAlgorithm(). void TBranch::SetCompressionAlgorithm ; (; Int_t ; algorithm = ROOT::RCompressionSetting::EAlgorithm::kUseGlobal). Set compression algorithm. ; Definition at line 2763 of file TBranch.cxx. ◆ SetCompressionLevel(). void TBranch::SetCompressionLevel ; (; Int_t ; level = ROOT::RCompressionSetting::ELevel::kUseMin). Set compression level. ; Definition at line 2783 of file TBranch.cxx. ◆ SetCompressionSettings(). void TBranch::SetCompressionSettings ; (; Int_t ; settings = ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault). Set compression settings. ; Definition at line 2805 of file TBranch.cxx. ◆ SetEntries(). void TBranch::SetEntries ; (; Long64_t ; entries). virtual . Set the number of entries in this branch. ; Reimplemented in THbookBranch.; Definition at line 2838 of file TBranch.cxx. ◆ SetEntryOffsetLen(). void TBranch:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBranch.html:62335,avoid,avoid,62335,doc/master/classTBranch.html,https://root.cern,https://root.cern/doc/master/classTBranch.html,1,['avoid'],['avoid']
Safety,. Static utility function.Definition TROOT.cxx:3078; TROOT::GetEtcDirstatic const TString & GetEtcDir()Get the sysconfig directory in the installation. Static utility function.Definition TROOT.cxx:3052; TROOT::TROOTTROOT(const TROOT &)=delete; TROOT::GetNclassesInt_t GetNclasses() constGet number of classes.Definition TROOT.cxx:1876; TROOT::GetExtraInterpreterArgsstatic const char **& GetExtraInterpreterArgs()INTERNAL function! Used by rootcling to inject interpreter arguments through a C-interface layer.Definition TROOT.cxx:2962; TROOT::SetMacroPathstatic void SetMacroPath(const char *newpath)Set or extend the macro search path.Definition TROOT.cxx:2788; TROOT::SetSelectedPadvoid SetSelectedPad(TVirtualPad *pad)Definition TROOT.h:333; TROOT::InitThreadsvoid InitThreads()Initialize threads library.Definition TROOT.cxx:2053; TROOT::fUUIDsTProcessUUID * fUUIDsPointer to TProcessID managing TUUIDs.Definition TROOT.h:166; TROOT::fConfigFeaturesTString fConfigFeaturesROOT ./configure detected build features.Definition TROOT.h:112; TROOT::GetFunctionTemplateTFunctionTemplate * GetFunctionTemplate(const char *name)Definition TROOT.cxx:1618; TROOT::fPluginManagerTPluginManager * fPluginManagerKeeps track of plugin library handlers.Definition TROOT.h:169; TROOT::GetGeometryTObject * GetGeometry(const char *name) constReturn pointer to Geometry with name.Definition TROOT.cxx:1747; TROOT::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRecursively remove this object from the list of Cleanups.Definition TROOT.cxx:2498; TROOT::fExecutingMacroBool_t fExecutingMacroTrue while executing a TMacro.Definition TROOT.h:136; TROOT::GetListOfBrowsablesTList * GetListOfBrowsables() constDefinition TROOT.h:258; TROOT::fBuiltDateInt_t fBuiltDateDate of ROOT built.Definition TROOT.h:118; TROOT::fIsWebDisplayBatchBool_t fIsWebDisplayBatchTrue if web widgets are not displayed.Definition TROOT.h:129; TROOT::GetSharedLibDirstatic const TString & GetSharedLibDir()Get the shared libraries ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TROOT_8h_source.html:46674,detect,detected,46674,doc/v632/TROOT_8h_source.html,https://root.cern,https://root.cern/doc/v632/TROOT_8h_source.html,1,['detect'],['detected']
Safety,. Static utility function.Definition TROOT.cxx:3082; TROOT::GetEtcDirstatic const TString & GetEtcDir()Get the sysconfig directory in the installation. Static utility function.Definition TROOT.cxx:3056; TROOT::TROOTTROOT(const TROOT &)=delete; TROOT::GetNclassesInt_t GetNclasses() constGet number of classes.Definition TROOT.cxx:1876; TROOT::GetExtraInterpreterArgsstatic const char **& GetExtraInterpreterArgs()INTERNAL function! Used by rootcling to inject interpreter arguments through a C-interface layer.Definition TROOT.cxx:2966; TROOT::SetMacroPathstatic void SetMacroPath(const char *newpath)Set or extend the macro search path.Definition TROOT.cxx:2788; TROOT::SetSelectedPadvoid SetSelectedPad(TVirtualPad *pad)Definition TROOT.h:333; TROOT::InitThreadsvoid InitThreads()Initialize threads library.Definition TROOT.cxx:2053; TROOT::fUUIDsTProcessUUID * fUUIDsPointer to TProcessID managing TUUIDs.Definition TROOT.h:166; TROOT::fConfigFeaturesTString fConfigFeaturesROOT ./configure detected build features.Definition TROOT.h:112; TROOT::GetFunctionTemplateTFunctionTemplate * GetFunctionTemplate(const char *name)Definition TROOT.cxx:1618; TROOT::fPluginManagerTPluginManager * fPluginManagerKeeps track of plugin library handlers.Definition TROOT.h:169; TROOT::GetGeometryTObject * GetGeometry(const char *name) constReturn pointer to Geometry with name.Definition TROOT.cxx:1747; TROOT::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRecursively remove this object from the list of Cleanups.Definition TROOT.cxx:2498; TROOT::fExecutingMacroBool_t fExecutingMacroTrue while executing a TMacro.Definition TROOT.h:136; TROOT::GetListOfBrowsablesTList * GetListOfBrowsables() constDefinition TROOT.h:258; TROOT::fBuiltDateInt_t fBuiltDateDate of ROOT built.Definition TROOT.h:118; TROOT::fIsWebDisplayBatchBool_t fIsWebDisplayBatchTrue if web widgets are not displayed.Definition TROOT.h:129; TROOT::GetSharedLibDirstatic const TString & GetSharedLibDir()Get the shared libraries ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8h_source.html:46673,detect,detected,46673,doc/master/TROOT_8h_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8h_source.html,1,['detect'],['detected']
Safety,". TAtomicCount. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » THREAD; » TAtomicCount. class TAtomicCount. TAtomicCount. Class providing atomic operations on a long. Setting, getting,; incrementing and decrementing are atomic, thread safe, operations. TAtomicCount a(n);. (n is convertible to long). Effects: Constructs an TAtomicCount with an initial value of n. long(a);. Returns: (long) the current value of a. ++a;. Effects: Atomically increments the value of a.; Returns: nothing. --a;. Effects: Atomically decrements the value of a.; Returns: (long) zero if the new value of a is zero,; unspecified non-zero value otherwise; (usually the new value). a.Set(n);. Effects: Set a to the value n.; Returns: nothing. a.Get();. Returns: (long) the current value of a. Function Members (Methods); public:. TAtomicCount(Long_t v); ~TAtomicCount(); Long_tGet() const; longoperator long() const; voidoperator++(); Long_toperator--(); voidSet(Long_t v). private:. TAtomicCount(const TAtomicCount&); TAtomicCount&operator=(const TAtomicCount&). Data Members; private:. Long_tfCntcounter. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TAtomicCount(const TAtomicCount &). TAtomicCount & operator=(const TAtomicCount& ). explicit TAtomicCount(Long_t v); { }. void operator++(); { ++fCnt; }. Long_t operator--(); { return --fCnt; }. operator long() const; { return fCnt; }. void Set(Long_t v); { fCnt = v; }. Long_t Get() const; { return fCnt; }. » Author: Fons Rademakers 14/11/06 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/thread:$Id: TAtomicCount.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2009-12-07 15:44; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TAtomicCount.html:384,safe,safe,384,root/html526/TAtomicCount.html,https://root.cern,https://root.cern/root/html526/TAtomicCount.html,1,['safe'],['safe']
Safety,". TAtomicCount. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » THREAD; » TAtomicCount. class TAtomicCount. TAtomicCount. Class providing atomic operations on a long. Setting, getting,; incrementing and decrementing are atomic, thread safe, operations. TAtomicCount a(n);. (n is convertible to long). Effects: Constructs an TAtomicCount with an initial value of n. long(a);. Returns: (long) the current value of a. ++a;. Effects: Atomically increments the value of a.; Returns: nothing. --a;. Effects: Atomically decrements the value of a.; Returns: (long) zero if the new value of a is zero,; unspecified non-zero value otherwise; (usually the new value). a.Set(n);. Effects: Set a to the value n.; Returns: nothing. a.Get();. Returns: (long) the current value of a. Function Members (Methods); public:. TAtomicCount(Long_t v); ~TAtomicCount(); Long_tGet() const; longoperator long() const; voidoperator++(); Long_toperator--(); voidSet(Long_t v). private:. TAtomicCount(const TAtomicCount&); TAtomicCount&operator=(const TAtomicCount&). Data Members; private:. Long_tfCntcounter. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TAtomicCount(const TAtomicCount& ). TAtomicCount & operator=(const TAtomicCount& ). explicit TAtomicCount(Long_t v); { }. void operator++(); { ++fCnt; }. Long_t operator--(); { return --fCnt; }. operator long() const; { return fCnt; }. void Set(Long_t v); { fCnt = v; }. Long_t Get() const; { return fCnt; }. » Author: Fons Rademakers 14/11/06 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/thread:$Id: TAtomicCount.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:02; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TAtomicCount.html:384,safe,safe,384,root/html528/TAtomicCount.html,https://root.cern,https://root.cern/root/html528/TAtomicCount.html,1,['safe'],['safe']
Safety,". TAtomicCount. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » THREAD; » TAtomicCount. class TAtomicCount. TAtomicCount. Class providing atomic operations on a long. Setting, getting,; incrementing and decrementing are atomic, thread safe, operations. TAtomicCount a(n);. (n is convertible to long). Effects: Constructs an TAtomicCount with an initial value of n. long(a);. Returns: (long) the current value of a. ++a;. Effects: Atomically increments the value of a.; Returns: nothing. --a;. Effects: Atomically decrements the value of a.; Returns: (long) zero if the new value of a is zero,; unspecified non-zero value otherwise; (usually the new value). a.Set(n);. Effects: Set a to the value n.; Returns: nothing. a.Get();. Returns: (long) the current value of a. Function Members (Methods); public:. TAtomicCount(Long_t v); ~TAtomicCount(); Long_tGet() const; longoperator long() const; voidoperator++(); Long_toperator--(); voidSet(Long_t v). private:. TAtomicCount(const TAtomicCount&); TAtomicCount&operator=(const TAtomicCount&). Data Members; private:. Long_tfCntcounter. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TAtomicCount(const TAtomicCount& ). TAtomicCount & operator=(const TAtomicCount& ). explicit TAtomicCount(Long_t v); { }. void operator++(); { ++fCnt; }. Long_t operator--(); { return --fCnt; }. operator long() const; { return fCnt; }. void Set(Long_t v); { fCnt = v; }. Long_t Get() const; { return fCnt; }. » Author: Fons Rademakers 14/11/06 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/thread:$Id$ » Last generated: 2015-09-08 17:03; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TAtomicCount.html:386,safe,safe,386,root/html534/TAtomicCount.html,https://root.cern,https://root.cern/root/html534/TAtomicCount.html,1,['safe'],['safe']
Safety,". TAtomicCount. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » THREAD; » TAtomicCount. class TAtomicCount. TAtomicCount. Class providing atomic operations on a long. Setting, getting,; incrementing and decrementing are atomic, thread safe, operations. TAtomicCount a(n);. (n is convertible to long). Effects: Constructs an TAtomicCount with an initial value of n. long(a);. Returns: (long) the current value of a. ++a;. Effects: Atomically increments the value of a.; Returns: nothing. --a;. Effects: Atomically decrements the value of a.; Returns: (long) zero if the new value of a is zero,; unspecified non-zero value otherwise; (usually the new value). a.Set(n);. Effects: Set a to the value n.; Returns: nothing. a.Get();. Returns: (long) the current value of a. Function Members (Methods); public:. TAtomicCount(Long_t v); ~TAtomicCount(); Long_tGet() const; longoperator long() const; voidoperator++(); Long_toperator--(); voidSet(Long_t v). private:. TAtomicCount(const TAtomicCount&); TAtomicCount&operator=(const TAtomicCount&). Data Members; private:. Long_tfCntcounter. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TAtomicCount(const TAtomicCount& ). TAtomicCount & operator=(const TAtomicCount& ). explicit TAtomicCount(Long_t v); { }. void operator++(); { ++fCnt; }. Long_t operator--(); { return --fCnt; }. operator long() const; { return fCnt; }. void Set(Long_t v); { fCnt = v; }. Long_t Get() const; { return fCnt; }. » Author: Fons Rademakers 14/11/06 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/thread:$Id: TAtomicCount.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-07-04 15:25; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TAtomicCount.html:386,safe,safe,386,root/html530/TAtomicCount.html,https://root.cern,https://root.cern/root/html530/TAtomicCount.html,1,['safe'],['safe']
Safety,". TAtomicCount. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » THREAD; » TAtomicCount. class TAtomicCount. TAtomicCount. Class providing atomic operations on a long. Setting, getting,; incrementing and decrementing are atomic, thread safe, operations. TAtomicCount a(n);. (n is convertible to long). Effects: Constructs an TAtomicCount with an initial value of n. long(a);. Returns: (long) the current value of a. ++a;. Effects: Atomically increments the value of a.; Returns: nothing. --a;. Effects: Atomically decrements the value of a.; Returns: (long) zero if the new value of a is zero,; unspecified non-zero value otherwise; (usually the new value). a.Set(n);. Effects: Set a to the value n.; Returns: nothing. a.Get();. Returns: (long) the current value of a. Function Members (Methods); public:. TAtomicCount(Long_t v); ~TAtomicCount(); Long_tGet() const; longoperator long() const; voidoperator++(); Long_toperator--(); voidSet(Long_t v). private:. TAtomicCount(const TAtomicCount&); TAtomicCount&operator=(const TAtomicCount&). Data Members; private:. Long_tfCntcounter. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TAtomicCount(const TAtomicCount& ). TAtomicCount & operator=(const TAtomicCount& ). explicit TAtomicCount(Long_t v); { }. void operator++(); { ++fCnt; }. Long_t operator--(); { return --fCnt; }. operator long() const; { return fCnt; }. void Set(Long_t v); { fCnt = v; }. Long_t Get() const; { return fCnt; }. » Author: Fons Rademakers 14/11/06 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/thread:$Id: TAtomicCount.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-11-03 20:10; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TAtomicCount.html:386,safe,safe,386,root/html532/TAtomicCount.html,https://root.cern,https://root.cern/root/html532/TAtomicCount.html,1,['safe'],['safe']
Safety,". TAtomicCount. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » THREAD; » TAtomicCount. class TAtomicCount. TAtomicCountGcc. Class providing atomic operations on a long. Setting, getting,; incrementing and decrementing are atomic, thread safe, operations. This implementation uses GNU libstdc++ v3 atomic primitives, see; http://gcc.gnu.org/onlinedocs/porting/Thread-safety.html. ATTENTION: Don't use this file directly, it is included by; TAtomicCount.h. Function Members (Methods); public:. ~TAtomicCount(); Long_tGet() const; longoperator long() const; voidoperator++(); Long_toperator--(); voidSet(Long_t v); TAtomicCount(Long_t v). private:. TAtomicCount&operator=(const TAtomicCount&); TAtomicCount(const TAtomicCount&). Data Members; private:. _Atomic_wordfCntcounter. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TAtomicCount(const TAtomicCount& ). TAtomicCount & operator=(const TAtomicCount& ). explicit TAtomicCount(Long_t v); { }. void operator++(); { __atomic_add(&fCnt, 1); }. Long_t operator--(); { return __exchange_and_add(&fCnt, -1) - 1; }. operator long() const; { return __exchange_and_add(&fCnt, 0); }. void Set(Long_t v). Long_t Get() const; { return __exchange_and_add(&fCnt, 0); }. » Author: Fons Rademakers 14/11/06 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/thread:$Id$ » Last generated: 2015-06-30 14:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TAtomicCount.html:389,safe,safe,389,root/html602/TAtomicCount.html,https://root.cern,https://root.cern/root/html602/TAtomicCount.html,2,['safe'],"['safe', 'safety']"
Safety,". TAtomicCount. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » THREAD; » TAtomicCount. class TAtomicCount. TAtomicCountGcc. Class providing atomic operations on a long. Setting, getting,; incrementing and decrementing are atomic, thread safe, operations. This implementation uses GNU libstdc++ v3 atomic primitives, see; http://gcc.gnu.org/onlinedocs/porting/Thread-safety.html. ATTENTION: Don't use this file directly, it is included by; TAtomicCount.h. Function Members (Methods); public:. ~TAtomicCount(); Long_tGet() const; longoperator long() const; voidoperator++(); Long_toperator--(); voidSet(Long_t v); TAtomicCount(Long_t v). private:. TAtomicCount&operator=(const TAtomicCount&); TAtomicCount(const TAtomicCount&). Data Members; private:. _Atomic_wordfCntcounter. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TAtomicCount(const TAtomicCount& ). TAtomicCount & operator=(const TAtomicCount& ). explicit TAtomicCount(Long_t v); { }. void operator++(); { __atomic_add(&fCnt, 1); }. Long_t operator--(); { return __exchange_and_add(&fCnt, -1) - 1; }. operator long() const; { return __exchange_and_add(&fCnt, 0); }. void Set(Long_t v). Long_t Get() const; { return __exchange_and_add(&fCnt, 0); }. » Author: Fons Rademakers 14/11/06 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/thread:$Id$ » Last generated: 2015-09-08 17:43; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TAtomicCount.html:389,safe,safe,389,root/html604/TAtomicCount.html,https://root.cern,https://root.cern/root/html604/TAtomicCount.html,2,['safe'],"['safe', 'safety']"
Safety,". TEnv. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TEnv. class TEnv: public TObject. TEnv. The TEnv class reads config files, by default named .rootrc. Three; types of config files are read: global, user and local files. The; global file is $ROOTSYS/etc/system<name> (or ROOTETCDIR/system<name>); the user file is $HOME/<name> and the local file is ./<name>.; By setting the shell variable ROOTENV_NO_HOME=1 the reading of; the $HOME/<name> resource file will be skipped. This might be useful; in case the home directory resides on an automounted remote file; system and one wants to avoid this file system from being mounted. The format of the .rootrc file is similar to the .Xdefaults format:. [+]<SystemName>.<RootName|ProgName>.<name>[(type)]: <value>. Where <SystemName> is either Unix, WinNT, MacOS or Vms,; <RootName> the name as given in the TApplication ctor (or ""RootApp""; in case no explicit TApplication derived object was created),; <ProgName> the current program name and <name> the resource name,; with optionally a type specification. <value> can be either a; string, an integer, a float/double or a boolean with the values; TRUE, FALSE, ON, OFF, YES, NO, OK, NOT. Booleans will be returned as; an integer 0 or 1. The options [+] allows the concatenation of; values to the same resouce name. E.g.:. Unix.Rint.Root.DynamicPath: .:$(ROOTSYS)/lib:~/lib; myapp.Root.Debug: FALSE; TH.Root.Debug: YES; *.Root.MemStat: 1. <SystemName> and <ProgName> or <RootName> may be the wildcard ""*"".; A # in the first column starts comment line. Note that the environment variables (like $ROOTSYS) need to be; surrounded in parentheses in order to be expanded. For the currently defined resources (and their default values) see; $ROOTSYS/etc/system.rootrc. Note that the .rootrc config files contain the config for ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEnv.html:772,avoid,avoid,772,root/html534/TEnv.html,https://root.cern,https://root.cern/root/html534/TEnv.html,3,['avoid'],['avoid']
Safety,". TEnv. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TEnv. class TEnv: public TObject. TEnv. The TEnv class reads config files, by default named .rootrc. Three; types of config files are read: global, user and local files. The; global file is $ROOTSYS/etc/system<name> (or ROOTETCDIR/system<name>); the user file is $HOME/<name> and the local file is ./<name>.; By setting the shell variable ROOTENV_NO_HOME=1 the reading of; the $HOME/<name> resource file will be skipped. This might be useful; in case the home directory resides on an automounted remote file; system and one wants to avoid this file system from being mounted. The format of the .rootrc file is similar to the .Xdefaults format:. [+]<SystemName>.<RootName|ProgName>.<name>[(type)]: <value>. Where <SystemName> is either Unix, WinNT, MacOS or Vms,; <RootName> the name as given in the TApplication ctor (or ""RootApp""; in case no explicit TApplication derived object was created),; <ProgName> the current program name and <name> the resource name,; with optionally a type specification. <value> can be either a; string, an integer, a float/double or a boolean with the values; TRUE, FALSE, ON, OFF, YES, NO, OK, NOT. Booleans will be returned as; an integer 0 or 1. The options [+] allows the concatenation of; values to the same resouce name. E.g.:. Unix.Rint.Root.DynamicPath: .:$ROOTSYS/lib:~/lib; myapp.Root.Debug: FALSE; TH.Root.Debug: YES; *.Root.MemStat: 1. <SystemName> and <ProgName> or <RootName> may be the wildcard ""*"".; A # in the first column starts comment line. For the currently defined resources (and their default values) see; $ROOTSYS/etc/system.rootrc. Note that the .rootrc config files contain the config for all ROOT; based applications. To add new entries to a TEnv:; TEnv env("".myfile"");; env.SetValue(""myname"",""value"");; e",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEnv.html:772,avoid,avoid,772,root/html528/TEnv.html,https://root.cern,https://root.cern/root/html528/TEnv.html,3,['avoid'],['avoid']
Safety,". TEnvRec. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TEnvRec. class TEnvRec: public TObject. TEnv. The TEnv class reads config files, by default named .rootrc. Three; types of config files are read: global, user and local files. The; global file is $ROOTSYS/etc/system<name> (or ROOTETCDIR/system<name>); the user file is $HOME/<name> and the local file is ./<name>.; By setting the shell variable ROOTENV_NO_HOME=1 the reading of; the $HOME/<name> resource file will be skipped. This might be useful; in case the home directory resides on an automounted remote file; system and one wants to avoid this file system from being mounted. The format of the .rootrc file is similar to the .Xdefaults format:. [+]<SystemName>.<RootName|ProgName>.<name>[(type)]: <value>. Where <SystemName> is either Unix, WinNT, MacOS or Vms,; <RootName> the name as given in the TApplication ctor (or ""RootApp""; in case no explicit TApplication derived object was created),; <ProgName> the current program name and <name> the resource name,; with optionally a type specification. <value> can be either a; string, an integer, a float/double or a boolean with the values; TRUE, FALSE, ON, OFF, YES, NO, OK, NOT. Booleans will be returned as; an integer 0 or 1. The options [+] allows the concatenation of; values to the same resouce name. E.g.:. Unix.Rint.Root.DynamicPath: .:$ROOTSYS/lib:~/lib; myapp.Root.Debug: FALSE; TH.Root.Debug: YES; *.Root.MemStat: 1. <SystemName> and <ProgName> or <RootName> may be the wildcard ""*"".; A # in the first column starts comment line. For the currently defined resources (and their default values) see; $ROOTSYS/etc/system.rootrc. Note that the .rootrc config files contain the config for all ROOT; based applications. Function Members (Methods); public:. TEnvRec(); TEnvRec(const TEnvRec&); ~TEnvRec(); voidTObject::Abstra",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEnvRec.html:755,avoid,avoid,755,root/html528/TEnvRec.html,https://root.cern,https://root.cern/root/html528/TEnvRec.html,1,['avoid'],['avoid']
Safety,". TEnvRec. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TEnvRec. class TEnvRec: public TObject. TEnv. The TEnv class reads config files, by default named .rootrc. Three; types of config files are read: global, user and local files. The; global file is $ROOTSYS/etc/system<name> (or ROOTETCDIR/system<name>); the user file is $HOME/<name> and the local file is ./<name>.; By setting the shell variable ROOTENV_NO_HOME=1 the reading of; the $HOME/<name> resource file will be skipped. This might be useful; in case the home directory resides on an automounted remote file; system and one wants to avoid this file system from being mounted. The format of the .rootrc file is similar to the .Xdefaults format:. [+]<SystemName>.<RootName|ProgName>.<name>[(type)]: <value>. Where <SystemName> is either Unix, WinNT, MacOS or Vms,; <RootName> the name as given in the TApplication ctor (or ""RootApp""; in case no explicit TApplication derived object was created),; <ProgName> the current program name and <name> the resource name,; with optionally a type specification. <value> can be either a; string, an integer, a float/double or a boolean with the values; TRUE, FALSE, ON, OFF, YES, NO, OK, NOT. Booleans will be returned as; an integer 0 or 1. The options [+] allows the concatenation of; values to the same resouce name. E.g.:. Unix.Rint.Root.DynamicPath: .:$ROOTSYS/lib:~/lib; myapp.Root.Debug: FALSE; TH.Root.Debug: YES; *.Root.MemStat: 1. <SystemName> and <ProgName> or <RootName> may be the wildcard ""*"".; A # in the first column starts comment line. For the currently defined resources (and their default values) see; $ROOTSYS/etc/system.rootrc. Note that the .rootrc config files contain the config for all ROOT; based applications. Function Members (Methods); public:. TEnvRec(); TEnvRec(const TEnvRec&); ~TEnvRec(); voidTObject::Abst",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TEnvRec.html:757,avoid,avoid,757,root/html530/TEnvRec.html,https://root.cern,https://root.cern/root/html530/TEnvRec.html,3,['avoid'],['avoid']
Safety,". TEnvRec. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TEnvRec. class TEnvRec: public TObject. TEnv. The TEnv class reads config files, by default named .rootrc. Three; types of config files are read: global, user and local files. The; global file is $ROOTSYS/etc/system<name> (or ROOTETCDIR/system<name>); the user file is $HOME/<name> and the local file is ./<name>.; By setting the shell variable ROOTENV_NO_HOME=1 the reading of; the $HOME/<name> resource file will be skipped. This might be useful; in case the home directory resides on an automounted remote file; system and one wants to avoid this file system from being mounted. The format of the .rootrc file is similar to the .Xdefaults format:. [+]<SystemName>.<RootName|ProgName>.<name>[(type)]: <value>. Where <SystemName> is either Unix, WinNT, MacOS or Vms,; <RootName> the name as given in the TApplication ctor (or ""RootApp""; in case no explicit TApplication derived object was created),; <ProgName> the current program name and <name> the resource name,; with optionally a type specification. <value> can be either a; string, an integer, a float/double or a boolean with the values; TRUE, FALSE, ON, OFF, YES, NO, OK, NOT. Booleans will be returned as; an integer 0 or 1. The options [+] allows the concatenation of; values to the same resouce name. E.g.:. Unix.Rint.Root.DynamicPath: .:$(ROOTSYS)/lib:~/lib; myapp.Root.Debug: FALSE; TH.Root.Debug: YES; *.Root.MemStat: 1. <SystemName> and <ProgName> or <RootName> may be the wildcard ""*"".; A # in the first column starts comment line. Note that the environment variables (like $ROOTSYS) need to be; surrounded in parentheses in order to be expanded. For the currently defined resources (and their default values) see; $ROOTSYS/etc/system.rootrc. Note that the .rootrc config files contain the co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEnvRec.html:781,avoid,avoid,781,root/html602/TEnvRec.html,https://root.cern,https://root.cern/root/html602/TEnvRec.html,2,['avoid'],['avoid']
Safety,". TEveGeoManagerHolder. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » EVE; » TEveGeoManagerHolder. class TEveGeoManagerHolder. Exception safe wrapper for setting gGeoManager.; Functionality to lock-unlock via setting of a static lock in; TGeoManager should be added (new feature of TGeoManager). Function Members (Methods); public:. TEveGeoManagerHolder(TGeoManager* new_gmgr = 0, Int_t n_seg = 0); virtual~TEveGeoManagerHolder(); static TClass*Class(); virtual TClass*IsA() const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. TEveGeoManagerHolder(const TEveGeoManagerHolder&); TEveGeoManagerHolder&operator=(const TEveGeoManagerHolder&). Data Members; private:. TGeoManager*fManager; Int_tfNSegments. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveGeoManagerHolder(TGeoManager* new_gmgr = 0, Int_t n_seg = 0); Constructor.; If n_seg is specified and larger than 2, the new geo-manager's; NSegments is set to this value. ~TEveGeoManagerHolder(); Destructor. TEvePadHolder& operator=(const TEveGeoManagerHolder& ). TEveGeoManagerHolder(const TEveGeoManagerHolder& ). » Last changed: root/eve:$Id: TEveUtil.h 36373 2010-10-19 17:43:35Z matevz $ » Last generated: 2010-10-20 08:46; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEveGeoManagerHolder.html:316,safe,safe,316,root/html528/TEveGeoManagerHolder.html,https://root.cern,https://root.cern/root/html528/TEveGeoManagerHolder.html,1,['safe'],['safe']
Safety,". TEveGeoManagerHolder. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » EVE; » TEveGeoManagerHolder. class TEveGeoManagerHolder. Exception safe wrapper for setting gGeoManager.; Functionality to lock-unlock via setting of a static lock in; TGeoManager should be added (new feature of TGeoManager). Function Members (Methods); public:. TEveGeoManagerHolder(TGeoManager* new_gmgr = 0, Int_t n_seg = 0); virtual~TEveGeoManagerHolder(); static TClass*Class(); virtual TClass*IsA() const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. TEveGeoManagerHolder(const TEveGeoManagerHolder&); TEveGeoManagerHolder&operator=(const TEveGeoManagerHolder&). Data Members; private:. TGeoManager*fManager; Int_tfNSegments. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveGeoManagerHolder(TGeoManager* new_gmgr = 0, Int_t n_seg = 0); Constructor.; If n_seg is specified and larger than 2, the new geo-manager's; NSegments is set to this value. ~TEveGeoManagerHolder(); Destructor. TEvePadHolder& operator=(const TEveGeoManagerHolder& ). TEveGeoManagerHolder(const TEveGeoManagerHolder& ). » Last changed: root/eve:$Id: TEveUtil.h 36373 2010-10-19 17:43:35Z matevz $ » Last generated: 2011-07-04 15:26; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TEveGeoManagerHolder.html:316,safe,safe,316,root/html530/TEveGeoManagerHolder.html,https://root.cern,https://root.cern/root/html530/TEveGeoManagerHolder.html,1,['safe'],['safe']
Safety,". TEveGeoManagerHolder. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » EVE; » TEveGeoManagerHolder. class TEveGeoManagerHolder. Exception safe wrapper for setting gGeoManager.; Functionality to lock-unlock via setting of a static lock in; TGeoManager should be added (new feature of TGeoManager). Function Members (Methods); public:. TEveGeoManagerHolder(TGeoManager* new_gmgr = 0, Int_t n_seg = 0); virtual~TEveGeoManagerHolder(); static TClass*Class(); virtual TClass*IsA() const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. TEveGeoManagerHolder(const TEveGeoManagerHolder&); TEveGeoManagerHolder&operator=(const TEveGeoManagerHolder&). Data Members; private:. TGeoManager*fManager; Int_tfNSegments. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveGeoManagerHolder(TGeoManager* new_gmgr = 0, Int_t n_seg = 0); Constructor.; If n_seg is specified and larger than 2, the new geo-manager's; NSegments is set to this value. ~TEveGeoManagerHolder(); Destructor. TEvePadHolder& operator=(const TEveGeoManagerHolder& ). TEveGeoManagerHolder(const TEveGeoManagerHolder& ). » Last changed: root/eve:$Id: TEveUtil.h 36373 2010-10-19 17:43:35Z matevz $ » Last generated: 2011-11-03 20:12; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEveGeoManagerHolder.html:316,safe,safe,316,root/html532/TEveGeoManagerHolder.html,https://root.cern,https://root.cern/root/html532/TEveGeoManagerHolder.html,1,['safe'],['safe']
Safety,". TEveGeoManagerHolder. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » EVE; » TEveGeoManagerHolder. class TEveGeoManagerHolder. Exception safe wrapper for setting gGeoManager.; Functionality to lock-unlock via setting of a static lock in; TGeoManager should be added (new feature of TGeoManager). Function Members (Methods); public:. TEveGeoManagerHolder(TGeoManager* new_gmgr = 0, Int_t n_seg = 0); virtual~TEveGeoManagerHolder(); static TClass*Class(); virtual TClass*IsA() const; virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). private:. TEveGeoManagerHolder(const TEveGeoManagerHolder&); TEveGeoManagerHolder&operator=(const TEveGeoManagerHolder&). Data Members; private:. TGeoManager*fManager; Int_tfNSegments. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveGeoManagerHolder(TGeoManager* new_gmgr = 0, Int_t n_seg = 0); Constructor.; If n_seg is specified and larger than 2, the new geo-manager's; NSegments is set to this value. ~TEveGeoManagerHolder(); Destructor. TEvePadHolder& operator=(const TEveGeoManagerHolder& ). TEveGeoManagerHolder(const TEveGeoManagerHolder& ). » Last changed: root/eve:$Id$ » Last generated: 2015-03-13 19:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEveGeoManagerHolder.html:316,safe,safe,316,root/html534/TEveGeoManagerHolder.html,https://root.cern,https://root.cern/root/html534/TEveGeoManagerHolder.html,1,['safe'],['safe']
Safety,". TEveGeoManagerHolder. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » EVE; » TEveGeoManagerHolder. class TEveGeoManagerHolder. Exception safe wrapper for setting gGeoManager.; Functionality to lock-unlock via setting of a static lock in; TGeoManager should be added (new feature of TGeoManager). Function Members (Methods); public:. virtual~TEveGeoManagerHolder(); static TClass*Class(); virtual TClass*IsA() const; virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TEveGeoManagerHolder(TGeoManager* new_gmgr = 0, Int_t n_seg = 0). private:. TEveGeoManagerHolder&operator=(const TEveGeoManagerHolder&); TEveGeoManagerHolder(const TEveGeoManagerHolder&). Data Members; private:. TGeoManager*fManager; Int_tfNSegments. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveGeoManagerHolder(TGeoManager* new_gmgr = 0, Int_t n_seg = 0); Constructor.; If n_seg is specified and larger than 2, the new geo-manager's; NSegments is set to this value. ~TEveGeoManagerHolder(); Destructor. TEvePadHolder& operator=(const TEveGeoManagerHolder& ). TEveGeoManagerHolder(const TEveGeoManagerHolder& ). » Last changed: root/eve:$Id$ » Last generated: 2015-06-02 15:43; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TEveGeoManagerHolder.html:316,safe,safe,316,root/html604/TEveGeoManagerHolder.html,https://root.cern,https://root.cern/root/html604/TEveGeoManagerHolder.html,1,['safe'],['safe']
Safety,". TEveGeoManagerHolder. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » EVE; » TEveGeoManagerHolder. class TEveGeoManagerHolder. Exception safe wrapper for setting gGeoManager.; Functionality to lock-unlock via setting of a static lock in; TGeoManager should be added (new feature of TGeoManager). Function Members (Methods); public:. virtual~TEveGeoManagerHolder(); static TClass*Class(); virtual TClass*IsA() const; virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TEveGeoManagerHolder(TGeoManager* new_gmgr = 0, Int_t n_seg = 0). private:. TEveGeoManagerHolder&operator=(const TEveGeoManagerHolder&); TEveGeoManagerHolder(const TEveGeoManagerHolder&). Data Members; private:. TGeoManager*fManager; Int_tfNSegments. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveGeoManagerHolder(TGeoManager* new_gmgr = 0, Int_t n_seg = 0); Constructor.; If n_seg is specified and larger than 2, the new geo-manager's; NSegments is set to this value. ~TEveGeoManagerHolder(); Destructor. TEvePadHolder& operator=(const TEveGeoManagerHolder& ). TEveGeoManagerHolder(const TEveGeoManagerHolder& ). » Last changed: root/eve:$Id$ » Last generated: 2015-06-30 14:45; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEveGeoManagerHolder.html:316,safe,safe,316,root/html602/TEveGeoManagerHolder.html,https://root.cern,https://root.cern/root/html602/TEveGeoManagerHolder.html,1,['safe'],['safe']
Safety,". TEvePadHolder. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » EVE; » TEvePadHolder. class TEvePadHolder. Exception safe wrapper for setting gPad.; Optionally calls gPad->Modified()/Update() in destructor. Function Members (Methods); public:. TEvePadHolder(Bool_t modify_update_p, TVirtualPad* new_pad = 0, Int_t subpad = 0); virtual~TEvePadHolder(); static TClass*Class(); virtual TClass*IsA() const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. TEvePadHolder(const TEvePadHolder&); TEvePadHolder&operator=(const TEvePadHolder&). Data Members; private:. Bool_tfModifyUpdateP; TVirtualPad*fOldPad. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEvePadHolder(Bool_t modify_update_p, TVirtualPad* new_pad = 0, Int_t subpad = 0); Constructor. ~TEvePadHolder(); Destructor. TEvePadHolder(const TEvePadHolder& ). TEvePadHolder& operator=(const TEvePadHolder& ). » Last changed: root/eve:$Id: TEveUtil.h 36373 2010-10-19 17:43:35Z matevz $ » Last generated: 2010-10-20 08:46; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEvePadHolder.html:295,safe,safe,295,root/html528/TEvePadHolder.html,https://root.cern,https://root.cern/root/html528/TEvePadHolder.html,1,['safe'],['safe']
Safety,". TEvePadHolder. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » EVE; » TEvePadHolder. class TEvePadHolder. Exception safe wrapper for setting gPad.; Optionally calls gPad->Modified()/Update() in destructor. Function Members (Methods); public:. TEvePadHolder(Bool_t modify_update_p, TVirtualPad* new_pad = 0, Int_t subpad = 0); virtual~TEvePadHolder(); static TClass*Class(); virtual TClass*IsA() const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. TEvePadHolder(const TEvePadHolder&); TEvePadHolder&operator=(const TEvePadHolder&). Data Members; private:. Bool_tfModifyUpdateP; TVirtualPad*fOldPad. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEvePadHolder(Bool_t modify_update_p, TVirtualPad* new_pad = 0, Int_t subpad = 0); Constructor. ~TEvePadHolder(); Destructor. TEvePadHolder(const TEvePadHolder& ). TEvePadHolder& operator=(const TEvePadHolder& ). » Last changed: root/eve:$Id: TEveUtil.h 36373 2010-10-19 17:43:35Z matevz $ » Last generated: 2011-07-04 15:27; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TEvePadHolder.html:295,safe,safe,295,root/html530/TEvePadHolder.html,https://root.cern,https://root.cern/root/html530/TEvePadHolder.html,1,['safe'],['safe']
Safety,". TEvePadHolder. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » EVE; » TEvePadHolder. class TEvePadHolder. Exception safe wrapper for setting gPad.; Optionally calls gPad->Modified()/Update() in destructor. Function Members (Methods); public:. TEvePadHolder(Bool_t modify_update_p, TVirtualPad* new_pad = 0, Int_t subpad = 0); virtual~TEvePadHolder(); static TClass*Class(); virtual TClass*IsA() const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. TEvePadHolder(const TEvePadHolder&); TEvePadHolder&operator=(const TEvePadHolder&). Data Members; private:. Bool_tfModifyUpdateP; TVirtualPad*fOldPad. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEvePadHolder(Bool_t modify_update_p, TVirtualPad* new_pad = 0, Int_t subpad = 0); Constructor. ~TEvePadHolder(); Destructor. TEvePadHolder(const TEvePadHolder& ). TEvePadHolder& operator=(const TEvePadHolder& ). » Last changed: root/eve:$Id: TEveUtil.h 36373 2010-10-19 17:43:35Z matevz $ » Last generated: 2011-11-03 20:12; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEvePadHolder.html:295,safe,safe,295,root/html532/TEvePadHolder.html,https://root.cern,https://root.cern/root/html532/TEvePadHolder.html,1,['safe'],['safe']
Safety,". TEvePadHolder. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » EVE; » TEvePadHolder. class TEvePadHolder. Exception safe wrapper for setting gPad.; Optionally calls gPad->Modified()/Update() in destructor. Function Members (Methods); public:. TEvePadHolder(Bool_t modify_update_p, TVirtualPad* new_pad = 0, Int_t subpad = 0); virtual~TEvePadHolder(); static TClass*Class(); virtual TClass*IsA() const; virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). private:. TEvePadHolder(const TEvePadHolder&); TEvePadHolder&operator=(const TEvePadHolder&). Data Members; private:. Bool_tfModifyUpdateP; TVirtualPad*fOldPad. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEvePadHolder(Bool_t modify_update_p, TVirtualPad* new_pad = 0, Int_t subpad = 0); Constructor. ~TEvePadHolder(); Destructor. TEvePadHolder(const TEvePadHolder& ). TEvePadHolder& operator=(const TEvePadHolder& ). » Last changed: root/eve:$Id$ » Last generated: 2015-03-13 19:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEvePadHolder.html:295,safe,safe,295,root/html534/TEvePadHolder.html,https://root.cern,https://root.cern/root/html534/TEvePadHolder.html,1,['safe'],['safe']
Safety,". TEvePadHolder. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » EVE; » TEvePadHolder. class TEvePadHolder. Exception safe wrapper for setting gPad.; Optionally calls gPad->Modified()/Update() in destructor. Function Members (Methods); public:. virtual~TEvePadHolder(); static TClass*Class(); virtual TClass*IsA() const; virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TEvePadHolder(Bool_t modify_update_p, TVirtualPad* new_pad = 0, Int_t subpad = 0). private:. TEvePadHolder&operator=(const TEvePadHolder&); TEvePadHolder(const TEvePadHolder&). Data Members; private:. Bool_tfModifyUpdateP; TVirtualPad*fOldPad. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEvePadHolder(Bool_t modify_update_p, TVirtualPad* new_pad = 0, Int_t subpad = 0); Constructor. ~TEvePadHolder(); Destructor. TEvePadHolder(const TEvePadHolder& ). TEvePadHolder& operator=(const TEvePadHolder& ). » Last changed: root/eve:$Id$ » Last generated: 2015-06-02 15:44; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TEvePadHolder.html:295,safe,safe,295,root/html604/TEvePadHolder.html,https://root.cern,https://root.cern/root/html604/TEvePadHolder.html,1,['safe'],['safe']
Safety,". TEvePadHolder. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » EVE; » TEvePadHolder. class TEvePadHolder. Exception safe wrapper for setting gPad.; Optionally calls gPad->Modified()/Update() in destructor. Function Members (Methods); public:. virtual~TEvePadHolder(); static TClass*Class(); virtual TClass*IsA() const; virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TEvePadHolder(Bool_t modify_update_p, TVirtualPad* new_pad = 0, Int_t subpad = 0). private:. TEvePadHolder&operator=(const TEvePadHolder&); TEvePadHolder(const TEvePadHolder&). Data Members; private:. Bool_tfModifyUpdateP; TVirtualPad*fOldPad. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEvePadHolder(Bool_t modify_update_p, TVirtualPad* new_pad = 0, Int_t subpad = 0); Constructor. ~TEvePadHolder(); Destructor. TEvePadHolder(const TEvePadHolder& ). TEvePadHolder& operator=(const TEvePadHolder& ). » Last changed: root/eve:$Id$ » Last generated: 2015-06-30 14:45; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEvePadHolder.html:295,safe,safe,295,root/html602/TEvePadHolder.html,https://root.cern,https://root.cern/root/html602/TEvePadHolder.html,1,['safe'],['safe']
Safety,". TFFTComplexReal. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » FFTW; » TFFTComplexReal. class TFFTComplexReal: public TVirtualFFT. TFFTComplexReal. One of the interface classes to the FFTW package, can be used directly; or via the TVirtualFFT class. Only the basic interface of FFTW is implemented. Computes the inverse of the real-to-complex transforms (class TFFTRealComplex); taking complex input (storing the non-redundant half of a logically Hermitian array); to real output (see FFTW manual for more details). How to use it:; 1) Create an instance of TFFTComplexReal - this will allocate input and output; arrays (unless an in-place transform is specified); 2) Run the Init() function with the desired flags and settings; 3) Set the data (via SetPoints(), SetPoint() or SetPointComplex() functions); 4) Run the Transform() function; 5) Get the output (via GetPoints(), GetPoint() or GetPointReal() functions); 6) Repeat steps 3)-5) as needed. For a transform of the same size, but with different flags, rerun the Init(); function and continue with steps 3)-5); NOTE: 1) running Init() function will overwrite the input array! Don't set any data; before running the Init() function; 2) FFTW computes unnormalized transform, so doing a transform followed by; its inverse will lead to the original array scaled by the transform size. 3) In Complex to Real transform the input array is destroyed. It cannot then; be retrieved when using the Get's methods. Function Members (Methods); public:. TFFTComplexReal(); TFFTComplexReal(const TFFTComplexReal&); TFFTComplexReal(Int_t n, Bool_t inPlace); TFFTComplexReal(Int_t ndim, Int_t* n, Bool_t inPlace); virtual~TFFTComplexReal(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrow",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFFTComplexReal.html:596,redund,redundant,596,root/html528/TFFTComplexReal.html,https://root.cern,https://root.cern/root/html528/TFFTComplexReal.html,4,['redund'],['redundant']
Safety,". TFFTComplexReal. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » FFTW; » TFFTComplexReal. class TFFTComplexReal: public TVirtualFFT. TFFTComplexReal. One of the interface classes to the FFTW package, can be used directly; or via the TVirtualFFT class. Only the basic interface of FFTW is implemented. Computes the inverse of the real-to-complex transforms (class TFFTRealComplex); taking complex input (storing the non-redundant half of a logically Hermitian array); to real output (see FFTW manual for more details). How to use it:; 1) Create an instance of TFFTComplexReal - this will allocate input and output; arrays (unless an in-place transform is specified); 2) Run the Init() function with the desired flags and settings; 3) Set the data (via SetPoints(), SetPoint() or SetPointComplex() functions); 4) Run the Transform() function; 5) Get the output (via GetPoints(), GetPoint() or GetPointReal() functions); 6) Repeat steps 3)-5) as needed. For a transform of the same size, but with different flags, rerun the Init(); function and continue with steps 3)-5); NOTE: 1) running Init() function will overwrite the input array! Don't set any data; before running the Init() function; 2) FFTW computes unnormalized transform, so doing a transform followed by; its inverse will lead to the original array scaled by the transform size. 3) In Complex to Real transform the input array is destroyed. It cannot then; be retrieved when using the Get's methods. Function Members (Methods); public:. virtual~TFFTComplexReal(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TFFTComplexReal.html:596,redund,redundant,596,root/html602/TFFTComplexReal.html,https://root.cern,https://root.cern/root/html602/TFFTComplexReal.html,2,['redund'],['redundant']
Safety,". TFileCacheRead. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » IO; » IO; » TFileCacheRead. class TFileCacheRead: public TObject. TFileCacheRead : a cache when reading files over the network. A caching system to speed up network I/O, i.e. when there is; no operating system caching support (like the buffer cache for; local disk I/O). The cache makes sure that every I/O is done with; a (large) fixed length buffer thereby avoiding many small I/O's.; Currently the read cache system is used by the classes TNetFile,; TXNetFile and TWebFile (via TFile::ReadBuffers()). When processing TTree, TChain, a specialized class TTreeCache that; derives from this class is automatically created. Function Members (Methods); public:. TFileCacheRead(); TFileCacheRead(TFile* file, Int_t buffersize); virtual~TFileCacheRead(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddBranch(TBranch*, Bool_t = kFALSE); virtual voidAddBranch(const char*, Bool_t = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* err",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFileCacheRead.html:592,avoid,avoiding,592,root/html528/TFileCacheRead.html,https://root.cern,https://root.cern/root/html528/TFileCacheRead.html,3,['avoid'],['avoiding']
Safety,". TFileCacheRead. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » IO; » IO; » TFileCacheRead. class TFileCacheRead: public TObject. TFileCacheRead : a cache when reading files over the network. A caching system to speed up network I/O, i.e. when there is; no operating system caching support (like the buffer cache for; local disk I/O). The cache makes sure that every I/O is done with; a (large) fixed length buffer thereby avoiding many small I/O's.; Currently the read cache system is used by the classes TNetFile,; TXNetFile and TWebFile (via TFile::ReadBuffers()). When processing TTree, TChain, a specialized class TTreeCache that; derives from this class is automatically created. Function Members (Methods); public:. TFileCacheRead(); TFileCacheRead(TFile* file, Int_t buffersize, TObject* tree = 0); virtual~TFileCacheRead(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddBranch(TBranch*, Bool_t = kFALSE); virtual voidAddBranch(const char*, Bool_t = kFALSE); virtual voidAddNoCacheBytesRead(Long64_t len); virtual voidAddNoCacheReadCalls(Int_t reads); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* option = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TFileCacheRead.html:592,avoid,avoiding,592,root/html534/TFileCacheRead.html,https://root.cern,https://root.cern/root/html534/TFileCacheRead.html,1,['avoid'],['avoiding']
Safety,". TFileCacheRead. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » IO; » IO; » TFileCacheRead. class TFileCacheRead: public TObject. TFileCacheRead : a cache when reading files over the network. A caching system to speed up network I/O, i.e. when there is; no operating system caching support (like the buffer cache for; local disk I/O). The cache makes sure that every I/O is done with; a (large) fixed length buffer thereby avoiding many small I/O's.; Currently the read cache system is used by the classes TNetFile,; TXNetFile and TWebFile (via TFile::ReadBuffers()). When processing TTree, TChain, a specialized class TTreeCache that; derives from this class is automatically created. Function Members (Methods); public:. virtual~TFileCacheRead(); voidTObject::AbstractMethod(const char* method) const; virtual Int_tAddBranch(TBranch*, Bool_t = kFALSE); virtual Int_tAddBranch(const char*, Bool_t = kFALSE); virtual voidAddNoCacheBytesRead(Long64_t len); virtual voidAddNoCacheReadCalls(Int_t reads); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* option = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TFileCacheRead.html:592,avoid,avoiding,592,root/html604/TFileCacheRead.html,https://root.cern,https://root.cern/root/html604/TFileCacheRead.html,1,['avoid'],['avoiding']
Safety,". TFileCacheRead. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » IO; » IO; » TFileCacheRead. class TFileCacheRead: public TObject. TFileCacheRead : a cache when reading files over the network. A caching system to speed up network I/O, i.e. when there is; no operating system caching support (like the buffer cache for; local disk I/O). The cache makes sure that every I/O is done with; a (large) fixed length buffer thereby avoiding many small I/O's.; Currently the read cache system is used by the classes TNetFile,; TXNetFile and TWebFile (via TFile::ReadBuffers()). When processing TTree, TChain, a specialized class TTreeCache that; derives from this class is automatically created. Function Members (Methods); public:. virtual~TFileCacheRead(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddBranch(TBranch*, Bool_t = kFALSE); virtual voidAddBranch(const char*, Bool_t = kFALSE); virtual voidAddNoCacheBytesRead(Long64_t len); virtual voidAddNoCacheReadCalls(Int_t reads); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* option = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TFileCacheRead.html:592,avoid,avoiding,592,root/html602/TFileCacheRead.html,https://root.cern,https://root.cern/root/html602/TFileCacheRead.html,1,['avoid'],['avoiding']
Safety,". TFileCacheWrite. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » IO; » IO; » TFileCacheWrite. class TFileCacheWrite: public TObject. TFileCacheWrite : a cache when writing files over the network. A caching system to speed up network I/O, i.e. when there is; no operating system caching support (like the buffer cache for; local disk I/O). The cache makes sure that every I/O is done with; a (large) fixed length buffer thereby avoiding many small I/O's.; Currently the write cache system is used by the classes TNetFile,; TXNetFile and TWebFile (via TFile::WriteBuffers()). The write cache is automatically created when writing a remote file; (created in TFile::Open()). Function Members (Methods); public:. TFileCacheWrite(); TFileCacheWrite(TFile* file, Int_t buffersize); virtual~TFileCacheWrite(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::E",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFileCacheWrite.html:596,avoid,avoiding,596,root/html528/TFileCacheWrite.html,https://root.cern,https://root.cern/root/html528/TFileCacheWrite.html,4,['avoid'],['avoiding']
Safety,". TFileCacheWrite. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » IO; » IO; » TFileCacheWrite. class TFileCacheWrite: public TObject. TFileCacheWrite : a cache when writing files over the network. A caching system to speed up network I/O, i.e. when there is; no operating system caching support (like the buffer cache for; local disk I/O). The cache makes sure that every I/O is done with; a (large) fixed length buffer thereby avoiding many small I/O's.; Currently the write cache system is used by the classes TNetFile,; TXNetFile and TWebFile (via TFile::WriteBuffers()). The write cache is automatically created when writing a remote file; (created in TFile::Open()). Function Members (Methods); public:. virtual~TFileCacheWrite(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TFileCacheWrite.html:596,avoid,avoiding,596,root/html602/TFileCacheWrite.html,https://root.cern,https://root.cern/root/html602/TFileCacheWrite.html,2,['avoid'],['avoiding']
Safety,". TFractionFitter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TFractionFitter. class TFractionFitter: public TObject. Fits MC fractions to data histogram (a la HMCMLL, see R. Barlow and C. Beeston,; Comp. Phys. Comm. 77 (1993) 219-228, and http://www.hep.man.ac.uk/~roger/hfrac.f). The virtue of this fit is that it takes into account both data and Monte Carlo; statistical uncertainties. The way in which this is done is through a standard; likelihood fit using Poisson statistics; however, the template (MC) predictions; are also varied within statistics, leading to additional contributions to the; overall likelihood. This leads to many more fit parameters (one per bin per; template), but the minimisation with respect to these additional parameters is; done analytically rather than introducing them as formal fit parameters. Some; special care needs to be taken in the case of bins with zero content. For more; details please see the original publication cited above. An example application of this fit is given below. For a TH1* histogram; (""data"") fitted as the sum of three Monte Carlo sources (""mc""):. {; TH1F *data; //data histogram; TH1F *mc0; // first MC histogram; TH1F *mc1; // second MC histogram; TH1F *mc2; // third MC histogram; .... // retrieve histograms; TObjArray *mc = new TObjArray(3); // MC histograms are put in this array; mc->Add(mc0);; mc->Add(mc1);; mc->Add(mc2);; TFractionFitter* fit = new TFractionFitter(data, mc); // initialise; fit->Constrain(1,0.0,1.0); // constrain fraction 1 to be between 0 and 1; fit->SetRangeX(1,15); // use only the first 15 bins in the fit; Int_t status = fit->Fit(); // perform the fit; cout << ""fit status: "" << status << endl;; if (status == 0) { // check on fit status; TH1F* result = (TH1F*) fit->GetPlot();; data->Draw(""Ep"");; result->Draw(""sam",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFractionFitter.html:698,predict,predictions,698,root/html528/TFractionFitter.html,https://root.cern,https://root.cern/root/html528/TFractionFitter.html,4,['predict'],['predictions']
Safety,". TFractionFitter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TFractionFitter. class TFractionFitter: public TObject. Fits MC fractions to data histogram (a la HMCMLL, see R. Barlow and C. Beeston,; Comp. Phys. Comm. 77 (1993) 219-228, and http://www.hep.man.ac.uk/~roger/hfrac.f). The virtue of this fit is that it takes into account both data and Monte Carlo; statistical uncertainties. The way in which this is done is through a standard; likelihood fit using Poisson statistics; however, the template (MC) predictions; are also varied within statistics, leading to additional contributions to the; overall likelihood. This leads to many more fit parameters (one per bin per; template), but the minimisation with respect to these additional parameters is; done analytically rather than introducing them as formal fit parameters. Some; special care needs to be taken in the case of bins with zero content. For more; details please see the original publication cited above. An example application of this fit is given below. For a TH1* histogram; (""data"") fitted as the sum of three Monte Carlo sources (""mc""):. {; TH1F *data; //data histogram; TH1F *mc0; // first MC histogram; TH1F *mc1; // second MC histogram; TH1F *mc2; // third MC histogram; .... // retrieve histograms; TObjArray *mc = new TObjArray(3); // MC histograms are put in this array; mc->Add(mc0);; mc->Add(mc1);; mc->Add(mc2);; TFractionFitter* fit = new TFractionFitter(data, mc); // initialise; fit->Constrain(1,0.0,1.0); // constrain fraction 1 to be between 0 and 1; fit->SetRangeX(1,15); // use only the first 15 bins in the fit; Int_t status = fit->Fit(); // perform the fit; std::cout << ""fit status: "" << status << std::endl;; if (status == 0) { // check on fit status; TH1F* result = (TH1F*) fit->GetPlot();; data->Draw(""Ep"");; result-",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TFractionFitter.html:698,predict,predictions,698,root/html602/TFractionFitter.html,https://root.cern,https://root.cern/root/html602/TFractionFitter.html,2,['predict'],['predictions']
Safety,". TGL5DDataSetEditor. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGL5DDataSetEditor. class TGL5DDataSetEditor: public TGedFrame. GUI editor for OpenGL 5D Painter.; Exception safety and ROOT's GUI are two; mutually exclusive things. So,; only ROOT's GUI here. Function Members (Methods); public:. TGL5DDataSetEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); virtual~TGL5DDataSetEditor(); voidTObject::AbstractMethod(const char* method) const; virtual Bool_tTGedFrame::AcceptModel(TObject*); virtual voidTGFrame::Activate(Bool_t); virtual voidTGedFrame::ActivateBaseClassEditors(TClass* cl); virtual voidTGedFrame::AddExtraTab(TGedFrame::TGedSubFrame* sf); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); voidAddNewSurface(); voidAlphaChanged(); voidAlphaChanged(Int_t alpha); virtual voidTObject::AppendPad(Option_t* option = """"); voidApplyAlpha(); voidApplyGridParameters(); voidApplyPlanes(); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); voidBoxCutToggled(); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TCla",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGL5DDataSetEditor.html:362,safe,safety,362,root/html528/TGL5DDataSetEditor.html,https://root.cern,https://root.cern/root/html528/TGL5DDataSetEditor.html,4,['safe'],['safety']
Safety,". TGL5DDataSetEditor. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGL5DDataSetEditor. class TGL5DDataSetEditor: public TGedFrame. GUI editor for OpenGL 5D Painter.; Exception safety and ROOT's GUI are two; mutually exclusive things. So,; only ROOT's GUI here. Function Members (Methods); public:. virtual~TGL5DDataSetEditor(); voidTObject::AbstractMethod(const char* method) const; virtual Bool_tTGedFrame::AcceptModel(TObject*); virtual voidTGFrame::Activate(Bool_t); virtual voidTGedFrame::ActivateBaseClassEditors(TClass* cl); virtual voidTGedFrame::AddExtraTab(TGedFrame::TGedSubFrame* sf); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); voidAddNewSurface(); voidAlphaChanged(); voidAlphaChanged(Int_t alpha); virtual voidTObject::AppendPad(Option_t* option = """"); voidApplyAlpha(); voidApplyGridParameters(); voidApplyPlanes(); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); voidBoxCutToggled(); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); voidColorChanged(Pixel_t pixelColor); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGL5DDataSetEditor.html:362,safe,safety,362,root/html602/TGL5DDataSetEditor.html,https://root.cern,https://root.cern/root/html602/TGL5DDataSetEditor.html,2,['safe'],['safety']
Safety,". TGRedirectOutputGuard. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGRedirectOutputGuard. class TGRedirectOutputGuard. TGRedirectOutputGuard. This class provides output redirection to a TGTextView in guaranteed; exception safe way. Use like this:; {; TGRedirectOutputGuard guard(textview);; ... // do something; guard.Update();; ... // do something else; }; when guard goes out of scope, Update() is called to flush what left; on the screed and the output is automatically redirected again to; the standard units.; The exception mechanism takes care of calling the dtors; of local objects so it is exception safe.; Optionally the output can also be saved into a file:; {; TGRedirectOutputGuard guard(textview, file, mode);; ... // do something; }. Function Members (Methods); public:. TGRedirectOutputGuard(const TGRedirectOutputGuard&); TGRedirectOutputGuard(TGTextView* tv, const char* flog = 0, const char* mode = ""a""); virtual~TGRedirectOutputGuard(); static TClass*Class(); virtual TClass*IsA() const; TGRedirectOutputGuard&operator=(const TGRedirectOutputGuard&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidUpdate(). Data Members; private:. TStringfLogFile; FILE*fLogFileRead; TGTextView*fTextView; Bool_tfTmpFile. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGRedirectOutputGuard(TGTextView* tv, const char* flog = 0, const char* mode = ""a""). void Update(). » Author: G. Ganis 10/10/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGRedirectOutputGuard.h 23115 2008-04-10 13:35:37Z rdm $ » Last generated: 2010-09-23 20:07; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mai",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGRedirectOutputGuard.html:383,safe,safe,383,root/html528/TGRedirectOutputGuard.html,https://root.cern,https://root.cern/root/html528/TGRedirectOutputGuard.html,2,['safe'],['safe']
Safety,". TGRedirectOutputGuard. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGRedirectOutputGuard. class TGRedirectOutputGuard. TGRedirectOutputGuard. This class provides output redirection to a TGTextView in guaranteed; exception safe way. Use like this:; {; TGRedirectOutputGuard guard(textview);; ... // do something; guard.Update();; ... // do something else; }; when guard goes out of scope, Update() is called to flush what left; on the screed and the output is automatically redirected again to; the standard units.; The exception mechanism takes care of calling the dtors; of local objects so it is exception safe.; Optionally the output can also be saved into a file:; {; TGRedirectOutputGuard guard(textview, file, mode);; ... // do something; }. Function Members (Methods); public:. TGRedirectOutputGuard(TGTextView* tv, const char* flog = 0, const char* mode = ""a""); virtual~TGRedirectOutputGuard(); static TClass*Class(); virtual TClass*IsA() const; virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidUpdate(). private:. TGRedirectOutputGuard(const TGRedirectOutputGuard&); TGRedirectOutputGuard&operator=(const TGRedirectOutputGuard&). Data Members; private:. TStringfLogFile; FILE*fLogFileRead; TGTextView*fTextView; Bool_tfTmpFile. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGRedirectOutputGuard(const TGRedirectOutputGuard& ). TGRedirectOutputGuard & operator=(const TGRedirectOutputGuard& ). TGRedirectOutputGuard(TGTextView* tv, const char* flog = 0, const char* mode = ""a""). void Update(). » Author: G. Ganis 10/10/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-09-08 17:04; This page has been automatically generated",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGRedirectOutputGuard.html:385,safe,safe,385,root/html534/TGRedirectOutputGuard.html,https://root.cern,https://root.cern/root/html534/TGRedirectOutputGuard.html,2,['safe'],['safe']
Safety,". TGRedirectOutputGuard. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGRedirectOutputGuard. class TGRedirectOutputGuard. TGRedirectOutputGuard. This class provides output redirection to a TGTextView in guaranteed; exception safe way. Use like this:; {; TGRedirectOutputGuard guard(textview);; ... // do something; guard.Update();; ... // do something else; }; when guard goes out of scope, Update() is called to flush what left; on the screed and the output is automatically redirected again to; the standard units.; The exception mechanism takes care of calling the dtors; of local objects so it is exception safe.; Optionally the output can also be saved into a file:; {; TGRedirectOutputGuard guard(textview, file, mode);; ... // do something; }. Function Members (Methods); public:. TGRedirectOutputGuard(const TGRedirectOutputGuard&); TGRedirectOutputGuard(TGTextView* tv, const char* flog = 0, const char* mode = ""a""); virtual~TGRedirectOutputGuard(); static TClass*Class(); virtual TClass*IsA() const; TGRedirectOutputGuard&operator=(const TGRedirectOutputGuard&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidUpdate(). Data Members; private:. TStringfLogFile; FILE*fLogFileRead; TGTextView*fTextView; Bool_tfTmpFile. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGRedirectOutputGuard(TGTextView* tv, const char* flog = 0, const char* mode = ""a""). void Update(). » Author: G. Ganis 10/10/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGRedirectOutputGuard.h 23115 2008-04-10 13:35:37Z rdm $ » Last generated: 2011-07-04 15:30; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a m",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGRedirectOutputGuard.html:385,safe,safe,385,root/html530/TGRedirectOutputGuard.html,https://root.cern,https://root.cern/root/html530/TGRedirectOutputGuard.html,2,['safe'],['safe']
Safety,". TGRedirectOutputGuard. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGRedirectOutputGuard. class TGRedirectOutputGuard. TGRedirectOutputGuard. This class provides output redirection to a TGTextView in guaranteed; exception safe way. Use like this:; {; TGRedirectOutputGuard guard(textview);; ... // do something; guard.Update();; ... // do something else; }; when guard goes out of scope, Update() is called to flush what left; on the screed and the output is automatically redirected again to; the standard units.; The exception mechanism takes care of calling the dtors; of local objects so it is exception safe.; Optionally the output can also be saved into a file:; {; TGRedirectOutputGuard guard(textview, file, mode);; ... // do something; }. Function Members (Methods); public:. TGRedirectOutputGuard(const TGRedirectOutputGuard&); TGRedirectOutputGuard(TGTextView* tv, const char* flog = 0, const char* mode = ""a""); virtual~TGRedirectOutputGuard(); static TClass*Class(); virtual TClass*IsA() const; TGRedirectOutputGuard&operator=(const TGRedirectOutputGuard&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidUpdate(). Data Members; private:. TStringfLogFile; FILE*fLogFileRead; TGTextView*fTextView; Bool_tfTmpFile. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGRedirectOutputGuard(TGTextView* tv, const char* flog = 0, const char* mode = ""a""). void Update(). » Author: G. Ganis 10/10/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGRedirectOutputGuard.h 23115 2008-04-10 13:35:37Z rdm $ » Last generated: 2011-11-03 20:15; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a m",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGRedirectOutputGuard.html:385,safe,safe,385,root/html532/TGRedirectOutputGuard.html,https://root.cern,https://root.cern/root/html532/TGRedirectOutputGuard.html,2,['safe'],['safe']
Safety,". TGRedirectOutputGuard. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGRedirectOutputGuard. class TGRedirectOutputGuard. TGRedirectOutputGuard. This class provides output redirection to a TGTextView in guaranteed; exception safe way. Use like this:; {; TGRedirectOutputGuard guard(textview);; ... // do something; guard.Update();; ... // do something else; }; when guard goes out of scope, Update() is called to flush what left; on the screed and the output is automatically redirected again to; the standard units.; The exception mechanism takes care of calling the dtors; of local objects so it is exception safe.; Optionally the output can also be saved into a file:; {; TGRedirectOutputGuard guard(textview, file, mode);; ... // do something; }. Function Members (Methods); public:. virtual~TGRedirectOutputGuard(); static TClass*Class(); virtual TClass*IsA() const; virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TGRedirectOutputGuard(TGTextView* tv, const char* flog = 0, const char* mode = ""a""); voidUpdate(). private:. TGRedirectOutputGuard&operator=(const TGRedirectOutputGuard&); TGRedirectOutputGuard(const TGRedirectOutputGuard&). Data Members; private:. TStringfLogFile; FILE*fLogFileRead; TGTextView*fTextView; Bool_tfTmpFile. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGRedirectOutputGuard(TGTextView* tv, const char* flog = 0, const char* mode = ""a""); Create output redirection guard.; The TGTextView instance should be initialized outside.; Text is added to the existing text in the frame.; If defined, 'flog' is interpreted as the path of a file; where to save the output; in such a case 'mode' if the; opening mode of the file (either ""w"" or ""a"").;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGRedirectOutputGuard.html:409,safe,safe,409,root/html602/TGRedirectOutputGuard.html,https://root.cern,https://root.cern/root/html602/TGRedirectOutputGuard.html,4,['safe'],['safe']
Safety,". TGeoBoolNode*fNodetop boolean node. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoCompositeShape(); Default constructor. TGeoCompositeShape(const char* name, const char* expression); Default constructor. TGeoCompositeShape(const char* expression); Default constructor. TGeoCompositeShape(const char* name, TGeoBoolNode* node); Constructor with a Boolean node. ~TGeoCompositeShape(); destructor. Double_t Capacity() const; Computes capacity of this shape [length^3] by sampling with 1% error. void ComputeBBox(); compute bounding box of the sphere. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Computes normal vector in POINT to the composite shape. Bool_t Contains(Double_t* point) const; Tests if point is inside the shape. Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute closest distance from point px,py to each corner. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to this composite shape.; Check if the bounding box is crossed within the requested distance. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to outside of this composite shape. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Divide all range of iaxis in range/step cells. void GetMeshNumbers(Int_t& nvert, Int_t& nsegs, Int_t& npols) const; Returns numbers of vertices, segments and polygons composing the shape mesh. void InspectShape() const; print shape parameters. void MakeNode(const char* expression); Make a booleann node according to the top level boolean operation of expression.; Propagates signal to branches until expression is fully decomposed.; printf(""Making node for : %s\n"", expression);. Bool_t PaintComposite(Option_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoCompositeShape.html:18100,safe,safe,18100,root/html528/TGeoCompositeShape.html,https://root.cern,https://root.cern/root/html528/TGeoCompositeShape.html,2,['safe'],['safe']
Safety,". TGeoManager. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoManager. class TGeoManager: public TNamed. General architecture. The new ROOT geometry package is a tool designed for building, browsing,; tracking and visualizing a detector geometry. The code is independent from; other external MC for simulation, therefore it does not contain any; constraints related to physics. However, the package defines a number of; hooks for tracking, such as media, materials, magnetic field or track state flags,; in order to allow interfacing to tracking MC's. The final goal is to be; able to use the same geometry for several purposes, such as tracking,; reconstruction or visualization, taking advantage of the ROOT features; related to bookkeeping, I/O, histograming, browsing and GUI's. The geometrical modeler is the most important component of the package and; it provides answers to the basic questions like ""Where am I ?"" or ""How far; from the next boundary ?"", but also to more complex ones like ""How far from; the closest surface ?"" or ""Which is the next crossing along a helix ?"". The architecture of the modeler is a combination between a GEANT-like; containment scheme and a normal CSG binary tree at the level of shapes. An; important common feature of all detector geometry descriptions is the; mother-daughter concept. This is the most natural approach when tracking; is concerned and imposes a set of constraints to the way geometry is defined.; Constructive solid geometry composition is used only in order to create more; complex shapes from an existing set of primitives through boolean operations.; This feature is not implemented yet but in future full definition of boolean; expressions will be supported. Practically every geometry defined in GEANT style can be mapped by the modeler.; The basic c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoManager.html:416,detect,detector,416,root/html528/TGeoManager.html,https://root.cern,https://root.cern/root/html528/TGeoManager.html,6,['detect'],['detector']
Safety,". TGeoPNEntry. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoPNEntry. class TGeoPNEntry: public TNamed. TGeoPhysicalNode, TGeoPNEntry. Physical nodes are the actual 'touchable' objects in the geometry, representing; a path of positioned volumes starting with the top node:; path=/TOP/A_1/B_4/C_3 , where A, B, C represent names of volumes.; The number of physical nodes is given by the total number of possible of; branches in the geometry hierarchy. In case of detector geometries and; specially for calorimeters this number can be of the order 1e6-1e9, therefore; it is impossible to create all physical nodes as objects in memory. In TGeo,; physical nodes are represented by the class TGeoPhysicalNode and can be created; on demand for alignment purposes:. TGeoPhysicalNode *pn = new TGeoPhysicalNode(""path_to_object""). Once created, a physical node can be misaligned, meaning that its position; or even shape can be changed:. pn->Align(TGeoMatrix* newmat, TGeoShape* newshape, Bool_t check=kFALSE). The knowledge of the path to the objects that need to be misaligned is; essential since there is no other way of identifying them. One can however; create 'symbolic links' to any complex path to make it more representable; for the object it designates:. TGeoPNEntry *pne = new TGeoPNEntry(""TPC_SECTOR_2"", ""path_to_tpc_sect2"");; pne->SetPhysicalNode(pn). Such a symbolic link hides the complexity of the path to the align object and; replaces it with a more meaningful name. In addition, TGeoPNEntry objects are; faster to search by name and they may optionally store an additional user; matrix. For more details please read the misalignment section in the Users Guide. Function Members (Methods); public:. TGeoPNEntry(); TGeoPNEntry(const char* unique_name, const char* path); virtual~TGeoPNEntry(); voidTObje",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoPNEntry.html:651,detect,detector,651,root/html528/TGeoPNEntry.html,https://root.cern,https://root.cern/root/html528/TGeoPNEntry.html,4,['detect'],['detector']
Safety,". TGeoPNEntry. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoPNEntry. class TGeoPNEntry: public TNamed. TGeoPhysicalNode, TGeoPNEntry. Physical nodes are the actual 'touchable' objects in the geometry, representing; a path of positioned volumes starting with the top node:; path=/TOP/A_1/B_4/C_3 , where A, B, C represent names of volumes.; The number of physical nodes is given by the total number of possible of; branches in the geometry hierarchy. In case of detector geometries and; specially for calorimeters this number can be of the order 1e6-1e9, therefore; it is impossible to create all physical nodes as objects in memory. In TGeo,; physical nodes are represented by the class TGeoPhysicalNode and can be created; on demand for alignment purposes:. TGeoPhysicalNode *pn = new TGeoPhysicalNode(""path_to_object""). Once created, a physical node can be misaligned, meaning that its position; or even shape can be changed:. pn->Align(TGeoMatrix* newmat, TGeoShape* newshape, Bool_t check=kFALSE). The knowledge of the path to the objects that need to be misaligned is; essential since there is no other way of identifying them. One can however; create 'symbolic links' to any complex path to make it more representable; for the object it designates:. TGeoPNEntry *pne = new TGeoPNEntry(""TPC_SECTOR_2"", ""path_to_tpc_sect2"");; pne->SetPhysicalNode(pn). Such a symbolic link hides the complexity of the path to the align object and; replaces it with a more meaningful name. In addition, TGeoPNEntry objects are; faster to search by name and they may optionally store an additional user; matrix. For more details please read the misalignment section in the Users Guide. Function Members (Methods); public:. virtual~TGeoPNEntry(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::Appe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoPNEntry.html:651,detect,detector,651,root/html602/TGeoPNEntry.html,https://root.cern,https://root.cern/root/html602/TGeoPNEntry.html,2,['detect'],['detector']
Safety,". TGeoPhysicalNode. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoPhysicalNode. class TGeoPhysicalNode: public TNamed, public TAttLine. TGeoPhysicalNode, TGeoPNEntry. Physical nodes are the actual 'touchable' objects in the geometry, representing; a path of positioned volumes starting with the top node:; path=/TOP/A_1/B_4/C_3 , where A, B, C represent names of volumes.; The number of physical nodes is given by the total number of possible of; branches in the geometry hierarchy. In case of detector geometries and; specially for calorimeters this number can be of the order 1e6-1e9, therefore; it is impossible to create all physical nodes as objects in memory. In TGeo,; physical nodes are represented by the class TGeoPhysicalNode and can be created; on demand for alignment purposes:. TGeoPhysicalNode *pn = new TGeoPhysicalNode(""path_to_object""). Once created, a physical node can be misaligned, meaning that its position; or even shape can be changed:. pn->Align(TGeoMatrix* newmat, TGeoShape* newshape, Bool_t check=kFALSE). The knowledge of the path to the objects that need to be misaligned is; essential since there is no other way of identifying them. One can however; create 'symbolic links' to any complex path to make it more representable; for the object it designates:. TGeoPNEntry *pne = new TGeoPNEntry(""TPC_SECTOR_2"", ""path_to_tpc_sect2"");; pne->SetPhysicalNode(pn). Such a symbolic link hides the complexity of the path to the align object and; replaces it with a more meaningful name. In addition, TGeoPNEntry objects are; faster to search by name and they may optionally store an additional user; matrix. For more details please read the misalignment section in the Users Guide. Function Members (Methods); public:. TGeoPhysicalNode(); TGeoPhysicalNode(const char* path); virtual~TGeoPhy",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoPhysicalNode.html:683,detect,detector,683,root/html528/TGeoPhysicalNode.html,https://root.cern,https://root.cern/root/html528/TGeoPhysicalNode.html,4,['detect'],['detector']
Safety,". TGeoPhysicalNode. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoPhysicalNode. class TGeoPhysicalNode: public TNamed, public TAttLine. TGeoPhysicalNode, TGeoPNEntry. Physical nodes are the actual 'touchable' objects in the geometry, representing; a path of positioned volumes starting with the top node:; path=/TOP/A_1/B_4/C_3 , where A, B, C represent names of volumes.; The number of physical nodes is given by the total number of possible of; branches in the geometry hierarchy. In case of detector geometries and; specially for calorimeters this number can be of the order 1e6-1e9, therefore; it is impossible to create all physical nodes as objects in memory. In TGeo,; physical nodes are represented by the class TGeoPhysicalNode and can be created; on demand for alignment purposes:. TGeoPhysicalNode *pn = new TGeoPhysicalNode(""path_to_object""). Once created, a physical node can be misaligned, meaning that its position; or even shape can be changed:. pn->Align(TGeoMatrix* newmat, TGeoShape* newshape, Bool_t check=kFALSE). The knowledge of the path to the objects that need to be misaligned is; essential since there is no other way of identifying them. One can however; create 'symbolic links' to any complex path to make it more representable; for the object it designates:. TGeoPNEntry *pne = new TGeoPNEntry(""TPC_SECTOR_2"", ""path_to_tpc_sect2"");; pne->SetPhysicalNode(pn). Such a symbolic link hides the complexity of the path to the align object and; replaces it with a more meaningful name. In addition, TGeoPNEntry objects are; faster to search by name and they may optionally store an additional user; matrix. For more details please read the misalignment section in the Users Guide. Function Members (Methods); public:. virtual~TGeoPhysicalNode(); voidTObject::AbstractMethod(const char* met",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoPhysicalNode.html:683,detect,detector,683,root/html602/TGeoPhysicalNode.html,https://root.cern,https://root.cern/root/html602/TGeoPhysicalNode.html,2,['detect'],['detector']
Safety,". TGeoPolygon. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoPolygon. class TGeoPolygon: public TObject. TGeoPolygon - Arbitrary polygon class. A polygon is a 2D shape defined by vertices in the XY plane. It is used by; TGeoXtru class for computing Contains() and Safety(). Only the pointers to; the actual lists of XY values are used - these are not owned by the class. To check if a point in XY plane is contained by a polygon, this is split; into an outscribed convex polygon and the remaining polygons of its subtracton; from the outscribed one. A point is INSIDE if it is; contained by the outscribed polygon but NOT by the remaining ones. Since these; can also be arbitrary polygons at their turn, a tree structure is formed:. P = Pconvex - (Pconvex-P) where (-) means 'subtraction'; Pconvex-P = P1 + P2 + ... where (+) means 'union'. *Note that P1, P2, ... do not intersect each other and they are defined; by subsets of the list of vertices of P. They can be split in the same; way as P*. Therefore, if C(P) represents the Boolean : 'does P contains a given point?',; then:. C(P) = C(Pconvex) .and. not(C(P1) | C(P2) | ...). For creating a polygon without TGeoXtru class, one has to call the constructor; TGeoPolygon(nvert) and then SetXY(Double_t *x, Double_t *y) providing the; arrays of X and Y vertex positions (defined clockwise) that have to 'live' longer; than the polygon they will describe. This complication is due to efficiency reasons.; At the end one has to call the FinishPolygon() method. Function Members (Methods); public:. TGeoPolygon(); TGeoPolygon(Int_t nvert); TGeoPolygon(const TGeoPolygon&); virtual~TGeoPolygon(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); Double_tArea() const; virtual voidTObject::Browse(TBrows",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoPolygon.html:453,Safe,Safety,453,root/html534/TGeoPolygon.html,https://root.cern,https://root.cern/root/html534/TGeoPolygon.html,1,['Safe'],['Safety']
Safety,". TGeoPolygon. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoPolygon. class TGeoPolygon: public TObject. TGeoPolygon - Arbitrary polygon class. A polygon is a 2D shape defined by vertices in the XY plane. It is used by; TGeoXtru class for computing Contains() and Safety(). Only the pointers to; the actual lists of XY values are used - these are not owned by the class. To check if a point in XY plane is contained by a polygon, this is split; into an outscribed convex polygon and the remaining polygons of its subtracton; from the outscribed one. A point is INSIDE if it is; contained by the outscribed polygon but NOT by the remaining ones. Since these; can also be arbitrary polygons at their turn, a tree structure is formed:. P = Pconvex - (Pconvex-P) where (-) means 'subtraction'; Pconvex-P = P1 + P2 + ... where (+) means 'union'. *Note that P1, P2, ... do not intersect each other and they are defined; by subsets of the list of vertices of P. They can be split in the same; way as P*. Therefore, if C(P) represents the Boolean : 'does P contains a given point?',; then:. C(P) = C(Pconvex) .and. not(C(P1) | C(P2) | ...). For creating a polygon without TGeoXtru class, one has to call the constructor; TGeoPolygon(nvert) and then SetXY(Double_t *x, Double_t *y) providing the; arrays of X and Y vertex positions (defined clockwise) that have to 'live' longer; than the polygon they will describe. This complication is due to efficiency reasons.; At the end one has to call the FinishPolygon() method. Function Members (Methods); public:. virtual~TGeoPolygon(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); Double_tArea() const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoPolygon.html:453,Safe,Safety,453,root/html602/TGeoPolygon.html,https://root.cern,https://root.cern/root/html602/TGeoPolygon.html,2,['Safe'],['Safety']
Safety,". TGeoPolygon. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoPolygon. class TGeoPolygon: public TObject. TGeoPolygon - Arbitrary polygon class. A polygon is a 2D shape defined by vertices in the XY plane. It is used by; TGeoXtru class for computing Contains() and Safety(). Only the pointers to; the actual lists of XY values are used - these are not owned by the class. To check if a point in XY plane is contained by a polygon, this is splitted; into an outscribed convex polygon and the remaining polygons of its subtracton; from the outscribed one. A point is INSIDE if it is; contained by the outscribed polygon but NOT by the remaining ones. Since these; can also be arbitrary polygons at their turn, a tree structure is formed:. P = Pconvex - (Pconvex-P) where (-) means 'subtraction'; Pconvex-P = P1 + P2 + ... where (+) means 'union'. *Note that P1, P2, ... do not intersect each other and they are defined; by subsets of the list of vertices of P. They can be splitted in the same; way as P*. Therefore, if C(P) represents the Boolean : 'does P contains a given point?',; then:. C(P) = C(Pconvex) .and. not(C(P1) | C(P2) | ...). For creating a polygon without TGeoXtru class, one has to call the constructor; TGeoPolygon(nvert) and then SetXY(Double_t *x, Double_t *y) providing the; arrays of X and Y vertex positions (defined clockwise) that have to 'live' longer; than the polygon they will describe. This complication is due to efficiency reasons.; At the end one has to call the FinishPolygon() method. Function Members (Methods); public:. TGeoPolygon(); TGeoPolygon(Int_t nvert); TGeoPolygon(const TGeoPolygon&); virtual~TGeoPolygon(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); Double_tArea() const; virtual voidTObject::Browse(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoPolygon.html:453,Safe,Safety,453,root/html528/TGeoPolygon.html,https://root.cern,https://root.cern/root/html528/TGeoPolygon.html,3,['Safe'],['Safety']
Safety,". TGeoShape. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoShape. class TGeoShape: public TNamed. TGeoShape - Base abstract class for all shapes. Shapes are geometrical objects that provide the basic modelling; functionality. They provide the definition of the LOCAL frame of coordinates,; with respect to which they are defined. Any implementation of a shape deriving; from the base TGeoShape class has to provide methods for :; - finding out if a point defined in their local frame is or not contained; inside;; - computing the distance from a local point to getting outside/entering the; shape, given a known direction;; - computing the maximum distance in any direction from a local point that; does NOT result in a boundary crossing of the shape (safe distance);; - computing the cosines of the normal vector to the crossed shape surface,; given a starting local point and an ongoing direction.; All the features above are globally managed by the modeller in order to; provide navigation functionality. In addition to those, shapes have also to; implement additional specific abstract methods :; - computation of the minimal box bounding the shape, given that this box have; to be aligned with the local coordinates;; - algorithms for dividing the shape along a given axis and producing resulting; divisions volumes. The modeler currently provides a set of 16 basic shapes, which we will call; primitives. It also provides a special class allowing the creation of shapes; made as a result of boolean operations between primitives. These are called; composite shapes and the composition operation can be recursive (composition; of composites). This allows the creation of a quite large number of different; shape topologies and combinations. Shapes are named objects and register themselves to the manager cl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoShape.html:941,safe,safe,941,root/html528/TGeoShape.html,https://root.cern,https://root.cern/root/html528/TGeoShape.html,6,['safe'],['safe']
Safety,". TGeometry. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » G3D; » TGeometry. class TGeometry: public TNamed. T G E O M E T R Y description. The Geometry class describes the geometry of a detector.; The current implementation supports the GEANT3 style description.; A special program provided in the ROOT utilities (toroot) can be used; to automatically translate a GEANT detector geometry into a ROOT geometry. a Geometry object is entered into the list of geometries into the; ROOT main object (see TROOT description) when the TGeometry; constructor is invoked.; Several geometries may coexist in memory. A Geometry object consist of the following linked lists:; - the TMaterial list (material definition only).; - the TRotmatrix list (Rotation matrices definition only).; - the TShape list (volume definition only).; - the TNode list assembling all detector elements. Only the Build and Draw functions for a geometry are currently supported. The conversion program from Geant to Root has been added in the list; of utilities in utils directory.(see g2root); The executable module of g2root can be found in $ROOTSYS/bin/g2root. To use this conversion program, type the shell command:; g2root geant_rzfile macro_name. for example; g2root na49.geom na49.C; will convert the GEANT RZ file na49.geom into a ROOT macro na49.C. To generate the Geometry structure within Root, do:; Root > .x na49.C; Root > na49.Draw(); Root > wh.x3d() (this invokes the 3-d Root viewver); Root > TFile gna49(""na49.root"",""NEW"") //open a new root file; Root > na49.Write() //Write the na49 geometry structure; Root > gna49.Write() //Write all keys (in this case only one); Note: all keys are also written on closing of the file, gna49.Close or; when the program exits, Root closes all open files correctly.; Once this file has been written, in a ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeometry.html:366,detect,detector,366,root/html528/TGeometry.html,https://root.cern,https://root.cern/root/html528/TGeometry.html,12,['detect'],['detector']
Safety,". TGondzioSolver. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » QUADP; » TGondzioSolver. class TGondzioSolver: public TQpSolverBase. TGondzioSolver. Derived class of TQpSolverBase implementing Gondzio-correction; version of Mehrotra's original predictor-corrector algorithm. Function Members (Methods); public:. TGondzioSolver(); TGondzioSolver(const TGondzioSolver& another); TGondzioSolver(TQpProbBase* of, TQpDataBase* prob, Int_t verbose = 0); virtual~TGondzioSolver(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; Double_tTQpSolverBase::DataNorm(); virtual voidDefMonitor(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, Int_t status_code, Int_t level); virtual voidTQpSolverBase::DefStart(TQpProbBase* formulation, TQpVar* iterate, TQpDataBase* prob, TQpResidual* resid, TQpVar* step); virtual Int_tTQpSolverBase::DefStatus(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Int_t i, Double_t mu, Int_t level); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTQpSolverBase::DoMonitor(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, Int_t stop_code, Int_t level); virtual Int_tTQpSolverBase::DoStatus(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Int_t i, Double_t mu, Int_t level); virtual voidTObject::Draw(Opti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGondzioSolver.html:421,predict,predictor-corrector,421,root/html528/TGondzioSolver.html,https://root.cern,https://root.cern/root/html528/TGondzioSolver.html,4,['predict'],['predictor-corrector']
Safety,". TGondzioSolver. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » QUADP; » TGondzioSolver. class TGondzioSolver: public TQpSolverBase. TGondzioSolver. Derived class of TQpSolverBase implementing Gondzio-correction; version of Mehrotra's original predictor-corrector algorithm. Function Members (Methods); public:. virtual~TGondzioSolver(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; Double_tTQpSolverBase::DataNorm(); virtual voidDefMonitor(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, Int_t status_code, Int_t level); virtual voidTQpSolverBase::DefStart(TQpProbBase* formulation, TQpVar* iterate, TQpDataBase* prob, TQpResidual* resid, TQpVar* step); virtual Int_tTQpSolverBase::DefStatus(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Int_t i, Double_t mu, Int_t level); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTQpSolverBase::DoMonitor(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, Int_t stop_code, Int_t level); virtual Int_tTQpSolverBase::DoStatus(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Int_t i, Double_t mu, Int_t level); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGondzioSolver.html:421,predict,predictor-corrector,421,root/html602/TGondzioSolver.html,https://root.cern,https://root.cern/root/html602/TGondzioSolver.html,2,['predict'],['predictor-corrector']
Safety,". TKey. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » IO; » IO; » TKey. class TKey: public TNamed. The TKey class includes functions to book space in a file,; to create I/O buffers, to fill these buffers,; to compress/uncompress data buffers. Before saving (making persistent) an object in a file, a key must; be created. The key structure contains all the information to; uniquely identify a persistent object in a file.; fNbytes = Number of bytes for the compressed object+key; fObjlen = Length of uncompressed object; fDatime = Date/Time when the object was written; fKeylen = Number of bytes for the key structure; fCycle = Cycle number of the object; fSeekKey = Address of the object on file (points to fNbytes); This is a redundant information used to cross-check; the data base integrity.; fSeekPdir = Pointer to the directory supporting this object; fClassName = Object class name; fName = Name of the object; fTitle = Title of the object. In the 16 highest bits of fSeekPdir is encoded a pid offset. This; offset is to be added to the pid index stored in the TRef object; and the referenced TObject. The TKey class is used by ROOT to:; - to write an object in the current directory; - to write a new ntuple buffer. The structure of a file is shown in TFile::TFile.; The structure of a directory is shown in TDirectoryFile ctor.; The TKey class is used by the TBasket class.; See also TTree. Function Members (Methods); public:. TKey(); TKey(TDirectory* motherDir); TKey(Long64_t pointer, Int_t nbytes, TDirectory* motherDir = 0); TKey(const TObject* obj, const char* name, Int_t bufsize, TDirectory* motherDir = 0); TKey(const char* name, const char* title, const TClass* cl, Int_t nbytes, TDirectory* motherDir = 0); TKey(const TString& name, const TString& title, const TClass* cl, Int_t nbytes, TDirectory* motherDir = 0",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TKey.html:897,redund,redundant,897,root/html528/TKey.html,https://root.cern,https://root.cern/root/html528/TKey.html,2,['redund'],['redundant']
Safety,". TKey. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » IO; » IO; » TKey. class TKey: public TNamed. The TKey class includes functions to book space in a file,; to create I/O buffers, to fill these buffers,; to compress/uncompress data buffers. Before saving (making persistent) an object in a file, a key must; be created. The key structure contains all the information to; uniquely identify a persistent object in a file.; fNbytes = Number of bytes for the compressed object+key; fObjlen = Length of uncompressed object; fDatime = Date/Time when the object was written; fKeylen = Number of bytes for the key structure; fCycle = Cycle number of the object; fSeekKey = Address of the object on file (points to fNbytes); This is a redundant information used to cross-check; the data base integrity.; fSeekPdir = Pointer to the directory supporting this object; fClassName = Object class name; fName = Name of the object; fTitle = Title of the object. In the 16 highest bits of fSeekPdir is encoded a pid offset. This; offset is to be added to the pid index stored in the TRef object; and the referenced TObject. The TKey class is used by ROOT to:; - to write an object in the current directory; - to write a new ntuple buffer. The structure of a file is shown in TFile::TFile.; The structure of a directory is shown in TDirectoryFile ctor.; The TKey class is used by the TBasket class.; See also TTree. Function Members (Methods); public:. TKey(); TKey(TDirectory* motherDir); TKey(TDirectory* motherDir, const TKey& orig, UShort_t pidOffset); TKey(Long64_t pointer, Int_t nbytes, TDirectory* motherDir = 0); TKey(const TObject* obj, const char* name, Int_t bufsize, TDirectory* motherDir = 0); TKey(const char* name, const char* title, const TClass* cl, Int_t nbytes, TDirectory* motherDir = 0); TKey(const TString& name, const TStrin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TKey.html:897,redund,redundant,897,root/html532/TKey.html,https://root.cern,https://root.cern/root/html532/TKey.html,2,['redund'],['redundant']
Safety,". TKey. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » IO; » IO; » TKey. class TKey: public TNamed. The TKey class includes functions to book space in a file,; to create I/O buffers, to fill these buffers,; to compress/uncompress data buffers. Before saving (making persistent) an object in a file, a key must; be created. The key structure contains all the information to; uniquely identify a persistent object in a file.; fNbytes = Number of bytes for the compressed object+key; fObjlen = Length of uncompressed object; fDatime = Date/Time when the object was written; fKeylen = Number of bytes for the key structure; fCycle = Cycle number of the object; fSeekKey = Address of the object on file (points to fNbytes); This is a redundant information used to cross-check; the data base integrity.; fSeekPdir = Pointer to the directory supporting this object; fClassName = Object class name; fName = Name of the object; fTitle = Title of the object. In the 16 highest bits of fSeekPdir is encoded a pid offset. This; offset is to be added to the pid index stored in the TRef object; and the referenced TObject. The TKey class is used by ROOT to:; - to write an object in the current directory; - to write a new ntuple buffer. The structure of a file is shown in TFile::TFile.; The structure of a directory is shown in TDirectoryFile ctor.; The TKey class is used by the TBasket class.; See also TTree. Function Members (Methods); public:. virtual~TKey(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TKey.html:897,redund,redundant,897,root/html602/TKey.html,https://root.cern,https://root.cern/root/html602/TKey.html,2,['redund'],['redundant']
Safety,". TLockGuard. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TLockGuard. class TLockGuard. TVirtualMutex. This class implements a mutex interface. The actual work is done via; TMutex which is available as soon as the thread library is loaded. and. TLockGuard. This class provides mutex resource management in a guaranteed and; exception safe way. Use like this:; {; TLockGuard guard(mutex);; ... // do something; }; when guard goes out of scope the mutex is unlocked in the TLockGuard; destructor. The exception mechanism takes care of calling the dtors; of local objects so it is exception safe. Function Members (Methods); public:. TLockGuard(TVirtualMutex* mutex); virtual~TLockGuard(); static TClass*Class(); virtual TClass*IsA() const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. TLockGuard(const TLockGuard&); TLockGuard&operator=(const TLockGuard&). Data Members; private:. TVirtualMutex*fMutex. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLockGuard(const TLockGuard& ). TLockGuard& operator=(const TLockGuard& ). TLockGuard(TVirtualMutex* mutex); { if (fMutex) fMutex->Lock(); }. virtual ~TLockGuard(); { if (fMutex) fMutex->UnLock(); }. » Author: Fons Rademakers 14/07/2002 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TVirtualMutex.h 25230 2008-08-25 15:22:04Z rdm $ » Last generated: 2010-09-23 20:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TLockGuard.html:521,safe,safe,521,root/html528/TLockGuard.html,https://root.cern,https://root.cern/root/html528/TLockGuard.html,2,['safe'],['safe']
Safety,". TLockGuard. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TLockGuard. class TLockGuard. TVirtualMutex. This class implements a mutex interface. The actual work is done via; TMutex which is available as soon as the thread library is loaded. and. TLockGuard. This class provides mutex resource management in a guaranteed and; exception safe way. Use like this:; {; TLockGuard guard(mutex);; ... // do something; }; when guard goes out of scope the mutex is unlocked in the TLockGuard; destructor. The exception mechanism takes care of calling the dtors; of local objects so it is exception safe. Function Members (Methods); public:. TLockGuard(TVirtualMutex* mutex); virtual~TLockGuard(); static TClass*Class(); virtual TClass*IsA() const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. TLockGuard(const TLockGuard&); TLockGuard&operator=(const TLockGuard&). Data Members; private:. TVirtualMutex*fMutex. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLockGuard(const TLockGuard& ). TLockGuard& operator=(const TLockGuard& ). TLockGuard(TVirtualMutex* mutex); { if (fMutex) fMutex->Lock(); }. virtual ~TLockGuard(); { if (fMutex) fMutex->UnLock(); }. » Author: Fons Rademakers 14/07/2002 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TVirtualMutex.h 25230 2008-08-25 15:22:04Z rdm $ » Last generated: 2011-07-04 15:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TLockGuard.html:521,safe,safe,521,root/html530/TLockGuard.html,https://root.cern,https://root.cern/root/html530/TLockGuard.html,2,['safe'],['safe']
Safety,". TLockGuard. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TLockGuard. class TLockGuard. TVirtualMutex. This class implements a mutex interface. The actual work is done via; TMutex which is available as soon as the thread library is loaded. and. TLockGuard. This class provides mutex resource management in a guaranteed and; exception safe way. Use like this:; {; TLockGuard guard(mutex);; ... // do something; }; when guard goes out of scope the mutex is unlocked in the TLockGuard; destructor. The exception mechanism takes care of calling the dtors; of local objects so it is exception safe. Function Members (Methods); public:. TLockGuard(TVirtualMutex* mutex); virtual~TLockGuard(); static TClass*Class(); virtual TClass*IsA() const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. TLockGuard(const TLockGuard&); TLockGuard&operator=(const TLockGuard&). Data Members; private:. TVirtualMutex*fMutex. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLockGuard(const TLockGuard& ). TLockGuard& operator=(const TLockGuard& ). TLockGuard(TVirtualMutex* mutex); { if (fMutex) fMutex->Lock(); }. virtual ~TLockGuard(); { if (fMutex) fMutex->UnLock(); }. » Author: Fons Rademakers 14/07/2002 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TVirtualMutex.h 25230 2008-08-25 15:22:04Z rdm $ » Last generated: 2011-11-03 20:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TLockGuard.html:521,safe,safe,521,root/html532/TLockGuard.html,https://root.cern,https://root.cern/root/html532/TLockGuard.html,2,['safe'],['safe']
Safety,". TLockGuard. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TLockGuard. class TLockGuard. TVirtualMutex. This class implements a mutex interface. The actual work is done via; TMutex which is available as soon as the thread library is loaded. and. TLockGuard. This class provides mutex resource management in a guaranteed and; exception safe way. Use like this:; {; TLockGuard guard(mutex);; ... // do something; }; when guard goes out of scope the mutex is unlocked in the TLockGuard; destructor. The exception mechanism takes care of calling the dtors; of local objects so it is exception safe. Function Members (Methods); public:. TLockGuard(TVirtualMutex* mutex); virtual~TLockGuard(); static TClass*Class(); virtual TClass*IsA() const; virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). private:. TLockGuard(const TLockGuard&); TLockGuard&operator=(const TLockGuard&). Data Members; private:. TVirtualMutex*fMutex. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLockGuard(const TLockGuard& ). TLockGuard& operator=(const TLockGuard& ). TLockGuard(TVirtualMutex* mutex); { if (fMutex) fMutex->Lock(); }. virtual ~TLockGuard(); { if (fMutex) fMutex->UnLock(); }. » Author: Fons Rademakers 14/07/2002 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-03-14 16:43; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TLockGuard.html:521,safe,safe,521,root/html534/TLockGuard.html,https://root.cern,https://root.cern/root/html534/TLockGuard.html,2,['safe'],['safe']
Safety,". TLockGuard. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TLockGuard. class TLockGuard. TVirtualMutex. This class implements a mutex interface. The actual work is done via; TMutex which is available as soon as the thread library is loaded. and. TLockGuard. This class provides mutex resource management in a guaranteed and; exception safe way. Use like this:; {; TLockGuard guard(mutex);; ... // do something; }; when guard goes out of scope the mutex is unlocked in the TLockGuard; destructor. The exception mechanism takes care of calling the dtors; of local objects so it is exception safe. Function Members (Methods); public:. ~TLockGuard(); static TClass*Class(); TClass*IsA() const; voidShowMembers(TMemberInspector& insp) const; voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TLockGuard(TVirtualMutex* mutex); Int_tUnLock(). private:. TLockGuard&operator=(const TLockGuard&); TLockGuard(const TLockGuard&). Data Members; private:. TVirtualMutex*fMutex. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Int_t UnLock(). TLockGuard(const TLockGuard& ). TLockGuard& operator=(const TLockGuard& ). TLockGuard(TVirtualMutex* mutex); { if (fMutex) fMutex->Lock(); }. ~TLockGuard(); { if (fMutex) fMutex->UnLock(); }. » Author: Fons Rademakers 14/07/2002 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-02 13:52; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TLockGuard.html:521,safe,safe,521,root/html602/TLockGuard.html,https://root.cern,https://root.cern/root/html602/TLockGuard.html,2,['safe'],['safe']
Safety,". TLockGuard. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TLockGuard. class TLockGuard. TVirtualMutex. This class implements a mutex interface. The actual work is done via; TMutex which is available as soon as the thread library is loaded. and. TLockGuard. This class provides mutex resource management in a guaranteed and; exception safe way. Use like this:; {; TLockGuard guard(mutex);; ... // do something; }; when guard goes out of scope the mutex is unlocked in the TLockGuard; destructor. The exception mechanism takes care of calling the dtors; of local objects so it is exception safe. Function Members (Methods); public:. ~TLockGuard(); static TClass*Class(); TClass*IsA() const; voidShowMembers(TMemberInspector& insp) const; voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TLockGuard(TVirtualMutex* mutex); Int_tUnLock(). private:. TLockGuard&operator=(const TLockGuard&); TLockGuard(const TLockGuard&). Data Members; private:. TVirtualMutex*fMutex. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Int_t UnLock(). TLockGuard(const TLockGuard& ). TLockGuard& operator=(const TLockGuard& ). TLockGuard(TVirtualMutex* mutex); { if (fMutex) fMutex->Lock(); }. ~TLockGuard(); { if (fMutex) fMutex->UnLock(); }. » Author: Fons Rademakers 14/07/2002 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-02 16:15; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TLockGuard.html:521,safe,safe,521,root/html604/TLockGuard.html,https://root.cern,https://root.cern/root/html604/TLockGuard.html,2,['safe'],['safe']
Safety,". TMaterial. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » G3D; » TMaterial. class TMaterial: public TNamed, public TAttFill. Manages a detector material. See class TGeometry. Function Members (Methods); public:. TMaterial(); TMaterial(const TMaterial&); TMaterial(const char* name, const char* title, Float_t a, Float_t z, Float_t density); TMaterial(const char* name, const char* title, Float_t a, Float_t z, Float_t density, Float_t radl, Float_t inter); virtual~TMaterial(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Float_tGetA(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMaterial.html:315,detect,detector,315,root/html528/TMaterial.html,https://root.cern,https://root.cern/root/html528/TMaterial.html,4,['detect'],['detector']
Safety,". TMaterial. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » G3D; » TMaterial. class TMaterial: public TNamed, public TAttFill. Manages a detector material. See class TGeometry. Function Members (Methods); public:. virtual~TMaterial(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Float_tGetA() const; virtual Float_tGetDensity() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMaterial.html:315,detect,detector,315,root/html602/TMaterial.html,https://root.cern,https://root.cern/root/html602/TMaterial.html,2,['detect'],['detector']
Safety,". TMatrixTBase<double>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TMatrixTBase<double>. class TMatrixTBase<double>: public TObject. Linear Algebra Package. The present package implements all the basic algorithms dealing; with vectors, matrices, matrix columns, rows, diagonals, etc.; In addition eigen-Vector analysis and several matrix decomposition; have been added (LU,QRH,Cholesky,Bunch-Kaufman and SVD) .; The decompositions are used in matrix inversion, equation solving. For a dense matrix, elements are arranged in memory in a ROW-wise; fashion . For (n x m) matrices where n*m <=kSizeMax (=25 currently); storage space is available on the stack, thus avoiding expensive; allocation/deallocation of heap space . However, this introduces of; course kSizeMax overhead for each matrix object . If this is an; issue recompile with a new appropriate value (>=0) for kSizeMax. Sparse matrices are also stored in row-wise fashion but additional; row/column information is stored, see TMatrixTSparse source for; additional details . Another way to assign and store matrix data is through Use; see for instance stressLinear.cxx file . Unless otherwise specified, matrix and vector indices always start; with 0, spanning up to the specified limit-1. However, there are; constructors to which one can specify aribtrary lower and upper; bounds, e.g. TMatrixD m(1,10,1,5) defines a matrix that ranges; from 1..10, 1..5 (a(1,1)..a(10,5)). The present package provides all facilities to completely AVOID; returning matrices. Use ""TMatrixD A(TMatrixD::kTransposed,B);""; and other fancy constructors as much as possible. If one really needs; to return a matrix, return a TMatrixTLazy object instead. The; conversion is completely transparent to the end user, e.g.; ""TMatrixT m = THaarMatrixT(5);"" and _is_ efficient. Si",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMatrixTBase_double_.html:851,avoid,avoiding,851,root/html528/TMatrixTBase_double_.html,https://root.cern,https://root.cern/root/html528/TMatrixTBase_double_.html,6,['avoid'],['avoiding']
Safety,". TMatrixTBase<float>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TMatrixTBase<float>. class TMatrixTBase<float>: public TObject. Linear Algebra Package. The present package implements all the basic algorithms dealing; with vectors, matrices, matrix columns, rows, diagonals, etc.; In addition eigen-Vector analysis and several matrix decomposition; have been added (LU,QRH,Cholesky,Bunch-Kaufman and SVD) .; The decompositions are used in matrix inversion, equation solving. For a dense matrix, elements are arranged in memory in a ROW-wise; fashion . For (n x m) matrices where n*m <=kSizeMax (=25 currently); storage space is available on the stack, thus avoiding expensive; allocation/deallocation of heap space . However, this introduces of; course kSizeMax overhead for each matrix object . If this is an; issue recompile with a new appropriate value (>=0) for kSizeMax. Sparse matrices are also stored in row-wise fashion but additional; row/column information is stored, see TMatrixTSparse source for; additional details . Another way to assign and store matrix data is through Use; see for instance stressLinear.cxx file . Unless otherwise specified, matrix and vector indices always start; with 0, spanning up to the specified limit-1. However, there are; constructors to which one can specify aribtrary lower and upper; bounds, e.g. TMatrixD m(1,10,1,5) defines a matrix that ranges; from 1..10, 1..5 (a(1,1)..a(10,5)). The present package provides all facilities to completely AVOID; returning matrices. Use ""TMatrixD A(TMatrixD::kTransposed,B);""; and other fancy constructors as much as possible. If one really needs; to return a matrix, return a TMatrixTLazy object instead. The; conversion is completely transparent to the end user, e.g.; ""TMatrixT m = THaarMatrixT(5);"" and _is_ efficient. Since",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMatrixTBase_float_.html:848,avoid,avoiding,848,root/html528/TMatrixTBase_float_.html,https://root.cern,https://root.cern/root/html528/TMatrixTBase_float_.html,6,['avoid'],['avoiding']
Safety,". TMehrotraSolver. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » QUADP; » TMehrotraSolver. class TMehrotraSolver: public TQpSolverBase. TMehrotraSolver. Derived class of TQpSolverBase implementing the original Mehrotra; predictor-corrector algorithm. Function Members (Methods); public:. TMehrotraSolver(); TMehrotraSolver(const TMehrotraSolver& another); TMehrotraSolver(TQpProbBase* of, TQpDataBase* prob, Int_t verbose = 0); virtual~TMehrotraSolver(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; Double_tTQpSolverBase::DataNorm(); virtual voidDefMonitor(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, Int_t status_code, Int_t level); virtual voidTQpSolverBase::DefStart(TQpProbBase* formulation, TQpVar* iterate, TQpDataBase* prob, TQpResidual* resid, TQpVar* step); virtual Int_tTQpSolverBase::DefStatus(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Int_t i, Double_t mu, Int_t level); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTQpSolverBase::DoMonitor(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, Int_t stop_code, Int_t level); virtual Int_tTQpSolverBase::DoStatus(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Int_t i, Double_t mu, Int_t level); virtual voidTObject::Draw(Option_t* option = """");",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMehrotraSolver.html:397,predict,predictor-corrector,397,root/html528/TMehrotraSolver.html,https://root.cern,https://root.cern/root/html528/TMehrotraSolver.html,4,['predict'],['predictor-corrector']
Safety,". TMehrotraSolver. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » QUADP; » TMehrotraSolver. class TMehrotraSolver: public TQpSolverBase. TMehrotraSolver. Derived class of TQpSolverBase implementing the original Mehrotra; predictor-corrector algorithm. Function Members (Methods); public:. virtual~TMehrotraSolver(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; Double_tTQpSolverBase::DataNorm(); virtual voidDefMonitor(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, Int_t status_code, Int_t level); virtual voidTQpSolverBase::DefStart(TQpProbBase* formulation, TQpVar* iterate, TQpDataBase* prob, TQpResidual* resid, TQpVar* step); virtual Int_tTQpSolverBase::DefStatus(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Int_t i, Double_t mu, Int_t level); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTQpSolverBase::DoMonitor(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, Int_t stop_code, Int_t level); virtual Int_tTQpSolverBase::DoStatus(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Int_t i, Double_t mu, Int_t level); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTQpSolverBas",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMehrotraSolver.html:397,predict,predictor-corrector,397,root/html602/TMehrotraSolver.html,https://root.cern,https://root.cern/root/html602/TMehrotraSolver.html,2,['predict'],['predictor-corrector']
Safety,". TMixture. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » G3D; » TMixture. class TMixture: public TMaterial. Manages a detector mixture. See class TGeometry. Function Members (Methods); public:. TMixture(); TMixture(const TMixture&); TMixture(const char* name, const char* title, Int_t nmixt); virtual~TMixture(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidDefineElement(Int_t n, Float_t a, Float_t z, Float_t w); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Float_tTMaterial::GetA() const; Float_t*GetAmixt() const; virtual Float_tTMaterial::GetDensity() const; virt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMixture.html:298,detect,detector,298,root/html528/TMixture.html,https://root.cern,https://root.cern/root/html528/TMixture.html,4,['detect'],['detector']
Safety,". TMixture. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » G3D; » TMixture. class TMixture: public TMaterial. Manages a detector mixture. See class TGeometry. Function Members (Methods); public:. virtual~TMixture(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidDefineElement(Int_t n, Float_t a, Float_t z, Float_t w); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Float_tTMaterial::GetA() const; Float_t*GetAmixt() const; virtual Float_tTMaterial::GetDensity() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMixture.html:298,detect,detector,298,root/html602/TMixture.html,https://root.cern,https://root.cern/root/html602/TMixture.html,2,['detect'],['detector']
Safety,". TObjectRefSpy. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TObjectRefSpy. class TObjectRefSpy: public TObject. TObjectSpy, TObjectRefSpy. Monitors objects for deletion and reflects the deletion by reverting; the internal pointer to zero. When this pointer is zero we know the; object has been deleted. This avoids the unsafe TestBit(kNotDeleted); hack. The spied object must have the kMustCleanup bit set otherwise; you will get an error. Function Members (Methods); public:. TObjectRefSpy(TObject*& obj, Bool_t fixMustCleanupBit = kTRUE); virtual~TObjectRefSpy(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TObjectRefSpy.html:496,avoid,avoids,496,root/html528/TObjectRefSpy.html,https://root.cern,https://root.cern/root/html528/TObjectRefSpy.html,8,"['avoid', 'unsafe']","['avoids', 'unsafe']"
Safety,". TObjectRefSpy. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TObjectRefSpy. class TObjectRefSpy: public TObject. TObjectSpy, TObjectRefSpy. Monitors objects for deletion and reflects the deletion by reverting; the internal pointer to zero. When this pointer is zero we know the; object has been deleted. This avoids the unsafe TestBit(kNotDeleted); hack. The spied object must have the kMustCleanup bit set otherwise; you will get an error. Function Members (Methods); public:. virtual~TObjectRefSpy(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOpti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TObjectRefSpy.html:496,avoid,avoids,496,root/html602/TObjectRefSpy.html,https://root.cern,https://root.cern/root/html602/TObjectRefSpy.html,4,"['avoid', 'unsafe']","['avoids', 'unsafe']"
Safety,". TObjectSpy. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TObjectSpy. class TObjectSpy: public TObject. TObjectSpy, TObjectRefSpy. Monitors objects for deletion and reflects the deletion by reverting; the internal pointer to zero. When this pointer is zero we know the; object has been deleted. This avoids the unsafe TestBit(kNotDeleted); hack. The spied object must have the kMustCleanup bit set otherwise; you will get an error. Function Members (Methods); public:. TObjectSpy(TObject* obj = 0, Bool_t fixMustCleanupBit = kTRUE); virtual~TObjectSpy(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObjec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TObjectSpy.html:487,avoid,avoids,487,root/html528/TObjectSpy.html,https://root.cern,https://root.cern/root/html528/TObjectSpy.html,8,"['avoid', 'unsafe']","['avoids', 'unsafe']"
Safety,". TObjectSpy. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TObjectSpy. class TObjectSpy: public TObject. TObjectSpy, TObjectRefSpy. Monitors objects for deletion and reflects the deletion by reverting; the internal pointer to zero. When this pointer is zero we know the; object has been deleted. This avoids the unsafe TestBit(kNotDeleted); hack. The spied object must have the kMustCleanup bit set otherwise; you will get an error. Function Members (Methods); public:. virtual~TObjectSpy(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TObjectSpy.html:487,avoid,avoids,487,root/html602/TObjectSpy.html,https://root.cern,https://root.cern/root/html602/TObjectSpy.html,4,"['avoid', 'unsafe']","['avoids', 'unsafe']"
Safety,". TPad. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » GPAD; » TPad. class TPad: public TVirtualPad, public TAttBBox2D. The Pad class is the most important graphics class in the ROOT system. /*. */. A Pad is contained in a Canvas.; A Pad may contain other pads (unlimited pad hierarchy).; A pad is a linked list of primitives of any type (graphics objects,; histograms, detectors, tracks, etc.).; Adding a new element into a pad is in general performed by the Draw; member function of the object classes.; It is important to realize that the pad is a linked list of references; to the original object.; For example, in case of a histogram, the histogram.Draw() operation; only stores a reference to the histogram object and not a graphical; representation of this histogram.; When the mouse is used to change (say the bin content), the bin content; of the original histogram is changed !!. The convention used in ROOT is that a Draw operation only adds; a reference to the object. The effective drawing is performed; when the canvas receives a signal to be painted.; This signal is generally sent when typing carriage return in the; command input or when a graphical operation has been performed on one; of the pads of this canvas.; When a Canvas/Pad is repainted, the member function Paint for all; objects in the Pad linked list is invoked. When the mouse is moved on the Pad, The member function DistancetoPrimitive; is called for all the elements in the pad. DistancetoPrimitive returns; the distance in pixels to this object.; when the object is within the distance window, the member function; ExecuteEvent is called for this object.; in ExecuteEvent, move, changes can be performed on the object.; For examples of DistancetoPrimitive and ExecuteEvent functions,; see classes TLine::DistancetoPrimitive, TLine::Execut",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TPad.html:548,detect,detectors,548,root/html534/TPad.html,https://root.cern,https://root.cern/root/html534/TPad.html,3,['detect'],['detectors']
Safety,". TPad. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » GPAD; » TPad. class TPad: public TVirtualPad. The Pad class is the most important graphics class in the ROOT system. /*. */. A Pad is contained in a Canvas.; A Pad may contain other pads (unlimited pad hierarchy).; A pad is a linked list of primitives of any type (graphics objects,; histograms, detectors, tracks, etc.).; Adding a new element into a pad is in general performed by the Draw; member function of the object classes.; It is important to realize that the pad is a linked list of references; to the original object.; For example, in case of a histogram, the histogram.Draw() operation; only stores a reference to the histogram object and not a graphical; representation of this histogram.; When the mouse is used to change (say the bin content), the bin content; of the original histogram is changed !!. The convention used in ROOT is that a Draw operation only adds; a reference to the object. The effective drawing is performed; when the canvas receives a signal to be painted.; This signal is generally sent when typing carriage return in the; command input or when a graphical operation has been performed on one; of the pads of this canvas.; When a Canvas/Pad is repainted, the member function Paint for all; objects in the Pad linked list is invoked. When the mouse is moved on the Pad, The member function DistancetoPrimitive; is called for all the elements in the pad. DistancetoPrimitive returns; the distance in pixels to this object.; when the object is within the distance window, the member function; ExecuteEvent is called for this object.; in ExecuteEvent, move, changes can be performed on the object.; For examples of DistancetoPrimitive and ExecuteEvent functions,; see classes TLine::DistancetoPrimitive, TLine::ExecuteEvent; TBox::Dista",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPad.html:529,detect,detectors,529,root/html528/TPad.html,https://root.cern,https://root.cern/root/html528/TPad.html,3,['detect'],['detectors']
Safety,". TParticle. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MONTECARLO; » EG; » TParticle. class TParticle: public TObject, public TAttLine, public TAtt3D. a dynamic particle class created by event generators and used during; the propagation in detectors. The static attributes of a TParticle; are described by TParticlePDG. Int_t fPdgCode; // PDG code of the particle; Int_t fStatusCode; // generation status code; Int_t fMother[2]; // Indices of the mother particles; Int_t fDaughter[2]; // Indices of the daughter particles; Float_t fWeight; // particle weight. Double_t fCalcMass; // Calculated mass. Double_t fPx; // x component of momentum; Double_t fPy; // y component of momentum; Double_t fPz; // z component of momentum; Double_t fE; // Energy. Double_t fVx; // x of production vertex; Double_t fVy; // y of production vertex; Double_t fVz; // z of production vertex; Double_t fVt; // t of production vertex. Double_t fPolarTheta; // Polar angle of polarisation; Double_t fPolarPhi; // azymutal angle of polarisation. TParticlePDG* fParticlePDG; //! reference to the particle record in PDG database. Function Members (Methods); public:. TParticle(); TParticle(const TParticle& part); TParticle(Int_t pdg, Int_t status, Int_t mother1, Int_t mother2, Int_t daughter1, Int_t daughter2, const TLorentzVector& p, const TLorentzVector& v); TParticle(Int_t pdg, Int_t status, Int_t mother1, Int_t mother2, Int_t daughter1, Int_t daughter2, Double_t px, Double_t py, Double_t pz, Double_t etot, Double_t vx, Double_t vy, Double_t vz, Double_t time); virtual~TParticle(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); Int_tBeauty() const; virtual voidTObject::Browse(TBrowser* b); Int_tCharm() const; static TClass*Class(); virtual const char*TObject::ClassName() cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TParticle.html:413,detect,detectors,413,root/html532/TParticle.html,https://root.cern,https://root.cern/root/html532/TParticle.html,2,['detect'],['detectors']
Safety,". TParticle. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MONTECARLO; » EG; » TParticle. class TParticle: public TObject, public TAttLine, public TAtt3D. a dynamic particle class created by event generators and used during; the propagation in detectors. The static attributes of a TParticle; are described by TParticlePDG. Int_t fPdgCode; // PDG code of the particle; Int_t fStatusCode; // generation status code; Int_t fMother[2]; // Indices of the mother particles; Int_t fDaughter[2]; // Indices of the daughter particles; Float_t fWeight; // particle weight. Double_t fCalcMass; // Calculated mass. Double_t fPx; // x component of momentum; Double_t fPy; // y component of momentum; Double_t fPz; // z component of momentum; Double_t fE; // Energy. Double_t fVx; // x of production vertex; Double_t fVy; // y of production vertex; Double_t fVz; // z of production vertex; Double_t fVt; // t of production vertex. Double_t fPolarTheta; // Polar angle of polarisation; Double_t fPolarPhi; // azymutal angle of polarisation. TParticlePDG* fParticlePDG; //! reference to the particle record in PDG database. Function Members (Methods); public:. TParticle(); TParticle(const TParticle& part); TParticle(Int_t pdg, Int_t status, Int_t mother1, Int_t mother2, Int_t daughter1, Int_t daughter2, const TLorentzVector& p, const TLorentzVector& v); TParticle(Int_t pdg, Int_t status, Int_t mother1, Int_t mother2, Int_t daughter1, Int_t daughter2, Double_t px, Double_t py, Double_t pz, Double_t etot, Double_t vx, Double_t vy, Double_t vz, Double_t time); virtual~TParticle(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); Int_tBeauty(); virtual voidTObject::Browse(TBrowser* b); Int_tCharm(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TParticle.html:413,detect,detectors,413,root/html528/TParticle.html,https://root.cern,https://root.cern/root/html528/TParticle.html,2,['detect'],['detectors']
Safety,". TParticle. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MONTECARLO; » EG; » TParticle. class TParticle: public TObject, public TAttLine, public TAtt3D. a dynamic particle class created by event generators and used during; the propagation in detectors. The static attributes of a TParticle; are described by TParticlePDG. Int_t fPdgCode; // PDG code of the particle; Int_t fStatusCode; // generation status code; Int_t fMother[2]; // Indices of the mother particles; Int_t fDaughter[2]; // Indices of the daughter particles; Float_t fWeight; // particle weight. Double_t fCalcMass; // Calculated mass. Double_t fPx; // x component of momentum; Double_t fPy; // y component of momentum; Double_t fPz; // z component of momentum; Double_t fE; // Energy. Double_t fVx; // x of production vertex; Double_t fVy; // y of production vertex; Double_t fVz; // z of production vertex; Double_t fVt; // t of production vertex. Double_t fPolarTheta; // Polar angle of polarisation; Double_t fPolarPhi; // azymutal angle of polarisation. TParticlePDG* fParticlePDG; //! reference to the particle record in PDG database. Function Members (Methods); public:. virtual~TParticle(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); Int_tBeauty() const; virtual voidTObject::Browse(TBrowser* b); Int_tCharm() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistanceto",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TParticle.html:413,detect,detectors,413,root/html602/TParticle.html,https://root.cern,https://root.cern/root/html602/TParticle.html,2,['detect'],['detectors']
Safety,". TRedirectOutputGuard. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TRedirectOutputGuard. class TRedirectOutputGuard. TRedirectOutputGuard. This class provides output redirection to a file in a guaranteed; exception safe way. Use like this:; {; TRedirectOutputGuard guard(filelog, mode);; ... // do something; }; when guard goes out of scope output is automatically redirected to; the standard units in the TRedirectOutputGuard destructor.; The exception mechanism takes care of calling the dtors; of local objects so it is exception safe.; The 'mode' options follow the fopen write modes convention; default; is ""a"". Function Members (Methods); public:. TRedirectOutputGuard(const TRedirectOutputGuard&); TRedirectOutputGuard(const char* fout, const char* mode = ""a""); virtual~TRedirectOutputGuard(); static TClass*Class(); virtual TClass*IsA() const; TRedirectOutputGuard&operator=(const TRedirectOutputGuard&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TRedirectOutputGuard(const char* fout, const char* mode = ""a""); { gSystem->RedirectOutput(fout, mode); }. virtual ~TRedirectOutputGuard(); { gSystem->RedirectOutput(0); }. » Author: G. Ganis 10/10/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TRedirectOutputGuard.h 20877 2007-11-19 11:17:07Z rdm $ » Last generated: 2010-09-23 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TRedirectOutputGuard.html:377,safe,safe,377,root/html528/TRedirectOutputGuard.html,https://root.cern,https://root.cern/root/html528/TRedirectOutputGuard.html,2,['safe'],['safe']
Safety,". TRedirectOutputGuard. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; inheritance tree (.pdf) viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TRedirectOutputGuard. class TRedirectOutputGuard. TRedirectOutputGuard. This class provides output redirection to a file in a guaranteed; exception safe way. Use like this:; {; TRedirectOutputGuard guard(filelog, mode);; ... // do something; }; when guard goes out of scope output is automatically redirected to; the standard units in the TRedirectOutputGuard destructor.; The exception mechanism takes care of calling the dtors; of local objects so it is exception safe.; The 'mode' options follow the fopen write modes convention; default; is ""a"". Function Members (Methods); public:. virtual~TRedirectOutputGuard(); static TClass*Class(); virtual TClass*IsA() const; TRedirectOutputGuard&operator=(const TRedirectOutputGuard&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TRedirectOutputGuard(const TRedirectOutputGuard&); TRedirectOutputGuard(const char* fout, const char* mode = ""a""). Class Charts. Inheritance Chart:. TRedirectOutputGuard. Function documentation; TRedirectOutputGuard(const char* fout, const char* mode = ""a""); { gSystem->RedirectOutput(fout, mode); }. virtual ~TRedirectOutputGuard(); { gSystem->RedirectOutput(0); }. » Author: G. Ganis 10/10/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-30 15:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TRedirectOutputGuard.html:403,safe,safe,403,root/html602/TRedirectOutputGuard.html,https://root.cern,https://root.cern/root/html602/TRedirectOutputGuard.html,2,['safe'],['safe']
Safety,". TRedirectOutputGuard. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TRedirectOutputGuard. class TRedirectOutputGuard. TRedirectOutputGuard. This class provides output redirection to a file in a guaranteed; exception safe way. Use like this:; {; TRedirectOutputGuard guard(filelog, mode);; ... // do something; }; when guard goes out of scope output is automatically redirected to; the standard units in the TRedirectOutputGuard destructor.; The exception mechanism takes care of calling the dtors; of local objects so it is exception safe.; The 'mode' options follow the fopen write modes convention; default; is ""a"". Function Members (Methods); public:. TRedirectOutputGuard(const TRedirectOutputGuard&); TRedirectOutputGuard(const char* fout, const char* mode = ""a""); virtual~TRedirectOutputGuard(); static TClass*Class(); virtual TClass*IsA() const; TRedirectOutputGuard&operator=(const TRedirectOutputGuard&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TRedirectOutputGuard(const char* fout, const char* mode = ""a""); { gSystem->RedirectOutput(fout, mode); }. virtual ~TRedirectOutputGuard(); { gSystem->RedirectOutput(0); }. » Author: G. Ganis 10/10/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TRedirectOutputGuard.h 20877 2007-11-19 11:17:07Z rdm $ » Last generated: 2011-07-04 15:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TRedirectOutputGuard.html:379,safe,safe,379,root/html530/TRedirectOutputGuard.html,https://root.cern,https://root.cern/root/html530/TRedirectOutputGuard.html,2,['safe'],['safe']
Safety,". TRedirectOutputGuard. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TRedirectOutputGuard. class TRedirectOutputGuard. TRedirectOutputGuard. This class provides output redirection to a file in a guaranteed; exception safe way. Use like this:; {; TRedirectOutputGuard guard(filelog, mode);; ... // do something; }; when guard goes out of scope output is automatically redirected to; the standard units in the TRedirectOutputGuard destructor.; The exception mechanism takes care of calling the dtors; of local objects so it is exception safe.; The 'mode' options follow the fopen write modes convention; default; is ""a"". Function Members (Methods); public:. TRedirectOutputGuard(const TRedirectOutputGuard&); TRedirectOutputGuard(const char* fout, const char* mode = ""a""); virtual~TRedirectOutputGuard(); static TClass*Class(); virtual TClass*IsA() const; TRedirectOutputGuard&operator=(const TRedirectOutputGuard&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TRedirectOutputGuard(const char* fout, const char* mode = ""a""); { gSystem->RedirectOutput(fout, mode); }. virtual ~TRedirectOutputGuard(); { gSystem->RedirectOutput(0); }. » Author: G. Ganis 10/10/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TRedirectOutputGuard.h 20877 2007-11-19 11:17:07Z rdm $ » Last generated: 2011-11-03 20:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TRedirectOutputGuard.html:379,safe,safe,379,root/html532/TRedirectOutputGuard.html,https://root.cern,https://root.cern/root/html532/TRedirectOutputGuard.html,2,['safe'],['safe']
Safety,". TRedirectOutputGuard. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TRedirectOutputGuard. class TRedirectOutputGuard. TRedirectOutputGuard. This class provides output redirection to a file in a guaranteed; exception safe way. Use like this:; {; TRedirectOutputGuard guard(filelog, mode);; ... // do something; }; when guard goes out of scope output is automatically redirected to; the standard units in the TRedirectOutputGuard destructor.; The exception mechanism takes care of calling the dtors; of local objects so it is exception safe.; The 'mode' options follow the fopen write modes convention; default; is ""a"". Function Members (Methods); public:. TRedirectOutputGuard(const TRedirectOutputGuard&); TRedirectOutputGuard(const char* fout, const char* mode = ""a""); virtual~TRedirectOutputGuard(); static TClass*Class(); virtual TClass*IsA() const; TRedirectOutputGuard&operator=(const TRedirectOutputGuard&); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TRedirectOutputGuard(const char* fout, const char* mode = ""a""); { gSystem->RedirectOutput(fout, mode); }. virtual ~TRedirectOutputGuard(); { gSystem->RedirectOutput(0); }. » Author: G. Ganis 10/10/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-09-08 17:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TRedirectOutputGuard.html:379,safe,safe,379,root/html534/TRedirectOutputGuard.html,https://root.cern,https://root.cern/root/html534/TRedirectOutputGuard.html,2,['safe'],['safe']
Safety,". TRedirectOutputGuard. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TRedirectOutputGuard. class TRedirectOutputGuard. TRedirectOutputGuard. This class provides output redirection to a file in a guaranteed; exception safe way. Use like this:; {; TRedirectOutputGuard guard(filelog, mode);; ... // do something; }; when guard goes out of scope output is automatically redirected to; the standard units in the TRedirectOutputGuard destructor.; The exception mechanism takes care of calling the dtors; of local objects so it is exception safe.; The 'mode' options follow the fopen write modes convention; default; is ""a"". Function Members (Methods); public:. virtual~TRedirectOutputGuard(); static TClass*Class(); virtual TClass*IsA() const; TRedirectOutputGuard&operator=(const TRedirectOutputGuard&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TRedirectOutputGuard(const TRedirectOutputGuard&); TRedirectOutputGuard(const char* fout, const char* mode = ""a""). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TRedirectOutputGuard(const char* fout, const char* mode = ""a""); { gSystem->RedirectOutput(fout, mode); }. virtual ~TRedirectOutputGuard(); { gSystem->RedirectOutput(0); }. » Author: G. Ganis 10/10/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-09-08 17:49; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TRedirectOutputGuard.html:379,safe,safe,379,root/html604/TRedirectOutputGuard.html,https://root.cern,https://root.cern/root/html604/TRedirectOutputGuard.html,2,['safe'],['safe']
Safety,". TRef. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TRef. class TRef: public TObject. TRef. Persistent Reference link to a TObject; A TRef is a lightweight object pointing to any TObject.; This object can be used instead of normal C++ pointers in case; - the referenced object R and the pointer P are not written to the same file; - P is read before R; - R and P are written to different Tree branches. When a top level object (eg Event *event) is a tree/graph of many objects,; the normal ROOT Streaming mechanism ensures that only one copy of each object; in the tree/graph is written to the output buffer to avoid circular; dependencies.; However if the object event is split into several files or into several; branches of one or more Trees, normal C++ pointers cannot be used because; each I/O operation will write the referenced objects.; When a TRef is used to point to a TObject *robj, for example in a class with; TRef fRef;; one can do:; fRef = robj; //to set the pointer; This TRef and robj can be written with two different I/O calls; in the same or different files, in the same or different branches of a Tree. If the TRef is read and the referenced object has not yet been read,; the TRef will return a null pointer. As soon as the referenced object; will be read, the TRef will point to it. If the referenced object is; contained in a TTree it can be autoloaded using the TBranchRef mechanism,; which is set up by simply calling TTree::BranchRef(). TRef also supports the complex situation where a TFile is updated; multiple times on the same machine or a different machine. How does it work. A TRef is itself a TObject with an additional transient pointer fPID.; When the statement fRef = robj is executed, the following actions happen:; - The pointer fPID is set to the cur",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TRef.html:822,avoid,avoid,822,root/html602/TRef.html,https://root.cern,https://root.cern/root/html602/TRef.html,2,['avoid'],['avoid']
Safety,". TRef. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TRef. class TRef: public TObject. TRef. Persistent Reference link to a TObject; A TRef is a lightweight object pointing to any TObject.; This object can be used instead of normal C++ pointers in case; - the referenced object R and the pointer P are not written to the same file; - P is read before R; - R and P are written to different Tree branches. When a top level object (eg Event *event) is a tree/graph of many objects,; the normal ROOT Streaming mechanism ensures that only one copy of each object; in the tree/graph is written to the output buffer to avoid circular; dependencies.; However if the object event is split into several files or into several; branches of one or more Trees, normal C++ pointers cannot be used because; each I/O operation will write the referenced objects.; When a TRef is used to point to a TObject *robj, for example in a class with; TRef fRef;; one can do:; fRef = robj; //to set the pointer; This TRef and robj can be written with two different I/O calls; in the same or different files, in the same or different branches of a Tree. If the TRef is read and the referenced object has not yet been read,; the TRef will return a null pointer. As soon as the referenced object; will be read, the TRef will point to it. If the referenced object is; contained in a TTree it can be autoloaded using the TBranchRef mechanism,; which is set up by simply calling TTree::BranchRef(). TRef also supports the complex situation where a TFile is updated; multiple times on the same machine or a different machine. How does it work. A TRef is itself a TObject with an additional transient pointer fPID.; When the statement fRef = robj is executed, the following actions happen:; - The pointer fPID is set to the current TProcessID.; - The ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TRef.html:798,avoid,avoid,798,root/html528/TRef.html,https://root.cern,https://root.cern/root/html528/TRef.html,4,['avoid'],['avoid']
Safety,". TRolke. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » PHYSICS; » TRolke. class TRolke: public TObject. TRolke. This class computes confidence intervals for the rate of a Poisson; process in the presence of uncertain background and/or efficiency. The treatment and the resulting limits are fully frequentist. The; limit calculations make use of the profile likelihood method. Author: Jan Conrad (CERN) 2004; Updated: Johan Lundberg (CERN) 2009. Copyright CERN 2004,2009 Jan.Conrad@cern.ch,; Johan.Lundberg@cern.ch. For a full list of methods and their syntax, and build instructions,; consult the header file TRolke.h. Examples/tutorials are found in the separate file Rolke.C. TRolke implements the following Models. The signal is always assumed to be Poisson, with the following; combinations of models of background and detection efficiency:. If unsure, first consider model 3, 4 or 5. 1: SetPoissonBkgBinomEff(x,y,z,tau,m). Background: Poisson; Efficiency: Binomial. when the background is simultaneously measured; from sidebands (or MC), and; the signal efficiency was determined from Monte Carlo. 2: SetPoissonBkgGaussEff(x,y,em,sde,tau). Background: Poisson; Efficiency: Gaussian. when the background is simultaneously measured; from sidebands (or MC), and; the efficiency is modeled as Gaussian. 3: SetGaussBkgGaussEff(x,bm,em,sde,sdb). Background: Gaussian; Efficiency: Gaussian. when background and efficiency can both be; modeled as Gaussian. 4: SetPoissonBkgKnownEff(x,y,tau,e). Background: Poisson; Efficiency: Known. when the background is simultaneously measured; from sidebands (or MC). 5: SetGaussBkgKnownEff(x,bm,sdb,e). Background: Gaussian; Efficiency: Known. when background is Gaussian. 6: SetKnownBkgBinomEff(x,z,b,m). Background: Known; Efficiency: Binomial. when signal effi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TRolke.html:1025,detect,detection,1025,root/html602/TRolke.html,https://root.cern,https://root.cern/root/html602/TRolke.html,2,['detect'],['detection']
Safety,". TRolke. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » PHYSICS; » TRolke. class TRolke: public TObject. TRolke. This class computes confidence intervals for the rate of a Poisson; process in the presence of uncertain background and/or efficiency. The treatment and the resulting limits are fully frequentist. The; limit calculations make use of the profile likelihood method. Author: Jan Conrad (CERN) 2004; Updated: Johan Lundberg (CERN) 2009. Copyright CERN 2004,2009 Jan.Conrad@cern.ch,; Johan.Lundberg@cern.ch. For a full list of methods and their syntax, and build instructions,; consult the header file TRolke.h. Examples/tutorials are found in the separate file Rolke.C. TRolke implements the following Models. The signal is always assumed to be Poisson, with the following; combinations of models of background and detection efficiency:. If unsure, first consider model 3, 4 or 5. 1: SetPoissonBkgBinomEff(x,y,z,tau,m). Background: Poisson; Efficiency: Binomial. when the background is simultaneously measured; from sidebands (or MC), and; the signal efficiency was determined from Monte Carlo. 2: SetPoissonBkgGaussEff(x,y,em,sde,tau). Background: Poisson; Efficiency: Gaussian. when the background is simultaneously measured; from sidebands (or MC), and; the efficiency is modeled as Gaussian. 3: SetGaussBkgGaussEff(x,bm,em,sde,sdb). Background: Gaussian; Efficiency: Gaussian. when background and efficiency can both be; modeled as Gaussian. 4: SetPoissonBkgKnownEff(x,y,tau,e). Background: Poisson; Efficiency: Known. when the background is simultaneously measured; from sidebands (or MC). 5: SetGaussBkgKnownEff(x,bm,sdb,e). Background: Gaussian; Efficiency: Known. when background is Gaussian. 6: SetKnownBkgBinomEff(x,z,b,m). Background: Known; Efficiency: Binomial. when signal efficiency was determined fr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TRolke.html:1001,detect,detection,1001,root/html528/TRolke.html,https://root.cern,https://root.cern/root/html528/TRolke.html,4,['detect'],['detection']
Safety,". TRotMatrix. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » G3D; » TRotMatrix. class TRotMatrix: public TNamed. Manages a detector rotation matrix. See class TGeometry. Function Members (Methods); public:. virtual~TRotMatrix(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tDeterminant() const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_t*GetGLMatrix(Double_t* rGLMatrix) const; virtual const char*TObject::GetIconName() const; virtual Double_t*G",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TRotMatrix.html:325,detect,detector,325,root/html602/TRotMatrix.html,https://root.cern,https://root.cern/root/html602/TRotMatrix.html,2,['detect'],['detector']
Safety,". TRotMatrix. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » G3D; » TRotMatrix. class TRotMatrix: public TNamed. Manages a detector rotation matrix. See class TGeometry. Function Members (Methods); public:. TRotMatrix(); TRotMatrix(const TRotMatrix&); TRotMatrix(const char* name, const char* title, Double_t* matrix); TRotMatrix(const char* name, const char* title, Double_t theta, Double_t phi, Double_t psi); TRotMatrix(const char* name, const char* title, Double_t theta1, Double_t phi1, Double_t theta2, Double_t phi2, Double_t theta3, Double_t phi3); virtual~TRotMatrix(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tDeterminant() const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TRotMatrix.html:301,detect,detector,301,root/html528/TRotMatrix.html,https://root.cern,https://root.cern/root/html528/TRotMatrix.html,4,['detect'],['detector']
Safety,". TTimer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TTimer. class TTimer: public TSysEvtHandler. TTimer. Handles synchronous and a-synchronous timer events.; 1. synchronous timer is registered into TSystem and is processed; within the standard ROOT event-loop.; 2. asynchronous timer is passed to the operating system which sends; an external signal to ROOT and thus interrupts its event-loop. You can use this class in one of the following ways:; - Sub-class TTimer and override the Notify() method.; - Re-implement the TObject::HandleTimer() method in your class; and pass a pointer to this object to timer, see the SetObject(); method.; - Pass an interpreter command to timer, see SetCommand() method.; - Create a TTimer, connect its Timeout() signal to the; appropriate methods. Then when the time is up it will emit a; Timeout() signal and call connected slots. Minimum timeout interval is defined in TSystem::ESysConstants as; kItimerResolution (currently 10 ms). Signal/slots example:; TTimer *timer = new TTimer();; timer->Connect(""Timeout()"", ""myObjectClassName"",; myObject, ""TimerDone()"");; timer->Start(2000, kTRUE); // 2 seconds single-shot. To emit the Timeout signal repeadetly with minimum timeout:; timer->Start(0, kFALSE);. Function Members (Methods); public:. virtual~TTimer(); voidTObject::AbstractMethod(const char* method) const; voidTSysEvtHandler::Activate(); virtual voidTSysEvtHandler::Activated()SIGNAL ; virtual voidAdd(); virtual voidTSysEvtHandler::Added()SIGNAL ; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObj",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTimer.html:950,Timeout,Timeout,950,root/html602/TTimer.html,https://root.cern,https://root.cern/root/html602/TTimer.html,2,['Timeout'],['Timeout']
Safety,". TTimer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TTimer. class TTimer: public TSysEvtHandler. TTimer. Handles synchronous and a-synchronous timer events.; 1. synchronous timer is registered into TSystem and is processed; within the standard ROOT event-loop.; 2. asynchronous timer is passed to the operating system which sends; an external signal to ROOT and thus interrupts its event-loop. You can use this class in one of the following ways:; - Sub-class TTimer and override the Notify() method.; - Re-implement the TObject::HandleTimer() method in your class; and pass a pointer to this object to timer, see the SetObject(); method.; - Pass an interpreter command to timer, see SetCommand() method.; - Create a TTimer, connect its Timeout() signal to the; appropriate methods. Then when the time is up it will emit a; Timeout() signal and call connected slots. Minimum timeout interval is defined in TSystem::ESysConstants as; kItimerResolution (currently 10 ms). Signal/slots example:; TTimer *timer = new TTimer();; timer->Connect(""Timeout()"", ""myObjectClassName"",; myObject, ""TimerDone()"");; timer->Start(2000, kTRUE); // 2 seconds single-shot. To emit the Timeout signal repeadetly with minimum timeout:; timer->Start(0, kFALSE);. Function Members (Methods); public:. TTimer(Long_t milliSec = 0, Bool_t mode = kTRUE); TTimer(TObject* obj, Long_t milliSec, Bool_t mode = kTRUE); TTimer(const char* command, Long_t milliSec, Bool_t mode = kTRUE); virtual~TTimer(); voidTObject::AbstractMethod(const char* method) const; voidTSysEvtHandler::Activate(); virtual voidTSysEvtHandler::Activated()SIGNAL ; virtual voidAdd(); virtual voidTSysEvtHandler::Added()SIGNAL ; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTimer.html:926,Timeout,Timeout,926,root/html528/TTimer.html,https://root.cern,https://root.cern/root/html528/TTimer.html,4,['Timeout'],['Timeout']
Safety,". TVectorT<double>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TVectorT<double>. class TVectorT<double>: public TObject. TVectorT. Template class of Vectors in the linear algebra package. Unless otherwise specified, vector indices always start with 0,; spanning up to the specified limit-1. For (n) vectors where n <= kSizeMax (5 currently) storage space is; available on the stack, thus avoiding expensive allocation/; deallocation of heap space . However, this introduces of course; kSizeMax overhead for each vector object . If this is an issue; recompile with a new appropriate value (>=0) for kSizeMax. Another way to assign and store vector data is through Use; see for instance stressLinear.cxx file . Note that Constructors/assignments exists for all different matrix; views. For usage examples see $ROOTSYS/test/stressLinear.cxx. Function Members (Methods); public:. virtual~TVectorT<double>(); TVectorT<double>&Abs(); voidTObject::AbstractMethod(const char* method) const; voidAdd(const TVectorT<double>& v); voidAdd(const TVectorT<double>& v1, const TVectorT<double>& v2); voidAddSomeConstant(double val, const TVectorT<double>& select); virtual voidTObject::AppendPad(Option_t* option = """"); TVectorT<double>&Apply(const TElementActionT<double>& action); TVectorT<double>&Apply(const TElementPosActionT<double>& action); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVectorT_double_.html:602,avoid,avoiding,602,root/html602/TVectorT_double_.html,https://root.cern,https://root.cern/root/html602/TVectorT_double_.html,2,['avoid'],['avoiding']
Safety,". TVectorT<double>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TVectorT<double>. class TVectorT<double>: public TObject. TVectorT. Template class of Vectors in the linear algebra package. Unless otherwise specified, vector indices always start with 0,; spanning up to the specified limit-1. For (n) vectors where n <= kSizeMax (5 currently) storage space is; available on the stack, thus avoiding expensive allocation/; deallocation of heap space . However, this introduces of course; kSizeMax overhead for each vector object . If this is an issue; recompile with a new appropriate value (>=0) for kSizeMax. Another way to assign and store vector data is through Use; see for instance stressLinear.cxx file . Note that Constructors/assignments exists for all different matrix; views. For usage examples see $ROOTSYS/test/stressLinear.cxx. This class is also known as (typedefs to this class)TVectorD, TVectorT<Double_t>. Function Members (Methods); public:. TVectorT<double>(); TVectorT<double>(Int_t n); TVectorT<double>(const TVectorT<double>& another); TVectorT<double>(const TMatrixTRow_const<double>& mr); TVectorT<double>(const TMatrixTColumn_const<double>& mc); TVectorT<double>(const TMatrixTDiag_const<double>& md); TVectorT<double>(const TVectorT<float>& another); TVectorT<double>(Int_t lwb, Int_t upb); TVectorT<double>(Int_t n, const double* elements); TVectorT<double>(Int_t lwb, Int_t upb, const double* elements); virtual~TVectorT<double>(); TVectorT<double>&Abs(); voidTObject::AbstractMethod(const char* method) const; voidAdd(const TVectorT<double>& v); voidAdd(const TVectorT<double>& v1, const TVectorT<double>& v2); voidAddSomeConstant(double val, const TVectorT<double>& select); virtual voidTObject::AppendPad(Option_t* option = """"); TVectorT<double>&Apply(const TElementActionT<double>&",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TVectorT_double_.html:578,avoid,avoiding,578,root/html530/TVectorT_double_.html,https://root.cern,https://root.cern/root/html530/TVectorT_double_.html,2,['avoid'],['avoiding']
Safety,". TVectorT<double>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TVectorT<double>. class TVectorT<double>: public TObject. TVectorT. Template class of Vectors in the linear algebra package. Unless otherwise specified, vector indices always start with 0,; spanning up to the specified limit-1. For (n) vectors where n <= kSizeMax (5 currently) storage space is; available on the stack, thus avoiding expensive allocation/; deallocation of heap space . However, this introduces of course; kSizeMax overhead for each vector object . If this is an issue; recompile with a new appropriate value (>=0) for kSizeMax. Another way to assign and store vector data is through Use; see for instance stressLinear.cxx file . Note that Constructors/assignments exists for all different matrix; views. For usage examples see $ROOTSYS/test/stressLinear.cxx. This class is also known as (typedefs to this class)TVectorT<Double_t>, TVectorD. Function Members (Methods); public:. TVectorT<double>(); TVectorT<double>(Int_t n); TVectorT<double>(const TVectorT<double>& another); TVectorT<double>(const TMatrixTRow_const<double>& mr); TVectorT<double>(const TMatrixTColumn_const<double>& mc); TVectorT<double>(const TMatrixTDiag_const<double>& md); TVectorT<double>(const TVectorT<float>& another); TVectorT<double>(Int_t lwb, Int_t upb); TVectorT<double>(Int_t n, const double* elements); TVectorT<double>(Int_t lwb, Int_t upb, const double* elements); virtual~TVectorT<double>(); TVectorT<double>&Abs(); voidTObject::AbstractMethod(const char* method) const; voidAdd(const TVectorT<double>& v); voidAdd(const TVectorT<double>& v1, const TVectorT<double>& v2); voidAddSomeConstant(double val, const TVectorT<double>& select); virtual voidTObject::AppendPad(Option_t* option = """"); TVectorT<double>&Apply(const TElementActionT<double>&",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVectorT_double_.html:578,avoid,avoiding,578,root/html528/TVectorT_double_.html,https://root.cern,https://root.cern/root/html528/TVectorT_double_.html,2,['avoid'],['avoiding']
Safety,". TVectorT<float>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TVectorT<float>. class TVectorT<float>: public TObject. TVectorT. Template class of Vectors in the linear algebra package. Unless otherwise specified, vector indices always start with 0,; spanning up to the specified limit-1. For (n) vectors where n <= kSizeMax (5 currently) storage space is; available on the stack, thus avoiding expensive allocation/; deallocation of heap space . However, this introduces of course; kSizeMax overhead for each vector object . If this is an issue; recompile with a new appropriate value (>=0) for kSizeMax. Another way to assign and store vector data is through Use; see for instance stressLinear.cxx file . Note that Constructors/assignments exists for all different matrix; views. For usage examples see $ROOTSYS/test/stressLinear.cxx. Function Members (Methods); public:. virtual~TVectorT<float>(); TVectorT<float>&Abs(); voidTObject::AbstractMethod(const char* method) const; voidAdd(const TVectorT<float>& v); voidAdd(const TVectorT<float>& v1, const TVectorT<float>& v2); voidAddSomeConstant(float val, const TVectorT<float>& select); virtual voidTObject::AppendPad(Option_t* option = """"); TVectorT<float>&Apply(const TElementActionT<float>& action); TVectorT<float>&Apply(const TElementPosActionT<float>& action); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* opt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVectorT_float_.html:599,avoid,avoiding,599,root/html602/TVectorT_float_.html,https://root.cern,https://root.cern/root/html602/TVectorT_float_.html,2,['avoid'],['avoiding']
Safety,". TVectorT<float>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TVectorT<float>. class TVectorT<float>: public TObject. TVectorT. Template class of Vectors in the linear algebra package. Unless otherwise specified, vector indices always start with 0,; spanning up to the specified limit-1. For (n) vectors where n <= kSizeMax (5 currently) storage space is; available on the stack, thus avoiding expensive allocation/; deallocation of heap space . However, this introduces of course; kSizeMax overhead for each vector object . If this is an issue; recompile with a new appropriate value (>=0) for kSizeMax. Another way to assign and store vector data is through Use; see for instance stressLinear.cxx file . Note that Constructors/assignments exists for all different matrix; views. For usage examples see $ROOTSYS/test/stressLinear.cxx. This class is also known as (typedefs to this class)TVectorT<Float_t>, TVector, TVectorF. Function Members (Methods); public:. TVectorT<float>(); TVectorT<float>(Int_t n); TVectorT<float>(const TVectorT<float>& another); TVectorT<float>(const TMatrixTRow_const<float>& mr); TVectorT<float>(const TMatrixTColumn_const<float>& mc); TVectorT<float>(const TMatrixTDiag_const<float>& md); TVectorT<float>(const TVectorT<double>& another); TVectorT<float>(Int_t lwb, Int_t upb); TVectorT<float>(Int_t n, const float* elements); TVectorT<float>(Int_t lwb, Int_t upb, const float* elements); virtual~TVectorT<float>(); TVectorT<float>&Abs(); voidTObject::AbstractMethod(const char* method) const; voidAdd(const TVectorT<float>& v); voidAdd(const TVectorT<float>& v1, const TVectorT<float>& v2); voidAddSomeConstant(float val, const TVectorT<float>& select); virtual voidTObject::AppendPad(Option_t* option = """"); TVectorT<float>&Apply(const TElementActionT<float>& action); TVectorT<",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TVectorT_float_.html:575,avoid,avoiding,575,root/html534/TVectorT_float_.html,https://root.cern,https://root.cern/root/html534/TVectorT_float_.html,1,['avoid'],['avoiding']
Safety,". TVectorT<float>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TVectorT<float>. class TVectorT<float>: public TObject. TVectorT. Template class of Vectors in the linear algebra package. Unless otherwise specified, vector indices always start with 0,; spanning up to the specified limit-1. For (n) vectors where n <= kSizeMax (5 currently) storage space is; available on the stack, thus avoiding expensive allocation/; deallocation of heap space . However, this introduces of course; kSizeMax overhead for each vector object . If this is an issue; recompile with a new appropriate value (>=0) for kSizeMax. Another way to assign and store vector data is through Use; see for instance stressLinear.cxx file . Note that Constructors/assignments exists for all different matrix; views. For usage examples see $ROOTSYS/test/stressLinear.cxx. This class is also known as (typedefs to this class)TVectorT<Float_t>, TVectorF, TVector. Function Members (Methods); public:. TVectorT<float>(); TVectorT<float>(Int_t n); TVectorT<float>(const TVectorT<float>& another); TVectorT<float>(const TMatrixTRow_const<float>& mr); TVectorT<float>(const TMatrixTColumn_const<float>& mc); TVectorT<float>(const TMatrixTDiag_const<float>& md); TVectorT<float>(const TVectorT<double>& another); TVectorT<float>(Int_t lwb, Int_t upb); TVectorT<float>(Int_t n, const float* elements); TVectorT<float>(Int_t lwb, Int_t upb, const float* elements); virtual~TVectorT<float>(); TVectorT<float>&Abs(); voidTObject::AbstractMethod(const char* method) const; voidAdd(const TVectorT<float>& v); voidAdd(const TVectorT<float>& v1, const TVectorT<float>& v2); voidAddSomeConstant(float val, const TVectorT<float>& select); virtual voidTObject::AppendPad(Option_t* option = """"); TVectorT<float>&Apply(const TElementActionT<float>& action); TVectorT<",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVectorT_float_.html:575,avoid,avoiding,575,root/html528/TVectorT_float_.html,https://root.cern,https://root.cern/root/html528/TVectorT_float_.html,3,['avoid'],['avoiding']
Safety,". TVirtualFFT. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualFFT. class TVirtualFFT: public TObject. TVirtualFFT. TVirtualFFT is an interface class for Fast Fourier Transforms. The default FFT library is FFTW. To use it, FFTW3 library should already; be installed, and ROOT should be have fftw3 module enabled, with the directories; of fftw3 include file and library specified (see installation instructions).; Function SetDefaultFFT() allows to change the default library. Available transform types:; FFT:; - ""C2CFORWARD"" - a complex input/output discrete Fourier transform (DFT); in one or more dimensions, -1 in the exponent; - ""C2CBACKWARD""- a complex input/output discrete Fourier transform (DFT); in one or more dimensions, +1 in the exponent; - ""R2C"" - a real-input/complex-output discrete Fourier transform (DFT); in one or more dimensions,; - ""C2R"" - inverse transforms to ""R2C"", taking complex input; (storing the non-redundant half of a logically Hermitian array); to real output; - ""R2HC"" - a real-input DFT with output in ¡Èhalfcomplex¡É format,; i.e. real and imaginary parts for a transform of size n stored as; r0, r1, r2, ..., rn/2, i(n+1)/2-1, ..., i2, i1; - ""HC2R"" - computes the reverse of FFTW_R2HC, above; - ""DHT"" - computes a discrete Hartley transform. Sine/cosine transforms:; Different types of transforms are specified by parameter kind of the SineCosine() static; function. 4 different kinds of sine and cosine transforms are available; DCT-I (REDFT00 in FFTW3 notation)- kind=0; DCT-II (REDFT01 in FFTW3 notation)- kind=1; DCT-III(REDFT10 in FFTW3 notation)- kind=2; DCT-IV (REDFT11 in FFTW3 notation)- kind=3; DST-I (RODFT00 in FFTW3 notation)- kind=4; DST-II (RODFT01 in FFTW3 notation)- kind=5; DST-III(RODFT10 in FFTW3 notation)- kind=6; DST-IV (RODFT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVirtualFFT.html:1145,redund,redundant,1145,root/html602/TVirtualFFT.html,https://root.cern,https://root.cern/root/html602/TVirtualFFT.html,2,['redund'],['redundant']
Safety,". TVirtualFFT. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualFFT. class TVirtualFFT: public TObject. TVirtualFFT. TVirtualFFT is an interface class for Fast Fourier Transforms. The default FFT library is FFTW. To use it, FFTW3 library should already; be installed, and ROOT should be have fftw3 module enabled, with the directories; of fftw3 include file and library specified (see installation instructions).; Function SetDefaultFFT() allows to change the default library. Available transform types:; FFT:; - ""C2CFORWARD"" - a complex input/output discrete Fourier transform (DFT); in one or more dimensions, -1 in the exponent; - ""C2CBACKWARD""- a complex input/output discrete Fourier transform (DFT); in one or more dimensions, +1 in the exponent; - ""R2C"" - a real-input/complex-output discrete Fourier transform (DFT); in one or more dimensions,; - ""C2R"" - inverse transforms to ""R2C"", taking complex input; (storing the non-redundant half of a logically Hermitian array); to real output; - ""R2HC"" - a real-input DFT with output in ¡Èhalfcomplex¡É format,; i.e. real and imaginary parts for a transform of size n stored as; r0, r1, r2, ..., rn/2, i(n+1)/2-1, ..., i2, i1; - ""HC2R"" - computes the reverse of FFTW_R2HC, above; - ""DHT"" - computes a discrete Hartley transform. Sine/cosine transforms:; Different types of transforms are specified by parameter kind of the SineCosine() static; function. 4 different kinds of sine and cosine transforms are available; DCT-I (REDFT00 in FFTW3 notation)- kind=0; DCT-II (REDFT01 in FFTW3 notation)- kind=1; DCT-III(REDFT10 in FFTW3 notation)- kind=2; DCT-IV (REDFT11 in FFTW3 notation)- kind=3; DST-I (RODFT00 in FFTW3 notation)- kind=4; DST-II (RODFT01 in FFTW3 notation)- kind=5; DST-III(RODFT10 in FFTW3 notation)- kind=6; DST-IV (RODFT11 in FFTW3 notation)- k",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TVirtualFFT.html:1121,redund,redundant,1121,root/html530/TVirtualFFT.html,https://root.cern,https://root.cern/root/html530/TVirtualFFT.html,3,['redund'],['redundant']
Safety,". TVirtualFFT. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualFFT. class TVirtualFFT: public TObject. TVirtualFFT. TVirtualFFT is an interface class for Fast Fourier Transforms. The default FFT library is FFTW. To use it, FFTW3 library should already; be installed, and ROOT should be have fftw3 module enabled, with the directories; of fftw3 include file and library specified (see installation instructions).; Function SetDefaultFFT() allows to change the default library. Available transform types:; FFT:; - ""C2CFORWARD"" - a complex input/output discrete Fourier transform (DFT); in one or more dimensions, -1 in the exponent; - ""C2CBACKWARD""- a complex input/output discrete Fourier transform (DFT); in one or more dimensions, +1 in the exponent; - ""R2C"" - a real-input/complex-output discrete Fourier transform (DFT); in one or more dimensions,; - ""C2R"" - inverse transforms to ""R2C"", taking complex input; (storing the non-redundant half of a logically Hermitian array); to real output; - ""R2HC"" - a real-input DFT with output in ¡Èhalfcomplex¡É format,; i.e. real and imaginary parts for a transform of size n stored as; r0, r1, r2, ..., rn/2, i(n+1)/2-1, ..., i2, i1; - ""HC2R"" - computes the reverse of FFTW_R2HC, above; - ""DHT"" - computes a discrete Hartley transform. Sine/cosine transforms:; Different types of transforms are specified by parameter kind of the SineCosine() static; function. 4 different kinds of sine and cosine transforms are available; DCT-I (REDFT00 in FFTW3 notation)- kind=0; DCT-II (REDFT10 in FFTW3 notation)- kind=1; DCT-III(REDFT01 in FFTW3 notation)- kind=2; DCT-IV (REDFT11 in FFTW3 notation)- kind=3; DST-I (RODFT00 in FFTW3 notation)- kind=4; DST-II (RODFT10 in FFTW3 notation)- kind=5; DST-III(RODFT01 in FFTW3 notation)- kind=6; DST-IV (RODFT11 in FFTW3 notation)- k",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualFFT.html:1121,redund,redundant,1121,root/html528/TVirtualFFT.html,https://root.cern,https://root.cern/root/html528/TVirtualFFT.html,1,['redund'],['redundant']
Safety,". TVirtualMutex. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualMutex. class TVirtualMutex: public TObject. TVirtualMutex. This class implements a mutex interface. The actual work is done via; TMutex which is available as soon as the thread library is loaded. and. TLockGuard. This class provides mutex resource management in a guaranteed and; exception safe way. Use like this:; {; TLockGuard guard(mutex);; ... // do something; }; when guard goes out of scope the mutex is unlocked in the TLockGuard; destructor. The exception mechanism takes care of calling the dtors; of local objects so it is exception safe. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualMutex(); voidTObject::AbstractMethod(const char* method) const; Int_tAcquire(); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual Int_tCleanUp(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVirtualMutex.html:570,safe,safe,570,root/html602/TVirtualMutex.html,https://root.cern,https://root.cern/root/html602/TVirtualMutex.html,4,['safe'],['safe']
Safety,". TVirtualMutex. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualMutex. class TVirtualMutex: public TObject. TVirtualMutex. This class implements a mutex interface. The actual work is done via; TMutex which is available as soon as the thread library is loaded. and. TLockGuard. This class provides mutex resource management in a guaranteed and; exception safe way. Use like this:; {; TLockGuard guard(mutex);; ... // do something; }; when guard goes out of scope the mutex is unlocked in the TLockGuard; destructor. The exception mechanism takes care of calling the dtors; of local objects so it is exception safe. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualMutex(); voidTObject::AbstractMethod(const char* method) const; Int_tAcquire(); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual Int_tCleanUp(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualMutex.html:546,safe,safe,546,root/html528/TVirtualMutex.html,https://root.cern,https://root.cern/root/html528/TVirtualMutex.html,8,['safe'],['safe']
Safety,". TXNetFile. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » NETX; » TXNetFile. class TXNetFile: public TNetFile. TXNetFile. Authors: Alvise Dorigo, Fabrizio Furano; INFN Padova, 2003; Interfaced to the standalone client (XrdClient): G. Ganis, CERN. TXNetFile is an extension of TNetFile able to deal with new xrootd; server. Its new features are:; - Automatic server kind recognition (xrootd load balancer, xrootd; data server, old rootd); - Backward compatibility with old rootd server (acts as an old; TNetFile); - Fault tolerance for read/write operations (read/write timeouts; and retry); - Internal connection timeout (tunable indipendently from the OS; one) handled by threads; - handling of redirections from server; - Single TCP physical channel for multiple TXNetFile's instances; inside the same application; So, each TXNetFile object client must send messages containing; its ID (streamid). The server, of course, will respond with; messages containing the client's ID, in order to make the client; able to recognize its message by matching its streamid with that; one contained in the server's response.; - Tunable log verbosity level (0 = nothing, 3 = dump read/write; buffers too!); - Many parameters configurable via TEnv facility (see SetParm(); methods). Function Members (Methods); public:. virtual~TXNetFile(); voidTObject::AbstractMethod(const char* method) const; virtual voidTDirectoryFile::Add(TObject* obj, Bool_t replace = kFALSE); static voidTDirectory::AddDirectory(Bool_t add = kTRUE); static Bool_tTDirectory::AddDirectoryStatus(); virtual voidTDirectoryFile::Append(TObject* obj, Bool_t replace = kFALSE); virtual Int_tTDirectoryFile::AppendKey(TKey* key); virtual voidTObject::AppendPad(Option_t* option = """"); static TFileOpenHandle*TFile::AsyncOpen(const char* name, Op",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TXNetFile.html:770,timeout,timeouts,770,root/html602/TXNetFile.html,https://root.cern,https://root.cern/root/html602/TXNetFile.html,2,['timeout'],"['timeout', 'timeouts']"
Safety,". TXNetFile. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » NETX; » TXNetFile. class TXNetFile: public TNetFile. TXNetFile. Authors: Alvise Dorigo, Fabrizio Furano; INFN Padova, 2003; Interfaced to the standalone client (XrdClient): G. Ganis, CERN. TXNetFile is an extension of TNetFile able to deal with new xrootd; server. Its new features are:; - Automatic server kind recognition (xrootd load balancer, xrootd; data server, old rootd); - Backward compatibility with old rootd server (acts as an old; TNetFile); - Fault tolerance for read/write operations (read/write timeouts; and retry); - Internal connection timeout (tunable indipendently from the OS; one) handled by threads; - handling of redirections from server; - Single TCP physical channel for multiple TXNetFile's instances; inside the same application; So, each TXNetFile object client must send messages containing; its ID (streamid). The server, of course, will respond with; messages containing the client's ID, in order to make the client; able to recognize its message by matching its streamid with that; one contained in the server's response.; - Tunable log verbosity level (0 = nothing, 3 = dump read/write; buffers too!); - Many parameters configurable via TEnv facility (see SetParm(); methods). Function Members (Methods); public:. TXNetFile(); TXNetFile(const char* url, Option_t* option = """", const char* fTitle = """", Int_t compress = 1, Int_t netopt = 0, Bool_t parallelopen = kFALSE, const char* logicalurl = 0); virtual~TXNetFile(); voidTObject::AbstractMethod(const char* method) const; virtual voidTDirectoryFile::Add(TObject* obj, Bool_t replace = kFALSE); static voidTDirectory::AddDirectory(Bool_t add = kTRUE); static Bool_tTDirectory::AddDirectoryStatus(); virtual voidTDirectoryFile::Append(TObject* obj, Bool_t replace = kFALSE); virtu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TXNetFile.html:746,timeout,timeouts,746,root/html528/TXNetFile.html,https://root.cern,https://root.cern/root/html528/TXNetFile.html,8,['timeout'],"['timeout', 'timeouts']"
Safety,". TXNetFile. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » NETX; » TXNetFile. class TXNetFile: public TNetFile. TXNetFile. Authors: Alvise Dorigo, Fabrizio Furano; INFN Padova, 2003; Interfaced to the standalone client (XrdClient): G. Ganis, CERN. TXNetFile is an extension of TNetFile able to deal with new xrootd; server. Its new features are:; - Automatic server kind recognition (xrootd load balancer, xrootd; data server, old rootd); - Backward compatibility with old rootd server (acts as an old; TNetFile); - Fault tolerance for read/write operations (read/write timeouts; and retry); - Internal connection timeout (tunable indipendently from the OS; one) handled by threads; - handling of redirections from server; - Single TCP physical channel for multiple TXNetFile's instances; inside the same application; So, each TXNetFile object client must send messages containing; its ID (streamid). The server, of course, will respond with; messages containing the client's ID, in order to make the client; able to recognize its message by matching its streamid with that; one contained in the server's response.; - Tunable log verbosity level (0 = nothing, 3 = dump read/write; buffers too!); - Many parameters configurable via TEnv facility (see SetParm(); methods). Function Members (Methods); public:. virtual~TXNetFile(); voidTObject::AbstractMethod(const char* method) const; virtual voidTDirectoryFile::Add(TObject* obj, Bool_t replace = kFALSE); static voidTDirectory::AddDirectory(Bool_t add = kTRUE); static Bool_tTDirectory::AddDirectoryStatus(); virtual voidTDirectoryFile::Append(TObject* obj, Bool_t replace = kFALSE); virtual Int_tTDirectoryFile::AppendKey(TKey* key); virtual voidTObject::AppendPad(Option_t* option = """"); static TFileOpenHandle*TFile::AsyncOpen(const char* name, Option_t* option = """", con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TXNetFile.html:746,timeout,timeouts,746,root/html604/TXNetFile.html,https://root.cern,https://root.cern/root/html604/TXNetFile.html,2,['timeout'],"['timeout', 'timeouts']"
Safety,". TXNetSystem. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » NETX; » TXNetSystem. class TXNetSystem: public TNetSystem. TXNetSystem. Authors: Frank Winklmeier, Fabrizio Furano; INFN Padova, 2005. TXNetSystem is an extension of TNetSystem able to deal with new; xrootd servers. The class detects the nature of the server and; redirects the calls to TNetSystem in case of a rootd server. Function Members (Methods); public:. virtual~TXNetSystem(); virtual voidTSystem::Abort(int code = 0); voidTObject::AbstractMethod(const char* method) const; virtual intTSystem::AcceptConnection(int sock); virtual Bool_tAccessPathName(const char* path, EAccessMode mode); virtual voidTSystem::AddDynamicPath(const char* pathname); virtual voidTSystem::AddFileHandler(TFileHandler* fh); virtual voidTSystem::AddIncludePath(const char* includePath); virtual voidTSystem::AddLinkedLibs(const char* linkedLib); virtual voidTSystem::AddSignalHandler(TSignalHandler* sh); virtual voidTSystem::AddStdExceptionHandler(TStdExceptionHandler* eh); virtual voidTSystem::AddTimer(TTimer* t); virtual intTSystem::AnnounceTcpService(int port, Bool_t reuse, int backlog, int tcpwindowsize = -1); virtual intTSystem::AnnounceUdpService(int port, int backlog); virtual intTSystem::AnnounceUnixService(int port, int backlog); virtual intTSystem::AnnounceUnixService(const char* sockpath, int backlog); virtual voidTObject::AppendPad(Option_t* option = """"); virtual const char*TSystem::BaseName(const char* pathname); voidTSystem::Beep(Int_t freq = -1, Int_t duration = -1, Bool_t setDefault = kFALSE); virtual voidTObject::Browse(TBrowser* b); Bool_tTSystem::cd(const char* path); virtual Bool_tTSystem::ChangeDirectory(const char* path); virtual intTSystem::Chmod(const char* file, UInt_t mode); static TClass*Class(); virtual const c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TXNetSystem.html:487,detect,detects,487,root/html602/TXNetSystem.html,https://root.cern,https://root.cern/root/html602/TXNetSystem.html,2,['detect'],['detects']
Safety,". TXNetSystem. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » NETX; » TXNetSystem. class TXNetSystem: public TNetSystem. TXNetSystem. Authors: Frank Winklmeier, Fabrizio Furano; INFN Padova, 2005. TXNetSystem is an extension of TNetSystem able to deal with new; xrootd servers. The class detects the nature of the server and; redirects the calls to TNetSystem in case of a rootd server. Function Members (Methods); public:. TXNetSystem(Bool_t owner = kTRUE); TXNetSystem(const char* url, Bool_t owner = kTRUE); virtual~TXNetSystem(); virtual voidTSystem::Abort(int code = 0); voidTObject::AbstractMethod(const char* method) const; virtual intTSystem::AcceptConnection(int sock); virtual Bool_tAccessPathName(const char* path, EAccessMode mode); virtual voidTSystem::AddDynamicPath(const char* pathname); virtual voidTSystem::AddFileHandler(TFileHandler* fh); virtual voidTSystem::AddIncludePath(const char* includePath); virtual voidTSystem::AddLinkedLibs(const char* linkedLib); virtual voidTSystem::AddSignalHandler(TSignalHandler* sh); virtual voidTSystem::AddStdExceptionHandler(TStdExceptionHandler* eh); virtual voidTSystem::AddTimer(TTimer* t); virtual intTSystem::AnnounceTcpService(int port, Bool_t reuse, int backlog, int tcpwindowsize = -1); virtual intTSystem::AnnounceUdpService(int port, int backlog); virtual intTSystem::AnnounceUnixService(int port, int backlog); virtual intTSystem::AnnounceUnixService(const char* sockpath, int backlog); virtual voidTObject::AppendPad(Option_t* option = """"); virtual const char*TSystem::BaseName(const char* pathname); voidTSystem::Beep(Int_t freq = -1, Int_t duration = -1, Bool_t setDefault = kFALSE); virtual voidTObject::Browse(TBrowser* b); Bool_tTSystem::cd(const char* path); virtual Bool_tTSystem::ChangeDirectory(const char* path); virtual intTSystem::Chmod(const c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TXNetSystem.html:463,detect,detects,463,root/html532/TXNetSystem.html,https://root.cern,https://root.cern/root/html532/TXNetSystem.html,2,['detect'],['detects']
Safety,". TXNetSystem. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » NETX; » TXNetSystem. class TXNetSystem: public TNetSystem. TXNetSystem. Authors: Frank Winklmeier, Fabrizio Furano; INFN Padova, 2005. TXNetSystem is an extension of TNetSystem able to deal with new; xrootd servers. The class detects the nature of the server and; redirects the calls to TNetSystem in case of a rootd server. Function Members (Methods); public:. TXNetSystem(Bool_t owner = kTRUE); TXNetSystem(const char* url, Bool_t owner = kTRUE); virtual~TXNetSystem(); virtual voidTSystem::Abort(int code = 0); voidTObject::AbstractMethod(const char* method) const; virtual intTSystem::AcceptConnection(int sock); virtual Bool_tAccessPathName(const char* path, EAccessMode mode); virtual voidTSystem::AddDynamicPath(const char* pathname); virtual voidTSystem::AddFileHandler(TFileHandler* fh); virtual voidTSystem::AddIncludePath(const char* includePath); virtual voidTSystem::AddLinkedLibs(const char* linkedLib); virtual voidTSystem::AddSignalHandler(TSignalHandler* sh); virtual voidTSystem::AddStdExceptionHandler(TStdExceptionHandler* eh); virtual voidTSystem::AddTimer(TTimer* t); virtual intTSystem::AnnounceTcpService(int port, Bool_t reuse, int backlog, int tcpwindowsize = -1); virtual intTSystem::AnnounceUnixService(int port, int backlog); virtual intTSystem::AnnounceUnixService(const char* sockpath, int backlog); virtual voidTObject::AppendPad(Option_t* option = """"); virtual const char*TSystem::BaseName(const char* pathname); voidTSystem::Beep(Int_t freq = -1, Int_t duration = -1, Bool_t setDefault = kFALSE); virtual voidTObject::Browse(TBrowser* b); Bool_tTSystem::cd(const char* path); virtual Bool_tTSystem::ChangeDirectory(const char* path); virtual intTSystem::Chmod(const char* file, UInt_t mode); static TClass*Class(); virtual const c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TXNetSystem.html:463,detect,detects,463,root/html530/TXNetSystem.html,https://root.cern,https://root.cern/root/html530/TXNetSystem.html,1,['detect'],['detects']
Safety,". TXNetSystem. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » NETX; » TXNetSystem. class TXNetSystem: public TNetSystem. TXNetSystem. Authors: Frank Winklmeier, Fabrizio Furano; INFN Padova, 2005. TXNetSystem is an extension of TNetSystem able to deal with new; xrootd servers. The class detects the nature of the server and; redirects the calls to TNetSystem in case of a rootd server. Function Members (Methods); public:. TXNetSystem(Bool_t owner = kTRUE); TXNetSystem(const char* url, Bool_t owner = kTRUE); virtual~TXNetSystem(); virtual voidTSystem::Abort(int code = 0); voidTObject::AbstractMethod(const char* method) const; virtual intTSystem::AcceptConnection(int sock); virtual Bool_tAccessPathName(const char* path, EAccessMode mode); virtual voidTSystem::AddFileHandler(TFileHandler* fh); virtual voidTSystem::AddIncludePath(const char* includePath); virtual voidTSystem::AddLinkedLibs(const char* linkedLib); virtual voidTSystem::AddSignalHandler(TSignalHandler* sh); virtual voidTSystem::AddStdExceptionHandler(TStdExceptionHandler* eh); virtual voidTSystem::AddTimer(TTimer* t); virtual intTSystem::AnnounceTcpService(int port, Bool_t reuse, int backlog, int tcpwindowsize = -1); virtual intTSystem::AnnounceUnixService(int port, int backlog); virtual intTSystem::AnnounceUnixService(const char* sockpath, int backlog); virtual voidTObject::AppendPad(Option_t* option = """"); virtual const char*TSystem::BaseName(const char* pathname); voidTSystem::Beep(Int_t freq = -1, Int_t duration = -1, Bool_t setDefault = kFALSE); virtual voidTObject::Browse(TBrowser* b); Bool_tTSystem::cd(const char* path); virtual Bool_tTSystem::ChangeDirectory(const char* path); virtual intTSystem::Chmod(const char* file, UInt_t mode); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTSystem::CleanC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TXNetSystem.html:463,detect,detects,463,root/html528/TXNetSystem.html,https://root.cern,https://root.cern/root/html528/TXNetSystem.html,1,['detect'],['detects']
Safety,". The TProcessID with number pidf is read from this file. ; If the object is not already entered in the gROOT list, it is added. ; Definition at line 1951 of file TFile.cxx. ◆ ReadStreamerInfo(). void TFile::ReadStreamerInfo ; (; ). virtual . Read the list of StreamerInfo from this file. ; The key with name holding the list of TStreamerInfo objects is read. The corresponding TClass objects are updated. Note that this function is not called if the static member fgReadInfo is false. (see TFile::SetReadStreamerInfo) ; Definition at line 3605 of file TFile.cxx. ◆ Recover(). Int_t TFile::Recover ; (; ). virtual . Attempt to recover file if not correctly closed. ; The function returns the number of keys that have been recovered. If no keys can be recovered, the file will be declared Zombie by the calling function. This function is automatically called when opening a file. If the file is open in read only mode, the file is not modified. If open in update mode and the function finds something to recover, a new directory header is written to the file. When opening the file gain no message from Recover will be reported. If keys have been recovered, the file is usable and you can safely read the corresponding objects. If the file is not usable (a zombie), you can test for this case with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {<actions to take if file is unusable>}; If the file has been recovered, the bit kRecovered is set in the TFile object in memory. You can test if the file has been recovered with if (f.TestBit(TFile::kRecovered)) {... the file has been recovered}; When writing TTrees to a file, it is important to save the Tree header at regular intervals (see TTree::AutoSave). If a file containing a Tree is recovered, the last Tree header written to the file will be used. In this case all the entries in all the branches written before writing the header are valid entries. One can disable the automatic recovery procedure by setting TFile.Recover 0; in the sys",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTFile.html:89148,recover,recover,89148,doc/v632/classTFile.html,https://root.cern,https://root.cern/doc/v632/classTFile.html,2,['recover'],['recover']
Safety,". The same prior is used; for all the TEfficiency objects.; . Example:; If you use cuts to select electrons which can originate from two different; processes, you can determine the selection efficiency for each process. The; overall selection efficiency is then the combined efficiency. The weights to be used in the; combination should be the probability that an; electron comes from the corresponding process.; . VI. Further operations; VI.1 Information about the internal histograms; The methods GetPassedHistogram and GetTotalHistogram; return a constant pointer to the internal histograms. They can be used to; obtain information about the internal histograms (e.g. the binning, number of passed / total events in a bin, mean values...).; One can obtain a clone of the internal histograms by calling GetCopyPassedHisto or GetCopyTotalHisto.; The returned histograms are completely independent from the current; TEfficiency object. By default, they are not attached to a directory to; avoid the duplication of data and the user is responsible for deleting them.; . Example:; //open a root file which contains a TEfficiency object; TFile* pFile = new TFile(""myfile.root"",""update"");; //get TEfficiency object with name ""my_eff""; TEfficiency* pEff = (TEfficiency*)pFile->Get(""my_eff"");; //get clone of total histogram; TH1* clone = pEff->GetCopyTotalHisto();; //change clone...; //save changes of clone directly; clone->Write();; //or append it to the current directoy and write the file; //clone->SetDirectory(gDirectory);; //pFile->Wrtie();; //delete histogram object; delete clone;; clone = 0;; . It is also possible to set the internal total or passed histogram by using the; methods SetPassedHistogram or; SetTotalHistogram.; In order to ensure the validity of the TEfficiency object, the consistency of the; new histogram and the stored histogram is checked. It sometimes might be; impossible to change the histograms in a consistent way. Therefore one can force; the replacement by passing th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEfficiency.html:17445,avoid,avoid,17445,root/html534/TEfficiency.html,https://root.cern,https://root.cern/root/html534/TEfficiency.html,1,['avoid'],['avoid']
Safety,". Therefore, when running on shared computing resources, use ROOT::EnableImplicitMT(i); replacing i with the number of CPUs/slots that were allocated for this job. Thread-safety of user-defined expressions; RDataFrame operations such as Histo1D() or Snapshot() are guaranteed to work correctly in multi-thread event loops. User-defined expressions, such as strings or lambdas passed to Filter(), Define(), Foreach(), Reduce() or Aggregate() will have to be thread-safe, i.e. it should be possible to call them concurrently from different threads.; Note that simple Filter() and Define() transformations will inherently satisfy this requirement: Filter() / Define() expressions will often be pure in the functional programming sense (no side-effects, no dependency on external state), which eliminates all risks of race conditions.; In order to facilitate writing of thread-safe operations, some RDataFrame features such as Foreach(), Define() or OnPartialResult() offer thread-aware counterparts (ForeachSlot(), DefineSlot(), OnPartialResultSlot()): their only difference is that they will pass an extra slot argument (an unsigned integer) to the user-defined expression. When calling user-defined code concurrently, RDataFrame guarantees that different threads will employ different values of the slot parameter, where slot will be a number between 0 and GetNSlots() - 1. In other words, within a slot, computation runs sequentially and events are processed sequentially. Note that the same slot might be associated to different threads over the course of a single event loop, but two threads will never receive the same slot at the same time. This extra parameter might facilitate writing safe parallel code by having each thread write/modify a different processing slot, e.g. a different element of a list. See here for an example usage of ForeachSlot(). Parallel execution of multiple RDataFrame event loops; A complex analysis may require multiple separate RDataFrame computation graphs to produc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:46983,safe,safe,46983,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,2,['safe'],['safe']
Safety,. Use convert tool from ImageMagic if you want to set a different delay or enable looping. ; Definition at line 204 of file TGLAutoRotator.cxx. ◆ StartImageAutoSaveWithGUISettings(). void TGLAutoRotator::StartImageAutoSaveWithGUISettings ; (; ). Start auto-saving images as set-up via GUI. ; Definition at line 263 of file TGLAutoRotator.cxx. ◆ Stop(). void TGLAutoRotator::Stop ; (; ). Stop the auto-rotator. ; Definition at line 137 of file TGLAutoRotator.cxx. ◆ StopImageAutoSave(). void TGLAutoRotator::StopImageAutoSave ; (; ). Stops automatic saving of images. ; Definition at line 240 of file TGLAutoRotator.cxx. ◆ Streamer(). void TGLAutoRotator::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void TGLAutoRotator::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 114 of file TGLAutoRotator.h. ◆ Timeout(). void TGLAutoRotator::Timeout ; (; ). Called on every timer timeout. ; Moves / rotates the camera and optionally produces a screenshot. ; Definition at line 151 of file TGLAutoRotator.cxx. Member Data Documentation. ◆ fADolly. Double_t TGLAutoRotator::fADolly. protected . Definition at line 42 of file TGLAutoRotator.h. ◆ fATheta. Double_t TGLAutoRotator::fATheta. protected . Definition at line 41 of file TGLAutoRotator.h. ◆ fCamera. TGLCamera* TGLAutoRotator::fCamera. protected . Definition at line 31 of file TGLAutoRotator.h. ◆ fDeltaPhi. Double_t TGLAutoRotator::fDeltaPhi. protected . Definition at line 37 of file TGLAutoRotator.h. ◆ fDollyA0. Double_t TGLAutoRotator::fDollyA0. protected . Definition at line 44 of file TGLAutoRotator.h. ◆ fDt. Double_t TGLAutoRotator::fDt. protected . Definition at line 39 of file TGLAutoRotator.h. ◆ fImageAutoSave. Bool_t TGLAutoRotator::fImageAutoSave. protected . Definition at line 49 of file TGLAutoRotator.h. ◆ fImageCount. Int_t TGLAutoRotator::fImageCount. protected . Definition at line 48 of fil,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGLAutoRotator.html:20312,timeout,timeout,20312,doc/master/classTGLAutoRotator.html,https://root.cern,https://root.cern/doc/master/classTGLAutoRotator.html,1,['timeout'],['timeout']
Safety,". Works only after calling FindNextBoundary. Double_t * FindNormal(Bool_t forward = kTRUE); Computes normal vector to the next surface that will be or was already; crossed when propagating on a straight line from a given point/direction.; Returns the normal vector cosines in the MASTER coordinate system. The dot; product of the normal and the current direction is positive defined. TGeoNode * InitTrack(const Double_t* point, const Double_t* dir); Initialize current point and current direction vector (normalized); in MARS. Return corresponding node. TGeoNode * InitTrack(Double_t x, Double_t y, Double_t z, Double_t nx, Double_t ny, Double_t nz); Initialize current point and current direction vector (normalized); in MARS. Return corresponding node. void ResetState(); Reset current state flags. Double_t Safety(Bool_t inside = kFALSE); Compute safe distance from the current point. This represent the distance; from POINT to the closest boundary. void SafetyOverlaps(); Compute safe distance from the current point within an overlapping node. TGeoNode * SearchNode(Bool_t downwards = kFALSE, const TGeoNode* skipnode = 0); Returns the deepest node containing fPoint, which must be set a priori. TGeoNode * FindInCluster(Int_t* cluster, Int_t nc); Find a node inside a cluster of overlapping nodes. Current node must; be on top of all the nodes in cluster. Always nc>1. Int_t GetTouchedCluster(Int_t start, Double_t* point, Int_t* check_list, Int_t ncheck, Int_t* result); Make the cluster of overlapping nodes in a voxel, containing point in reference; of the mother. Returns number of nodes containing the point. Nodes should not be; offsets. TGeoNode * Step(Bool_t is_geom = kTRUE, Bool_t cross = kTRUE); Make a rectiliniar step of length fStep from current point (fPoint) on current; direction (fDirection). If the step is imposed by geometry, is_geom flag; must be true (default). The cross flag specifies if the boundary should be; crossed in case of a geometry step (default true). Return",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoNavigator.html:16679,Safe,SafetyOverlaps,16679,root/html528/TGeoNavigator.html,https://root.cern,https://root.cern/root/html528/TGeoNavigator.html,6,"['Safe', 'safe']","['SafetyOverlaps', 'safe']"
Safety,". Works only after calling FindNextBoundary. Double_t * FindNormal(Bool_t forward = kTRUE); Computes normal vector to the next surface that will be or was already; crossed when propagating on a straight line from a given point/direction.; Returns the normal vector cosines in the MASTER coordinate system. The dot; product of the normal and the current direction is positive defined. TGeoNode * InitTrack(const Double_t* point, const Double_t* dir); Initialize current point and current direction vector (normalized); in MARS. Return corresponding node. TGeoNode * InitTrack(Double_t x, Double_t y, Double_t z, Double_t nx, Double_t ny, Double_t nz); Initialize current point and current direction vector (normalized); in MARS. Return corresponding node. void ResetState(); Reset current state flags. Double_t Safety(Bool_t inside = kFALSE); Compute safe distance from the current point. This represent the distance; from POINT to the closest boundary. void SafetyOverlaps(); Compute safe distance from the current point within an overlapping node. TGeoNode * SearchNode(Bool_t downwards = kFALSE, const TGeoNode* skipnode = 0); Returns the deepest node containing fPoint, which must be set a priori.; Check if parallel world navigation is enabled. TGeoNode * FindInCluster(Int_t* cluster, Int_t nc); Find a node inside a cluster of overlapping nodes. Current node must; be on top of all the nodes in cluster. Always nc>1. Int_t GetTouchedCluster(Int_t start, Double_t* point, Int_t* check_list, Int_t ncheck, Int_t* result); Make the cluster of overlapping nodes in a voxel, containing point in reference; of the mother. Returns number of nodes containing the point. Nodes should not be; offsets. TGeoNode * Step(Bool_t is_geom = kTRUE, Bool_t cross = kTRUE); Make a rectiliniar step of length fStep from current point (fPoint) on current; direction (fDirection). If the step is imposed by geometry, is_geom flag; must be true (default). The cross flag specifies if the boundary should be; crossed i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoNavigator.html:17372,Safe,SafetyOverlaps,17372,root/html534/TGeoNavigator.html,https://root.cern,https://root.cern/root/html534/TGeoNavigator.html,6,"['Safe', 'safe']","['SafetyOverlaps', 'safe']"
Safety,". inline . Evaluate the loss function of the net using the activations that are currently stored in the output layer. ; Definition at line 305 of file Net.h. ◆ Loss() [2/2]. template<typename Architecture_t , typename Layer_t > . auto TMVA::DNN::TNet< Architecture_t, Layer_t >::Loss ; (; Matrix_t & ; X, . const Matrix_t & ; Y, . const Matrix_t & ; weights, . bool ; applyDropout = false, . bool ; includeRegularization = true . ). inline . Propagate the input batch X through the net and evaluate the error function for the resulting activations of the output layer. ; Definition at line 320 of file Net.h. ◆ Prediction() [1/2]. template<typename Architecture_t , typename Layer_t > . void TMVA::DNN::TNet< Architecture_t, Layer_t >::Prediction ; (; Matrix_t & ; Y_hat, . EOutputFunction ; f . ); const. inline . Compute the neural network prediction obtained from applying the output function f to the activation of the last layer in the network. ; Definition at line 339 of file Net.h. ◆ Prediction() [2/2]. template<typename Architecture_t , typename Layer_t > . void TMVA::DNN::TNet< Architecture_t, Layer_t >::Prediction ; (; Matrix_t & ; Y_hat, . Matrix_t & ; X, . EOutputFunction ; f . ). inline . Compute the neural network prediction obtained from forwarding the batch X through the neural network and applying the output function f to the activation of the last layer in the network. ; Definition at line 329 of file Net.h. ◆ Print(). template<typename Architecture_t , typename Layer_t > . void TMVA::DNN::TNet< Architecture_t, Layer_t >::Print. Definition at line 392 of file Net.h. ◆ SetBatchSize(). template<typename Architecture_t , typename Layer_t = TLayer<Architecture_t>> . void TMVA::DNN::TNet< Architecture_t, Layer_t >::SetBatchSize ; (; size_t ; batchSize). inline . Definition at line 148 of file Net.h. ◆ SetDropoutProbabilities(). template<typename Architecture_t , typename Layer_t > . void TMVA::DNN::TNet< Architecture_t, Layer_t >::SetDropoutProbabilities ; (; const s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TNet.html:14095,Predict,Prediction,14095,doc/master/classTMVA_1_1DNN_1_1TNet.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TNet.html,1,['Predict'],['Prediction']
Safety,". read table configurations as special table ; Definition at line 1054 of file TSQLFile.cxx. ◆ ReadFree(). void TSQLFile::ReadFree ; (; ). inlinefinalvirtual . Read the FREE linked list. ; Every file has a linked list (fFree) of free segments. This linked list has been written on the file via WriteFree as a single data record. ; Reimplemented from TFile.; Definition at line 239 of file TSQLFile.h. ◆ ReadSpecialObject(). TObject * TSQLFile::ReadSpecialObject ; (; Long64_t ; keyid, . TObject * ; obj = nullptr . ). protected . Read data of special kind of objects. ; Definition at line 851 of file TSQLFile.cxx. ◆ ReadSQLClassInfos(). void TSQLFile::ReadSQLClassInfos ; (; ). protected . Read all class infos from IdsTable. ; Definition at line 1911 of file TSQLFile.cxx. ◆ Recover(). Int_t TSQLFile::Recover ; (; ). inlinefinalvirtual . Attempt to recover file if not correctly closed. ; The function returns the number of keys that have been recovered. If no keys can be recovered, the file will be declared Zombie by the calling function. This function is automatically called when opening a file. If the file is open in read only mode, the file is not modified. If open in update mode and the function finds something to recover, a new directory header is written to the file. When opening the file gain no message from Recover will be reported. If keys have been recovered, the file is usable and you can safely read the corresponding objects. If the file is not usable (a zombie), you can test for this case with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {<actions to take if file is unusable>}; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; If the file has been recovered, the bit kRecovered is set in the TFile object in memory. You can test if the file has been recovered with if (f.TestBit(TFile::kRecovered)) {... the file has been recovered}; When writing TTrees to a file, it is importa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSQLFile.html:84582,recover,recovered,84582,doc/master/classTSQLFile.html,https://root.cern,https://root.cern/doc/master/classTSQLFile.html,1,['recover'],['recovered']
Safety,". static Double_t TGeoTubeSeg::DistFromOutsideS ; (; const Double_t * ; point, . const Double_t * ; dir, . Double_t ; rmin, . Double_t ; rmax, . Double_t ; dz, . Double_t ; c1, . Double_t ; s1, . Double_t ; c2, . Double_t ; s2, . Double_t ; cm, . Double_t ; sm, . Double_t ; cdfi . ). static . ◆ Divide(). TGeoVolume * TGeoTubeSeg::Divide ; (; TGeoVolume * ; voldiv, . const char * ; divname, . Int_t ; iaxis, . Int_t ; ndiv, . Double_t ; start, . Double_t ; step . ). overridevirtual . Reimplemented from TGeoTube. ◆ GetAxisRange(). Double_t TGeoTubeSeg::GetAxisRange ; (; Int_t ; iaxis, . Double_t & ; xlo, . Double_t & ; xhi . ); const. overridevirtual . Reimplemented from TGeoTube. ◆ GetBoundingCylinder(). void TGeoTubeSeg::GetBoundingCylinder ; (; Double_t * ; param); const. overridevirtual . Reimplemented from TGeoTube. ◆ GetBuffer3D(). const TBuffer3D & TGeoTubeSeg::GetBuffer3D ; (; Int_t ; reqSections, . Bool_t ; localFrame . ); const. overridevirtual . Stub implementation to avoid forcing implementation at this stage. ; Reimplemented from TGeoTube. ◆ GetByteCount(). Int_t TGeoTubeSeg::GetByteCount ; (; ); const. inlineoverridevirtual . Reimplemented from TGeoTube.; Definition at line 149 of file TGeoTube.h. ◆ GetMakeRuntimeShape(). TGeoShape * TGeoTubeSeg::GetMakeRuntimeShape ; (; TGeoShape * ; mother, . TGeoMatrix * ; mat . ); const. overridevirtual . Reimplemented from TGeoTube. ◆ GetMeshNumbers(). void TGeoTubeSeg::GetMeshNumbers ; (; Int_t & ; nvert, . Int_t & ; nsegs, . Int_t & ; npols . ); const. overridevirtual . Reimplemented from TGeoTube. ◆ GetNmeshVertices(). Int_t TGeoTubeSeg::GetNmeshVertices ; (; ); const. overridevirtual . Reimplemented from TGeoTube. ◆ GetPhi1(). Double_t TGeoTubeSeg::GetPhi1 ; (; ); const. inline . Definition at line 154 of file TGeoTube.h. ◆ GetPhi2(). Double_t TGeoTubeSeg::GetPhi2 ; (; ); const. inline . Definition at line 155 of file TGeoTube.h. ◆ GetPointsOnSegments(). Bool_t TGeoTubeSeg::GetPointsOnSegments ; (; Int_t ; npoints",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoTubeSeg.html:29974,avoid,avoid,29974,doc/master/classTGeoTubeSeg.html,https://root.cern,https://root.cern/doc/master/classTGeoTubeSeg.html,1,['avoid'],['avoid']
Safety,". std::span< double const > ; xVals, . int ; intOrder, . bool ; correctForBinSize, . bool ; cdfBoundaries . ). A vectorized version of RooDataHist::weight() for one dimensional histograms with up to one dimensional interpolation. ; Parameters. [out]outputAn array of weights corresponding the values in xVals. ; [in]xValsAn array of coordinates for which the weights should be calculated. ; [in]intOrderInterpolation order; 0th and 1st order are supported. ; [in]correctForBinSizeEnable the inverse bin volume correction factor. ; [in]cdfBoundariesEnable the special boundary condition for a cdf: Underflow bins are assumed to have weight zero and overflow bins have weight one. Otherwise, the histogram is mirrored at the boundaries for the interpolation. . Definition at line 1351 of file RooDataHist.cxx. ◆ weightSquared() [1/2]. double RooDataHist::weightSquared ; (; ); const. inlineoverridevirtual . Return squared weight of last bin that was requested with get(). ; Deprecated:Use the safer weightSquared(std::size_t) const. ; Implements RooAbsData.; Definition at line 190 of file RooDataHist.h. ◆ weightSquared() [2/2]. double RooDataHist::weightSquared ; (; std::size_t ; i); const. inline . Return squared weight sum of i-th bin. ; See alsogetIndex(). If sumw2 is not being tracked, assume that all previous fill operations had a weight of 1, i.e., return the bare weight of the bin. ; Definition at line 116 of file RooDataHist.h. ◆ wgtErrHiArray(). double const * RooDataHist::wgtErrHiArray ; (; ); const. inline . Definition at line 218 of file RooDataHist.h. ◆ wgtErrLoArray(). double const * RooDataHist::wgtErrLoArray ; (; ); const. inline . Definition at line 217 of file RooDataHist.h. Friends And Related Symbol Documentation. ◆ RooDataHistSliceIter. friend class RooDataHistSliceIter. friend . Definition at line 227 of file RooDataHist.h. Member Data Documentation. ◆ _arrSize. Int_t RooDataHist::_arrSize {0}. protected . Definition at line 246 of file RooDataHist.h. ◆ _binboun",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooDataHist.html:85554,safe,safer,85554,doc/master/classRooDataHist.html,https://root.cern,https://root.cern/doc/master/classRooDataHist.html,1,['safe'],['safer']
Safety,". ◆ Register() [4/5]. void RLoopManager::Register ; (; RFilterBase * ; filterPtr). Definition at line 959 of file RLoopManager.cxx. ◆ Register() [5/5]. void RLoopManager::Register ; (; RRangeBase * ; rangePtr). Definition at line 974 of file RLoopManager.cxx. ◆ RegisterCallback(). void RLoopManager::RegisterCallback ; (; ULong64_t ; everyNEvents, . std::function< void(unsigned int)> && ; f . ). Definition at line 1033 of file RLoopManager.cxx. ◆ Report(). void RLoopManager::Report ; (; ROOT::RDF::RCutFlowReport & ; rep); const. finalvirtual . Call FillReport on all booked filters. ; Implements ROOT::Detail::RDF::RNodeBase.; Definition at line 1012 of file RLoopManager.cxx. ◆ Run(). void RLoopManager::Run ; (; bool ; jit = true). Start the event loop with a different mechanism depending on IMT/no IMT, data source/no data source. ; Also perform a few setup and clean-up operations (jit actions if necessary, clear booked actions after the loop...). The jitting phase is skipped if the jit parameter is false (unsafe, use with care). ; Definition at line 889 of file RLoopManager.cxx. ◆ RunAndCheckFilters(). void RLoopManager::RunAndCheckFilters ; (; unsigned int ; slot, . Long64_t ; entry . ). private . Execute actions and make sure named filters are called for each event. ; Named filters must be called even if the analysis logic would not require it, lest they report confusing results. ; Definition at line 708 of file RLoopManager.cxx. ◆ RunDataSource(). void RLoopManager::RunDataSource ; (; ). private . Run event loop over data accessed through a DataSource, in sequence. ; Definition at line 635 of file RLoopManager.cxx. ◆ RunDataSourceMT(). void RLoopManager::RunDataSourceMT ; (; ). private . Run event loop over data accessed through a DataSource, in parallel. ; Definition at line 666 of file RLoopManager.cxx. ◆ RunEmptySource(). void RLoopManager::RunEmptySource ; (; ). private . Run event loop with no source files, in sequence. ; Definition at line 505 of file RLoopMa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Detail_1_1RDF_1_1RLoopManager.html:24019,unsafe,unsafe,24019,doc/master/classROOT_1_1Detail_1_1RDF_1_1RLoopManager.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Detail_1_1RDF_1_1RLoopManager.html,1,['unsafe'],['unsafe']
Safety,".""; 450 << Endl;; 451 Log() << kFATAL << ""The OPENCL architecture has not been implemented yet. ""; 452 ""Please use Architecture=CPU or Architecture=CPU for the ""; 453 ""time being. See the TMVA Users' Guide for instructions ""; 454 ""if you encounter problems.""; 455 << Endl;; 456 }; 457 ; 458 if (fArchitectureString == ""GPU"") {; 459#ifndef DNNCUDA // Included only if DNNCUDA flag is _not_ set.; 460 Log() << kERROR << ""CUDA backend not enabled. Please make sure ""; 461 ""you have CUDA installed and it was successfully ""; 462 ""detected by CMAKE.""; 463 << Endl;; 464 Log() << kFATAL << ""CUDA backend not enabled. Please make sure ""; 465 ""you have CUDA installed and it was successfully ""; 466 ""detected by CMAKE.""; 467 << Endl;; 468#endif // DNNCUDA; 469 }; 470 ; 471 if (fArchitectureString == ""CPU"") {; 472#ifndef DNNCPU // Included only if DNNCPU flag is _not_ set.; 473 Log() << kERROR << ""Multi-core CPU backend not enabled. Please make sure ""; 474 ""you have a BLAS implementation and it was successfully ""; 475 ""detected by CMake as well that the imt CMake flag is set.""; 476 << Endl;; 477 Log() << kFATAL << ""Multi-core CPU backend not enabled. Please make sure ""; 478 ""you have a BLAS implementation and it was successfully ""; 479 ""detected by CMake as well that the imt CMake flag is set.""; 480 << Endl;; 481#endif // DNNCPU; 482 }; 483 ; 484 //; 485 // Set network structure.; 486 //; 487 ; 488 fLayout = TMVA::MethodDNN::ParseLayoutString (fLayoutString);; 489 size_t inputSize = GetNVariables ();; 490 size_t outputSize = 1;; 491 if (fAnalysisType == Types::kRegression && GetNTargets() != 0) {; 492 outputSize = GetNTargets();; 493 } else if (fAnalysisType == Types::kMulticlass && DataInfo().GetNClasses() >= 2) {; 494 outputSize = DataInfo().GetNClasses();; 495 }; 496 ; 497 fNet.SetBatchSize(1);; 498 fNet.SetInputWidth(inputSize);; 499 ; 500 auto itLayout = std::begin (fLayout);; 501 auto itLayoutEnd = std::end (fLayout)-1;; 502 for ( ; itLayout != itLayoutEnd; ++itLayout) {; 503 fN",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDNN_8cxx_source.html:16223,detect,detected,16223,doc/master/MethodDNN_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDNN_8cxx_source.html,1,['detect'],['detected']
Safety,".*.Root.Html.SourceDir: .:src:include; WinNT.*.Root.Html.SourceDir: .;src;include; URL stem for ROOT documentation pages (default is """").; Root.Html.Root: http://root.cern.ch/root/html; Filesystem output directory for generated web pages (default: htmldoc).; Root.Html.OutputDir: htmldoc/; Address of the package’s home page (default: http://root.cern.ch):; Root.Html.HomePage:; Location of user defined header and footer files, see http://root.cern.ch/root/html/THtml#conf:header (defaults are """", example: ../header.txt, ../footer.txt):; Root.Html.Header:; Root.Html.Footer:; Tag for detecting class description comments (default value is set below).; Root.Html.Description: //____________________; Tag for detecting “Author” comment (default value is set below).; Root.Html.Author: // Author:; Tag for detecting “last updated” comment. THtml uses the current date if this tag is not found in a class source file (default value is set below).; Root.Html.LastUpdate: // @(#); Tag for detecting “Copyright” comment (default value is set below).; Root.Html.Copyright: * Copyright; 28.6.3 GUI Specific Settings; Set the “native” ROOT GUI interface to be used in a ROOT session.; Gui.Backend: native; Gui.Factory: native; GUI default fonts in use:; Gui.DefaultFont: -adobe-helvetica-medium-r-*-*-12-*-*-*-*-*-iso8859-1; Gui.MenuFont: -adobe-helvetica-medium-r-*-*-12-*-*-*-*-*-iso8859-1; Gui.MenuHiFont: -adobe-helvetica-bold-r-*-*-12-*-*-*-*-*-iso8859-1; Gui.DocFixedFont: -adobe-courier-medium-r-*-*-12-*-*-*-*-*-iso8859-1; Gui.DocPropFont: -adobe-helvetica-medium-r-*-*-12-*-*-*-*-*-iso8859-1; Gui.IconFont: -adobe-helvetica-medium-r-*-*-10-*-*-*-*-*-iso8859-1; Gui.StatusFont: -adobe-helvetica-medium-r-*-*-10-*-*-*-*-*-iso8859-1; Regular background and foreground colors in use:; Gui.BackgroundColor: #c0c0c0; Gui.ForegroundColor: black; Selection background and foreground colors in use:; Gui.SelectBackgroundColor: #000080; Gui.SelectForegroundColor: white; Document background and foreground col",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1260364,detect,detecting,1260364,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['detect'],['detecting']
Safety,"..; Searching...; No Matches. List of all members |; Public Member Functions |; Static Public Member Functions |; Static Private Member Functions |; Private Attributes |; List of all members ; TFilePrefetch Class ReferenceInput/Output Library. ; The prefetching mechanism uses two classes (TFilePrefetch and TFPBlock) to prefetch in advance a block of tree entries. ; There is a thread which takes care of actually transferring the blocks and making them available to the main requesting thread. Therefore, the time spent by the main thread waiting for the data before processing considerably decreases. Besides the prefetching mechanisms there is also a local caching option which can be enabled by the user. Both capabilities are disabled by default and must be explicitly enabled by the user. ; Definition at line 33 of file TFilePrefetch.h. Public Member Functions;  TFilePrefetch (TFile *);  Constructor. ;  ;  ~TFilePrefetch () override;  Destructor. ;  ; void AddPendingBlock (TFPBlock *);  Safe method to add a block to the pendingList. ;  ; void AddReadBlock (TFPBlock *);  Safe method to add a block to the readList. ;  ; Bool_t BinarySearchReadList (TFPBlock *, Long64_t, Int_t, Int_t *);  Search for a requested element in a block and return the index. ;  ; Bool_t CheckBlockInCache (char *&, TFPBlock *);  Test if the block is in cache. ;  ; TFPBlock * CreateBlockObj (Long64_t *, Int_t *, Int_t);  Create a new block or recycle an old one. ;  ; char * GetBlockFromCache (const char *, Int_t);  Return a buffer from cache. ;  ; std::condition_variable & GetCondNewBlock ();  ; TFPBlock * GetPendingBlock ();  Safe method to remove a block from the pendingList. ;  ; TThread * GetThread () const;  Return reference to the consumer thread. ;  ; Long64_t GetWaitTime ();  Return the time spent wating for buffer to be read in microseconds. ;  ; TClass * IsA () const override;  ; Bool_t IsPrefetchFinished () const;  ; void ReadAsync (TFPBlock *, Bool_t &);  Read one block and insert it in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFilePrefetch.html:1088,Safe,Safe,1088,doc/master/classTFilePrefetch.html,https://root.cern,https://root.cern/doc/master/classTFilePrefetch.html,1,['Safe'],['Safe']
Safety,"./(n-1)) * std::exp(-alpha*alpha/2.);; 136 intpow = C - A /(n-1.) * std::pow(B-z,-n+1) ;; 137 }; 138 else {; 139 // for n=1 the primitive of 1/x is log(x); 140 intpow = -A * std::log( n / abs_alpha ) + A * std::log( B -z );; 141 }; 142 intgaus = sqrtpiover2*(1.+ROOT::Math::erf(abs_alpha*oneoversqrt2));; 143 }; 144 else; 145 {; 146 intgaus = ROOT::Math::gaussian_cdf_c(z, 1);; 147 intgaus *= sqrt2pi;; 148 intpow = 0; ; 149 }; 150 return sigma * (intgaus + intpow);; 151 }; 152 ; 153 ; 154 double exponential_cdf_c(double x, double lambda, double x0); 155 {; 156 if ((x-x0) < 0) return 1.0;; 157 else return std::exp(- lambda * (x-x0));; 158 }; 159 ; 160 ; 161 double exponential_cdf(double x, double lambda, double x0); 162 {; 163 if ((x-x0) < 0) return 0.0;; 164 else // use expm1 function to avoid errors at small x; 165 return - ROOT::Math::expm1( - lambda * (x-x0) ) ;; 166 }; 167 ; 168 ; 169 double fdistribution_cdf_c(double x, double n, double m, double x0); 170 {; 171 // f distribution is defined only for both n and m > 0; 172 if (n < 0 || m < 0) return std::numeric_limits<double>::quiet_NaN();; 173 ; 174 double z = m/(m + n*(x-x0));; 175 // fox z->1 and large a and b IB looses precision use complement function; 176 if (z > 0.9 && n > 1 && m > 1) return 1.- fdistribution_cdf(x,n,m,x0);; 177 ; 178 // for the complement use the fact that IB(x,a,b) = 1. - IB(1-x,b,a); 179 return ROOT::Math::inc_beta(m/(m + n*(x-x0)), .5*m, .5*n);; 180 }; 181 ; 182 ; 183 double fdistribution_cdf(double x, double n, double m, double x0); 184 {; 185 // f distribution is defined only for both n and m > 0; 186 if (n < 0 || m < 0); 187 return std::numeric_limits<double>::quiet_NaN();; 188 ; 189 double z = n*(x-x0)/(m + n*(x-x0));; 190 // fox z->1 and large a and b IB looses precision use complement function; 191 if (z > 0.9 && n > 1 && m > 1); 192 return 1. - fdistribution_cdf_c(x,n,m,x0);; 193 ; 194 return ROOT::Math::inc_beta(z, .5*n, .5*m);; 195 }; 196 ; 197 ; 198 double gamma_cdf_c(double x,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/ProbFuncMathCore_8cxx_source.html:5290,avoid,avoid,5290,doc/master/ProbFuncMathCore_8cxx_source.html,https://root.cern,https://root.cern/doc/master/ProbFuncMathCore_8cxx_source.html,1,['avoid'],['avoid']
Safety,".17 in Hastie,Tibshirani & Friedman book this is the covariance between the estimated response yhat and the true value y. NOT REALLY SURE IF THIS IS CORRECT! — THIS IS NOT USED — ; Definition at line 925 of file RuleFitParams.cxx. ◆ Penalty(). Double_t TMVA::RuleFitParams::Penalty ; (; ); const. This is the ""lasso"" penalty To be used for regression. ; — NOT USED — ; Definition at line 356 of file RuleFitParams.cxx. ◆ Risk() [1/2]. Double_t TMVA::RuleFitParams::Risk ; (; UInt_t ; ind1, . UInt_t ; ind2, . Double_t ; neff . ); const. risk assessment ; Definition at line 314 of file RuleFitParams.cxx. ◆ Risk() [2/2]. Double_t TMVA::RuleFitParams::Risk ; (; UInt_t ; ind1, . UInt_t ; ind2, . Double_t ; neff, . UInt_t ; itau . ); const. risk assessment for tau model <itau> ; Definition at line 334 of file RuleFitParams.cxx. ◆ RiskPath(). Double_t TMVA::RuleFitParams::RiskPath ; (; ); const. inline . Definition at line 108 of file RuleFitParams.h. ◆ RiskPerf() [1/2]. Double_t TMVA::RuleFitParams::RiskPerf ; (; ); const. inline . Definition at line 109 of file RuleFitParams.h. ◆ RiskPerf() [2/2]. Double_t TMVA::RuleFitParams::RiskPerf ; (; UInt_t ; itau); const. inline . Definition at line 110 of file RuleFitParams.h. ◆ RiskPerfTst(). UInt_t TMVA::RuleFitParams::RiskPerfTst ; (; ). Estimates the error rate with the current set of parameters. ; using the <Perf> subsample. Return the tau index giving the lowest error ; Definition at line 1201 of file RuleFitParams.cxx. ◆ SetGDErrScale(). void TMVA::RuleFitParams::SetGDErrScale ; (; Double_t ; s). inline . Definition at line 85 of file RuleFitParams.h. ◆ SetGDNPathSteps(). void TMVA::RuleFitParams::SetGDNPathSteps ; (; Int_t ; np). inline . Definition at line 65 of file RuleFitParams.h. ◆ SetGDPathStep(). void TMVA::RuleFitParams::SetGDPathStep ; (; Double_t ; s). inline . Definition at line 68 of file RuleFitParams.h. ◆ SetGDTau(). void TMVA::RuleFitParams::SetGDTau ; (; Double_t ; t). inline . Definition at line 82 of file Ru",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1RuleFitParams.html:17034,Risk,RiskPerf,17034,doc/master/classTMVA_1_1RuleFitParams.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1RuleFitParams.html,1,['Risk'],['RiskPerf']
Safety,".188594 0.0151297 14758.1 0; : 19 | 0.673327 0.684121 0.189356 0.0146185 14650.5 1; : 20 | 0.68729 0.678527 0.188558 0.0148948 14741.2 2; : ; : Elapsed time for training with 3200 events: 3.82 sec ; : Evaluate deep neural network on CPU using batches with size = 256; : ; TMVA_DNN : [dataset] : Evaluation of TMVA_DNN on training sample (3200 events); : Elapsed time for evaluation of 3200 events: 0.0999 sec ; : Creating xml weight file: ␛[0;36mdataset/weights/TMVAClassification_TMVA_DNN.weights.xml␛[0m; : Creating standalone class: ␛[0;36mdataset/weights/TMVAClassification_TMVA_DNN.class.C␛[0m; Factory : Training finished; : ; Factory : Train method: PyKeras_LSTM for Classification; : ; : ; : ␛[1m================================================================␛[0m; : ␛[1mH e l p f o r M V A m e t h o d [ PyKeras_LSTM ] :␛[0m; : ; : Keras is a high-level API for the Theano and Tensorflow packages.; : This method wraps the training and predictions steps of the Keras; : Python package for TMVA, so that dataloading, preprocessing and; : evaluation can be done within the TMVA system. To use this Keras; : interface, you have to generate a model with Keras first. Then,; : this model can be loaded and trained in TMVA.; : ; : ; : <Suppress this message by specifying ""!H"" in the booking option>; : ␛[1m================================================================␛[0m; : ; : Split TMVA training data in 2560 training events and 640 validation events; : Training Model Summary; saved recurrent model model_LSTM.h5; Booking Keras model LSTM; Model: ""sequential""; _________________________________________________________________; Layer (type) Output Shape Param # ; =================================================================; reshape (Reshape) (None, 10, 30) 0 ; ; lstm (LSTM) (None, 10, 10) 1640 ; ; flatten (Flatten) (None, 100) 0 ; ; dense (Dense) (None, 64) 6464 ; ; dense_1 (Dense) (None, 2) 130 ; ; =================================================================; Total param",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:20594,predict,predictions,20594,doc/master/TMVA__RNN__Classification_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html,1,['predict'],['predictions']
Safety,".4 */; 4282 case 504:; 4283 return ""Gateway Time-out""; /* RFC2616 Section 10.5.5 */; 4284 case 505:; 4285 return ""HTTP Version not supported""; /* RFC2616 Section 10.5.6 */; 4286 case 506:; 4287 return ""Variant Also Negotiates""; /* RFC 2295, Section 8.1 */; 4288 case 507:; 4289 return ""Insufficient Storage""; /* RFC2518 Section 10.6, RFC4918; 4290 * Section 11.5 */; 4291 case 508:; 4292 return ""Loop Detected""; /* RFC5842 Section 7.1 */; 4293 ; 4294 case 510:; 4295 return ""Not Extended""; /* RFC 2774, Section 7 */; 4296 case 511:; 4297 return ""Network Authentication Required""; /* RFC 6585, Section 6 */; 4298 ; 4299 /* Other status codes, not shown in the IANA HTTP status code; 4300 * assignment.; 4301 * E.g., ""de facto"" standards due to common use, ... */; 4302 case 418:; 4303 return ""I am a teapot""; /* RFC2324 Section 2.3.2 */; 4304 case 419:; 4305 return ""Authentication Timeout""; /* common use */; 4306 case 420:; 4307 return ""Enhance Your Calm""; /* common use */; 4308 case 440:; 4309 return ""Login Timeout""; /* common use */; 4310 case 509:; 4311 return ""Bandwidth Limit Exceeded""; /* common use */; 4312 ; 4313 default:; 4314 /* This error code is unknown. This should not happen. */; 4315 if (conn) {; 4316 mg_cry_internal(conn,; 4317 ""Unknown HTTP response code: %u"",; 4318 response_code);; 4319 }; 4320 ; 4321 /* Return at least a category according to RFC 2616 Section 10. */; 4322 if (response_code >= 100 && response_code < 200) {; 4323 /* Unknown informational status code */; 4324 return ""Information"";; 4325 }; 4326 if (response_code >= 200 && response_code < 300) {; 4327 /* Unknown success code */; 4328 return ""Success"";; 4329 }; 4330 if (response_code >= 300 && response_code < 400) {; 4331 /* Unknown redirection code */; 4332 return ""Redirection"";; 4333 }; 4334 if (response_code >= 400 && response_code < 500) {; 4335 /* Unknown request error code */; 4336 return ""Client Error"";; 4337 }; 4338 if (response_code >= 500 && response_code < 600) {; 4339 /* Unknown server er",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:128550,Timeout,Timeout,128550,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,2,['Timeout'],['Timeout']
Safety,".4 */; 4283 case 504:; 4284 return ""Gateway Time-out""; /* RFC2616 Section 10.5.5 */; 4285 case 505:; 4286 return ""HTTP Version not supported""; /* RFC2616 Section 10.5.6 */; 4287 case 506:; 4288 return ""Variant Also Negotiates""; /* RFC 2295, Section 8.1 */; 4289 case 507:; 4290 return ""Insufficient Storage""; /* RFC2518 Section 10.6, RFC4918; 4291 * Section 11.5 */; 4292 case 508:; 4293 return ""Loop Detected""; /* RFC5842 Section 7.1 */; 4294 ; 4295 case 510:; 4296 return ""Not Extended""; /* RFC 2774, Section 7 */; 4297 case 511:; 4298 return ""Network Authentication Required""; /* RFC 6585, Section 6 */; 4299 ; 4300 /* Other status codes, not shown in the IANA HTTP status code; 4301 * assignment.; 4302 * E.g., ""de facto"" standards due to common use, ... */; 4303 case 418:; 4304 return ""I am a teapot""; /* RFC2324 Section 2.3.2 */; 4305 case 419:; 4306 return ""Authentication Timeout""; /* common use */; 4307 case 420:; 4308 return ""Enhance Your Calm""; /* common use */; 4309 case 440:; 4310 return ""Login Timeout""; /* common use */; 4311 case 509:; 4312 return ""Bandwidth Limit Exceeded""; /* common use */; 4313 ; 4314 default:; 4315 /* This error code is unknown. This should not happen. */; 4316 if (conn) {; 4317 mg_cry_internal(conn,; 4318 ""Unknown HTTP response code: %u"",; 4319 response_code);; 4320 }; 4321 ; 4322 /* Return at least a category according to RFC 2616 Section 10. */; 4323 if (response_code >= 100 && response_code < 200) {; 4324 /* Unknown informational status code */; 4325 return ""Information"";; 4326 }; 4327 if (response_code >= 200 && response_code < 300) {; 4328 /* Unknown success code */; 4329 return ""Success"";; 4330 }; 4331 if (response_code >= 300 && response_code < 400) {; 4332 /* Unknown redirection code */; 4333 return ""Redirection"";; 4334 }; 4335 if (response_code >= 400 && response_code < 500) {; 4336 /* Unknown request error code */; 4337 return ""Client Error"";; 4338 }; 4339 if (response_code >= 500 && response_code < 600) {; 4340 /* Unknown server er",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:128582,Timeout,Timeout,128582,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,2,['Timeout'],['Timeout']
Safety,".998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; ... (remaining 14 messages suppressed); ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=-3.35967 cHl3=-9.58704 cHq3=-6.27461; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=486.968, denominator=wrap_pdf_Int[pTV]=829530; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=486.968, denominator=wrap_pdf_Int[pTV]=829530; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=486.968, denominator=wrap_pdf_Int[pTV]=829530; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=486.968, denominator=wrap_pdf_Int[pTV]=829530; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=0.154263 cHl3=2.95902 cHq3=-2.78828; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=59.1285, denominator=wrap_pdf_Int[pTV]=200921; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Erro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf712__lagrangianmorphfit_8C.html:14434,recover,recover,14434,doc/master/rf712__lagrangianmorphfit_8C.html,https://root.cern,https://root.cern/doc/master/rf712__lagrangianmorphfit_8C.html,2,['recover'],['recover']
Safety,".; 228 SafeDelete(fAppImp);; 229}; 230 ; 231////////////////////////////////////////////////////////////////////////////////; 232/// Static method. This method should be called from static library; 233/// initializers if the library needs the low level graphics system.; 234 ; 235void TApplication::NeedGraphicsLibs(); 236{; 237 fgGraphNeeded = kTRUE;; 238}; 239 ; 240////////////////////////////////////////////////////////////////////////////////; 241/// Initialize the graphics environment.; 242/// If @param only_web is specified, only web-related part of graphics is loaded; 243 ; 244void TApplication::InitializeGraphics(Bool_t only_web); 245{; 246 if (fgGraphInit || !fgGraphNeeded); 247 return;; 248 ; 249 if (!only_web) {; 250 // Load the graphics related libraries; 251 LoadGraphicsLibs();; 252 ; 253 // Try to load TrueType font renderer. Only try to load if not in batch; 254 // mode and Root.UseTTFonts is true and Root.TTFontPath exists. Abort silently; 255 // if libttf or libGX11TTF are not found in $ROOTSYS/lib or $ROOTSYS/ttf/lib.; 256 const char *ttpath = gEnv->GetValue(""Root.TTFontPath"",; 257 TROOT::GetTTFFontDir());; 258 char *ttfont = gSystem->Which(ttpath, ""arialbd.ttf"", kReadPermission);; 259 // Check for use of DFSG - fonts; 260 if (!ttfont); 261 ttfont = gSystem->Which(ttpath, ""FreeSansBold.ttf"", kReadPermission);; 262 ; 263 #if !defined(R__WIN32); 264 if (!gROOT->IsBatch() && !strcmp(gVirtualX->GetName(), ""X11"") &&; 265 ttfont && gEnv->GetValue(""Root.UseTTFonts"", 1)) {; 266 if (gClassTable->GetDict(""TGX11TTF"")) {; 267 // in principle we should not have linked anything against libGX11TTF; 268 // but with ACLiC this can happen, initialize TGX11TTF by hand; 269 // (normally this is done by the static library initializer); 270 ProcessLine(""TGX11TTF::Activate();"");; 271 } else {; 272 TPluginHandler *h;; 273 if ((h = gROOT->GetPluginManager()->FindHandler(""TVirtualX"", ""x11ttf""))); 274 if (h->LoadPlugin() == -1); 275 Info(""InitializeGraphics"", ""no TTF support"")",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TApplication_8cxx_source.html:9041,Abort,Abort,9041,doc/master/TApplication_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html,1,['Abort'],['Abort']
Safety,".; Back in your working directory, tag correctly and then push tags.; Now, you must alert all your developers that, if they have pulled the erroneous tag to their local repository, they will need to remove the tag from their local repository with git -d <tag> and then re-pull from the repository. Otherwise, deleted tags will keep re-appearing in the remote repository and/or users will be unable to pull or push to the remote. Undo the last commit:. Undo the commit:; git reset --soft HEAD^. Do stuff.; Recommit:; git commit -a -m <message> -c ORIG_HEAD. Note that the -c ORIG_HEAD clause causes git to use the meta-data from the previous HEAD (author, etc) with the exception of the commit message. Changing the -c to -C and omitting the -m option will cause git to reuse the commit message too. Recover deleted (committed files). Get a list of all commits with deleted files:; git log --diff-filter=D --summary | less. Find your file and note the SHA1 hash for that commit.; Recover it:; git checkout <commit>^ -- file. Stage selected changes within a file. git add --patch ; Follow the on-screen directions. Tig: a simple and colored text-mode interface for Git; Tig is a command line tool that wraps many Git browse operations (like log, diff, show, status) in a colored text-mode interface based on ncurses. Tig has been written by Jonas Fonseca.; See the full Tig manual for a detailed description.; Obtaining Tig; Tig is available as package from many Linux distributions. On Debian/Ubuntu it is available with the package name tig from the default repositories.; On RHEL-based systems it is available from the additional repository RepoForge.; On OS X it is easily installed via Homebrew:; brew install tig. Tig pager mode; Many git commands can be piped into tig. When tig is invoked this way, it is in pager mode: output will be colored according to the input format, and colored.; For instance it is possible to pipe the differences of one file like this:; git diff path/to/file.cxx | ti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/git-tips-and-tricks.html:15880,Recover,Recover,15880,d/git-tips-and-tricks.html,https://root.cern,https://root.cern/d/git-tips-and-tricks.html,1,['Recover'],['Recover']
Safety,".; In case a wrong division axis is supplied, returns pointer to; volume that was divided. const char * GetAxisName(Int_t iaxis) const; Returns name of axis IAXIS. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. Double_t GetRmin(Int_t ipl) const; Returns Rmin for Z segment IPL. Double_t GetRmax(Int_t ipl) const; Returns Rmax for Z segment IPL. Double_t GetZ(Int_t ipl) const; Returns Z for segment IPL. void InspectShape() const; print shape parameters. TBuffer3D * MakeBuffer3D() const; Creates a TBuffer3D describing *this* shape.; Coordinates are in local reference frame. void SetSegsAndPols(TBuffer3D& buff) const; Fill TBuffer3D structure for segments and polygons. Double_t SafetyToSegment(const Double_t* point, Int_t ipl, Bool_t in = kTRUE, Double_t safmin = TGeoShape::Big()) const; Compute safety from POINT to segment between planes ipl, ipl+1 within safmin. Double_t Safety(const Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape, according; to option. The matching point on the shape is stored in spoint.; ---> localize the Z segment. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetDimensions(Double_t* param); Set polycone dimensions starting from an array. void SetPoints(Double_t* points) const; create polycone mesh points. void SetPoints(Float_t* points) const; create polycone mesh points. Int_t GetNmeshVertices() const; Return number of vertices of the mesh representation. void Sizeof3D() const; fill size of this 3-D object; TVirtualGeoPainter *painter = gGeoManager->GetGeomer();; if (!painter) return;; Int_t n;. n = gGeoManager->GetNsegments()+1;. Int_t numPoints = fNz*2*n;; Int_t numSegs = 4*(fNz*n-1+(fDphi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoPcon.html:16586,Safe,SafetyToSegment,16586,root/html534/TGeoPcon.html,https://root.cern,https://root.cern/root/html534/TGeoPcon.html,6,"['Safe', 'safe']","['SafetyToSegment', 'safety']"
Safety,".; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const float* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2009-12-07 13:44; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html:11189,avoid,avoid,11189,root/html526/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html,15,['avoid'],['avoid']
Safety,".; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const float* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2010-09-23 19:57; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html:11255,avoid,avoid,11255,root/html528/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html,15,['avoid'],['avoid']
Safety,".; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const float* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-07-04 15:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html:11257,avoid,avoid,11257,root/html530/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html,15,['avoid'],['avoid']
Safety,".; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const float* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html:11257,avoid,avoid,11257,root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html,15,['avoid'],['avoid']
Safety,".; The TBuffer object is filled via the class::Streamer function.; If the file is compressed (default) a second buffer is created to hold the compressed buffer.; Reservation of the corresponding space in the file by looking in the TFree list of free blocks of the file.; The buffer is written to the file. By default, the buffersize will be taken from the average buffer size of all objects written to the current file so far. Use TDirectoryFile::SetBufferSize to force a given buffer size.; If a name is specified, it will be the name of the key. If name is not given, the name of the key will be the name as returned by obj->GetName().; The option can be a combination of:; ""SingleKey""; ""Overwrite""; ""WriteDelete"" Using the ""Overwrite"" option a previous key with the same name is overwritten. The previous key is deleted before writing the new object. Using the ""WriteDelete"" option a previous key with the same name is deleted only after the new object has been written. This option is safer than kOverwrite but it is slower. The ""SingleKey"" option is only used by TCollection::Write() to write a container with a single key instead of each object in the container with its own key. An object is read from this directory via TDirectoryFile::Get. The function returns the total number of bytes written to the directory. It returns 0 if the object cannot be written. WARNING: avoid special characters like '^','$','.' in the name as they are used by the regular expression parser (see TRegexp). ; Reimplemented from TDirectory.; Definition at line 1909 of file TDirectoryFile.cxx. Member Data Documentation. ◆ fBufferSize. Int_t TDirectoryFile::fBufferSize {0}. protected . Default buffer size to create new TKeys. ; Definition at line 41 of file TDirectoryFile.h. ◆ fDatimeC. TDatime TDirectoryFile::fDatimeC. protected . Date and time when directory is created. ; Definition at line 37 of file TDirectoryFile.h. ◆ fDatimeM. TDatime TDirectoryFile::fDatimeM. protected . Date and time of last modifi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDirectoryFile.html:54444,safe,safer,54444,doc/master/classTDirectoryFile.html,https://root.cern,https://root.cern/doc/master/classTDirectoryFile.html,1,['safe'],['safer']
Safety,".Definition TEnum.h:33; TObjectMother of all ROOT objects.Definition TObject.h:41; TVirtualStreamerInfoAbstract Interface class describing Streamer information for one class.Definition TVirtualStreamerInfo.h:44; ROOT::Experimental::NTupleSize_tstd::uint64_t NTupleSize_tInteger type long enough to hold the maximum number of entries in a column.Definition RNTupleUtil.hxx:115; ROOT::Experimental::ENTupleStructureENTupleStructureThe fields in the ntuple model tree can carry different structural information about the type system.Definition RNTupleUtil.hxx:112; ROOT::Experimental::kLeaf@ kLeafDefinition RNTupleUtil.hxx:112; ROOT::Experimental::kRecord@ kRecordDefinition RNTupleUtil.hxx:112; ROOT::Internal::GetDemangledTypeNamestd::string GetDemangledTypeName(const std::type_info &t)Definition TGenericClassInfo.cxx:31; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; ROOT::Experimental::RClassField::RSubFieldInfoDefinition RField.hxx:105; ROOT::Experimental::RClassField::RSubFieldInfo::fRoleESubFieldRole fRoleDefinition RField.hxx:106; ROOT::Experimental::RClassField::RSubFieldInfo::fOffsetstd::size_t fOffsetDefinition RField.hxx:107; ROOT::Experimental::RClusterSizeWrap the integer in a struct in order to avoid template specialization clash with std::uint64_t.Definition RNTupleUtil.hxx:118; ROOT::Experimental::RClusterSize::ValueTypestd::uint64_t ValueTypeDefinition RNTupleUtil.hxx:119; ROOT::Experimental::RFieldBase::RBulkSpecDefinition RFieldBase.hxx:668; ROOT::Experimental::RFieldBase::RCreateObjectDeleter< void >Definition RField.hxx:461; ROOT::Experimental::RFieldBase::RCreateObjectDeleterDefinition RFieldBase.hxx:448; ROOT::RNTupleCardinalityHelper types to present an offset column as array of collection sizes.Definition RNTupleUtil.hxx:32. treentuplev7incROOTRField.hxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:02 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RField_8hxx_source.html:41121,avoid,avoid,41121,doc/master/RField_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RField_8hxx_source.html,1,['avoid'],['avoid']
Safety,".Print(); ; frame2 = x.frame(Title=""Fit in left/right sideband""); data.plotOn(frame2); model2.plotOn(frame2, VisualizeError=r2); model2.plotOn(frame2); model2.paramOn(frame2); frame2.Draw(); ; ; # Fit in one region; # -------------------------------------------; # Note how restricting the region to only the left tail increases; # the fit uncertainty; ; canv.cd(3); x.setRange(""leftToMiddle"", 0.0, 5.0); ; model3 = ROOT.RooAddPdf(model); r3 = model3.fitTo(data, Range=""leftToMiddle"", Save=True, PrintLevel=-1); r3.Print(); ; frame3 = x.frame(Title=""Fit from left to middle""); data.plotOn(frame3); model3.plotOn(frame3, VisualizeError=r3); model3.plotOn(frame3); model3.paramOn(frame3); frame3.Draw(); ; canv.Draw(); ; canv.SaveAs(""rf204a_extendedLikelihood.png""); [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'signalRange' created with bounds [4,6]; [#1] INFO:Minimization -- p.d.f. provides expected number of events, including extended term in likelihood.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooFitResult: minimized FCN value: -3872.49, estimated distance to minimum: 4.30406e-05; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf204a__extendedLikelihood_8py.html:4022,safe,safe,4022,doc/master/rf204a__extendedLikelihood_8py.html,https://root.cern,https://root.cern/doc/master/rf204a__extendedLikelihood_8py.html,1,['safe'],['safe']
Safety,".cxx. ◆ Close(). void TProof::Close ; (; Option_t * ; opt = """"). Close all open slave servers. ; Client can decide to shutdown the remote session by passing option is 'S' or 's'. Default for clients is detach, if supported. Masters always shutdown the remote counterpart. ; Definition at line 1798 of file TProof.cxx. ◆ CloseProgressDialog(). void TProof::CloseProgressDialog ; (; ). Close progress dialog. ; Definition at line 9283 of file TProof.cxx. ◆ Collect() [1/4]. Int_t TProof::Collect ; (; const TSlave * ; sl, . Long_t ; timeout = -1, . Int_t ; endtype = -1, . Bool_t ; deactonfail = kFALSE . ). private . Collect responses from slave sl. ; Returns the number of slaves that responded (=1). If timeout >= 0, wait at most timeout seconds (timeout = -1 by default, which means wait forever). If defined (>= 0) endtype is the message that stops this collection. ; Definition at line 2669 of file TProof.cxx. ◆ Collect() [2/4]. Int_t TProof::Collect ; (; ESlaves ; list = kActive, . Long_t ; timeout = -1, . Int_t ; endtype = -1, . Bool_t ; deactonfail = kFALSE . ). protected . Collect responses from the slave servers. ; Returns the number of slaves that responded. If timeout >= 0, wait at most timeout seconds (timeout = -1 by default, which means wait forever). If defined (>= 0) endtype is the message that stops this collection. ; Definition at line 2727 of file TProof.cxx. ◆ Collect() [3/4]. Int_t TProof::Collect ; (; TList * ; slaves, . Long_t ; timeout = -1, . Int_t ; endtype = -1, . Bool_t ; deactonfail = kFALSE . ). protected . Collect responses from the slave servers. ; Returns the number of slaves that responded. If timeout >= 0, wait at most timeout seconds (timeout = -1 by default, which means wait forever). If defined (>= 0) endtype is the message that stops this collection. ; Definition at line 2696 of file TProof.cxx. ◆ Collect() [4/4]. Int_t TProof::Collect ; (; TMonitor * ; mon, . Long_t ; timeout = -1, . Int_t ; endtype = -1, . Bool_t ; deactonfail = kFALSE . )",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:77456,timeout,timeout,77456,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,1,['timeout'],['timeout']
Safety,".cxx. ◆ StartGarbageCollection(). void TCollection::StartGarbageCollection ; (; ). static . Set up for garbage collection. ; Definition at line 696 of file TCollection.cxx. ◆ Streamer(). void TCollection::Streamer ; (; TBuffer & ; b). overridevirtual . Stream all objects in the collection to or from the I/O buffer. ; Reimplemented from TObject.; Reimplemented in TQCommand, TQUndoManager, TQConnection, THashList, THashTable, TList, TMap, TObjArray, TOrdCollection, TRefArray, TSeqCollection, TSortedList, TListOfDataMembers, TListOfEnums, TListOfEnumsWithLock, TListOfFunctions, TListOfFunctionTemplates, TGeoNavigatorArray, TGridJobStatusList, and TParallelCoordSelect.; Definition at line 606 of file TCollection.cxx. ◆ StreamerNVirtual(). void TCollection::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 222 of file TCollection.h. ◆ UseRWLock(). bool TCollection::UseRWLock ; (; Bool_t ; enable = true). virtual . Set this collection to use a RW lock upon access, making it thread safe. ; Return the previous state.; Note: To test whether the usage is enabled do: collection->TestBit(TCollection::kUseRWLock); ; Reimplemented in THashList.; Definition at line 761 of file TCollection.cxx. ◆ Write() [1/2]. Int_t TCollection::Write ; (; const char * ; name = nullptr, . Int_t ; option = 0, . Int_t ; bsize = 0 . ); const. overridevirtual . Write all objects in this collection. ; By default all objects in the collection are written individually (each object gets its own key). Note, this is recursive, i.e. objects in collections in the collection are also written individually. To write all objects using a single key specify a name and set option to TObject::kSingleKey (i.e. 1). ; Reimplemented from TObject.; Reimplemented in TMap.; Definition at line 648 of file TCollection.cxx. ◆ Write() [2/2]. Int_t TCollection::Write ; (; const char * ; name = nullptr, . Int_t ; option = 0, . Int_t ; bsize = 0 . ). overridevirtual . Write all objects in t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTCollection.html:34442,safe,safe,34442,doc/v632/classTCollection.html,https://root.cern,https://root.cern/doc/v632/classTCollection.html,2,['safe'],['safe']
Safety,".cxx:3683; TF1::EAddToListEAddToListAdd to list behavior.Definition TF1.h:240; TF1::EAddToList::kDefault@ kDefault; TF1::EAddToList::kNo@ kNo; TF1::EAddToList::kAdd@ kAdd; TF1::Derivativevirtual Double_t Derivative(Double_t x, Double_t *params=nullptr, Double_t epsilon=0.001) constReturns the first derivative of the function at point x, computed by Richardson's extrapolation metho...Definition TF1.cxx:1113; TF1::GetNumbervirtual Int_t GetNumber() constDefinition TF1.h:526; TF1::GetNDFvirtual Int_t GetNDF() constReturn the number of degrees of freedom in the fit the fNDF parameter has been previously computed du...Definition TF1.cxx:1889; TF1::fParErrorsstd::vector< Double_t > fParErrorsArray of errors of the fNpar parameters.Definition TF1.h:274; TF1::fNdimInt_t fNdimFunction dimension.Definition TF1.h:266; TF1::CalcGaussLegendreSamplingPointsstatic void CalcGaussLegendreSamplingPoints(Int_t num, Double_t *x, Double_t *w, Double_t eps=3.0e-11)Type safe interface (static method) The number of sampling points are taken from the TGraph.Definition TF1.cxx:3826; TF1::AbsValuestatic void AbsValue(Bool_t reject=kTRUE)Static function: set the fgAbsValue flag.Definition TF1.cxx:984; TF1::GetHistogramvirtual TH1 * GetHistogram() constReturn a pointer to the histogram used to visualise the function Note that this histogram is managed ...Definition TF1.cxx:1584; TF1::GetParLimitsvirtual void GetParLimits(Int_t ipar, Double_t &parmin, Double_t &parmax) constReturn limits for parameter ipar.Definition TF1.cxx:1940; TF1::fNparInt_t fNparNumber of parameters.Definition TF1.h:265; TF1::GetYaxisTAxis * GetYaxis() constGet y axis of the function.Definition TF1.cxx:2411; TF1::SetNDFvirtual void SetNDF(Int_t ndf)Set the number of degrees of freedom ndf should be the number of points used in a fit - the number of...Definition TF1.cxx:3419; TF1::GetParErrorvirtual Double_t GetParError(Int_t ipar) constReturn value of parameter number ipar.Definition TF1.cxx:1930; TF1::Classstatic TClass *",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TF1_8cxx_source.html:175721,safe,safe,175721,doc/master/TF1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html,1,['safe'],['safe']
Safety,".d.f evaluates to NaN @ numerator=wrap_pdf=-0.675078, denominator=wrap_pdf_Int[pTV]=86190.2; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=0.186765 cHl3=8.8591 cHq3=-0.971282; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=-6.32705, denominator=wrap_pdf_Int[pTV]=46316; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=0.218731 cHl3=0.37397 cHq3=-2.08166; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=38.6705, denominator=wrap_pdf_Int[pTV]=90131.3; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=38.6705, denominator=wrap_pdf_Int[pTV]=90131.3; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=38.6705, denominator=wrap_pdf_Int[pTV]=90131.3; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=38.6705, denominator=wrap_pdf_Int[pTV]=90131.3; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=3.22694 cHl3=-7.04051 cHq3=0.54016; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=-2.21831, denominator=wrap_pdf_Int[pTV]=89722.5; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=3.44258 cHl3=4.96668 cHq3=0.0273884; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf712__lagrangianmorphfit_8C.html:11548,recover,recover,11548,doc/master/rf712__lagrangianmorphfit_8C.html,https://root.cern,https://root.cern/doc/master/rf712__lagrangianmorphfit_8C.html,2,['recover'],['recover']
Safety,".d.f evaluates to NaN @ numerator=wrap_pdf=38.6705, denominator=wrap_pdf_Int[pTV]=90131.3; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=3.22694 cHl3=-7.04051 cHq3=0.54016; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=-2.21831, denominator=wrap_pdf_Int[pTV]=89722.5; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=3.44258 cHl3=4.96668 cHq3=0.0273884; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denomi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf712__lagrangianmorphfit_8C.html:12765,recover,recover,12765,doc/master/rf712__lagrangianmorphfit_8C.html,https://root.cern,https://root.cern/doc/master/rf712__lagrangianmorphfit_8C.html,2,['recover'],['recover']
Safety,".fSelectedFunctions){; 3359// int retCode = FwdDeclFromFcnDecl(*fcnDeclPtr, interp, buffer);; 3360// newFwdDeclString += Decl2FwdDecl(*fcnDeclPtr,interp);; 3361// if (-1 == retCode){; 3362// ROOT::TMetaUtils::Error(""GenerateFwdDeclString"",; 3363// ""Error generating fwd decl for function %s\n"",; 3364// fcnDeclPtr->getNameAsString().c_str());; 3365// return emptyString;; 3366// }; 3367// if (retCode == 0 && fwdDecls.insert(buffer).second); 3368// fwdDeclString+=""\""""+buffer+""\""\n"";; 3369// }; 3370 ; 3371 if (fwdDeclString.empty()) fwdDeclString = """";; 3372 return fwdDeclString;; 3373}; 3374 ; 3375////////////////////////////////////////////////////////////////////////////////; 3376/// Generate a string for the dictionary from the headers-classes map.; 3377 ; 3378const std::string GenerateStringFromHeadersForClasses(const HeadersDeclsMap_t &headersClassesMap,; 3379 const std::string &detectedUmbrella,; 3380 bool payLoadOnly = false); 3381{; 3382 std::string headerName;; 3383 ; 3384 if (genreflex::verbose); 3385 std::cout << ""Class-headers Mapping:\n"";; 3386 std::string headersClassesMapString = """";; 3387 for (auto const & classHeaders : headersClassesMap) {; 3388 if (genreflex::verbose); 3389 std::cout << "" o "" << classHeaders.first << "" --> "";; 3390 headersClassesMapString += ""\"""";; 3391 headersClassesMapString += classHeaders.first + ""\"""";; 3392 for (auto const & header : classHeaders.second) {; 3393 headerName = (detectedUmbrella == header || payLoadOnly) ? ""payloadCode"" : ""\"""" + header + ""\"""";; 3394 headersClassesMapString += "", "" + headerName;; 3395 if (genreflex::verbose); 3396 std::cout << "", "" << headerName;; 3397 if (payLoadOnly); 3398 break;; 3399 }; 3400 if (genreflex::verbose); 3401 std::cout << std::endl;; 3402 headersClassesMapString += "", \""@\"",\n"";; 3403 }; 3404 headersClassesMapString += ""nullptr"";; 3405 return headersClassesMapString;; 3406}; 3407 ; 3408////////////////////////////////////////////////////////////////////////////////; 3409 ; 3410bool Is",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rootcling__impl_8cxx_source.html:134405,detect,detectedUmbrella,134405,doc/master/rootcling__impl_8cxx_source.html,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html,1,['detect'],['detectedUmbrella']
Safety,".h""; 125#include ""TRefArray.h""; 126 ; 127using std::multimap, std::make_pair, std::string;; 128 ; 129// Mutex to protect CINT and META operations; 130// (exported to be used for similar cases in related classes); 131 ; 132TVirtualMutex* gInterpreterMutex = nullptr;; 133 ; 134namespace {; 135 ; 136 static constexpr const char kUndeterminedClassInfoName[] = ""<NOT YET DETERMINED FROM fClassInfo>"";; 137 ; 138 class TMmallocDescTemp {; 139 private:; 140 void *fSave;; 141 public:; 142 TMmallocDescTemp(void *value = nullptr) :; 143 fSave(ROOT::Internal::gMmallocDesc) { ROOT::Internal::gMmallocDesc = value; }; 144 ~TMmallocDescTemp() { ROOT::Internal::gMmallocDesc = fSave; }; 145 };; 146 ; 147 // When a new class is created, we need to be able to find; 148 // if there are any existing classes that have the same name; 149 // after any typedefs are expanded. (This only really affects; 150 // template arguments.) To avoid having to search through all classes; 151 // in that case, we keep a hash table mapping from the fully; 152 // typedef-expanded names to the original class names.; 153 // An entry is made in the table only if they are actually different.; 154 //; 155 // In these objects, the TObjString base holds the typedef-expanded; 156 // name (the hash key), and fOrigName holds the original class name; 157 // (the value to which the key maps).; 158 //; 159 class TNameMapNode : public TObjString {; 160 public:; 161 TString fOrigName;; 162 ; 163 TNameMapNode(const char *typedf, const char *orig) :; 164 TObjString (typedf),; 165 fOrigName (orig); 166 {; 167 }; 168 };; 169 ; 170}; 171 ; 172std::atomic<Int_t> TClass::fgClassCount;; 173 ; 174static bool IsFromRootCling() {; 175 // rootcling also uses TCling for generating the dictionary ROOT files.; 176 const static bool foundSymbol = dlsym(RTLD_DEFAULT, ""usedToIdentifyRootClingByDlSym"");; 177 return foundSymbol;; 178}; 179 ; 180// Implementation of the TDeclNameRegistry; 181 ; 182////////////////////////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:5524,avoid,avoid,5524,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,2,['avoid'],['avoid']
Safety,".h. ◆ GetEntry(). Long64_t TEntryList::GetEntry ; (; Long64_t ; index). virtual . Return the number of the entry #index of this TEntryList in the TTree or TChain See also Next(). ; Reimplemented in TEntryListFromFile.; Definition at line 759 of file TEntryList.cxx. ◆ GetEntryAndTree(). Long64_t TEntryList::GetEntryAndTree ; (; Long64_t ; index, . Int_t & ; treenum . ). virtual . Return the index of ""index""-th non-zero entry in the TTree or TChain and the # of the corresponding tree in the chain. ; Reimplemented in TEntryListFromFile.; Definition at line 835 of file TEntryList.cxx. ◆ GetEntryList(). TEntryList * TEntryList::GetEntryList ; (; const char * ; treename, . const char * ; filename, . Option_t * ; opt = """" . ). virtual . Return the entry list, corresponding to treename and filename By default, the filename is first tried as is, and then, if the corresponding list is not found, the filename is expanded to the absolute path, and compared again. ; To avoid it, use option ""ne"" ; Reimplemented in TEntryListFromFile.; Definition at line 889 of file TEntryList.cxx. ◆ GetFileName() [1/2]. virtual const char * TEntryList::GetFileName ; (; ); const. inlinevirtual . Reimplemented in TEntryListFromFile.; Definition at line 80 of file TEntryList.h. ◆ GetFileName() [2/2]. void TEntryList::GetFileName ; (; const char * ; filename, . TString & ; fn, . bool * ; local = nullptr . ). protected . To be able to re-localize the entry-list we identify the file by just the name and the anchor, i.e. ; we drop protocol, host, options, ... The result in the form 'file::anchor' (or 'file', if no anchor is present) is saved in 'fn'. The function optionally (is 'local' is defined) checks file locality (i.e. protocol 'file://') returning the result in '*local' . ; Definition at line 870 of file TEntryList.cxx. ◆ GetLists(). virtual TList * TEntryList::GetLists ; (; ); const. inlinevirtual . Definition at line 76 of file TEntryList.h. ◆ GetN(). virtual Long64_t TEntryList::GetN ; (; ); co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEntryList.html:33182,avoid,avoid,33182,doc/master/classTEntryList.html,https://root.cern,https://root.cern/doc/master/classTEntryList.html,1,['avoid'],['avoid']
Safety,".h. ◆ GetRmin1(). virtual Double_t TGeoCone::GetRmin1 ; (; ); const. inlinevirtual . Definition at line 76 of file TGeoCone.h. ◆ GetRmin2(). virtual Double_t TGeoCone::GetRmin2 ; (; ); const. inlinevirtual . Definition at line 78 of file TGeoCone.h. ◆ InspectShape(). void TGeoCone::InspectShape ; (; ); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoConeSeg. ◆ IsA(). TClass * TGeoCone::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TGeoBBox.; Reimplemented in TGeoConeSeg.; Definition at line 96 of file TGeoCone.h. ◆ IsCylType(). Bool_t TGeoCone::IsCylType ; (; ); const. inlineoverridevirtual . Reimplemented from TGeoBBox.; Definition at line 82 of file TGeoCone.h. ◆ MakeBuffer3D(). TBuffer3D * TGeoCone::MakeBuffer3D ; (; ); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoConeSeg. ◆ operator=(). TGeoCone & TGeoCone::operator= ; (; const TGeoCone & ; ). protecteddelete . ◆ Safety(). Double_t TGeoCone::Safety ; (; const Double_t * ; point, . Bool_t ; in = kTRUE . ); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoConeSeg. ◆ Safety_v(). void TGeoCone::Safety_v ; (; const Double_t * ; points, . const Bool_t * ; inside, . Double_t * ; safe, . Int_t ; vecsize . ); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoConeSeg. ◆ SafetyS(). static Double_t TGeoCone::SafetyS ; (; const Double_t * ; point, . Bool_t ; in, . Double_t ; dz, . Double_t ; rmin1, . Double_t ; rmax1, . Double_t ; rmin2, . Double_t ; rmax2, . Int_t ; skipz = 0 . ). static . ◆ SavePrimitive(). void TGeoCone::SavePrimitive ; (; std::ostream & ; out, . Option_t * ; option = """" . ). overridevirtual . Save a primitive as a C++ statement(s) on output stream ""out"". ; Reimplemented from TGeoBBox.; Reimplemented in TGeoConeSeg. ◆ SetConeDimensions(). void TGeoCone::SetConeDimensions ; (; Double_t ; dz, . Double_t ; rmin1, . Double_t ; rmax1, . Double",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoCone.html:31386,Safe,Safety,31386,doc/master/classTGeoCone.html,https://root.cern,https://root.cern/doc/master/classTGeoCone.html,1,['Safe'],['Safety']
Safety,".h. ◆ MakeBuffer3D(). TBuffer3D * TGeoPcon::MakeBuffer3D ; (; ); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoPgon. ◆ operator=(). TGeoPcon & TGeoPcon::operator= ; (; const TGeoPcon & ; ). protecteddelete . ◆ Phi1(). Double_t & TGeoPcon::Phi1 ; (; ). inline . Definition at line 93 of file TGeoPcon.h. ◆ Rmax(). Double_t & TGeoPcon::Rmax ; (; Int_t ; ipl). inline . Definition at line 96 of file TGeoPcon.h. ◆ Rmin(). Double_t & TGeoPcon::Rmin ; (; Int_t ; ipl). inline . Definition at line 95 of file TGeoPcon.h. ◆ Safety(). Double_t TGeoPcon::Safety ; (; const Double_t * ; point, . Bool_t ; in = kTRUE . ); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoPgon. ◆ Safety_v(). void TGeoPcon::Safety_v ; (; const Double_t * ; points, . const Bool_t * ; inside, . Double_t * ; safe, . Int_t ; vecsize . ); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoPgon. ◆ SafetyToSegment(). Double_t TGeoPcon::SafetyToSegment ; (; const Double_t * ; point, . Int_t ; ipl, . Bool_t ; in = kTRUE, . Double_t ; safmin = TGeoShape::Big() . ); const. ◆ SavePrimitive(). void TGeoPcon::SavePrimitive ; (; std::ostream & ; out, . Option_t * ; option = """" . ). overridevirtual . Save a primitive as a C++ statement(s) on output stream ""out"". ; Reimplemented from TGeoBBox.; Reimplemented in TGeoPgon. ◆ SetDimensions(). void TGeoPcon::SetDimensions ; (; Double_t * ; param). overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoPgon. ◆ SetPoints() [1/2]. void TGeoPcon::SetPoints ; (; Double_t * ; points); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoPgon. ◆ SetPoints() [2/2]. void TGeoPcon::SetPoints ; (; Float_t * ; points); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoPgon. ◆ SetSegsAndPols(). void TGeoPcon::SetSegsAndPols ; (; TBuffer3D & ; buff); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoPgon. ◆ SetSegsAndPol",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoPcon.html:31891,Safe,SafetyToSegment,31891,doc/master/classTGeoPcon.html,https://root.cern,https://root.cern/doc/master/classTGeoPcon.html,1,['Safe'],['SafetyToSegment']
Safety,".h:202; TFile::kMerge@ kMergeDefinition TFile.h:202; TFile::kNet@ kNetDefinition TFile.h:202; TFile::kFile@ kFileDefinition TFile.h:202; TFile::ShowStreamerInfovirtual void ShowStreamerInfo()Show the StreamerInfo of all classes written to this file.Definition TFile.cxx:3750; TFile::SysSeekvirtual Long64_t SysSeek(Int_t fd, Long64_t offset, Int_t whence)Interface to system lseek.Definition TFile.cxx:4525; TFile::SysStatvirtual Int_t SysStat(Int_t fd, Long_t *id, Long64_t *size, Long_t *flags, Long_t *modtime)Return file stat information.Definition TFile.cxx:4543; TFile::SysOpenvirtual Int_t SysOpen(const char *pathname, Int_t flags, UInt_t mode)Interface to system open. All arguments like in POSIX open().Definition TFile.cxx:4481; TFile::ECacheActionECacheActionTTreeCache flushing semantics.Definition TFile.h:70; TFile::kDoNotDisconnect@ kDoNotDisconnectDefinition TFile.h:70; TFile::SetOpenTimeoutstatic UInt_t SetOpenTimeout(UInt_t timeout)Sets open timeout time (in ms). Returns previous timeout value.Definition TFile.cxx:4724; TFile::ReadFreevirtual void ReadFree()Read the FREE linked list.Definition TFile.cxx:1925; TFile::Cpvirtual Bool_t Cp(const char *dst, Bool_t progressbar=kTRUE, UInt_t buffersize=1000000)Allows to copy this file to the dst URL.Definition TFile.cxx:5003; TFile::fgTsSIHashesstatic ROOT::Internal::RConcurrentHashColl fgTsSIHashes!TS Set of hashes built from read streamer infosDefinition TFile.h:120; TFile::fBytesReadExtraLong64_t fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer.Definition TFile.h:77; TFile::fBytesWriteLong64_t fBytesWriteNumber of bytes written to this file.Definition TFile.h:75; TFile::fIsRootFileBool_t fIsRootFile!True is this is a ROOT file, raw file otherwiseDefinition TFile.h:104; TFile::Flushvirtual void Flush()Synchronize a file's in-memory and on-disk states.Definition TFile.cxx:1141; TFile::fFreeTList * fFreeFree segments linked list table.Definition TFile.h:93; TFile::ReadBufferAsyncvirtual B",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:224938,timeout,timeout,224938,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['timeout'],['timeout']
Safety,".h:22; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooChebychevChebychev polynomial p.d.f.Definition RooChebychev.h:25; RooCustomizerRooCustomizer is a factory class to produce clones of a prototype composite PDF object with the same ...Definition RooCustomizer.h:36; RooDataSetContainer class to hold unbinned data.Definition RooDataSet.h:33; RooExponentialExponential PDF.Definition RooExponential.h:22; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; sigmaconst Double_t sigmaDefinition h1analysisProxy.h:11; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf207_comptoolsDefinition rf207_comptools.py:1; ; [#0] WARNING:InputArguments -- The parameter 'sigma' with range [-inf, inf] of the RooGaussian 'sig' exceeds the safe range of (0, inf). Advise to limit its range.; 1) 0x7ffcf3635ea0 RooRealVar:: x = 5 L(0 - 10) ""x""; 1) 0x7ffcf3632040 RooRealVar:: a0 = 0.5 L(0 - 1) ""a0""; 2) 0x7ffcf3632428 RooRealVar:: a1 = 0.2 L(0 - 1) ""a1""; 3) 0x7ffcf3632810 RooRealVar:: alpha = -1 C L(-INF - +INF) ""alpha""; 4) 0x7ffcf3632bf8 RooRealVar:: bkg1frac = 0.2 L(0 - 1) ""fraction of component 1 in background""; 5) 0x7ffcf3632fe0 RooRealVar:: bkgfrac = 0.5 L(0 - 1) ""fraction of background""; 6) 0x7ffcf3634428 RooRealVar:: mean = 5 C L(-INF - +INF) ""mean of gaussians""; 7) 0x7ffcf3631c58 RooRealVar:: sigma = 0.5 C L(-INF - +INF) ""width of gaussians""; RooArgSet::parameters = (a0,a1,alpha,bkg1frac,bkgfrac,mean,sigma); 1) 0x7ffcf3635228 RooAddPdf:: model[ bkgfrac * bkg + [%] * sig ] = 0.582695/1 ""g1+g2+a""; 2) 0x7ffcf3633d08 RooAddPdf:: bkg[ bkg1frac * bkg1 + [%] * bkg2 ] = 0.16539/1 ""Signal""; 3) 0x7ffcf3631230 RooChebychev:: bkg1[ x=x coefficients=(a0,a1) ] = 0.8 ""Background 1""; 4",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf207__comptools_8C.html:6485,safe,safe,6485,doc/master/rf207__comptools_8C.html,https://root.cern,https://root.cern/doc/master/rf207__comptools_8C.html,1,['safe'],['safe']
Safety,".hxx:41; ROOT::TThreadExecutor::Mapauto Map(F func, unsigned nTimes, R redfunc, unsigned nChunks) -> std::vector< InvokeResult_t< F > >Execute a function nTimes in parallel, dividing the execution in nChunks and providing a result per c...Definition TThreadExecutor.hxx:289. ROOT::TThreadExecutor::MapReduce; This set of methods behaves exactly like Map, but takes an additional function as a third argument. This function is applied to the set of objects returned by the corresponding Map execution to ""squash"" them into a single object. This function should be independent of the size of the vector returned by Map due to optimization of the number of chunks.; If this function is a binary operator, the ""squashing"" will be performed in parallel. This is exclusive to ROOT::TThreadExecutor and not any other ROOT::TExecutorCRTP-derived classes.; An integer can be passed as the fourth argument indicating the number of chunks we want to divide our work in. This may be useful to avoid the overhead introduced when running really short tasks.; Examples:; root[] ROOT::TThreadExecutor pool; auto ten = pool.MapReduce([]() { return 1; }, 10, [](const std::vector<int> &v) { return std::accumulate(v.begin(), v.end(), 0); }); root[] ROOT::TThreadExecutor pool; auto hist = pool.MapReduce(CreateAndFillHists, 10, PoolUtils::ReduceObjects);; ROOT::ExecutorUtils::ReduceObjectsMerge collection of TObjects.Definition PoolUtils.h:35; ROOT::TThreadExecutor::MapReduceauto MapReduce(F func, unsigned nTimes, R redfunc) -> InvokeResult_t< F >Execute a function nTimes in parallel (Map) and accumulate the results into a single value (Reduce).Definition TThreadExecutor.hxx:482; v@ vDefinition rootcling_impl.cxx:3687. Definition at line 41 of file TThreadExecutor.hxx. Public Member Functions;  TThreadExecutor (const TThreadExecutor &)=delete;  ;  TThreadExecutor (UInt_t nThreads=0u);  Class constructor. ;  ; template<class F , class T > ; void Foreach (F func, const std::vector< T > &args, unsigned nChunk",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1TThreadExecutor.html:3575,avoid,avoid,3575,doc/v632/classROOT_1_1TThreadExecutor.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1TThreadExecutor.html,1,['avoid'],['avoid']
Safety,".hxx:41; ROOT::TThreadExecutor::Mapauto Map(F func, unsigned nTimes, R redfunc, unsigned nChunks) -> std::vector< InvokeResult_t< F > >Execute a function nTimes in parallel, dividing the execution in nChunks and providing a result per c...Definition TThreadExecutor.hxx:289. ROOT::TThreadExecutor::MapReduce; This set of methods behaves exactly like Map, but takes an additional function as a third argument. This function is applied to the set of objects returned by the corresponding Map execution to ""squash"" them into a single object. This function should be independent of the size of the vector returned by Map due to optimization of the number of chunks.; If this function is a binary operator, the ""squashing"" will be performed in parallel. This is exclusive to ROOT::TThreadExecutor and not any other ROOT::TExecutorCRTP-derived classes.; An integer can be passed as the fourth argument indicating the number of chunks we want to divide our work in. This may be useful to avoid the overhead introduced when running really short tasks.; Examples:; root[] ROOT::TThreadExecutor pool; auto ten = pool.MapReduce([]() { return 1; }, 10, [](const std::vector<int> &v) { return std::accumulate(v.begin(), v.end(), 0); }); root[] ROOT::TThreadExecutor pool; auto hist = pool.MapReduce(CreateAndFillHists, 10, PoolUtils::ReduceObjects);; ROOT::ExecutorUtils::ReduceObjectsMerge collection of TObjects.Definition PoolUtils.h:35; ROOT::TThreadExecutor::MapReduceauto MapReduce(F func, unsigned nTimes, R redfunc) -> InvokeResult_t< F >Execute a function nTimes in parallel (Map) and accumulate the results into a single value (Reduce).Definition TThreadExecutor.hxx:482; v@ vDefinition rootcling_impl.cxx:3699. Definition at line 41 of file TThreadExecutor.hxx. Public Member Functions;  TThreadExecutor (const TThreadExecutor &)=delete;  ;  TThreadExecutor (UInt_t nThreads=0u);  Class constructor. ;  ; template<class F , class T > ; void Foreach (F func, const std::vector< T > &args, unsigned nChunk",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1TThreadExecutor.html:3576,avoid,avoid,3576,doc/master/classROOT_1_1TThreadExecutor.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1TThreadExecutor.html,1,['avoid'],['avoid']
Safety,".pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TTimer. class TTimer: public TSysEvtHandler. TTimer. Handles synchronous and a-synchronous timer events.; 1. synchronous timer is registered into TSystem and is processed; within the standard ROOT event-loop.; 2. asynchronous timer is passed to the operating system which sends; an external signal to ROOT and thus interrupts its event-loop. You can use this class in one of the following ways:; - Sub-class TTimer and override the Notify() method.; - Re-implement the TObject::HandleTimer() method in your class; and pass a pointer to this object to timer, see the SetObject(); method.; - Pass an interpreter command to timer, see SetCommand() method.; - Create a TTimer, connect its Timeout() signal to the; appropriate methods. Then when the time is up it will emit a; Timeout() signal and call connected slots. Minimum timeout interval is defined in TSystem::ESysConstants as; kItimerResolution (currently 10 ms). Signal/slots example:; TTimer *timer = new TTimer();; timer->Connect(""Timeout()"", ""myObjectClassName"",; myObject, ""TimerDone()"");; timer->Start(2000, kTRUE); // 2 seconds single-shot. To emit the Timeout signal repeadetly with minimum timeout:; timer->Start(0, kFALSE);. Function Members (Methods); public:. virtual~TTimer(); voidTObject::AbstractMethod(const char* method) const; voidTSysEvtHandler::Activate(); virtual voidTSysEvtHandler::Activated()SIGNAL ; virtual voidAdd(); virtual voidTSysEvtHandler::Added()SIGNAL ; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; Bool_tCheckTimer(const TTime& now); static TClass*Class(); virtual const char*TObject::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTimer.html:1088,timeout,timeout,1088,root/html602/TTimer.html,https://root.cern,https://root.cern/root/html602/TTimer.html,2,['timeout'],['timeout']
Safety,"/ Add a timer to the system eventloop by calling TurnOn().; 116/// The interpreter will execute command from Notify().; 117 ; 118TTimer::TTimer(const char *command, Long_t ms, Bool_t mode) : fTime(ms); 119{; 120 fObject = nullptr;; 121 fCommand = command;; 122 fSync = mode;; 123 fIntSyscalls = kFALSE;; 124 Reset();; 125}; 126 ; 127////////////////////////////////////////////////////////////////////////////////; 128/// Check if timer timed out.; 129 ; 130Bool_t TTimer::CheckTimer(const TTime &now); 131{; 132 if (fAbsTime <= now) {; 133 fTimeout = kTRUE;; 134 Notify();; 135 return kTRUE;; 136 }; 137 return kFALSE;; 138}; 139 ; 140////////////////////////////////////////////////////////////////////////////////; 141/// Notify when timer times out. The timer is always reset. To stop; 142/// the timer call TurnOff(). Make sure to call Reset() also in derived; 143/// Notify() so timers will keep working repeatedly.; 144 ; 145Bool_t TTimer::Notify(); 146{; 147 Timeout(); // emit Timeout() signal; 148 if (fObject) fObject->HandleTimer(this);; 149 if (fCommand && fCommand.Length() > 0); 150 gROOT->ProcessLine(fCommand);; 151 ; 152 Reset();; 153 return kTRUE;; 154}; 155 ; 156////////////////////////////////////////////////////////////////////////////////; 157/// Reset the timer.; 158 ; 159void TTimer::Reset(); 160{; 161 // make sure gSystem exists; 162 ROOT::GetROOT();; 163 ; 164 fTimeout = kFALSE;; 165 fAbsTime = fTime;; 166 if (gSystem) {; 167 fAbsTime += gSystem->Now();; 168 if (!fSync) gSystem->ResetTimer(this);; 169 }; 170}; 171 ; 172////////////////////////////////////////////////////////////////////////////////; 173/// Set the interpreter command to be executed at time out. Removes the; 174/// object to be notified (if it was set).; 175 ; 176void TTimer::SetCommand(const char *command); 177{; 178 fObject = nullptr;; 179 fCommand = command;; 180}; 181 ; 182////////////////////////////////////////////////////////////////////////////////; 183/// Set the object to be notifi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTimer_8cxx_source.html:5214,Timeout,Timeout,5214,doc/master/TTimer_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTimer_8cxx_source.html,2,['Timeout'],['Timeout']
Safety,"/ after the host or port specifier; (see last example). Further the expansion of the standard shell; characters, like ~, $, .., are handled as expected.; TNetFile (actually TUrl) uses 1094 as default port for rootd. Connecting to a rootd requires the remote user id and password.; TNetFile allows three ways for you to provide your login:; 1) Setting it globally via the static functions:; TAuthenticate::SetGlobalUser() and; TAuthenticate::SetGlobalPasswd(); 2) Getting it from the ~/.netrc file (same file as used by ftp); 3) Command line prompt; The different methods will be tried in the order given above.; On machines with AFS rootd will authenticate using AFS (if it was; compiled with AFS support). If the protocol is specified as ""roots"" a secure authetication; method will be used. The secure method uses the SRP, Secure Remote; Passwords, package. SRP uses a so called ""asymmetric key exchange //; protocol"" in which no passwords are ever send over the wire. This //; protocol is safe against all known security attacks. For more see:. NetFile //; ; //; If the protocol is specified as ""rootk"" kerberos5 will be used for; authentication. The rootd daemon lives in the directory $ROOTSYS/bin. It can be; started either via inetd or by hand from the command line (no need; to be super user). For more info about rootd see the web page:. NetFile //; ; //. Function Members (Methods); public:. TNetFile(); TNetFile(const char* url, Option_t* option = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); virtual~TNetFile(); voidTObject::AbstractMethod(const char* method) const; virtual voidTDirectoryFile::Add(TObject* obj, Bool_t replace = kFALSE); static voidTDirectory::AddDirectory(Bool_t add = kTRUE); static Bool_tTDirectory::AddDirectoryStatus(); virtual voidTDirectoryFile::Append(TObject* obj, Bool_t replace = kFALSE); virtual Int_tTDirectoryFile::AppendKey(TKey* key); virtual voidTObject::AppendPad(Option_t* option = """"); static TFileOpenHandle*TFile::AsyncOpen(co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TNetFile.html:1909,safe,safe,1909,root/html528/TNetFile.html,https://root.cern,https://root.cern/root/html528/TNetFile.html,4,['safe'],['safe']
Safety,"/ after the host or port specifier; (see last example). Further the expansion of the standard shell; characters, like ~, $, .., are handled as expected.; TNetFile (actually TUrl) uses 1094 as default port for rootd. Connecting to a rootd requires the remote user id and password.; TNetFile allows three ways for you to provide your login:; 1) Setting it globally via the static functions:; TAuthenticate::SetGlobalUser() and; TAuthenticate::SetGlobalPasswd(); 2) Getting it from the ~/.netrc file (same file as used by ftp); 3) Command line prompt; The different methods will be tried in the order given above.; On machines with AFS rootd will authenticate using AFS (if it was; compiled with AFS support). If the protocol is specified as ""roots"" a secure authetication; method will be used. The secure method uses the SRP, Secure Remote; Passwords, package. SRP uses a so called ""asymmetric key exchange //; protocol"" in which no passwords are ever send over the wire. This //; protocol is safe against all known security attacks. For more see:. NetFile //; ; //; If the protocol is specified as ""rootk"" kerberos5 will be used for; authentication. The rootd daemon lives in the directory $ROOTSYS/bin. It can be; started either via inetd or by hand from the command line (no need; to be super user). For more info about rootd see the web page:. NetFile //; ; //. Function Members (Methods); public:. TNetSystem(Bool_t ftpowner = kTRUE); TNetSystem(const char* url, Bool_t ftpowner = kTRUE); virtual~TNetSystem(); virtual voidTSystem::Abort(int code = 0); voidTObject::AbstractMethod(const char* method) const; virtual intTSystem::AcceptConnection(int sock); virtual Bool_tAccessPathName(const char* path, EAccessMode mode); virtual voidTSystem::AddDynamicPath(const char* pathname); virtual voidTSystem::AddFileHandler(TFileHandler* fh); virtual voidTSystem::AddIncludePath(const char* includePath); virtual voidTSystem::AddLinkedLibs(const char* linkedLib); virtual voidTSystem::AddSignalHandler(TS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TNetSystem.html:1917,safe,safe,1917,root/html530/TNetSystem.html,https://root.cern,https://root.cern/root/html530/TNetSystem.html,3,['safe'],['safe']
