quality_attribute,sentence,source,author,repo,version,id,keyword,matched_word,match_idx,filename,wiki,url,total_similar,target_keywords,target_matched_words
Usability,". CodeChecker: running the analyzer from the command line. CodeChecker: running the analyzer from the command line; Basic Usage. Install CodeChecker as described here: CodeChecker Install Guide. Create a compilation database. If you use cmake then pass the -DCMAKE_EXPORT_COMPILE_COMMANDS=1 parameter to cmake. Cmake will create a compile_commands.json file.; If you have a Makefile based or similar build system then you can log the build commands with the help of CodeChecker:. make clean; CodeChecker log -b ""make"" -o compile_commands.json. Analyze your project. CodeChecker analyze compile_commands.json -o ./reports. View the analysis results.; Print the detailed results in the command line:. CodeChecker parse --print-steps ./reports. Or view the detailed results in a browser:. CodeChecker parse ./reports -e html -o ./reports_html; firefox ./reports_html/index.html. Optional: store the analysis results in a DB. mkdir ./ws; CodeChecker server -w ./ws -v 8555 &; CodeChecker store ./reports --name my-project --url http://localhost:8555/Default. Optional: manage (categorize, suppress) the results in your web browser:. firefox http://localhost:8555/Default. Detailed Usage. For extended documentation please refer to the official site of CodeChecker!. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/codechecker.html:188,Guid,Guide,188,interpreter/llvm-project/clang/www/analyzer/codechecker.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/codechecker.html,1,['Guid'],['Guide']
Usability,". Core Libraries; ROOT Error Handlers; There is a new rootrc variable which allows to control the; installation of the ROOT error handlers. By default the handlers; are activated:. Root.ErrorHandlers: 1. but setting the value to 0 result in no error handlers being installed; and the originals remaining in place. This can be useful if ROOT is used in; conjunction with other frameworks that already installed their own handlers. TString; TString::Hash() and thus also TMath::Hash() now use MurmurHash3_x64_128; from http://code.google.com/p/smhasher/ which is public domain.; To accelerate the hash in the case of pointers even further, pointers (and same-sized texts) are hashed using a simple bitwise xor.; This dramatically increases the hash performance for long texts, and still by a factor 5 for pointers.; The pointer case is most visible for certain I/O operations (TExMap).; TColor; Add the method SetAlpha() to set the alpha value (transparency; level) for an existing color. TStyle. The default font set by gStyle->SetLegendFont() was ignored. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/doc/v534/index.html:689,simpl,simple,689,core/doc/v534/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/doc/v534/index.html,1,['simpl'],['simple']
Usability,". Core. New class TBase64 providing Base64 encoding and decoding. Base64 encoded; messages are typically used in authentication protocols and to pack binary; data in HTTP or mail messages. New method in TSystem:. TString TSystem::GetFromPipe(const char *command). which executes ""command"" in the shell and returns the output in the TString.; Multi-line output is separated by \n's. Add proper support for Microsoft Visual C++ 9.0; Add support for 'unix' sockets on Windows.; New method TString::Clear() to reset the string but not to resize it to the default; (small) size. Useful when the string was pre-allocated to a large size and; has to be re-used.; Insure that ROOT's autoloader is always enabled whenever loading rootmap files.; Add function void TAttAxis::SetNdivisions(Int_t n1, Int_t n2, Int_t n3, Bool_t optim); ; Enable autoloading of typedef.; The statically linked roota executable and libRoot.a are currently; only supported on Linux platforms. We hope to extend this to MacOS X; soon. Meta. Add new macro ClassDefNV (ClassDef Non Virtual) which does not define any virtual function. ClassDef does define IsA, Streamer and ShowMember as virtual. This should be used only in classes that are never inherited from!; Improve performance of TClass::GetMethod (and friends). ACLiC. Implement TClassEdit::InsertStd() which puts ""std::"" in front of all STL classes.; The generated library now always checks with which version of ROOT the library was build and rebuilt the library if the running version of ROOT is different.; Add support for '+' character embedded in the script's name or directory name.; The dependency tracking file (script_C.d) is now always created when the library is built.; The dependency tracking file now records with which version of ROOT the library was built and the library is now rebuilt if it is loaded in a different version of ROOT. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/doc/v524/index.html:495,Clear,Clear,495,core/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/doc/v524/index.html,1,['Clear'],['Clear']
Usability,". Core. The ROOT source directory has been drastically reorganized and simplified.; Each source directory containing the code for a single library or plugin,; were all in the same top level directory, without logical grouping.; This made it difficult to see which libraries were related and belonged; together. In the new structure we've added a set of meta directories; that are used to group the sources of related libraries, and that also; reflects the ROOT team work package structure.; Note, the name and number of libraries has not been changed.; This new structure also facilitates the maintaining of the release notes; and other documentation items per meta package. On Linux, MacOS X and Windows, there is no need anymore to define the; environment variable ROOTSYS. Internally ROOTSYS is set depending on the; location of the ROOT libraries. ROOTSYS was never needed when ROOT was; configured using --prefix. On MacOS X when configure'ing with --enable-rpath (and not specifying; --prefix) the installation does not need (DY)LD_LIBRARY_PATH to be set; anymore. The installation is completely relocatable. The (DY)LD_LIBRARY_PATH; is determined relative to the location of the root executable. On Windows .root files are now associated with the most recently executed; ROOT installation, i.e. run ROOT once and .root files open with ROOT. Class TMessageHandler derives now from TQObject and does emit signals.; This allows for easier usage of this class. In this release xrootd and libAfterImage are managed in Subversion; via so called ""vendor branches"". This is completely transparent; except for people who do directly use svn. You will get the message:. $ svn up; svn: Failed to add directory 'xrootd/src/xrootd': object of the same name already exists; $ rm -rf xrootd/src/xrootd; $ svn up; svn: Failed to add directory 'asimage/src/libAfterImage': object of the same name already exists; $ rm -rf asimage/src/libAfterImage; $ svn up. Port to gcc 4.3.1. This version of gcc is much stric",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/doc/v520/index.html:71,simpl,simplified,71,core/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/doc/v520/index.html,1,['simpl'],['simplified']
Usability,". Due to the self-containment of assemblies, they are very; practical to use when a container is hard to define due to possible; overlaps during positioning. For instance, it is very easy creating; honeycomb structures. A very useful example for creating and using; assemblies can be found at:; <http://root.cern.ch/root/html/examples/assembly.C.html>`.`. Creation of an assembly is very easy: one has just to create a; **`TGeoVolumeAssembly`** object and position the components inside as; for any volume:. ``` {.cpp}; TGeoVolume *vol = new TGeoVolumeAssembly(name);; vol->AddNode(vdaughter1, cpy1, matrix1);; vol->AddNode(vdaughter2, cpy2, matrix2);; ```. Note that components cannot be declared as ""overlapping"" and that a; component can be an assembly volume. For existing flat volume; structures, one can define assemblies to force a hierarchical structure; therefore optimizing the performance. Usage of assemblies does NOT imply; penalties in performance, but in some cases, it can be observed that it; is not as performing as bounding the structure in a container volume; with a simple shape. Choosing a normal container is therefore; recommended whenever possible. ![Assemblies of volumes](pictures/080001CF.png). ### Geometrical Transformations. All geometrical transformations handled by the modeller are provided as; a built-in package. This was designed to minimize memory requirements; and optimize performance of point/vector master-to-local and; local-to-master computation. We need to have in mind that a; transformation in **`TGeo`** has two major use-cases. The first one is; for defining the placement of a volume with respect to its container; reference frame. This frame will be called 'master' and the frame of the; positioned volume - 'local'. If `T` is a transformation used for; positioning volume daughters, then: `MASTER = T * LOCAL`. Therefore `T `is used to perform a local to master conversion, while; `T-1` for a master to local conversion. The second use case is the;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:90843,simpl,simple,90843,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['simpl'],['simple']
Usability,". Extensible: It is very simple to add a new argument type to CommandLine.; Simply specify the parser that you want to use with the command line option; when you declare it. `Custom parsers`_ are no problem. #. Labor Saving: The CommandLine library cuts down on the amount of grunt work; that you, the user, have to do. For example, it automatically provides a; ``-help`` option that shows the available command line options for your tool.; Additionally, it does most of the basic correctness checking for you. #. Capable: The CommandLine library can handle lots of different forms of; options often found in real programs. For example, `positional`_ arguments,; ``ls`` style `grouping`_ options (to allow processing '``ls -lad``'; naturally), ``ld`` style `prefix`_ options (to parse '``-lmalloc; -L/usr/lib``'), and interpreter style options. This document will hopefully let you jump in and start using CommandLine in your; utility quickly and painlessly. Additionally it should be a simple reference; manual to figure out how stuff works. Quick Start Guide; =================. This section of the manual runs through a simple CommandLine'ification of a; basic compiler tool. This is intended to show you how to jump into using the; CommandLine library in your own program, and show you some of the cool things it; can do. To start out, you need to include the CommandLine header file into your program:. .. code-block:: c++. #include ""llvm/Support/CommandLine.h"". Additionally, you need to add this as the first line of your main program:. .. code-block:: c++. int main(int argc, char **argv) {; cl::ParseCommandLineOptions(argc, argv);; ...; }. ... which actually parses the arguments and fills in the variable declarations. Now that you are ready to support command line arguments, we need to tell the; system which ones we want, and what type of arguments they are. The CommandLine; library uses a declarative syntax to model command line arguments with the; global variable declarations that ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst:3580,simpl,simple,3580,interpreter/llvm-project/llvm/docs/CommandLine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst,1,['simpl'],['simple']
Usability,". GUI Libraries; TRootBrowser. Following a user request on savannah,; a filtering mechanism in the browser has been implemented. To filter the content of a file; (or a folder inside a file), simply click on the ""Filter"" button. A dialog will popup, asking; for a filtering expression string (regexp like). The filter will then be applied on the current; list tree item (folder) and will stay active until a wildcard (""*"") expression or an empty; string ("""") is entered as new filtering value. The filter button automatically reflects the; status of any selected list tree item, and if a filter is active on it, the button state is; ""engaged"" and its tooltip shows what is actually displayed in this file/folder. It is possible; to filter several files/folders, each one having its own filtering argument. TGNumberEntry. Fix a possible overflow when entering a float having its fraction part exceeding kMaxInt (e.g 9.9999999999). This fix the bug #84033, TGNumberEntryField. TTreeViewer. Make the ""Histogram"" text entry expanding in X direction (i.e. resize it when resizing the tree viewer). TGInputDialog. Implemented a hack to detect if user press cancel or if an empty string ("""") has been selected.; When the Cancel button is pressed, the first two characters are reset to 0, and if the user select; an empty string ("""") the first character is reset to 0 and the second one is set to 1. TGPrintDialog. The ""Printer"" text entry has been replaced by a combo box populated with the list of available printers on the system, and select the default one, if any. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/doc/v532/index.html:191,simpl,simply,191,gui/doc/v532/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/doc/v532/index.html,1,['simpl'],['simply']
Usability,". GUI; TRootCanvas. In SetWindowSize the event queue is flushed to make sure; the window size change is really done. TRootContextMenu. When creating the dialog from the context menu, skip arguments that are pointers (but not char *) and have a default value. This should avoid confusing input fields in dialog.; Implemented online help in root dialogs (the dialog boxes used with contextual menus) via a new ""Online Help"" button. This opens a Root HTML browser at the right class/method location in the Root reference guide on the web.; The base url can be changed with the Browser.StartUrl option in system.rootrc (by default: http://root.cern.ch/root/html/ClassIndex.html); Added a small '?' on the right of the context menu entries, giving access to online help. TGMenu. Add possibility to add a right aligned shortcut by using a tab character ('\t') before the shortcut string, as shown below:; fMenuFile->AddEntry(""&Open...\tCtrl+O"", kOpenFile);; Use new way of adding right aligned shortcuts in the menu entries in most of the GUI classes using shortcuts in their menu. TGSlider. Added HandleConfigureNotify() to handle resizing events. New Browser. Automatically browse ROOT files if there is any open when starting the browser.; Correct system files manipulations (copy, rename, delete) and automatic update of the list tree. GUIHTML; TGHtmlBrowser. Added ability to display single picture from the web and to open pdf files with external viewer (Windows only); Implemented anchor navigation (e.g. http://root.cern.ch/root/html/TH1.html#TH1:Multiply). ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/doc/v524/index.html:518,guid,guide,518,gui/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/doc/v524/index.html,1,['guid'],['guide']
Usability,". Given. #pragma omp parallel; ;; #pragma omp parallel; {}. ``ompExecutableDirective(hasStructuredBlock(nullStmt()))`` will match ``;``. Matcher<ObjCInterfaceDecl>isDerivedFromMatcher<NamedDecl> Base; Matches C++ classes that are directly or indirectly derived from a class; matching Base, or Objective-C classes that directly or indirectly; subclass a class matching Base. Note that a class is not considered to be derived from itself. Example matches Y, Z, C (Base == hasName(""X"")); class X;; class Y : public X {}; // directly derived; class Z : public Y {}; // indirectly derived; typedef X A;; typedef A B;; class C : public B {}; // derived from a typedef of X. In the following example, Bar matches isDerivedFrom(hasName(""X"")):; class Foo;; typedef Foo X;; class Bar : public Foo {}; // derived from a type that X is a typedef of. In the following example, Bar matches isDerivedFrom(hasName(""NSObject"")); @interface NSObject @end; @interface Bar : NSObject @end. Usable as: Matcher<CXXRecordDecl>, Matcher<ObjCInterfaceDecl>. Matcher<ObjCInterfaceDecl>isDirectlyDerivedFromMatcher<NamedDecl> Base; Matches C++ or Objective-C classes that are directly derived from a class; matching Base. Note that a class is not considered to be derived from itself. Example matches Y, C (Base == hasName(""X"")); class X;; class Y : public X {}; // directly derived; class Z : public Y {}; // indirectly derived; typedef X A;; typedef A B;; class C : public B {}; // derived from a typedef of X. In the following example, Bar matches isDerivedFrom(hasName(""X"")):; class Foo;; typedef Foo X;; class Bar : public Foo {}; // derived from a type that X is a typedef of. Matcher<ObjCInterfaceDecl>isSameOrDerivedFromMatcher<NamedDecl> Base; Similar to isDerivedFrom(), but also matches classes that directly; match Base. Matcher<ObjCMessageExpr>calleeMatcher<Decl> InnerMatcher; Matches 1) if the call expression's callee's declaration matches the; given matcher; or 2) if the Obj-C message expression's callee's met",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:219282,Usab,Usable,219282,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['Usab'],['Usable']
Usability,". Graphical Output; PostScript and PDF. The marker size between the screen output and the output file formats; was not consistent.; Implement the text kerning. The effect is clearly illustrated with; the following script. Without kerning the red X is overlaped by the; the rest of the text.; ; {; TCanvas *c = new TCanvas;; TLatex *l = new TLatex(0.5, 0.5, ""AVAVAVAVAVAVAVAVAVA#color[2]{X}"");; l->Draw();; c->SaveAs(""c1.eps"");; }; ; The original idea came from Oleksandr Grebenyuk. It has been implemented; in a such way that the kerning mechanism is activated only when needed. If; not needed the old way of text rendering is used. It was done that way; because most of the time kerning is not needed and text rendered using; the kerning mechanism takes more space in the PS/PDF files.; Very long text strings made wrong PS files.; PDF also allows to define table of contents. Now, this facility can be used; in ROOT. The following example shows how to proceed:; ; {; TCanvas* canvas = new TCanvas(""canvas"");; TH1F* histo = new TH1F(""histo"",""test 1"",10,0.,10.);; histo->SetFillColor(2);; histo->Fill(2.);; histo->Draw();; canvas->Print(""plots.pdf("",""Title:One bin filled"");; histo->Fill(4.);; histo->Draw();; canvas->Print(""plots.pdf"",""Title:Two bins filled"");; histo->Fill(6.);; histo->Draw();; canvas->Print(""plots.pdf"",""Title:Three bins filled"");; histo->Fill(8.);; histo->Draw();; canvas->Print(""plots.pdf"",""Title:Four bins filled"");; histo->Fill(8.);; histo->Draw();; canvas->Print(""plots.pdf)"",""Title:The fourth bin content is 2"");; }; ; Each character string following the keyword ""Title:"" makes a new entry in; the table of contents.; TPostScript::Text: Inside a string, the backslash itself is now; escaped. The PS file generated by the two following lines did not work.; ; TText t(.5,.5,""\\t\\"");; t.Draw();; . Small fix regarding line width in TPDF.; In some cases there was some extra blanck page at the beginning of the; PDF files. In particular when generated using the ""[]"" mechanism. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/doc/v528/index.html:174,clear,clearly,174,graf2d/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/doc/v528/index.html,1,['clear'],['clearly']
Usability,". Graphical Output; TASImage / libAfterImage. In TImageDump the way the markers 6 and 7 are drawn; (medium dot and big dot) has been changed to make sure they have; the same size as the one on screen.; Changes in libAfterImage (draw.c & draw.h), TASImage.cxx; and TImageDump.cxx in order to produce nice looking; circular (hollow and solid) markers. Previously the line; used to draw hollow circular markers looked very thick and; the solid ones did not look circular.; Remove the global variable named ""dpy"" in libAfterImage. It produced; an error if a user program used that simple variable name. ""dpy""; was a pointer to a ""Display"". PostScript and PDF. Now, a text with size 0 is not drawn in PDF files. An invalid; PDF file is created if a text with size 0 is produced.; The landscape orientation is now correct in pdf files. gv recognizes; the files as ""Landscape"" and the orientation is not upside down; as it was before (seascape).; In PostScript and PDF files the method DrawPS is used to write; a single (x,y) position.; This case was not treated correctly and, because of that, the PS and PDF; files might contain useless attributes settings. That was only a few; bytes more in the file but they were useless. TLegend. When a object is added ""by name"" in a legend, the; TMultiGraph and THStack present in the current pad; are scanned if an object with this name has not been; found in the pad. Previously the graphs and histograms; were hidden in multi-graphs and histogram-stacks when one; tried to add them by name.; New reference guide. TGaxis. In PaintAxis The option ""U"", for unlabeled axis, was not; implemented in case of alphanumeric axis' labels.; On log-scale TGAxis, with labels having lower values than 1 and ticks marks; set to the positive side, alignement issues seem to come up.; The following example shows four TGAxis drawn respectively with the; following options: RG-, RG+, LG-, LG+. For the RG+ and LG+ options,; the 10E-1 and 10E-2 labels were ill-aligned, showing a sh",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/doc/v524/index.html:577,simpl,simple,577,graf2d/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/doc/v524/index.html,1,['simpl'],['simple']
Usability,". H No False − Print method-specific help message. CreateMVAPdfs No False − Create PDFs for classifier outputs (signal and background). IgnoreNegWeightsInTraining No False − Events with negative weights are ignored in the training (but are included for testing and performance evaluation). NTrees No 800 − Number of trees in the forest. MaxDepth No 3 − Max depth of the decision tree allowed. MinNodeSize No 5% − Minimum percentage of training events required in a leaf node (default: Classification: 5%, Regression: 0.2%). nCuts No 20 − Number of grid points in variable range used in finding optimal cut in node splitting. BoostType No AdaBoost AdaBoost, RealAdaBoost, Bagging, AdaBoostR2, Grad Boosting type for the trees in the forest . AdaBoostR2Loss No Quadratic Linear, Quadratic, Exponential Type of Loss function in AdaBoostR2. UseBaggedGrad No False − Use only a random subsample of all events for growing the trees in each iteration. (Only valid for GradBoost). Shrinkage No 1 − Learning rate for GradBoost algorithm. AdaBoostBeta No 0.5 − Learning rate for AdaBoost algorithm. UseRandomisedTrees No False − Determine at each node splitting the cut variable only as the best out of a random subset of variables (like in RandomForests). UseNvars No 2 − Size of the subset of variables used with RandomisedTree option. UsePoissonNvars No True − Interpret UseNvars not as fixed number but as mean of a Possion distribution in each split with RandomisedTree option. BaggedSampleFraction No 0.6 − Relative size of bagged event sample to original size of the data sample (used whenever bagging is used (i.e. UseBaggedGrad, Bagging,). UseYesNoLeaf No True − Use Sig or Bkg categories, or the purity=S/(S+B) as classification of the leaf node -> Real-AdaBoost. NegWeightTreatment No InverseBoostNegWeights InverseBoostNegWeights, IgnoreNegWeightsInTraining, PairNegWeightsGlobal, Pray How to treat events with negative weights in the BDT training (particular the boosting) : IgnoreInTraining; Boos",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html:12569,Learn,Learning,12569,documentation/tmva/UsersGuide/optionRef.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html,1,['Learn'],['Learning']
Usability,". Help for ROOT's Reference Guide. Help for ROOT's Reference Guide. Contents. Parts of the Reference Guide. Type Index; Class Index; Inheritance. Modules. What they are; List of Modules; Modules' Library Dependencies. Class Reference. Sections; Link Box; Info Box; List of Data and Function Members. Display Options; Access (public / protected / private); Inheritance. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Member Function Documentation. Parts of the Reference Guide; Type Index; All basic types and typedefs are documented in the Type Index. Class Index; All classes and namespaces are listed alphabetically in the Class Index,; along with a short info of what they are used for.; You can jump to a class's entry using the shortcuts ontop of the page.; They are optimized for quick access: they are distributed evenly, and short.; Classes are grouped in modules; these, too, are listed ontop of the list of classes. Inheritance; All classes along with their derived and base classes are shown in the; Class Hierarchy.; The documentation for each class also shows the inheritance diagram.; The class hierarchy is meant to give an overview of available classes; and their relations. Modules; What they are; Classes are grouped into modules. For ROOT, this is done on a per-directory basis:; each module corresponds to a sub-directory. In other cases one module might represent; one library. Either way, modules are meant to combine similar or related classes,; allowing users to find classes close by context. If you need some functionality that; you cannot find in a class you know, you might want to check for classes in the same; module - maybe one of them does what you need. List of Modules; Modules are listed ontop of the Class Index and as part; of the Library Dependencies Chart. Modules' Library Dependencies; Each module is assumed to be part of a library. The dependencies of libraries are; not only relevant for linking, but often reflect also the contextual d",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/etc/html/HELP.html:28,Guid,Guide,28,etc/html/HELP.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/etc/html/HELP.html,4,['Guid'],['Guide']
Usability,". Histogram package; TGraphDelaunay. New version of the method TGraphDelaunay::Enclose(). This method; decides if a point is inside a triangle or not. The way it was implemented; produced infinite numbers and generated wrong peaks. It was visible on some; machines only (for instance MacOsX). Now this method uses; TMath::IsInside(). It is much safer, it runs faster, and the; code is simpler. The problem could be seen with a simple macro like the; following one:; ; {; TCanvas *c1 = new TCanvas(""c1"", ""c1"",0,0,600,600);; c1->SetTheta(90.);; c1->SetPhi(0.0001);; gStyle->SetPalette(1);; TGraph2D *graph2d = new TGraph2D();; graph2d->SetPoint(0, 110, 110, 0.0);; graph2d->SetPoint(1, -80, 50, 1.0);; graph2d->SetPoint(2, -70, 40, 2.0);; graph2d->SetPoint(3,-110, -50, 3.0);; graph2d->SetNpx(9);; graph2d->SetNpy(9);; graph2d->Draw(""surf1"");; graph2d->SetLineWidth(2);; graph2d->Draw("" triw p0 same"");; }; . The X and Y vectors are normalized in order to compute the triangles.; The scale factor used was the same for the X and Y axis.; This generated problems (very long triangles instead of the obvious ones); in some cases when the X and Y axis had very different ranges. Having two; scale factors, one for the X axis and one for the Y axis, cures the problem. TGraph2D. In case all the points are in the same Z-plane Z0 (zmin = zmax), the graph; minimum is set to Z0-0.01*Z0 and the maximum to Z0+0.01*Z0. This; allow to make TGraph2D like:; ; {; double *x = new double[2];; double *y = new double[2];; double *z = new double[2];; x[0] = 6215.;; x[1] = 5542.;; y[0] = 3853.;; y[1] = 5270.;; z[0] = 2723.;; z[1] = 2723.;; TGraph2D * g = new TGraph2D(2, x, y, z);; g->Draw(""LINE"");; }; . TGraph2DPainter. When a TGraph2D was painted with the option TRI1 the; color distribution in case of log scale along the Z axis was wrong. THistPainter. After executing the following macro, zooming the X axis interactively; generated the error message:; ; Error in <TGraphPainter::PaintGraphHist>: X must have N+",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v528/index.html:385,simpl,simpler,385,hist/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v528/index.html,2,['simpl'],"['simple', 'simpler']"
Usability,". Html; THtml is now using the leyout of the new ROOT web site. There is a number of other improvements:. The sources now show line numbers. Each line number is a link and an anchor, i.e. it can be jumped to.; The line number can be copy&pasted: mark the line number from the right and drag your mouse to the left until teh line number and a space next to it are marked. When you paste this you will get the file and line number in the GDB-format (MyFile.cxx:123), e.g. to set breakpoints.; THtml now uses short class names, e.g. map<A,B,less<A>,allocator<pair<A,B> > > now simply becomes map<A,B>. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/html/doc/v524/index.html:574,simpl,simply,574,html/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/html/doc/v524/index.html,1,['simpl'],['simply']
Usability,". I/O Libraries; TFileCacheRead. Support for multiple TFileCacheRead per TFile.; Multiple TFileCacheRead per TFile are supported by augmenting the existing TFile::SetCacheRead() function with an optional TObject* argument specifying the owner (i.e. tree) of the cache. This function will assign a TFileCacheRead to a TFile for the given TTree. A cache can be removed by setting the pointer TFileCacheRead to 0.; Similarly, in TFile::GetCacheRead() an optional TObject* argument was added to obtain the TFileCacheRead from a TFile.; In addition to the unassigned TFileCacheRead pointer, TFile will maintain a map of tree specific cache pointers.; Backward compatibility in both functions is handled by making the TObject* argument optional. If it is not specified in the TFile::SetCacheRead() call, only the unassigned TFileCacheRead pointer is updated, otherwise the map and the unassigned cache are updated. In TFile::GetCacheRead(), if an owner is not specified or doesn't exist in the file's cache map, the unassigned cache is returned, unless it is 0 and there is exactly one entry in the cache map.; Distinguish counter for bytes read and read calls for learning phase. TFileMerger. Improve efficiency of TFileMerger when merging a single file by doing a TFile::Cp rather than a load/write of the objects.; In TFileMerger and hadd when objects can not be merged do not overwrite the last object in the set with the first!; Renable warning about not being able to merge objects in TFileMerger and hadd.; Fix hadd problem where the incremental merging fails if the TTree are stored in sub-directories.; Improve the code used for forward compatibility (record the type as TDirectory even-though the class is now TDirectoryFile) by delaying the switching of the class name until it is written (to the buffer). This avoids problem where a TKey is created (by TFile::mkdir) and then immediately used for reading (this happens in the incremental file merger). ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/doc/v534/index.html:1159,learn,learning,1159,io/doc/v534/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/doc/v534/index.html,1,['learn'],['learning']
Usability,". It tells ROOT not to; save that data member in a root file when saving the class. For example,; in this version of Event, the `fPt` and `fTransient` data members are; not persistent. ``` {.cpp}; class Event : public TObject {; private:; TDirectory *fTransient; //! current directory; Float_t fPt; //! transient value; ...; ```. ### The Pointer to Objects (//-\>). The string ""`->`"" in the comment field of the members `*fH` and; `*fTracks` instruct the automatic `Streamer` to assume these will point; to valid objects and the `Streamer `of the objects can be called rather; than the more expensive `R__b << fH`. It is important to note that no; check is done on the validity of the pointer value. In particular if the; pointer points, directly or indirectly, back to the current object, this; will result in an infinite recursion and the abrupt end of the process. ``` {.cpp}; TClonesArray *fTracks; //->; TH1F *fH; //->; ```. ### Variable Length Array. When the `Streamer `comes across a pointer to a simple type, it assumes; it is an array. Somehow, it has to know how many elements are in the; array to reserve enough space in the buffer and write out the; appropriate number of elements. This is done in the class definition.; For example:. ``` {.cpp}; class Event : public TObject {; private:; char fType[20];; Int_t fNtrack;; Int_t fNseg;; Int_t fNvertex;; ...; Float_t *fClosestDistance; //[fNvertex]; ```. The array `fClosestDistance` is defined as a pointer of floating point; numbers. A comment mark (//), and the number in square brackets tell the; `Streamer `the length of the array for this object. In general the; syntax is:. ``` {.cpp}; <simple type> *<name>//[<length>]; ```. The length cannot be an expression. If a variable is used, it needs to; be an integer data member of the class. It must be defined ahead of its; use, or in a base class. The same notation also applies to variable length array of object and; variable length array of pointer to objects. ``` {.cpp}; MyObject",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:46743,simpl,simple,46743,documentation/users-guide/InputOutput.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md,1,['simpl'],['simple']
Usability,". Limitations: 5-th dimension is not shown correctly at the moment; (lacks sofisticated algorithms, we do not have in a ROOT's math; library now). Because of this limitation, GUI is just a toy now, must; be changed. Future directions:. GUI improvements.; Support several different density estimators.; Implement regression tools. Minor changes, fixes and improvements. It is now possible to draw a histogram with the ""GLBOX"" in the; GL-viewer. New class TGLColor has been introduced to simplify color; management in TGLViewer and TGLRnrCtx. Add support for several color-sets (class TGLColorSet -; each defines colors for background, foreground, outline, markup and; for outlines of selected and highlighted objects. This also allows for independent changing of background color and; outline mode in the GL viewer - the e key now toggles between; dark / light background. New class TGLAnnotation - it allows display of; annotation-text on top of displayed objects. The annotation can be created from the TGLViewer editor; (""Guides"" tab). After that it can be dragged around the screen, edited; or closed. TGLAxisPainter - reimplemented to completely separate; label and tick-mark positioning code from the rendering itself. TGLSAViewer - when exporting an image properly take into; account image extension if it was typed by the user. TGLFont now uses the same font-naming scheme as the rest; of ROOT (had to specify font-file names before). Overlay-object management has been improved. Allow clipping object to be fixed by user - until now it was updated; on every redraw. See TGLViewer::SetClipAutoUpdate(). Eve. TEveElement - add context-menu functions allowing the; source-object to be printed, dumped or exported to CINT. TEveTrack - added flag for locking of current; track-points - the track will not be re-extrapolated automatically; even when the extrapolation parameters are changed. TEveTrack - removed ALICE specific ImportXyzz(); functions for loading of kinematics, hits and clusters ass",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/doc/v524/index.html:3186,Guid,Guides,3186,graf3d/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/doc/v524/index.html,1,['Guid'],['Guides']
Usability,". Note that when an object is created, its attributes are taken from the; current style. For example, you may have created a histogram in a; previous session and saved it in a file. Meanwhile, if you have changed; the style, the histogram will be drawn with the old attributes. You can; force the current style attributes to be set when you read an object; from a file by calling `ForceStyle` before reading the objects from the; file. ``` {.cpp}; gROOT->ForceStyle();; ```. When you call `gROOT->ForceStyle()` and read an object from a ROOT file,; the object's method `UseCurrentStyle` is called. The attributes saved; with the object are replaced by the current style attributes. You call; also call `myObject->UseCurrentStyle()` directly. For example if you; have a canvas or pad with your histogram or any other object, you can; force these objects to get the attributes of the current style by:. ``` {.cpp}; canvas->UseCurrentStyle();; ```. The description of the style functions should be clear from the name of; the **`TStyle`** setters or getters. Some functions have an extended; description, in particular:. - `TStyle::SetLabelFont`. - `TStyle::SetLineStyleString`: set the format of dashed lines. - `TStyle::SetOptStat`. - `TStyle::SetPalette` to change the colors palette. - `TStyle::SetTitleOffset`. - `TStyle::SetOptDate(Int_t optdate)` to support several date formats.; If `optdate` is non-null, the current date/time will be printed in; the canvas. The position of the date string can be controlled by:; `optdate = 10*format `+` mode`. - `mode = 1` the date is printed in the bottom/left corner. - `mode = 2` date is printed in the bottom/right corner. - `mode = 3` date is printed in the top/right corner. - `format = 0` (default) date format is like: ""Wed Sep 25 17:10:35; 2002"". - `format = 1` date format is: ""2002-09-25"". - `format = 2` date format is: ""2002-09-25 17:10:35"". ## 3D Viewers. ROOT provides several viewers capable of displaying 3D content:. - the Pad - simple line",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:104149,clear,clear,104149,documentation/users-guide/Graphics.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md,1,['clear'],['clear']
Usability,". Open Projects. Open Projects; This page lists several projects that would boost analyzer's usability and; power. Most of the projects listed here are infrastructure-related so this list; is an addition to the potential checkers; list. If you are interested in tackling one of these, please send an email; to the cfe-dev; mailing list to notify other members of the community. Release checkers from ""alpha""; New checkers which were contributed to the analyzer,; but have not passed a rigorous evaluation process,; are committed as ""alpha checkers"" (from ""alpha version""),; and are not enabled by default.; Ideally, only the checkers which are actively being worked on should be in; ""alpha"",; but over the years the development of many of those has stalled.; Such checkers should either be improved; up to a point where they can be enabled by default,; or removed from the analyzer entirely. ; alpha.security.ArrayBound and; alpha.security.ArrayBoundV2; Array bounds checking is a desired feature,; but having an acceptable rate of false positives might not be possible; without a proper; loop widening support.; Additionally, it might be more promising to perform index checking based on; tainted index values.; (Difficulty: Medium). alpha.unix.StreamChecker; A SimpleStreamChecker has been presented in the Building a Checker in 24; Hours talk; (slides; video).; This alpha checker is an attempt to write a production grade stream checker.; However, it was found to have an unacceptably high false positive rate.; One of the found problems was that eagerly splitting the state; based on whether the system call may fail leads to too many reports.; A delayed split where the implication is stored in the state; (similarly to nullability implications in TrustNonnullChecker); may produce much better results.; (Difficulty: Medium). Improve C++ support; ; Handle construction as part of aggregate initialization.; Aggregates; are objects that can be brace-initialized without calling a; constructor (th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/open_projects.html:93,usab,usability,93,interpreter/llvm-project/clang/www/analyzer/open_projects.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/open_projects.html,1,['usab'],['usability']
Usability,". OpenGL. Add support for showing tooltips for objects shown in; TGLViewer. See TGLEventHandler::TriggerTooltip(const; char* text) and RemoveTooltip(). Usage example is in; class TEveViewerList. Add new overlay element TGLCameraOverlay that allows to; display: a) coordinate axes for orthographic mode; b) intersection of; center of screen with a given plane. Add suport for fading in/out of the viewer contents. Many improvements in text and axis rendering for orthographic; view markup. In TGLSceneBase add data-member Bool_t; fSelectable allowing one to preventing any of its elements to be; selected. Useful when given scene is used as background to help guid; the eye. Eve. Added support for internal window management. Windows can be; arranged in horizontal/vertical stacks, tabs and main windows.; The containers and individaul windows can be moved to arbitrary; window-slot. See classes TEveWindow and TEveWindowManager. See tutorial tutorials/eve/test_windows.C. TEveQuadSet -- Add flag 'Bool_t fAntiFlick'. If on (now the; default) it causes each quad to be also rendered as a pixel, thus; preventing it from disappearing when zoomed away. This is needed for visualization of small quads, e.g. silicon; detectors digits. TEveCalo classes -- Add support for automatic rebinning; of 3D views (only supported for 2D views before). In 2D mode support; automatic determination of the cell color based on the most energetic; contribution from available calo slices. Add support for enumerative registration of calorimeter towers. Before; one had to provide THStack as input. See TEveCaloDataVec; class. TEveTrackList -- Generalized API for finding of momentum; limits. TEveTrackPropagator now supports propagation of charged; particles in arbitrary / external magnetic field. Propagation can be; done with the helix-stepper or with the Runge-Kutta method. New abstract interface to magnetic field TEveMagField to get; field vector at given position. Implement two interfaces:; TEveMagFieldConst fo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/doc/v522/index.html:659,guid,guid,659,graf3d/doc/v522/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/doc/v522/index.html,1,['guid'],['guid']
Usability,". OpenGL; Major changes. Reorganization of scene rendering in TGLViewer - render opaque; objects from all scenes first, then all transparent ones. Modularization of input event-handling in TGLViewer: all; event-handling is done by the TGLEventHandler class. One can; sub-class it now and modify behaviour of a given viewer. For; example, see TEveLegoEventHandler. Support highlighting of physical shapes for providing feedback and; showing selection. Minor changes, fixes and improvements. Improve saving of images from the GL-viewer so that the dialog; boxes and other windows do not result in black areas on the saved; image. The window must still be fully contained within the desktop. Improved camera controls. Three new orthographic cameras have; been added to TGLViewer, looking at the scene from another; side than the one present so far. Improved FTGL font management across rendering contexts and text; rendering support. New class TGLAxisPainter that can render 2D and 3D axes; via GL. For example see tutorials/eve/cms_calo.C. Possible performance issues with ATI drivers (fglrx). In late 2007 ATI switched to a new driver architecture. With these; drivers a significant degradation of GL performance in selection mode,; up to a factor of 50, was observed. Both linux and Windows drivers; were affected. The issue has been resolved in the latest driver; versions. Eve; Major changes. Support for multiple, parallel OpenGL views that can show different; projections of the same event. Provide object selection and feedback highlight across all GL-views and; list-trees. New classes for visualization of calorimeter data,; TEveCaloXYZ, see tutorials/eve/cms_calo.C. Available; representations: 3D-cylindrical view, projected views r-phi and rho-z,; and lego-view (with dedicated event handler allowing detailed; inspection of the data). Support for compound objects in view of selection, highlight and; color managament (see class TEveCompound). Optimize updates of GL-scenes by introducing c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/doc/v520/index.html:418,feedback,feedback,418,graf3d/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/doc/v520/index.html,1,['feedback'],['feedback']
Usability,". PROOF System. Added functionality; ; Added interface to simplify the creation of the performance; tree: two new methods TProof::SetPerfTree(""<file>"") and; TProof::SavePerfTree(""<file>"", ""<queryref>"") allow set; and/or save the information to a given file path. The perfomance tree; settim=ngs are diabled after each query, so they need to be enabled; each time.; Add support for a command line test run of 'proofserv'; this is; useful to test that the environment is setup correctly.; In TProofBench::DrawCPU, add possibility to extract of a couple; of numbers supposed to give an idea of the computing specs of the; cluster being benchmarked. These are the maximum rate for the standard; CPU intensive task and the normalized, per worker, rate. Both are; expressed in RNGPS (RaNdom Generation Per Second).; Add class TProofPerfAnalysis collecting a set of tools to; analyse the performance tree.; Add support for selector-by-object processing in PROOF. The; selector object, created and configured locally by the user, is added; to the input list and recuperated from there on the worker machines for; processing. Any input list setting in the selector itself is not; streamed but temporarly moved to then standard input list, so that user; can use the selector input list as container of processing information; if they find convenient to do so. Process(...) methods with the file; name argument replaced by 'TSelector *' have  introduced where; relevant (TProof, TProofPlayer and their derivatives, TDSet).  ; Add the possibility to force submerging at node level, i.e. one; submerger per physical machine. In this way the network traffic can be; minimized, for example when merging large output files. The new feature; is enabled by setting the Int_t parameter 'PROOF_MergersByHost' (or the; directive 'Proof.MergersByHost') to a non-null value.; Simplify enabling of basic feedback. In TProof::Process, add; support for switches ""fb=name1,name2,name3,... "" or; ""feedback=name1,name2,name3,... """,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v534/index.html:58,simpl,simplify,58,proof/doc/v534/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v534/index.html,1,['simpl'],['simplify']
Usability,". ROOT Version 5.26/00 Release Notes. Quick Links:; ROOT Homepage; Download; Reference Guide. Search. ROOT. » Download; » Release Notes. ROOT Version 5.26/00 Release Notes. ROOT version 5.26/00 will be released on December 15 2009.; In case you are upgrading from an old version, please read the releases notes; of version 5.16, 5.18, 5.20, 5.22 and version 5.24 in addition to these notes. Bindings - packages related to the interplay with other programming languages (Python, Ruby); Cint - the C++ interpreter; Core - the basic ROOT functionality; Geometry - building, representing and drawing geometrical objects; 2D Graphics - ROOT's two dimensional graphics interface; 3D Graphics - ROOT's three dimensional graphics interface; Graphical User Interface - from basic GUI elements to ROOT's own, complete dialogs; Histograming - counting values, spectra, and drawing them; HTML - the documentation generator; Input/Ouput - storing and reading data; Mathemathics - everything one can use to calculate: minimizers, matrixes, FFT, and much more; Miscellaneous - things that didn't make it into the other groups: table ; Monte Carlo - monte carlo and physics simulation interfaces; Networking - network-related parts, e.g. protocols and authentication interfaces; PROOF - parallel ROOT facility; RooFit - a fitting library; RooStats - a collection of statistical tools ; SQL - database interfaces; TMVA - multivariate analysis tools; Trees - ROOT's unique container class and related utilities. Binaries for all supported platforms are available at:. https://root.cern/releases/release-52600/. For more information, see:. http://root.cern.ch; The following people have contributed to this new version:; Bertrand Bellenot, CERN/SFT,; Brian Bockelman, UNL,; Rene Brun, CERN/SFT,; Philippe Canal, FNAL,; Olivier Couet, CERN/SFT,; Kyle Cranmer, NYU/Atlas, RooStats; Valeri Fine, BNL/STAR,; Lucie Flekova, CERN/SFT summer student,; Fabrizio Furano, CERN/IT, ; Gerri Ganis, CERN/SFT,; Andrei Gheata, CERN/Ali",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/doc/v526/index.html:87,Guid,Guide,87,doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/doc/v526/index.html,1,['Guid'],['Guide']
Usability,". ROOT Version 5.28/00 Release Notes. Quick Links:; ROOT Homepage; Download; Reference Guide. Search. ROOT. » Download; » Release Notes. ROOT Version 5.28/00 Release Notes. ROOT version 5.28/00 has been released on December 15 2010.; In case you are upgrading from an old version, please read the releases notes; of version 5.16, 5.18, 5.20, 5.22, 5.24 and version 5.26 in addition to these notes. Bindings - packages related to the interplay with other programming languages (Python, Ruby); Cint - the C++ interpreter; Core - the basic ROOT functionality; Geometry - building, representing and drawing geometrical objects; 2D Graphics - ROOT's two dimensional graphics interface; 3D Graphics - ROOT's three dimensional graphics interface; Graphical User Interface - from basic GUI elements to ROOT's own, complete dialogs; Histograming - counting values, spectra, and drawing them; HTML - the documentation generator; Input/Ouput - storing and reading data; Mathemathics - everything one can use to calculate: minimizers, matrixes, FFT, and much more; Miscellaneous - things that didn't make it into the other groups: table ; Monte Carlo - monte carlo and physics simulation interfaces; Networking - network-related parts, e.g. protocols and authentication interfaces; PROOF - parallel ROOT facility; RooFit - a fitting library; RooStats - a collection of statistical tools ; SQL - database interfaces; TMVA - multivariate analysis tools; Trees - ROOT's unique container class and related utilities; Tutorials - ROOT's Tutorials. Binaries for all supported platforms are available at:. https://root.cern/releases/release-52800/. For more information, see:. http://root.cern.ch; The following people have contributed to this new version:; Alberto Annovi, INFN, TH1, ; Kevin Belasco, Princeton University, RooStats,; Bertrand Bellenot, CERN/SFT,; Rene Brun, CERN/SFT,; Philippe Canal, FNAL,; Olivier Couet, CERN/SFT,; Kyle Cranmer, NYU, RooStats,; Jason Detwiler, LBL, TClonesArray, ; Valeri Fine, BNL/",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/doc/v528/index.html:87,Guid,Guide,87,doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/doc/v528/index.html,1,['Guid'],['Guide']
Usability,". ROOT Version 5.30/00 Release Notes. Quick Links:; ROOT Homepage; Download; Reference Guide. Search. ROOT. » Download; » Release Notes. ROOT Version 5.30/00 Release Notes. ROOT version 5.28/00 has been released on December 15 2010.; In case you are upgrading from an old version, please read the releases notes; of version 5.16, 5.18, 5.20, 5.22, 5.24, 5,26 and version 5.28 in addition to these notes. The release of version 5.30 is scheduled for June 27, 2011. Bindings - packages related to the interplay with other programming languages (Python, Ruby); Cint - the C++ interpreter; Core - the basic ROOT functionality; Geometry - building, representing and drawing geometrical objects; 2D Graphics - ROOT's two dimensional graphics interface; 3D Graphics - ROOT's three dimensional graphics interface; Graphical User Interface - from basic GUI elements to ROOT's own, complete dialogs; Histograming - counting values, spectra, and drawing them; HTML - the documentation generator; Input/Ouput - storing and reading data; Mathemathics - everything one can use to calculate: minimizers, matrixes, FFT, and much more; Miscellaneous - things that didn't make it into the other groups: table ; Monte Carlo - monte carlo and physics simulation interfaces; Networking - network-related parts, e.g. protocols and authentication interfaces; PROOF - parallel ROOT facility; RooFit - a fitting library; RooStats - a collection of statistical tools ; SQL - database interfaces; TMVA - multivariate analysis tools; Trees - ROOT's unique container class and related utilities; Tutorials - ROOT's Tutorials. Binaries for all supported platforms are available at:. https://root.cern/releases/release-52800/. For more information, see:. http://root.cern.ch; The following people have contributed to this new version:; Bertrand Bellenot, CERN/SFT,; Dario Berzano, INFN and University of Torino, ALICE, Proof,; Rene Brun, CERN/SFT,; Philippe Canal, FNAL,; Olivier Couet, CERN/SFT,; Kyle Cranmer, NYU, RooStats,; Gerr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/doc/v530/index.html:87,Guid,Guide,87,doc/v530/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/doc/v530/index.html,1,['Guid'],['Guide']
Usability,". ROOT Version 5.32/00 Release Notes. Quick Links:; ROOT Homepage; Download; Reference Guide. Search. ROOT. » Download; » Release Notes. ROOT Version 5.32/00 Release Notes. ROOT version 5.32/00 has been released on Nov 29, 2011.; In case you are upgrading from an old version, please read the releases notes; of version 5.26, 5,28 and version 5.30 in addition to these notes. The release of version 5.34 is scheduled for May 29, 2012. Bindings - packages related to the interplay with other programming languages (Python, Ruby); Cint - the C++ interpreter; Core - the basic ROOT functionality; Geometry - building, representing and drawing geometrical objects; 2D Graphics - ROOT's two dimensional graphics interface; 3D Graphics - ROOT's three dimensional graphics interface; Graphical User Interface - from basic GUI elements to ROOT's own, complete dialogs; Histograming - counting values, spectra, and drawing them; HTML - the documentation generator; Input/Ouput - storing and reading data; Mathemathics - everything one can use to calculate: minimizers, matrixes, FFT, and much more; Miscellaneous - things that didn't make it into the other groups: table ; Monte Carlo - monte carlo and physics simulation interfaces; Networking - network-related parts, e.g. protocols and authentication interfaces; PROOF - parallel ROOT facility; RooFit - a fitting library; RooStats - a collection of statistical tools ; SQL - database interfaces; TMVA - multivariate analysis tools; Trees - ROOT's unique container class and related utilities; Tutorials - ROOT's Tutorials. For more information, see:. http://root.cern.ch; The following people have contributed to this new version:; Bertrand Bellenot, CERN/SFT,; Rene Brun, CERN/SFT,; Philippe Canal, FNAL,; Olivier Couet, CERN/SFT,; Kyle Cranmer, NYU/ATLAS, RooStats,; Sven Kreiss, NYU/ATLAS, RooStats,; Gena Kukartsev, CERN and FNAL/CMS, ; Gerri Ganis, CERN/SFT,; Andrei Gheata, CERN/Alice,; Christian Gumpert, CERN and University Dresden/ATLAS, Math,; Wi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/doc/v532/index.html:87,Guid,Guide,87,doc/v532/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/doc/v532/index.html,1,['Guid'],['Guide']
Usability,". ROOT Version 5.33/01 Release Notes. Quick Links:; ROOT Homepage; Download; Reference Guide. Search. ROOT. » Download; » Release Notes. ROOT Version 5.33/01 Release Notes. ROOT version 5.32/00 has been released on November 29, 2011.; In case you are upgrading from an old version, please read the releases notes; of version 5.26, 5,28 and version 5.30 in addition to these notes. The release of version 5.34 is scheduled for May 30, 2012. Bindings - packages related to the interplay with other programming languages (Python, Ruby); Cint - the C++ interpreter; Core - the basic ROOT functionality; Geometry - building, representing and drawing geometrical objects; 2D Graphics - ROOT's two dimensional graphics interface; 3D Graphics - ROOT's three dimensional graphics interface; Graphical User Interface - from basic GUI elements to ROOT's own, complete dialogs; Histograming - counting values, spectra, and drawing them; HTML - the documentation generator; Input/Ouput - storing and reading data; Mathemathics - everything one can use to calculate: minimizers, matrixes, FFT, and much more; Miscellaneous - things that didn't make it into the other groups: table ; Monte Carlo - monte carlo and physics simulation interfaces; Networking - network-related parts, e.g. protocols and authentication interfaces; PROOF - parallel ROOT facility; RooFit - a fitting library; RooStats - a collection of statistical tools ; SQL - database interfaces; TMVA - multivariate analysis tools; Trees - ROOT's unique container class and related utilities; Tutorials - ROOT's Tutorials. For more information, see:. http://root.cern.ch; The following people have contributed to this new version:; Bertrand Bellenot, CERN/SFT,; Rene Brun, CERN/SFT,; Philippe Canal, FNAL,; Olivier Couet, CERN/SFT,; Kyle Cranmer, NYU, RooStats,; Gerri Ganis, CERN/SFT,; Andrei Gheata, CERN/Alice,; Wim Lavrijsen, LBNL, PyRoot,; Lorenzo Moneta, CERN/SFT,; Axel Naumann, CERN/SFT,; Fons Rademakers, CERN/SFT,; Paul Russo, FNAL, ; Joerg ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/doc/v534/index.html:87,Guid,Guide,87,doc/v534/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/doc/v534/index.html,1,['Guid'],['Guide']
Usability,". RooFit. HistFactory. One of the core classes used by HistFactory models (RooRealSumPdf) was modified leading to substantial speed improvements (for models that use the default -standard_form option). . This new version supports a few types of interpolation for the normalization of the histograms:. code = 0: piece-wise linear (old default); code = 1: piece-wise log (new default); code = 2: parabolic interp with linear extrap ( common at tevatron, avoids kink for asymmetric uncert). The piece-wise logarithmic interpolation paired with a Gaussian constraint is equivalent to a log-normal constraint in a transformed version of the nuisance parameter. The benefit of this approach is that it is easy to avoid the normalization from taking on unphysical negative values. This is the prescription used by the CMS Higgs group, and agreed upon by the LHC Higgs Combination Group. There is not yet XML-based steering for the different interpolation types, but there is a simple script to modify it. . results/example_combined_GaussExample_model.root . Near term goals for HistFactory. Utilities for dealing with Monte Carlo statistical uncertainty in the template histograms; Support for N-D histograms; A new style of histogram variations without a constraint term attached (for shapes determined from control samples); XML steering for interpolation types. RooStats; General Improvements. This release brings several speed improvements to the RooStats tools and improved stability and performance with PROOF. This comes mainly through changes to the ToyMCSampler. In addition the HypoTestInverter tool has been rewritten, leading to some changes in the HypoTestResult. Finally, a new hypothesis test new called FrequentistCalculator was written, which plays the same role as the HybridCalculator but eliminates nuisance parameters in a frequentist way. ToyMCSampler. The primary interface for this class is to return a SamplingDistribution of a given TestStatistic.; The ToyMCSampler had a number of ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v530/index.html:970,simpl,simple,970,roofit/doc/v530/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v530/index.html,1,['simpl'],['simple']
Usability,". Running the analyzer from the command line. Running the analyzer from the command line; Static Analyzer is by design a GUI tool. Its purpose is to find buggy execution; paths in the program, and such paths are very hard to comprehend by looking at; a non-interactive standard output. It is possible, however, to invoke the; Static Analyzer from the command line in order to obtain analysis results, and; then later view them interactively in a graphical interface. The following; tools are used commonly to run the analyzer from the command line. Both tools; are wrapper scripts to drive the analysis and the underlying invocations of the; Clang compiler:. Scan-Build; is an old and simple command-line tool that emits static analyzer warnings as HTML files while compiling your project. You can view the analysis results in your web browser.; . Useful for individual developers who simply want to view static analysis results at their desk, or in a very simple collaborative environment.; . Works on all major platforms (Windows, Linux, macOS) and is available as a package in many Linux distributions.; . Does not include support for cross-translation-unit analysis.; . CodeChecker; is a web server that runs the Static Analyzer on your projects on demand and maintains a database of issues.; . Perfect for managing large amounts of Static Analyzer warnings in a collaborative environment.; . Generally much more feature-rich than scan-build.; ; Supports incremental analysis: Results can be stored in a database, subsequent analysis runs can be compared to list the newly added defects.; Cross Translation Unit (CTU) analysis is supported fully on Linux via CodeChecker.; Can run clang-tidy checkers too.; Open source, but out-of-tree, i.e. not part of the LLVM project. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/command-line.html:685,simpl,simple,685,interpreter/llvm-project/clang/www/analyzer/command-line.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/command-line.html,3,['simpl'],"['simple', 'simply']"
Usability,". TASImage - libAfterImage library; TASImage. Protection added in DrawCircle. Problem seen with gcc version 4.2.3.; Fixed byte swapping issues. With that fix the pictures generated in batch; mode on Solaris and Mac are now correct (cf stressGraphics -k).; The Alpha Blending code has been rewritten in a simpler way in order to; work on linux with gcc 4.2.3. Here also the pictures generated in batch; mode were wrong.; In FillRectangleInternal when the rectangle to be drawn had its width or; its height equal to 0, they were set to the current image width or height.; This was not a good solution because this obscured completely the picture.; In particular, some markers being drawn with a filled rectangle, they; obscured the picture when they were really small because in that case the; rectangle drawn had width=height=0. Now, when a rectangle has its width or; height equal to 0 it is set to 1 (pixel) with makes sense because; ""0"" means ""tiny"" not ""huge"" ...; New method to retrieve the last zoom position on an image:; ; void TASImage::GetZoomPosition(UInt_t &x, UInt_t &y, UInt_t &w, UInt_t &h) const; ; This is useful when the zoom has been done interactively using the mouse.; In batch, when a picture was saved in a binary file (gif for instance) from; an image containing more than one pad, only the first pad was saved. The; following macro demonstrates the problem: ccc2.gif was wrong compared to; ccc1.gif. {; gROOT->SetBatch();; TCanvas *c = new TCanvas;; c->Divide(1,2);; TH1F *h = new TH1F(""gaus"", ""gaus"", 100, -5, 5);; h->FillRandom(""gaus"", 10000);; c->cd(1); h->Draw();; c->cd(2); h->Draw(""c*"");; c->Print(""ccc1.gif"");; TImage *img = TImage::Create();; img->FromPad(c);; img->WriteImage(""ccc2.gif"");; }. libAfterImage. There no need anymore for the special version we had up to now. The; modifications we needed have been introduced in the official version.; This version also fixes the color problem on BigEndian machines.; On these machines (Mac and Solaris for instance) the c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/doc/v520/index.html:304,simpl,simpler,304,graf2d/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/doc/v520/index.html,1,['simpl'],['simpler']
Usability,". TPDF. The following macro produced a wrong PDF file. The second page had a black; background.; ; {; gROOT->SetStyle(""Plain"");; TCanvas* canvas = new TCanvas(""canvas"", ""canvas"", 600, 700);; TH1F* h = new TH1F(""h"",""ht"", 100, -5, 5);; h->FillRandom(""gaus"",10000);; canvas->Divide(2,1);; canvas->cd(1); h->Draw();; canvas->Update();; canvas->Print(""test.pdf("");; canvas->Print(""test.pdf"");; canvas->Print(""test.pdf)"");; }; . TPostscript. Fix a precision problem in the text positionning. When the pad limits along; X or Y were very close the text position might be wrong. This was found; thanks to the test #15 in stressGraphics. The text position is now computed; using double precision variables only. TASImage. Horizontal dashed lines having a width greater than 1, were not correct. TLatex. Improve the sqrt drawing to avoid the overlapping; problem mentionned here https://savannah.cern.ch/bugs/index.php?82436. TGaxis. The following macro produced two different labelling. Label ""3"" was missing; on the axis ""b"".; ; {; TGaxis *a = new TGaxis(0.2,0.5,0.8,0.5,0.2,3.5,510,""G"");; a->SetMoreLogLabels(1); a->Draw();; TGaxis *b = new TGaxis(0.8,0.7,0.2,0.7,0.2,3.5,510,""G"");; b->SetMoreLogLabels(1); b->Draw();; }; . TPad. Add a protection in TPad:Clear() to fix the; bug report #78382. An histogram redrawing in a cloned; pad produced a segmentation fault. GX11Gui. Only call XFreeColors if we are on a <= 8 plane machine (to match calls; to XAllocColor). This solves the bug #77329: X11 error clicking; on '?' in context menus. TGWin32. Unmap the window before to destroy it, in order to properly receive; kUnmapNotify needed by gClient->WaitForUnmap(). This fixes the problem; reported on; the forum. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/doc/v530/index.html:1247,Clear,Clear,1247,graf2d/doc/v530/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/doc/v530/index.html,1,['Clear'],['Clear']
Usability,". The `TTree::Draw` method is convenient and easy to use; however it falls; short if you need to do some programming with the variable. For example, for plotting the masses of all oppositely changed pairs of; tracks, you would need to write a program that loops over all events,; finds all pairs of tracks, and calculates the required quantities. We; have shown how to retrieve the data arrays from the branches of the tree; in the previous section, and you could just write that program from; scratch. Since this is a very common task, ROOT provides a utility that; generates a skeleton class designed to loop over the entries of the; tree. This is the `TTree::MakeClass` method. We will now go through the steps; of using `MakeClass` with a simplified example. The methods used here; obviously work for complex event loop calculations. These are our assumptions: we would like to do selective plotting and; loop through each entry of the tree and tracks. We chose a simple; example: we want to plot `fPx` of the first 100 tracks of each entry. We; have a ROOT tree with a branch for each data member in the ""`Event`""; object. To build this file and tree follow the instructions on how to; build the examples in `$ROOTSYS/test`. Execute `Event` and instruct it; to split the object with this command (from the UNIX command line). ``` {.cpp}; > $ROOTSYS/test/Event 400 1 2 1; ```. This creates an `Event.root` file with 400 events, compressed, split,; and filled. See `$ROOTSYS/test/MainEvent.cxx` for more info. The person who designed the tree makes a shared library available to; you, which defines the classes needed. In this case, the classes are; Event, `EventHeader`, and Track and they are defined in the shared; library `libEvent.so`. The designer also gives you the `Event.h` file to; see the definition of the classes. You can locate `Event.h` in; `$ROOTSYS/test`, and if you have not yet built `libEvent.so`, please see; the instructions of how to build it (typing make in \$ROOTSYS/test i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:121977,simpl,simple,121977,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['simpl'],['simple']
Usability,". The driver expects to understand all available; options, although there is some facility for just passing certain; classes of options through (like ``-Wl,``). Each argument corresponds to exactly one abstract ``Option``; definition, which describes how the option is parsed along with some; additional metadata. The Arg instances themselves are lightweight and; merely contain enough information for clients to determine which; option they correspond to and their values (if they have additional; parameters). For example, a command line like ""-Ifoo -I foo"" would parse to two; Arg instances (a JoinedArg and a SeparateArg instance), but each; would refer to the same Option. Options are lazily created in order to avoid populating all Option; classes when the driver is loaded. Most of the driver code only needs; to deal with options by their unique ID (e.g., ``options::OPT_I``),. Arg instances themselves do not generally store the values of; parameters. In many cases, this would simply result in creating; unnecessary string copies. Instead, Arg instances are always embedded; inside an ArgList structure, which contains the original vector of; argument strings. Each Arg itself only needs to contain an index into; this vector instead of storing its values directly. The clang driver can dump the results of this stage using the; ``-###`` flag (which must precede any actual command; line arguments). For example:. .. code-block:: console. $ clang -### -Xarch_i386 -fomit-frame-pointer -Wa,-fast -Ifoo -I foo t.c; Option 0 - Name: ""-Xarch_"", Values: {""i386"", ""-fomit-frame-pointer""}; Option 1 - Name: ""-Wa,"", Values: {""-fast""}; Option 2 - Name: ""-I"", Values: {""foo""}; Option 3 - Name: ""-I"", Values: {""foo""}; Option 4 - Name: ""<input>"", Values: {""t.c""}. After this stage is complete the command line should be broken down; into well defined option objects with their appropriate parameters.; Subsequent stages should rarely, if ever, need to do any string; processing. #. **Pipeline: Compilat",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst:4980,simpl,simply,4980,interpreter/llvm-project/clang/docs/DriverInternals.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst,1,['simpl'],['simply']
Usability,". To have services like telephone and; electricity you will need to route the wires to your home. In; addition, you cannot build some things yourself. For example, you; cannot build a commercial airport on your patch of land. From a global; perspective, it would make no sense for everyone to build their; own airport. You see you will be very busy building the infrastructure; (or framework) before you can use the phone to communicate with your; collaborators and have a drink of water at the same time. In software; engineering, it is much the same way. In a framework, the basic; utilities and services, such as I/O and graphics, are provided. In; addition, ROOT being a HEP analysis framework, it provides a large; selection of HEP specific utilities such as histograms and fitting.; The drawback of a framework is that you are constrained to it, as you; are constraint to use the routing algorithm provided by your telephone; service. You also have to learn the framework interfaces, which in; this analogy is the same as learning how to use a telephone. If you are interested in doing physics, a good HEP framework will save; you much work. Next is a list of the more commonly used components of; ROOT: Command Line Interpreter, Histograms and Fitting, Writing a; Graphical User Interface, 2D Graphics, Input/Output , Collection; Classes, Script Processor. There are also less commonly used components, as: 3D Graphics,; Parallel Processing (PROOF), Run Time Type Identification (RTTI),; Socket and Network Communication, Threads. #### Advantages of Frameworks. The benefits of frameworks can be summarized as follows:. - Less code to write - the programmer should be able to use and; reuse the majority of the existing code. Basic functionality, such; as fitting and histogramming are implemented and ready to use and; customize. - More reliable and robust code - the code inherited from a; framework has already been tested and integrated with the rest of; the framework. - More consistent a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:6508,learn,learn,6508,documentation/users-guide/Introduction.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md,2,['learn'],"['learn', 'learning']"
Usability,". Tree. Significantly improve performance of TTree Proxy.; Improve read performance of sub-branch containing vector of single types.; Fix TTree::LoadBasket to properly handle the (new) case where no basket is stored with the TTree object.; Fix the axis used for an histogram created by TTree::Draw for a branch of TString or std::string objects.; MakeProxy now correctly support branches that created with a leaflist with more than one leaf; (usually used for C-struct).; TTree::CloneTree and TChain::Merge in fast mode now can recover from some mismatch errors between; the input and output TTrees by falling back to using the 'slow' mode. In particular this allow; a 'fast cloning' to handle files that requires schema evolution (albeit it is of course much slower).; Make sure that the TTreeCache is not attempting to cache (wrongly) the content of branches that are in an auxiliary files.; Make sure that FillBuffer does it work when the learning phase is over even if the entry number is 'low' for the 'current' file of a chain.; If TTree::SetEventList is called, TTree::GetEntryList no longer relinquish ownership of the automatically created TEntryList; Add the ability to see the TTree UserInfo list from the TBrowser; Fix the case of reading a TTree containing an 'old' class layout that contained a std::vector that is no longer part of the current class layout; Implement direct interfaces from TTree to the result of TSelector::Draw; TTree:GetVal(int) and TTree::GetVar(int); In TTree::ReadFile add the possibility to read multiple input files and add support for large/wide Trees definition.; Added support for ""5-D"" plotting.; Added support for std::bitset; Reduce the memory used by the mechanism keeping track of the entry of variables sizes within a basket (fEntryOffset).; The memory used now automatically decrease if the number of entries in the basket is less than 1/4 oflength of fEntryOffset.; Also the default length fEntryOffset can be set via TTree::SetDefaultEntryOffsetLen ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/doc/v524/index.html:942,learn,learning,942,tree/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/doc/v524/index.html,1,['learn'],['learning']
Usability,". Tutorials. New tutorial $ROOTSYS/tutorials/graphics/mass_spectrum.C. It; produces the following output:; . New tutorial $ROOTSYS/math/goftest.C showing the example; usage of the new ROOT::Math::GoFTest class. New tutorial $ROOTSYS/math/multiDimSampling.C showing the example; usage of the new ROOT::Math::DistSampler interface for; random generation from arbitrary functions using Unuran or Foam. New tutorial $ROOTSYS/math/kdTreeBinning.C showing the example; usage of the new TKDTreeBinning class. New tutorial $ROOTSYS/fit/NumericalMinimization.C showing; a minimization example (Rosenbrock function) using the; ROOT::Math::Minimizer interface. New tutorial $ROOTSYS/fit/exampleFit3D.C showing; a simple fit example of 3D points with a 3D function. New tutorial $ROOTSYS/fit/TSVDUnfoldExample.C showing; an example of the new TSVDUnfold class. New Roostats tutorials:. New Demos that take name for file, workspace, modelconfig, and data, then use the corresponding calculator tool. If the file is not specified it will read an file produced from running the HistFactory tutorial example. StandardProfileLikelihoodDemo.C: ; StandardFeldmanCousinsDemo.C: ; StandardBayesianMCMCDemo.C: ; StandardBayesianNumericalDemo.C: ; StandardProfileInspectorDemo.C: . Demonstrate some new PDFs. TestNonCentral.C: demonstrates non central chi-square; JeffreysPriorDemo.C: demonstrates Jeffreys Prior. Instructional Examples. IntervalExamples.C: Standard Gaussian with known answer using 4 techniques; FourBinInstructional.C: Example of a standard data-driven approach for estimating backgrounds. A lot of discussion.; HybridInstructional.C: Example of protoype on/off problem with a data-driven background estimate. A lot of discussion; HybridStandardForm.C: Variant on above in 'standard form'; MultivariateGaussianTest.C: A validation example with an N-D multivariate Gaussian . Renamed the rs201_hybridcalculator.C to; HybridOriginalDemo.C; Removed some obsolete roostats tutorials (all the rs500 types). ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/doc/v528/index.html:702,simpl,simple,702,tutorials/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/doc/v528/index.html,1,['simpl'],['simple']
Usability,". When the level of a; component reaches the limit value one can choose either smooth; transition (by decreasing the limit value) or a sharp modulo; transition (continuing with 0 value). This allows various visual; effects. One can choose from the following set of the algorithms:. - 0 = RGB Smooth,; - 1 = RGB Modulo,; - 2 = CMY Smooth,; - 3 = CMY Modulo,; - 4 = CIE Smooth; - 5 = CIE Modulo,; - 6 = YIQ Smooth,; - 7 = YIQ Modulo,; - 8 = HVS Smooth,; - 9 = HVS Modulo. This function does not apply on Simple display modes group. Default; value is 0. Example choosing CMY Modulo to paint the 2D histogram:. ``` {.cpp}; h2->Draw(""SPEC c1(3) dm(0,1) a(30,30,0)"");; ```. The operator ""`lp(x,y,z)`"" sets the light position. In Light and; LightHeight display modes groups the color palette is calculated; according to the fictive light source position in 3-d space. Using; this function one can change the source's position and thus achieve; various graphical effects. This function does not apply for Simple and; Height display modes groups. Default is: `lp(1000,1000,100)` . The operator ""`s(shading,shadow)`"" allows to set the shading. The; surface picture is composed of triangles. The edges of the neighboring; triangles can be smoothed (shaded). The shadow can be painted as well.; The function does not apply on Simple display modes group. The; possible values for shading are:. - 0 = Not Shaded,; - 1 = Shaded. The possible values for shadow are:. - 0 = Shadows are not painted,; - 1 = Shadows are painted. Default values: `s(1,0)` . The operator ""`b(bezier)`"" sets the Bezier smoothing. For Simple; display modes group and for Grid, LinesX and LinesY display modes one; can smooth data using Bezier smoothing algorithm. The function does; not apply on other display modes groups and display modes. Possible; values are: 0 = No bezier smoothing, 1 = Bezier smoothing. Default; value is: `b(0)`. The operator ""`cw(width)`"" sets the contour width. This function; applies only on for the Contours dis",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:39711,Simpl,Simple,39711,documentation/users-guide/Histograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md,1,['Simpl'],['Simple']
Usability,". When there is no; way to reconstitute the value of the lost instruction, this is the best; possible outcome. However, it's often possible to do better:. * If the dying instruction can be RAUW'd, do so. The; ``Value::replaceAllUsesWith`` API transparently updates debug uses of the; dying instruction to point to the replacement value. * If the dying instruction cannot be RAUW'd, call ``llvm::salvageDebugInfo`` on; it. This makes a best-effort attempt to rewrite debug uses of the dying; instruction by describing its effect as a ``DIExpression``. * If one of the **operands** of a dying instruction would become trivially; dead, use ``llvm::replaceAllDbgUsesWith`` to rewrite the debug uses of that; operand. Consider the following example function:. .. code-block:: llvm. define i16 @foo(i16 %a) {; %b = sext i16 %a to i32; %c = and i32 %b, 15; call void @llvm.dbg.value(metadata i32 %c, ...); %d = trunc i32 %c to i16; ret i16 %d; }. Now, here's what happens after the unnecessary truncation instruction ``%d`` is; replaced with a simplified instruction:. .. code-block:: llvm. define i16 @foo(i16 %a) {; call void @llvm.dbg.value(metadata i32 undef, ...); %simplified = and i16 %a, 15; ret i16 %simplified; }. Note that after deleting ``%d``, all uses of its operand ``%c`` become; trivially dead. The debug use which used to point to ``%c`` is now ``undef``,; and debug info is needlessly lost. To solve this problem, do:. .. code-block:: cpp. llvm::replaceAllDbgUsesWith(%c, theSimplifiedAndInstruction, ...). This results in better debug info because the debug use of ``%c`` is preserved:. .. code-block:: llvm. define i16 @foo(i16 %a) {; %simplified = and i16 %a, 15; call void @llvm.dbg.value(metadata i16 %simplified, ...); ret i16 %simplified; }. You may have noticed that ``%simplified`` is narrower than ``%c``: this is not; a problem, because ``llvm::replaceAllDbgUsesWith`` takes care of inserting the; necessary conversion operations into the DIExpressions of updated debug uses. D",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToUpdateDebugInfo.rst:7808,simpl,simplified,7808,interpreter/llvm-project/llvm/docs/HowToUpdateDebugInfo.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToUpdateDebugInfo.rst,1,['simpl'],['simplified']
Usability,". private:; T m_t;; };. void instantiate() { TemplStruct<int> ti; }. 2 matches found. Replacement produces incorrect output:. struct S {; safe_int m_i;; };. template <typename T> struct TemplStruct {; TemplStruct() {}; ~TemplStruct() {}. private:; safe_int m_t;; };. void instantiate() { TemplStruct<int> ti; }. 1 match found. Replacement produces correct output:. struct S {; safe_int m_i;; };. template <typename T> struct TemplStruct {; TemplStruct() {}; ~TemplStruct() {}. private:; T m_t;; };. void instantiate() { TemplStruct<int> ti; }. Add prefix to member initializer. cxxCtorInitializer(; forField(fieldDecl()); ).bind(""add_prefix""). given:. struct Simple {};. struct Record {; Record() : i(42) {}; private:; int i;; Simple s;; };. 2 matches found. Replacement produces incorrect output:. struct Simple {};. struct Record {; m_Record() : m_i(42) {}; private:; int i;; Simple s;; };. 1 match found. Replacement produces correct output:. struct Simple {};. struct Record {; Record() : m_i(42) {}; private:; int i;; Simple s;; };. Ignored default arguments. callExpr(; callee(functionDecl(; hasName(""hasDefaultArg""); )),; argumentCountIs(1); ).bind(""add_prefix""). given:. void hasDefaultArg(int i, int j = 0) {}; void callDefaultArg() { hasDefaultArg(42); }. No match. 1 match found. Lambda fields. fieldDecl(; hasType(asString(""int"")); ).bind(""make_safe""). given:. struct S {; int m_i;; };. void func() {; int a = 0;; int c = 0;. auto l = [a, b = c](int d) { int e = d; };; l(43);; }. 2 matches found. Replacement produces incorrect output:. struct S {; safe_int m_i;; };. void func() {; int a = 0;; int c = 0;. auto l = [safe_a, safe_b = c](int d) { int e = d; };; l(43);; }. 1 match found. Replacement produces correct output:. struct S {; safe_int m_i;; };. void func() {; int a = 0;; int c = 0;. auto l = [a, b = c](int d) { int e = d; };; l(43);; }. Rewritten binary operators. binaryOperator(; hasOperatorName(""<""),; hasRHS(hasDescendant(integerLiteral(equals(0)))); ). given:. #include ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:6320,Simpl,Simple,6320,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['Simpl'],['Simple']
Usability,".. -*- mode: rst -*-. CPyCppyy: Python-C++ bindings interface based on Cling/LLVM; ===========================================================. CPyCppyy is the CPython equivalent of _cppyy in PyPy.; It provides dynamic Python-C++ bindings by leveraging the Cling C++; interpreter and LLVM.; Details and performance are described in; `this paper <http://conferences.computer.org/pyhpc/2016/papers/5220a027.pdf>`_. CPyCppyy is a CPython extension module built on top of the same backend API; as PyPy/_cppyy.; It thus requires the installation of the; `cppyy backend <https://pypi.python.org/pypi/cppyy-backend/>`_; for use, which will pull in Cling.; CPython/cppyy and PyPy/cppyy are designed to be compatible, although there; are differences due to the former being reference counted and the latter; being garbage collected, as well as temporary differences due to different; release cycles of the respective projects. ----. Find the cppyy documentation here:; http://cppyy.readthedocs.io. Change log:; https://cppyy.readthedocs.io/en/latest/changelog.html. Bug reports/feedback:; https://github.com/wlav/cppyy/issues; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/README.rst:1069,feedback,feedback,1069,bindings/pyroot/cppyy/CPyCppyy/README.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/README.rst,1,['feedback'],['feedback']
Usability,".. -*- mode: rst -*-. cppyy: Python-C++ bindings interface based on Cling/LLVM; ========================================================. cppyy provides fully automatic, dynamic Python-C++ bindings by leveraging; the Cling C++ interpreter and LLVM.; It supports both PyPy (natively), CPython, and C++ language standards; through C++17 (and parts of C++20). Details and performance are described in; `this paper <http://cern.ch/wlav/Cppyy_LavrijsenDutta_PyHPC16.pdf>`_,; originally presented at PyHPC'16, but since updated with improved performance; numbers. Full documentation: `cppyy.readthedocs.io <http://cppyy.readthedocs.io/>`_. Notebook-based tutorial: `Cppyy Tutorial <https://github.com/wlav/cppyy/blob/master/doc/tutorial/CppyyTutorial.ipynb>`_. For Anaconda/miniconda, install cppyy from `conda-forge <https://anaconda.org/conda-forge/cppyy>`_. ----. Change log:; https://cppyy.readthedocs.io/en/latest/changelog.html. Bug reports/feedback:; https://github.com/wlav/cppyy/issues; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/README.rst:941,feedback,feedback,941,bindings/pyroot/cppyy/cppyy/README.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/README.rst,1,['feedback'],['feedback']
Usability,".. _basic_types:. Basic types; ===========. C++ has a far richer set of builtin types than Python.; Most Python code can remain relatively agnostic to that, and ``cppyy``; provides automatic conversions as appropriate.; On the other hand, Python builtin types such as lists and maps are far; richer than any builtin types in C++.; These are mapped to their Standard Template Library equivalents instead. The C++ code used for the examples below can be found; :doc:`here <cppyy_features_header>`, and it is assumed that that code is; loaded before running any of the example code snippets.; Download it, save it under the name ``features.h``, and simply include it:. .. code-block:: python. >>> import cppyy; >>> cppyy.include('features.h'); >>>. `Builtins`; """""""""""""""""""". The selection of builtin data types varies greatly between Python and C++.; Where possible, builtin data types map onto the expected equivalent Python; types, with the caveats that there may be size differences, different; precision or rounding, etc.; For example, a C++ ``float`` is returned as a Python ``float``, which is in; fact a C++ ``double``.; If sizes allow, conversions are automatic.; For example, a C++ ``unsigned int`` becomes a Python2 ``long`` or Python3; ``int``, but unsigned-ness is still honored:. .. code-block:: python. >>> cppyy.gbl.gUint; 0L; >>> type(cppyy.gbl.gUint); <type 'long'>; >>> cppyy.gbl.gUint = -1; Traceback (most recent call last):; File ""<stdin>"", line 1, in <module>; ValueError: cannot convert negative integer to unsigned; >>>. On some platforms, 8-bit integer types such as ``int8_t`` and ``uint8_t`` are; represented as `char` types.; For consistency, these are mapped onto Python `int`. Some types are builtin in Python, but (STL) classes in C++.; Examples are ``str`` vs. ``std::string`` (see also the; :doc:`Strings <strings>` section) and ``complex`` vs. ``std::complex``.; These classes have been pythonized to behave the same wherever possible.; For example, string comparison work",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/basic_types.rst:646,simpl,simply,646,bindings/pyroot/cppyy/cppyy/doc/source/basic_types.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/basic_types.rst,1,['simpl'],['simply']
Usability,".. _bugs:. Bugs and feedback; =================. Please report bugs, ask questions, request improvements, and post general; comments on the `issue tracker`_ or on `stack overflow`_ (marked with the; ""cppyy"" tag). .. _`issue tracker`: https://github.com/wlav/cppyy/issues; .. _`stack overflow`: https://stackoverflow.com/questions/tagged/cppyy; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/bugs.rst:20,feedback,feedback,20,bindings/pyroot/cppyy/cppyy/doc/source/bugs.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/bugs.rst,1,['feedback'],['feedback']
Usability,".. _github-reviews:. ======================; LLVM GitHub User Guide; ======================. Introduction; ============; The LLVM Project uses `GitHub <https://github.com/>`_ for; `Source Code <https://github.com/llvm/llvm-project>`_,; `Releases <https://github.com/llvm/llvm-project/releases>`_,; `Issue Tracking <https://github.com/llvm/llvm-project/issues>`_., and; `Code Reviews <https://github.com/llvm/llvm-project/pulls>`_. This page describes how the LLVM Project users and developers can; participate in the project using GitHub. Branches; ========. It is possible to create branches that starts with `users/<username>/`, however this is; intended to be able to support ""stacked"" pull-request. Do not create any branches in the; llvm/llvm-project repository otherwise, please use a fork (see below). User branches that; aren't associated with a pull-request **will be deleted**. Pull Requests; =============; The LLVM project is using GitHub Pull Requests for Code Reviews. This document; describes the typical workflow of creating a Pull Request and getting it reviewed; and accepted. This is meant as an overview of the GitHub workflow, for complete; documentation refer to `GitHub's documentation <https://docs.github.com/pull-requests>`_. GitHub Tools; ------------; You can interact with GitHub in several ways: via git command line tools,; the web browser, `GitHub Desktop <https://desktop.github.com/>`_, or the; `GitHub CLI <https://cli.github.com>`_. This guide will cover the git command line; tools and the GitHub CLI. The GitHub CLI (`gh`) will be most like the `arc` workflow and; recommended. Creating Pull Requests; ----------------------; Keep in mind that when creating a pull request, it should generally only contain one; self-contained commit initially.; This makes it easier for reviewers to understand the introduced changes and; provide feedback. It also helps maintain a clear and organized commit history; for the project. If you have multiple changes you want to int",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GitHub.rst:62,Guid,Guide,62,interpreter/llvm-project/llvm/docs/GitHub.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GitHub.rst,1,['Guid'],['Guide']
Usability,".. _philosophy:. Philosophy; ==========. .. toctree::; :hidden:. As a Python-C++ language binder, cppyy has several unique features: it fills; gaps and covers use cases not available through other binders.; This document explains some of the design choices made and the thinking; behind the implementations of those features.; It's categorized as ""philosophy"" because a lot of it is open to; interpretation.; Its main purpose is simply to help you decide whether cppyy covers your use; cases and binding requirements, before committing any time to; :ref:`trying it out <starting>`. Run-time v.s. compile-time; --------------------------. What performs better, run-time or compile-time?; The obvious answer is compile-time: see the performance differences between; C++ and Python, for example.; Obvious, but completely wrong, however.; In fact, when it comes to Python, it is even the `wrong question.`. Everything in Python is run-time: modules, classes, functions, etc. are all; run-time constructs.; A Python module that defines a class is a set of instructions to the Python; interpreter that lead to the construction of the desired class object.; A C/C++ extension module that defines a class does the same thing by calling; a succession of Python interpreter Application Programming Interfaces (APIs;; the exact same that Python uses itself internally).; If you use a compile-time binder such as `SWIG`_ or `pybind11`_ to bind a C++; class, then what gets compiled is the series of API calls necessary to; construct a Python-side equivalent at `run-time` (when the module gets; loaded), not the Python class object.; In short, whether a binding is created at ""compile-time"" or at run-time has; no measurable bearing on performance. What does affect performance is the overhead to cross the language barrier.; This consists of unboxing Python objects to extract or convert the underlying; objects or data to something that matches what C++ expects; overload; resolution based on the unboxed argume",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/philosophy.rst:429,simpl,simply,429,bindings/pyroot/cppyy/cppyy/doc/source/philosophy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/philosophy.rst,1,['simpl'],['simply']
Usability,".. _repositories:. Repositories; ============. The ``cppyy`` module is a frontend that requires an intermediate (Python; interpreter dependent) layer, and a backend (see; :ref:`Package Structure <package-structure>`).; Because of this layering and because it leverages several existing packages; through reuse, the relevant codes are contained across a number of; repositories. * Frontend, cppyy: https://github.com/wlav/cppyy; * CPython (v2/v3) intermediate: https://github.com/wlav/CPyCppyy; * PyPy intermediate (module _cppyy): https://foss.heptapod.net/pypy; * Backend, cppyy: https://github.com/wlav/cppyy-backend. The backend repo contains both the cppyy-cling (under ""cling"") and; cppyy-backend (under ""clingwrapper"") packages. .. _building_from_source:. Building from source; --------------------. Except for cppyy-cling, the structure in the repositories follows a normal; PyPA package and they are thus ready to build with `setuptools`_: simply; clone the package and either run ``python setup.py``, or use ``pip``. It is highly recommended to follow the dependency chain when manually; upgrading packages individually (i.e. ``cppyy-cling``, ``cppyy-backend``,; ``CPyCppyy`` if on CPython, and then finally ``cppyy``), because upstream; packages expose headers that are used by the ones downstream.; Of course, if only building for a patch/point release, there is no need to; re-install the full chain (or follow the order).; Always run the local updates from the package directories (i.e. where the; ``setup.py`` file is located), as some tools rely on the package structure. The ``STDCXX`` envar can be used to control the C++ standard version; use; ``MAKE`` to change the ``make`` command; and ``MAKE_NPROCS`` to control the; maximum number of parallel jobs.; Compilation of the backend, which contains a customized version of; Clang/LLVM, can take a long time, so by default the setup script will use all; cores (x2 if hyperthreading is enabled). On MS Windows, some temporary path names",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/repositories.rst:948,simpl,simply,948,bindings/pyroot/cppyy/cppyy/doc/source/repositories.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/repositories.rst,1,['simpl'],['simply']
Usability,".. _starting:. Trying it out; =============. This is a basic guide to try cppyy and see whether it works for you.; Large code bases will benefit from more advanced features such as; :doc:`pythonizations <pythonizations>` for a cleaner interface to clients;; precompiled modules for faster parsing and reduced memory usage;; "":ref:`dictionaries <dictionaries>`"" to package locations and manage; dependencies; and mapping files for automatic, lazy, loading.; You can, however, get very far with just the basics and it may even be; completely sufficient for small packages with fewer classes. cppyy works by parsing C++ definitions through ``cling``, generating tiny; wrapper codes to honor compile-time features and create standardized; interfaces, then compiling/linking those wrappers with the ``clang`` JIT.; It thus requires only those two ingredients: *C++ definitions* and; *linker symbols*.; All cppyy uses, the basic and the more advanced, are variations on the; theme of bringing these two together at the point of use. Definitions typically live in header files and symbols in libraries.; Headers can be loaded with ``cppyy.include`` and libraries with the; ``cppyy.load_library`` call.; Loading the header is sufficient to start exploring, with ``cppyy.gbl`` the; starting point of all things C++, while the linker symbols are only needed at ; the point of first use. Here is an example using the `zlib`_ library, which is likely available on; your system:. .. code-block:: python. >>> import cppyy; >>> cppyy.include('zlib.h') # bring in C++ definitions; >>> cppyy.load_library('libz') # load linker symbols; >>> cppyy.gbl.zlibVersion() # use a zlib API; '1.2.11'; >>>. Since header files can include other header files, it is easy to aggregate; all relevant ones into a single header to include.; If there are project-specific include paths, you can add those paths through; ``cppyy.add_include_path``.; If a header is C-only and not set for use with C++, use ``cppyy.c_include``,; which ad",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/starting.rst:61,guid,guide,61,bindings/pyroot/cppyy/cppyy/doc/source/starting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/starting.rst,1,['guid'],['guide']
Usability,".. role:: raw-html(raw); :format: html. =================================; LLVM Code Coverage Mapping Format; =================================. .. contents::; :local:. Introduction; ============. LLVM's code coverage mapping format is used to provide code coverage; analysis using LLVM's and Clang's instrumentation based profiling; (Clang's ``-fprofile-instr-generate`` option). This document is aimed at those who would like to know how LLVM's code coverage; mapping works under the hood. A prior knowledge of how Clang's profile guided; optimization works is useful, but not required. For those interested in using; LLVM to provide code coverage analysis for their own programs, see the `Clang; documentation <https://clang.llvm.org/docs/SourceBasedCodeCoverage.html>`. We start by briefly describing LLVM's code coverage mapping format and the; way that Clang and LLVM's code coverage tool work with this format. After; the basics are down, more advanced features of the coverage mapping format; are discussed - such as the data structures, LLVM IR representation and; the binary encoding. High Level Overview; ===================. LLVM's code coverage mapping format is designed to be a self contained; data format that can be embedded into the LLVM IR and into object files.; It's described in this document as a **mapping** format because its goal is; to store the data that is required for a code coverage tool to map between; the specific source ranges in a file and the execution counts obtained; after running the instrumented version of the program. The mapping data is used in two places in the code coverage process:. 1. When clang compiles a source file with ``-fcoverage-mapping``, it; generates the mapping information that describes the mapping between the; source ranges and the profiling instrumentation counters.; This information gets embedded into the LLVM IR and conveniently; ends up in the final executable file when the program is linked. 2. It is also used by *llvm-cov* -",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CoverageMappingFormat.rst:533,guid,guided,533,interpreter/llvm-project/llvm/docs/CoverageMappingFormat.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CoverageMappingFormat.rst,1,['guid'],['guided']
Usability,".. you get the idea. The `bool parser`_ just turns the string values into; boolean values, and rejects things like '``compiler -f=foo``'. Similarly, the; `float`_, `double`_, and `int`_ parsers work like you would expect, using the; '``strtol``' and '``strtod``' C library calls to parse the string value into the; specified data type. With the declarations above, ""``compiler -help``"" emits this:. ::. USAGE: compiler [options] <input file>. OPTIONS:; -f - Enable binary output on terminals; -o - Override output filename; -quiet - Don't print informational messages; -help - display available options (-help-hidden for more). and ""``compiler -help-hidden``"" prints this:. ::. USAGE: compiler [options] <input file>. OPTIONS:; -f - Enable binary output on terminals; -o - Override output filename; -q - Don't print informational messages; -quiet - Don't print informational messages; -help - display available options (-help-hidden for more). This brief example has shown you how to use the '`cl::opt`_' class to parse; simple scalar command line arguments. In addition to simple scalar arguments,; the CommandLine library also provides primitives to support CommandLine option; `aliases`_, and `lists`_ of options. .. _aliases:. Argument Aliases; ----------------. So far, the example works well, except for the fact that we need to check the; quiet condition like this now:. .. code-block:: c++. ...; if (!Quiet && !Quiet2) printInformationalMessage(...);; ... ... which is a real pain! Instead of defining two values for the same; condition, we can use the ""`cl::alias`_"" class to make the ""``-q``"" option an; **alias** for the ""``-quiet``"" option, instead of providing a value itself:. .. code-block:: c++. cl::opt<bool> Force (""f"", cl::desc(""Overwrite output files""));; cl::opt<bool> Quiet (""quiet"", cl::desc(""Don't print informational messages""));; cl::alias QuietA(""q"", cl::desc(""Alias for -quiet""), cl::aliasopt(Quiet));. The third line (which is the only one we modified from above) defines ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst:11550,simpl,simple,11550,interpreter/llvm-project/llvm/docs/CommandLine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst,1,['simpl'],['simple']
Usability,"... <arguments to function>). Overview:; """""""""""""""""". The '``llvm.coro.suspend.async``' intrinsic marks the point where; execution of an async coroutine is suspended and control is passed to a callee. Arguments:; """""""""""""""""""". The first argument should be the result of the `llvm.coro.async.resume` intrinsic.; Lowering will replace this intrinsic with the resume function for this suspend; point. The second argument is the `context projection function`. It should describe; how-to restore the `async context` in the continuation function from the first; argument of the continuation function. Its type is `ptr (ptr)`. The third argument is the function that models transfer to the callee at the; suspend point. It should take 3 arguments. Lowering will `musttail` call this; function. The fourth to six argument are the arguments for the third argument. Semantics:; """""""""""""""""""". The result of the intrinsic are mapped to the arguments of the resume function.; Execution is suspended at this intrinsic and resumed when the resume function is; called. .. _coro.prepare.async:. 'llvm.coro.prepare.async' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; ::. declare ptr @llvm.coro.prepare.async(ptr <coroutine function>). Overview:; """""""""""""""""". The '``llvm.coro.prepare.async``' intrinsic is used to block inlining of the; async coroutine until after coroutine splitting. Arguments:; """""""""""""""""""". The first argument should be an async coroutine of type `void (ptr, ptr, ptr)`.; Lowering will replace this intrinsic with its coroutine function argument. .. _coro.suspend.retcon:. 'llvm.coro.suspend.retcon' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; ::. declare i1 @llvm.coro.suspend.retcon(...). Overview:; """""""""""""""""". The '``llvm.coro.suspend.retcon``' intrinsic marks the point where; execution of a returned-continuation coroutine is suspended and control; is returned back to the caller. `llvm.coro.suspend.retcon`` does not support separate save points;; they are not useful when the cont",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:54434,resume,resumed,54434,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,2,['resume'],"['resume', 'resumed']"
Usability,"..; > Instead, it could a great topic for a separate study. Agreed. :). > What is the semantics of the IA64 stop bit?. Basically, the IA64 writes instructions like this:; mov ...; add ...; sub ...; op xxx; op xxx; ;;; mov ...; add ...; sub ...; op xxx; op xxx; ;;. Where the ;; delimits a group of instruction with no dependencies between; them, which can all be executed concurrently (to the limits of the; available functional units). The ;; gets translated into a bit set in one; of the opcodes. The advantages of this representation is that you don't have to do some; kind of 'thread id scheduling' pass by having to specify ahead of time how; many threads to use, and the representation doesn't have a per instruction; overhead... > And finally, another thought about the syntax for arrays :-); > Although this syntax:; > array <dimension-list> of <type>; > is verbose, it will be used only in the human-readable assembly code so; > size should not matter. I think we should consider it because I find it; > to be the clearest syntax. It could even make arrays of function; > pointers somewhat readable. My only comment will be to give you an example of why this is a bad; idea. :). Here is an example of using the switch statement (with my recommended; syntax):. switch uint %val, label %otherwise, ; [%3 x {uint, label}] [ { uint %57, label %l1 }, ; { uint %20, label %l2 }, ; { uint %14, label %l3 } ]. Here it is with the syntax you are proposing:. switch uint %val, label %otherwise, ; array %3 of {uint, label} ; array of {uint, label}; { uint %57, label %l1 },; { uint %20, label %l2 },; { uint %14, label %l3 }. Which is ambiguous and very verbose. It would be possible to specify; constants with [] brackets as in my syntax, which would look like this:. switch uint %val, label %otherwise,; array %3 of {uint, label} [ { uint %57, label %l1 },; { uint %20, label %l2 },; { uint %14, label %l3 } ]. But then the syntax is inconsistent between type definition and constant; definition (wh",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-09-AdveCommentsResponse.txt:8091,clear,clearest,8091,interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-09-AdveCommentsResponse.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-09-AdveCommentsResponse.txt,1,['clear'],['clearest']
Usability,"..; This work is licensed under a Creative Commons Attribution 3.0 Unported License.; SPDX-License-Identifier: CC-BY-3.0. ===============; Response Guide; ===============. This is a :doc:`Code of Conduct<CodeOfConduct>` (CoC) incident response guide; used by the Code of Conduct Committee and LLVM event organizers. Code of Conduct Committee; =========================. All responses to Code of Conduct reports will be managed by a Code of Conduct; Committee. . Additional Code of Conduct Response Teams; =========================================. In-person events will have an additional response team to immediately respond; to an incident. For example:. * Each LLVM Developers' Meeting has a Code of Conduct response team.; * For LLVM meetups, the local organizers will be the first point of contact.; * Any other event funded by the LLVM Foundation or listed on the LLVM website,; will have a code of conduct response team or point of contact for CoC ; reports. These teams should determine if an :ref:`immediate response<Immediate Response; Checklist>` is needed before sending the report to the Code of Conduct; committee. .. _Receiving a report:. Receiving a Report; ==================. Reports are typically received by email (conduct@llvm.org) or in person from; the reporter or event CoC response team. When receiving a report by email, the CoC Committee should acknowledge receipt; within 24 hours. The acknowledgement should be understanding and compassionate; but no commitment should be made on whether this is a violation or which action; will be taken. Specific guidance is in the checklist below. For in-person events that have a violation reported, the report should be sent; to the Code of Conduct committee within 24 hours by the on-site CoC response; team. . .. _Immediate Response Checklist:. Immediate Response Checklist; ============================. The CoC committee generally works, decides, and communicates together. If the; report indicates that an immediate response is ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ResponseGuide.rst:148,Guid,Guide,148,interpreter/llvm-project/llvm/docs/ResponseGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ResponseGuide.rst,2,"['Guid', 'guid']","['Guide', 'guide']"
Usability,"..; This work is licensed under a Creative Commons Attribution 3.0 Unported License.; SPDX-License-Identifier: CC-BY-3.0. ==============================; LLVM Community Code of Conduct; ==============================. The LLVM community has always worked to be a welcoming and respectful; community, and we want to ensure that doesn't change as we grow and evolve. To; that end, we have a few ground rules that we ask people to adhere to:. * `be friendly and patient`_,; * `be welcoming`_,; * `be considerate`_,; * `be respectful`_,; * `be careful in the words that you choose and be kind to others`_, and; * `when we disagree, try to understand why`_. This isn't an exhaustive list of things that you can't do. Rather, take it in; the spirit in which it's intended - a guide to make it easier to communicate; and participate in the community. This code of conduct applies to all spaces managed by the LLVM project or The; LLVM Foundation. This includes IRC channels, mailing lists, bug trackers, LLVM; events such as the developer meetings and socials, and any other forums created; by the project that the community uses for communication. It applies to all of; your communication and conduct in these spaces, including emails, chats, things; you say, slides, videos, posters, signs, or even t-shirts you display in these; spaces. . In rare cases, violations of this code outside of these spaces may affect a ; person’s ability to participate within these spaces. Important examples ; include `sexual and gender-based violence`_, `hate crimes`_, and `hate speech`_. ; We do not conduct proactive research, but we have an obligation to respond ; to any reported concerns. We are not interested in evaluating severity, ; responding punitively, or holding people accountable. Both the relevance ; and our response is instead focused on how a person’s continued participation ; impacts the community’s safety, wellbeing, and inclusivity. We specifically ; prioritize remaining a welcoming community to v",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeOfConduct.rst:770,guid,guide,770,interpreter/llvm-project/llvm/docs/CodeOfConduct.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeOfConduct.rst,1,['guid'],['guide']
Usability,"..; This work is licensed under a Creative Commons Attribution 3.0 Unported License.; SPDX-License-Identifier: CC-BY-3.0. =================================; LLVM CoC Incident Reporting Guide; =================================. First of all, please do not feel like you may be a burden to us by reporting; incidents. We consider reports an opportunity for us to act: by knowing about; an incident, we can act on it if appropriate, and reduce continuation of; problematic behavior. If we don't know, we can't learn or take any appropriate; actions. If you are not sure the situation being reported was a :doc:`Code of; Conduct<CodeOfConduct>` violation, we encourage you to still report it. We; would much rather have reports where we decide to take no action, rather than; miss a report of an actual violation. There is no harm in reporting an incident; which is later determined not to be a violation, and knowing about incidents; that are not violations can also help us to improve the Code of Conduct or the; processes surrounding it. Reporting and Contact Information; =================================. * For any incident involving an online platform (e.g., mailing lists, forums, ; irc/discord/slack, etc) we ask that you make any reports by emailing ; conduct@llvm.org. This is received by all members of the CoC Committee. * For LLVM Developers' Meetings, please file a report with the on-site Code ; of Conduct team. Their names and contact details are listed on the event ; webpage. You can also approach any other staff member, who can be ; identified by special badges and often found at the registration desk, ; to help you locate a member of the Code of Conduct team. All incidents ; reported in-person at a LLVM Developers' Meeting will be emailed to the ; Code of Conduct Committee. . * For meetups, please report the incident to the local meetup organizers first; and then email conduct@llvm.org with your report. Each meetup will have a ; contact listed on the associated meetup page.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReportingGuide.rst:185,Guid,Guide,185,interpreter/llvm-project/llvm/docs/ReportingGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReportingGuide.rst,2,"['Guid', 'learn']","['Guide', 'learn']"
Usability,".; 2. Implement JSROOT.extend instead of jQuery.extend, reduce; usage of jquery.js in core JSROOT classes; 3. Implement main graphics without jquery at all,; such mode used in `nobrowser` mode.; 4. Provide optional latex drawing with MathJax SVG.; TMathText always drawn with MathJax,; other classes require `mathjax` option in URL; 5. Improve drawing of different text classes, correctly handle; their alignment and scaling, special handling for IE; 6. Fix error with time axes - time offset was not correctly interpreted. ## Changes in 3.3; 1. Use d3.time.scale for display of time scales; 2. Within JSRootCore.js script URL one could specify JSROOT; functionality to be loaded: '2d', '3d', 'io', 'load', 'onload'.; Old method with JSROOT.AssertPrerequisites will also work.; 3. With THttpServer JSROOT now provides simple control functionality.; One could publish commands and execute them from the browser; 4. One could open several ROOT files simultaneously; 5. Add 'simple' layout - drawing uses full space on the right side; 6. Allow to open ROOT files in online session (via url parameter); 7. One could monitor simultaneously objects from server and root files; 8. Implement 'autocol' draw option - when superimposing histograms,; their line colors will be automatically assigned; 9. Implement 'nostat' draw option - disabled stat drawing; 10. Using '_same_' identifier in item name, one can easily draw or superimpose; similar items from different files. Could be used in URL like:; `...&files=[file1.root,file2.root]&items=[file1.root/hpx, file2.root/_same_]`; `...&files=[file1.root,file2.root]&item=file1.root/hpx+file2.root/_same_`; Main limitation - file names should have similar length.; 11. When 'autozoom' specified in draw options, histogram zoomed into; non-empty content. Same command available via context menu.; 12. Item of 'Text' kind can be created. It is displayed as; plain text in the browser. If property 'mathjax' specified,; MathJax.js library will be loaded and used ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/changes.md:67369,simpl,simple,67369,js/changes.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/changes.md,1,['simpl'],['simple']
Usability,".; Any volume is an un-positioned object in the sense that it defines only; a ***`local frame`*** (matching the one of its ***`shape`***). In order; to fully define the mother-daughter relationship between two volumes one; has to specify how the daughter will be positioned inside. This is; accomplished by defining a ***`local geometrical transformation`*** of; the daughter with respect to the mother coordinate system. These; transformations will be subsequently used in the example. ***`Q:`*** ""I see the lines defining the top level volume as in the previous example,; but what about the other volumes named REPLICA and ROOT?"". ***`A:`*** You will also notice that several other volumes are created; by using lines like:. ``` {.cpp}; TGeoVolume *someVolume = gGeoManager->MakeXXX(""someName"",; ptrMedium, /* parameters coresponding to XXX ...*/); ```. In the method above **`XXX`** represent some shape name (Box, Tube,; etc.). This is just a simple way of creating a volume having a given; shape in one-step (see also section: ""Creating and Positioning; Volumes""). As for REPLICA and ROOT volumes, they are just some; ***`virtual volumes`*** used for grouping and positioning together other; ***`real volumes`***. See ""Positioned Volumes (Nodes)"". The same; structure represented by (a real or) a virtual volume can be; ***`replicated`*** several times in the geometry. ***`Q:`*** ""Fine, so probably the real volumes are the ones composing the letters R,; O and T. Why one have to define so many volumes to make an R?"". ***`A:`*** Well, in real life some objects have much more complex shapes; that an ***`R`***. The modeller cannot just know all of them; the idea; is to make a complex object by using elementary building blocks that; have known shapes (called ***`primitive shapes`***). Gluing these; together in the appropriate way is the user responsibility. ***`Q:`*** ""I am getting the global picture but not making much out of it... There; are also a lot of calls to TGeoVolume::AddNode()",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:6493,simpl,simple,6493,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['simpl'],['simple']
Usability,".; MI = BuildMI(MBB, DL, TII.get(X86::SAHF));. // Create a self looping branch instruction.; BuildMI(MBB, DL, TII.get(X86::JNE)).addMBB(&MBB);. If you need to add a definition operand (other than the optional destination; register), you must explicitly mark it as such:. .. code-block:: c++. MI.addReg(Reg, RegState::Define);. Fixed (preassigned) registers; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. One important issue that the code generator needs to be aware of is the presence; of fixed registers. In particular, there are often places in the instruction; stream where the register allocator *must* arrange for a particular value to be; in a particular register. This can occur due to limitations of the instruction; set (e.g., the X86 can only do a 32-bit divide with the ``EAX``/``EDX``; registers), or external factors like calling conventions. In any case, the; instruction selector should emit code that copies a virtual register into or out; of a physical register when needed. For example, consider this simple LLVM example:. .. code-block:: llvm. define i32 @test(i32 %X, i32 %Y) {; %Z = sdiv i32 %X, %Y; ret i32 %Z; }. The X86 instruction selector might produce this machine code for the ``div`` and; ``ret``:. .. code-block:: text. ;; Start of div; %EAX = mov %reg1024 ;; Copy X (in reg1024) into EAX; %reg1027 = sar %reg1024, 31; %EDX = mov %reg1027 ;; Sign extend X into EDX; idiv %reg1025 ;; Divide by Y (in reg1025); %reg1026 = mov %EAX ;; Read the result (Z) out of EAX. ;; Start of ret; %EAX = mov %reg1026 ;; 32-bit return value goes in EAX; ret. By the end of code generation, the register allocator would coalesce the; registers and delete the resultant identity moves producing the following; code:. .. code-block:: text. ;; X is in EAX, Y is in ECX; mov %EAX, %EDX; sar %EDX, 31; idiv %ECX; ret. This approach is extremely general (if it can handle the X86 architecture, it; can handle anything!) and allows all of the target specific knowledge about the; instruction stream to be isolat",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:19869,simpl,simple,19869,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,1,['simpl'],['simple']
Usability,".; Such new versions will be similar in spirit to the present version,; but may differ in detail to address new problems or concerns. Each version is given a distinguishing version number. If the Library; specifies a version number of this License which applies to it and; ""any later version"", you have the option of following the terms and; conditions either of that version or of any later version published by; the Free Software Foundation. If the Library does not specify a; license version number, you may choose any version ever published by; the Free Software Foundation.; ; 14. If you wish to incorporate parts of the Library into other free; programs whose distribution conditions are incompatible with these,; write to the author to ask for permission. For software which is; copyrighted by the Free Software Foundation, write to the Free; Software Foundation; we sometimes make exceptions for this. Our; decision will be guided by the two goals of preserving the free status; of all derivatives of our free software and of promoting the sharing; and reuse of software generally. NO WARRANTY. 15. BECAUSE THE LIBRARY IS LICENSED FREE OF CHARGE, THERE IS NO; WARRANTY FOR THE LIBRARY, TO THE EXTENT PERMITTED BY APPLICABLE LAW.; EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR; OTHER PARTIES PROVIDE THE LIBRARY ""AS IS"" WITHOUT WARRANTY OF ANY; KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR; PURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE; LIBRARY IS WITH YOU. SHOULD THE LIBRARY PROVE DEFECTIVE, YOU ASSUME; THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION. 16. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN; WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY; AND/OR REDISTRIBUTE THE LIBRARY AS PERMITTED ABOVE, BE LIABLE TO YOU; FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR; CONSEQUENTIAL DAMAGES A",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/LGPL2_1.txt:22823,guid,guided,22823,LGPL2_1.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/LGPL2_1.txt,1,['guid'],['guided']
Usability,".; This environment can use the Windows SDK headers directly and does not required additional; headers or additional runtime machinery (such as is used by mingw). Windows Itanium Stack:. * Uses the Itanium C++ abi.; * libc++.; * libc++-abi.; * libunwind.; * The MS VS CRT.; * Is compatible with MS Windows SDK include headers.; * COFF/PE file format.; * LLD. Note: compiler-rt is not used. This functionality is supplied by the MS VCRT. Prerequisites; =============. * The MS SDK is installed as part of MS Visual Studio.; * Clang with support for the windows-itanium triple.; * COFF LLD with support for the -autoimport switch. Known issues:; =============. SJLJ exceptions, ""-fsjlj-exceptions"", are the only currently supported model. link.exe (the MS linker) is unsuitable as it doesn't support auto-importing which; is currently required to link correctly. However, if that limitation is removed; then there are no other known issues with using link.exe. Currently, there is a lack of a usable Windows compiler driver for Windows Itanium.; A reasonable work-around is to build clang with a windows-msvc default target and; then override the triple with e.g. ""-Xclang -triple -Xclang x86_64-unknown-windows-itanium"".; The linker can be specified with: ""-fuse-ld=lld"". In the Itanium C++ ABI the first member of an object is a pointer to the vtable; for its class. The vtable is often emitted into the object file with the key function; and must be imported for classes marked dllimport. The pointers must be globally; unique. Unfortunately, the COFF/PE file format does not provide a mechanism to; store a runtime address from another DLL into this pointer (although runtime; addresses are patched into the IAT). Therefore, the compiler must emit some code,; that runs after IAT patching but before anything that might use the vtable pointers,; and sets the vtable pointer to the address from the IAT. For the special case of; the references to vtables for __cxxabiv1::__class_type_info from typei",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToBuildWindowsItaniumPrograms.rst:1329,usab,usable,1329,interpreter/llvm-project/llvm/docs/HowToBuildWindowsItaniumPrograms.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToBuildWindowsItaniumPrograms.rst,1,['usab'],['usable']
Usability,".begin(token %id, ptr %alloc); ...; store i32 42, ptr %promise ; store something into the promise; ...; ret ptr %hdl; }. define i32 @main() {; entry:; %hdl = call ptr @f(i32 4) ; starts the coroutine and returns its handle; %promise.addr = call ptr @llvm.coro.promise(ptr %hdl, i32 4, i1 false); %val = load i32, ptr %promise.addr ; load a value from the promise; call void @print(i32 %val); call void @llvm.coro.destroy(ptr %hdl); ret i32 0; }. .. _coroutine intrinsics:. Coroutine Structure Intrinsics; ------------------------------; Intrinsics described in this section are used within a coroutine to describe; the coroutine structure. They should not be used outside of a coroutine. .. _coro.size:. 'llvm.coro.size' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; ::. declare i32 @llvm.coro.size.i32(); declare i64 @llvm.coro.size.i64(). Overview:; """""""""""""""""". The '``llvm.coro.size``' intrinsic returns the number of bytes; required to store a `coroutine frame`_. This is only supported for; switched-resume coroutines. Arguments:; """""""""""""""""""". None. Semantics:; """""""""""""""""""". The `coro.size` intrinsic is lowered to a constant representing the size of; the coroutine frame. .. _coro.align:. 'llvm.coro.align' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; ::. declare i32 @llvm.coro.align.i32(); declare i64 @llvm.coro.align.i64(). Overview:; """""""""""""""""". The '``llvm.coro.align``' intrinsic returns the alignment of a `coroutine frame`_.; This is only supported for switched-resume coroutines. Arguments:; """""""""""""""""""". None. Semantics:; """""""""""""""""""". The `coro.align` intrinsic is lowered to a constant representing the alignment of; the coroutine frame. .. _coro.begin:. 'llvm.coro.begin' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; ::. declare ptr @llvm.coro.begin(token <id>, ptr <mem>). Overview:; """""""""""""""""". The '``llvm.coro.begin``' intrinsic returns an address of the coroutine frame. Arguments:; """""""""""""""""""". The first argument is a token returned by a call to '``llvm.coro.id`",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:31660,resume,resume,31660,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,.h; mlir/include/mlir-c/Dialect/Func.h; mlir/include/mlir-c/Dialect/GPU.h; mlir/include/mlir-c/Dialect/Linalg.h; mlir/include/mlir-c/Dialect/LLVM.h; mlir/include/mlir-c/Dialect/PDL.h; mlir/include/mlir-c/Dialect/Quant.h; mlir/include/mlir-c/Dialect/SCF.h; mlir/include/mlir-c/Dialect/Shape.h; mlir/include/mlir-c/Dialect/SparseTensor.h; mlir/include/mlir-c/Dialect/Tensor.h; mlir/lib/Analysis/AliasAnalysis.cpp; mlir/lib/Analysis/BufferViewFlowAnalysis.cpp; mlir/lib/Analysis/CallGraph.cpp; mlir/lib/Analysis/DataFlowAnalysis.cpp; mlir/lib/Analysis/DataLayoutAnalysis.cpp; mlir/lib/Analysis/Liveness.cpp; mlir/lib/Analysis/SliceAnalysis.cpp; mlir/lib/Analysis/AliasAnalysis/LocalAliasAnalysis.cpp; mlir/lib/Analysis/Presburger/IntegerRelation.cpp; mlir/lib/Analysis/Presburger/LinearTransform.cpp; mlir/lib/Analysis/Presburger/Matrix.cpp; mlir/lib/Analysis/Presburger/PresburgerSet.cpp; mlir/lib/Analysis/Presburger/PresburgerSpace.cpp; mlir/lib/Analysis/Presburger/PWMAFunction.cpp; mlir/lib/Analysis/Presburger/Simplex.cpp; mlir/lib/Analysis/Presburger/Utils.cpp; mlir/lib/Bindings/Python/AllPassesRegistration.cpp; mlir/lib/Bindings/Python/AsyncPasses.cpp; mlir/lib/Bindings/Python/DialectLinalg.cpp; mlir/lib/Bindings/Python/DialectPDL.cpp; mlir/lib/Bindings/Python/DialectQuant.cpp; mlir/lib/Bindings/Python/DialectSparseTensor.cpp; mlir/lib/Bindings/Python/ExecutionEngineModule.cpp; mlir/lib/Bindings/Python/Globals.h; mlir/lib/Bindings/Python/GPUPasses.cpp; mlir/lib/Bindings/Python/IRAffine.cpp; mlir/lib/Bindings/Python/IRAttributes.cpp; mlir/lib/Bindings/Python/IRCore.cpp; mlir/lib/Bindings/Python/IRInterfaces.cpp; mlir/lib/Bindings/Python/IRModule.cpp; mlir/lib/Bindings/Python/IRModule.h; mlir/lib/Bindings/Python/IRTypes.cpp; mlir/lib/Bindings/Python/LinalgPasses.cpp; mlir/lib/Bindings/Python/MainModule.cpp; mlir/lib/Bindings/Python/Pass.cpp; mlir/lib/Bindings/Python/Pass.h; mlir/lib/Bindings/Python/PybindUtils.cpp; mlir/lib/Bindings/Python/PybindUtils.h; mlir/lib/Bindings/Python,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt:377110,Simpl,Simplex,377110,interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,1,['Simpl'],['Simplex']
Usability,".llvm_stackmaps"". The segment name is ""__LLVM_STACKMAPS"". Stack Map Usage; ===============. The stack map support described in this document can be used to; precisely determine the location of values at a specific position in; the code. LLVM does not maintain any mapping between those values and; any higher-level entity. The runtime must be able to interpret the; stack map record given only the ID, offset, and the order of the; locations, records, and functions, which LLVM preserves. Note that this is quite different from the goal of debug information,; which is a best-effort attempt to track the location of named; variables at every instruction. An important motivation for this design is to allow a runtime to; commandeer a stack frame when execution reaches an instruction address; associated with a stack map. The runtime must be able to rebuild a; stack frame and resume program execution using the information; provided by the stack map. For example, execution may resume in an; interpreter or a recompiled version of the same function. This usage restricts LLVM optimization. Clearly, LLVM must not move; stores across a stack map. However, loads must also be handled; conservatively. If the load may trigger an exception, hoisting it; above a stack map could be invalid. For example, the runtime may; determine that a load is safe to execute without a type check given; the current state of the type system. If the type system changes while; some activation of the load's function exists on the stack, the load; becomes unsafe. The runtime can prevent subsequent execution of that; load by immediately patching any stack map location that lies between; the current call site and the load (typically, the runtime would; simply patch all stack map locations to invalidate the function). If; the compiler had hoisted the load above the stack map, then the; program could crash before the runtime could take back control. To enforce these semantics, stackmap and patchpoint intrinsics are;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/StackMaps.rst:17795,resume,resume,17795,interpreter/llvm-project/llvm/docs/StackMaps.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/StackMaps.rst,1,['resume'],['resume']
Usability,"/ create frame record; mov x1, #2 // set x1 to a constant indicating the type of failure; adrp x16, :got:__hwasan_tag_mismatch_v2 // call runtime function to save remaining registers and report error; ldr x16, [x16, :got_lo12:__hwasan_tag_mismatch_v2] // (load address from GOT to avoid potential register clobbers in delay load handler); br x16. Heap; ----. Tagging the heap memory/pointers is done by `malloc`.; This can be based on any malloc that forces all objects to be TG-aligned.; `free` tags the memory with a different tag. Stack; -----. Stack frames are instrumented by aligning all non-promotable allocas; by `TG` and tagging stack memory in function prologue and epilogue. Tags for different allocas in one function are **not** generated; independently; doing that in a function with `M` allocas would require; maintaining `M` live stack pointers, significantly increasing register; pressure. Instead we generate a single base tag value in the prologue,; and build the tag for alloca number `M` as `ReTag(BaseTag, M)`, where; ReTag can be as simple as exclusive-or with constant `M`. Stack instrumentation is expected to be a major source of overhead,; but could be optional. Globals; -------. Most globals in HWASAN instrumented code are tagged. This is accomplished; using the following mechanisms:. * The address of each global has a static tag associated with it. The first; defined global in a translation unit has a pseudorandom tag associated; with it, based on the hash of the file path. Subsequent global tags are; incremental from the previously-assigned tag. * The global's tag is added to its symbol address in the object file's symbol; table. This causes the global's address to be tagged when its address is; taken. * When the address of a global is taken directly (i.e. not via the GOT), a special; instruction sequence needs to be used to add the tag to the address,; because the tag would otherwise take the address outside of the small code; model (4GB on AArch64). No c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst:6060,simpl,simple,6060,interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst,1,['simpl'],['simple']
Usability,"//. Shrink: (setlt (loadi32 P), 0) -> (setlt (loadi8 Phi), 0). //===---------------------------------------------------------------------===//. Reassociate should turn things like:. int factorial(int X) {; return X*X*X*X*X*X*X*X;; }. into llvm.powi calls, allowing the code generator to produce balanced; multiplication trees. First, the intrinsic needs to be extended to support integers, and second the; code generator needs to be enhanced to lower these to multiplication trees. //===---------------------------------------------------------------------===//. Interesting? testcase for add/shift/mul reassoc:. int bar(int x, int y) {; return x*x*x+y+x*x*x*x*x*y*y*y*y;; }; int foo(int z, int n) {; return bar(z, n) + bar(2*z, 2*n);; }. This is blocked on not handling X*X*X -> powi(X, 3) (see note above). The issue; is that we end up getting t = 2*X s = t*t and don't turn this into 4*X*X,; which is the same number of multiplies and is canonical, because the 2*X has; multiple uses. Here's a simple example:. define i32 @test15(i32 %X1) {; %B = mul i32 %X1, 47 ; X1*47; %C = mul i32 %B, %B; ret i32 %C; }. //===---------------------------------------------------------------------===//. Reassociate should handle the example in GCC PR16157:. extern int a0, a1, a2, a3, a4; extern int b0, b1, b2, b3, b4; ; void f () { /* this can be optimized to four additions... */ ; b4 = a4 + a3 + a2 + a1 + a0; ; b3 = a3 + a2 + a1 + a0; ; b2 = a2 + a1 + a0; ; b1 = a1 + a0; ; } . This requires reassociating to forms of expressions that are already available,; something that reassoc doesn't think about yet. //===---------------------------------------------------------------------===//. These two functions should generate the same code on big-endian systems:. int g(int *j,int *l) { return memcmp(j,l,4); }; int h(int *j, int *l) { return *j - *l; }. this could be done in SelectionDAGISel.cpp, along with other special cases,; for 1,2,4,8 bytes. //===----------------------------------------------------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt:2281,simpl,simple,2281,interpreter/llvm-project/llvm/lib/Target/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt,1,['simpl'],['simple']
Usability,"//===----------------------------------------------------------------------===//; // Clang Static Analyzer; //===----------------------------------------------------------------------===//. = Library Structure =. The analyzer library has two layers: a (low-level) static analysis; engine (ExprEngine.cpp and friends), and some static checkers; (*Checker.cpp). The latter are built on top of the former via the; Checker and CheckerVisitor interfaces (Checker.h and; CheckerVisitor.h). The Checker interface is designed to be minimal; and simple for checker writers, and attempts to isolate them from much; of the gore of the internal analysis engine. = How It Works =. The analyzer is inspired by several foundational research papers ([1],; [2]). (FIXME: kremenek to add more links). In a nutshell, the analyzer is basically a source code simulator that; traces out possible paths of execution. The state of the program; (values of variables and expressions) is encapsulated by the state; (ProgramState). A location in the program is called a program point; (ProgramPoint), and the combination of state and program point is a; node in an exploded graph (ExplodedGraph). The term ""exploded"" comes; from exploding the control-flow edges in the control-flow graph (CFG). Conceptually the analyzer does a reachability analysis through the; ExplodedGraph. We start at a root node, which has the entry program; point and initial state, and then simulate transitions by analyzing; individual expressions. The analysis of an expression can cause the; state to change, resulting in a new node in the ExplodedGraph with an; updated program point and an updated state. A bug is found by hitting; a node that satisfies some ""bug condition"" (basically a violation of a; checking invariant). The analyzer traces out multiple paths by reasoning about branches and; then bifurcating the state: on the true branch the conditions of the; branch are assumed to be true and on the false branch the conditions; of the branc",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/README.txt:537,simpl,simple,537,interpreter/llvm-project/clang/lib/StaticAnalyzer/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/README.txt,1,['simpl'],['simple']
Usability,"//===----------------------------------------------------------------------===//; // ModuleMaker Sample project; //===----------------------------------------------------------------------===//. This project is an extremely simple example of using some simple pieces of the ; LLVM API. The actual executable generated by this project simply emits an ; LLVM bitcode file to standard output. It is designed to show some basic ; usage of LLVM APIs, and how to link to LLVM libraries.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ModuleMaker/README.txt:224,simpl,simple,224,interpreter/llvm-project/llvm/examples/ModuleMaker/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ModuleMaker/README.txt,3,['simpl'],"['simple', 'simply']"
Usability,"/64162>`_); - Fix a crash when calling a consteval function in an expression used as; the size of an array.; (`#65520 <https://github.com/llvm/llvm-project/issues/65520>`_). - Clang no longer tries to capture non-odr-used variables that appear; in the enclosing expression of a lambda expression with a noexcept specifier.; (`#67492 <https://github.com/llvm/llvm-project/issues/67492>`_). - Fix crash when fold expression was used in the initialization of default; argument. Fixes:; (`#67395 <https://github.com/llvm/llvm-project/issues/67395>`_). - Fixed a bug causing destructors of constant-evaluated structured bindings; initialized by array elements to be called in the wrong evaluation context. - Fix crash where ill-formed code was being treated as a deduction guide and; we now produce a diagnostic. Fixes:; (`#65522 <https://github.com/llvm/llvm-project/issues/65522>`_). - Fixed a bug where clang incorrectly considered implicitly generated deduction; guides from a non-templated constructor and a templated constructor as ambiguous,; rather than prefer the non-templated constructor as specified in; [standard.group]p3. - Fixed a crash caused by incorrect handling of dependence on variable templates; with non-type template parameters of reference type. Fixes:; (`#65153 <https://github.com/llvm/llvm-project/issues/65153>`_). - Clang now properly compares constraints on an out of line class template; declaration definition. Fixes:; (`#61763 <https://github.com/llvm/llvm-project/issues/61763>`_). - Fix a bug where implicit deduction guides are not correctly generated for nested template; classes. Fixes:; (`#46200 <https://github.com/llvm/llvm-project/issues/46200>`_); (`#57812 <https://github.com/llvm/llvm-project/issues/57812>`_). - Diagnose use of a variable-length array in a coroutine. The design of; coroutines is such that it is not possible to support VLA use. Fixes:; (`#65858 <https://github.com/llvm/llvm-project/issues/65858>`_). - Fix bug where we were overriding zero-",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:51422,guid,guides,51422,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst,1,['guid'],['guides']
Usability,"/; __stop_omp_offloading_entries /*EntriesEnd*/; }; };; static const __tgt_bin_desc BinDesc = {; sizeof(Images) / sizeof(Images[0]), /*NumDeviceImages*/; Images, /*DeviceImages*/; __start_omp_offloading_entries, /*HostEntriesBegin*/; __stop_omp_offloading_entries /*HostEntriesEnd*/; };. Global Constructor and Destructor; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The global constructor (``.omp_offloading.descriptor_reg()``) registers the; device images with the runtime by calling the ``__tgt_register_lib()`` runtime; function. The constructor is explicitly defined in ``.text.startup`` section and; is run once when the program starts. Similarly, the global destructor; (``.omp_offloading.descriptor_unreg()``) calls ``__tgt_unregister_lib()`` for; the destructor and is also defined in ``.text.startup`` section and run when the; program exits. Offloading Example; ------------------. This section contains a simple example of generating offloading code using; OpenMP offloading. We will use a simple ``ZAXPY`` BLAS routine. .. code-block:: c++. #include <complex>. using complex = std::complex<double>;. void zaxpy(complex *X, complex *Y, complex D, std::size_t N) {; #pragma omp target teams distribute parallel for; for (std::size_t i = 0; i < N; ++i); Y[i] = D * X[i] + Y[i];; }. int main() {; const std::size_t N = 1024;; complex X[N], Y[N], D;; #pragma omp target data map(to:X[0 : N]) map(tofrom:Y[0 : N]); zaxpy(X, Y, D, N);; }. This code is compiled using the following Clang flags. .. code-block:: console. $ clang++ -fopenmp -fopenmp-targets=nvptx64 -O3 zaxpy.cpp -c. The output section in the object file can be seen using the ``readelf`` utility.; The ``.llvm.offloading`` section has the ``SHF_EXCLUDE`` flag so it will be; removed from the final executable or shared library by the linker. .. code-block:: text. $ llvm-readelf -WS zaxpy.o; Section Headers:; [Nr] Name Type Address Off Size ES Flg Lk Inf Al; [11] omp_offloading_entries PROGBITS 0000000000000000 0001f0 000040 00 A 0 0 1;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OffloadingDesign.rst:21838,simpl,simple,21838,interpreter/llvm-project/clang/docs/OffloadingDesign.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OffloadingDesign.rst,1,['simpl'],['simple']
Usability,"/F"").; - Allow reading of older version of TTreePerfStats (ROOT-8520); - In `TTree::OptimizeBaskets()` do not call GetBasket(0) to avoid disc reads; - It is now possible to define the precision of the default histogram created; by `TTree::Draw`. Three new parameters are available in `$ROOTSYS/etcsystem.rootrc`; ```{.cpp}; Hist.Precision.1D: float; Hist.Precision.2D: float; Hist.Precision.3D: float; ```; the default values are `float`. They can be set to `double`.; - Fix ROOT-8742: TTree::SetBranchAddress could not be invoked safely even when dealing with the same tree obtained from the same file opened in different threads.; - TTree::Branch() now complains if a ""name[size]/F"" branch specification is passed wrongly (e.g. as ""name/F[size]""). ### TDataFrame; - Creation of the TDataFrame class. The TDataFrame allows to interact with data; stored in columnar format in a functional and intuitive way in order to perform; data analysis. Parallelism is accessible simply by activating implicit; multi-threading with the ROOT::EnableImplicitMT() function.; In a nutshell, the functionality provided is:; - Create and fill histograms with one single method invocation; - Express filtering of entries with strings, lambdas or functions; - Easy creation of efficiencies of cut-flows; - Possibility to run on ranges of entries; - Creating columns not present in the original dataset; - Chain multiple actions to be executed on the same event loop; - Creation of events on-the-fly (e.g. via Pythia or user-define generator functors), with no need for an input TTree; - Snapshot on a rootfile the dataset after cuts and after augmentation with columns created by the user; - Run analyses expressed as chains of actions in parallel in a transparent way for the user; See [the online documentation](https://root.cern.ch/doc/master/classROOT_1_1Experimental_1_1TDF_1_1TDataFrame.html) for more details. ## 2D Graphics Libraries; - If one used ""col2"" or ""colz2"", the value of `TH1::fMaximum` got modified.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v610/index.md:6310,simpl,simply,6310,README/ReleaseNotes/v610/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v610/index.md,1,['simpl'],['simply']
Usability,/HTTPClientTests.cpp; llvm/unittests/Demangle/DemangleTest.cpp; llvm/unittests/Demangle/DLangDemangleTest.cpp; llvm/unittests/Demangle/OutputBufferTest.cpp; llvm/unittests/Demangle/RustDemangleTest.cpp; llvm/unittests/Demangle/StringViewTest.cpp; llvm/unittests/ExecutionEngine/JITLink/LinkGraphTests.cpp; llvm/unittests/ExecutionEngine/Orc/EPCGenericJITLinkMemoryManagerTest.cpp; llvm/unittests/ExecutionEngine/Orc/EPCGenericMemoryAccessTest.cpp; llvm/unittests/ExecutionEngine/Orc/ExecutionSessionWrapperFunctionCallsTest.cpp; llvm/unittests/ExecutionEngine/Orc/ExecutorAddressTest.cpp; llvm/unittests/ExecutionEngine/Orc/JITTargetMachineBuilderTest.cpp; llvm/unittests/ExecutionEngine/Orc/LazyCallThroughAndReexportsTest.cpp; llvm/unittests/ExecutionEngine/Orc/LookupAndRecordAddrsTest.cpp; llvm/unittests/ExecutionEngine/Orc/ObjectLinkingLayerTest.cpp; llvm/unittests/ExecutionEngine/Orc/OrcCAPITest.cpp; llvm/unittests/ExecutionEngine/Orc/ResourceTrackerTest.cpp; llvm/unittests/ExecutionEngine/Orc/SimpleExecutorMemoryManagerTest.cpp; llvm/unittests/ExecutionEngine/Orc/SimplePackedSerializationTest.cpp; llvm/unittests/ExecutionEngine/Orc/TaskDispatchTest.cpp; llvm/unittests/ExecutionEngine/Orc/ThreadSafeModuleTest.cpp; llvm/unittests/Frontend/OpenACCTest.cpp; llvm/unittests/Frontend/OpenMPContextTest.cpp; llvm/unittests/Frontend/OpenMPParsingTest.cpp; llvm/unittests/InterfaceStub/ELFYAMLTest.cpp; llvm/unittests/IR/DemandedBitsTest.cpp; llvm/unittests/IR/ManglerTest.cpp; llvm/unittests/IR/ModuleTest.cpp; llvm/unittests/IR/TimePassesTest.cpp; llvm/unittests/IR/UseTest.cpp; llvm/unittests/IR/VectorTypesTest.cpp; llvm/unittests/MC/Disassembler.cpp; llvm/unittests/MC/DwarfLineTableHeaders.cpp; llvm/unittests/MC/MCInstPrinter.cpp; llvm/unittests/MC/TargetRegistry.cpp; llvm/unittests/MC/AMDGPU/DwarfRegMappings.cpp; llvm/unittests/MC/SystemZ/SystemZAsmLexerTest.cpp; llvm/unittests/ObjCopy/ObjCopyTest.cpp; llvm/unittests/Object/ArchiveTest.cpp; llvm/unittests/Object/ELFObjectFileTest.,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt:346039,Simpl,SimpleExecutorMemoryManagerTest,346039,interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,1,['Simpl'],['SimpleExecutorMemoryManagerTest']
Usability,/JITTargetMachineBuilder.h; llvm/include/llvm/ExecutionEngine/Orc/Layer.h; llvm/include/llvm/ExecutionEngine/Orc/LazyReexports.h; llvm/include/llvm/ExecutionEngine/Orc/LookupAndRecordAddrs.h; llvm/include/llvm/ExecutionEngine/Orc/MachOPlatform.h; llvm/include/llvm/ExecutionEngine/Orc/Mangling.h; llvm/include/llvm/ExecutionEngine/Orc/ObjectFileInterface.h; llvm/include/llvm/ExecutionEngine/Orc/ObjectLinkingLayer.h; llvm/include/llvm/ExecutionEngine/Orc/ObjectTransformLayer.h; llvm/include/llvm/ExecutionEngine/Orc/OrcABISupport.h; llvm/include/llvm/ExecutionEngine/Orc/RTDyldObjectLinkingLayer.h; llvm/include/llvm/ExecutionEngine/Orc/SpeculateAnalyses.h; llvm/include/llvm/ExecutionEngine/Orc/Speculation.h; llvm/include/llvm/ExecutionEngine/Orc/ThreadSafeModule.h; llvm/include/llvm/ExecutionEngine/Orc/Shared/ExecutorAddress.h; llvm/include/llvm/ExecutionEngine/Orc/Shared/OrcRTBridge.h; llvm/include/llvm/ExecutionEngine/Orc/Shared/SimplePackedSerialization.h; llvm/include/llvm/ExecutionEngine/Orc/Shared/SimpleRemoteEPCUtils.h; llvm/include/llvm/ExecutionEngine/Orc/TargetProcess/ExecutorBootstrapService.h; llvm/include/llvm/ExecutionEngine/Orc/TargetProcess/JITLoaderGDB.h; llvm/include/llvm/ExecutionEngine/Orc/TargetProcess/RegisterEHFrames.h; llvm/include/llvm/ExecutionEngine/Orc/TargetProcess/SimpleExecutorDylibManager.h; llvm/include/llvm/ExecutionEngine/Orc/TargetProcess/SimpleExecutorMemoryManager.h; llvm/include/llvm/ExecutionEngine/Orc/TargetProcess/SimpleRemoteEPCServer.h; llvm/include/llvm/ExecutionEngine/Orc/TargetProcess/TargetExecutionUtils.h; llvm/include/llvm/FileCheck/FileCheck.h; llvm/include/llvm/Frontend/OpenMP/OMPAssume.h; llvm/include/llvm/Frontend/OpenMP/OMPConstants.h; llvm/include/llvm/Frontend/OpenMP/OMPContext.h; llvm/include/llvm/Frontend/OpenMP/OMPGridValues.h; llvm/include/llvm/InterfaceStub/ELFObjHandler.h; llvm/include/llvm/InterfaceStub/IFSHandler.h; llvm/include/llvm/InterfaceStub/IFSStub.h; llvm/include/llvm/IR/Assumptions.h; llvm/include/l,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt:254064,Simpl,SimpleRemoteEPCUtils,254064,interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,1,['Simpl'],['SimpleRemoteEPCUtils']
Usability,/Orc/EPCDynamicLibrarySearchGenerator.cpp; llvm/lib/ExecutionEngine/Orc/EPCEHFrameRegistrar.cpp; llvm/lib/ExecutionEngine/Orc/EPCGenericDylibManager.cpp; llvm/lib/ExecutionEngine/Orc/EPCGenericRTDyldMemoryManager.cpp; llvm/lib/ExecutionEngine/Orc/EPCIndirectionUtils.cpp; llvm/lib/ExecutionEngine/Orc/IRCompileLayer.cpp; llvm/lib/ExecutionEngine/Orc/IRTransformLayer.cpp; llvm/lib/ExecutionEngine/Orc/Layer.cpp; llvm/lib/ExecutionEngine/Orc/LazyReexports.cpp; llvm/lib/ExecutionEngine/Orc/LookupAndRecordAddrs.cpp; llvm/lib/ExecutionEngine/Orc/Mangling.cpp; llvm/lib/ExecutionEngine/Orc/ObjectFileInterface.cpp; llvm/lib/ExecutionEngine/Orc/ObjectTransformLayer.cpp; llvm/lib/ExecutionEngine/Orc/SpeculateAnalyses.cpp; llvm/lib/ExecutionEngine/Orc/Speculation.cpp; llvm/lib/ExecutionEngine/Orc/TaskDispatch.cpp; llvm/lib/ExecutionEngine/Orc/Shared/AllocationActions.cpp; llvm/lib/ExecutionEngine/Orc/Shared/OrcError.cpp; llvm/lib/ExecutionEngine/Orc/Shared/OrcRTBridge.cpp; llvm/lib/ExecutionEngine/Orc/Shared/SimpleRemoteEPCUtils.cpp; llvm/lib/ExecutionEngine/Orc/TargetProcess/JITLoaderGDB.cpp; llvm/lib/ExecutionEngine/Orc/TargetProcess/OrcRTBootstrap.cpp; llvm/lib/ExecutionEngine/Orc/TargetProcess/OrcRTBootstrap.h; llvm/lib/ExecutionEngine/Orc/TargetProcess/RegisterEHFrames.cpp; llvm/lib/ExecutionEngine/Orc/TargetProcess/SimpleExecutorDylibManager.cpp; llvm/lib/ExecutionEngine/Orc/TargetProcess/SimpleExecutorMemoryManager.cpp; llvm/lib/ExecutionEngine/Orc/TargetProcess/TargetExecutionUtils.cpp; llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldCOFF.h; llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldCOFFAArch64.h; llvm/lib/FileCheck/FileCheckImpl.h; llvm/lib/Frontend/OpenACC/ACC.cpp; llvm/lib/Frontend/OpenMP/OMP.cpp; llvm/lib/Frontend/OpenMP/OMPContext.cpp; llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp; llvm/lib/FuzzMutate/OpDescriptor.cpp; llvm/lib/FuzzMutate/RandomIRBuilder.cpp; llvm/lib/InterfaceStub/ELFObjHandler.cpp; llvm/lib/InterfaceStub/IFSHandler.cpp; llvm/lib/Interface,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt:288073,Simpl,SimpleRemoteEPCUtils,288073,interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,1,['Simpl'],['SimpleRemoteEPCUtils']
Usability,"/WLCG-AuthZ-WG/bearer-token-discovery/blob/master/specification.md). Short overview:. 1. If the `BEARER_TOKEN` environment variable is set, then the value is taken to be the token contents.; 2. If the `BEARER_TOKEN_FILE` environment variable is set, then its value is interpreted as a filename. The contents of the specified file are taken to be the token contents.; 3. If the `XDG_RUNTIME_DIR` environment variable is set, then take the token from the contents of `$XDG_RUNTIME_DIR/bt_u$ID`(this additional location is intended to provide improved security for shared login environments as `$XDG_RUNTIME_DIR` is defined to be user-specific as opposed to a system-wide directory.).; 4. Otherwise, take the token from `/tmp/bt_u$ID`. ## GUI Libraries. ### RBrowser improvements. - central factory methods to handle browsing, editing and drawing of different classes; - simple possibility to extend RBrowser on user-defined classes; - support of web-based geometry viewer; - better support of TTree drawing; - server-side handling of code editor and image viewer widgets; - rbrowser content is fully recovered when web-browser is reloaded; - load of widgets code only when really required (shorter startup time for RBrowser). ## Montecarlo Libraries. ## PROOF Libraries. ## Language Bindings. ## JavaScript ROOT. ### Major JSROOT update to version 6. - update all used libraries `d3.js`, `three.js`, `MathJax.js`, openui5; - change to Promise based interface for all async methods, remove call-back arguments; - change scripts names, core scripts name now `JSRoot.core.js`; - unify function/methods naming conventions, many changes in method names; - provide central code loader via `JSROOT.require`, supporting 4 different loading engines; - many nice features and many bug fixes; see JSROOT v6 release notes. ## Tutorials. ## Class Reference Guide. ## Build, Configuration and Testing Infrastructure. - a new cmake variable, `CMAKE_INSTALL_PYTHONDIR`, has been added: it allows customization of the i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v624/index.md:26910,simpl,simple,26910,README/ReleaseNotes/v624/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v624/index.md,1,['simpl'],['simple']
Usability,"/github.com/root-project/root/issues/15197)] - RBDT does not support xgboost inference; * [[#15156](https://github.com/root-project/root/issues/15156)] - Segfault in TMVA::Experimental::SOFIE::RModel::Streamer; * [[#15139](https://github.com/root-project/root/issues/15139)] - cmake option -Dall=YES breaks the cmake; * [[#15118](https://github.com/root-project/root/issues/15118)] - jsoninterface does not build if provided with RapidYAML; * [[#15108](https://github.com/root-project/root/issues/15108)] - Turn off clang-format for Linkdef files; * [[#15090](https://github.com/root-project/root/issues/15090)] - TClass::GetClassInfo() is not thread safe; * [[#15077](https://github.com/root-project/root/issues/15077)] - Passing different floating point types to `RVec` utility functions; * [[#15048](https://github.com/root-project/root/issues/15048)] - [ntuple] Handling of virtual inheritance broken; * [[#15040](https://github.com/root-project/root/issues/15040)] - [RDataFrame] Inaccurate example of progress bar from documentation; * [[#15028](https://github.com/root-project/root/issues/15028)] - [RDataFrame] Unable to cacheread remote file; * [[#15027](https://github.com/root-project/root/issues/15027)] - spurrious cmake message about AfterImage with -Dminimal=ON; * [[#14981](https://github.com/root-project/root/issues/14981)] - RVecs leak memory with np.asarray in pyROOT; * [[#14964](https://github.com/root-project/root/issues/14964)] - ROOT-HEAD fails with ""cling interactive line includer >>>: fatal error: module file '[snip]/Vc.pcm' not found: module file not found""; * [[#14958](https://github.com/root-project/root/issues/14958)] - ROOT_HEAD failed with error message: Fail to detect cryptographic random generator; * [[#14921](https://github.com/root-project/root/issues/14921)] - ROOT Fails to build macOS 14.4 arm64 Xcode 15.3; * [[#14914](https://github.com/root-project/root/issues/14914)] - VecOps::Take with default argument doesn't check correctly the out of boundary ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md:27150,progress bar,progress bar,27150,README/ReleaseNotes/v632/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md,1,['progress bar'],['progress bar']
Usability,"/sft.cern.ch/lcg/external/PoD/3.12/x86_64-slc5-gcc41-python24-boost1.53; ** Server is started. Use ""pod-info -sd"" to check the status of the server. ### Request and wait for workers. Now the server is started but you don't have any worker available. To; request for `<n>` workers, do:. vafreq <n>. To check how many workers became available for use:. pod-info -n. To continuously update the check (`Ctrl-C` to terminate):. vafcount. Example of output:. Updating every 5 seconds. Press Ctrl-C to stop monitoring...; [20130411-172235] 0; [20130411-172240] 0; [20130411-172245] 12; [20130411-172250] 12; ... To execute a command after a certain number of workers is available (in; the example we wait for 5 workers then start ROOT):. vafwait 5 && root -l. > Workers take some time before becoming available. Also, it is possible; > that not all the requested workers will be satisfied. ### Start ROOT and use PROOF. When you are satisfied with the available number of active workers, you; may start your PROOF analysis. Start ROOT, and from its prompt connect; to PROOF like this:. root [0] TProof::Open(""pod://"");. Example of output:. Starting master: opening connection ...; Starting master: OK; Opening connections to workers: OK (12 workers); Setting up worker servers: OK (12 workers); PROOF set to parallel mode (12 workers). ### Stop or restart your PoD cluster. At the end of your session, remember to free the workers by stopping; your PoD server:. vafctl --stop. > PoD will stop the PROOF master and the workers after detecting they've; > been idle for a certain amount of time anyway, but it is a good habit; > to stop it for yourself when you're finished using it, so that you are; > immediately freeing resources and let them be available for other; > users. In case of a major PROOF failure (i.e., crash), you can simply restart; your personal PROOF cluster by running:. vafctl --start. PoD will stop and restart the PROOF master. You'll need to request the; workers again at this point.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/UsingVirtualAnalysisFacility.md:12587,simpl,simply,12587,proof/doc/confman/UsingVirtualAnalysisFacility.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/UsingVirtualAnalysisFacility.md,1,['simpl'],['simply']
Usability,"0)"");; ```. The operator ""`lp(x,y,z)`"" sets the light position. In Light and; LightHeight display modes groups the color palette is calculated; according to the fictive light source position in 3-d space. Using; this function one can change the source's position and thus achieve; various graphical effects. This function does not apply for Simple and; Height display modes groups. Default is: `lp(1000,1000,100)` . The operator ""`s(shading,shadow)`"" allows to set the shading. The; surface picture is composed of triangles. The edges of the neighboring; triangles can be smoothed (shaded). The shadow can be painted as well.; The function does not apply on Simple display modes group. The; possible values for shading are:. - 0 = Not Shaded,; - 1 = Shaded. The possible values for shadow are:. - 0 = Shadows are not painted,; - 1 = Shadows are painted. Default values: `s(1,0)` . The operator ""`b(bezier)`"" sets the Bezier smoothing. For Simple; display modes group and for Grid, LinesX and LinesY display modes one; can smooth data using Bezier smoothing algorithm. The function does; not apply on other display modes groups and display modes. Possible; values are: 0 = No bezier smoothing, 1 = Bezier smoothing. Default; value is: `b(0)`. The operator ""`cw(width)`"" sets the contour width. This function; applies only on for the Contours display mode. One can change the; width between horizontal slices and thus their density. Default value:; `cw(50)` . The operator ""`lhw(weight)`"" sets the light height weight. For; LightHeight display modes group one can change the weight between both; shading algorithms. The function does not apply on other display modes; groups. Default value is `lhw(0.5)` . The operator ""`cm(enable,color,width,height,style)`"" allows to; draw a marker on each node. In addition to the surface drawn using any; above given algorithm one can display channel marks. One can control; the color as well as the width, height (in pixels) and the style of; the marks. The paramet",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:40309,Simpl,Simple,40309,documentation/users-guide/Histograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md,1,['Simpl'],['Simple']
Usability,"0, %entry ], [ %indvar.next, %bb2 ]; 	%1 = load i32* %cond, align 4; 	%2 = icmp eq i32 %1, 0; 	br i1 %2, label %bb2, label %bb1. bb1:		; preds = %bb; 	%3 = xor i32 %.rle, 234	; 	store i32 %3, i32* %res, align 4; 	br label %bb2. bb2:		; preds = %bb, %bb1; 	%.rle6 = phi i32 [ %3, %bb1 ], [ %.rle, %bb ]	; 	%indvar.next = add i32 %i.05, 1	; 	%exitcond = icmp eq i32 %indvar.next, %n; 	br i1 %exitcond, label %return, label %bb. DSE should sink partially dead stores to get the store out of the loop. Here's another partial dead case:; http://gcc.gnu.org/bugzilla/show_bug.cgi?id=12395. //===---------------------------------------------------------------------===//. Scalar PRE hoists the mul in the common block up to the else:. int test (int a, int b, int c, int g) {; int d, e;; if (a); d = b * c;; else; d = b - c;; e = b * c + g;; return d + e;; }. It would be better to do the mul once to reduce codesize above the if.; This is GCC PR38204. //===---------------------------------------------------------------------===//; This simple function from 179.art:. int winner, numf2s;; struct { double y; int reset; } *Y;. void find_match() {; int i;; winner = 0;; for (i=0;i<numf2s;i++); if (Y[i].y > Y[winner].y); winner =i;; }. Compiles into (with clang TBAA):. for.body: ; preds = %for.inc, %bb.nph; %indvar = phi i64 [ 0, %bb.nph ], [ %indvar.next, %for.inc ]; %i.01718 = phi i32 [ 0, %bb.nph ], [ %i.01719, %for.inc ]; %tmp4 = getelementptr inbounds %struct.anon* %tmp3, i64 %indvar, i32 0; %tmp5 = load double* %tmp4, align 8, !tbaa !4; %idxprom7 = sext i32 %i.01718 to i64; %tmp10 = getelementptr inbounds %struct.anon* %tmp3, i64 %idxprom7, i32 0; %tmp11 = load double* %tmp10, align 8, !tbaa !4; %cmp12 = fcmp ogt double %tmp5, %tmp11; br i1 %cmp12, label %if.then, label %for.inc. if.then: ; preds = %for.body; %i.017 = trunc i64 %indvar to i32; br label %for.inc. for.inc: ; preds = %for.body, %if.then; %i.01719 = phi i32 [ %i.01718, %for.body ], [ %i.017, %if.then ]; %indvar.next = add i6",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt:29796,simpl,simple,29796,interpreter/llvm-project/llvm/lib/Target/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt,1,['simpl'],['simple']
Usability,"0,0);; root[] TGeoMedium *med = new TGeoMedium(""Vacuum"",1,mat);; ```. We can finally make our volume having a box shape. Note that the world; volume does not need to be a box - it can be any other shape. Generally,; boxes and tubes are the most recommendable shapes for this purpose due; to their fast navigation algorithms. ``` {.cpp}; root[] TGeoVolume *top=gGeoManager->MakeBox(""Top"",med,10.,10.,10.);; ```. The default units are in centimeters. Now we want to make this volume; our world. We have to do this operation **before** closing the geometry. ``` {.cpp}; root[] gGeoManager->SetTopVolume(top);; ```. This should be enough, but it is not since always after defining some; geometry hierarchy, **`TGeo`** needs to build some optimization; structures and perform some checks. Note the messages posted after the; statement is executed. We will describe the corresponding operations; later. ``` {.cpp}; root[] gGeoManager->CloseGeometry();; ```. Now we are really done with geometry building stage, but we would like; to see our simple world:. ``` {.cpp}; root[] top->SetLineColor(kMagenta);; root[] gGeoManager->SetTopVisible(); // the TOP is invisible; root[] top->Draw();; ```. ### Example 2: A Geometrical Hierarchy Look and Feel. Before going further, let us get a look and feel of interacting with the; modeller. For this, we will use one of the examples illustrating the; geometry package. To get an idea on the geometry structure created in; this example, just look at the link:; <http://root.cern.ch/root/html/tutorials/geom/rootgeom.C.html>. You will; notice that this is a bit more complex that just creating the ""world""; since several other volumes are created and put together in a hierarchy.; The purpose here is just to learn how to interact with a geometry that; is already built, but just few hints on the building steps in this; example might be useful. The geometry here represents the word ROOT that; is replicated in some symmetric manner. You might for instance ask some; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:4067,simpl,simple,4067,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['simpl'],['simple']
Usability,"000] {File} 'pr-46466-codeview-clang.o' -> COFF-x86-64. [001] {CompileUnit} 'pr-46466.cpp'; [002] 1 {Struct} 'Struct'; [003] 2 {Union} 'Union'; [004] 3 {Enumeration} 'NestedEnum' -> 'int'; [005] {Enumerator} 'BLUE' = '0x1'; [005] {Enumerator} 'RED' = '0x0'. Logical View:; [000] {File} 'pr-46466-codeview-msvc.o' -> COFF-i386. [001] {CompileUnit} 'pr-46466.cpp'; [002] 1 {Struct} 'Struct'; [003] 2 {Union} 'Union'; [004] 3 {Enumeration} 'NestedEnum' -> 'int'; [005] {Enumerator} 'BLUE' = '0x1'; [005] {Enumerator} 'RED' = '0x0'. Logical View:; [000] {File} 'pr-46466-dwarf-clang.o' -> elf64-x86-64. [001] {CompileUnit} 'pr-46466.cpp'. Logical View:; [000] {File} 'pr-46466-dwarf-gcc.o' -> elf64-x86-64. [001] {CompileUnit} 'pr-46466.cpp'; [002] 1 {Struct} 'Struct'; [003] 2 {Union} 'Union'; [004] 3 {Enumeration} 'NestedEnum' -> 'unsigned int'; [005] {Enumerator} 'BLUE' = '0x1'; [005] {Enumerator} 'RED' = '0x0'. Using the :program:`llvm-debuginfo-analyzer` selection facilities, we; can produce a simple tabular output including a summary for the logical; types that are **Enumerator**. The logical view is sorted by the types; name. .. code-block:: none. llvm-debuginfo-analyzer --attribute=format,level; --output-sort=name; --select-types=Enumerator; --print=types,summary; pr-46466-*.o. .. code-block:: none. Logical View:; [000] {File} 'pr-46466-codeview-clang.o' -> COFF-x86-64. [001] {CompileUnit} 'pr-46466.cpp'; [005] {Enumerator} 'BLUE' = '0x1'; [005] {Enumerator} 'RED' = '0x0'. -----------------------------; Element Total Found; -----------------------------; Scopes 5 0; Symbols 2 0; Types 6 2; Lines 0 0; -----------------------------; Total 13 2. Logical View:; [000] {File} 'pr-46466-codeview-msvc.o' -> COFF-i386. [001] {CompileUnit} 'pr-46466.cpp'; [005] {Enumerator} 'BLUE' = '0x1'; [005] {Enumerator} 'RED' = '0x0'. -----------------------------; Element Total Found; -----------------------------; Scopes 5 0; Symbols 2 0; Types 7 2; Lines 0 0; -----------------------------; To",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst:46584,simpl,simple,46584,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst,1,['simpl'],['simple']
Usability,"081287804; i=11, fSumw2 type= 62, offset=528, len=1, method=1081287924; i=12, fOption type= 65, offset=540, len=1, method=1081288044; i=13, fFunctions type= 63, offset=548, len=1, method=1081288164; ```. ### Optimized StreamerInfo. The entries starting with ""`i = 0`"" is the optimized format of the; `StreamerInfo`. Consecutive data members of the same simple type and; size are collapsed and read at once into an array for performance; optimization. ``` {.cpp}; i= 0, TNamed type= 67, offset= 0, len=1, method=0; i= 1, TAttLine type= 0, offset= 28, len=1, method=142484480; i= 2, TAttFill type= 0, offset= 40, len=1, method=142496992; i= 3, TAttMarker type= 0, offset= 48, len=1, method=142509704; ```. For example, the five data members beginning with `fEnties `and the; three data members beginning with `fMaximum`, are put into an array; called `fEntries` (`i = 9`) with the length 8. ``` {.cpp}; i= 9, fEntries type= 28, offset=452, len=8, method=0; ```. Only simple type data members are combined, object data members are not; combined. For example the three axis data members remain separate. The; ""method"" is a handle to the method that reads the object. ### Automatic Schema Evolution. When a class is defined in ROOT, it must include the `ClassDef` macro as; the last line in the header file inside the class definition. The syntax; is:. ``` {.cpp}; ClassDef(<ClassName>,<VersionNumber>); ```. The version number identifies this particular version of the class. When; a class has version 0 it is not stored in a root file but its base; class(es) is(are). The reason can be that this class has no data members; worth saving or all real info is in the base classes. The version number; is written to the file in the `Streamer` by the call; `TBuffer::WriteVersion`. You, as the designer of the class, do not need; to do any manual modification in the `Streamer`. ROOT schema evolution; mechanism is automatic and handled by the `StreamerInfo`. ### Manual Data Model Evolution Capabilities. The ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:75581,simpl,simple,75581,documentation/users-guide/InputOutput.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md,1,['simpl'],['simple']
Usability,"1(1)<<std::endl;. ////////////////////////////////////////////////////////////; //creating a MyFunctor's object and passing object to R's //; //environment, the status should be true because is not //; //using the default function //; ////////////////////////////////////////////////////////////; MyFunctor functor;; functor.setFunction(TMath::Erf);; r[""functor""]<<functor;; //printing the status that should be true; r<<""print(functor$getStatus())"";; r<<""print(sprintf('value in R = %f',functor$doEval( 1 )))"";; std::cout<<""value in ROOT = ""<<TMath::Erf(1)<<std::endl;; }; ~~~. ## Simple fitting in R and plot in ROOT; The next example creates an exponential fit.; The idea is to create a set of numbers x,y with noise from ROOT,; pass them to R and fit the data to `x^3`,; get the fitted coefficient(power) and plot the data,; the known function and the fitted function using ROOT's classes. ~~~{.cxx}; #include<TRInterface.h>; #include<TRandom.h>. TCanvas *SimpleFitting(){; TCanvas *c1 = new TCanvas(""c1"",""Curve Fitting"",700,500);; c1->SetGrid();. // draw a frame to define the range; TMultiGraph *mg = new TMultiGraph();. // create the first graph (points with gaussian noise); const Int_t n = 24;; Double_t x1[n] ;; Double_t y1[n] ;; //Generate the points along a X^3 with noise; TRandom rg;; rg.SetSeed(520);; for (Int_t i = 0; i < n; i++) {; x1[i] = rg.Uniform(0, 1);; y1[i] = TMath::Power(x1[i], 3) + rg.Gaus() * 0.06;; }. TGraph *gr1 = new TGraph(n,x1,y1);; gr1->SetMarkerColor(kBlue);; gr1->SetMarkerStyle(8);; gr1->SetMarkerSize(1);; mg->Add(gr1);. // create the second graph; TF1 *f_known=new TF1(""f_known"",""pow(x,3)"",0,1);; TGraph *gr2 = new TGraph(f_known);; gr2->SetMarkerColor(kRed);; gr2->SetMarkerStyle(8);; gr2->SetMarkerSize(1);; mg->Add(gr2);; //passing data to Rfot fitting; ROOT::R::TRInterface &r=ROOT::R::TRInterface::Instance();; r[""x""]<<TVectorD(n, x1);; r[""y""]<<TVectorD(n, y1);; //creating a R data frame; r<<""ds<-data.frame(x=x,y=y)"";; //fitting x and y to X^power using",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/r/doc/users-guide/ROOTR_Users_Guide.md:14857,Simpl,SimpleFitting,14857,bindings/r/doc/users-guide/ROOTR_Users_Guide.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/r/doc/users-guide/ROOTR_Users_Guide.md,1,['Simpl'],['SimpleFitting']
Usability,"10-6). If we multiply the number of tracks by 7 s,; (1,000,000,000 \* 7 \* 10-6) we calculate that the time allocating and; freeing memory is about 2 hours. This is the chunk of time saved when a; **`TClonesArray`** is used rather than a **`TObjArray`**. If you do not; want to wait 2 hours for your tracks (or equivalent objects), be sure to; use a **`TClonesArray`** for same-class objects arrays. Branches with; **`TClonesArrays`** use the same method (`TTree::Branch`) as any other; object described above. If splitting is specified the objects in the; **`TClonesArray`** are split, not the **`TClonesArray`** itself. ### Identical Branch Names. When a top-level object (say `event`), has two data members of the same; class the sub branches end up with identical names. To distinguish the; sub branch we must associate them with the master branch by including a; ""`.`"" (a dot) at the end of the master branch name. This will force the; name of the sub branch to be `master.sub` branch instead of simply `sub`; branch. For example, a tree has two branches `Trigger` and; `MuonTrigger`, each containing an object of the same class (`Trigger`).; To identify uniquely the sub branches we add the dot:. ``` {.cpp}; tree->Branch(""Trigger."",""Trigger"",&b1,8000,1);; tree->Branch(""MuonTrigger."",""Trigger"",&b2,8000,1);; ```. If `Trigger` has three members, `T1`, `T2`, `T3`, the two instructions; above will generate sub branches called: `Trigger.T1`, `Trigger.T2`,; `Trigger.T3`, `MuonTrigger.T1`, `MuonTrigger.T2`, and` MuonTrigger.T3`. ## Adding a Branch with a Folder. Use the syntax below to add a branch from a folder:. ``` {.cpp}; tree->Branch(""/aFolder"");; ```. This method creates one branch for each element in the folder. The; method returns the total number of branches created. ## Adding a Branch with a Collection. This `Branch` method creates one branch for each element in the; collection. ``` {.cpp}; tree->Branch(*aCollection, 8000, 99);; // Int_t TTree::Branch(TCollection *list, Int_t ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:30693,simpl,simply,30693,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['simpl'],['simply']
Usability,"100000; ```; Depending on the algorithm, some of the control parameters might have no effect. #### `ROOT::Math::AdaptiveIntegratorMultiDim`. This class implements an adaptive quadrature integration method for multi dimensional functions. It is described in this paper; *Genz, A.A. Malik, An adaptive algorithm for numerical integration over an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302*.; It is part of the *MathCore* library.; The user can control the relative and absolute tolerance and the maximum allowed number of function evaluation. #### `ROOT::Math::GSLMCIntegrator`. It is a class for performing numerical integration of a multidimensional function. It uses the numerical integration algorithms of GSL, which reimplements the algorithms used; in the QUADPACK, a numerical integration package written in Fortran. Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges.; For a detail description of the GSL methods visit the GSL users guide.; Specific configuration options (documented in the GSL user guide) for the `ROOT::Math::GSLMCIntegration` can be set directly in the class, or when using it via the `ROOT::Math::IntegratorMultiDim`; interface, can be defined using the `ROOT::Math::IntegratorMultiDimOptions`. ## Function Derivation. There are in ROOT only two classes to perform numerical derivation. One of them is in the MathCore library while the other is in the MathMore wrapping an integration function from the GSL library.; * RichardsonDerivator: Implements the Richardson method for numerical integration. It can calculate up to the third derivative of a function.; * GSLDerivator of *MathMore* based on GSL. ## Numerical Minimization. The algorithms provided by ROOT for numerical integration are implemented following the hierarchy shown in the next image. The left branch of classes are used for one dimensional minimization, while; the right one is used for multidimensional minimizat",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:62072,guid,guide,62072,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['guid'],['guide']
Usability,"290a4df218e51e1ceec1106fe317b0ebc76938d9273592053f38204e%40group.calendar.google.com/public/basic.ics>`__; `gcal <https://calendar.google.com/calendar/embed?src=48c4ad60290a4df218e51e1ceec1106fe317b0ebc76938d9273592053f38204e%40group.calendar.google.com>`__; - `Google meet <https://meet.google.com/cbz-grrp-obs>`__; - English, French; * - Phoebe Wang (she/her); - X86 backend, General questions to X86, women in compilers.; - Monthly, 3rd Wednesday of the month at 8:30am Beijing time, for 30 minutes.; - `MS Teams <https://teams.microsoft.com/l/meetup-join/19%3ameeting_NWQ0MjU0NjYtZjUyMi00YTU3LThmM2EtY2Y2YTE4NGM3NmFi%40thread.v2/0?context=%7b%22Tid%22%3a%2246c98d88-e344-4ed4-8496-4ed7712e255d%22%2c%22Oid%22%3a%227b309d9c-a9bb-44c8-a940-ab97eef42d4d%22%7d>`__; - English, Chinese; * - Amara Emerson; - GlobalISel questions.; - Monthly, 4th Wednesday of the month at 9:30am PT, for 30 minutes.; - `Google meet <https://meet.google.com/pdd-dibg-cwv>`__; - English. Guidance for office hours hosts; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. * If you're interested in becoming an office hours host, please add your; information to the list above. Please create a calendar event for it and; invite calendar@llvm.org to the event so that it'll show up on the; :ref:`llvm-community-calendar`.; Please see :ref:`llvm-community-calendar-host-guidance` for more guidance on; what to add to your calendar invite.; * When starting an office hours session, consider typing something like ""*Hi,; I'm available for chats in the next half hour at* video chat URL. *I'm; looking forward to having conversations on the video chat or here.*"" on the; LLVM chat channels that you are already on. These could include:. * the `#office-hours Discord channel; <https://discord.com/channels/636084430946959380/976196303681896538>`__.; * :ref:`IRC`. Doing this can help:; * overcome potential anxiety to call in for a first time,; * people who prefer to first exchange a few messages through text chat; before dialing in, and; * re",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingInvolved.rst:15661,Guid,Guidance,15661,interpreter/llvm-project/llvm/docs/GettingInvolved.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingInvolved.rst,1,['Guid'],['Guidance']
Usability,"2d to make it possible to use ROOT's; graphics on iOS devices (iPad, iPhone, iPod touch).; Among other things, it has the ROOT::iOS::Pad class, which is a version; of TPad for iOS (pad with TF2 example below). Two applications, based on this module, were developed for iOS (currently,; for iPad only): ""Tutorials"" and ""RootBrowser"".; They can be found in $ROOTSYS/test/ios. ""Tutorials"" app; Small application with several demos, ""iOS version"" of the $ROOTSYS/tutorlas/demos.C. ""Tutorials"" application:. supports portrait and landscape orientation; has several demos (can be selected by tapping on table's cells); supports different gestures (pinch, single and double tap, pan, etc. - active gestures are shown by hint icons); has ""zoom"" mode - pinch or double tap gesture will zoom in/out pad's contents; has ""selection"" mode - with single tap user can select different objects inside pad - axes, histograms, pavestats etc.; 3D objects can be rotated.; has a simple editor to modify pad's parameters : fill color, logarithmic scale, grid, ticks, etc. ""RootBrowser"" app; This application is a simplified version of TBrowser and TCanvas; for iOS. User can open ROOT's file (application uses TWebFile) and; browse file's contents.; RootBrower registers *.root file extension in a system, so for; example, attached root files from a mail client can be opened by; RootBrowser.; Application has several views. In a top level view, user can see; opened files, open new files, close files (long press gesture on; a file icon):. Tap gesture on a file's icon will open ""File contents"" view. This; view shows objects and nested directories. For objects small; previews are generated. Tapping on a directory's icon will open; new view with directory's contents. Simple search is supported; (in the current TDirectoryFile). Tap on a object's preview will open detailed view for this object.; Using pinch gesture or double tap, you can zoom in/zoom out pad's; contents.; If you have several objects in a file or dir",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/doc/v532/index.html:2273,simpl,simple,2273,graf2d/doc/v532/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/doc/v532/index.html,1,['simpl'],['simple']
Usability,"32 = SUB32rr %6, %0, implicit-def $eflags, debug-location !5; JB_1 %bb.1, implicit $eflags, debug-location !5; JMP_1 %bb.2, debug-location !5. bb.2.bb2:; %8:gr32 = MOV32r0 implicit-def dead $eflags; $eax = COPY %8, debug-location !5; RET 0, $eax, debug-location !5. Observe first that there is a DBG_VALUE instruction for every ``llvm.dbg.value``; intrinsic in the source IR, ensuring no source level assignments go missing.; Then consider the different ways in which variable locations have been recorded:. * For the first dbg.value an immediate operand is used to record a zero value.; * The dbg.value of the PHI instruction leads to a DBG_VALUE of virtual register; ``%0``.; * The first GEP has its effect folded into the first load instruction; (as a 4-byte offset), but the variable location is salvaged by folding; the GEPs effect into the DIExpression.; * The second GEP is also folded into the corresponding load. However, it is; insufficiently simple to be salvaged, and is emitted as a ``$noreg``; DBG_VALUE, indicating that the variable takes on an undefined location.; * The final dbg.value has its Value placed in virtual register ``%1``. Instruction Scheduling; ----------------------. A number of passes can reschedule instructions, notably instruction selection; and the pre-and-post RA machine schedulers. Instruction scheduling can; significantly change the nature of the program -- in the (very unlikely) worst; case the instruction sequence could be completely reversed. In such; circumstances LLVM follows the principle applied to optimizations, that it is; better for the debugger not to display any state than a misleading state.; Thus, whenever instructions are advanced in order of execution, any; corresponding DBG_VALUE is kept in its original position, and if an instruction; is delayed then the variable is given an undefined location for the duration; of the delay. To illustrate, consider this pseudo-MIR:. .. code-block:: text. %1:gr32 = MOV32rm %0, 1, $noreg, 4, $nor",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:32445,simpl,simple,32445,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['simpl'],['simple']
Usability,"4020e-02; root[] f1.Derivative(3); (Double_t)(-3.45675056671992330e-01); root[] f1.Integral(0,3); (Double_t)1.84865252799946810e+00; root[] f1.Draw(); ```. By default the method `TF1::Paint()`, that draws the function,; computes 100 equidistant points to draw it. The number of points can; be set to a higher value with:. ``` {.cpp}; root[] f1.SetNpx(2000);; ```. Note that while the ROOT framework is an object-oriented framework,; this does not prevent the user from calling plain functions. ### User Interaction. Now we will look at some interactive capabilities. Try to draw the; function `sin(x)/x` again. Every object in a window (which is called a; canvas) is, in fact, a graphical object in the sense that you can grab; it, resize it, and change its characteristics with a mouse click. For; example, bring the cursor over the x-axis. The cursor changes to a; hand with a pointing finger when it is over the axis. Now, left click; and drag the mouse along the axis to the right. You have a very simple; zoom. When you move the mouse over any object, you can get access to; selected methods by pressing the right mouse button and obtaining a; context menu. If you try this on the function **`TF1`**, you will get; a menu showing available methods. The other objects on this canvas are; the title, a **`TPaveText`** object`;` the x and y-axis, **`TAxis`**; objects, the frame, a **`TFrame`** object, and the canvas a; **`TCanvas `** object. Try clicking on these and observe the context; menu with their methods. ![A context menu](pictures/0300002A.png). For example try selecting the `SetRange()` method and putting `-10`,; `10` in the dialog box fields. This is equivalent to executing; `f1.SetRange(-10,10)` from the command line, followed by `f1.Draw()`.; Here are some other options you can try. Once the picture suits your wishes, you may want to see the code you; should put in a script to obtain the same result. To do that, choose; Save / `canvas.C` entry of the File menu. This will ge",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:20972,simpl,simple,20972,documentation/users-guide/GettingStarted.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md,1,['simpl'],['simple']
Usability,47483647; * TH1L : histograms with one long64 per channel. Maximum bin content = 9223372036854775807; * TH1F : histograms with one float per channel. Maximum precision 7 digits; * TH1D : histograms with one double per channel. Maximum precision 14 digits; * 2-D histograms:; * TH2C : histograms with one byte per channel. Maximum bin content = 127; * TH2S : histograms with one short per channel. Maximum bin content = 32767; * TH2I : histograms with one int per channel. Maximum bin content = 2147483647; * TH2L : histograms with one long64 per channel. Maximum bin content = 9223372036854775807; * TH2F : histograms with one float per channel. Maximum precision 7 digits; * TH2D : histograms with one double per channel. Maximum precision 14 digits; * 3-D histograms:; * TH3C : histograms with one byte per channel. Maximum bin content = 127; * TH3S : histograms with one short per channel. Maximum bin content = 32767; * TH3I : histograms with one int per channel. Maximum bin content = 2147483647; * TH3L : histograms with one long64 per channel. Maximum bin content = 9223372036854775807; * TH3F : histograms with one float per channel. Maximum precision 7 digits; * TH3D : histograms with one double per channel. Maximum precision 14 digits. See also:. - [The Chapter about the Histogram classes in the Users Guide](ftp://root.cern.ch/root/doc/3Histograms.pdf); - [The Chapter about Fitting Histogram in the Users Guide](ftp://root.cern.ch/root/doc/5FittingHistograms.pdf); - [How to use the Histogram classes](https://root.cern/manual/histograms/); - [How to Merge files with histograms and Trees](https://root.cern/manual/storing_root_objects/#merging-root-files-with-hadd); - [How to Fit Histograms](https://root.cern/manual/fitting/); - [How to Fit find peaks in histograms](https://root.cern/doc/master/peaks_8C.html); - [How to convert Hbook/PAW files to ROOT](https://root-forum.cern.ch/t/how-to-convert-hbook-paw-files-to-root/). \defgroup HistPainting Painting classes; \ingroup Hist; ,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/doc/Hist.md:1721,Guid,Guide,1721,hist/doc/Hist.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/Hist.md,2,['Guid'],['Guide']
Usability,"5.4.3.3 Type Conversion Operations; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. .. note::. This section is the same as DWARF Version 5 section 2.5.1.6. .. _amdgpu-dwarf-general-operations:. A.2.5.4.3.4 Special Value Operations; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. .. note::. This section replaces parts of DWARF Version 5 sections 2.5.1.2, 2.5.1.3, and; 2.5.1.7. There are these special value operations currently defined:. 1. ``DW_OP_regval_type``. ``DW_OP_regval_type`` has two operands. The first is an unsigned LEB128; integer that represents a register number R. The second is an unsigned; LEB128 integer DR that represents the byte offset of a debugging information; entry D relative to the beginning of the current compilation unit, that; provides the type T of the register value. The operation is equivalent to performing ``DW_OP_regx R; DW_OP_deref_type; DR``. .. note::. Should DWARF allow the type T to be a larger size than the size of the; register R? Restricting a larger bit size avoids any issue of conversion; as the, possibly truncated, bit contents of the register is simply; interpreted as a value of T. If a conversion is wanted it can be done; explicitly using a ``DW_OP_convert`` operation. GDB has a per register hook that allows a target specific conversion on a; register by register basis. It defaults to truncation of bigger registers.; Removing use of the target hook does not cause any test failures in common; architectures. If the compiler for a target architecture did want some; form of conversion, including a larger result type, it could always; explicitly use the ``DW_OP_convert`` operation. If T is a larger type than the register size, then the default GDB; register hook reads bytes from the next register (or reads out of bounds; for the last register!). Removing use of the target hook does not cause; any test failures in common architectures (except an illegal hand written; assembly test). If a target architecture requires this behavior, these; extensions",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:87669,simpl,simply,87669,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['simpl'],['simply']
Usability,"562, 0.000562] 0.000562 X86ISelLowering.cpp:83:0: llvm::X86TargetLowering::X86TargetLowering(llvm::X86TargetMachine const&, llvm::X86Subtarget const&); 125 102 [ 0.000001, 0.000003, 0.000010, 0.000017, 0.000049] 0.000471 Verifier.cpp:3714:0: (anonymous namespace)::Verifier::visitInstruction(llvm::Instruction&); 90 8 [ 0.000023, 0.000035, 0.000106, 0.000106, 0.000106] 0.000342 X86ISelLowering.cpp:3363:0: llvm::X86TargetLowering::LowerCall(llvm::TargetLowering::CallLoweringInfo&, llvm::SmallVectorImpl<llvm::SDValue>&) const; 124 32 [ 0.000003, 0.000007, 0.000016, 0.000041, 0.000041] 0.000310 Verifier.cpp:1967:0: (anonymous namespace)::Verifier::visitFunction(llvm::Function const&); 123 1 [ 0.000302, 0.000302, 0.000302, 0.000302, 0.000302] 0.000302 LLVMContextImpl.cpp:54:0: llvm::LLVMContextImpl::~LLVMContextImpl(); 139 46 [ 0.000000, 0.000002, 0.000006, 0.000008, 0.000019] 0.000138 TargetLowering.cpp:506:0: llvm::TargetLowering::SimplifyDemandedBits(llvm::SDValue, llvm::APInt const&, llvm::APInt&, llvm::APInt&, llvm::TargetLowering::TargetLoweringOpt&, unsigned int, bool) const. This shows us that for our input file, ``llc`` spent the most cumulative time; in the lexer (a total of 1 millisecond). If we wanted for example to work with; this data in a spreadsheet, we can output the results as CSV using the; ``-format=csv`` option to the command for further analysis. If we want to get a textual representation of the raw trace we can use the; ``llvm-xray convert`` tool to get YAML output. The first few lines of that; output for an example trace would look like the following:. ::. $ llvm-xray convert -f yaml --symbolize --instr_map=./bin/llc xray-log.llc.m35qPB; ---; header:; version: 1; type: 0; constant-tsc: true; nonstop-tsc: true; cycle-frequency: 2601000000; records:; - { type: 0, func-id: 110, function: __cxx_global_var_init.8, cpu: 37, thread: 69819, kind: function-enter, tsc: 5434426023268520 }; - { type: 0, func-id: 110, function: __cxx_global_var_init.8, cpu: 37, ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/XRayExample.rst:4574,Simpl,SimplifyDemandedBits,4574,interpreter/llvm-project/llvm/docs/XRayExample.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/XRayExample.rst,1,['Simpl'],['SimplifyDemandedBits']
Usability,"5sbHZtLndnQGdtYWlsLmNvbQ>`__; - `Meeting details/agenda <https://docs.google.com/document/d/1ivYDSn_5ChTeiZ7TiO64WC_jYJnGwAUiT9Ngi9cAdFU/edit?usp=sharing>`__; * - GlobalISel; - Every 2nd Tuesday of the month; - `gcal <https://calendar.google.com/calendar/u/0?cid=ZDcyMjc0ZjZiZjNhMzFlYmE3NTNkMWM2MGM2NjM5ZWU3ZDE2MjM4MGFlZDc2ZjViY2UyYzMwNzVhZjk4MzQ4ZEBncm91cC5jYWxlbmRhci5nb29nbGUuY29t>`__; - `Meeting details/agenda <https://docs.google.com/document/d/1Ry8O4-Tm5BFj9AMjr8qTQFU80z-ptiNQ62687NaIvLs/edit?usp=sharing>`__; * - Floating Point Working Group; - Every 3rd Wednesday of the month; - `gcal <https://calendar.google.com/calendar/u/0?cid=MDI1ODI1MDdiYWM3OWQxODY5MDA3MTI1NjZlYzNmYzY5YjMzYWMyNGQ3ZGUwYThjNzZjN2IxOTk3NmYxOTBjMEBncm91cC5jYWxlbmRhci5nb29nbGUuY29t>`__; - `Meeting details/agenda: <https://docs.google.com/document/d/1QcmUlWftPlBi-Wz6b6PipqJfvjpJ-OuRMRnN9Dm2t0c>`__. .. _office-hours:. Office hours; ------------. A number of experienced LLVM contributors make themselves available for a chat; on a regular schedule, to anyone who is looking for some guidance. Please find; the list of who is available when, through which medium, and what their area of; expertise is. Don't be too shy to dial in!. The :doc:`CodeOfConduct` applies to all office hours. Of course, people take time off from time to time, so if you dial in and you; don't find anyone present, chances are they happen to be off that day. .. list-table:: LLVM office hours; :widths: 15 40 15 15 15; :header-rows: 1. * - Name; - In-scope topics; - When?; - Where?; - Languages; * - Kristof Beyls; - General questions on how to contribute to LLVM; organizing meetups;; submitting talks; and other general LLVM-related topics. Arm/AArch64; codegen. LLVM security group. LLVM Office Hours.; - Every 2nd and 4th Wednesday of the month at 9.30am CET, for 30 minutes.; `ics <https://calendar.google.com/calendar/ical/co0h4ndpvtfe64opn7eraiq3ac%40group.calendar.google.com/public/basic.ics>`__; - `Jitsi <https://meet.jit.si/Kristof",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingInvolved.rst:10145,guid,guidance,10145,interpreter/llvm-project/llvm/docs/GettingInvolved.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingInvolved.rst,1,['guid'],['guidance']
Usability,": ""-I"", Values: {""foo""}; Option 3 - Name: ""-I"", Values: {""foo""}; Option 4 - Name: ""<input>"", Values: {""t.c""}. After this stage is complete the command line should be broken down; into well defined option objects with their appropriate parameters.; Subsequent stages should rarely, if ever, need to do any string; processing. #. **Pipeline: Compilation Action Construction**. Once the arguments are parsed, the tree of subprocess jobs needed for; the desired compilation sequence are constructed. This involves; determining the input files and their types, what work is to be done; on them (preprocess, compile, assemble, link, etc.), and constructing; a list of Action instances for each task. The result is a list of one; or more top-level actions, each of which generally corresponds to a; single output (for example, an object or linked executable). The majority of Actions correspond to actual tasks, however there are; two special Actions. The first is InputAction, which simply serves to; adapt an input argument for use as an input to other Actions. The; second is BindArchAction, which conceptually alters the architecture; to be used for all of its input Actions. The clang driver can dump the results of this stage using the; ``-ccc-print-phases`` flag. For example:. .. code-block:: console. $ clang -ccc-print-phases -x c t.c -x assembler t.s; 0: input, ""t.c"", c; 1: preprocessor, {0}, cpp-output; 2: compiler, {1}, assembler; 3: assembler, {2}, object; 4: input, ""t.s"", assembler; 5: assembler, {4}, object; 6: linker, {3, 5}, image. Here the driver is constructing seven distinct actions, four to; compile the ""t.c"" input into an object file, two to assemble the; ""t.s"" input, and one to link them together. A rather different compilation pipeline is shown here; in this; example there are two top level actions to compile the input files; into two separate object files, where each object file is built using; ``lipo`` to merge results built for two separate architectures. .. code-blo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst:6622,simpl,simply,6622,interpreter/llvm-project/clang/docs/DriverInternals.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst,1,['simpl'],['simply']
Usability,": If an LLVM subcomponent has a C API already; included, then expanding that C API is acceptable. Adding C API for; subcomponents that don't currently have one needs to be discussed on the; `LLVM Discourse forums`_ for design and maintainability feedback prior to implementation. * Documentation: Any changes to the C API are required to be documented in the; release notes so that it's clear to external users who do not follow the; project how the C API is changing and evolving. .. _toolchain:. Updating Toolchain Requirements; -------------------------------. We intend to require newer toolchains as time goes by. This means LLVM's; codebase can use newer versions of C++ as they get standardized. Requiring newer; toolchains to build LLVM can be painful for those building LLVM; therefore, it; will only be done through the following process:. * It is a general goal to support LLVM and GCC versions from the last 3 years; at a minimum. This time-based guideline is not strict: we may support much; older compilers, or decide to support fewer versions. * An RFC is sent to the `LLVM Discourse forums`_. - Detail upsides of the version increase (e.g. which newer C++ language or; library features LLVM should use; avoid miscompiles in particular compiler; versions, etc).; - Detail downsides on important platforms (e.g. Ubuntu LTS status). * Once the RFC reaches consensus, update the CMake toolchain version checks as; well as the :doc:`getting started<GettingStarted>` guide. This provides a; softer transition path for developers compiling LLVM, because the; error can be turned into a warning using a CMake flag. This is an important; step: LLVM still doesn't have code which requires the new toolchains, but it; soon will. If you compile LLVM but don't read the forums, we should; tell you!. * Ensure that at least one LLVM release has had this soft-error. Not all; developers compile LLVM top-of-tree. These release-bound developers should; also be told about upcoming changes. * Turn the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst:34374,guid,guideline,34374,interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,1,['guid'],['guideline']
Usability,": c++. void InitializeModuleAndPassManager(void) {; // Open a new context and module.; TheContext = std::make_unique<LLVMContext>();; TheModule = std::make_unique<Module>(""my cool jit"", TheContext);; TheModule->setDataLayout(TheJIT->getDataLayout());. // Create a new builder for the module.; Builder = std::make_unique<IRBuilder<>>(*TheContext);. // Create a new pass manager attached to it.; TheFPM = std::make_unique<legacy::FunctionPassManager>(TheModule.get());; ... The KaleidoscopeJIT class is a simple JIT built specifically for these; tutorials, available inside the LLVM source code; at `llvm-src/examples/Kaleidoscope/include/KaleidoscopeJIT.h; <https://github.com/llvm/llvm-project/blob/main/llvm/examples/Kaleidoscope/include/KaleidoscopeJIT.h>`_.; In later chapters we will look at how it works and extend it with; new features, but for now we will take it as given. Its API is very simple:; ``addModule`` adds an LLVM IR module to the JIT, making its functions; available for execution (with its memory managed by a ``ResourceTracker``); and; ``lookup`` allows us to look up pointers to the compiled code. We can take this simple API and change our code that parses top-level expressions to; look like this:. .. code-block:: c++. static ExitOnError ExitOnErr;; ...; static void HandleTopLevelExpression() {; // Evaluate a top-level expression into an anonymous function.; if (auto FnAST = ParseTopLevelExpr()) {; if (FnAST->codegen()) {; // Create a ResourceTracker to track JIT'd memory allocated to our; // anonymous expression -- that way we can free it after executing.; auto RT = TheJIT->getMainJITDylib().createResourceTracker();. auto TSM = ThreadSafeModule(std::move(TheModule), std::move(TheContext));; ExitOnErr(TheJIT->addModule(std::move(TSM), RT));; InitializeModuleAndPassManager();. // Search the JIT for the __anon_expr symbol.; auto ExprSymbol = ExitOnErr(TheJIT->lookup(""__anon_expr""));; assert(ExprSymbol && ""Function not found"");. // Get the symbol's address and ca",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl04.rst:12235,simpl,simple,12235,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl04.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl04.rst,1,['simpl'],['simple']
Usability,": int}; HotPatchTableOffset: {type: int}; EnclaveConfigurationPointer: {type: int}; VolatileMetadataPointer: {type: int}; GuardEHContinuationTable: {type: int}; GuardEHContinuationCount: {type: int}; GuardXFGCheckFunctionPointer: {type: int}; GuardXFGDispatchFunctionPointer: {type: int}; GuardXFGTableDispatchFunctionPointer: {type: int}; CastGuardOsDeterminedFailureMode: {type: int}. symbols:; - Name: .text; Value: 0; SectionNumber: 1; SimpleType: IMAGE_SYM_TYPE_NULL # (0); ComplexType: IMAGE_SYM_DTYPE_NULL # (0); StorageClass: IMAGE_SYM_CLASS_STATIC # (3); NumberOfAuxSymbols: 1; AuxiliaryData:; ""\x24\x00\x00\x00\x03\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00"" # |$.................|. - Name: _main; Value: 0; SectionNumber: 1; SimpleType: IMAGE_SYM_TYPE_NULL # (0); ComplexType: IMAGE_SYM_DTYPE_NULL # (0); StorageClass: IMAGE_SYM_CLASS_EXTERNAL # (2). Here's a simplified Kwalify_ schema with an extension to allow alternate types. .. _Kwalify: http://www.kuwata-lab.com/kwalify/ruby/users-guide.html. .. code-block:: yaml. type: map; mapping:; header:; type: map; mapping:; Machine: [ {type: str, enum:; [ IMAGE_FILE_MACHINE_UNKNOWN; , IMAGE_FILE_MACHINE_AM33; , IMAGE_FILE_MACHINE_AMD64; , IMAGE_FILE_MACHINE_ARM; , IMAGE_FILE_MACHINE_ARMNT; , IMAGE_FILE_MACHINE_ARM64; , IMAGE_FILE_MACHINE_EBC; , IMAGE_FILE_MACHINE_I386; , IMAGE_FILE_MACHINE_IA64; , IMAGE_FILE_MACHINE_M32R; , IMAGE_FILE_MACHINE_MIPS16; , IMAGE_FILE_MACHINE_MIPSFPU; , IMAGE_FILE_MACHINE_MIPSFPU16; , IMAGE_FILE_MACHINE_POWERPC; , IMAGE_FILE_MACHINE_POWERPCFP; , IMAGE_FILE_MACHINE_R4000; , IMAGE_FILE_MACHINE_SH3; , IMAGE_FILE_MACHINE_SH3DSP; , IMAGE_FILE_MACHINE_SH4; , IMAGE_FILE_MACHINE_SH5; , IMAGE_FILE_MACHINE_THUMB; , IMAGE_FILE_MACHINE_WCEMIPSV2; ]}; , {type: int}; ]; Characteristics:; - type: seq; sequence:; - type: str; enum: [ IMAGE_FILE_RELOCS_STRIPPED; , IMAGE_FILE_EXECUTABLE_IMAGE; , IMAGE_FILE_LINE_NUMS_STRIPPED; , IMAGE_FILE_LOCAL_SYMS_STRIPPED; , IMAGE_FILE_AGGRESSIVE_WS_TRIM; , IMAGE_FIL",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/yaml2obj.rst:3179,guid,guide,3179,interpreter/llvm-project/llvm/docs/yaml2obj.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/yaml2obj.rst,1,['guid'],['guide']
Usability,":"");; ExitOnErr.setExitCodeMapper(; [](const Error &Err) {; if (Err.isA<BadFileFormat>()); return 2;; return 1;; });. Use ``ExitOnError`` in your tool code where possible as it can greatly improve; readability. .. _err_cantfail:. Using cantFail to simplify safe callsites; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Some functions may only fail for a subset of their inputs, so calls using known; safe inputs can be assumed to succeed. The cantFail functions encapsulate this by wrapping an assertion that their; argument is a success value and, in the case of Expected<T>, unwrapping the; T value:. .. code-block:: c++. Error onlyFailsForSomeXValues(int X);; Expected<int> onlyFailsForSomeXValues2(int X);. void foo() {; cantFail(onlyFailsForSomeXValues(KnownSafeValue));; int Y = cantFail(onlyFailsForSomeXValues2(KnownSafeValue));; ...; }. Like the ExitOnError utility, cantFail simplifies control flow. Their treatment; of error cases is very different however: Where ExitOnError is guaranteed to; terminate the program on an error input, cantFail simply asserts that the result; is success. In debug builds this will result in an assertion failure if an error; is encountered. In release builds the behavior of cantFail for failure values is; undefined. As such, care must be taken in the use of cantFail: clients must be; certain that a cantFail wrapped call really can not fail with the given; arguments. Use of the cantFail functions should be rare in library code, but they are; likely to be of more use in tool and unit-test code where inputs and/or; mocked-up classes or functions may be known to be safe. Fallible constructors; """""""""""""""""""""""""""""""""""""""""". Some classes require resource acquisition or other complex initialization that; can fail during construction. Unfortunately constructors can't return errors,; and having clients test objects after they're constructed to ensure that they're; valid is error prone as it's all too easy to forget the test. To work around; this, use the named",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:32850,simpl,simply,32850,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['simpl'],['simply']
Usability,":. .. code-block:: text. refs: ((Ref)[, (Ref)]*). where each ``Ref`` contains a reference to the summary id of the referenced; value (e.g. ``^1``). .. _typeidinfo_summary:. TypeIdInfo; ^^^^^^^^^^. The optional ``TypeIdInfo`` field, used for; `Control Flow Integrity <https://clang.llvm.org/docs/ControlFlowIntegrity.html>`_,; looks like:. .. code-block:: text. typeIdInfo: [(TypeTests)]?[, (TypeTestAssumeVCalls)]?[, (TypeCheckedLoadVCalls)]?[, (TypeTestAssumeConstVCalls)]?[, (TypeCheckedLoadConstVCalls)]?. These optional fields have the following forms:. TypeTests; """""""""""""""""". .. code-block:: text. typeTests: (TypeIdRef[, TypeIdRef]*). Where each ``TypeIdRef`` refers to a :ref:`type id<typeid_summary>`; by summary id or ``GUID``. TypeTestAssumeVCalls; """""""""""""""""""""""""""""""""""""""". .. code-block:: text. typeTestAssumeVCalls: (VFuncId[, VFuncId]*). Where each VFuncId has the format:. .. code-block:: text. vFuncId: (TypeIdRef, offset: 16). Where each ``TypeIdRef`` refers to a :ref:`type id<typeid_summary>`; by summary id or ``GUID`` preceded by a ``guid:`` tag. TypeCheckedLoadVCalls; """""""""""""""""""""""""""""""""""""""""". .. code-block:: text. typeCheckedLoadVCalls: (VFuncId[, VFuncId]*). Where each VFuncId has the format described for ``TypeTestAssumeVCalls``. TypeTestAssumeConstVCalls; """""""""""""""""""""""""""""""""""""""""""""""""". .. code-block:: text. typeTestAssumeConstVCalls: (ConstVCall[, ConstVCall]*). Where each ConstVCall has the format:. .. code-block:: text. (VFuncId, args: (Arg[, Arg]*)). and where each VFuncId has the format described for ``TypeTestAssumeVCalls``,; and each Arg is an integer argument number. TypeCheckedLoadConstVCalls; """""""""""""""""""""""""""""""""""""""""""""""""""". .. code-block:: text. typeCheckedLoadConstVCalls: (ConstVCall[, ConstVCall]*). Where each ConstVCall has the format described for; ``TypeTestAssumeConstVCalls``. .. _typeid_summary:. Type ID Summary Entry; ---------------------. Each type id summary entry corresponds to a type identifier resolution; which is generated during the LTO link porti",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:347540,GUID,GUID,347540,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,2,"['GUID', 'guid']","['GUID', 'guid']"
Usability,":. Formatting strings (the ``formatv`` function); ---------------------------------------------; While LLVM doesn't necessarily do a lot of string manipulation and parsing, it; does do a lot of string formatting. From diagnostic messages, to llvm tool; outputs such as ``llvm-readobj`` to printing verbose disassembly listings and; LLDB runtime logging, the need for string formatting is pervasive. The ``formatv`` is similar in spirit to ``printf``, but uses a different syntax; which borrows heavily from Python and C#. Unlike ``printf`` it deduces the type; to be formatted at compile time, so it does not need a format specifier such as; ``%d``. This reduces the mental overhead of trying to construct portable format; strings, especially for platform-specific types like ``size_t`` or pointer types.; Unlike both ``printf`` and Python, it additionally fails to compile if LLVM does; not know how to format the type. These two properties ensure that the function; is both safer and simpler to use than traditional formatting methods such as; the ``printf`` family of functions. Simple formatting; ^^^^^^^^^^^^^^^^^. A call to ``formatv`` involves a single **format string** consisting of 0 or more; **replacement sequences**, followed by a variable length list of **replacement values**.; A replacement sequence is a string of the form ``{N[[,align]:style]}``. ``N`` refers to the 0-based index of the argument from the list of replacement; values. Note that this means it is possible to reference the same parameter; multiple times, possibly with different style and/or alignment options, in any order. ``align`` is an optional string specifying the width of the field to format; the value into, and the alignment of the value within the field. It is specified as; an optional **alignment style** followed by a positive integral **field width**. The; alignment style can be one of the characters ``-`` (left align), ``=`` (center align),; or ``+`` (right align). The default is right aligned. ``s",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:12119,simpl,simpler,12119,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['simpl'],['simpler']
Usability,":. declare void @llvm.coro.destroy(ptr <handle>). Overview:; """""""""""""""""". The '``llvm.coro.destroy``' intrinsic destroys a suspended; switched-resume coroutine. Arguments:; """""""""""""""""""". The argument is a coroutine handle to a suspended coroutine. Semantics:; """""""""""""""""""". When possible, the `coro.destroy` intrinsic is replaced with a direct call to; the coroutine destroy function. Otherwise it is replaced with an indirect call; based on the function pointer for the destroy function stored in the coroutine; frame. Destroying a coroutine that is not suspended leads to undefined behavior. .. _coro.resume:. 'llvm.coro.resume' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ::. declare void @llvm.coro.resume(ptr <handle>). Overview:; """""""""""""""""". The '``llvm.coro.resume``' intrinsic resumes a suspended switched-resume coroutine. Arguments:; """""""""""""""""""". The argument is a handle to a suspended coroutine. Semantics:; """""""""""""""""""". When possible, the `coro.resume` intrinsic is replaced with a direct call to the; coroutine resume function. Otherwise it is replaced with an indirect call based; on the function pointer for the resume function stored in the coroutine frame.; Resuming a coroutine that is not suspended leads to undefined behavior. .. _coro.done:. 'llvm.coro.done' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ::. declare i1 @llvm.coro.done(ptr <handle>). Overview:; """""""""""""""""". The '``llvm.coro.done``' intrinsic checks whether a suspended; switched-resume coroutine is at the final suspend point or not. Arguments:; """""""""""""""""""". The argument is a handle to a suspended coroutine. Semantics:; """""""""""""""""""". Using this intrinsic on a coroutine that does not have a `final suspend`_ point; or on a coroutine that is not suspended leads to undefined behavior. .. _coro.promise:. 'llvm.coro.promise' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ::. declare ptr @llvm.coro.promise(ptr <ptr>, i32 <alignment>, i1 <from>). Overview:; """""""""""""""""". The '``llvm.coro.promise``' intr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:28077,resume,resume,28077,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,2,['resume'],['resume']
Usability,":. double %test3(bool %B) {; %C = select bool %B, double 123.412, double 523.01123123; ret double %C; }. Currently, the select is being lowered, which prevents the dag combiner from; turning 'select (load CPI1), (load CPI2)' -> 'load (select CPI1, CPI2)'. The pattern isel got this one right. //===---------------------------------------------------------------------===//. Lower memcpy / memset to a series of SSE 128 bit move instructions when it's; feasible. //===---------------------------------------------------------------------===//. Codegen:; if (copysign(1.0, x) == copysign(1.0, y)); into:; if (x^y & mask); when using SSE. //===---------------------------------------------------------------------===//. Use movhps to update upper 64-bits of a v4sf value. Also movlps on lower half; of a v4sf value. //===---------------------------------------------------------------------===//. Better codegen for vector_shuffles like this { x, 0, 0, 0 } or { x, 0, x, 0}.; Perhaps use pxor / xorp* to clear a XMM register first?. //===---------------------------------------------------------------------===//. External test Nurbs exposed some problems. Look for; __ZN15Nurbs_SSE_Cubic17TessellateSurfaceE, bb cond_next140. This is what icc; emits:. movaps (%edx), %xmm2 #59.21; movaps (%edx), %xmm5 #60.21; movaps (%edx), %xmm4 #61.21; movaps (%edx), %xmm3 #62.21; movl 40(%ecx), %ebp #69.49; shufps $0, %xmm2, %xmm5 #60.21; movl 100(%esp), %ebx #69.20; movl (%ebx), %edi #69.20; imull %ebp, %edi #69.49; addl (%eax), %edi #70.33; shufps $85, %xmm2, %xmm4 #61.21; shufps $170, %xmm2, %xmm3 #62.21; shufps $255, %xmm2, %xmm2 #63.21; lea (%ebp,%ebp,2), %ebx #69.49; negl %ebx #69.49; lea -3(%edi,%ebx), %ebx #70.33; shll $4, %ebx #68.37; addl 32(%ecx), %ebx #68.37; testb $15, %bl #91.13; jne L_B1.24 # Prob 5% #91.13. This is the llvm code after instruction scheduling:. cond_next140 (0xa910740, LLVM BB @0xa90beb0):; 	%reg1078 = MOV32ri -3; 	%reg1079 = ADD32rm %reg1078, %reg1068, 1, %noreg, 0; 	%re",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/README-SSE.txt:3588,clear,clear,3588,interpreter/llvm-project/llvm/lib/Target/X86/README-SSE.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/README-SSE.txt,1,['clear'],['clear']
Usability,://github.com/root-project/root/issues/10221)] - ROOT interpreter built with C++17 does not find `std::optional` without including it first; * [[#10146](https://github.com/root-project/root/issues/10146)] - Byte swapped floats in TMVA sofie on big endian architectures (s390x); * [[#10061](https://github.com/root-project/root/issues/10061)] - Distributed RDataFrame test failures on Mac/ARM; * [[#9917](https://github.com/root-project/root/issues/9917)] - SetRange and SetRangeUser fail silently; * [[#9594](https://github.com/root-project/root/issues/9594)] - Systematic build failure of ROOT master in the LCG DEBUG builds since Jan 15th; * [[#9524](https://github.com/root-project/root/issues/9524)] - Failure to build/run when MACOSX_DEPLOYMENT_TARGET is set to 11 or higher; * [[#9514](https://github.com/root-project/root/issues/9514)] - Printed SVG image contains newline cutting through XML tags; * [[#9489](https://github.com/root-project/root/issues/9489)] - [RF] Cannot turn off useless messages with RooMCStudy unbinned fits + Progress bar would be better.; * [[#9292](https://github.com/root-project/root/issues/9292)] - Integer overflow in TTreeCache::FillBuffer; * [[#8959](https://github.com/root-project/root/issues/8959)] - `ninja clean` does not remove `modules.idx`; * [[#8952](https://github.com/root-project/root/issues/8952)] - Make hadd return a non-zero exit code when encountering a corrupted file; * [[#8942](https://github.com/root-project/root/issues/8942)] - cannot buid the dependent project; * [[#8794](https://github.com/root-project/root/issues/8794)] - [TGNumberEntry] centiseconds; * [[#8720](https://github.com/root-project/root/issues/8720)] - Apply TChain::SetImplicitMT() to underlying trees; * [[#8639](https://github.com/root-project/root/issues/8639)] - (RDataFrame) AsNumpy returns Boolean branches as 'object' dtype numpy arrays; * [[#8582](https://github.com/root-project/root/issues/8582)] - TThreadTimer behavior; * [[#8581](https://github.com/root-pro,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md:46194,Progress bar,Progress bar,46194,README/ReleaseNotes/v632/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md,1,['Progress bar'],['Progress bar']
Usability,"::createJITDylib`` method with a unique name:. .. code-block:: c++. ExecutionSession ES;; auto &JD = ES.createJITDylib(""libFoo.dylib"");. The JITDylib is owned by the ``ExecutionEngine`` instance and will be freed; when it is destroyed. How to remove code; ------------------. To remove an individual module from a JITDylib it must first be added using an; explicit ``ResourceTracker``. The module can then be removed by calling; ``ResourceTracker::remove``:. .. code-block:: c++. auto &JD = ... ;; auto M = ... ;. auto RT = JD.createResourceTracker();; Layer.add(RT, std::move(M)); // Add M to JD, tracking resources with RT. RT.remove(); // Remove M from JD. Modules added directly to a JITDylib will be tracked by that JITDylib's default; resource tracker. All code can be removed from a JITDylib by calling ``JITDylib::clear``. This; leaves the cleared JITDylib in an empty but usable state. JITDylibs can be removed by calling ``ExecutionSession::removeJITDylib``. This; clears the JITDylib and then puts it into a defunct state. No further operations; can be performed on the JITDylib, and it will be destroyed as soon as the last; handle to it is released. An example of how to use the resource management APIs can be found at; ``llvm/examples/OrcV2Examples/LLJITRemovableCode``. How to add the support for custom program representation; --------------------------------------------------------; In order to add the support for a custom program representation, a custom ``MaterializationUnit``; for the program representation, and a custom ``Layer`` are needed. The Layer will have two; operations: ``add`` and ``emit``. The ``add`` operation takes an instance of your program; representation, builds one of your custom ``MaterializationUnits`` to hold it, then adds it; to a ``JITDylib``. The emit operation takes a ``MaterializationResponsibility`` object and an; instance of your program representation and materializes it, usually by compiling it and handing; the resulting object off to an ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ORCv2.rst:24258,clear,clears,24258,interpreter/llvm-project/llvm/docs/ORCv2.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ORCv2.rst,1,['clear'],['clears']
Usability,"::vector<std::unique_ptr<ExprAST>> Args;; if (CurTok != ')') {; while (true) {; if (auto Arg = ParseExpression()); Args.push_back(std::move(Arg));; else; return nullptr;. if (CurTok == ')'); break;. if (CurTok != ','); return LogError(""Expected ')' or ',' in argument list"");; getNextToken();; }; }. // Eat the ')'.; getNextToken();. return std::make_unique<CallExprAST>(IdName, std::move(Args));; }. This routine follows the same style as the other routines. (It expects; to be called if the current token is a ``tok_identifier`` token). It; also has recursion and error handling. One interesting aspect of this is; that it uses *look-ahead* to determine if the current identifier is a; stand alone variable reference or if it is a function call expression.; It handles this by checking to see if the token after the identifier is; a '(' token, constructing either a ``VariableExprAST`` or; ``CallExprAST`` node as appropriate. Now that we have all of our simple expression-parsing logic in place, we; can define a helper function to wrap it together into one entry point.; We call this class of expressions ""primary"" expressions, for reasons; that will become more clear `later in the; tutorial <LangImpl06.html#user-defined-unary-operators>`_. In order to parse an arbitrary; primary expression, we need to determine what sort of expression it is:. .. code-block:: c++. /// primary; /// ::= identifierexpr; /// ::= numberexpr; /// ::= parenexpr; static std::unique_ptr<ExprAST> ParsePrimary() {; switch (CurTok) {; default:; return LogError(""unknown token when expecting an expression"");; case tok_identifier:; return ParseIdentifierExpr();; case tok_number:; return ParseNumberExpr();; case '(':; return ParseParenExpr();; }; }. Now that you see the definition of this function, it is more obvious why; we can assume the state of CurTok in the various functions. This uses; look-ahead to determine which sort of expression is being inspected, and; then parses it with a function call. Now that bas",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst:10910,simpl,simple,10910,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst,1,['simpl'],['simple']
Usability,":Kind AttrKind; Matches declaration that has a given attribute. Given; __attribute__((device)) void f() { ... }; decl(hasAttr(clang::attr::CUDADevice)) matches the function declaration of; f. If the matcher is used from clang-query, attr::Kind parameter should be; passed as a quoted string. e.g., hasAttr(""attr::CUDADevice""). Matcher<Decl>isExpandedFromMacrostd::string MacroName; Matches statements that are (transitively) expanded from the named macro.; Does not match if only part of the statement is expanded from that macro or; if different parts of the statement are expanded from different; appearances of the macro. Matcher<Decl>isExpansionInFileMatchingStringRef RegExp, Regex::RegexFlags Flags = NoFlags; Matches AST nodes that were expanded within files whose name is; partially matching a given regex. Example matches Y but not X; (matcher = cxxRecordDecl(isExpansionInFileMatching(""AST.*"")); #include ""ASTMatcher.h""; class X {};; ASTMatcher.h:; class Y {};. Usable as: Matcher<Decl>, Matcher<Stmt>, Matcher<TypeLoc>. If the matcher is used in clang-query, RegexFlags parameter; should be passed as a quoted string. e.g: ""NoFlags"".; Flags can be combined with '|' example ""IgnoreCase | BasicRegex"". Matcher<Decl>isExpansionInMainFile; Matches AST nodes that were expanded within the main-file. Example matches X but not Y; (matcher = cxxRecordDecl(isExpansionInMainFile()); #include <Y.h>; class X {};; Y.h:; class Y {};. Usable as: Matcher<Decl>, Matcher<Stmt>, Matcher<TypeLoc>. Matcher<Decl>isExpansionInSystemHeader; Matches AST nodes that were expanded within system-header-files. Example matches Y but not X; (matcher = cxxRecordDecl(isExpansionInSystemHeader()); #include <SystemHeader.h>; class X {};; SystemHeader.h:; class Y {};. Usable as: Matcher<Decl>, Matcher<Stmt>, Matcher<TypeLoc>. Matcher<Decl>isImplicit; Matches an entity that has been implicitly added by the compiler (e.g.; implicit default/copy constructors). Matcher<Decl>isInAnonymousNamespace; Matches declaratio",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:82504,Usab,Usable,82504,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['Usab'],['Usable']
Usability,:RunFixedScan will scan using a fixed grid the parameter of interest. HypoTestInverter::RunAutoScan will perform an automatic scan to find optimally the curve and it will stop when the desired precision is obtained.; The confidence level value at a given point can also be done via HypoTestInverter::RunOnePoint.; The class can scan the CLs+b values (default) or alternatively CLs (if the; method HypoTestInverter::UseCLs has been called).; The estimated error due to the MC toys statistics from the HybridCalculator is propagated into the limits obtained from the HypoTestResult; A new tutorial rs801_HypoTestInverter.C has been added in the tutorials/roostats directory to show the usage of this class. New class BayesianCalculator. New class for calculating Bayesian interval using numerical integration. It implements the IntervalCalculator interface and returns as result a SimpleInterval. . The BayesianCalculator::GetInterval() method returns a SimpleInterval which contains the lower and upper value of the bayesian interval obtained from the posterior probability for the given confidence level.; The class return also the posterior pdf (BayesianCalculator::GetPosteriorPdf()) obtained from integrating (marginalizing) on the nuisance parameters.; It works currently only for one-dimensional problems by relying on RooFit for performing analytical or numerical integration.; A plot of the posterior and the desired interval can be obtained using BayesianCalculator::GetPosteriorPlot().; A new tutorial rs701_BayesianCalculator.C has been added in the tutorials/roostats directory to show the usage of this class. MCMCCalculator. Add possibility to specify the prior function in the constructor of the class to have a signature similar to the BayesianCalculator class. When no prior is specified it is assumed is part of the global model (pdf) passed to the class. Improvements and Bug fixes. Various improvements and fixes have been applied also to all the calculator classes. Internally now,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v526/index.html:16166,Simpl,SimpleInterval,16166,roofit/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v526/index.html,1,['Simpl'],['SimpleInterval']
Usability,":function<std::shared_ptr<Module>(std::shared_ptr<Module>)>;. IRTransformLayer<decltype(CompileLayer), OptimizeFunction> OptimizeLayer;. std::unique_ptr<JITCompileCallbackManager> CompileCallbackManager;; CompileOnDemandLayer<decltype(OptimizeLayer)> CODLayer;. public:; using ModuleHandle = decltype(CODLayer)::ModuleHandleT;. First we need to include the CompileOnDemandLayer.h header, then add two new; members: a std::unique_ptr<JITCompileCallbackManager> and a CompileOnDemandLayer,; to our class. The CompileCallbackManager member is used by the CompileOnDemandLayer; to create the compile callback needed for each function. .. code-block:: c++. KaleidoscopeJIT(); : TM(EngineBuilder().selectTarget()), DL(TM->createDataLayout()),; ObjectLayer([]() { return std::make_shared<SectionMemoryManager>(); }),; CompileLayer(ObjectLayer, SimpleCompiler(*TM)),; OptimizeLayer(CompileLayer,; [this](std::shared_ptr<Module> M) {; return optimizeModule(std::move(M));; }),; CompileCallbackManager(; orc::createLocalCompileCallbackManager(TM->getTargetTriple(), 0)),; CODLayer(OptimizeLayer,; [this](Function &F) { return std::set<Function*>({&F}); },; *CompileCallbackManager,; orc::createLocalIndirectStubsManagerBuilder(; TM->getTargetTriple())) {; llvm::sys::DynamicLibrary::LoadLibraryPermanently(nullptr);; }. Next we have to update our constructor to initialize the new members. To create; an appropriate compile callback manager we use the; createLocalCompileCallbackManager function, which takes a TargetMachine and an; ExecutorAddr to call if it receives a request to compile an unknown; function. In our simple JIT this situation is unlikely to come up, so we'll; cheat and just pass '0' here. In a production quality JIT you could give the; address of a function that throws an exception in order to unwind the JIT'd; code's stack. Now we can construct our CompileOnDemandLayer. Following the pattern from; previous layers we start by passing a reference to the next layer down in our; stack -- ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT3.rst:5082,Simpl,SimpleCompiler,5082,interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT3.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT3.rst,1,['Simpl'],['SimpleCompiler']
Usability,":local:. Release Administrative Tasks; ----------------------------. This section describes a few administrative tasks that need to be done for the; release process to begin. Specifically, it involves:. * Updating version numbers,. * Creating the release branch, and. * Tagging release candidates for the release team to begin testing. Create Release Branch; ^^^^^^^^^^^^^^^^^^^^^. Branch the Git trunk using the following procedure:. #. Remind developers that the release branching is imminent and to refrain from; committing patches that might break the build. E.g., new features, large; patches for works in progress, an overhaul of the type system, an exciting; new TableGen feature, etc. #. Verify that the current git trunk is in decent shape by; examining nightly tester and buildbot results. #. Bump the version in trunk to N.0.0git and tag the commit with llvmorg-N-init.; If ``X`` is the version to be released, then ``N`` is ``X + 1``. ::. $ git tag -sa llvmorg-N-init. #. Clear the release notes in trunk. #. Create the release branch from the last known good revision from before the; version bump. The branch's name is release/X.x where ``X`` is the major version; number and ``x`` is just the letter ``x``. #. On the newly-created release branch, immediately bump the version; to X.1.0git (where ``X`` is the major version of the branch.). #. All tags and branches need to be created in both the llvm/llvm-project and; llvm/llvm-test-suite repos. Update LLVM Version; ^^^^^^^^^^^^^^^^^^^. After creating the LLVM release branch, update the release branches'; version with the script in ``llvm/utils/release/bump-version.py``. Tagging the LLVM Release Candidates; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Tag release candidates:. ::. $ git tag -sa llvmorg-X.Y.Z-rcN. The Release Manager must supply pre-packaged source tarballs for users. This can; be done with the export.sh script in utils/release. Tarballs, release binaries, or any other release artifacts must be uploaded to; GitHub. T",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToReleaseLLVM.rst:4114,Clear,Clear,4114,interpreter/llvm-project/llvm/docs/HowToReleaseLLVM.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToReleaseLLVM.rst,1,['Clear'],['Clear']
Usability,"; 	%tmp614615 = sext i16 %tmp101 to i32		; <i32> [#uses=1]; 	%tmp621622 = sext i16 %tmp104 to i32		; <i32> [#uses=1]; 	%tmp623 = sub i32 32, %tmp621622		; <i32> [#uses=1]; 	br label %bb114. produces:. LBB3_5:	# bb114.preheader; 	movswl	-68(%ebp), %eax; 	movl	$32, %ecx; 	movl	%ecx, -80(%ebp); 	subl	%eax, -80(%ebp); 	movswl	-52(%ebp), %eax; 	movl	%ecx, -84(%ebp); 	subl	%eax, -84(%ebp); 	movswl	-70(%ebp), %eax; 	movl	%ecx, -88(%ebp); 	subl	%eax, -88(%ebp); 	movswl	-50(%ebp), %eax; 	subl	%eax, %ecx; 	movl	%ecx, -76(%ebp); 	movswl	-42(%ebp), %eax; 	movl	%eax, -92(%ebp); 	movswl	-66(%ebp), %eax; 	movl	%eax, -96(%ebp); 	movw	$0, -98(%ebp). This appears to be bad because the RA is not folding the store to the stack ; slot into the movl. The above instructions could be:; 	movl $32, -80(%ebp); ...; 	movl $32, -84(%ebp); ...; This seems like a cross between remat and spill folding. This has redundant subtractions of %eax from a stack slot. However, %ecx doesn't; change, so we could simply subtract %eax from %ecx first and then use %ecx (or; vice-versa). //===---------------------------------------------------------------------===//. This code:. 	%tmp659 = icmp slt i16 %tmp654, 0		; <i1> [#uses=1]; 	br i1 %tmp659, label %cond_true662, label %cond_next715. produces this:. 	testw	%cx, %cx; 	movswl	%cx, %esi; 	jns	LBB4_109	# cond_next715. Shark tells us that using %cx in the testw instruction is sub-optimal. It; suggests using the 32-bit register (which is what ICC uses). //===---------------------------------------------------------------------===//. We compile this:. void compare (long long foo) {; if (foo < 4294967297LL); abort();; }. to:. compare:; subl $4, %esp; cmpl $0, 8(%esp); setne %al; movzbw %al, %ax; cmpl $1, 12(%esp); setg %cl; movzbw %cl, %cx; cmove %ax, %cx; testb $1, %cl; jne .LBB1_2 # UnifiedReturnBlock; .LBB1_1: # ifthen; call abort; .LBB1_2: # UnifiedReturnBlock; addl $4, %esp; ret. (also really horrible code on ppc). This is due to the expand code for 64-bit; c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/README.txt:16615,simpl,simply,16615,interpreter/llvm-project/llvm/lib/Target/X86/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/README.txt,1,['simpl'],['simply']
Usability,"; ![Editors for shapes, materials, media, matrices](pictures/020001F1.jpg); ![Editors for shapes, materials, media, matrices](pictures/020001F2.jpg); ![Editors for shapes, materials, media, matrices](pictures/020001F3.jpg); ![Editors for shapes, materials, media, matrices](pictures/030001F4.png). For most editors, the functionalities Apply and Undo are provided. For shapes, changing any of the shape parameters will activate the; ""*Apply*"" button only if the check button ""*Delayed draw*"" is checked,; otherwise the changes are immediately applied. Once the apply button is; pressed, the changes are applied to the edited shape and drawn. The; ""*Undo*"" button becomes active after the first modification has been; applied. It allows restoring the initial parameters of the shape. NOTE: In this version the ""*Undo*"" does not allow restoring an; intermediate state of the parameters that was applied - it will always; restore the parameters at the moment the shape was edited. All material properties changes are undoable. The mixture editor; currently allows adding elements one by one in the mixture composition.; This can be done either by element weight fraction or by number of; atoms. Once an element was added using one method the other method is not; selectable anymore. Summing component fractions up to 1 in the final; mixture is the user responsibility. Adding materials as components of a; mixture is not supported in this version. The elements that were added to the mixture appear in the bottom of the; mixture editor. The operations performed on mixture are not undoable. ### Creation of New Objects. As described above, all geometry object creators are accessible within; the geometry manager editor frame. Generally, if the new object that; needs to be created does not depend on other objects, it will be built; with a set of default parameters. This is the case for all shapes; (except composite shapes) and matrices. For all the other objects the; interface forces the selection ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:171187,undo,undoable,171187,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['undo'],['undoable']
Usability,"; # Foreword #. ## What M is intended to do ##. M is conceived as a tool to find the minimum value of a multi-parameter; function (the ""$\mbox{FCN}$"") and analyze the shape of the function; around the minimum. The principal application is foreseen for; statistical analysis, working on chisquare or log-likelihood functions,; to compute the best-fit parameter values and uncertainties, including; correlations between the parameters. It is especially suited to handle; difficult problems, including those which may require guidance in order; to find the correct solution. ## What M is not intended to do ##. Although M will of course solve easy problems faster than complicated; ones, it is not intended for the repeated solution of identically; parametrized problems (such as track fitting in a detector) where a; specialized program will in general be much more efficient. ## Further remarks ##. M was initially written in Fortran around 1975-1980 at CERN by Fred; James @bib-MINUIT. Its main field of usage is statistical data analysis; of experimental data recorded at CERN, but it is also used by people; doing data analysis outside CERN or outside high energy physics (HEP).; In 2002 Fred James started a project aiming to re-implement M in an; object-oriented way using . More information about recent developments, releases and installation; can be obtained from the M homepage @bib-C++MINUIT. The names of M applications are written in capital letters (e.g.; $\mbox{MIGRAD}$, $\mbox{MINOS}$, $\mbox{CONTOURS}$), the; corresponding names of the classes are written using sans-serif font; type (MnMigrad, MnMinos, MnContours). # Introduction: M basic concepts #. [sec:intro]. ## The organization of M ##. The M package acts on a multiparameter *objective function* which is; called — for historical reasons — the $\mbox{FCN}$ function (see; [howto:fcn]). This function is usually a chisquared or a log–likelihood,; but it could also be a mathematical function. The $\mbox{FCN}$; function needs ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:523,guid,guidance,523,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['guid'],['guidance']
Usability,"; * - `Compiler Research - Calling C++ libraries from a D-written DSL: A cling/cppyy-based approach <https://www.youtube.com/watch?v=7teqrCNzrD8>`_; - *Alexandru Militaru* 2021 Compiler-Research Meeting; - This video presents D and C++ interoperability through SIL-Cling architecture. .. list-table:: Interactive CUDA C++ with Cling:; :widths: 25 25 50; :header-rows: 1. * - Link; - Info ; - Description; * - `Adding CUDA® Support to Cling: JIT Compile to GPUs <https://www.youtube.com/watch?v=XjjZRhiFDVs>`_; - *Simeon Ehrig* 2020 LLVM Developer Meeting; - Interactive CUDA-C++ through Cling is presented. Cling-CUDA architecture is discussed in detail, and an example of interactive simulation for laser plasma applications is shown. . .. list-table:: C++ in Jupyter Notebook - Xeus Cling:; :widths: 25 25 50; :header-rows: 1; ; * - Link; - Info ; - Description; * - `Interactive C++ code development using C++Explorer and GitHub Classroom for educational purposes <https://www.youtube.com/watch?v=HBgF2Yr0foA>`_; - *Patrick Diehl* 2020 Youtube; - C++Explorer is a novel teaching environment based on Jupyterhub and Cling, adapted to teaching C++ programming and source code management.; * - `Deep dive into the Xeus-based Cling kernel for Jupyter <https://www.youtube.com/watch?v=kx3wvKk4Qss>`_; - *Vassil Vassilev* 2021 Youtube; - Xeus-Cling is a Cling-based notebook kernel which delivers interactive C++. ; * - `Xeus-Cling: Run C++ code in Jupyter Notebook <https://www.youtube.com/watch?v=4fcKlJ_5QQk>`_ ; - *LearnOpenCV* 2019 Youtube; - In this demo, you will learn an example of C++ code in Jupyter Notebook using Xeus-Cling kernel. . .. list-table:: Clad:; :widths: 25 25 50; :header-rows: 1; ; * - Link; - Info ; - Description; * - `Clad: Automatic differentiation plugin for C++ <https://clad.readthedocs.io/en/latest/index.html>`_ ; - Read The Docs webpage; - Clad is a plugin for Cling. It allows to perform Automatic Differentiation (AD) on multivariate functions and functor objects. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/docs/chapters/references.rst:7367,Learn,LearnOpenCV,7367,interpreter/cling/docs/chapters/references.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/docs/chapters/references.rst,2,"['Learn', 'learn']","['LearnOpenCV', 'learn']"
Usability,"; -----------------------. The storage layout of raw profile data format is illustrated below. Basically,; when the raw profile is read into an memory buffer, the actual byte offset of a; section is inferred from the section's order in the layout and size information; of all the sections ahead of it. ::. +----+-----------------------+; | | Magic |; | +-----------------------+; | | Version |; | +-----------------------+; H | Size Info for |; E | Section 1 |; A +-----------------------+; D | Size Info for |; E | Section 2 |; R +-----------------------+; | | ... |; | +-----------------------+; | | Size Info for |; | | Section N |; +----+-----------------------+; P | Section 1 |; A +-----------------------+; Y | Section 2 |; L +-----------------------+; O | ... |; A +-----------------------+; D | Section N |; +----+-----------------------+. .. note::; Sections might be padded to meet specific alignment requirements. For; simplicity, header fields and data sections solely for padding purpose are; omitted in the data layout graph above and the rest of this document. Header; -------. ``Magic``; Magic number encodes profile format (raw, indexed or text). For the raw format,; the magic number also encodes the endianness (big or little) and C pointer; size (4 or 8 bytes) of the platform on which the profile is generated. A factory method reads the magic number to construct reader properly and returns; error upon unrecognized format. Specifically, the factory method and raw profile; reader implementation make sure that a raw profile file could be read back on; a platform with the opposite endianness and/or the other C pointer size. ``Version``; The lower 32 bits specify the actual version and the most significant 32 bits; specify the variant types of the profile. IR-based instrumentation PGO and; context-sensitive IR-based instrumentation PGO are two variant types. ``BinaryIdsSize``; The byte size of `binary id`_ section. ``NumData``; The number of profile metadata. The byte si",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/InstrProfileFormat.rst:2758,simpl,simplicity,2758,interpreter/llvm-project/llvm/docs/InstrProfileFormat.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/InstrProfileFormat.rst,1,['simpl'],['simplicity']
Usability,"; -------------------. .. note::. To Be Written. Instruction Alias Processing; ----------------------------. Once the instruction is parsed, it enters the MatchInstructionImpl function.; The MatchInstructionImpl function performs alias processing and then does actual; matching. Alias processing is the phase that canonicalizes different lexical forms of the; same instructions down to one representation. There are several different kinds; of alias that are possible to implement and they are listed below in the order; that they are processed (which is in order from simplest/weakest to most; complex/powerful). Generally you want to use the first alias mechanism that; meets the needs of your instruction, because it will allow a more concise; description. Mnemonic Aliases; ^^^^^^^^^^^^^^^^. The first phase of alias processing is simple instruction mnemonic remapping for; classes of instructions which are allowed with two different mnemonics. This; phase is a simple and unconditionally remapping from one input mnemonic to one; output mnemonic. It isn't possible for this form of alias to look at the; operands at all, so the remapping must apply for all forms of a given mnemonic.; Mnemonic aliases are defined simply, for example X86 has:. ::. def : MnemonicAlias<""cbw"", ""cbtw"">;; def : MnemonicAlias<""smovq"", ""movsq"">;; def : MnemonicAlias<""fldcww"", ""fldcw"">;; def : MnemonicAlias<""fucompi"", ""fucomip"">;; def : MnemonicAlias<""ud2a"", ""ud2"">;. ... and many others. With a MnemonicAlias definition, the mnemonic is remapped; simply and directly. Though MnemonicAlias's can't look at any aspect of the; instruction (such as the operands) they can depend on global modes (the same; ones supported by the matcher), through a Requires clause:. ::. def : MnemonicAlias<""pushf"", ""pushfq"">, Requires<[In64BitMode]>;; def : MnemonicAlias<""pushf"", ""pushfl"">, Requires<[In32BitMode]>;. In this example, the mnemonic gets mapped into a different one depending on; the current instruction set. Instruction",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:82321,simpl,simple,82321,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,1,['simpl'],['simple']
Usability,"; .. _instructionselect:. InstructionSelect; -----------------. This pass transforms generic machine instructions into equivalent; target-specific instructions. It traverses the ``MachineFunction`` bottom-up,; selecting uses before definitions, enabling trivial dead code elimination. .. _api-instructionselector:. API: InstructionSelector; ^^^^^^^^^^^^^^^^^^^^^^^^. The target implements the ``InstructionSelector`` class, containing the; target-specific selection logic proper. The instance is provided by the subtarget, so that it can specialize the; selector by subtarget feature (with, e.g., a vector selector overriding parts; of a general-purpose common selector).; We might also want to parameterize it by MachineFunction, to enable selector; variants based on function attributes like optsize. The simple API consists of:. .. code-block:: c++. virtual bool select(MachineInstr &MI). This target-provided method is responsible for mutating (or replacing) a; possibly-generic MI into a fully target-specific equivalent.; It is also responsible for doing the necessary constraining of gvregs into the; appropriate register classes as well as passing through COPY instructions to; the register allocator. The ``InstructionSelector`` can fold other instructions into the selected MI,; by walking the use-def chain of the vreg operands.; As GlobalISel is Global, this folding can occur across basic blocks. SelectionDAG Rule Imports; ^^^^^^^^^^^^^^^^^^^^^^^^^. TableGen will import SelectionDAG rules and provide the following function to; execute them:. .. code-block:: c++. bool selectImpl(MachineInstr &MI). The ``--stats`` option can be used to determine what proportion of rules were; successfully imported. The easiest way to use this is to copy the; ``-gen-globalisel`` tablegen command from ``ninja -v`` and modify it. Similarly, the ``--warn-on-skipped-patterns`` option can be used to obtain the; reasons that rules weren't imported. This can be used to focus on the most; important rejec",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GlobalISel/InstructionSelect.rst:807,simpl,simple,807,interpreter/llvm-project/llvm/docs/GlobalISel/InstructionSelect.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GlobalISel/InstructionSelect.rst,1,['simpl'],['simple']
Usability,"; .. _tblgen-mirpats:. ========================; MIR Patterns in TableGen; ========================. .. contents::; :local:. User's Guide; ============. This section is intended for developers who want to use MIR patterns in their; TableGen files. ``NOTE``:; This feature is still in active development. This document may become outdated; over time. If you see something that's incorrect, please update it. Use Cases; ---------. MIR patterns are supported in the following places:. * GlobalISel ``GICombineRule``; * GlobalISel ``GICombinePatFrag``. Syntax; ------. MIR patterns use the DAG datatype in TableGen. .. code-block:: text. (inst operand0, operand1, ...). ``inst`` must be a def which inherits from ``Instruction`` (e.g. ``G_FADD``); or ``GICombinePatFrag``. Operands essentially fall into one of two categories:. * immediates. * untyped, unnamed: ``0``; * untyped, named: ``0:$y``; * typed, unnamed: ``(i32 0)``; * typed, named: ``(i32 0):$y``. * machine operands. * untyped: ``$x``; * typed: ``i32:$x``. Semantics:. * A typed operand always adds an operand type check to the matcher.; * There is a trivial type inference system to propagate types. * e.g. You only need to use ``i32:$x`` once in any pattern of a; ``GICombinePatFrag`` alternative or ``GICombineRule``, then all; other patterns in that rule/alternative can simply use ``$x``; (``i32:$x`` is redundant). * A named operand's behavior depends on whether the name has been seen before. * For match patterns, reusing an operand name checks that the operands; are identical (see example 2 below).; * For apply patterns, reusing an operand name simply copies that operand into; the new instruction (see example 2 below). Operands are ordered just like they would be in a MachineInstr: the defs (outs); come first, then the uses (ins). Patterns are generally grouped into another DAG datatype with a dummy operator; such as ``match``, ``apply`` or ``pattern``. Finally, any DAG datatype in TableGen can be named. This also holds for",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GlobalISel/MIRPatterns.rst:132,Guid,Guide,132,interpreter/llvm-project/llvm/docs/GlobalISel/MIRPatterns.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GlobalISel/MIRPatterns.rst,1,['Guid'],['Guide']
Usability,"; === TextInput. = Purpose. Read and edit text lines, and write what was read. This library is a simplistic alternative to readline / editline. It offers; less functionality but it has a more liberal license (see LICENSE.TXT in; the topmost) directory, it has no external dependencies, and it works on; all platforms that I tested:; - Linux; - Windows (probably >= 2000); - MacOS; - Solaris; Adding other platforms is trivial. = Internal Design. TextInput.h contains the main interface. The reading can be extended by; adding classes that derive from Reader; the displaying can be extended; by deriving from Display. There can be multiple readers and multiple displays. All displays are; equal, all readers are equal. All displays show the input of all; readers. The terminal / console implementations for readers and; displays are provided. Both readers and displays only attach while; textinput is acively reading input. As soon as the input is done (enter; was pressed), they detach from the terminal, allowing the application; to take control of the terminal, and even to crash without leaving the; terminal in a non-default state. The editor provides basic emacs-like keybinding, as known from e.g.; bash. It supports ^O, ^R (for now without regex), and most word-centric; editing commands. See KeyBinding for details. KeyBinding maps the InputData read from the Reader to Editor::Commands.; The Editor performs the requested editing actions, and the Displays; are informed about the changes. TextInput gives access to the read; state (""are we done?"") and the input. = Why no [N]Curses?. Because of platform independence (well, one could still have a; TerminalDisplayCurses) and because nowadays this is actually rarely; needed. Sure, it's the ""right"" way of interfacing terminals. But the; number of terminal types in the wild has siginifantly decreased, so; just hard-coding escape sequences became a viable alternative. = References. These pages helped when writing libtextinput:; http://tldp.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/textinput/src/textinput/doc/textinput.txt:97,simpl,simplistic,97,core/textinput/src/textinput/doc/textinput.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/textinput/src/textinput/doc/textinput.txt,1,['simpl'],['simplistic']
Usability,"; CHECK-LABEL: C_ctor_base:; ; CHECK: mov [[SAVETHIS:r[0-9]+]], r0; ; CHECK: bl A_ctor_base; ; CHECK: mov r0, [[SAVETHIS]]; %0 = bitcast %struct.C* %this to %struct.A*; %call = tail call %struct.A* @A_ctor_base(%struct.A* %0); %1 = bitcast %struct.C* %this to %struct.B*; %call2 = tail call %struct.B* @B_ctor_base(%struct.B* %1, i32 %x); ret %struct.C* %this; }. define %struct.D* @D_ctor_base(%struct.D* %this, i32 %x) {; entry:; ; CHECK-LABEL: D_ctor_base:. The use of ``CHECK-LABEL:`` directives in this case ensures that the three; ``CHECK:`` directives only accept lines corresponding to the body of the; ``@C_ctor_base`` function, even if the patterns match lines found later in; the file. Furthermore, if one of these three ``CHECK:`` directives fail,; FileCheck will recover by continuing to the next block, allowing multiple test; failures to be detected in a single invocation. There is no requirement that ``CHECK-LABEL:`` directives contain strings that; correspond to actual syntactic labels in a source or output language: they must; simply uniquely match a single line in the file being verified. ``CHECK-LABEL:`` directives cannot contain variable definitions or uses. Directive modifiers; ~~~~~~~~~~~~~~~~~~~. A directive modifier can be append to a directive by following the directive; with ``{<modifier>}`` where the only supported value for ``<modifier>`` is; ``LITERAL``. The ``LITERAL`` directive modifier can be used to perform a literal match. The; modifier results in the directive not recognizing any syntax to perform regex; matching, variable capture or any substitutions. This is useful when the text; to match would require excessive escaping otherwise. For example, the; following will perform literal matches rather than considering these as; regular expressions:. .. code-block:: text. Input: [[[10, 20]], [[30, 40]]]; Output %r10: [[10, 20]]; Output %r10: [[30, 40]]. ; CHECK{LITERAL}: [[[10, 20]], [[30, 40]]]; ; CHECK-DAG{LITERAL}: [[30, 40]]; ; CHECK-DAG{LITERA",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst:23580,simpl,simply,23580,interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,1,['simpl'],['simply']
Usability,"; Design doc for a redesign of the Bugpoint tool. :doc:`Proposals/TestSuite`; Proposals for additional benchmarks/programs for llvm's test-suite. :doc:`Proposals/VariableNames`; Proposal to change the variable names coding standard. :doc:`Proposals/VectorPredication`; Proposal for predicated vector instructions in LLVM. .. _llvm-community-calendar:. LLVM community calendar; -----------------------. We aim to maintain a public calendar view of all events happening in the LLVM; community such as :ref:`online-sync-ups` and :ref:`office-hours`. The calendar; can be found at; https://calendar.google.com/calendar/u/0/embed?src=calendar@llvm.org and can; also be seen inline below:. .. raw:: html. <iframe src=""https://calendar.google.com/calendar/embed?height=600&wkst=1&bgcolor=%23ffffff&ctz=UTC&showCalendars=0&showDate=1&showNav=1&src=Y2FsZW5kYXJAbGx2bS5vcmc&color=%23039BE5"" style=""border:solid 1px #777"" width=""800"" height=""600"" frameborder=""0"" scrolling=""no""></iframe>. .. _llvm-community-calendar-host-guidance:. Guidance on what to put into LLVM community calendar invites; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. To add your event, create a calendar event for it and invite calendar@llvm.org; on it. Your event should then show up on the community calendar. Please put the following pieces of information in your calendar invite:. * Write a single paragraph describing what the event is about. Include things; such as who the event is for and what sort of topics are discussed.; * State explicitly that the :doc:`CodeOfConduct` applies to this event.; * Make it clear who:. * the organizer is. * the person to contact is in case of any code-of-conduct issues. Typically,; this would be the organizer. * If you have meeting minutes for your event, add a pointer to where those live.; A good place for meeting minutes could be as a post on LLVM Discourse. An example invite looks as follows. .. code-block:: none. This event is a meetup for all developers of LLDB. Meeti",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingInvolved.rst:19580,guid,guidance,19580,interpreter/llvm-project/llvm/docs/GettingInvolved.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingInvolved.rst,1,['guid'],['guidance']
Usability,"; Explicit linking is required by newer distributions, like Ubuntu 11.10,; that require all dependent shared libs to be specified when linking. They; also have default options set to dead strip shared libs that don't resolve; any symbols (equivalent to the MacOS X build changes described above). Core Libraries; TClonesArray. Introduce TClonesArray::ConstructedAt which; always returns an already constructed object. If the slot is being used for the; first time, it calls the default constructor otherwise it returns the object as; is (unless a string is passed as the 2nd argument to the function in which case,; it also calls Clear(second_argument) on the object).; This allows to replace code like:. for (int i = 0; i < ev->Ntracks; i++) {; new(a[i]) TTrack(x,y,z,...);; ...; ...; }; ...; a.Delete(); // or a.Clear(""C""). with the simpler and more efficient:. for (int i = 0; i < ev->Ntracks; i++) {; TTrack *track = (TTrack*)a.ConstructedAt(i);; track->Set(x,y,z,....);; ...; ...; }; ...; a.Clear();. even in case where the TTrack class allocates memory. TClonesArray: update ExpandCreateFast to also reset the non-used slots; so that calling Clear (which does too much) is no longer necessary; when using ExpandCreateFast. New Thread Pool class. A first version of TThreadPool class has been introduced.; This class implements a Thread Pool pattern.; So far it supports only one type of queue - FIFO. Thread library. Reduces risk of internal dead lock by using a private internal lock to protect the internals of TThread, rather than using TThread::Lock. New header TThreadSlots.h to centralize and formalize the use of the TThread local memory slots amongst the ROOT packages. Global Variables. The global values gPad, gVirtualX, gInterpreter, gDirectory and gFile; are now all accessed via a static function of their respective class. The; access is made transparent via a CPP macro.; The access is now also made transparent from the CINT and python prompt.; gPad, gVirtualX and gInterpreter a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/doc/v532/index.html:2200,Clear,Clear,2200,core/doc/v532/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/doc/v532/index.html,1,['Clear'],['Clear']
Usability,; LaSum.h; MPIProcess.h; MatrixInverse.h; MinimumBuilder.h; MinimumError.h; MinimumErrorUpdator.h; MinimumParameters.h; MinimumSeed.h; MinimumSeedGenerator.h; MinimumState.h; MinosError.h; Minuit2Minimizer.h; MinuitParameter.h; MnApplication.h; MnConfig.h; MnContours.h; MnCovarianceSqueeze.h; MnCross.h; MnEigen.h; MnFcn.h; MnFumiliMinimize.h; MnFunctionCross.h; MnGlobalCorrelationCoeff.h; MnHesse.h; MnLineSearch.h; MnMachinePrecision.h; MnMatrix.h; MnMatrixfwd.h; MnMigrad.h; MnMinimize.h; MnMinos.h; MnParabola.h; MnParabolaFactory.h; MnParabolaPoint.h; MnParameterScan.h; MnPlot.h; MnPosDef.h; MnPrint.h; MnScan.h; MnSeedGenerator.h; MnSimplex.h; MnStrategy.h; MnTiny.h; MnTraceObject.h; MnUserCovariance.h; MnUserFcn.h; MnUserParameterState.h; MnUserParameters.h; MnUserTransformation.h; MnVectorTransform.h; ModularFunctionMinimizer.h; NegativeG2LineSearch.h; Numerical2PGradientCalculator.h; ParametricFunction.h; ScanBuilder.h; ScanMinimizer.h; SimplexBuilder.h; SimplexMinimizer.h; SimplexParameters.h; SimplexSeedGenerator.h; SinParameterTransformation.h; SqrtLowParameterTransformation.h; SqrtUpParameterTransformation.h; StackAllocator.h; VariableMetricBuilder.h; VariableMetricEDMEstimator.h; VariableMetricMinimizer.h; VectorOuterProduct.h; ). set(MINUIT2_SOURCES; AnalyticalGradientCalculator.cxx; BFGSErrorUpdator.cxx; CombinedMinimumBuilder.cxx; DavidonErrorUpdator.cxx; ExternalInternalGradientCalculator.cxx; FumiliBuilder.cxx; FumiliErrorUpdator.cxx; FumiliGradientCalculator.cxx; FumiliMinimizer.cxx; FumiliStandardChi2FCN.cxx; FumiliStandardMaximumLikelihoodFCN.cxx; HessianGradientCalculator.cxx; InitialGradientCalculator.cxx; LaEigenValues.cxx; LaInnerProduct.cxx; LaInverse.cxx; LaOuterProduct.cxx; LaSumOfElements.cxx; LaVtMVSimilarity.cxx; MPIProcess.cxx; MinimumBuilder.cxx; Minuit2Minimizer.cxx; MnApplication.cxx; MnContours.cxx; MnCovarianceSqueeze.cxx; MnEigen.cxx; MnFcn.cxx; MnFumiliMinimize.cxx; MnFunctionCross.cxx; MnGlobalCorrelationCoeff.cxx; MnHesse.cxx; MnL,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/CMakeLists.txt:1969,Simpl,SimplexParameters,1969,math/minuit2/src/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/CMakeLists.txt,1,['Simpl'],['SimplexParameters']
Usability,; MIGChecker.cpp; MoveChecker.cpp; MPI-Checker/MPIBugReporter.cpp; MPI-Checker/MPIChecker.cpp; MPI-Checker/MPIFunctionClassifier.cpp; NSAutoreleasePoolChecker.cpp; NSErrorChecker.cpp; NoReturnFunctionChecker.cpp; NonNullParamChecker.cpp; NonnullGlobalConstantsChecker.cpp; NullabilityChecker.cpp; NumberObjectConversionChecker.cpp; ObjCAtSyncChecker.cpp; ObjCAutoreleaseWriteChecker.cpp; ObjCContainersASTChecker.cpp; ObjCContainersChecker.cpp; ObjCMissingSuperCallChecker.cpp; ObjCPropertyChecker.cpp; ObjCSelfInitChecker.cpp; ObjCSuperDeallocChecker.cpp; ObjCUnusedIVarsChecker.cpp; OSObjectCStyleCast.cpp; PaddingChecker.cpp; PointerArithChecker.cpp; PointerIterationChecker.cpp; PointerSortingChecker.cpp; PointerSubChecker.cpp; PthreadLockChecker.cpp; cert/PutenvWithAutoChecker.cpp; RetainCountChecker/RetainCountChecker.cpp; RetainCountChecker/RetainCountDiagnostics.cpp; ReturnPointerRangeChecker.cpp; ReturnUndefChecker.cpp; ReturnValueChecker.cpp; RunLoopAutoreleaseLeakChecker.cpp; SimpleStreamChecker.cpp; SmartPtrChecker.cpp; SmartPtrModeling.cpp; StackAddrEscapeChecker.cpp; StdLibraryFunctionsChecker.cpp; StdVariantChecker.cpp; STLAlgorithmModeling.cpp; StreamChecker.cpp; StringChecker.cpp; Taint.cpp; TaintTesterChecker.cpp; TestAfterDivZeroChecker.cpp; TraversalChecker.cpp; TrustNonnullChecker.cpp; TrustReturnsNonnullChecker.cpp; UndefBranchChecker.cpp; UndefCapturedBlockVarChecker.cpp; UndefResultChecker.cpp; UndefinedArraySubscriptChecker.cpp; UndefinedAssignmentChecker.cpp; UndefinedNewArraySizeChecker.cpp; UninitializedObject/UninitializedObjectChecker.cpp; UninitializedObject/UninitializedPointee.cpp; UnixAPIChecker.cpp; UnreachableCodeChecker.cpp; VforkChecker.cpp; VLASizeChecker.cpp; ValistChecker.cpp; VirtualCallChecker.cpp; WebKit/NoUncountedMembersChecker.cpp; WebKit/ASTUtils.cpp; WebKit/PtrTypesSemantics.cpp; WebKit/RefCntblBaseVirtualDtorChecker.cpp; WebKit/UncountedCallArgsChecker.cpp; WebKit/UncountedLambdaCapturesChecker.cpp; WebKit/UncountedLocalVarsCh,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CMakeLists.txt:2685,Simpl,SimpleStreamChecker,2685,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CMakeLists.txt,1,['Simpl'],['SimpleStreamChecker']
Usability,"; Matches the initialization statement of a for loop. Example:; forStmt(hasLoopVariable(anything())); matches 'int x' in; for (int x : a) { }. Matcher<CXXForRangeStmt>hasRangeInitMatcher<Expr> InnerMatcher; Matches the range initialization statement of a for loop. Example:; forStmt(hasRangeInit(anything())); matches 'a' in; for (int x : a) { }. Matcher<CXXFunctionalCastExpr>hasTypeLocMatcher<TypeLoc> Inner; Matches if the type location of a node matches the inner matcher. Examples:; int x;; declaratorDecl(hasTypeLoc(loc(asString(""int"")))); matches int x. auto x = int(3);; cxxTemporaryObjectExpr(hasTypeLoc(loc(asString(""int"")))); matches int(3). struct Foo { Foo(int, int); };; auto x = Foo(1, 2);; cxxFunctionalCastExpr(hasTypeLoc(loc(asString(""struct Foo"")))); matches Foo(1, 2). Usable as: Matcher<BlockDecl>, Matcher<CXXBaseSpecifier>,; Matcher<CXXCtorInitializer>, Matcher<CXXFunctionalCastExpr>,; Matcher<CXXNewExpr>, Matcher<CXXTemporaryObjectExpr>,; Matcher<CXXUnresolvedConstructExpr>,; Matcher<ClassTemplateSpecializationDecl>, Matcher<CompoundLiteralExpr>,; Matcher<DeclaratorDecl>, Matcher<ExplicitCastExpr>,; Matcher<ObjCPropertyDecl>, Matcher<TemplateArgumentLoc>,; Matcher<TypedefNameDecl>. Matcher<CXXMemberCallExpr>onImplicitObjectArgumentMatcher<Expr> InnerMatcher; Matches on the implicit object argument of a member call expression. Unlike; `on`, matches the argument directly without stripping away anything. Given; class Y { public: void m(); };; Y g();; class X : public Y { void g(); };; void z(Y y, X x) { y.m(); x.m(); x.g(); (g()).m(); }; cxxMemberCallExpr(onImplicitObjectArgument(hasType(; cxxRecordDecl(hasName(""Y""))))); matches `y.m()`, `x.m()` and (g()).m(), but not `x.g()`.; cxxMemberCallExpr(on(callExpr())); does not match `(g()).m()`, because the parens are not ignored. FIXME: Overload to allow directly matching types?. Matcher<CXXMemberCallExpr>onMatcher<Expr> InnerMatcher; Matches on the implicit object argument of a member call expression, after; st",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:157943,Usab,Usable,157943,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['Usab'],['Usable']
Usability,; MatrixInverse.h; MinimumBuilder.h; MinimumError.h; MinimumErrorUpdator.h; MinimumParameters.h; MinimumSeed.h; MinimumSeedGenerator.h; MinimumState.h; MinosError.h; Minuit2Minimizer.h; MinuitParameter.h; MnApplication.h; MnConfig.h; MnContours.h; MnCovarianceSqueeze.h; MnCross.h; MnEigen.h; MnFcn.h; MnFumiliMinimize.h; MnFunctionCross.h; MnGlobalCorrelationCoeff.h; MnHesse.h; MnLineSearch.h; MnMachinePrecision.h; MnMatrix.h; MnMatrixfwd.h; MnMigrad.h; MnMinimize.h; MnMinos.h; MnParabola.h; MnParabolaFactory.h; MnParabolaPoint.h; MnParameterScan.h; MnPlot.h; MnPosDef.h; MnPrint.h; MnScan.h; MnSeedGenerator.h; MnSimplex.h; MnStrategy.h; MnTiny.h; MnTraceObject.h; MnUserCovariance.h; MnUserFcn.h; MnUserParameterState.h; MnUserParameters.h; MnUserTransformation.h; MnVectorTransform.h; ModularFunctionMinimizer.h; NegativeG2LineSearch.h; Numerical2PGradientCalculator.h; ParametricFunction.h; ScanBuilder.h; ScanMinimizer.h; SimplexBuilder.h; SimplexMinimizer.h; SimplexParameters.h; SimplexSeedGenerator.h; SinParameterTransformation.h; SqrtLowParameterTransformation.h; SqrtUpParameterTransformation.h; StackAllocator.h; VariableMetricBuilder.h; VariableMetricEDMEstimator.h; VariableMetricMinimizer.h; VectorOuterProduct.h; ). set(MINUIT2_SOURCES; AnalyticalGradientCalculator.cxx; BFGSErrorUpdator.cxx; CombinedMinimumBuilder.cxx; DavidonErrorUpdator.cxx; ExternalInternalGradientCalculator.cxx; FumiliBuilder.cxx; FumiliErrorUpdator.cxx; FumiliGradientCalculator.cxx; FumiliMinimizer.cxx; FumiliStandardChi2FCN.cxx; FumiliStandardMaximumLikelihoodFCN.cxx; HessianGradientCalculator.cxx; InitialGradientCalculator.cxx; LaEigenValues.cxx; LaInnerProduct.cxx; LaInverse.cxx; LaOuterProduct.cxx; LaSumOfElements.cxx; LaVtMVSimilarity.cxx; MPIProcess.cxx; MinimumBuilder.cxx; Minuit2Minimizer.cxx; MnApplication.cxx; MnContours.cxx; MnCovarianceSqueeze.cxx; MnEigen.cxx; MnFcn.cxx; MnFumiliMinimize.cxx; MnFunctionCross.cxx; MnGlobalCorrelationCoeff.cxx; MnHesse.cxx; MnLineSearch.cxx; MnMachi,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/CMakeLists.txt:1990,Simpl,SimplexSeedGenerator,1990,math/minuit2/src/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/CMakeLists.txt,1,['Simpl'],['SimplexSeedGenerator']
Usability,"; Structured bindings __cpp_structured_bindings C++17 C++03; template template arguments __cpp_template_template_args C++17 C++03; ``static operator[]`` __cpp_multidimensional_subscript C++20 C++03; Designated initializers __cpp_designated_initializers C++20 C++03; Conditional ``explicit`` __cpp_conditional_explicit C++20 C++03; ``using enum`` __cpp_using_enum C++20 C++03; ``if consteval`` __cpp_if_consteval C++23 C++20; ``static operator()`` __cpp_static_call_operator C++23 C++03; Attributes on Lambda-Expressions C++23 C++11; -------------------------------------- -------------------------------- ------------- -------------; Designated initializers (N494) C99 C89; Array & element qualification (N2607) C23 C89; Attributes (N2335) C23 C89; ====================================== ================================ ============= =============. Type Trait Primitives; =====================. Type trait primitives are special builtin constant expressions that can be used; by the standard C++ library to facilitate or simplify the implementation of; user-facing type traits in the <type_traits> header. They are not intended to be used directly by user code because they are; implementation-defined and subject to change -- as such they're tied closely to; the supported set of system headers, currently:. * LLVM's own libc++; * GNU libstdc++; * The Microsoft standard C++ library. Clang supports the `GNU C++ type traits; <https://gcc.gnu.org/onlinedocs/gcc/Type-Traits.html>`_ and a subset of the; `Microsoft Visual C++ type traits; <https://msdn.microsoft.com/en-us/library/ms177194(v=VS.100).aspx>`_,; as well as nearly all of the; `Embarcadero C++ type traits; <http://docwiki.embarcadero.com/RADStudio/Rio/en/Type_Trait_Functions_(C%2B%2B11)_Index>`_. The following type trait primitives are supported by Clang. Those traits marked; (C++) provide implementations for type traits specified by the C++ standard;; ``__X(...)`` has the same semantics and constraints as the corresponding; ``std:",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:57049,simpl,simplify,57049,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['simpl'],['simplify']
Usability,"; a convergence token operand to define the set of communicating threads relative; to the operation that defined the token. Let ``U`` be a convergent operation other than a call to a convergence; control intrinsic, and ``D`` be the convergent operation that defines; the token value used as the ``convergencectrl`` operand to ``U``. Two; threads execute converged dynamic instances of ``U`` if and only if the; token value in both threads was returned by converged dynamic; instances of ``D``. .. note::. The text defines convergence token values as representing dynamic instances.; But if we were to assume that converged dynamic instances produce the same; token value, then we could almost think of the token value as representing a; set of threads instead -- specifically, the set ``S`` of threads that; executed converged dynamic instances of the defining instruction ``D``. In this intuitive picture, when a convergence token value ``T`` is used by a; ``convergencectrl`` bundle on an instruction ``I``, then the set of threads that; communicates in ``I`` is a subset of the set ``S`` represented by the token value.; Specifically, it is the subset of threads that ends up executing ``I`` while; using the token value. This by itself wouldn't quite work as a definition: what if ``I`` is executed; multiple times by the same threads? Which execution of ``I`` in thread 1; communicates with which execution of ``I`` in thread 2? Leaning on the notion; of dynamic instances gives a robust answer to this question as long as ``D``; and ``I`` are at the same loop (or cycle) nesting level. The case where ``D`` and ``I`` are at different loop nesting levels is; forbidden by the :ref:`static rules <convergence_static_rules>` -- handling; that case is the purpose of :ref:`llvm.experimental.convergence.loop; <llvm.experimental.convergence.loop>`. .. _convergence_control_intrinsics:. Convergence Control Intrinsics; ==============================. This section describes target-independent intrinsi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergentOperations.rst:20874,intuit,intuitive,20874,interpreter/llvm-project/llvm/docs/ConvergentOperations.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergentOperations.rst,1,['intuit'],['intuitive']
Usability,"; an error if a user program used that simple variable name. ""dpy""; was a pointer to a ""Display"". PostScript and PDF. Now, a text with size 0 is not drawn in PDF files. An invalid; PDF file is created if a text with size 0 is produced.; The landscape orientation is now correct in pdf files. gv recognizes; the files as ""Landscape"" and the orientation is not upside down; as it was before (seascape).; In PostScript and PDF files the method DrawPS is used to write; a single (x,y) position.; This case was not treated correctly and, because of that, the PS and PDF; files might contain useless attributes settings. That was only a few; bytes more in the file but they were useless. TLegend. When a object is added ""by name"" in a legend, the; TMultiGraph and THStack present in the current pad; are scanned if an object with this name has not been; found in the pad. Previously the graphs and histograms; were hidden in multi-graphs and histogram-stacks when one; tried to add them by name.; New reference guide. TGaxis. In PaintAxis The option ""U"", for unlabeled axis, was not; implemented in case of alphanumeric axis' labels.; On log-scale TGAxis, with labels having lower values than 1 and ticks marks; set to the positive side, alignement issues seem to come up.; The following example shows four TGAxis drawn respectively with the; following options: RG-, RG+, LG-, LG+. For the RG+ and LG+ options,; the 10E-1 and 10E-2 labels were ill-aligned, showing a shift to the right; compared to the 1E2, 1E1 and 1 labels.; ; {; c1 = new TCanvas(""c1"",""Examples of Log TGaxis"",10,10,700,500);; c1->Range(-10,-1,10,1);; TGaxis *axis1 = new TGaxis(-7,-0.8,-7,0.8,0.01,100,50510,""RG-"");; axis1->SetTitle(""RG-""); axis1->Draw();; TGaxis *axis2 = new TGaxis(-2,-0.8,-2,0.8,0.01,100,50510,""RG+"");; axis2->SetLabelOffset(-0.04); axis2->SetTitleOffset(-1.5);; axis2->SetTitle(""RG+""); axis2->Draw();; TGaxis *axis3 = new TGaxis(2,-0.8,2,0.8,0.01,100,50510,""LG-"");; axis3->SetLabelOffset(-0.04);; axis3->SetTitle(""L",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/doc/v524/index.html:1543,guid,guide,1543,graf2d/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/doc/v524/index.html,1,['guid'],['guide']
Usability,"; and functions that capture the builtin function data from the TableGen; definitions in a compact manner. - OpenCL specific code in ``SemaLookup.cpp``. When ``Sema::LookupBuiltin``; encounters a potential builtin function, it will check if the name corresponds; to a valid OpenCL builtin function. If so, all overloads of the function are; inserted using ``InsertOCLBuiltinDeclarationsFromTable`` and overload; resolution takes place. OpenCL Extensions and Features; ------------------------------. Clang implements various extensions to OpenCL kernel languages. New functionality is accepted as soon as the documentation is detailed to the; level sufficient to be implemented. There should be an evidence that the; extension is designed with implementation feasibility in consideration and; assessment of complexity for C/C++ based compilers. Alternatively, the; documentation can be accepted in a format of a draft that can be further; refined during the implementation. Implementation guidelines; ^^^^^^^^^^^^^^^^^^^^^^^^^. This section explains how to extend clang with the new functionality. **Parsing functionality**. If an extension modifies the standard parsing it needs to be added to; the clang frontend source code. This also means that the associated macro; indicating the presence of the extension should be added to clang. The default flow for adding a new extension into the frontend is to; modify `OpenCLExtensions.def; <https://github.com/llvm/llvm-project/blob/main/clang/include/clang/Basic/OpenCLExtensions.def>`__,; containing the list of all extensions and optional features supported by; the frontend. This will add the macro automatically and also add a field in the target; options ``clang::TargetOptions::OpenCLFeaturesMap`` to control the exposure; of the new extension during the compilation. Note that by default targets like `SPIR-V`, `SPIR` or `X86` expose all the OpenCL; extensions. For all other targets the configuration has to be made explicitly. Note that the ta",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst:8233,guid,guidelines,8233,interpreter/llvm-project/clang/docs/OpenCLSupport.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst,1,['guid'],['guidelines']
Usability,"; and greater than 0.0 to enable cache. This value can be overridden by the; environment variable ROOT_TTREECACHE_SIZE. The resource variable TTreeCache.Prefill sets the default TTreeCache prefilling; type. The prefill type may be: 0 for no prefilling and 1 to prefill all; the branches. It can be overridden by the environment variable ROOT_TTREECACHE_PREFILL. In particular the default can be set back to the same as in version 5 by; setting TTreeCache.Size (or ROOT_TTREECACHE_SIZE) and TTreeCache.Prefill; (or ROOT_TTREECACHE_PREFILL) both to zero. TTree methods which are expected to modify a cache, like AddBranchToCache, will; attempt to setup a cache of default size if one does not exist, irrespective of; whether the auto cache creation is enabled. Additionally several methods giving; control of the cache have changed return type from void to Int_t, to be able to; return a code to indicate if there was an error. Usually TTree::SetCacheSize will no longer reset the list of branches to be; cached (either set or previously learnt) nor restart the learning phase.; The learning phase is restarted when a new cache is created, e.g. after having; removed a cache with SetCacheSize(0). ### TSelectorDraw. The axis titles in case of a `x:y:z` plot with the option `COLZ` were not correct. ### TParallelCoordVar. Change the format used to print the variables limit for ||-Coord to `%g`. It was; `%6.4f` before. ## Histogram Libraries. ### TFormula. - New version of the TFormula class based on Cling. Formula expressions are now used to create functions which are passed to Cling to be Just In Time compiled.; The expression is therefore compiled using Clang/LLVVM which will give execution time as compiled code and in addition correctness of the result obtained.; - This class is not 100% backward compatible with the old TFormula class, which is still available in ROOT as =ROOT::v5::TFormula=.; Some of the TFormula member funtions available in version 5, such as =Analyze= and =AnalyzeFun",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v604/index.md:14772,learn,learnt,14772,README/ReleaseNotes/v604/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v604/index.md,2,['learn'],"['learning', 'learnt']"
Usability,"; arrays are composite types. Simple types are also called primitive; types, basic types, and Cling sometimes calls them fundamental types. When we say, ""writing an object to a file"", we actually mean writing the; current values of the data members. The most common way to do this is to; decompose (also called the serialization of) the object into its data; members and write them to disk. The decomposition is the job of the; `Streamer`. Every class with ambitions to be stored in a file has a; `Streamer `that decomposes it and ""streams"" its members into a buffer. The methods of the class are not written to the file, it contains only; the persistent data members. To decompose the parent classes, the; `Streamer `calls the `Streamer `of the parent classes. It moves up the; inheritance tree until it reaches an ancestor without a parent. To; serialize the object data members it calls their `Streamer`. They in; turn move up their own inheritance tree and so forth. The simple data; members are written to the buffer directly. Eventually the buffer; contains all simple data members of all the classes that make up this; particular object. Data members that are references (as; `MyClass &fObj;`) are never saved, it is always the responsibility of; the object's constructor to set them properly. ### Automatically Generated Streamers. A `Streamer `usually calls other `Streamers`: the `Streamer `of its; parents and data members. This architecture depends on all classes; having `Streamers`, because eventually they will be called. To ensure; that a class has a `Streamer`, `rootcling` automatically creates one in; the `ClassDef` macro that is defined in `$ROOTSYS/include/Rtypes.h`.; `ClassDef` defines several methods for any class, and one of them is the; `Streamer`. The automatically generated `Streamer `is complete and can; be used as long as no customization is needed. The `Event` class is defined in `$ROOTSYS/test/Event.h`. Looking at the; class definition, we find that it inherits f",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:43196,simpl,simple,43196,documentation/users-guide/InputOutput.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md,1,['simpl'],['simple']
Usability,"; call GCC. Although this makes the driver much more complicated than; might otherwise be necessary, we decided that being very compatible with; the gcc command line interface was worth it in order to allow users to; quickly test clang on their projects. Flexible; --------. The driver was designed to be flexible and easily accommodate new uses; as we grow the clang and LLVM infrastructure. As one example, the driver; can easily support the introduction of tools which have an integrated; assembler; something we hope to add to LLVM in the future. Similarly, most of the driver functionality is kept in a library which; can be used to build other tools which want to implement or accept a gcc; like interface. Low Overhead; ------------. The driver should have as little overhead as possible. In practice, we; found that the gcc driver by itself incurred a small but meaningful; overhead when compiling many small files. The driver doesn't do much; work compared to a compilation, but we have tried to keep it as; efficient as possible by following a few simple principles:. - Avoid memory allocation and string copying when possible.; - Don't parse arguments more than once.; - Provide a few simple interfaces for efficiently searching arguments. Simple; ------. Finally, the driver was designed to be ""as simple as possible"", given; the other goals. Notably, trying to be completely compatible with the; gcc driver adds a significant amount of complexity. However, the design; of the driver attempts to mitigate this complexity by dividing the; process into a number of independent stages instead of a single; monolithic task. Internal Design and Implementation; ==================================. .. contents::; :local:; :depth: 1. Internals Introduction; ----------------------. In order to satisfy the stated goals, the driver was designed to; completely subsume the functionality of the gcc executable; that is, the; driver should not need to delegate to gcc to perform subtasks. On; Darwin",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst:1974,simpl,simple,1974,interpreter/llvm-project/clang/docs/DriverInternals.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst,1,['simpl'],['simple']
Usability,"; calling it undefined behavior. Therefore we chose to delay destroying the; instance variables to a point at which message sends are clearly disallowed:; the point at which the root class's deallocation routines take over. In most code, the difference is not observable. It can, however, be observed; if an instance variable holds a strong reference to an object whose; deallocation will trigger a side-effect which must be carefully ordered with; respect to the destruction of the super class. Such code violates the design; principle that semantically important behavior should be explicit. A simple; fix is to clear the instance variable manually during ``dealloc``; a more; holistic solution is to move semantically important side-effects out of; ``dealloc`` and into a separate teardown phase which can rely on working with; well-formed objects. .. _arc.misc.autoreleasepool:. ``@autoreleasepool``; --------------------. To simplify the use of autorelease pools, and to bring them under the control; of the compiler, a new kind of statement is available in Objective-C. It is; written ``@autoreleasepool`` followed by a *compound-statement*, i.e. by a new; scope delimited by curly braces. Upon entry to this block, the current state; of the autorelease pool is captured. When the block is exited normally,; whether by fallthrough or directed control flow (such as ``return`` or; ``break``), the autorelease pool is restored to the saved state, releasing all; the objects in it. When the block is exited with an exception, the pool is not; drained. ``@autoreleasepool`` may be used in non-ARC translation units, with equivalent; semantics. A program is ill-formed if it refers to the ``NSAutoreleasePool`` class. .. admonition:: Rationale. Autorelease pools are clearly important for the compiler to reason about, but; it is far too much to expect the compiler to accurately reason about control; dependencies between two calls. It is also very easy to accidentally forget; to drain an autorelea",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:90509,simpl,simplify,90509,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['simpl'],['simplify']
Usability,"; class A { void func(); };; class B { void member(); };. cxxRecordDecl(hasMethod(hasName(""func""))) matches the declaration of; A but not B. Matcher<CXXRecordDecl>isDerivedFromMatcher<NamedDecl> Base; Matches C++ classes that are directly or indirectly derived from a class; matching Base, or Objective-C classes that directly or indirectly; subclass a class matching Base. Note that a class is not considered to be derived from itself. Example matches Y, Z, C (Base == hasName(""X"")); class X;; class Y : public X {}; // directly derived; class Z : public Y {}; // indirectly derived; typedef X A;; typedef A B;; class C : public B {}; // derived from a typedef of X. In the following example, Bar matches isDerivedFrom(hasName(""X"")):; class Foo;; typedef Foo X;; class Bar : public Foo {}; // derived from a type that X is a typedef of. In the following example, Bar matches isDerivedFrom(hasName(""NSObject"")); @interface NSObject @end; @interface Bar : NSObject @end. Usable as: Matcher<CXXRecordDecl>, Matcher<ObjCInterfaceDecl>. Matcher<CXXRecordDecl>isDirectlyDerivedFromMatcher<NamedDecl> Base; Matches C++ or Objective-C classes that are directly derived from a class; matching Base. Note that a class is not considered to be derived from itself. Example matches Y, C (Base == hasName(""X"")); class X;; class Y : public X {}; // directly derived; class Z : public Y {}; // indirectly derived; typedef X A;; typedef A B;; class C : public B {}; // derived from a typedef of X. In the following example, Bar matches isDerivedFrom(hasName(""X"")):; class Foo;; typedef Foo X;; class Bar : public Foo {}; // derived from a type that X is a typedef of. Matcher<CXXRecordDecl>isSameOrDerivedFromMatcher<NamedDecl> Base; Similar to isDerivedFrom(), but also matches classes that directly; match Base. Matcher<CXXRewrittenBinaryOperator>hasEitherOperandMatcher<Expr> InnerMatcher; Matches if either the left hand side or the right hand side of a; binary operator or fold expression matches. Matcher<CXXRew",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:167827,Usab,Usable,167827,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['Usab'],['Usable']
Usability,"; configuration for the LLVM project which will build the fastest or; **RelWithDebInfo** which is also several time larger than Release.; Another technique is to build all of LLVM in Release mode and change; compiler flags, disabling optimization and enabling debug information, only; for specific libraries or source files you actually need to debug. 14. Test LLVM in Visual Studio:. You can run LLVM tests by merely building the project ""check-all"". The test; results will be shown in the VS output window. Once the build succeeds, you; have verified a working LLVM development environment!. You should not see any unexpected failures, but will see many unsupported; tests and expected failures:. ::. 114>Testing Time: 1124.66s; 114> Skipped : 39; 114> Unsupported : 21649; 114> Passed : 51615; 114> Expectedly Failed: 93; ========== Build: 114 succeeded, 0 failed, 321 up-to-date, 0 skipped ==========``. Alternatives to manual installation; ===================================; Instead of the steps above, to simplify the installation procedure you can use; `Chocolatey <https://chocolatey.org/>`_ as package manager.; After the `installation <https://chocolatey.org/install>`_ of Chocolatey,; run these commands in an admin shell to install the required tools:. .. code-block:: bat. choco install -y git cmake python3; pip3 install psutil. There is also a Windows; `Dockerfile <https://github.com/llvm/llvm-zorg/blob/main/buildbot/google/docker/windows-base-vscode2019/Dockerfile>`_; with the entire build tool chain. This can be used to test the build with a; tool chain different from your host installation or to create build servers. Next steps; ==========; 1. Read the documentation.; 2. Seriously, read the documentation.; 3. Remember that you were warned twice about reading the documentation. Test LLVM on the command line:; ------------------------------; The LLVM tests can be run by changing directory to the llvm source; directory and running:. .. code-block:: bat. c:\llvm> python ..",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStartedVS.rst:8088,simpl,simplify,8088,interpreter/llvm-project/llvm/docs/GettingStartedVS.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStartedVS.rst,1,['simpl'],['simplify']
Usability,"; def : InstAlias<""movsx $src, $dst"", (MOVSX64rr32 GR64:$dst, GR32 :$src)>;. This shows a powerful example of the instruction aliases, matching the same; mnemonic in multiple different ways depending on what operands are present in; the assembly. The result of instruction aliases can include operands in a; different order than the destination instruction, and can use an input multiple; times, for example:. ::. def : InstAlias<""clrb $reg"", (XOR8rr GR8 :$reg, GR8 :$reg)>;; def : InstAlias<""clrw $reg"", (XOR16rr GR16:$reg, GR16:$reg)>;; def : InstAlias<""clrl $reg"", (XOR32rr GR32:$reg, GR32:$reg)>;; def : InstAlias<""clrq $reg"", (XOR64rr GR64:$reg, GR64:$reg)>;. This example also shows that tied operands are only listed once. In the X86; backend, XOR8rr has two input GR8's and one output GR8 (where an input is tied; to the output). InstAliases take a flattened operand list without duplicates; for tied operands. The result of an instruction alias can also use immediates; and fixed physical registers which are added as simple immediate operands in the; result, for example:. ::. // Fixed Immediate operand.; def : InstAlias<""aad"", (AAD8i8 10)>;. // Fixed register operand.; def : InstAlias<""fcomi"", (COM_FIr ST1)>;. // Simple alias.; def : InstAlias<""fcomi $reg"", (COM_FIr RST:$reg)>;. Instruction aliases can also have a Requires clause to make them subtarget; specific. If the back-end supports it, the instruction printer can automatically emit the; alias rather than what's being aliased. It typically leads to better, more; readable code. If it's better to print out what's being aliased, then pass a '0'; as the third parameter to the InstAlias definition. Instruction Matching; --------------------. .. note::. To Be Written. .. _Implementations of the abstract target description interfaces:; .. _implement the target description:. Target-specific Implementation Notes; ====================================. This section of the document explains features or design decisions that are;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:85139,simpl,simple,85139,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,1,['simpl'],['simple']
Usability,"; event, and we would like to compute `Px2 + Py2` for every event; and histogram the result. If we had saved the million events without a **`TTree`** we would have; to:. - read each event in its entirety into memory; - extract the `Px` and `Py` from the event; - compute the sum of the squares; - fill a histogram. We would have to do that a million times! This is very time consuming,; and we really do not need to read the entire event, every time. All we; need are two little data members (`Px` and `Py`). On the other hand, if; we use a tree with one branch containing `Px` and another branch; containing `Py`, we can read all values of `Px` and `Py` by only reading; the `Px` and `Py` branches. This makes the use of the **`TTree`** very; attractive. ## A Simple TTree. This script builds a **`TTree`** from an ASCII file containing; statistics about the staff at CERN. This script, `cernbuild.C` and its input; file `cernstaff.dat` are in `$ROOTSYS/tutorials/tree`. ``` {.cpp}; {; // Simplified version of cernbuild.C.; // This macro to read data from an ascii file and; // create a root file with a TTree. Int_t Category;; UInt_t Flag;; Int_t Age;; Int_t Service;; Int_t Children;; Int_t Grade;; Int_t Step;; Int_t Hrweek;; Int_t Cost;; Char_t Division[4];; Char_t Nation[3];. FILE *fp = fopen(""cernstaff.dat"",""r"");. TFile *hfile = hfile = TFile::Open(""cernstaff.root"",""RECREATE"");. TTree *tree = new TTree(""T"",""CERN 1988 staff data"");; tree->Branch(""Category"",&Category,""Category/I"");; tree->Branch(""Flag"",&Flag,""Flag/i"");; tree->Branch(""Age"",&Age,""Age/I"");; tree->Branch(""Service"",&Service,""Service/I"");; tree->Branch(""Children"",&Children,""Children/I"");; tree->Branch(""Grade"",&Grade,""Grade/I"");; tree->Branch(""Step"",&Step,""Step/I"");; tree->Branch(""Hrweek"",&Hrweek,""Hrweek/I"");; tree->Branch(""Cost"",&Cost,""Cost/I"");; tree->Branch(""Division"",Division,""Division/C"");; tree->Branch(""Nation"",Nation,""Nation/C"");; char line[80];; while (fgets(line,80,fp)) {; sscanf(&line[0],""%d %d %d %d %d %d %d ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:2879,Simpl,Simplified,2879,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['Simpl'],['Simplified']
Usability,"; function with parameters, called `[0]`, `[1]` and so on in the ROOT; formula syntax. We now need a way to assign values to these parameters;; this is achieved with the method; `SetParameter(<parameter_number>,<parameter_value>)` of class `TF1`.; Here is an example:. ``` {.cpp}; root [13] TF1 f2(""f2"",""[0]*sin([1]*x)/x"",0.,10.);; root [14] f2.SetParameter(0,1);; root [15] f2.SetParameter(1,1);; root [16] f2.Draw();; ```. Of course, this version shows the same results as the initial one. Try; playing with the parameters and plot the function again. The class `TF1`; has a large number of very useful methods, including integration and; differentiation. To make full use of this and other ROOT classes, visit; the documentation on the Internet under; <https://root.cern/doc/master/>. Formulae in ROOT; are evaluated using the class `TFormula`, so also look up the relevant; class documentation for examples, implemented functions and syntax. You should definitely download this guide to your own system to have it; at you disposal whenever you need it. To extend a little bit on the above example, consider a more complex; function you would like to define. You can also do this using standard; `C` or `C++` code. Consider the example below, which calculates and displays the; interference pattern produced by light falling on a multiple slit.; Please do not type in the example below at the ROOT command line, there; is a much simpler way: Make sure you have the file `slits.C` on disk,; and type `root slits.C` in the shell. This will start root and make it; read the ""macro"" `slits.C`, i.e. all the lines in the file will be; executed one after the other. ``` {.cpp .numberLines}; @ROOT_INCLUDE_FILE macros/slits.C; ```; [f21]: figures/TF1_DoubleSlit.png ""f21""; <a name=""f21""></a>. ![Output of slits.C with parameters 0.2 and 2.\label{f21}][f21]. The example first asks for user input, namely the ratio of slit width; over slit distance, and the number of slits. After entering this; informatio",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md:4888,guid,guide,4888,documentation/primer/ROOT_as_calculator.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md,1,['guid'],['guide']
Usability,"; something goes wrong. As the method described here also works without; using PROOF, the development work on an analysis script can be done in; the standard way on a small subset of the data, and only for the full; processing one would use parallelism via PROOF. It is worth to remind the reader that the speed of typical data analysis; programs limited by the I/O speed (for example the latencies implied by; reading data from a hard drive). It is therefore expected that this; limitation cannot be eliminated with the usage of any parallel analysis; toolkit. ### Optimisation Regarding N-tuples ###. ROOT automatically applies compression algorithms on n-tuples to reduce; the memory consumption. A value that is in most cases the same will; consume only small space on your disk (but it has to be decompressed on; reading). Nevertheless, you should think about the design of your; n-tuples and your analyses as soon as the processing time exceeds some; minutes. - Try to keep your n-tuples simple and use appropriate variable types.; If your measurement has only a limited precision, it is needless to; store it with double precision. - Experimental conditions that do not change with every single; measurement should be stored in a separate tree. Although the; compression can handle redundant values, the processing time; increase with every variable that has to be filled. - The function `SetCacheSize(long)` specifies the size of the cache; for reading a `TTree` object from a file. The default value is 30MB.; A manual increase may help in certain situations. Please note that; the caching mechanism can cover only one `TTree` object per `TFile`; object. - You can select the branches to be covered by the caching algorithm; with `AddBranchToCache` and deactivate unneeded branches with; `SetBranchStatus`. This mechanism can result in a significant; speed-up for simple operations on trees with many branches. - You can measure the performance easily with `TTreePerfStats`. The; ROOT documen",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md:13664,simpl,simple,13664,documentation/primer/filio.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md,1,['simpl'],['simple']
Usability,"; the assembly. The result of instruction aliases can include operands in a; different order than the destination instruction, and can use an input multiple; times, for example:. ::. def : InstAlias<""clrb $reg"", (XOR8rr GR8 :$reg, GR8 :$reg)>;; def : InstAlias<""clrw $reg"", (XOR16rr GR16:$reg, GR16:$reg)>;; def : InstAlias<""clrl $reg"", (XOR32rr GR32:$reg, GR32:$reg)>;; def : InstAlias<""clrq $reg"", (XOR64rr GR64:$reg, GR64:$reg)>;. This example also shows that tied operands are only listed once. In the X86; backend, XOR8rr has two input GR8's and one output GR8 (where an input is tied; to the output). InstAliases take a flattened operand list without duplicates; for tied operands. The result of an instruction alias can also use immediates; and fixed physical registers which are added as simple immediate operands in the; result, for example:. ::. // Fixed Immediate operand.; def : InstAlias<""aad"", (AAD8i8 10)>;. // Fixed register operand.; def : InstAlias<""fcomi"", (COM_FIr ST1)>;. // Simple alias.; def : InstAlias<""fcomi $reg"", (COM_FIr RST:$reg)>;. Instruction aliases can also have a Requires clause to make them subtarget; specific. If the back-end supports it, the instruction printer can automatically emit the; alias rather than what's being aliased. It typically leads to better, more; readable code. If it's better to print out what's being aliased, then pass a '0'; as the third parameter to the InstAlias definition. Instruction Matching; --------------------. .. note::. To Be Written. .. _Implementations of the abstract target description interfaces:; .. _implement the target description:. Target-specific Implementation Notes; ====================================. This section of the document explains features or design decisions that are; specific to the code generator for a particular target. .. _tail call section:. Tail call optimization; ----------------------. Tail call optimization, callee reusing the stack of the caller, is currently; supported on x86/x86-64, ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:85339,Simpl,Simple,85339,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,1,['Simpl'],['Simple']
Usability,"; type operand provided as input, the input value will be split into multiple; registers, and all of them passed to the inline asm. However, this feature is often not as useful as you might think. Firstly, the registers are *not* guaranteed to be consecutive. So, on those; architectures that have instructions which operate on multiple consecutive; instructions, this is not an appropriate way to support them. (e.g. the 32-bit; SparcV8 has a 64-bit load, which instruction takes a single 32-bit register. The; hardware then loads into both the named register, and the next register. This; feature of inline asm would not be useful to support that.). A few of the targets provide a template string modifier allowing explicit access; to the second register of a two-register operand (e.g. MIPS ``L``, ``M``, and; ``D``). On such an architecture, you can actually access the second allocated; register (yet, still, not any subsequent ones). But, in that case, you're still; probably better off simply splitting the value into two separate operands, for; clarity. (e.g. see the description of the ``A`` constraint on X86, which,; despite existing only for use with this feature, is not really a good idea to; use). Indirect inputs and outputs; """""""""""""""""""""""""""""""""""""""""""""""""""""". Indirect output or input constraints can be specified by the ""``*``"" modifier; (which goes after the ""``=``"" in case of an output). This indicates that the asm; will write to or read from the contents of an *address* provided as an input; argument. (Note that in this way, indirect outputs act more like an *input* than; an output: just like an input, they consume an argument of the call expression,; rather than producing a return value. An indirect output constraint is an; ""output"" only in that the asm is expected to write to the contents of the input; memory location, instead of just read from it). This is most typically used for memory constraint, e.g. ""``=*m``"", to pass the; address of a variable as a value. It is als",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:215317,simpl,simply,215317,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['simpl'],['simply']
Usability,"; with safe_int:. fieldDecl(; hasType(asString(""int"")); ).bind(""use_safe_int""). given:. struct S {; int m_i;; };. template <typename T> struct TemplStruct {; TemplStruct() {}; ~TemplStruct() {}. private:; T m_t;; };. void instantiate() { TemplStruct<int> ti; }. 2 matches found. Replacement produces incorrect output:. struct S {; safe_int m_i;; };. template <typename T> struct TemplStruct {; TemplStruct() {}; ~TemplStruct() {}. private:; safe_int m_t;; };. void instantiate() { TemplStruct<int> ti; }. 1 match found. Replacement produces correct output:. struct S {; safe_int m_i;; };. template <typename T> struct TemplStruct {; TemplStruct() {}; ~TemplStruct() {}. private:; T m_t;; };. void instantiate() { TemplStruct<int> ti; }. Add prefix to member initializer. cxxCtorInitializer(; forField(fieldDecl()); ).bind(""add_prefix""). given:. struct Simple {};. struct Record {; Record() : i(42) {}; private:; int i;; Simple s;; };. 2 matches found. Replacement produces incorrect output:. struct Simple {};. struct Record {; m_Record() : m_i(42) {}; private:; int i;; Simple s;; };. 1 match found. Replacement produces correct output:. struct Simple {};. struct Record {; Record() : m_i(42) {}; private:; int i;; Simple s;; };. Ignored default arguments. callExpr(; callee(functionDecl(; hasName(""hasDefaultArg""); )),; argumentCountIs(1); ).bind(""add_prefix""). given:. void hasDefaultArg(int i, int j = 0) {}; void callDefaultArg() { hasDefaultArg(42); }. No match. 1 match found. Lambda fields. fieldDecl(; hasType(asString(""int"")); ).bind(""make_safe""). given:. struct S {; int m_i;; };. void func() {; int a = 0;; int c = 0;. auto l = [a, b = c](int d) { int e = d; };; l(43);; }. 2 matches found. Replacement produces incorrect output:. struct S {; safe_int m_i;; };. void func() {; int a = 0;; int c = 0;. auto l = [safe_a, safe_b = c](int d) { int e = d; };; l(43);; }. 1 match found. Replacement produces correct output:. struct S {; safe_int m_i;; };. void func() {; int a = 0;; int c = 0;. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:6103,Simpl,Simple,6103,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['Simpl'],['Simple']
Usability,";. The ``CalcValue`` class is invoked with the template argument ``arg``. It; calculates a value for the ``ret`` field, which is then retrieved at the; ""point of call"" in the initialization for the Result field. The anonymous; record created in this example serves no other purpose than to carry the; result value. Here is a practical example. The class ``isValidSize`` determines whether a; specified number of bytes represents a valid data size. The bit ``ret`` is; set appropriately. The field ``ValidSize`` obtains its initial value by; invoking ``isValidSize`` with the data size and retrieving the ``ret`` field; from the resulting anonymous record. .. code-block:: text. class isValidSize<int size> {; bit ret = !cond(!eq(size, 1): 1,; !eq(size, 2): 1,; !eq(size, 4): 1,; !eq(size, 8): 1,; !eq(size, 16): 1,; true: 0);; }. def Data1 {; int Size = ...;; bit ValidSize = isValidSize<Size>.ret;; }. Preprocessing Facilities; ========================. The preprocessor embedded in TableGen is intended only for simple; conditional compilation. It supports the following directives, which are; specified somewhat informally. .. productionlist::; LineBegin: beginning of line; LineEnd: newline | return | EOF; WhiteSpace: space | tab; CComment: ""/*"" ... ""*/""; BCPLComment: ""//"" ... `LineEnd`; WhiteSpaceOrCComment: `WhiteSpace` | `CComment`; WhiteSpaceOrAnyComment: `WhiteSpace` | `CComment` | `BCPLComment`; MacroName: `ualpha` (`ualpha` | ""0""...""9"")*; PreDefine: `LineBegin` (`WhiteSpaceOrCComment`)*; : ""#define"" (`WhiteSpace`)+ `MacroName`; : (`WhiteSpaceOrAnyComment`)* `LineEnd`; PreIfdef: `LineBegin` (`WhiteSpaceOrCComment`)*; : (""#ifdef"" | ""#ifndef"") (`WhiteSpace`)+ `MacroName`; : (`WhiteSpaceOrAnyComment`)* `LineEnd`; PreElse: `LineBegin` (`WhiteSpaceOrCComment`)*; : ""#else"" (`WhiteSpaceOrAnyComment`)* `LineEnd`; PreEndif: `LineBegin` (`WhiteSpaceOrCComment`)*; : ""#endif"" (`WhiteSpaceOrAnyComment`)* `LineEnd`. ..; PreRegContentException: `PreIfdef` | `PreElse` | `PreEndif` | EOF; Pr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst:56705,simpl,simple,56705,interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,1,['simpl'],['simple']
Usability,";; const int a = 5;; static_assert(*p == 5, ""x"");. TargetPointer; ~~~~~~~~~~~~~. While null pointer arithmetic or integer-to-pointer conversion is; banned in constexpr, some expressions on target offsets must be folded,; replicating the behaviour of the ``offsetof`` builtin. Target pointers; are characterised by 3 offsets: a field offset, an array offset and a; base offset, along with a descriptor specifying the type the pointer is; supposed to refer to. Array indexing adjusts the array offset, while the; field offset is adjusted when a pointer to a member is created. Casting; an integer to a pointer sets the value of the base offset. As a special; case, null pointers are target pointers with all offsets set to 0. TypeInfoPointer; ~~~~~~~~~~~~~~~. ``TypeInfoPointer`` tracks two types: the type assigned to; ``std::type_info`` and the type which was passed to ``typeinfo``. InvalidPointer; ~~~~~~~~~~~~~~. Such pointers are built by operations which cannot generate valid; pointers, allowing the interpreter to continue execution after emitting; a warning. Inspecting such a pointer stops execution. TODO; ====. Missing Language Features; -------------------------. * Changing the active field of unions; * ``volatile``; * ``__builtin_constant_p``; * ``dynamic_cast``; * ``new`` and ``delete``; * Fixed Point numbers and arithmetic on Complex numbers; * Several builtin methods, including string operations and; ``__builtin_bit_cast``; * Continue-after-failure: a form of exception handling at the bytecode; level should be implemented to allow execution to resume. As an example,; argument evaluation should resume after the computation of an argument fails.; * Pointer-to-Integer conversions; * Lazy descriptors: the interpreter creates a ``Record`` and ``Descriptor``; when it encounters a type: ones which are not yet defined should be lazily; created when required. Known Bugs; ----------. * If execution fails, memory storing APInts and APFloats is leaked when the; stack is cleared; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ConstantInterpreter.rst:14626,resume,resume,14626,interpreter/llvm-project/clang/docs/ConstantInterpreter.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ConstantInterpreter.rst,3,"['clear', 'resume']","['cleared', 'resume']"
Usability,";; if (s1 != s2); return;; }. struct HasSpaceship; {; bool operator<=>(const HasOpEq &) const;; };. void use_spaceship(); {; HasSpaceship s1;; HasSpaceship s2;; if (s1 != s2); return;; }. Matcher<*>eachOfMatcher<*>, ..., Matcher<*>; Matches if any of the given matchers matches. Unlike anyOf, eachOf will generate a match result for each; matching submatcher. For example, in:; class A { int a; int b; };; The matcher:; cxxRecordDecl(eachOf(has(fieldDecl(hasName(""a"")).bind(""v"")),; has(fieldDecl(hasName(""b"")).bind(""v"")))); will generate two results binding ""v"", the first of which binds; the field declaration of a, the second the field declaration of; b. Usable as: Any Matcher. Matcher<*>findAllMatcher<*> Matcher; Matches if the node or any descendant matches. Generates results for each match. For example, in:; class A { class B {}; class C {}; };; The matcher:; cxxRecordDecl(hasName(""::A""),; findAll(cxxRecordDecl(isDefinition()).bind(""m""))); will generate results for A, B and C. Usable as: Any Matcher. Matcher<*>forEachDescendantMatcher<*>; Matches AST nodes that have descendant AST nodes that match the; provided matcher. Example matches X, A, A::X, B, B::C, B::C::X; (matcher = cxxRecordDecl(forEachDescendant(cxxRecordDecl(hasName(""X""))))); class X {};; class A { class X {}; }; // Matches A, because A::X is a class of name; // X inside A.; class B { class C { class X {}; }; };. DescendantT must be an AST base type. As opposed to 'hasDescendant', 'forEachDescendant' will cause a match for; each result that matches instead of only on the first one. Note: Recursively combined ForEachDescendant can cause many matches:; cxxRecordDecl(forEachDescendant(cxxRecordDecl(; forEachDescendant(cxxRecordDecl()); ))); will match 10 times (plus injected class name matches) on:; class A { class B { class C { class D { class E {}; }; }; }; };. Usable as: Any Matcher. Matcher<*>forEachMatcher<*>; Matches AST nodes that have child AST nodes that match the; provided matcher. Example matches X",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:132071,Usab,Usable,132071,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['Usab'],['Usable']
Usability,";; return nullptr;; }. The ``LogError`` routines are simple helper routines that our parser will; use to handle errors. The error recovery in our parser will not be the; best and is not particular user-friendly, but it will be enough for our; tutorial. These routines make it easier to handle errors in routines; that have various return types: they always return null. With these basic helper functions, we can implement the first piece of; our grammar: numeric literals. Basic Expression Parsing; ========================. We start with numeric literals, because they are the simplest to; process. For each production in our grammar, we'll define a function; which parses that production. For numeric literals, we have:. .. code-block:: c++. /// numberexpr ::= number; static std::unique_ptr<ExprAST> ParseNumberExpr() {; auto Result = std::make_unique<NumberExprAST>(NumVal);; getNextToken(); // consume the number; return std::move(Result);; }. This routine is very simple: it expects to be called when the current; token is a ``tok_number`` token. It takes the current number value,; creates a ``NumberExprAST`` node, advances the lexer to the next token,; and finally returns. There are some interesting aspects to this. The most important one is; that this routine eats all of the tokens that correspond to the; production and returns the lexer buffer with the next token (which is; not part of the grammar production) ready to go. This is a fairly; standard way to go for recursive descent parsers. For a better example,; the parenthesis operator is defined like this:. .. code-block:: c++. /// parenexpr ::= '(' expression ')'; static std::unique_ptr<ExprAST> ParseParenExpr() {; getNextToken(); // eat (.; auto V = ParseExpression();; if (!V); return nullptr;. if (CurTok != ')'); return LogError(""expected ')'"");; getNextToken(); // eat ).; return V;; }. This function illustrates a number of interesting things about the; parser:. 1) It shows how we use the LogError routines. When called",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst:7563,simpl,simple,7563,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst,1,['simpl'],['simple']
Usability,";; }; ------------- Defs -----------------; def HelloWorld { // Hello; string msg = ""Hello world!"";; }; ```; [Try this example on Compiler Explorer.](https://godbolt.org/z/13xo1P5oz). The internalized records are passed on to various backends, which extract; information from a subset of the records and generate one or more output files. These output files are typically .inc files for C++, but may be any type of file; that the backend developer needs. Resources for learning the language:; * [TableGen Overview](https://llvm.org/docs/TableGen/index.html); * [Programmer's reference guide](https://llvm.org/docs/TableGen/ProgRef.html); * [Tutorial](jupyter/tablegen_tutorial_part_1.ipynb); * [Tools for Learning LLVM TableGen](https://blog.llvm.org/posts/2023-12-07-tools-for-learning-llvm-tablegen/); * [Lessons in TableGen](https://www.youtube.com/watch?v=45gmF77JFBY) (video),; [slides](https://archive.fosdem.org/2019/schedule/event/llvm_tablegen/attachments/slides/3304/export/events/attachments/llvm_tablegen/slides/3304/tablegen.pdf); * [Improving Your TableGen Descriptions](https://www.youtube.com/watch?v=dIEVUlsiktQ); (video), [slides](https://llvm.org/devmtg/2019-10/slides/Absar-ImprovingYourTableGenDescription.pdf). Writing TableGen backends:; * [TableGen Backend Developer's Guide](https://llvm.org/docs/TableGen/BackGuide.html); * [How to write a TableGen backend](https://www.youtube.com/watch?v=UP-LBRbvI_U); (video), [slides](https://llvm.org/devmtg/2021-11/slides/2021-how-to-write-a-tablegen-backend.pdf), also available as a; 	[notebook](jupyter/sql_query_backend.ipynb). TableGen in MLIR:; * [Operation Definition Specification](https://mlir.llvm.org/docs/DefiningDialects/Operations/); * [Defining Dialect Attributes and Types](https://mlir.llvm.org/docs/DefiningDialects/AttributesAndTypes/). Useful tools:; * [TableGen Jupyter Kernel](jupyter/); * [TableGen LSP Language Server](https://mlir.llvm.org/docs/Tools/MLIRLSP/#tablegen-lsp-language-server--tblgen-lsp-server). ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/README.md:1897,Guid,Guide,1897,interpreter/llvm-project/llvm/utils/TableGen/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/README.md,1,['Guid'],['Guide']
Usability,"<< ""Hello.\n"";; }. with the following one:. .. code-block:: c++. module;; #include <iostream>; export module M;; export void Hello() {; std::cout << ""Hello.\n"";; }. .. code-block:: console. $ clang++ -std=c++20 -xc++-system-header --precompile iostream -o iostream.pcm; $ clang++ -std=c++20 -fmodule-file=iostream.pcm --precompile M.cppm -o M.cpp. In the latter example, the Clang could find the BMI for the ``<iostream>``; so it would try to replace the ``#include <iostream>`` to ``import <iostream>;`` automatically. Relationships between Clang modules; -----------------------------------. Header units have pretty similar semantics with Clang modules.; The semantics of both of them are like headers. In fact, we could even ""mimic"" the sytle of header units by Clang modules:. .. code-block:: c++. module ""iostream"" {; export *; header ""/path/to/libstdcxx/iostream""; }. .. code-block:: console. $ clang++ -std=c++20 -fimplicit-modules -fmodule-map-file=.modulemap main.cpp. It would be simpler if we are using libcxx:. .. code-block:: console. $ clang++ -std=c++20 main.cpp -fimplicit-modules -fimplicit-module-maps. Since there is already one; `module map <https://github.com/llvm/llvm-project/blob/main/libcxx/include/module.modulemap.in>`_; in the source of libcxx. Then immediately leads to the question: why don't we implement header units through Clang header modules?. The main reason for this is that Clang modules have more semantics like hierarchy or; wrapping multiple headers together as a big module.; However, these things are not part of Standard C++ Header units,; and we want to avoid the impression that these additional semantics get interpreted as Standard C++ behavior. Another reason is that there are proposals to introduce module mappers to the C++ standard; (for example, https://wg21.link/p1184r2).; If we decide to reuse Clang's modulemap, we may get in trouble once we need to introduce another module mapper. So the final answer for why we don't reuse the interface o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:31389,simpl,simpler,31389,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,1,['simpl'],['simpler']
Usability,"<Type>usingTypeMatcher<UsingType>...; Matches types specified through a using declaration. Given; namespace a { struct S {}; }; using a::S;; S s;. usingType() matches the type of the variable declaration of s. Matcher<Type>variableArrayTypeMatcher<VariableArrayType>...; Matches C arrays with a specified size that is not an; integer-constant-expression. Given; void f() {; int a[] = { 2, 3 }; int b[42];; int c[a[0]];; }; variableArrayType(); matches ""int c[a[0]]"". Narrowing Matchers. Narrowing matchers match certain attributes on the current node, thus; narrowing down the set of nodes of the current type to match on.; There are special logical narrowing matchers (allOf, anyOf, anything and unless); which allow users to create more powerful match expressions. Return typeNameParameters. Matcher<*>allOfMatcher<*>, ..., Matcher<*>; Matches if all given matchers match. Usable as: Any Matcher. Matcher<*>anyOfMatcher<*>, ..., Matcher<*>; Matches if any of the given matchers matches. Usable as: Any Matcher. Matcher<*>anything; Matches any node. Useful when another matcher requires a child matcher, but there's no; additional constraint. This will often be used with an explicit conversion; to an internal::Matcher<> type such as TypeMatcher. Example: DeclarationMatcher(anything()) matches all declarations, e.g.,; ""int* p"" and ""void f()"" in; int* p;; void f();. Usable as: Any Matcher. unspecifiedmapAnyOfnodeMatcherFunction...; Matches any of the NodeMatchers with InnerMatchers nested within. Given; if (true);; for (; true; );; with the matcher; mapAnyOf(ifStmt, forStmt).with(; hasCondition(cxxBoolLiteralExpr(equals(true))); ).bind(""trueCond""); matches the if and the for. It is equivalent to:; auto trueCond = hasCondition(cxxBoolLiteralExpr(equals(true)));; anyOf(; ifStmt(trueCond).bind(""trueCond""),; forStmt(trueCond).bind(""trueCond""); );. The with() chain-call accepts zero or more matchers which are combined; as-if with allOf() in each of the node matchers.; Usable as: Any Matche",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:53872,Usab,Usable,53872,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['Usab'],['Usable']
Usability,"<char> >::size_type) 1; [cling]$. Cling is built on the top of LLVM and Clang libraries. In addition to standard interpreters it has a command line prompt and uses just-in-time (JIT) compiler. This kind of software application is commonly known as an interactive compiler.; ; Cling started off as a contemporary, high-performance alternative of the current C++ interpreter in the ROOT project - CINT.; ; Why interpreting C++ with Cling?. Learning C++ . ; One use case of cling is to aid the C++ learning process. Offering imediate feedback the user can easily get familiar with the structures and spelling of the language. ; . Creating scripts; ; The power of an interpreter lays as well in the compactness and ease of repeatedly running a small snippet of code - aka a script. This can be done in cling by inserting the bash-like style line: ; . #!/usr/bin/cling; . Rapid Application Development (RAD) . ; Cling can be used successfully for Rapid Application Development allowing for prototyping and proofs of concept taking advantage of dynamicity and feedback during the implementation process.; . Runtime-Generated Code ; ; Sometime it's convenient to create code as a reaction to input; (user/network/configuration).; Runtime-generated code can interface with C++ libraries.; . Embedding Cling . The functionality of an application can be enriched by embedding Cling. To embed Cling, the main program has to be provided. One of the things this main program has to do is initialize the Cling interpreter. There are optional calls to pass command line arguments to Cling. Afterwards, you can call the interpreter from any anywhere within the application. For compilation and linkage the application needs the path to the clang and llvm libraries and the invocation is order dependent since the linker cannot do backward searches. g++ embedcling.cxx -std=c++11 -L/usr/local/lib; -lclingInterpreter -lclingUtils ; -lclangFrontend -lclangSerialization -lclangParse -lclangSema ; -lclangAnalysis -lclan",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/index.html:1386,feedback,feedback,1386,interpreter/cling/www/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/index.html,1,['feedback'],['feedback']
Usability,"= B[0];; }. The runtime condition (``rtc``) checks that the array ``A`` and the; element `B[0]` do not alias. Currently, this transformation does not support followup-attributes. Loop Interchange; ----------------. Currently, the ``LoopInterchange`` pass does not use any metadata. Ambiguous Transformation Order; ==============================. If there multiple transformations defined, the order in which they are; executed depends on the order in LLVM's pass pipeline, which is subject; to change. The default optimization pipeline (anything higher than; ``-O0``) has the following order. When using the legacy pass manager:. - LoopInterchange (if enabled); - SimpleLoopUnroll/LoopFullUnroll (only performs full unrolling); - VersioningLICM (if enabled); - LoopDistribute; - LoopVectorizer; - LoopUnrollAndJam (if enabled); - LoopUnroll (partial and runtime unrolling). When using the legacy pass manager with LTO:. - LoopInterchange (if enabled); - SimpleLoopUnroll/LoopFullUnroll (only performs full unrolling); - LoopVectorizer; - LoopUnroll (partial and runtime unrolling). When using the new pass manager:. - SimpleLoopUnroll/LoopFullUnroll (only performs full unrolling); - LoopDistribute; - LoopVectorizer; - LoopUnrollAndJam (if enabled); - LoopUnroll (partial and runtime unrolling). Leftover Transformations; ========================. Forced transformations that have not been applied after the last; transformation pass should be reported to the user. The transformation; passes themselves cannot be responsible for this reporting because they; might not be in the pipeline, there might be multiple passes able to; apply a transformation (e.g. ``LoopInterchange`` and Polly) or a; transformation attribute may be 'hidden' inside another passes' followup; attribute. The pass ``-transform-warning`` (``WarnMissedTransformationsPass``); emits such warnings. It should be placed after the last transformation; pass. The current pass pipeline has a fixed order in which transformations; pa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TransformMetadata.rst:14124,Simpl,SimpleLoopUnroll,14124,interpreter/llvm-project/llvm/docs/TransformMetadata.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TransformMetadata.rst,1,['Simpl'],['SimpleLoopUnroll']
Usability,"=. Coroutine Manipulation Intrinsics; ---------------------------------. Intrinsics described in this section are used to manipulate an existing; coroutine. They can be used in any function which happen to have a pointer; to a `coroutine frame`_ or a pointer to a `coroutine promise`_. .. _coro.destroy:. 'llvm.coro.destroy' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.coro.destroy(ptr <handle>). Overview:; """""""""""""""""". The '``llvm.coro.destroy``' intrinsic destroys a suspended; switched-resume coroutine. Arguments:; """""""""""""""""""". The argument is a coroutine handle to a suspended coroutine. Semantics:; """""""""""""""""""". When possible, the `coro.destroy` intrinsic is replaced with a direct call to; the coroutine destroy function. Otherwise it is replaced with an indirect call; based on the function pointer for the destroy function stored in the coroutine; frame. Destroying a coroutine that is not suspended leads to undefined behavior. .. _coro.resume:. 'llvm.coro.resume' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ::. declare void @llvm.coro.resume(ptr <handle>). Overview:; """""""""""""""""". The '``llvm.coro.resume``' intrinsic resumes a suspended switched-resume coroutine. Arguments:; """""""""""""""""""". The argument is a handle to a suspended coroutine. Semantics:; """""""""""""""""""". When possible, the `coro.resume` intrinsic is replaced with a direct call to the; coroutine resume function. Otherwise it is replaced with an indirect call based; on the function pointer for the resume function stored in the coroutine frame.; Resuming a coroutine that is not suspended leads to undefined behavior. .. _coro.done:. 'llvm.coro.done' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ::. declare i1 @llvm.coro.done(ptr <handle>). Overview:; """""""""""""""""". The '``llvm.coro.done``' intrinsic checks whether a suspended; switched-resume coroutine is at the final suspend point or not. Arguments:; """""""""""""""""""". The argument is a handle to a suspended coroutin",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:27715,resume,resume,27715,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"====. .. contents::; :local:. **This tutorial is under active development. It is incomplete and details may; change frequently.** Nonetheless we invite you to try it out as it stands, and; we welcome any feedback. Chapter 3 Introduction; ======================. **Warning: This text is currently out of date due to ORC API updates.**. **The example code has been updated and can be used. The text will be updated; once the API churn dies down.**. Welcome to Chapter 3 of the ""Building an ORC-based JIT in LLVM"" tutorial. This; chapter discusses lazy JITing and shows you how to enable it by adding an ORC; CompileOnDemand layer the JIT from `Chapter 2 <BuildingAJIT2.html>`_. Lazy Compilation; ================. When we add a module to the KaleidoscopeJIT class from Chapter 2 it is; immediately optimized, compiled and linked for us by the IRTransformLayer,; IRCompileLayer and RTDyldObjectLinkingLayer respectively. This scheme, where all the; work to make a Module executable is done up front, is simple to understand and; its performance characteristics are easy to reason about. However, it will lead; to very high startup times if the amount of code to be compiled is large, and; may also do a lot of unnecessary compilation if only a few compiled functions; are ever called at runtime. A truly ""just-in-time"" compiler should allow us to; defer the compilation of any given function until the moment that function is; first called, improving launch times and eliminating redundant work. In fact,; the ORC APIs provide us with a layer to lazily compile LLVM IR:; *CompileOnDemandLayer*. The CompileOnDemandLayer class conforms to the layer interface described in; Chapter 2, but its addModule method behaves quite differently from the layers; we have seen so far: rather than doing any work up front, it just scans the; Modules being added and arranges for each function in them to be compiled the; first time it is called. To do this, the CompileOnDemandLayer creates two small; utilities for e",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT3.rst:1135,simpl,simple,1135,interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT3.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT3.rst,1,['simpl'],['simple']
Usability,"====. In addition to the regular ""whole program"" tests, the ``test-suite``; module also provides a mechanism for compiling the programs in different; ways. If the variable TEST is defined on the ``gmake`` command line, the; test system will include a Makefile named; ``TEST.<value of TEST variable>.Makefile``. This Makefile can modify; build rules to yield different results. For example, the LLVM nightly tester uses ``TEST.nightly.Makefile`` to; create the nightly test reports. To run the nightly tests, run; ``gmake TEST=nightly``. There are several TEST Makefiles available in the tree. Some of them are; designed for internal LLVM research and will not work outside of the; LLVM research group. They may still be valuable, however, as a guide to; writing your own TEST Makefile for any optimization or analysis passes; that you develop with LLVM. Generating Test Output; ======================. There are a number of ways to run the tests and generate output. The; most simple one is simply running ``gmake`` with no arguments. This will; compile and run all programs in the tree using a number of different; methods and compare results. Any failures are reported in the output,; but are likely drowned in the other output. Passes are not reported; explicitly. Somewhat better is running ``gmake TEST=sometest test``, which runs the; specified test and usually adds per-program summaries to the output; (depending on which sometest you use). For example, the ``nightly`` test; explicitly outputs TEST-PASS or TEST-FAIL for every test after each; program. Though these lines are still drowned in the output, it's easy; to grep the output logs in the Output directories. Even better are the ``report`` and ``report.format`` targets (where; ``format`` is one of ``html``, ``csv``, ``text`` or ``graphs``). The; exact contents of the report are dependent on which ``TEST`` you are; running, but the text results are always shown at the end of the run and; the results are always stored in the ``re",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestSuiteMakefileGuide.rst:3771,simpl,simple,3771,interpreter/llvm-project/llvm/docs/TestSuiteMakefileGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestSuiteMakefileGuide.rst,2,['simpl'],"['simple', 'simply']"
Usability,"=====; reserved ``s_trap 0x00`` Reserved by hardware.; debugger breakpoint ``s_trap 0x01`` *none* Reserved for debugger to use for; breakpoints. Causes wave to be halted; with the PC at the trap instruction.; The debugger is responsible to resume; the wave, including the instruction; that the breakpoint overwrote.; ``llvm.trap`` ``s_trap 0x02`` ``SGPR0-1``: Causes wave to be halted with the PC at; ``queue_ptr`` the trap instruction. The associated; queue is signalled to put it into the; error state. When the queue is put in; the error state, the waves executing; dispatches on the queue will be; terminated.; ``llvm.debugtrap`` ``s_trap 0x03`` *none* - If debugger not enabled then behaves; as a no-operation. The trap handler; is entered and immediately returns to; continue execution of the wavefront.; - If the debugger is enabled, causes; the debug trap to be reported by the; debugger and the wavefront is put in; the halt state with the PC at the; instruction. The debugger must; increment the PC and resume the wave.; reserved ``s_trap 0x04`` Reserved.; reserved ``s_trap 0x05`` Reserved.; reserved ``s_trap 0x06`` Reserved.; reserved ``s_trap 0x07`` Reserved.; reserved ``s_trap 0x08`` Reserved.; reserved ``s_trap 0xfe`` Reserved.; reserved ``s_trap 0xff`` Reserved.; =================== =============== =============== =======================================. .. .. table:: AMDGPU Trap Handler for AMDHSA OS Code Object V4 and Above; :name: amdgpu-trap-handler-for-amdhsa-os-v4-onwards-table. =================== =============== ================ ================= =======================================; Usage Code Sequence GFX6-GFX8 Inputs GFX9-GFX11 Inputs Description; =================== =============== ================ ================= =======================================; reserved ``s_trap 0x00`` Reserved by hardware.; debugger breakpoint ``s_trap 0x01`` *none* *none* Reserved for debugger to use for; breakpoints. Causes wave to be halted; with the PC at the trap instr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:383610,resume,resume,383610,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['resume'],['resume']
Usability,"======. The JIT linker concept was introduced in LLVM's earlier generation of JIT APIs,; MCJIT. In MCJIT the *RuntimeDyld* component enabled re-use of LLVM as an; in-memory compiler by adding an in-memory link step to the end of the usual; compiler pipeline. Rather than dumping relocatable objects to disk as a compiler; usually would, MCJIT passed them to RuntimeDyld to be linked into a target; process. This approach to linking differs from standard *static* or *dynamic* linking:. A *static linker* takes one or more relocatable object files as input and links; them into an executable or dynamic library on disk. A *dynamic linker* applies relocations to executables and dynamic libraries that; have been loaded into memory. A *JIT linker* takes a single relocatable object file at a time and links it; into a target process, usually using a context object to allow the linked code; to resolve symbols in the target. RuntimeDyld; -----------. In order to keep RuntimeDyld's implementation simple MCJIT imposed some; restrictions on compiled code:. #. It had to use the Large code model, and often restricted available relocation; models in order to limit the kinds of relocations that had to be supported. #. It required strong linkage and default visibility on all symbols -- behavior; for other linkages/visibilities was not well defined. #. It constrained and/or prohibited the use of features requiring runtime; support, e.g. static initializers or thread local storage. As a result of these restrictions not all language features supported by LLVM; worked under MCJIT, and objects to be loaded under the JIT had to be compiled to; target it (precluding the use of precompiled code from other sources under the; JIT). RuntimeDyld also provided very limited visibility into the linking process; itself: Clients could access conservative estimates of section size; (RuntimeDyld bundled stub size and padding estimates into the section size; value) and the final relocated bytes, but could not ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst:35759,simpl,simple,35759,interpreter/llvm-project/llvm/docs/JITLink.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst,1,['simpl'],['simple']
Usability,"=======. Debug information is a hard problem for a few different reasons - mostly; centered around optimized code. First, optimization makes keeping source; locations more difficult. In LLVM IR we keep the original source location; for each IR level instruction on the instruction. Optimization passes; should keep the source locations for newly created instructions, but merged; instructions only get to keep a single location - this can cause jumping; around when stepping through optimized programs. Secondly, optimization; can move variables in ways that are either optimized out, shared in memory; with other variables, or difficult to track. For the purposes of this; tutorial we're going to avoid optimization (as you'll see with one of the; next sets of patches). Ahead-of-Time Compilation Mode; ==============================. To highlight only the aspects of adding debug information to a source; language without needing to worry about the complexities of JIT debugging; we're going to make a few changes to Kaleidoscope to support compiling; the IR emitted by the front end into a simple standalone program that; you can execute, debug, and see results. First we make our anonymous function that contains our top level; statement be our ""main"":. .. code-block:: udiff. - auto Proto = std::make_unique<PrototypeAST>("""", std::vector<std::string>());; + auto Proto = std::make_unique<PrototypeAST>(""main"", std::vector<std::string>());. just with the simple change of giving it a name. Then we're going to remove the command line code wherever it exists:. .. code-block:: udiff. @@ -1129,7 +1129,6 @@ static void HandleTopLevelExpression() {; /// top ::= definition | external | expression | ';'; static void MainLoop() {; while (true) {; - fprintf(stderr, ""ready> "");; switch (CurTok) {; case tok_eof:; return;; @@ -1184,7 +1183,6 @@ int main() {; BinopPrecedence['*'] = 40; // highest. // Prime the first token.; - fprintf(stderr, ""ready> "");; getNextToken();. Lastly we're going to disable",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl09.rst:2746,simpl,simple,2746,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl09.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl09.rst,1,['simpl'],['simple']
Usability,"=======. Generating LLVM code for expression nodes is very straightforward: less; than 45 lines of commented code for all four of our expression nodes.; First we'll do numeric literals:. .. code-block:: c++. Value *NumberExprAST::codegen() {; return ConstantFP::get(*TheContext, APFloat(Val));; }. In the LLVM IR, numeric constants are represented with the; ``ConstantFP`` class, which holds the numeric value in an ``APFloat``; internally (``APFloat`` has the capability of holding floating point; constants of Arbitrary Precision). This code basically just creates; and returns a ``ConstantFP``. Note that in the LLVM IR that constants; are all uniqued together and shared. For this reason, the API uses the; ""foo::get(...)"" idiom instead of ""new foo(..)"" or ""foo::Create(..)"". .. code-block:: c++. Value *VariableExprAST::codegen() {; // Look this variable up in the function.; Value *V = NamedValues[Name];; if (!V); LogErrorV(""Unknown variable name"");; return V;; }. References to variables are also quite simple using LLVM. In the simple; version of Kaleidoscope, we assume that the variable has already been; emitted somewhere and its value is available. In practice, the only; values that can be in the ``NamedValues`` map are function arguments.; This code simply checks to see that the specified name is in the map (if; not, an unknown variable is being referenced) and returns the value for; it. In future chapters, we'll add support for `loop induction; variables <LangImpl05.html#for-loop-expression>`_ in the symbol table, and for `local; variables <LangImpl07.html#user-defined-local-variables>`_. .. code-block:: c++. Value *BinaryExprAST::codegen() {; Value *L = LHS->codegen();; Value *R = RHS->codegen();; if (!L || !R); return nullptr;. switch (Op) {; case '+':; return Builder->CreateFAdd(L, R, ""addtmp"");; case '-':; return Builder->CreateFSub(L, R, ""subtmp"");; case '*':; return Builder->CreateFMul(L, R, ""multmp"");; case '<':; L = Builder->CreateFCmpULT(L, R, ""cmptmp"");; // C",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst:5771,simpl,simple,5771,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst,1,['simpl'],['simple']
Usability,"=======; Modules; =======. .. contents::; :local:. Introduction; ============; Most software is built using a number of software libraries, including libraries supplied by the platform, internal libraries built as part of the software itself to provide structure, and third-party libraries. For each library, one needs to access both its interface (API) and its implementation. In the C family of languages, the interface to a library is accessed by including the appropriate header files(s):. .. code-block:: c. #include <SomeLib.h>. The implementation is handled separately by linking against the appropriate library. For example, by passing ``-lSomeLib`` to the linker. Modules provide an alternative, simpler way to use software libraries that provides better compile-time scalability and eliminates many of the problems inherent to using the C preprocessor to access the API of a library. Problems with the current model; -------------------------------; The ``#include`` mechanism provided by the C preprocessor is a very poor way to access the API of a library, for a number of reasons:. * **Compile-time scalability**: Each time a header is included, the; compiler must preprocess and parse the text in that header and every; header it includes, transitively. This process must be repeated for; every translation unit in the application, which involves a huge; amount of redundant work. In a project with *N* translation units; and *M* headers included in each translation unit, the compiler is; performing *M x N* work even though most of the *M* headers are; shared among multiple translation units. C++ is particularly bad,; because the compilation model for templates forces a huge amount of; code into headers. * **Fragility**: ``#include`` directives are treated as textual; inclusion by the preprocessor, and are therefore subject to any; active macro definitions at the time of inclusion. If any of the; active macro definitions happens to collide with a name in the; library, it can b",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:705,simpl,simpler,705,interpreter/llvm-project/clang/docs/Modules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst,1,['simpl'],['simpler']
Usability,"=========. If clang successfully produces an executable, but that executable doesn't run; right, this is either a bug in the code or a bug in the compiler. The first; thing to check is to make sure it is not using undefined behavior (e.g.; reading a variable before it is defined). In particular, check to see if the; program is clean under various `sanitizers; <https://github.com/google/sanitizers>`_ (e.g. ``clang; -fsanitize=undefined,address``) and `valgrind <http://valgrind.org/>`_. Many; ""LLVM bugs"" that we have chased down ended up being bugs in the program being; compiled, not LLVM. Once you determine that the program itself is not buggy, you should choose; which code generator you wish to compile the program with (e.g. LLC or the JIT); and optionally a series of LLVM passes to run. For example:. .. code-block:: bash. bugpoint -run-llc [... optzn passes ...] file-to-test.bc --args -- [program arguments]. bugpoint will try to narrow down your list of passes to the one pass that; causes an error, and simplify the bitcode file as much as it can to assist; you. It will print a message letting you know how to reproduce the; resulting error. The :doc:`OptBisect <OptBisect>` page shows an alternative method for finding; incorrect optimization passes. Incorrect code generation; =========================. Similarly to debugging incorrect compilation by mis-behaving passes, you; can debug incorrect code generation by either LLC or the JIT, using; ``bugpoint``. The process ``bugpoint`` follows in this case is to try to; narrow the code down to a function that is miscompiled by one or the other; method, but since for correctness, the entire program must be run,; ``bugpoint`` will compile the code it deems to not be affected with the C; Backend, and then link in the shared object it generates. To debug the JIT:. .. code-block:: bash. bugpoint -run-jit -output=[correct output file] [bitcode file] \; --tool-args -- [arguments to pass to lli] \; --args -- [program arguments]. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToSubmitABug.rst:8985,simpl,simplify,8985,interpreter/llvm-project/llvm/docs/HowToSubmitABug.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToSubmitABug.rst,1,['simpl'],['simplify']
Usability,"=========. The next thing missing is handling of function prototypes. In; Kaleidoscope, these are used both for 'extern' function declarations as; well as function body definitions. The code to do this is; straight-forward and not very interesting (once you've survived; expressions):. .. code-block:: c++. /// prototype; /// ::= id '(' id* ')'; static std::unique_ptr<PrototypeAST> ParsePrototype() {; if (CurTok != tok_identifier); return LogErrorP(""Expected function name in prototype"");. std::string FnName = IdentifierStr;; getNextToken();. if (CurTok != '('); return LogErrorP(""Expected '(' in prototype"");. // Read the list of argument names.; std::vector<std::string> ArgNames;; while (getNextToken() == tok_identifier); ArgNames.push_back(IdentifierStr);; if (CurTok != ')'); return LogErrorP(""Expected ')' in prototype"");. // success.; getNextToken(); // eat ')'. return std::make_unique<PrototypeAST>(FnName, std::move(ArgNames));; }. Given this, a function definition is very simple, just a prototype plus; an expression to implement the body:. .. code-block:: c++. /// definition ::= 'def' prototype expression; static std::unique_ptr<FunctionAST> ParseDefinition() {; getNextToken(); // eat def.; auto Proto = ParsePrototype();; if (!Proto) return nullptr;. if (auto E = ParseExpression()); return std::make_unique<FunctionAST>(std::move(Proto), std::move(E));; return nullptr;; }. In addition, we support 'extern' to declare functions like 'sin' and; 'cos' as well as to support forward declaration of user functions. These; 'extern's are just prototypes with no body:. .. code-block:: c++. /// external ::= 'extern' prototype; static std::unique_ptr<PrototypeAST> ParseExtern() {; getNextToken(); // eat extern.; return ParsePrototype();; }. Finally, we'll also let the user type in arbitrary top-level expressions; and evaluate them on the fly. We will handle this by defining anonymous; nullary (zero argument) functions for them:. .. code-block:: c++. /// toplevelexpr ::= expressio",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst:21629,simpl,simple,21629,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst,1,['simpl'],['simple']
Usability,"=========; At first, let's define how exactly we compare complex objects. Complex object comparison (function, basic-block, etc) is mostly based on its; sub-object comparison results. It is similar to the next ""tree"" objects; comparison:. #. For two trees *T1* and *T2* we perform *depth-first-traversal* and have; two sequences as a product: ""*T1Items*"" and ""*T2Items*"". #. We then compare chains ""*T1Items*"" and ""*T2Items*"" in; the most-significant-item-first order. The result of items comparison; would be the result of *T1* and *T2* comparison itself. FunctionComparator::compare(void); ---------------------------------; A brief look at the source code tells us that the comparison starts in the; “``int FunctionComparator::compare(void)``” method. 1. The first parts to be compared are the function's attributes and some; properties that is outside the “attributes” term, but still could make the; function different without changing its body. This part of the comparison is; usually done within simple *cmpNumbers* or *cmpFlags* operations (e.g.; ``cmpFlags(F1->hasGC(), F2->hasGC())``). Below is a full list of function's; properties to be compared on this stage:. * *Attributes* (those are returned by ``Function::getAttributes()``; method). * *GC*, for equivalence, *RHS* and *LHS* should be both either without; *GC* or with the same one. * *Section*, just like a *GC*: *RHS* and *LHS* should be defined in the; same section. * *Variable arguments*. *LHS* and *RHS* should be both either with or; without *var-args*. * *Calling convention* should be the same. 2. Function type. Checked by ``FunctionComparator::cmpType(Type*, Type*)``; method. It checks return type and parameters type; the method itself will be; described later. 3. Associate function formal parameters with each other. Then comparing function; bodies, if we see the usage of *LHS*'s *i*-th argument in *LHS*'s body, then,; we want to see usage of *RHS*'s *i*-th argument at the same place in *RHS*'s; body, otherwise fun",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MergeFunctions.rst:12206,simpl,simple,12206,interpreter/llvm-project/llvm/docs/MergeFunctions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MergeFunctions.rst,1,['simpl'],['simple']
Usability,"=========== =====================================. Barriers; --------. '``llvm.nvvm.barrier0``'; ^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". .. code-block:: llvm. declare void @llvm.nvvm.barrier0(). Overview:; """""""""""""""""". The '``@llvm.nvvm.barrier0()``' intrinsic emits a PTX ``bar.sync 0``; instruction, equivalent to the ``__syncthreads()`` call in CUDA. Other Intrinsics; ----------------. For the full set of NVPTX intrinsics, please see the; ``include/llvm/IR/IntrinsicsNVVM.td`` file in the LLVM source tree. .. _libdevice:. Linking with Libdevice; ======================. The CUDA Toolkit comes with an LLVM bitcode library called ``libdevice`` that; implements many common mathematical functions. This library can be used as a; high-performance math library for any compilers using the LLVM NVPTX target.; The library can be found under ``nvvm/libdevice/`` in the CUDA Toolkit and; there is a separate version for each compute architecture. For a list of all math functions implemented in libdevice, see; `libdevice Users Guide <http://docs.nvidia.com/cuda/libdevice-users-guide/index.html>`_. To accommodate various math-related compiler flags that can affect code; generation of libdevice code, the library code depends on a special LLVM IR; pass (``NVVMReflect``) to handle conditional compilation within LLVM IR. This; pass looks for calls to the ``@__nvvm_reflect`` function and replaces them; with constants based on the defined reflection parameters. Such conditional; code often follows a pattern:. .. code-block:: c++. float my_function(float a) {; if (__nvvm_reflect(""FASTMATH"")); return my_function_fast(a);; else; return my_function_precise(a);; }. The default value for all unspecified reflection parameters is zero. The ``NVVMReflect`` pass should be executed early in the optimization; pipeline, immediately after the link stage. The ``internalize`` pass is also; recommended to remove unused math functions from the resulting PTX. For an; input IR module ``module.bc``, the f",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NVPTXUsage.rst:8029,Guid,Guide,8029,interpreter/llvm-project/llvm/docs/NVPTXUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NVPTXUsage.rst,1,['Guid'],['Guide']
Usability,"============; HLSL Support; ============. .. contents::; :local:. Introduction; ============. HLSL Support is under active development in the Clang codebase. This document; describes the high level goals of the project, the guiding principles, as well; as some idiosyncrasies of the HLSL language and how we intend to support them in; Clang. Project Goals; =============. The long term goal of this project is to enable Clang to function as a; replacement for the `DirectXShaderCompiler (DXC); <https://github.com/microsoft/DirectXShaderCompiler/>`_ in all its supported; use cases. Accomplishing that goal will require Clang to be able to process most; existing HLSL programs with a high degree of source compatibility. Non-Goals; ---------. HLSL ASTs do not need to be compatible between DXC and Clang. We do not expect; identical code generation or that features will resemble DXC's implementation or; architecture. In fact, we explicitly expect to deviate from DXC's implementation; in key ways. Guiding Principles; ==================. This document lacks details for architectural decisions that are not yet; finalized. Our top priorities are quality, maintainability, and flexibility. In; accordance with community standards we are expecting a high level of test; coverage, and we will engineer our solutions with long term maintenance in mind.; We are also working to limit modifications to the Clang C++ code paths and; share as much functionality as possible. Architectural Direction; =======================. HLSL support in Clang is expressed as C++ minus unsupported C and C++ features.; This is different from how other Clang languages are implemented. Most languages; in Clang are additive on top of C. HLSL is not a formally or fully specified language, and while our goals require; a high level of source compatibility, implementations can vary and we have some; flexibility to be more or less permissive in some cases. For modern HLSL DXC is; the reference implementation. The HLSL ef",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HLSL/HLSLSupport.rst:224,guid,guiding,224,interpreter/llvm-project/clang/docs/HLSL/HLSLSupport.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HLSL/HLSLSupport.rst,1,['guid'],['guiding']
Usability,"=============; Clang Plugins; =============. Clang Plugins make it possible to run extra user defined actions during a; compilation. This document will provide a basic walkthrough of how to write and; run a Clang Plugin. Introduction; ============. Clang Plugins run FrontendActions over code. See the :doc:`FrontendAction; tutorial <RAVFrontendAction>` on how to write a ``FrontendAction`` using the; ``RecursiveASTVisitor``. In this tutorial, we'll demonstrate how to write a; simple clang plugin. Writing a ``PluginASTAction``; =============================. The main difference from writing normal ``FrontendActions`` is that you can; handle plugin command line options. The ``PluginASTAction`` base class declares; a ``ParseArgs`` method which you have to implement in your plugin. .. code-block:: c++. bool ParseArgs(const CompilerInstance &CI,; const std::vector<std::string>& args) {; for (unsigned i = 0, e = args.size(); i != e; ++i) {; if (args[i] == ""-some-arg"") {; // Handle the command line argument.; }; }; return true;; }. Registering a plugin; ====================. A plugin is loaded from a dynamic library at runtime by the compiler. To; register a plugin in a library, use ``FrontendPluginRegistry::Add<>``:. .. code-block:: c++. static FrontendPluginRegistry::Add<MyPlugin> X(""my-plugin-name"", ""my plugin description"");. Defining pragmas; ================. Plugins can also define pragmas by declaring a ``PragmaHandler`` and; registering it using ``PragmaHandlerRegistry::Add<>``:. .. code-block:: c++. // Define a pragma handler for #pragma example_pragma; class ExamplePragmaHandler : public PragmaHandler {; public:; ExamplePragmaHandler() : PragmaHandler(""example_pragma"") { }; void HandlePragma(Preprocessor &PP, PragmaIntroducer Introducer,; Token &PragmaTok) {; // Handle the pragma; }; };. static PragmaHandlerRegistry::Add<ExamplePragmaHandler> Y(""example_pragma"",""example pragma description"");. Defining attributes; ===================. Plugins can define attributes by",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst:479,simpl,simple,479,interpreter/llvm-project/clang/docs/ClangPlugins.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst,1,['simpl'],['simple']
Usability,"==============; MyFirstTypoFix; ==============. .. contents::; :local:. Introduction; ============. This tutorial will guide you through the process of making a change to; LLVM, and contributing it back to the LLVM project. We'll be making a; change to Clang, but the steps for other parts of LLVM are the same.; Even though the change we'll be making is simple, we're going to cover; steps like building LLVM, running the tests, and code review. This is; good practice, and you'll be prepared for making larger changes. We'll assume you:. - know how to use an editor,. - have basic C++ knowledge,. - know how to install software on your system,. - are comfortable with the command line,. - have basic knowledge of git. The change we're making; -----------------------. Clang has a warning for infinite recursion:. .. code:: console. $ echo ""void foo() { foo(); }"" > ~/test.cc; $ clang -c -Wall ~/test.cc; input.cc:1:14: warning: all paths through this function will call; itself [-Winfinite-recursion]. This is clear enough, but not exactly catchy. Let's improve the wording; a little:. .. code:: console. input.cc:1:14: warning: to understand recursion, you must first; understand recursion [-Winfinite-recursion]. Dependencies; ------------. We're going to need some tools:. - git: to check out the LLVM source code,. - a C++ compiler: to compile LLVM source code. You'll want `a recent; version <https://llvm.org/docs/GettingStarted.html#host-c-toolchain-both-compiler-and-standard-library>`__; of Clang, GCC, or Visual Studio. - CMake: used to configure how LLVM should be built on your system,. - ninja: runs the C++ compiler to (re)build specific parts of LLVM,. - python: to run the LLVM tests,. As an example, on Ubuntu:. .. code:: console. $ sudo apt-get install git clang cmake ninja-build python arcanist. Building LLVM; =============. Checkout; --------. The source code is stored `on; Github <https://github.com/llvm/llvm-project>`__ in one large repository; (""the monorepo""). It may tak",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MyFirstTypoFix.rst:119,guid,guide,119,interpreter/llvm-project/llvm/docs/MyFirstTypoFix.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MyFirstTypoFix.rst,2,"['guid', 'simpl']","['guide', 'simple']"
Usability,"==============; SanitizerStats; ==============. .. contents::; :local:. Introduction; ============. The sanitizers support a simple mechanism for gathering profiling statistics; to help understand the overhead associated with sanitizers. How to build and run; ====================. SanitizerStats can currently only be used with :doc:`ControlFlowIntegrity`.; In addition to ``-fsanitize=cfi*``, pass the ``-fsanitize-stats`` flag.; This will cause the program to count the number of times that each control; flow integrity check in the program fires. At run time, set the ``SANITIZER_STATS_PATH`` environment variable to direct; statistics output to a file. The file will be written on process exit.; The following substitutions will be applied to the environment variable:. - ``%b`` -- The executable basename.; - ``%p`` -- The process ID. You can also send the ``SIGUSR2`` signal to a process to make it write; sanitizer statistics immediately. The ``sanstats`` program can be used to dump statistics. It takes as a; command line argument the path to a statistics file produced by a program; compiled with ``-fsanitize-stats``. The output of ``sanstats`` is in four columns, separated by spaces. The first; column is the file and line number of the call site. The second column is; the function name. The third column is the type of statistic gathered (in; this case, the type of control flow integrity check). The fourth column is; the call count. Example:. .. code-block:: console. $ cat -n vcall.cc; 1 struct A {; 2 virtual void f() {}; 3 };; 4; 5 __attribute__((noinline)) void g(A *a) {; 6 a->f();; 7 }; 8; 9 int main() {; 10 A a;; 11 g(&a);; 12 }; $ clang++ -fsanitize=cfi -fvisibility=hidden -flto -fuse-ld=gold vcall.cc -fsanitize-stats -g; $ SANITIZER_STATS_PATH=a.stats ./a.out; $ sanstats a.stats; vcall.cc:6 _Z1gP1A cfi-vcall 1; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerStats.rst:125,simpl,simple,125,interpreter/llvm-project/clang/docs/SanitizerStats.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerStats.rst,1,['simpl'],['simple']
Usability,"===============. .. contents::; :local:. **This tutorial is under active development. It is incomplete and details may; change frequently.** Nonetheless we invite you to try it out as it stands, and; we welcome any feedback. Chapter 2 Introduction; ======================. **Warning: This tutorial is currently being updated to account for ORC API; changes. Only Chapters 1 and 2 are up-to-date.**. **Example code from Chapters 3 to 5 will compile and run, but has not been; updated**. Welcome to Chapter 2 of the ""Building an ORC-based JIT in LLVM"" tutorial. In; `Chapter 1 <BuildingAJIT1.html>`_ of this series we examined a basic JIT; class, KaleidoscopeJIT, that could take LLVM IR modules as input and produce; executable code in memory. KaleidoscopeJIT was able to do this with relatively; little code by composing two off-the-shelf *ORC layers*: IRCompileLayer and; ObjectLinkingLayer, to do much of the heavy lifting. In this layer we'll learn more about the ORC layer concept by using a new layer,; IRTransformLayer, to add IR optimization support to KaleidoscopeJIT. Optimizing Modules using the IRTransformLayer; =============================================. In `Chapter 4 <LangImpl04.html>`_ of the ""Implementing a language with LLVM""; tutorial series the llvm *FunctionPassManager* is introduced as a means for; optimizing LLVM IR. Interested readers may read that chapter for details, but; in short: to optimize a Module we create an llvm::FunctionPassManager; instance, configure it with a set of optimizations, then run the PassManager on; a Module to mutate it into a (hopefully) more optimized but semantically; equivalent form. In the original tutorial series the FunctionPassManager was; created outside the KaleidoscopeJIT and modules were optimized before being; added to it. In this Chapter we will make optimization a phase of our JIT; instead. For now this will provide us a motivation to learn more about ORC; layers, but in the long term making optimization part of our JIT",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT2.rst:1142,learn,learn,1142,interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT2.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT2.rst,1,['learn'],['learn']
Usability,"===============; Support Library; ===============. Abstract; ========. This document provides some details on LLVM's Support Library, located in the; source at ``lib/Support`` and ``include/llvm/Support``. The library's purpose; is to shield LLVM from the differences between operating systems for the few; services LLVM needs from the operating system. Much of LLVM is written using; portability features of standard C++. However, in a few areas, system dependent; facilities are needed and the Support Library is the wrapper around those; system calls. By centralizing LLVM's use of operating system interfaces, we make it possible; for the LLVM tool chain and runtime libraries to be more easily ported to new; platforms since (theoretically) only ``lib/Support`` needs to be ported. This; library also unclutters the rest of LLVM from #ifdef use and special cases for; specific operating systems. Such uses are replaced with simple calls to the; interfaces provided in ``include/llvm/Support``. Note that the Support Library is not intended to be a complete operating system; wrapper (such as the Adaptive Communications Environment (ACE) or Apache; Portable Runtime (APR)), but only provides the functionality necessary to; support LLVM. The Support Library was originally referred to as the System Library, written; by Reid Spencer who formulated the design based on similar work originating; from the eXtensible Programming System (XPS). Several people helped with the; effort; especially, Jeff Cohen and Henrik Bach on the Win32 port. Keeping LLVM Portable; =====================. In order to keep LLVM portable, LLVM developers should adhere to a set of; portability rules associated with the Support Library. Adherence to these rules; should help the Support Library achieve its goal of shielding LLVM from the; variations in operating system interfaces and doing so efficiently. The; following sections define the rules needed to fulfill this objective. Don't Include System Headers; ------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportLibrary.rst:929,simpl,simple,929,interpreter/llvm-project/llvm/docs/SupportLibrary.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportLibrary.rst,1,['simpl'],['simple']
Usability,"================; MemorySanitizer; ================. .. contents::; :local:. Introduction; ============. MemorySanitizer is a detector of uninitialized reads. It consists of a; compiler instrumentation module and a run-time library. Typical slowdown introduced by MemorySanitizer is **3x**. How to build; ============. Build LLVM/Clang with `CMake <https://llvm.org/docs/CMake.html>`_. Usage; =====. Simply compile and link your program with ``-fsanitize=memory`` flag.; The MemorySanitizer run-time library should be linked to the final; executable, so make sure to use ``clang`` (not ``ld``) for the final; link step. When linking shared libraries, the MemorySanitizer run-time; is not linked, so ``-Wl,-z,defs`` may cause link errors (don't use it; with MemorySanitizer). To get a reasonable performance add ``-O1`` or; higher. To get meaningful stack traces in error messages add; ``-fno-omit-frame-pointer``. To get perfect stack traces you may need; to disable inlining (just use ``-O1``) and tail call elimination; (``-fno-optimize-sibling-calls``). .. code-block:: console. % cat umr.cc; #include <stdio.h>. int main(int argc, char** argv) {; int* a = new int[10];; a[5] = 0;; if (a[argc]); printf(""xx\n"");; return 0;; }. % clang -fsanitize=memory -fno-omit-frame-pointer -g -O2 umr.cc. If a bug is detected, the program will print an error message to; stderr and exit with a non-zero exit code. .. code-block:: console. % ./a.out; WARNING: MemorySanitizer: use-of-uninitialized-value; #0 0x7f45944b418a in main umr.cc:6; #1 0x7f45938b676c in __libc_start_main libc-start.c:226. By default, MemorySanitizer exits on the first detected error. If you; find the error report hard to understand, try enabling; :ref:`origin tracking <msan-origins>`. ``__has_feature(memory_sanitizer)``; ------------------------------------. In some cases one may need to execute different code depending on; whether MemorySanitizer is enabled. :ref:`\_\_has\_feature; <langext-__has_feature-__has_extension>` can b",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MemorySanitizer.rst:400,Simpl,Simply,400,interpreter/llvm-project/clang/docs/MemorySanitizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MemorySanitizer.rst,1,['Simpl'],['Simply']
Usability,"=================; SanitizerCoverage; =================. .. contents::; :local:. Introduction; ============. LLVM has a simple code coverage instrumentation built in (SanitizerCoverage).; It inserts calls to user-defined functions on function-, basic-block-, and edge- levels.; Default implementations of those callbacks are provided and implement; simple coverage reporting and visualization,; however if you need *just* coverage visualization you may want to use; :doc:`SourceBasedCodeCoverage <SourceBasedCodeCoverage>` instead. Tracing PCs with guards; =======================. With ``-fsanitize-coverage=trace-pc-guard`` the compiler will insert the following code; on every edge:. .. code-block:: none. __sanitizer_cov_trace_pc_guard(&guard_variable). Every edge will have its own `guard_variable` (uint32_t). The compiler will also insert calls to a module constructor:. .. code-block:: c++. // The guards are [start, stop).; // This function will be called at least once per DSO and may be called; // more than once with the same values of start/stop.; __sanitizer_cov_trace_pc_guard_init(uint32_t *start, uint32_t *stop);. With an additional ``...=trace-pc,indirect-calls`` flag; ``__sanitizer_cov_trace_pc_indirect(void *callee)`` will be inserted on every indirect call. The functions `__sanitizer_cov_trace_pc_*` should be defined by the user. Example:. .. code-block:: c++. // trace-pc-guard-cb.cc; #include <stdint.h>; #include <stdio.h>; #include <sanitizer/coverage_interface.h>. // This callback is inserted by the compiler as a module constructor; // into every DSO. 'start' and 'stop' correspond to the; // beginning and end of the section with the guards for the entire; // binary (executable or DSO). The callback will be called at least; // once per DSO and may be called multiple times with the same parameters.; extern ""C"" void __sanitizer_cov_trace_pc_guard_init(uint32_t *start,; uint32_t *stop) {; static uint64_t N; // Counter for the guards.; if (start == stop || *start) ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerCoverage.rst:120,simpl,simple,120,interpreter/llvm-project/clang/docs/SanitizerCoverage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerCoverage.rst,2,['simpl'],['simple']
Usability,"===================; Misexpect; ===================; .. contents::. .. toctree::; :maxdepth: 1. When developers use ``llvm.expect`` intrinsics, i.e., through use of; ``__builtin_expect(...)``, they are trying to communicate how their code is; expected to behave at runtime to the optimizer. These annotations, however, can; be incorrect for a variety of reasons: changes to the code base invalidate them; silently, the developer mis-annotated them (e.g., using ``LIKELY`` instead of; ``UNLIKELY``), or perhaps they assumed something incorrectly when they wrote; the annotation. Regardless of why, it is useful to detect these situations so; that the optimizer can make more useful decisions about the code. MisExpect; diagnostics are intended to help developers identify and address these; situations, by comparing the use of the ``llvm.expect`` intrinsic to the ground; truth provided by a profiling input. The MisExpect checks in the LLVM backend follow a simple procedure: if there is; a mismatch between the branch weights collected during profiling and those; supplied by an ``llvm.expect`` intrinsic, then it will emit a diagnostic; message to the user. The most natural place to perform the verification is just prior to when; branch weights are assigned to the target instruction in the form of; branch weight metadata. There are 3 key places in the LLVM backend where branch weights are; created and assigned based on profiling information or the use of the; ``llvm.expect`` intrinsic, and our implementation focuses on these; places to perform the verification. We calculate the threshold for emitting MisExpect related diagnostics; based on the values the compiler assigns to ``llvm.expect`` intrinsics,; which can be set through the ``-likely-branch-weight`` and; ``-unlikely-branch-weight`` LLVM options. During verification, if the; profile weights mismatch the calculated threshold, then we will emit a; remark or warning detailing a potential performance regression. The; diagnostic al",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MisExpect.rst:958,simpl,simple,958,interpreter/llvm-project/llvm/docs/MisExpect.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MisExpect.rst,1,['simpl'],['simple']
Usability,"====================; Objective-C Literals; ====================. Introduction; ============. Three new features were introduced into clang at the same time:; *NSNumber Literals* provide a syntax for creating ``NSNumber`` from; scalar literal expressions; *Collection Literals* provide a short-hand; for creating arrays and dictionaries; *Object Subscripting* provides a; way to use subscripting with Objective-C objects. Users of Apple; compiler releases can use these features starting with the Apple LLVM; Compiler 4.0. Users of open-source LLVM.org compiler releases can use; these features starting with clang v3.1. These language additions simplify common Objective-C programming; patterns, make programs more concise, and improve the safety of; container creation. This document describes how the features are implemented in clang, and; how to use them in your own programs. NSNumber Literals; =================. The framework class ``NSNumber`` is used to wrap scalar values inside; objects: signed and unsigned integers (``char``, ``short``, ``int``,; ``long``, ``long long``), floating point numbers (``float``,; ``double``), and boolean values (``BOOL``, C++ ``bool``). Scalar values; wrapped in objects are also known as *boxed* values. In Objective-C, any character, numeric or boolean literal prefixed with; the ``'@'`` character will evaluate to a pointer to an ``NSNumber``; object initialized with that value. C's type suffixes may be used to; control the size of numeric literals. Examples; --------. The following program illustrates the rules for ``NSNumber`` literals:. .. code-block:: objc. void main(int argc, const char *argv[]) {; // character literals.; NSNumber *theLetterZ = @'Z'; // equivalent to [NSNumber numberWithChar:'Z']. // integral literals.; NSNumber *fortyTwo = @42; // equivalent to [NSNumber numberWithInt:42]; NSNumber *fortyTwoUnsigned = @42U; // equivalent to [NSNumber numberWithUnsignedInt:42U]; NSNumber *fortyTwoLong = @42L; // equivalent to [NSNumber n",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst:646,simpl,simplify,646,interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst,1,['simpl'],['simplify']
Usability,"=====================; LLVM Coding Standards; =====================. .. contents::; :local:. Introduction; ============. This document describes coding standards that are used in the LLVM project.; Although no coding standards should be regarded as absolute requirements to be; followed in all instances, coding standards are; particularly important for large-scale code bases that follow a library-based; design (like LLVM). While this document may provide guidance for some mechanical formatting issues,; whitespace, or other ""microscopic details"", these are not fixed standards.; Always follow the golden rule:. .. _Golden Rule:. **If you are extending, enhancing, or bug fixing already implemented code,; use the style that is already being used so that the source is uniform and; easy to follow.**. Note that some code bases (e.g. ``libc++``) have special reasons to deviate; from the coding standards. For example, in the case of ``libc++``, this is; because the naming and other conventions are dictated by the C++ standard. There are some conventions that are not uniformly followed in the code base; (e.g. the naming convention). This is because they are relatively new, and a; lot of code was written before they were put in place. Our long term goal is; for the entire codebase to follow the convention, but we explicitly *do not*; want patches that do large-scale reformatting of existing code. On the other; hand, it is reasonable to rename the methods of a class if you're about to; change it in some other way. Please commit such changes separately to; make code review easier. The ultimate goal of these guidelines is to increase the readability and; maintainability of our common source base. Languages, Libraries, and Standards; ===================================. Most source code in LLVM and other LLVM projects using these coding standards; is C++ code. There are some places where C code is used either due to; environment restrictions, historical restrictions, or due to third-",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst:458,guid,guidance,458,interpreter/llvm-project/llvm/docs/CodingStandards.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst,1,['guid'],['guidance']
Usability,"=====================; LLVM Developer Policy; =====================. .. contents::; :local:. Introduction; ============. This document contains the LLVM Developer Policy which defines the project's; policy towards developers and their contributions. The intent of this policy is; to eliminate miscommunication, rework, and confusion that might arise from the; distributed nature of LLVM's development. By stating the policy in clear terms,; we hope each developer can know ahead of time what to expect when making LLVM; contributions. This policy covers all llvm.org subprojects, including Clang,; LLDB, libc++, etc. This policy is also designed to accomplish the following objectives:. #. Attract both users and developers to the LLVM project. #. Make life as simple and easy for contributors as possible. #. Keep the top of tree as stable as possible. #. Establish awareness of the project's :ref:`copyright, license, and patent; policies <copyright-license-patents>` with contributors to the project. This policy is aimed at frequent contributors to LLVM. People interested in; contributing one-off patches can do so in an informal way by sending them to the; `llvm-commits mailing list; <http://lists.llvm.org/mailman/listinfo/llvm-commits>`_ and engaging another; developer to see it through the process. Developer Policies; ==================. This section contains policies that pertain to frequent LLVM developers. We; always welcome `one-off patches`_ from people who do not routinely contribute to; LLVM, but we expect more from frequent contributors to keep the system as; efficient as possible for everyone. Frequent LLVM contributors are expected to; meet the following requirements in order for LLVM to maintain a high standard of; quality. Stay Informed; -------------. Developers should stay informed by reading the `LLVM Discourse forums`_ and subscribing; to the categories of interest for notifications. Paying attention to changes being made by others is a good way to see what oth",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst:427,clear,clear,427,interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,2,"['clear', 'simpl']","['clear', 'simple']"
Usability,"=====================; YAML I/O; =====================. .. contents::; :local:. Introduction to YAML; ====================. YAML is a human readable data serialization language. The full YAML language; spec can be read at `yaml.org; <http://www.yaml.org/spec/1.2/spec.html#Introduction>`_. The simplest form of; yaml is just ""scalars"", ""mappings"", and ""sequences"". A scalar is any number; or string. The pound/hash symbol (#) begins a comment line. A mapping is; a set of key-value pairs where the key ends with a colon. For example:. .. code-block:: yaml. # a mapping; name: Tom; hat-size: 7. A sequence is a list of items where each item starts with a leading dash ('-').; For example:. .. code-block:: yaml. # a sequence; - x86; - x86_64; - PowerPC. You can combine mappings and sequences by indenting. For example a sequence; of mappings in which one of the mapping values is itself a sequence:. .. code-block:: yaml. # a sequence of mappings with one key's value being a sequence; - name: Tom; cpus:; - x86; - x86_64; - name: Bob; cpus:; - x86; - name: Dan; cpus:; - PowerPC; - x86. Sometime sequences are known to be short and the one entry per line is too; verbose, so YAML offers an alternate syntax for sequences called a ""Flow; Sequence"" in which you put comma separated sequence elements into square; brackets. The above example could then be simplified to :. .. code-block:: yaml. # a sequence of mappings with one key's value being a flow sequence; - name: Tom; cpus: [ x86, x86_64 ]; - name: Bob; cpus: [ x86 ]; - name: Dan; cpus: [ PowerPC, x86 ]. Introduction to YAML I/O; ========================. The use of indenting makes the YAML easy for a human to read and understand,; but having a program read and write YAML involves a lot of tedious details.; The YAML I/O library structures and simplifies reading and writing YAML; documents. YAML I/O assumes you have some ""native"" data structures which you want to be; able to dump as YAML and recreate from YAML. The first step is to try",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/YamlIO.rst:294,simpl,simplest,294,interpreter/llvm-project/llvm/docs/YamlIO.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/YamlIO.rst,1,['simpl'],['simplest']
Usability,"======================; Matching the Clang AST; ======================. This document explains how to use Clang's LibASTMatchers to match interesting; nodes of the AST and execute code that uses the matched nodes. Combined with; :doc:`LibTooling`, LibASTMatchers helps to write code-to-code transformation; tools or query tools. We assume basic knowledge about the Clang AST. See the :doc:`Introduction; to the Clang AST <IntroductionToTheClangAST>` if you want to learn more; about how the AST is structured. .. FIXME: create tutorial and link to the tutorial. Introduction; ------------. LibASTMatchers provides a domain specific language to create predicates on; Clang's AST. This DSL is written in and can be used from C++, allowing users; to write a single program to both match AST nodes and access the node's C++; interface to extract attributes, source locations, or any other information; provided on the AST level. AST matchers are predicates on nodes in the AST. Matchers are created by; calling creator functions that allow building up a tree of matchers, where; inner matchers are used to make the match more specific. For example, to create a matcher that matches all class or union declarations; in the AST of a translation unit, you can call `recordDecl(); <LibASTMatchersReference.html#recordDecl0Anchor>`_. To narrow the match down,; for example to find all class or union declarations with the name ""``Foo``"",; insert a `hasName <LibASTMatchersReference.html#hasName0Anchor>`_ matcher: the; call ``recordDecl(hasName(""Foo""))`` returns a matcher that matches classes or; unions that are named ""``Foo``"", in any namespace. By default, matchers that; accept multiple inner matchers use an implicit `allOf(); <LibASTMatchersReference.html#allOf0Anchor>`_. This allows further narrowing; down the match, for example to match all classes that are derived from; ""``Bar``"": ``recordDecl(hasName(""Foo""), isDerivedFrom(""Bar""))``. How to create a matcher; -----------------------. With more th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchers.rst:465,learn,learn,465,interpreter/llvm-project/clang/docs/LibASTMatchers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchers.rst,1,['learn'],['learn']
Usability,"=======================; External Clang Examples; =======================. Introduction; ============. This page provides some examples of the kinds of things that people have; done with Clang that might serve as useful guides (or starting points) from; which to develop your own tools. They may be helpful even for something as; banal (but necessary) as how to set up your build to integrate Clang. Clang's library-based design is deliberately aimed at facilitating use by; external projects, and we are always interested in improving Clang to; better serve our external users. Some typical categories of applications; where Clang is used are:. - Static analysis.; - Documentation/cross-reference generation. If you know of (or wrote!) a tool or project using Clang, please post on; `the Discourse forums (Clang Frontend category); <https://discourse.llvm.org/c/clang/6>`_ to have it added.; (or if you are already a Clang contributor, feel free to directly commit; additions). Since the primary purpose of this page is to provide examples; that can help developers, generally they must have code available. List of projects and tools; ==========================. `<https://github.com/Andersbakken/rtags/>`_; ""RTags is a client/server application that indexes c/c++ code and keeps; a persistent in-memory database of references, symbolnames, completions; etc."". `<https://rprichard.github.io/CxxCodeBrowser/>`_; ""A C/C++ source code indexer and navigator"". `<https://github.com/etaoins/qconnectlint>`_; ""qconnectlint is a Clang tool for statically verifying the consistency; of signal and slot connections made with Qt's ``QObject::connect``."". `<https://github.com/woboq/woboq_codebrowser>`_; ""The Woboq Code Browser is a web-based code browser for C/C++ projects.; Check out `<https://code.woboq.org/>`_ for an example!"". `<https://github.com/mozilla/dxr>`_; ""DXR is a source code cross-reference tool that uses static analysis; data collected by instrumented compilers."". `<https://github.com/esch",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ExternalClangExamples.rst:220,guid,guides,220,interpreter/llvm-project/clang/docs/ExternalClangExamples.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ExternalClangExamples.rst,1,['guid'],['guides']
Usability,"=======================; Writing an LLVM Backend; =======================. .. toctree::; :hidden:. HowToUseInstrMappings. .. contents::; :local:. Introduction; ============. This document describes techniques for writing compiler backends that convert; the LLVM Intermediate Representation (IR) to code for a specified machine or; other languages. Code intended for a specific machine can take the form of; either assembly code or binary code (usable for a JIT compiler). The backend of LLVM features a target-independent code generator that may; create output for several types of target CPUs --- including X86, PowerPC,; ARM, and SPARC. The backend may also be used to generate code targeted at SPUs; of the Cell processor or GPUs to support the execution of compute kernels. The document focuses on existing examples found in subdirectories of; ``llvm/lib/Target`` in a downloaded LLVM release. In particular, this document; focuses on the example of creating a static compiler (one that emits text; assembly) for a SPARC target, because SPARC has fairly standard; characteristics, such as a RISC instruction set and straightforward calling; conventions. Audience; --------. The audience for this document is anyone who needs to write an LLVM backend to; generate code for a specific hardware or software target. Prerequisite Reading; --------------------. These essential documents must be read before reading this document:. * `LLVM Language Reference Manual <LangRef.html>`_ --- a reference manual for; the LLVM assembly language. * :doc:`CodeGenerator` --- a guide to the components (classes and code; generation algorithms) for translating the LLVM internal representation into; machine code for a specified target. Pay particular attention to the; descriptions of code generation stages: Instruction Selection, Scheduling and; Formation, SSA-based Optimization, Register Allocation, Prolog/Epilog Code; Insertion, Late Machine Code Optimizations, and Code Emission. * :doc:`TableGen/index` --",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst:444,usab,usable,444,interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst,1,['usab'],['usable']
Usability,"========================. From LLVM 3.5 onwards the CMake build system exports LLVM libraries as; importable CMake targets. This means that clients of LLVM can now reliably use; CMake to develop their own LLVM-based projects against an installed version of; LLVM regardless of how it was built. Here is a simple example of a CMakeLists.txt file that imports the LLVM libraries; and uses them to build a simple application ``simple-tool``. .. code-block:: cmake. cmake_minimum_required(VERSION 3.20.0); project(SimpleProject). find_package(LLVM REQUIRED CONFIG). message(STATUS ""Found LLVM ${LLVM_PACKAGE_VERSION}""); message(STATUS ""Using LLVMConfig.cmake in: ${LLVM_DIR}""). # Set your project compile flags.; # E.g. if using the C++ header files; # you will need to enable C++11 support; # for your compiler. include_directories(${LLVM_INCLUDE_DIRS}); separate_arguments(LLVM_DEFINITIONS_LIST NATIVE_COMMAND ${LLVM_DEFINITIONS}); add_definitions(${LLVM_DEFINITIONS_LIST}). # Now build our tools; add_executable(simple-tool tool.cpp). # Find the libraries that correspond to the LLVM components; # that we wish to use; llvm_map_components_to_libnames(llvm_libs support core irreader). # Link against LLVM libraries; target_link_libraries(simple-tool ${llvm_libs}). The ``find_package(...)`` directive when used in CONFIG mode (as in the above; example) will look for the ``LLVMConfig.cmake`` file in various locations (see; cmake manual for details). It creates a ``LLVM_DIR`` cache entry to save the; directory where ``LLVMConfig.cmake`` is found or allows the user to specify the; directory (e.g. by passing ``-DLLVM_DIR=/usr/lib/cmake/llvm`` to; the ``cmake`` command or by setting it directly in ``ccmake`` or ``cmake-gui``). This file is available in two different locations. * ``<LLVM_INSTALL_PACKAGE_DIR>/LLVMConfig.cmake`` where; ``<LLVM_INSTALL_PACKAGE_DIR>`` is the location where LLVM CMake modules are; installed as part of an installed version of LLVM. This is typically; ``cmake/llvm/`` ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst:41838,simpl,simple-tool,41838,interpreter/llvm-project/llvm/docs/CMake.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst,1,['simpl'],['simple-tool']
Usability,"=========================; Compiling CUDA with clang; =========================. .. contents::; :local:. Introduction; ============. This document describes how to compile CUDA code with clang, and gives some; details about LLVM and clang's CUDA implementations. This document assumes a basic familiarity with CUDA. Information about CUDA; programming can be found in the; `CUDA programming guide; <http://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html>`_. Compiling CUDA Code; ===================. Prerequisites; -------------. CUDA is supported since llvm 3.9. Clang currently supports CUDA 7.0 through; 12.1. If clang detects a newer CUDA version, it will issue a warning and will; attempt to use detected CUDA SDK it as if it were CUDA 12.1. Before you build CUDA code, you'll need to have installed the CUDA SDK. See; `NVIDIA's CUDA installation guide; <https://docs.nvidia.com/cuda/cuda-installation-guide-linux/index.html>`_ for; details. Note that clang `maynot support; <https://bugs.llvm.org/show_bug.cgi?id=26966>`_ the CUDA toolkit as installed by; some Linux package managers. Clang does attempt to deal with specific details of; CUDA installation on a handful of common Linux distributions, but in general the; most reliable way to make it work is to install CUDA in a single directory from; NVIDIA's `.run` package and specify its location via `--cuda-path=...` argument. CUDA compilation is supported on Linux. Compilation on MacOS and Windows may or; may not work and currently have no maintainers. Invoking clang; --------------. Invoking clang for CUDA compilation works similarly to compiling regular C++.; You just need to be aware of a few additional flags. You can use `this <https://gist.github.com/855e277884eb6b388cd2f00d956c2fd4>`_; program as a toy example. Save it as ``axpy.cu``. (Clang detects that you're; compiling CUDA code by noticing that your filename ends with ``.cu``.; Alternatively, you can pass ``-x cuda``.). To build and run, run the following com",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CompileCudaWithLLVM.rst:391,guid,guide,391,interpreter/llvm-project/llvm/docs/CompileCudaWithLLVM.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CompileCudaWithLLVM.rst,4,['guid'],"['guide', 'guide-linux']"
Usability,"=========================; Dependence Graphs in LLVM; =========================. .. contents::; :local:. Introduction; ============; Dependence graphs are useful tools in compilers for analyzing relationships; between various program elements to help guide optimizations. The ideas; behind these graphs are described in papers [1]_ and [2]_. The implementation of these ideas in LLVM may be slightly different than; what is mentioned in the papers. These differences are documented in; the `implementation details <implementation-details_>`_. .. _DataDependenceGraph:. Data Dependence Graph; =====================; In its simplest form the Data Dependence Graph (or DDG) represents data; dependencies between individual instructions. Each node in such a graph; represents a single instruction and is referred to as an ""atomic"" node.; It is also possible to combine some atomic nodes that have a simple; def-use dependency between them into larger nodes that contain multiple-; instructions. As described in [1]_ the DDG uses graph abstraction to group nodes; that are part of a strongly connected component of the graph; into special nodes called pi-blocks. pi-blocks represent cycles of data; dependency that prevent reordering transformations. Since any strongly; connected component of the graph is a maximal subgraph of all the nodes; that form a cycle, pi-blocks are at most one level deep. In other words,; no pi-blocks are nested inside another pi-block, resulting in a; hierarchical representation that is at most one level deep. For example, consider the following:. .. code-block:: c++. for (int i = 1; i < n; i++) {; b[i] = c[i] + b[i-1];; }. This code contains a statement that has a loop carried dependence on; itself creating a cycle in the DDG. The figure below illustrates; how the cycle of dependency is carried through multiple def-use relations; and a memory access dependency. .. image:: cycle.png. The DDG corresponding to this example would have a pi-block that contains; all the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DependenceGraphs/index.rst:251,guid,guide,251,interpreter/llvm-project/llvm/docs/DependenceGraphs/index.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DependenceGraphs/index.rst,3,"['guid', 'simpl']","['guide', 'simple', 'simplest']"
Usability,"==========================; Clang's refactoring engine; ==========================. This document describes the design of Clang's refactoring engine and provides; a couple of examples that show how various primitives in the refactoring API; can be used to implement different refactoring actions. The :doc:`LibTooling`; library provides several other APIs that are used when developing a; refactoring action. Refactoring engine can be used to implement local refactorings that are; initiated using a selection in an editor or an IDE. You can combine; :doc:`AST matchers<LibASTMatchers>` and the refactoring engine to implement; refactorings that don't lend themselves well to source selection and/or have to; query ASTs for some particular nodes. We assume basic knowledge about the Clang AST. See the :doc:`Introduction; to the Clang AST <IntroductionToTheClangAST>` if you want to learn more; about how the AST is structured. .. FIXME: create new refactoring action tutorial and link to the tutorial. Introduction; ------------. Clang's refactoring engine defines a set refactoring actions that implement; a number of different source transformations. The ``clang-refactor``; command-line tool can be used to perform these refactorings. Certain; refactorings are also available in other clients like text editors and IDEs. A refactoring action is a class that defines a list of related refactoring; operations (rules). These rules are grouped under a common umbrella - a single; ``clang-refactor`` command. In addition to rules, the refactoring action; provides the action's command name and description to ``clang-refactor``.; Each action must implement the ``RefactoringAction`` interface. Here's an; outline of a ``local-rename`` action:. .. code-block:: c++. class LocalRename final : public RefactoringAction {; public:; StringRef getCommand() const override { return ""local-rename""; }. StringRef getDescription() const override {; return ""Finds and renames symbols in code with no indexer supp",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst:883,learn,learn,883,interpreter/llvm-project/clang/docs/RefactoringEngine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst,1,['learn'],['learn']
Usability,==========================; Performance Training Data; ==========================. This directory contains simple source files for use as training data for; generating PGO data and linker order files for clang.; ,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/perf-training/README.txt:107,simpl,simple,107,interpreter/llvm-project/clang/utils/perf-training/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/perf-training/README.txt,1,['simpl'],['simple']
Usability,"=============================; User Guide for AMDGPU Backend; =============================. .. contents::; :local:. .. toctree::; :hidden:. AMDGPU/AMDGPUAsmGFX7; AMDGPU/AMDGPUAsmGFX8; AMDGPU/AMDGPUAsmGFX9; AMDGPU/AMDGPUAsmGFX900; AMDGPU/AMDGPUAsmGFX904; AMDGPU/AMDGPUAsmGFX906; AMDGPU/AMDGPUAsmGFX908; AMDGPU/AMDGPUAsmGFX90a; AMDGPU/AMDGPUAsmGFX940; AMDGPU/AMDGPUAsmGFX10; AMDGPU/AMDGPUAsmGFX1011; AMDGPU/AMDGPUAsmGFX1013; AMDGPU/AMDGPUAsmGFX1030; AMDGPU/AMDGPUAsmGFX11; AMDGPUModifierSyntax; AMDGPUOperandSyntax; AMDGPUInstructionSyntax; AMDGPUInstructionNotation; AMDGPUDwarfExtensionsForHeterogeneousDebugging; AMDGPUDwarfExtensionAllowLocationDescriptionOnTheDwarfExpressionStack/AMDGPUDwarfExtensionAllowLocationDescriptionOnTheDwarfExpressionStack. Introduction; ============. The AMDGPU backend provides ISA code generation for AMD GPUs, starting with the; R600 family up until the current GCN families. It lives in the; ``llvm/lib/Target/AMDGPU`` directory. LLVM; ====. .. _amdgpu-target-triples:. Target Triples; --------------. Use the Clang option ``-target <Architecture>-<Vendor>-<OS>-<Environment>``; to specify the target triple:. .. table:: AMDGPU Architectures; :name: amdgpu-architecture-table. ============ ==============================================================; Architecture Description; ============ ==============================================================; ``r600`` AMD GPUs HD2XXX-HD6XXX for graphics and compute shaders.; ``amdgcn`` AMD GPUs GCN GFX6 onwards for graphics and compute shaders.; ============ ==============================================================. .. table:: AMDGPU Vendors; :name: amdgpu-vendor-table. ============ ==============================================================; Vendor Description; ============ ==============================================================; ``amd`` Can be used for all AMD GPU usage.; ``mesa3d`` Can be used if the OS is ``mesa3d``.; ============ ========================================================",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:36,Guid,Guide,36,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['Guid'],['Guide']
Usability,"=============================; User Guide for NVPTX Back-end; =============================. .. contents::; :local:; :depth: 3. Introduction; ============. To support GPU programming, the NVPTX back-end supports a subset of LLVM IR; along with a defined set of conventions used to represent GPU programming; concepts. This document provides an overview of the general usage of the back-; end, including a description of the conventions used and the set of accepted; LLVM IR. .. note::. This document assumes a basic familiarity with CUDA and the PTX; assembly language. Information about the CUDA Driver API and the PTX assembly; language can be found in the `CUDA documentation; <http://docs.nvidia.com/cuda/index.html>`_. Conventions; ===========. Marking Functions as Kernels; ----------------------------. In PTX, there are two types of functions: *device functions*, which are only; callable by device code, and *kernel functions*, which are callable by host; code. By default, the back-end will emit device functions. Metadata is used to; declare a function as a kernel function. This metadata is attached to the; ``nvvm.annotations`` named metadata object, and has the following format:. .. code-block:: text. !0 = !{<function-ref>, metadata !""kernel"", i32 1}. The first parameter is a reference to the kernel function. The following; example shows a kernel function calling a device function in LLVM IR. The; function ``@my_kernel`` is callable from host code, but ``@my_fmad`` is not. .. code-block:: llvm. define float @my_fmad(float %x, float %y, float %z) {; %mul = fmul float %x, %y; %add = fadd float %mul, %z; ret float %add; }. define void @my_kernel(float* %ptr) {; %val = load float, float* %ptr; %ret = call float @my_fmad(float %val, float %val, float %val); store float %ret, float* %ptr; ret void; }. !nvvm.annotations = !{!1}; !1 = !{void (float*)* @my_kernel, !""kernel"", i32 1}. When compiled, the PTX kernel functions are callable by host-side code. .. _address_spaces:. Addre",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NVPTXUsage.rst:36,Guid,Guide,36,interpreter/llvm-project/llvm/docs/NVPTXUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NVPTXUsage.rst,1,['Guid'],['Guide']
Usability,"=============================; User Guide for RISC-V Target; =============================. .. contents::; :local:. Introduction; ============. The RISC-V target provides code generation for processors implementing; supported variations of the RISC-V specification. It lives in the; ``llvm/lib/Target/RISCV`` directory. Specification Documents; =======================. There have been a number of revisions to the RISC-V specifications. LLVM aims; to implement the most recent ratified version of the standard RISC-V base ISAs; and ISA extensions with pragmatic variances. The most recent specification can; be found at: https://github.com/riscv/riscv-isa-manual/releases/. `The official RISC-V International specification page; <https://riscv.org/technical/specifications/>`_. is also worth checking, but; tends to significantly lag the specifications linked above. Make sure to check; the `wiki for not yet integrated extensions; <https://wiki.riscv.org/display/HOME/Recently+Ratified+Extensions>`_ and note; that in addition, we sometimes carry support for extensions that have not yet; been ratified (these will be marked as experimental - see below) and support; various vendor-specific extensions (see below). The current known variances from the specification are:. * Unconditionally allowing instructions from zifencei, zicsr, zicntr, and; zihpm without gating them on the extensions being enabled. Previous; revisions of the specification included these instructions in the base; ISA, and we preserve this behavior to avoid breaking existing code. If; a future revision of the specification reuses these opcodes for other; extensions, we may need to reevaluate this choice, and thus recommend; users migrate build systems so as not to rely on this.; * Allowing CSRs to be named without gating on specific extensions. This; applies to all CSR names, not just those in zicsr, zicntr, and zihpm.; * The ordering of ``z*``, ``s*``, and ``x*`` prefixed extension names is not; enforced in user-sp",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/RISCVUsage.rst:36,Guid,Guide,36,interpreter/llvm-project/llvm/docs/RISCVUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/RISCVUsage.rst,1,['Guid'],['Guide']
Usability,=============================; User Guide for SPIR-V Target; =============================. .. contents::; :local:. .. toctree::; :hidden:. Introduction; ============. The SPIR-V target provides code generation for the SPIR-V binary format described; in `the official SPIR-V specification <https://www.khronos.org/registry/SPIR-V/>`_. .. _spirv-target-triples:. Target Triples; ==============. For cross-compilation into SPIR-V use option. ``-target <Architecture><Subarchitecture>-<Vendor>-<OS>-<Environment>``. to specify the target triple:. .. table:: SPIR-V Architectures. ============ ==============================================================; Architecture Description; ============ ==============================================================; ``spirv32`` SPIR-V with 32-bit pointer width.; ``spirv64`` SPIR-V with 64-bit pointer width.; ============ ==============================================================. .. table:: SPIR-V Subarchitectures. =============== ==============================================================; Subarchitecture Description; =============== ==============================================================; *<empty>* SPIR-V version deduced by tools based on the compiled input.; ``v1.0`` SPIR-V version 1.0.; ``v1.1`` SPIR-V version 1.1.; ``v1.2`` SPIR-V version 1.2.; ``v1.3`` SPIR-V version 1.3.; ``v1.4`` SPIR-V version 1.4.; ``v1.5`` SPIR-V version 1.5.; =============== ==============================================================. .. table:: SPIR-V Vendors. ===================== ==============================================================; Vendor Description; ===================== ==============================================================; *<empty>*/``unknown`` Generic SPIR-V target without any vendor-specific settings.; ===================== ==============================================================. .. table:: Operating Systems. ===================== ============================================================; OS Description,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SPIRVUsage.rst:36,Guid,Guide,36,interpreter/llvm-project/llvm/docs/SPIRVUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SPIRVUsage.rst,1,['Guid'],['Guide']
Usability,"==============================. .. contents::; :local:. .. warning::; This is a work in progress. Introduction; ============. This document is a reference manual for the Machine IR (MIR) serialization; format. MIR is a human readable serialization format that is used to represent; LLVM's :ref:`machine specific intermediate representation; <machine code representation>`. The MIR serialization format is designed to be used for testing the code; generation passes in LLVM. Overview; ========. The MIR serialization format uses a YAML container. YAML is a standard; data serialization language, and the full YAML language spec can be read at; `yaml.org; <http://www.yaml.org/spec/1.2/spec.html#Introduction>`_. A MIR file is split up into a series of `YAML documents`_. The first document; can contain an optional embedded LLVM IR module, and the rest of the documents; contain the serialized machine functions. .. _YAML documents: http://www.yaml.org/spec/1.2/spec.html#id2800132. MIR Testing Guide; =================. You can use the MIR format for testing in two different ways:. - You can write MIR tests that invoke a single code generation pass using the; ``-run-pass`` option in llc. - You can use llc's ``-stop-after`` option with existing or new LLVM assembly; tests and check the MIR output of a specific code generation pass. Testing Individual Code Generation Passes; -----------------------------------------. The ``-run-pass`` option in llc allows you to create MIR tests that invoke just; a single code generation pass. When this option is used, llc will parse an; input MIR file, run the specified code generation pass(es), and output the; resulting MIR code. You can generate an input MIR file for the test by using the ``-stop-after`` or; ``-stop-before`` option in llc. For example, if you would like to write a test; for the post register allocation pseudo instruction expansion pass, you can; specify the machine copy propagation pass in the ``-stop-after`` option, as it; runs j",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MIRLangRef.rst:1088,Guid,Guide,1088,interpreter/llvm-project/llvm/docs/MIRLangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MIRLangRef.rst,1,['Guid'],['Guide']
Usability,"===============================; ASTImporter: Merging Clang ASTs; ===============================. The ``ASTImporter`` class is part of Clang's core library, the AST library.; It imports nodes of an ``ASTContext`` into another ``ASTContext``. In this document, we assume basic knowledge about the Clang AST. See the :doc:`Introduction; to the Clang AST <IntroductionToTheClangAST>` if you want to learn more; about how the AST is structured.; Knowledge about :doc:`matching the Clang AST <LibASTMatchers>` and the `reference for the matchers <https://clang.llvm.org/docs/LibASTMatchersReference.html>`_ are also useful. .. contents::; :local:. Introduction; ------------. ``ASTContext`` holds long-lived AST nodes (such as types and decls) that can be referred to throughout the semantic analysis of a file.; In some cases it is preferable to work with more than one ``ASTContext``.; For example, we'd like to parse multiple different files inside the same Clang tool.; It may be convenient if we could view the set of the resulting ASTs as if they were one AST resulting from the parsing of each file together.; ``ASTImporter`` provides the way to copy types or declarations from one ``ASTContext`` to another.; We refer to the context from which we import as the **""from"" context** or *source context*; and the context into which we import as the **""to"" context** or *destination context*. Existing clients of the ``ASTImporter`` library are Cross Translation Unit (CTU) static analysis and the LLDB expression parser.; CTU static analysis imports a definition of a function if its definition is found in another translation unit (TU).; This way the analysis can breach out from the single TU limitation.; LLDB's ``expr`` command parses a user-defined expression, creates an ``ASTContext`` for that and then imports the missing definitions from the AST what we got from the debug information (DWARF, etc). Algorithm of the import; -----------------------. Importing one AST node copies that node int",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst:397,learn,learn,397,interpreter/llvm-project/clang/docs/LibASTImporter.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst,1,['learn'],['learn']
Usability,"===============================; Building a Distribution of LLVM; ===============================. .. contents::; :local:. Introduction; ============. This document is geared toward people who want to build and package LLVM and any; combination of LLVM sub-project tools for distribution. This document covers; useful features of the LLVM build system as well as best practices and general; information about packaging LLVM. If you are new to CMake you may find the :doc:`CMake` or :doc:`CMakePrimer`; documentation useful. Some of the things covered in this document are the inner; workings of the builds described in the :doc:`AdvancedBuilds` document. General Distribution Guidance; =============================. When building a distribution of a compiler it is generally advised to perform a; bootstrap build of the compiler. That means building a ""stage 1"" compiler with; your host toolchain, then building the ""stage 2"" compiler using the ""stage 1""; compiler. This is done so that the compiler you distribute benefits from all the; bug fixes, performance optimizations and general improvements provided by the; new compiler. In deciding how to build your distribution there are a few trade-offs that you; will need to evaluate. The big two are:. #. Compile time of the distribution against performance of the built compiler. #. Binary size of the distribution against performance of the built compiler. The guidance for maximizing performance of the generated compiler is to use LTO,; PGO, and statically link everything. This will result in an overall larger; distribution, and it will take longer to generate, but it provides the most; opportunity for the compiler to optimize. The guidance for minimizing distribution size is to dynamically link LLVM and; Clang libraries into the tools to reduce code duplication. This will come at a; substantial performance penalty to the generated binary both because it reduces; optimization opportunity, and because dynamic linking requires resolving s",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BuildingADistribution.rst:676,Guid,Guidance,676,interpreter/llvm-project/llvm/docs/BuildingADistribution.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BuildingADistribution.rst,1,['Guid'],['Guidance']
Usability,"===============================; ORC Design and Implementation; ===============================. .. contents::; :local:. Introduction; ============. This document aims to provide a high-level overview of the design and; implementation of the ORC JIT APIs. Except where otherwise stated all discussion; refers to the modern ORCv2 APIs (available since LLVM 7). Clients wishing to; transition from OrcV1 should see Section :ref:`transitioning_orcv1_to_orcv2`. Use-cases; =========. ORC provides a modular API for building JIT compilers. There are a number; of use cases for such an API. For example:. 1. The LLVM tutorials use a simple ORC-based JIT class to execute expressions; compiled from a toy language: Kaleidoscope. 2. The LLVM debugger, LLDB, uses a cross-compiling JIT for expression; evaluation. In this use case, cross compilation allows expressions compiled; in the debugger process to be executed on the debug target process, which may; be on a different device/architecture. 3. In high-performance JITs (e.g. JVMs, Julia) that want to make use of LLVM's; optimizations within an existing JIT infrastructure. 4. In interpreters and REPLs, e.g. Cling (C++) and the Swift interpreter. By adopting a modular, library-based design we aim to make ORC useful in as many; of these contexts as possible. Features; ========. ORC provides the following features:. **JIT-linking**; ORC provides APIs to link relocatable object files (COFF, ELF, MachO) [1]_; into a target process at runtime. The target process may be the same process; that contains the JIT session object and jit-linker, or may be another process; (even one running on a different machine or architecture) that communicates; with the JIT via RPC. **LLVM IR compilation**; ORC provides off the shelf components (IRCompileLayer, SimpleCompiler,; ConcurrentIRCompiler) that make it easy to add LLVM IR to a JIT'd process. **Eager and lazy compilation**; By default, ORC will compile symbols as soon as they are looked up in the JIT; se",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ORCv2.rst:627,simpl,simple,627,interpreter/llvm-project/llvm/docs/ORCv2.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ORCv2.rst,1,['simpl'],['simple']
Usability,"===============================; TableGen Programmer's Reference; ===============================. .. sectnum::. .. contents::; :local:. Introduction; ============. The purpose of TableGen is to generate complex output files based on; information from source files that are significantly easier to code than the; output files would be, and also easier to maintain and modify over time. The; information is coded in a declarative style involving classes and records,; which are then processed by TableGen. The internalized records are passed on; to various *backends*, which extract information from a subset of the records; and generate one or more output files. These output files are typically; ``.inc`` files for C++, but may be any type of file that the backend; developer needs. This document describes the LLVM TableGen facility in detail. It is intended; for the programmer who is using TableGen to produce code for a project. If; you are looking for a simple overview, check out the :doc:`TableGen Overview; <./index>`. The various ``*-tblgen`` commands used to invoke TableGen are; described in :doc:`tblgen Family - Description to C++; Code<../CommandGuide/tblgen>`. An example of a backend is ``RegisterInfo``, which generates the register; file information for a particular target machine, for use by the LLVM; target-independent code generator. See :doc:`TableGen Backends <./BackEnds>`; for a description of the LLVM TableGen backends, and :doc:`TableGen; Backend Developer's Guide <./BackGuide>` for a guide to writing a new; backend. Here are a few of the things backends can do. * Generate the register file information for a particular target machine. * Generate the instruction definitions for a target. * Generate the patterns that the code generator uses to match instructions; to intermediate representation (IR) nodes. * Generate semantic attribute identifiers for Clang. * Generate abstract syntax tree (AST) declaration node definitions for Clang. * Generate AST statement nod",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst:960,simpl,simple,960,interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,1,['simpl'],['simple']
Usability,"===============================; lit - A Software Testing Tool; ===============================. About; =====. *lit* is a portable tool for executing LLVM and Clang style test suites,; summarizing their results, and providing indication of failures. *lit* is; designed to be a lightweight testing tool with as simple a user interface as; possible. Features; ========. * Portable!; * Flexible test discovery.; * Parallel test execution.; * Support for multiple test formats and test suite designs. Documentation; =============. The official *lit* documentation is in the man page, available online at the LLVM; Command Guide: http://llvm.org/cmds/lit.html. Source; ======. The *lit* source is available as part of LLVM, in the LLVM source repository:; https://github.com/llvm/llvm-project/tree/main/llvm/utils/lit. Contributing to lit; ===================. Please browse the issues labeled *tools:llvm-lit* in LLVM's issue tracker for; ideas on what to work on:; https://github.com/llvm/llvm-project/labels/tools%3Allvm-lit. Before submitting patches, run the test suite to ensure nothing has regressed::. # From within your LLVM source directory.; utils/lit/lit.py \; --path /path/to/your/llvm/build/bin \; utils/lit/tests. Note that lit's tests depend on ``not`` and ``FileCheck``, LLVM utilities.; You will need to have built LLVM tools in order to run lit's test suite; successfully. You'll also want to confirm that lit continues to work when testing LLVM.; Follow the instructions in http://llvm.org/docs/TestingGuide.html to run the; regression test suite:. make check-llvm. And be sure to run the llvm-lit wrapper script as well:. /path/to/your/llvm/build/bin/llvm-lit utils/lit/tests. Finally, make sure lit works when installed via setuptools:. python utils/lit/setup.py install; lit --path /path/to/your/llvm/build/bin utils/lit/tests. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/README.rst:310,simpl,simple,310,interpreter/llvm-project/llvm/utils/lit/README.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/README.rst,2,"['Guid', 'simpl']","['Guide', 'simple']"
Usability,"================================; LLVM Tutorial: Table of Contents; ================================. Kaleidoscope: Implementing a Language with LLVM; ===============================================. .. toctree::; :hidden:. MyFirstLanguageFrontend/index. :doc:`MyFirstLanguageFrontend/index`; This is the ""Kaleidoscope"" Language tutorial, showing how to implement a simple; language using LLVM components in C++. .. toctree::; :titlesonly:; :glob:; :numbered:. MyFirstLanguageFrontend/LangImpl*. Building a JIT in LLVM; ===============================================. .. toctree::; :titlesonly:; :glob:; :numbered:. BuildingAJIT*. External Tutorials; ==================. `Tutorial: Creating an LLVM Backend for the Cpu0 Architecture <http://jonathan2251.github.io/lbd/>`_; A step-by-step tutorial for developing an LLVM backend. Under; active development at `<https://github.com/Jonathan2251/lbd>`_ (please; contribute!). `Howto: Implementing LLVM Integrated Assembler`_; A simple guide for how to implement an LLVM integrated assembler for an; architecture. .. _`Howto: Implementing LLVM Integrated Assembler`: http://www.embecosm.com/appnotes/ean10/ean10-howto-llvmas-1.0.html. Advanced Topics; ===============. #. `Writing an Optimization for LLVM <https://llvm.org/pubs/2004-09-22-LCPCLLVMTutorial.html>`_. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/index.rst:366,simpl,simple,366,interpreter/llvm-project/llvm/docs/tutorial/index.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/index.rst,3,"['guid', 'simpl']","['guide', 'simple']"
Usability,"=================================; How To Release LLVM To The Public; =================================. Introduction; ============. This document contains information about successfully releasing LLVM ---; including sub-projects: e.g., ``clang`` and ``compiler-rt`` --- to the public.; It is the Release Manager's responsibility to ensure that a high quality build; of LLVM is released. If you're looking for the document on how to test the release candidates and; create the binary packages, please refer to the :doc:`ReleaseProcess` instead. .. _timeline:. Release Timeline; ================. LLVM is released on a time based schedule --- with major releases roughly; every 6 months. In between major releases there may be dot releases.; The release manager will determine if and when to make a dot release based; on feedback from the community. Typically, dot releases should be made if; there are large number of bug-fixes in the stable branch or a critical bug; has been discovered that affects a large number of users. Unless otherwise stated, dot releases will follow the same procedure as; major releases. Annual Release Schedule; -----------------------. Here is the annual release schedule for LLVM. This is meant to be a; guide, and release managers are not required to follow this exactly.; Releases should be tagged on Tuesdays. =============================== =========================; Release Approx. Date; =============================== =========================; *release branch: even releases* *4th Tue in January*; *release branch: odd releases* *4th Tue in July*; X.1.0-rc1 3 days after branch.; X.1.0-rc2 2 weeks after branch.; X.1.0-rc3 4 weeks after branch; **X.1.0-final** **6 weeks after branch**; **X.1.1** **8 weeks after branch**; **X.1.2** **10 weeks after branch**; **X.1.3** **12 weeks after branch**; **X.1.4** **14 weeks after branch**; **X.1.5** **16 weeks after branch**; **X.1.6 (if necessary)** **18 weeks after branch**; =============================== =======",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToReleaseLLVM.rst:820,feedback,feedback,820,interpreter/llvm-project/llvm/docs/HowToReleaseLLVM.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToReleaseLLVM.rst,1,['feedback'],['feedback']
Usability,"=================================; LLVM Testing Infrastructure Guide; =================================. .. contents::; :local:. .. toctree::; :hidden:. TestSuiteGuide; TestSuiteMakefileGuide. Overview; ========. This document is the reference manual for the LLVM testing; infrastructure. It documents the structure of the LLVM testing; infrastructure, the tools needed to use it, and how to add and run; tests. Requirements; ============. In order to use the LLVM testing infrastructure, you will need all of the; software required to build LLVM, as well as `Python <http://python.org>`_ 3.6 or; later. LLVM Testing Infrastructure Organization; ========================================. The LLVM testing infrastructure contains three major categories of tests:; unit tests, regression tests and whole programs. The unit tests and regression; tests are contained inside the LLVM repository itself under ``llvm/unittests``; and ``llvm/test`` respectively and are expected to always pass -- they should be; run before every commit. The whole programs tests are referred to as the ""LLVM test suite"" (or; ""test-suite"") and are in the ``test-suite``; `repository on GitHub <https://github.com/llvm/llvm-test-suite.git>`_.; For historical reasons, these tests are also referred to as the ""nightly; tests"" in places, which is less ambiguous than ""test-suite"" and remains; in use although we run them much more often than nightly. Unit tests; ----------. Unit tests are written using `Google Test <https://github.com/google/googletest/blob/master/docs/primer.md>`_; and `Google Mock <https://github.com/google/googletest/blob/master/docs/gmock_for_dummies.md>`_; and are located in the ``llvm/unittests`` directory.; In general unit tests are reserved for targeting the support library and other; generic data structure, we prefer relying on regression tests for testing; transformations and analysis on the IR. Regression tests; ----------------. The regression tests are small pieces of code that test a spe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst:63,Guid,Guide,63,interpreter/llvm-project/llvm/docs/TestingGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst,1,['Guid'],['Guide']
Usability,"=================================; MergeFunctions pass, how it works; =================================. .. contents::; :local:. Introduction; ============; Sometimes code contains equal functions, or functions that does exactly the same; thing even though they are non-equal on the IR level (e.g.: multiplication on 2; and 'shl 1'). It could happen due to several reasons: mainly, the usage of; templates and automatic code generators. Though, sometimes the user itself could; write the same thing twice :-). The main purpose of this pass is to recognize such functions and merge them. This document is the extension to pass comments and describes the pass logic. It; describes the algorithm that is used in order to compare functions and; explains how we could combine equal functions correctly to keep the module; valid. Material is brought in a top-down form, so the reader could start to learn pass; from high level ideas and end with low-level algorithm details, thus preparing; him or her for reading the sources. The main goal is to describe the algorithm and logic here and the concept. If; you *don't want* to read the source code, but want to understand pass; algorithms, this document is good for you. The author tries not to repeat the; source-code and covers only common cases to avoid the cases of needing to; update this document after any minor code changes. What should I know to be able to follow along with this document?; -----------------------------------------------------------------. The reader should be familiar with common compile-engineering principles and; LLVM code fundamentals. In this article, we assume the reader is familiar with; `Single Static Assignment; <http://en.wikipedia.org/wiki/Static_single_assignment_form>`_; concept and has an understanding of; `IR structure <https://llvm.org/docs/LangRef.html#high-level-structure>`_. We will use terms such as; ""`module <https://llvm.org/docs/LangRef.html#high-level-structure>`_"",; ""`function <https://llvm.org/do",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MergeFunctions.rst:893,learn,learn,893,interpreter/llvm-project/llvm/docs/MergeFunctions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MergeFunctions.rst,1,['learn'],['learn']
Usability,"=================================; User Guide for the DirectX Target; =================================. .. warning::; Disclaimer: The DirectX backend is experimental and under active development.; It is not yet feature complete or ready to be used outside of experimental or; demonstration contexts. .. contents::; :local:. .. toctree::; :hidden:. Introduction; ============. The DirectX target implements the DirectX programmability interfaces. These; interfaces are documented in the `DirectX Specifications. <https://github.com/Microsoft/DirectX-Specs>`_. Initially the backend is aimed at supporting DirectX 12, and support for DirectX; 11 is planned at a later date. The DirectX backend is currently experimental and is not shipped with any; release builds of LLVM tools. To enable building the DirectX backend locally add; ``DirectX`` to the ``LLVM_EXPERIMENTAL_TARGETS_TO_BUILD`` CMake option. For more; information on building LLVM see the :doc:`CMake` documentation. .. _dx-target-triples:. Target Triples; ==============. At present the DirectX target only supports the ``dxil`` architecture, which; generates code for the; `DirectX Intermediate Language. <https://github.com/microsoft/DirectXShaderCompiler/blob/main/docs/DXIL.rst>`_. In addition to target architecture, the DirectX backend also needs to know the; target runtime version and pipeline stage. These are expressed using the OS and; Environment triple component. Presently the DirectX backend requires targeting the ``shadermodel`` OS, and; supports versions 6.0+ (at time of writing the latest announced version is 6.7). .. table:: DirectX Environments. ================== ========================================================; Environment Description; ================== ========================================================; ``pixel`` Pixel shader; ``vertex`` Vertex shader; ``geometry`` Geometry shader; ``hull`` Hull shader (tesselation); ``domain`` Domain shader (tesselation); ``compute`` Compute kernel; ``librar",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DirectXUsage.rst:40,Guid,Guide,40,interpreter/llvm-project/llvm/docs/DirectXUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DirectXUsage.rst,1,['Guid'],['Guide']
Usability,"===================================; Stack maps and patch points in LLVM; ===================================. .. contents::; :local:; :depth: 2. Definitions; ===========. In this document we refer to the ""runtime"" collectively as all; components that serve as the LLVM client, including the LLVM IR; generator, object code consumer, and code patcher. A stack map records the location of ``live values`` at a particular; instruction address. These ``live values`` do not refer to all the; LLVM values live across the stack map. Instead, they are only the; values that the runtime requires to be live at this point. For; example, they may be the values the runtime will need to resume; program execution at that point independent of the compiled function; containing the stack map. LLVM emits stack map data into the object code within a designated; :ref:`stackmap-section`. This stack map data contains a record for; each stack map. The record stores the stack map's instruction address; and contains an entry for each mapped value. Each entry encodes a; value's location as a register, stack offset, or constant. A patch point is an instruction address at which space is reserved for; patching a new instruction sequence at run time. Patch points look; much like calls to LLVM. They take arguments that follow a calling; convention and may return a value. They also imply stack map; generation, which allows the runtime to locate the patchpoint and; find the location of ``live values`` at that point. Motivation; ==========. This functionality is currently experimental but is potentially useful; in a variety of settings, the most obvious being a runtime (JIT); compiler. Example applications of the patchpoint intrinsics are; implementing an inline call cache for polymorphic method dispatch or; optimizing the retrieval of properties in dynamically typed languages; such as JavaScript. The intrinsics documented here are currently used by the JavaScript; compiler within the open source WebKit pr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/StackMaps.rst:677,resume,resume,677,interpreter/llvm-project/llvm/docs/StackMaps.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/StackMaps.rst,1,['resume'],['resume']
Usability,"===================================; TableGen Backend Developer's Guide; ===================================. .. sectnum::. .. contents::; :local:. Introduction; ============. The purpose of TableGen is to generate complex output files based on; information from source files that are significantly easier to code than the; output files would be, and also easier to maintain and modify over time. The; information is coded in a declarative style involving classes and records,; which are then processed by TableGen. The internalized records are passed on; to various backends, which extract information from a subset of the records; and generate an output file. These output files are typically ``.inc`` files; for C++, but may be any type of file that the backend developer needs. This document is a guide to writing a backend for TableGen. It is not a; complete reference manual, but rather a guide to using the facilities; provided by TableGen for the backends. For a complete reference to the; various data structures and functions involved, see the primary TableGen; header file (``record.h``) and/or the Doxygen documentation. This document assumes that you have read the :doc:`TableGen Programmer's; Reference <./ProgRef>`, which provides a detailed reference for coding; TableGen source files. For a description of the existing backends, see; :doc:`TableGen BackEnds <./BackEnds>`. Data Structures; ===============. The following sections describe the data structures that contain the classes; and records that are collected from the TableGen source files by the; TableGen parser. Note that the term *class* refers to an abstract record; class, while the term *record* refers to a concrete record. Unless otherwise noted, functions associated with classes are instance; functions. ``RecordKeeper``; ----------------. An instance of the ``RecordKeeper`` class acts as the container for all the; classes and records parsed and collected by TableGen. The ``RecordKeeper``; instance is passed to t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/BackGuide.rst:66,Guid,Guide,66,interpreter/llvm-project/llvm/docs/TableGen/BackGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/BackGuide.rst,3,"['Guid', 'guid']","['Guide', 'guide']"
Usability,"=====================================; Coroutines in LLVM; =====================================. .. contents::; :local:; :depth: 3. .. warning::; Compatibility across LLVM releases is not guaranteed. Introduction; ============. .. _coroutine handle:. LLVM coroutines are functions that have one or more `suspend points`_.; When a suspend point is reached, the execution of a coroutine is suspended and; control is returned back to its caller. A suspended coroutine can be resumed; to continue execution from the last suspend point or it can be destroyed. In the following example, we call function `f` (which may or may not be a; coroutine itself) that returns a handle to a suspended coroutine; (**coroutine handle**) that is used by `main` to resume the coroutine twice and; then destroy it:. .. code-block:: llvm. define i32 @main() {; entry:; %hdl = call ptr @f(i32 4); call void @llvm.coro.resume(ptr %hdl); call void @llvm.coro.resume(ptr %hdl); call void @llvm.coro.destroy(ptr %hdl); ret i32 0; }. .. _coroutine frame:. In addition to the function stack frame which exists when a coroutine is; executing, there is an additional region of storage that contains objects that; keep the coroutine state when a coroutine is suspended. This region of storage; is called the **coroutine frame**. It is created when a coroutine is called; and destroyed when a coroutine either runs to completion or is destroyed; while suspended. LLVM currently supports two styles of coroutine lowering. These styles; support substantially different sets of features, have substantially; different ABIs, and expect substantially different patterns of frontend; code generation. However, the styles also have a great deal in common. In all cases, an LLVM coroutine is initially represented as an ordinary LLVM; function that has calls to `coroutine intrinsics`_ defining the structure of; the coroutine. The coroutine function is then, in the most general case,; rewritten by the coroutine lowering passes to become t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:473,resume,resumed,473,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,4,['resume'],"['resume', 'resumed']"
Usability,"======================================; test-suite Makefile Guide (deprecated); ======================================. .. contents::; :local:. Overview; ========. First, all tests are executed within the LLVM object directory tree.; They *are not* executed inside of the LLVM source tree. This is because; the test suite creates temporary files during execution. To run the test suite, you need to use the following steps:. #. Check out the ``test-suite`` module with:. .. code-block:: bash. % git clone https://github.com/llvm/llvm-test-suite.git test-suite. #. FIXME: these directions are outdated and won't work. Figure out; what the correct thing to do is, and write it down here. #. Configure and build ``llvm``. #. Configure and build ``llvm-gcc``. #. Install ``llvm-gcc`` somewhere. #. *Re-configure* ``llvm`` from the top level of each build tree (LLVM; object directory tree) in which you want to run the test suite, just; as you do before building LLVM. During the *re-configuration*, you must either: (1) have ``llvm-gcc``; you just built in your path, or (2) specify the directory where your; just-built ``llvm-gcc`` is installed using; ``--with-llvmgccdir=$LLVM_GCC_DIR``. You must also tell the configure machinery that the test suite is; available so it can be configured for your build tree:. .. code-block:: bash. % cd $LLVM_OBJ_ROOT ; $LLVM_SRC_ROOT/configure [--with-llvmgccdir=$LLVM_GCC_DIR]. [Remember that ``$LLVM_GCC_DIR`` is the directory where you; *installed* llvm-gcc, not its src or obj directory.]. #. You can now run the test suite from your build tree as follows:. .. code-block:: bash. % cd $LLVM_OBJ_ROOT/projects/test-suite; % make. Note that the second and third steps only need to be done once. After; you have the suite checked out and configured, you don't need to do it; again (unless the test code or configure script changes). Configuring External Tests; ==========================. In order to run the External tests in the ``test-suite`` module, you; must s",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestSuiteMakefileGuide.rst:60,Guid,Guide,60,interpreter/llvm-project/llvm/docs/TestSuiteMakefileGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestSuiteMakefileGuide.rst,1,['Guid'],['Guide']
Usability,"=======================================; LLVM's Optional Rich Disassembly Output; =======================================. .. contents::; :local:. Introduction; ============. LLVM's default disassembly output is raw text. To allow consumers more ability; to introspect the instructions' textual representation or to reformat for a more; user friendly display there is an optional rich disassembly output. This optional output is sufficient to reference into individual portions of the; instruction text. This is intended for clients like disassemblers, list file; generators, and pretty-printers, which need more than the raw instructions and; the ability to print them. To provide this functionality the assembly text is marked up with annotations.; The markup is simple enough in syntax to be robust even in the case of version; mismatches between consumers and producers. That is, the syntax generally does; not carry semantics beyond ""this text has an annotation,"" so consumers can; simply ignore annotations they do not understand or do not care about. After calling ``LLVMCreateDisasm()`` to create a disassembler context the; optional output is enable with this call:. .. code-block:: c. LLVMSetDisasmOptions(DC, LLVMDisassembler_Option_UseMarkup);. Then subsequent calls to ``LLVMDisasmInstruction()`` will return output strings; with the marked up annotations. Instruction Annotations; =======================. .. _contextual markups:. Contextual markups; ------------------. Annotated assembly display will supply contextual markup to help clients more; efficiently implement things like pretty printers. Most markup will be target; independent, so clients can effectively provide good display without any target; specific knowledge. Annotated assembly goes through the normal instruction printer, but optionally; includes contextual tags on portions of the instruction string. An annotation; is any '<' '>' delimited section of text(1). .. code-block:: bat. annotation: '<' tag-name tag-mod",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MarkedUpDisassembly.rst:765,simpl,simple,765,interpreter/llvm-project/llvm/docs/MarkedUpDisassembly.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MarkedUpDisassembly.rst,2,['simpl'],"['simple', 'simply']"
Usability,"=======================================; The Often Misunderstood GEP Instruction; =======================================. .. contents::; :local:. Introduction; ============. This document seeks to dispel the mystery and confusion surrounding LLVM's; `GetElementPtr <LangRef.html#getelementptr-instruction>`_ (GEP) instruction.; Questions about the wily GEP instruction are probably the most frequently; occurring questions once a developer gets down to coding with LLVM. Here we lay; out the sources of confusion and show that the GEP instruction is really quite; simple. Address Computation; ===================. When people are first confronted with the GEP instruction, they tend to relate; it to known concepts from other programming paradigms, most notably C array; indexing and field selection. GEP closely resembles C array indexing and field; selection, however it is a little different and this leads to the following; questions. What is the first index of the GEP instruction?; -----------------------------------------------. Quick answer: The index stepping through the second operand. The confusion with the first index usually arises from thinking about the; GetElementPtr instruction as if it was a C index operator. They aren't the; same. For example, when we write, in ""C"":. .. code-block:: c++. AType *Foo;; ...; X = &Foo->F;. it is natural to think that there is only one index, the selection of the field; ``F``. However, in this example, ``Foo`` is a pointer. That pointer; must be indexed explicitly in LLVM. C, on the other hand, indices through it; transparently. To arrive at the same address location as the C code, you would; provide the GEP instruction with two index operands. The first operand indexes; through the pointer; the second operand indexes the field ``F`` of the; structure, just as if you wrote:. .. code-block:: c++. X = &Foo[0].F;. Sometimes this question gets rephrased as:. .. _GEP index through first pointer:. *Why is it okay to index through the first",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GetElementPtr.rst:565,simpl,simple,565,interpreter/llvm-project/llvm/docs/GetElementPtr.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GetElementPtr.rst,1,['simpl'],['simple']
Usability,"========================================; The PDB Info Stream (aka the PDB Stream); ========================================. .. contents::; :local:. .. _pdb_stream_header:. Stream Header; =============; At offset 0 of the PDB Stream is a header with the following layout:. .. code-block:: c++. struct PdbStreamHeader {; ulittle32_t Version;; ulittle32_t Signature;; ulittle32_t Age;; Guid UniqueId;; };. - **Version** - A Value from the following enum:. .. code-block:: c++. enum class PdbStreamVersion : uint32_t {; VC2 = 19941610,; VC4 = 19950623,; VC41 = 19950814,; VC50 = 19960307,; VC98 = 19970604,; VC70Dep = 19990604,; VC70 = 20000404,; VC80 = 20030901,; VC110 = 20091201,; VC140 = 20140508,; };. While the meaning of this field appears to be obvious, in practice we have; never observed a value other than ``VC70``, even with modern versions of; the toolchain, and it is unclear why the other values exist. It is assumed; that certain aspects of the PDB stream's layout, and perhaps even that of; the other streams, will change if the value is something other than ``VC70``. - **Signature** - A 32-bit time-stamp generated with a call to ``time()`` at; the time the PDB file is written. Note that due to the inherent uniqueness; problems of using a timestamp with 1-second granularity, this field does not; really serve its intended purpose, and as such is typically ignored in favor; of the ``Guid`` field, described below. - **Age** - The number of times the PDB file has been written. This can be used; along with ``Guid`` to match the PDB to its corresponding executable. - **Guid** - A 128-bit identifier guaranteed to be unique across space and time.; In general, this can be thought of as the result of calling the Win32 API; `UuidCreate <https://msdn.microsoft.com/en-us/library/windows/desktop/aa379205(v=vs.85).aspx>`__,; although LLVM cannot rely on that, as it must work on non-Windows platforms. .. _pdb_named_stream_map:. Named Stream Map; ================. Following the header",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PDB/PdbStream.rst:385,Guid,Guid,385,interpreter/llvm-project/llvm/docs/PDB/PdbStream.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PDB/PdbStream.rst,1,['Guid'],['Guid']
Usability,"=========================================+; | uint64_t | key offset | Absolute byte offset of the key in the string table |; +----------+--------------+-------------------------------------------------------+; | uint64_t | value offset | Absolute byte offset of the value in the string table |; +----------+--------------+-------------------------------------------------------+. The string entries simply provide offsets to a key and value pair in the; binary images string table. The string table is simply a collection of null; terminated strings with defined offsets in the image. The string entry allows us; to create a key-value pair from this string table. This is used for passing; arbitrary arguments to the image, such as the triple and architecture. All of these structures are combined to form a single binary blob, the order; does not matter because of the use of absolute offsets. This makes it easier to; extend in the future. As mentioned previously, multiple offloading images are; bundled together by simply concatenating them in this format. Because we have; the magic bytes and size of each image, we can extract them as-needed. Usage; =====. This tool can be used with the following arguments. Generally information is; passed as a key-value pair to the ``image=`` argument. The ``file`` and; ``triple``, arguments are considered mandatory to make a valid image.; The ``arch`` argument is suggested. .. code-block:: console. OVERVIEW: A utility for bundling several object files into a single binary.; The output binary can then be embedded into the host section table; to create a fatbinary containing offloading code. USAGE: clang-offload-packager [options]. OPTIONS:. Generic Options:. --help - Display available options (--help-hidden for more); --help-list - Display list of available options (--help-list-hidden for more); --version - Display the version of this program. clang-offload-packager options:. --image=<<key>=<value>,...> - List of key and value arguments. Requir",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangOffloadPackager.rst:7425,simpl,simply,7425,interpreter/llvm-project/clang/docs/ClangOffloadPackager.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangOffloadPackager.rst,1,['simpl'],['simply']
Usability,"=========================================; A guide to Dockerfiles for building LLVM; =========================================. Introduction; ============; You can find a number of sources to build docker images with LLVM components in; ``llvm/utils/docker``. They can be used by anyone who wants to build the docker; images for their own use, or as a starting point for someone who wants to write; their own Dockerfiles. We currently provide Dockerfiles with ``debian10`` and ``nvidia-cuda`` base images.; We also provide an ``example`` image, which contains placeholders that one would need; to fill out in order to produce Dockerfiles for a new docker image. Why?; ----; Docker images provide a way to produce binary distributions of; software inside a controlled environment. Having Dockerfiles to builds docker images; inside LLVM repo makes them much more discoverable than putting them into any other; place. Docker basics; -------------; If you've never heard about Docker before, you might find this section helpful; to get a very basic explanation of it.; `Docker <https://www.docker.com/>`_ is a popular solution for running programs in; an isolated and reproducible environment, especially to maintain releases for; software deployed to large distributed fleets.; It uses linux kernel namespaces and cgroups to provide a lightweight isolation; inside currently running linux kernel.; A single active instance of dockerized environment is called a *docker; container*.; A snapshot of a docker container filesystem is called a *docker image*.; One can start a container from a prebuilt docker image. Docker images are built from a so-called *Dockerfile*, a source file written in; a specialized language that defines instructions to be used when build; the docker image (see `official; documentation <https://docs.docker.com/engine/reference/builder/>`_ for more; details). A minimal Dockerfile typically contains a base image and a number; of RUN commands that have to be executed to build ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Docker.rst:45,guid,guide,45,interpreter/llvm-project/llvm/docs/Docker.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Docker.rst,1,['guid'],['guide']
Usability,"==========================================; The LLVM Target-Independent Code Generator; ==========================================. .. role:: raw-html(raw); :format: html. .. raw:: html. <style>; .unknown { background-color: #C0C0C0; text-align: center; }; .unknown:before { content: ""?"" }; .no { background-color: #C11B17 }; .no:before { content: ""N"" }; .partial { background-color: #F88017 }; .yes { background-color: #0F0; }; .yes:before { content: ""Y"" }; .na { background-color: #6666FF; }; .na:before { content: ""N/A"" }; </style>. .. contents::; :local:. .. warning::; This is a work in progress. Introduction; ============. The LLVM target-independent code generator is a framework that provides a suite; of reusable components for translating the LLVM internal representation to the; machine code for a specified target---either in assembly form (suitable for a; static compiler) or in binary machine code format (usable for a JIT; compiler). The LLVM target-independent code generator consists of six main; components:. 1. `Abstract target description`_ interfaces which capture important properties; about various aspects of the machine, independently of how they will be used.; These interfaces are defined in ``include/llvm/Target/``. 2. Classes used to represent the `code being generated`_ for a target. These; classes are intended to be abstract enough to represent the machine code for; *any* target machine. These classes are defined in; ``include/llvm/CodeGen/``. At this level, concepts like ""constant pool; entries"" and ""jump tables"" are explicitly exposed. 3. Classes and algorithms used to represent code at the object file level, the; `MC Layer`_. These classes represent assembly level constructs like labels,; sections, and instructions. At this level, concepts like ""constant pool; entries"" and ""jump tables"" don't exist. 4. `Target-independent algorithms`_ used to implement various phases of native; code generation (register allocation, scheduling, stack frame representati",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:921,usab,usable,921,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,1,['usab'],['usable']
Usability,"=============================================; Building a JIT: Per-function Lazy Compilation; =============================================. .. contents::; :local:. **This tutorial is under active development. It is incomplete and details may; change frequently.** Nonetheless we invite you to try it out as it stands, and; we welcome any feedback. Chapter 3 Introduction; ======================. **Warning: This text is currently out of date due to ORC API updates.**. **The example code has been updated and can be used. The text will be updated; once the API churn dies down.**. Welcome to Chapter 3 of the ""Building an ORC-based JIT in LLVM"" tutorial. This; chapter discusses lazy JITing and shows you how to enable it by adding an ORC; CompileOnDemand layer the JIT from `Chapter 2 <BuildingAJIT2.html>`_. Lazy Compilation; ================. When we add a module to the KaleidoscopeJIT class from Chapter 2 it is; immediately optimized, compiled and linked for us by the IRTransformLayer,; IRCompileLayer and RTDyldObjectLinkingLayer respectively. This scheme, where all the; work to make a Module executable is done up front, is simple to understand and; its performance characteristics are easy to reason about. However, it will lead; to very high startup times if the amount of code to be compiled is large, and; may also do a lot of unnecessary compilation if only a few compiled functions; are ever called at runtime. A truly ""just-in-time"" compiler should allow us to; defer the compilation of any given function until the moment that function is; first called, improving launch times and eliminating redundant work. In fact,; the ORC APIs provide us with a layer to lazily compile LLVM IR:; *CompileOnDemandLayer*. The CompileOnDemandLayer class conforms to the layer interface described in; Chapter 2, but its addModule method behaves quite differently from the layers; we have seen so far: rather than doing any work up front, it just scans the; Modules being added and arranges for each",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT3.rst:339,feedback,feedback,339,interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT3.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT3.rst,1,['feedback'],['feedback']
Usability,"=============================================; My First Language Frontend with LLVM Tutorial; =============================================. .. toctree::; :hidden:. LangImpl01; LangImpl02; LangImpl03; LangImpl04; LangImpl05; LangImpl06; LangImpl07; LangImpl08; LangImpl09; LangImpl10. **Requirements:** This tutorial assumes you know C++, but no previous; compiler experience is necessary. Welcome to the ""My First Language Frontend with LLVM"" tutorial. Here we; run through the implementation of a simple language, showing; how fun and easy it can be. This tutorial will get you up and running; fast and show a concrete example of something that uses LLVM to generate; code. This tutorial introduces the simple ""Kaleidoscope"" language, building it; iteratively over the course of several chapters, showing how it is built; over time. This lets us cover a range of language design and LLVM-specific; ideas, showing and explaining the code for it all along the way,; and reduces the overwhelming amount of details up front. We strongly; encourage that you *work with this code* - make a copy and hack it up and; experiment. **Warning**: In order to focus on teaching compiler techniques and LLVM; specifically,; this tutorial does *not* show best practices in software engineering; principles. For example, the code uses global variables; pervasively, doesn't use; `visitors <http://en.wikipedia.org/wiki/Visitor_pattern>`_, etc... but; instead keeps things simple and focuses on the topics at hand. This tutorial is structured into chapters covering individual topics,; allowing you to skip ahead as you wish:. - `Chapter #1: Kaleidoscope language and Lexer <LangImpl01.html>`_ -; This shows where we are; going and the basic functionality that we want to build. A lexer; is also the first part of building a parser for a language, and we; use a simple C++ lexer which is easy to understand.; - `Chapter #2: Implementing a Parser and AST <LangImpl02.html>`_ -; With the lexer in place, we can talk abo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/index.rst:499,simpl,simple,499,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/index.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/index.rst,2,['simpl'],['simple']
Usability,"==============================================; Kaleidoscope: Adding JIT and Optimizer Support; ==============================================. .. contents::; :local:. Chapter 4 Introduction; ======================. Welcome to Chapter 4 of the ""`Implementing a language with; LLVM <index.html>`_"" tutorial. Chapters 1-3 described the implementation; of a simple language and added support for generating LLVM IR. This; chapter describes two new techniques: adding optimizer support to your; language, and adding JIT compiler support. These additions will; demonstrate how to get nice, efficient code for the Kaleidoscope; language. Trivial Constant Folding; ========================. Our demonstration for Chapter 3 is elegant and easy to extend.; Unfortunately, it does not produce wonderful code. The IRBuilder,; however, does give us obvious optimizations when compiling simple code:. ::. ready> def test(x) 1+2+x;; Read function definition:; define double @test(double %x) {; entry:; %addtmp = fadd double 3.000000e+00, %x; ret double %addtmp; }. This code is not a literal transcription of the AST built by parsing the; input. That would be:. ::. ready> def test(x) 1+2+x;; Read function definition:; define double @test(double %x) {; entry:; %addtmp = fadd double 2.000000e+00, 1.000000e+00; %addtmp1 = fadd double %addtmp, %x; ret double %addtmp1; }. Constant folding, as seen above, in particular, is a very common and; very important optimization: so much so that many language implementors; implement constant folding support in their AST representation. With LLVM, you don't need this support in the AST. Since all calls to; build LLVM IR go through the LLVM IR builder, the builder itself checked; to see if there was a constant folding opportunity when you call it. If; so, it just does the constant fold and return the constant instead of; creating an instruction. Well, that was easy :). In practice, we recommend always using; ``IRBuilder`` when generating code like this. It has no ""s",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl04.rst:355,simpl,simple,355,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl04.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl04.rst,2,['simpl'],['simple']
Usability,"==============================================; LLVM Atomic Instructions and Concurrency Guide; ==============================================. .. contents::; :local:. Introduction; ============. LLVM supports instructions which are well-defined in the presence of threads and; asynchronous signals. The atomic instructions are designed specifically to provide readable IR and; optimized code generation for the following:. * The C++ ``<atomic>`` header and C ``<stdatomic.h>`` headers. These; were originally added in C++11 and C11. The memory model has been; subsequently adjusted to correct errors in the initial; specification, so LLVM currently intends to implement the version; specified by C++20. (See the `C++20 draft standard; <https://isocpp.org/files/papers/N4860.pdf>`_ or the unofficial; `latest C++ draft <https://eel.is/c++draft/>`_. A `C2x draft; <https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3047.pdf>`_ is; also available, though the text has not yet been updated with the; errata corrected by C++20.). * Proper semantics for Java-style memory, for both ``volatile`` and regular; shared variables. (`Java Specification; <http://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html>`_). * gcc-compatible ``__sync_*`` builtins. (`Description; <https://gcc.gnu.org/onlinedocs/gcc/_005f_005fsync-Builtins.html>`_). * Other scenarios with atomic semantics, including ``static`` variables with; non-trivial constructors in C++. Atomic and volatile in the IR are orthogonal; ""volatile"" is the C/C++ volatile,; which ensures that every volatile load and store happens and is performed in the; stated order. A couple examples: if a SequentiallyConsistent store is; immediately followed by another SequentiallyConsistent store to the same; address, the first store can be erased. This transformation is not allowed for a; pair of volatile stores. On the other hand, a non-volatile non-atomic load can; be moved across a volatile load freely, but not an Acquire load. This document is int",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Atomics.rst:89,Guid,Guide,89,interpreter/llvm-project/llvm/docs/Atomics.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Atomics.rst,1,['Guid'],['Guide']
Usability,"=================================================; Choosing the Right Interface for Your Application; =================================================. Clang provides infrastructure to write tools that need syntactic and semantic; information about a program. This document will give a short introduction of; the different ways to write clang tools, and their pros and cons. LibClang; --------. `LibClang <https://clang.llvm.org/doxygen/group__CINDEX.html>`_ is a stable high; level C interface to clang. When in doubt LibClang is probably the interface; you want to use. Consider the other interfaces only when you have a good; reason not to use LibClang. Canonical examples of when to use LibClang:. * Xcode; * Clang Python Bindings. Use LibClang when you...:. * want to interface with clang from other languages than C++; * need a stable interface that takes care to be backwards compatible; * want powerful high-level abstractions, like iterating through an AST with a; cursor, and don't want to learn all the nitty gritty details of Clang's AST. Do not use LibClang when you...:. * want full control over the Clang AST. Clang Plugins; -------------. :doc:`Clang Plugins <ClangPlugins>` allow you to run additional actions on the; AST as part of a compilation. Plugins are dynamic libraries that are loaded at; runtime by the compiler, and they're easy to integrate into your build; environment. Canonical examples of when to use Clang Plugins:. * special lint-style warnings or errors for your project; * creating additional build artifacts from a single compile step. Use Clang Plugins when you...:. * need your tool to rerun if any of the dependencies change; * want your tool to make or break a build; * need full control over the Clang AST. Do not use Clang Plugins when you...:. * want to run tools outside of your build environment; * want full control on how Clang is set up, including mapping of in-memory; virtual files; * need to run over a specific subset of files in your project whi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Tooling.rst:1001,learn,learn,1001,interpreter/llvm-project/clang/docs/Tooling.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Tooling.rst,1,['learn'],['learn']
Usability,"==================================================; Kaleidoscope: Extending the Language: Control Flow; ==================================================. .. contents::; :local:. Chapter 5 Introduction; ======================. Welcome to Chapter 5 of the ""`Implementing a language with; LLVM <index.html>`_"" tutorial. Parts 1-4 described the implementation of; the simple Kaleidoscope language and included support for generating; LLVM IR, followed by optimizations and a JIT compiler. Unfortunately, as; presented, Kaleidoscope is mostly useless: it has no control flow other; than call and return. This means that you can't have conditional; branches in the code, significantly limiting its power. In this episode; of ""build that compiler"", we'll extend Kaleidoscope to have an; if/then/else expression plus a simple 'for' loop. If/Then/Else; ============. Extending Kaleidoscope to support if/then/else is quite straightforward.; It basically requires adding support for this ""new"" concept to the; lexer, parser, AST, and LLVM code emitter. This example is nice, because; it shows how easy it is to ""grow"" a language over time, incrementally; extending it as new ideas are discovered. Before we get going on ""how"" we add this extension, let's talk about; ""what"" we want. The basic idea is that we want to be able to write this; sort of thing:. ::. def fib(x); if x < 3 then; 1; else; fib(x-1)+fib(x-2);. In Kaleidoscope, every construct is an expression: there are no; statements. As such, the if/then/else expression needs to return a value; like any other. Since we're using a mostly functional form, we'll have; it evaluate its conditional, then return the 'then' or 'else' value; based on how the condition was resolved. This is very similar to the C; ""?:"" expression. The semantics of the if/then/else expression is that it evaluates the; condition to a boolean equality value: 0.0 is considered to be false and; everything else is considered to be true. If the condition is true, the; first ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst:366,simpl,simple,366,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst,2,['simpl'],['simple']
Usability,"=====================================================; Kaleidoscope: Kaleidoscope Introduction and the Lexer; =====================================================. .. contents::; :local:. The Kaleidoscope Language; =========================. This tutorial is illustrated with a toy language called; ""`Kaleidoscope <http://en.wikipedia.org/wiki/Kaleidoscope>`_"" (derived; from ""meaning beautiful, form, and view""). Kaleidoscope is a procedural; language that allows you to define functions, use conditionals, math,; etc. Over the course of the tutorial, we'll extend Kaleidoscope to; support the if/then/else construct, a for loop, user defined operators,; JIT compilation with a simple command line interface, debug info, etc. We want to keep things simple, so the only datatype in Kaleidoscope; is a 64-bit floating point type (aka 'double' in C parlance). As such,; all values are implicitly double precision and the language doesn't; require type declarations. This gives the language a very nice and; simple syntax. For example, the following simple example computes; `Fibonacci numbers: <http://en.wikipedia.org/wiki/Fibonacci_number>`_. ::. # Compute the x'th fibonacci number.; def fib(x); if x < 3 then; 1; else; fib(x-1)+fib(x-2). # This expression will compute the 40th number.; fib(40). We also allow Kaleidoscope to call into standard library functions - the; LLVM JIT makes this really easy. This means that you can use the; 'extern' keyword to define a function before you use it (this is also; useful for mutually recursive functions). For example:. ::. extern sin(arg);; extern cos(arg);; extern atan2(arg1 arg2);. atan2(sin(.4), cos(42)). A more interesting example is included in Chapter 6 where we write a; little Kaleidoscope application that `displays a Mandelbrot; Set <LangImpl06.html#kicking-the-tires>`_ at various levels of magnification. Let's dive into the implementation of this language!. The Lexer; =========. When it comes to implementing a language, the first thing n",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl01.rst:680,simpl,simple,680,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl01.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl01.rst,3,['simpl'],['simple']
Usability,"=======================================================; Building a JIT: Starting out with KaleidoscopeJIT; =======================================================. .. contents::; :local:. Chapter 1 Introduction; ======================. **Warning: This tutorial is currently being updated to account for ORC API; changes. Only Chapters 1 and 2 are up-to-date.**. **Example code from Chapters 3 to 5 will compile and run, but has not been; updated**. Welcome to Chapter 1 of the ""Building an ORC-based JIT in LLVM"" tutorial. This; tutorial runs through the implementation of a JIT compiler using LLVM's; On-Request-Compilation (ORC) APIs. It begins with a simplified version of the; KaleidoscopeJIT class used in the; `Implementing a language with LLVM <LangImpl01.html>`_ tutorials and then; introduces new features like concurrent compilation, optimization, lazy; compilation and remote execution. The goal of this tutorial is to introduce you to LLVM's ORC JIT APIs, show how; these APIs interact with other parts of LLVM, and to teach you how to recombine; them to build a custom JIT that is suited to your use-case. The structure of the tutorial is:. - Chapter #1: Investigate the simple KaleidoscopeJIT class. This will; introduce some of the basic concepts of the ORC JIT APIs, including the; idea of an ORC *Layer*. - `Chapter #2 <BuildingAJIT2.html>`_: Extend the basic KaleidoscopeJIT by adding; a new layer that will optimize IR and generated code. - `Chapter #3 <BuildingAJIT3.html>`_: Further extend the JIT by adding a; Compile-On-Demand layer to lazily compile IR. - `Chapter #4 <BuildingAJIT4.html>`_: Improve the laziness of our JIT by; replacing the Compile-On-Demand layer with a custom layer that uses the ORC; Compile Callbacks API directly to defer IR-generation until functions are; called. - `Chapter #5 <BuildingAJIT5.html>`_: Add process isolation by JITing code into; a remote process with reduced privileges using the JIT Remote APIs. To provide input for our JIT we will us",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT1.rst:655,simpl,simplified,655,interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT1.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT1.rst,1,['simpl'],['simplified']
Usability,"=======================================================; How to Update Debug Info: A Guide for LLVM Pass Authors; =======================================================. .. contents::; :local:. Introduction; ============. Certain kinds of code transformations can inadvertently result in a loss of; debug info, or worse, make debug info misrepresent the state of a program. This document specifies how to correctly update debug info in various kinds of; code transformations, and offers suggestions for how to create targeted debug; info tests for arbitrary transformations. For more on the philosophy behind LLVM debugging information, see; :doc:`SourceLevelDebugging`. Rules for updating debug locations; ==================================. .. _WhenToPreserveLocation:. When to preserve an instruction location; ----------------------------------------. A transformation should preserve the debug location of an instruction if the; instruction either remains in its basic block, or if its basic block is folded; into a predecessor that branches unconditionally. The APIs to use are; ``IRBuilder``, or ``Instruction::setDebugLoc``. The purpose of this rule is to ensure that common block-local optimizations; preserve the ability to set breakpoints on source locations corresponding to; the instructions they touch. Debugging, crash logs, and SamplePGO accuracy; would be severely impacted if that ability were lost. Examples of transformations that should follow this rule include:. * Instruction scheduling. Block-local instruction reordering should not drop; source locations, even though this may lead to jumpy single-stepping; behavior. * Simple jump threading. For example, if block ``B1`` unconditionally jumps to; ``B2``, *and* is its unique predecessor, instructions from ``B2`` can be; hoisted into ``B1``. Source locations from ``B2`` should be preserved. * Peephole optimizations that replace or expand an instruction, like ``(add X; X) => (shl X 1)``. The location of the ``shl`` instru",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToUpdateDebugInfo.rst:85,Guid,Guide,85,interpreter/llvm-project/llvm/docs/HowToUpdateDebugInfo.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToUpdateDebugInfo.rst,1,['Guid'],['Guide']
Usability,"=======================================================; Kaleidoscope: Extending the Language: Mutable Variables; =======================================================. .. contents::; :local:. Chapter 7 Introduction; ======================. Welcome to Chapter 7 of the ""`Implementing a language with; LLVM <index.html>`_"" tutorial. In chapters 1 through 6, we've built a; very respectable, albeit simple, `functional programming; language <http://en.wikipedia.org/wiki/Functional_programming>`_. In our; journey, we learned some parsing techniques, how to build and represent; an AST, how to build LLVM IR, and how to optimize the resultant code as; well as JIT compile it. While Kaleidoscope is interesting as a functional language, the fact; that it is functional makes it ""too easy"" to generate LLVM IR for it. In; particular, a functional language makes it very easy to build LLVM IR; directly in `SSA; form <http://en.wikipedia.org/wiki/Static_single_assignment_form>`_.; Since LLVM requires that the input code be in SSA form, this is a very; nice property and it is often unclear to newcomers how to generate code; for an imperative language with mutable variables. The short (and happy) summary of this chapter is that there is no need; for your front-end to build SSA form: LLVM provides highly tuned and; well tested support for this, though the way it works is a bit; unexpected for some. Why is this a hard problem?; ===========================. To understand why mutable variables cause complexities in SSA; construction, consider this extremely simple C example:. .. code-block:: c. int G, H;; int test(_Bool Condition) {; int X;; if (Condition); X = G;; else; X = H;; return X;; }. In this case, we have the variable ""X"", whose value depends on the path; executed in the program. Because there are two different possible values; for X before the return instruction, a PHI node is inserted to merge the; two values. The LLVM IR that we want for this example looks like this:. .. code-b",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst:399,simpl,simple,399,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,2,"['learn', 'simpl']","['learned', 'simple']"
Usability,"=======================================================; libFuzzer – a library for coverage-guided fuzz testing.; =======================================================; .. contents::; :local:; :depth: 1. Introduction; ============. LibFuzzer is an in-process, coverage-guided, evolutionary fuzzing engine. LibFuzzer is linked with the library under test, and feeds fuzzed inputs to the; library via a specific fuzzing entrypoint (aka ""target function""); the fuzzer; then tracks which areas of the code are reached, and generates mutations on the; corpus of input data in order to maximize the code coverage.; The code coverage; information for libFuzzer is provided by LLVM's SanitizerCoverage_; instrumentation. Contact: libfuzzer(#)googlegroups.com. Status; ======. The original authors of libFuzzer have stopped active work on it and switched; to working on another fuzzing engine, Centipede_. LibFuzzer is still fully; supported in that important bugs will get fixed. However, please do not expect; major new features or code reviews, other than for bug fixes. Versions; ========. LibFuzzer requires a matching version of Clang. Getting Started; ===============. .. contents::; :local:; :depth: 1. Fuzz Target; -----------. The first step in using libFuzzer on a library is to implement a; *fuzz target* -- a function that accepts an array of bytes and; does something interesting with these bytes using the API under test.; Like this:. .. code-block:: c++. // fuzz_target.cc; extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t *Data, size_t Size) {; DoSomethingInterestingWithMyAPI(Data, Size);; return 0; // Values other than 0 and -1 are reserved for future use.; }. Note that this fuzz target does not depend on libFuzzer in any way; and so it is possible and even desirable to use it with other fuzzing engines; e.g. AFL_ and/or Radamsa_. Some important things to remember about fuzz targets:. * The fuzzing engine will execute the fuzz target many times with different inputs in the same ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst:92,guid,guided,92,interpreter/llvm-project/llvm/docs/LibFuzzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst,2,['guid'],['guided']
Usability,"==========================================================; How to write RecursiveASTVisitor based ASTFrontendActions.; ==========================================================. Introduction; ============. In this tutorial you will learn how to create a FrontendAction that uses; a RecursiveASTVisitor to find CXXRecordDecl AST nodes with a specified; name. Creating a FrontendAction; =========================. When writing a clang based tool like a Clang Plugin or a standalone tool; based on LibTooling, the common entry point is the FrontendAction.; FrontendAction is an interface that allows execution of user specific; actions as part of the compilation. To run tools over the AST clang; provides the convenience interface ASTFrontendAction, which takes care; of executing the action. The only part left is to implement the; CreateASTConsumer method that returns an ASTConsumer per translation; unit. ::. class FindNamedClassAction : public clang::ASTFrontendAction {; public:; virtual std::unique_ptr<clang::ASTConsumer> CreateASTConsumer(; clang::CompilerInstance &Compiler, llvm::StringRef InFile) {; return std::make_unique<FindNamedClassConsumer>();; }; };. Creating an ASTConsumer; =======================. ASTConsumer is an interface used to write generic actions on an AST,; regardless of how the AST was produced. ASTConsumer provides many; different entry points, but for our use case the only one needed is; HandleTranslationUnit, which is called with the ASTContext for the; translation unit. ::. class FindNamedClassConsumer : public clang::ASTConsumer {; public:; virtual void HandleTranslationUnit(clang::ASTContext &Context) {; // Traversing the translation unit decl via a RecursiveASTVisitor; // will visit all nodes in the AST.; Visitor.TraverseDecl(Context.getTranslationUnitDecl());; }; private:; // A RecursiveASTVisitor implementation.; FindNamedClassVisitor Visitor;; };. Using the RecursiveASTVisitor; =============================. Now that everything is hooked up, t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RAVFrontendAction.rst:234,learn,learn,234,interpreter/llvm-project/clang/docs/RAVFrontendAction.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RAVFrontendAction.rst,1,['learn'],['learn']
Usability,"============================================================; Kaleidoscope: Extending the Language: User-defined Operators; ============================================================. .. contents::; :local:. Chapter 6 Introduction; ======================. Welcome to Chapter 6 of the ""`Implementing a language with; LLVM <index.html>`_"" tutorial. At this point in our tutorial, we now; have a fully functional language that is fairly minimal, but also; useful. There is still one big problem with it, however. Our language; doesn't have many useful operators (like division, logical negation, or; even any comparisons besides less-than). This chapter of the tutorial takes a wild digression into adding; user-defined operators to the simple and beautiful Kaleidoscope; language. This digression now gives us a simple and ugly language in; some ways, but also a powerful one at the same time. One of the great; things about creating your own language is that you get to decide what; is good or bad. In this tutorial we'll assume that it is okay to use; this as a way to show some interesting parsing techniques. At the end of this tutorial, we'll run through an example Kaleidoscope; application that `renders the Mandelbrot set <#kicking-the-tires>`_. This gives an; example of what you can build with Kaleidoscope and its feature set. User-defined Operators: the Idea; ================================. The ""operator overloading"" that we will add to Kaleidoscope is more; general than in languages like C++. In C++, you are only allowed to; redefine existing operators: you can't programmatically change the; grammar, introduce new operators, change precedence levels, etc. In this; chapter, we will add this capability to Kaleidoscope, which will let the; user round out the set of operators that are supported. The point of going into user-defined operators in a tutorial like this; is to show the power and flexibility of using a hand-written parser.; Thus far, the parser we have been implement",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl06.rst:736,simpl,simple,736,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl06.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl06.rst,2,['simpl'],['simple']
Usability,"=============================================================; How To Build Clang and LLVM with Profile-Guided Optimizations; =============================================================. Introduction; ============. PGO (Profile-Guided Optimization) allows your compiler to better optimize code; for how it actually runs. Users report that applying this to Clang and LLVM can; decrease overall compile time by 20%. This guide walks you through how to build Clang with PGO, though it also applies; to other subprojects, such as LLD. If you want to build other software with PGO, see the `end-user documentation; for PGO <https://clang.llvm.org/docs/UsersManual.html#profile-guided-optimization>`_. Using preconfigured CMake caches; ================================. See https://llvm.org/docs/AdvancedBuilds.html#multi-stage-pgo. Using the script; ================. We have a script at ``utils/collect_and_build_with_pgo.py``. This script is; tested on a few Linux flavors, and requires a checkout of LLVM, Clang, and; compiler-rt. Despite the name, it performs four clean builds of Clang, so it; can take a while to run to completion. Please see the script's ``--help`` for; more information on how to run it, and the different options available to you.; If you want to get the most out of PGO for a particular use-case (e.g. compiling; a specific large piece of software), please do read the section below on; 'benchmark' selection. Please note that this script is only tested on a few Linux distros. Patches to; add support for other platforms, as always, are highly appreciated. :). This script also supports a ``--dry-run`` option, which causes it to print; important commands instead of running them. Selecting 'benchmarks'; ======================. PGO does best when the profiles gathered represent how the user plans to use the; compiler. Notably, highly accurate profiles of llc building x86_64 code aren't; incredibly helpful if you're going to be targeting ARM. By default, the script above ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToBuildWithPGO.rst:104,Guid,Guided,104,interpreter/llvm-project/llvm/docs/HowToBuildWithPGO.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToBuildWithPGO.rst,4,"['Guid', 'guid']","['Guided', 'guide', 'guided-optimization']"
Usability,"===============================================================; Tutorial for building tools using LibTooling and LibASTMatchers; ===============================================================. This document is intended to show how to build a useful source-to-source; translation tool based on Clang's `LibTooling <LibTooling.html>`_. It is; explicitly aimed at people who are new to Clang, so all you should need; is a working knowledge of C++ and the command line. In order to work on the compiler, you need some basic knowledge of the; abstract syntax tree (AST). To this end, the reader is encouraged to; skim the :doc:`Introduction to the Clang; AST <IntroductionToTheClangAST>`. Step 0: Obtaining Clang; =======================. As Clang is part of the LLVM project, you'll need to download LLVM's; source code first. Both Clang and LLVM are in the same git repository,; under different directories. For further information, see the `getting; started guide <https://llvm.org/docs/GettingStarted.html>`_. .. code-block:: console. mkdir ~/clang-llvm && cd ~/clang-llvm; git clone https://github.com/llvm/llvm-project.git. Next you need to obtain the CMake build system and Ninja build tool. .. code-block:: console. cd ~/clang-llvm; git clone https://github.com/martine/ninja.git; cd ninja; git checkout release; ./configure.py --bootstrap; sudo cp ninja /usr/bin/. cd ~/clang-llvm; git clone https://gitlab.kitware.com/cmake/cmake.git; cd cmake; git checkout next; ./bootstrap; make; sudo make install. Okay. Now we'll build Clang!. .. code-block:: console. cd ~/clang-llvm; mkdir build && cd build; cmake -G Ninja ../llvm-project/llvm -DLLVM_ENABLE_PROJECTS=""clang;clang-tools-extra"" -DCMAKE_BUILD_TYPE=Release -DLLVM_BUILD_TESTS=ON; ninja; ninja check # Test LLVM only.; ninja clang-test # Test Clang only.; ninja install. And we're live. All of the tests should pass. Finally, we want to set Clang as its own compiler. .. code-block:: console. cd ~/clang-llvm/build; ccmake ../llvm-project/ll",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst:958,guid,guide,958,interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,1,['guid'],['guide']
Usability,"===================================================================; Cross-compilation using Clang; ===================================================================. Introduction; ============. This document will guide you in choosing the right Clang options; for cross-compiling your code to a different architecture. It assumes you; already know how to compile the code in question for the host architecture,; and that you know how to choose additional include and library paths. However, this document is *not* a ""how to"" and won't help you setting your; build system or Makefiles, nor choosing the right CMake options, etc.; Also, it does not cover all the possible options, nor does it contain; specific examples for specific architectures. For a concrete example, the; `instructions for cross-compiling LLVM itself; <https://llvm.org/docs/HowToCrossCompileLLVM.html>`_ may be of interest. After reading this document, you should be familiar with the main issues; related to cross-compilation, and what main compiler options Clang provides; for performing cross-compilation. Cross compilation issues; ========================. In GCC world, every host/target combination has its own set of binaries,; headers, libraries, etc. So, it's usually simple to download a package; with all files in, unzip to a directory and point the build system to; that compiler, that will know about its location and find all it needs to; when compiling your code. On the other hand, Clang/LLVM is natively a cross-compiler, meaning that; one set of programs can compile to all targets by setting the ``-target``; option. That makes it a lot easier for programmers wishing to compile to; different platforms and architectures, and for compiler developers that; only have to maintain one build system, and for OS distributions, that; need only one set of main packages. But, as is true to any cross-compiler, and given the complexity of; different architectures, OS's and options, it's not always easy finding; the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CrossCompilation.rst:216,guid,guide,216,interpreter/llvm-project/clang/docs/CrossCompilation.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CrossCompilation.rst,1,['guid'],['guide']
Usability,"=====================================================================; Building a JIT: Adding Optimizations -- An introduction to ORC Layers; =====================================================================. .. contents::; :local:. **This tutorial is under active development. It is incomplete and details may; change frequently.** Nonetheless we invite you to try it out as it stands, and; we welcome any feedback. Chapter 2 Introduction; ======================. **Warning: This tutorial is currently being updated to account for ORC API; changes. Only Chapters 1 and 2 are up-to-date.**. **Example code from Chapters 3 to 5 will compile and run, but has not been; updated**. Welcome to Chapter 2 of the ""Building an ORC-based JIT in LLVM"" tutorial. In; `Chapter 1 <BuildingAJIT1.html>`_ of this series we examined a basic JIT; class, KaleidoscopeJIT, that could take LLVM IR modules as input and produce; executable code in memory. KaleidoscopeJIT was able to do this with relatively; little code by composing two off-the-shelf *ORC layers*: IRCompileLayer and; ObjectLinkingLayer, to do much of the heavy lifting. In this layer we'll learn more about the ORC layer concept by using a new layer,; IRTransformLayer, to add IR optimization support to KaleidoscopeJIT. Optimizing Modules using the IRTransformLayer; =============================================. In `Chapter 4 <LangImpl04.html>`_ of the ""Implementing a language with LLVM""; tutorial series the llvm *FunctionPassManager* is introduced as a means for; optimizing LLVM IR. Interested readers may read that chapter for details, but; in short: to optimize a Module we create an llvm::FunctionPassManager; instance, configure it with a set of optimizations, then run the PassManager on; a Module to mutate it into a (hopefully) more optimized but semantically; equivalent form. In the original tutorial series the FunctionPassManager was; created outside the KaleidoscopeJIT and modules were optimized before being; added to it. In thi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT2.rst:411,feedback,feedback,411,interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT2.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT2.rst,1,['feedback'],['feedback']
Usability,"=======================================================================; Building a JIT: Extreme Laziness - Using LazyReexports to JIT from ASTs; =======================================================================. .. contents::; :local:. **This tutorial is under active development. It is incomplete and details may; change frequently.** Nonetheless we invite you to try it out as it stands, and; we welcome any feedback. Chapter 4 Introduction; ======================. Welcome to Chapter 4 of the ""Building an ORC-based JIT in LLVM"" tutorial. This; chapter introduces custom MaterializationUnits and Layers, and the lazy; reexports API. Together these will be used to replace the CompileOnDemandLayer; from `Chapter 3 <BuildingAJIT3.html>`_ with a custom lazy-JITing scheme that JITs; directly from Kaleidoscope ASTs. **To be done:**. **(1) Describe the drawbacks of JITing from IR (have to compile to IR first,; which reduces the benefits of laziness).**. **(2) Describe CompileCallbackManagers and IndirectStubManagers in detail.**. **(3) Run through the implementation of addFunctionAST.**. Full Code Listing; =================. Here is the complete code listing for our running example that JITs lazily from; Kaleidoscope ASTS. To build this example, use:. .. code-block:: bash. # Compile; clang++ -g toy.cpp `llvm-config --cxxflags --ldflags --system-libs --libs core orcjit native` -O3 -o toy; # Run; ./toy. Here is the code:. .. literalinclude:: ../../examples/Kaleidoscope/BuildingAJIT/Chapter4/KaleidoscopeJIT.h; :language: c++. `Next: Remote-JITing -- Process-isolation and laziness-at-a-distance <BuildingAJIT5.html>`_; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT4.rst:417,feedback,feedback,417,interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT4.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT4.rst,1,['feedback'],['feedback']
Usability,"> But in fact, if you read the entire answer carefully, he came to the same; > conclusion I do: that you have to go with familiar syntax over logical; > syntax because familiarity is such a strong force:; > ""However, familiarity is a strong force. To compare, in English, we; live; > more or less happily with the absurd rules for ""to be"" (am, are, is, been,; > was, were, ...) and all attempts to simplify are treated with contempt or; > (preferably) humor. It be a curious world and it always beed."". Although you have to remember that his situation was considerably; different than ours. He was in a position where he was designing a high; level language that had to be COMPATIBLE with C. Our language is such; that a new person would have to learn the new, different, syntax; anyways. Making them learn about the type system does not seem like much; of a stretch from learning the opcodes and how SSA form works, and how; everything ties together... > > Basically, my argument for this type construction system is that it is; > > VERY simple to use and understand (although it IS different than C, it is; > > very simple and straightforward, which C is NOT). In fact, I would assert; > > that most programmers TODAY do not understand pointers to member; > > functions, and have to look up an example when they have to write them. > Again, I don't disagree with this at all. But to some extent this; > particular problem is inherently difficult. Your syntax for the above; > example may be easier for you to read because this is the way you have been; > thinking about it. Honestly, I don't find it much easier than the C syntax.; > In either case, I would have to look up an example to write pointers to; > member functions. I would argue that because the lexical structure of the language is self; consistent, any person who spent a significant amount of time programming; in LLVM directly would understand how to do it without looking it up in a; manual. The reason this does not work for C is b",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-06-TypeNotationDebateResp4.txt:398,simpl,simplify,398,interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-06-TypeNotationDebateResp4.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-06-TypeNotationDebateResp4.txt,4,"['learn', 'simpl']","['learn', 'learning', 'simplify']"
Usability,"> ________________________________________________________________________________________; > <span style=""color:red"">**WARNING:**</span>; > This documentation is **not maintained anymore**. Some part might be obsolete or wrong, some; > part might be missing but still some valuable information can be found there. Instead please; > refer to the [ROOT Reference Guide](https://root.cern/doc/master/index.html) and the; > [ROOT Manual](https://root.cern/manual/). If you think some information should be imported; > in the [ROOT Reference Guide](https://root.cern/doc/master/index.html) or in the; > [ROOT Manual](https://root.cern/manual/), please post your request to the; > [ROOT Forum](https://root-forum.cern.ch) or via a; > [Github Issue](https://github.com/root-project/web/issues/new).; >; > ________________________________________________________________________________________; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/warning.md:362,Guid,Guide,362,documentation/users-guide/warning.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/warning.md,2,['Guid'],['Guide']
Usability,">(*TheContext,; /*DebugLogging*/ true);; TheSI->registerCallbacks(*ThePIC, TheMAM.get());; ... After initializing the global module ``TheModule`` and the FunctionPassManager,; we need to initialize other parts of the framework. The four AnalysisManagers; allow us to add analysis passes that run across the four levels of the IR; hierarchy. PassInstrumentationCallbacks and StandardInstrumentations are; required for the pass instrumentation framework, which allows developers to; customize what happens between passes. Once these managers are set up, we use a series of ""addPass"" calls to add a; bunch of LLVM transform passes:. .. code-block:: c++. // Add transform passes.; // Do simple ""peephole"" optimizations and bit-twiddling optzns.; TheFPM->addPass(InstCombinePass());; // Reassociate expressions.; TheFPM->addPass(ReassociatePass());; // Eliminate Common SubExpressions.; TheFPM->addPass(GVNPass());; // Simplify the control flow graph (deleting unreachable blocks, etc).; TheFPM->addPass(SimplifyCFGPass());. In this case, we choose to add four optimization passes.; The passes we choose here are a pretty standard set; of ""cleanup"" optimizations that are useful for a wide variety of code. I won't; delve into what they do but, believe me, they are a good starting place :). Next, we register the analysis passes used by the transform passes. .. code-block:: c++. // Register analysis passes used in these transform passes.; PassBuilder PB;; PB.registerModuleAnalyses(*TheMAM);; PB.registerFunctionAnalyses(*TheFAM);; PB.crossRegisterProxies(*TheLAM, *TheFAM, *TheCGAM, *TheMAM);; }. Once the PassManager is set up, we need to make use of it. We do this by; running it after our newly created function is constructed (in; ``FunctionAST::codegen()``), but before it is returned to the client:. .. code-block:: c++. if (Value *RetVal = Body->codegen()) {; // Finish off the function.; Builder.CreateRet(RetVal);. // Validate the generated code, checking for consistency.; verifyFunction(*Th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl04.rst:7370,Simpl,SimplifyCFGPass,7370,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl04.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl04.rst,1,['Simpl'],['SimplifyCFGPass']
Usability,">,; Matcher<CXXConstructExpr>, Matcher<CXXNewExpr>, Matcher<DeclRefExpr>,; Matcher<EnumType>, Matcher<InjectedClassNameType>, Matcher<LabelStmt>,; Matcher<MemberExpr>, Matcher<QualType>, Matcher<RecordType>,; Matcher<TagType>, Matcher<TemplateSpecializationType>,; Matcher<TemplateTypeParmType>, Matcher<TypedefType>,; Matcher<UnresolvedUsingType>. Matcher<TemplateArgumentLoc>hasTypeLocMatcher<TypeLoc> Inner; Matches if the type location of a node matches the inner matcher. Examples:; int x;; declaratorDecl(hasTypeLoc(loc(asString(""int"")))); matches int x. auto x = int(3);; cxxTemporaryObjectExpr(hasTypeLoc(loc(asString(""int"")))); matches int(3). struct Foo { Foo(int, int); };; auto x = Foo(1, 2);; cxxFunctionalCastExpr(hasTypeLoc(loc(asString(""struct Foo"")))); matches Foo(1, 2). Usable as: Matcher<BlockDecl>, Matcher<CXXBaseSpecifier>,; Matcher<CXXCtorInitializer>, Matcher<CXXFunctionalCastExpr>,; Matcher<CXXNewExpr>, Matcher<CXXTemporaryObjectExpr>,; Matcher<CXXUnresolvedConstructExpr>,; Matcher<ClassTemplateSpecializationDecl>, Matcher<CompoundLiteralExpr>,; Matcher<DeclaratorDecl>, Matcher<ExplicitCastExpr>,; Matcher<ObjCPropertyDecl>, Matcher<TemplateArgumentLoc>,; Matcher<TypedefNameDecl>. Matcher<TemplateArgument>isExprMatcher<Expr> InnerMatcher; Matches a sugar TemplateArgument that refers to a certain expression. Given; struct B { int next; };; template<int(B::*next_ptr)> struct A {};; A<&B::next> a;; templateSpecializationType(hasAnyTemplateArgument(; isExpr(hasDescendant(declRefExpr(to(fieldDecl(hasName(""next"")))))))); matches the specialization A<&B::next> with fieldDecl(...) matching; B::next. Matcher<TemplateArgument>refersToDeclarationMatcher<Decl> InnerMatcher; Matches a canonical TemplateArgument that refers to a certain; declaration. Given; struct B { int next; };; template<int(B::*next_ptr)> struct A {};; A<&B::next> a;; classTemplateSpecializationDecl(hasAnyTemplateArgument(; refersToDeclaration(fieldDecl(hasName(""next""))))); matches the specializa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:236993,Usab,Usable,236993,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['Usab'],['Usable']
Usability,">GetEntry(i);; params[0] = msumf; params[1] = ptsumf;; params[2] = acolin; params[3] = acopl;; bg->Fill(mlp->Evaluate(0,params));; }; for (i = 0; i < signal->GetEntries(); i++) {; signal->GetEntry(i);; params[0] = msumf;; params[1] = ptsumf;; params[2] = acolin;; params[3] = acopl;; sig->Fill(mlp->Evaluate(0,params));; }; TCanvas *cv = new TCanvas(""NNout_cv"",""Neural net output"");; bg->SetFillStyle(3008);; bg->SetFillColor(kBlue);; sig->SetFillStyle(3003);; sig->SetFillColor(kRed);; bg->SetStats(0);; sig->SetStats(0);; bg->Draw();; sig->Draw(""same"");; TLegend *legend = new TLegend(.75,.80,.95,.95);; legend->AddEntry(bg,""Background(WW)"");; legend->AddEntry(sig,""Signal(Higgs)"");; legend->Draw();; ```. The neural net output is then used to display the final difference; between background and signal events. The figure ""The neural net; output"" shows this plot. ![The neural net output](pictures/image144.png). As it can be seen, this is a quite efficient technique. As mentioned; earlier, neural networks are also used for fitting function. For some; application with a cylindrical symmetry, a magnetic field simulation; gives as output the angular component of the potential vector `A`, as; well as the radial and `z` components of the `B` field. One wants to fit those distributions with a function in order to plug; them into the `Geant` simulation code. Polynomial fits could be tried,; but it seems difficult to reach the desired precision over the full; range. One could also use a `spline` interpolation between known; points. In all cases, the resulting field would not be `C`-infinite. An example of output (for Br) is shown. First the initial function can; be seen as the target. Then, the resulting (normalized) neural net; output. In order to ease the learning, the ""normalize output"" was used; here. The initial amplitude can be recovered by multiplying by the; original RMS and then shifting by the original mean. ![The original and the neural net for Br](pictures/image145.jpg); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:81272,learn,learning,81272,documentation/users-guide/FittingHistograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md,1,['learn'],['learning']
Usability,">`; feedback, please revert and address said feedback before recommitting.; (Possibly after another round of review.); * If you are asked to revert by another contributor, please revert and discuss; the merits of the request offline (unless doing so would further destabilize; tip of tree). When should you revert someone else's change?. * In general, if the author themselves would revert the change per these; guidelines, we encourage other contributors to do so as a courtesy to the; author. This is one of the major cases where our norms differ from others;; we generally consider reverting a normal part of development. We don't; expect contributors to be always available, and the assurance that a; problematic patch will be reverted and we can return to it at our next; opportunity enables this. What are the expectations around a revert?. * Use your best judgment. If you're uncertain, please start an email on; the commit thread asking for assistance. We aren't trying to enumerate; every case, but rather give a set of guidelines.; * You should be sure that reverting the change improves the stability of tip; of tree. Sometimes reverting one change in a series can worsen things; instead of improving them. We expect reasonable judgment to ensure that; the proper patch or set of patches is being reverted.; * The commit message for the reverting commit should explain why patch; is being reverted.; * It is customary to respond to the original commit email mentioning the; revert. This serves as both a notice to the original author that their; patch was reverted, and helps others following llvm-commits track context.; * Ideally, you should have a publicly reproducible test case ready to share.; Where possible, we encourage sharing of test cases in commit threads, or; in PRs. We encourage the reverter to minimize the test case and to prune; dependencies where practical. This even applies when reverting your own; patch; documenting the reasons for others who might be following alo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst:20867,guid,guidelines,20867,interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,1,['guid'],['guidelines']
Usability,"A.getChecker<FooAnalysis>();; return !PAC.preservedWhenStateless();; }. If an analysis depends on other analyses, those analyses also need to be; checked if they are invalidated:. .. code-block:: c++. bool FooAnalysisResult::invalidate(Function &F, const PreservedAnalyses &PA,; FunctionAnalysisManager::Invalidator &Inv) {; auto PAC = PA.getChecker<FooAnalysis>();; if (!PAC.preserved() && !PAC.preservedSet<AllAnalysesOn<Function>>()); return true;. // Check transitive dependencies.; return Inv.invalidate<BarAnalysis>(F, PA) ||; Inv.invalidate<BazAnalysis>(F, PA);; }. Combining invalidation and analysis manager proxies results in some; complexity. For example, when we invalidate all analyses in a module pass,; we have to make sure that we also invalidate function analyses accessible via; any existing inner proxies. The inner proxy's ``invalidate()`` first checks; if the proxy itself should be invalidated. If so, that means the proxy may; contain pointers to IR that is no longer valid, meaning that the inner proxy; needs to completely clear all relevant analysis results. Otherwise the proxy; simply forwards the invalidation to the inner analysis manager. Generally for outer proxies, analysis results from the outer analysis manager; should be immutable, so invalidation shouldn't be a concern. However, it is; possible for some inner analysis to depend on some outer analysis, and when; the outer analysis is invalidated, we need to make sure that dependent inner; analyses are also invalidated. This actually happens with alias analysis; results. Alias analysis is a function-level analysis, but there are; module-level implementations of specific types of alias analysis. Currently; ``GlobalsAA`` is the only module-level alias analysis and it generally is not; invalidated so this is not so much of a concern. See; ``OuterAnalysisManagerProxy::Result::registerOuterAnalysisInvalidation()``; for more details. Invoking ``opt``; ================. .. code-block:: shell. $ opt -passes",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NewPassManager.rst:17437,clear,clear,17437,interpreter/llvm-project/llvm/docs/NewPassManager.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NewPassManager.rst,1,['clear'],['clear']
Usability,"ANDARD} which is less than the required ${LLVM_REQUIRED_CXX_STANDARD}.""); endif(). set(CMAKE_CXX_STANDARD ${LLVM_REQUIRED_CXX_STANDARD} CACHE STRING ""C++ standard to conform to""); set(CMAKE_CXX_STANDARD_REQUIRED YES). if (CYGWIN); # Cygwin is a bit stricter and lack things like 'strdup', 'stricmp', etc in; # c++xx mode.; set(CMAKE_CXX_EXTENSIONS YES); else(); set(CMAKE_CXX_EXTENSIONS NO); endif(). if (NOT CMAKE_BUILD_TYPE AND NOT CMAKE_CONFIGURATION_TYPES); message(FATAL_ERROR ""; No build type selected. You need to pass -DCMAKE_BUILD_TYPE=<type> in order to configure LLVM.; Available options are:; * -DCMAKE_BUILD_TYPE=Release - For an optimized build with no assertions or debug info.; * -DCMAKE_BUILD_TYPE=Debug - For an unoptimized build with assertions and debug info.; * -DCMAKE_BUILD_TYPE=RelWithDebInfo - For an optimized build with no assertions but with debug info.; * -DCMAKE_BUILD_TYPE=MinSizeRel - For a build optimized for size instead of speed.; Learn more about these options in our documentation at https://llvm.org/docs/CMake.html#cmake-build-type; ""); endif(). # Set default build type for cmake's try_compile module.; # CMake 3.17 or newer sets CMAKE_DEFAULT_BUILD_TYPE to one of the; # items from CMAKE_CONFIGURATION_TYPES. Logic below can be further; # simplified once LLVM's minimum CMake version is updated to 3.17.; if(CMAKE_DEFAULT_BUILD_TYPE); set(CMAKE_TRY_COMPILE_CONFIGURATION ${CMAKE_DEFAULT_BUILD_TYPE}); else(); if(CMAKE_CONFIGURATION_TYPES); list(GET CMAKE_CONFIGURATION_TYPES 0 CMAKE_TRY_COMPILE_CONFIGURATION); elseif(CMAKE_BUILD_TYPE); set(CMAKE_TRY_COMPILE_CONFIGURATION ${CMAKE_BUILD_TYPE}); endif(); endif(). # Side-by-side subprojects layout: automatically set the; # LLVM_EXTERNAL_${project}_SOURCE_DIR using LLVM_ALL_PROJECTS; # This allows an easy way of setting up a build directory for llvm and another; # one for llvm+clang+... using the same sources.; set(LLVM_ALL_PROJECTS ""bolt;clang;clang-tools-extra;compiler-rt;cross-project-tests;libc;libcl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt:4345,Learn,Learn,4345,interpreter/llvm-project/llvm/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt,1,['Learn'],['Learn']
Usability,"ARWIN_LTO_LIBRARY=${LLVM_SHLIB_OUTPUT_INTDIR}/libLTO.dylib; -DDYLD_LIBRARY_PATH=${LLVM_LIBRARY_OUTPUT_INTDIR}); elseif(MSVC); add_dependencies(clang-bootstrap-deps llvm-lib); set(${CLANG_STAGE}_AR -DCMAKE_AR=${LLVM_RUNTIME_OUTPUT_INTDIR}/llvm-lib); elseif(NOT WIN32); add_dependencies(clang-bootstrap-deps llvm-ar llvm-ranlib); if(NOT BOOTSTRAP_LLVM_ENABLE_LLD AND LLVM_BINUTILS_INCDIR); add_dependencies(clang-bootstrap-deps LLVMgold); endif(); set(${CLANG_STAGE}_AR -DCMAKE_AR=${LLVM_RUNTIME_OUTPUT_INTDIR}/llvm-ar); set(${CLANG_STAGE}_RANLIB -DCMAKE_RANLIB=${LLVM_RUNTIME_OUTPUT_INTDIR}/llvm-ranlib); endif(); endif(). if(CLANG_BOOTSTRAP_EXTRA_DEPS); add_dependencies(clang-bootstrap-deps ${CLANG_BOOTSTRAP_EXTRA_DEPS}); endif(). add_custom_target(${NEXT_CLANG_STAGE}-clear; DEPENDS ${CMAKE_CURRENT_BINARY_DIR}/${NEXT_CLANG_STAGE}-cleared; ); add_custom_command(; OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/${NEXT_CLANG_STAGE}-cleared; DEPENDS clang-bootstrap-deps; COMMAND ${CMAKE_COMMAND} -E remove_directory ${BINARY_DIR}; COMMAND ${CMAKE_COMMAND} -E make_directory ${BINARY_DIR}; COMMAND ${CMAKE_COMMAND} -E remove_directory ${STAMP_DIR}; COMMAND ${CMAKE_COMMAND} -E make_directory ${STAMP_DIR}; COMMENT ""Clobberring ${NEXT_CLANG_STAGE} build and stamp directories""; ). if(CMAKE_VERBOSE_MAKEFILE); set(verbose -DCMAKE_VERBOSE_MAKEFILE=On); endif(). set(_BOOTSTRAP_DEFAULT_PASSTHROUGH; PACKAGE_VERSION; PACKAGE_VENDOR; LLVM_VERSION_MAJOR; LLVM_VERSION_MINOR; LLVM_VERSION_PATCH; CLANG_VERSION_MAJOR; CLANG_VERSION_MINOR; CLANG_VERSION_PATCHLEVEL; CLANG_VERSION_SUFFIX; CLANG_VENDOR; LLVM_VERSION_SUFFIX; LLVM_BINUTILS_INCDIR; CLANG_REPOSITORY_STRING; CMAKE_MAKE_PROGRAM; CMAKE_OSX_ARCHITECTURES; CMAKE_BUILD_TYPE; LLVM_ENABLE_PROJECTS; LLVM_ENABLE_RUNTIMES). # We don't need to depend on compiler-rt/libcxx if we're building instrumented; # because the next stage will use the same compiler used to build this stage.; if(NOT LLVM_BUILD_INSTRUMENTED); if(TARGET compiler-rt); add_dependencies(clang-boot",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/CMakeLists.txt:23027,clear,clear,23027,interpreter/llvm-project/clang/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/CMakeLists.txt,3,['clear'],"['clear', 'cleared']"
Usability,"ATH=""${library_output_dir}\\\;%PATH%""; ROOTIGNOREPREFIX=1 ROOT_HIST=0 $<TARGET_FILE:root.exe> -l -q -b); else(); set(modules_idx_cmd COMMAND ${ld_library_path}=${library_output_dir}:$ENV{${ld_library_path}}; ROOTIGNOREPREFIX=1 ROOT_HIST=0 $<TARGET_FILE:root.exe> -l -q -b); endif(); add_custom_command(OUTPUT ${library_output_dir}/modules.idx; COMMAND ${CMAKE_COMMAND} -E remove -f modules.idx modules.timestamp; ${modules_idx_cmd}; WORKING_DIRECTORY ${library_output_dir}; DEPENDS $<TARGET_FILE:root.exe> Cling Hist Tree Gpad Graf HistPainter move_artifacts; ${modules_idx_deps}); add_custom_target(modules_idx ALL DEPENDS ${library_output_dir}/modules.idx); add_dependencies(modules_idx ${modules_idx_deps}); set_property(TARGET modules_idx PROPERTY modules_idx_file ${library_output_dir}/modules.idx); set_directory_properties(PROPERTIES ADDITIONAL_CLEAN_FILES ""${library_output_dir}/modules.timestamp""); endif(). #---hsimple.root---------(use the executable for clearer dependencies and proper return code)---; add_custom_target(hsimple ALL DEPENDS tutorials/hsimple.root); add_dependencies(hsimple onepcm); if(WIN32); set(hsimple_cmd COMMAND ${CMAKE_COMMAND} -E env PATH=""${CMAKE_RUNTIME_OUTPUT_DIRECTORY}\\\;%PATH%""; ROOTIGNOREPREFIX=1 ROOT_HIST=0 $<TARGET_FILE:root.exe> -l -q -b -n -x hsimple.C -e return); else(); set(hsimple_cmd COMMAND ${MODULES_ROOT_INCPATH} ${ld_library_path}=${CMAKE_LIBRARY_OUTPUT_DIRECTORY}:$ENV{${ld_library_path}}; ROOTIGNOREPREFIX=1 ROOT_HIST=0 $<TARGET_FILE:root.exe> -l -q -b -n -x hsimple.C -e return); endif(); add_custom_command(OUTPUT tutorials/hsimple.root; ${hsimple_cmd}; WORKING_DIRECTORY tutorials; DEPENDS $<TARGET_FILE:root.exe> Cling Hist Tree Gpad Graf HistPainter move_artifacts); install(FILES ${CMAKE_BINARY_DIR}/tutorials/hsimple.root DESTINATION ${CMAKE_INSTALL_TUTDIR} COMPONENT tests). if(runtime_cxxmodules); add_dependencies(hsimple modules_idx); endif(). #---copy special headers required for building on Windows---------------------------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/CMakeLists.txt:22977,clear,clearer,22977,CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/CMakeLists.txt,1,['clear'],['clearer']
Usability,"Among other things you can learn how; to detect Heartbleed_ in one second. Advanced features; =================; .. contents::; :local:; :depth: 1. Dictionaries; ------------; LibFuzzer supports user-supplied dictionaries with input language keywords; or other interesting byte sequences (e.g. multi-byte magic values).; Use ``-dict=DICTIONARY_FILE``. For some input languages using a dictionary; may significantly improve the search speed.; The dictionary syntax is similar to that used by AFL_ for its ``-x`` option::. # Lines starting with '#' and empty lines are ignored. # Adds ""blah"" (w/o quotes) to the dictionary.; kw1=""blah""; # Use \\ for backslash and \"" for quotes.; kw2=""\""ac\\dc\""""; # Use \xAB for hex values; kw3=""\xF7\xF8""; # the name of the keyword followed by '=' may be omitted:; ""foo\x0Abar"". Tracing CMP instructions; ------------------------. With an additional compiler flag ``-fsanitize-coverage=trace-cmp``; (on by default as part of ``-fsanitize=fuzzer``, see SanitizerCoverageTraceDataFlow_); libFuzzer will intercept CMP instructions and guide mutations based; on the arguments of intercepted CMP instructions. This may slow down; the fuzzing but is very likely to improve the results. Value Profile; -------------. With ``-fsanitize-coverage=trace-cmp`` (default with ``-fsanitize=fuzzer``); and extra run-time flag ``-use_value_profile=1`` the fuzzer will; collect value profiles for the parameters of compare instructions; and treat some new values as new coverage. The current implementation does roughly the following:. * The compiler instruments all CMP instructions with a callback that receives both CMP arguments.; * The callback computes `(caller_pc&4095) | (popcnt(Arg1 ^ Arg2) << 12)` and uses this value to set a bit in a bitset.; * Every new observed bit in the bitset is treated as new coverage. This feature has a potential to discover many interesting inputs,; but there are two downsides.; First, the extra instrumentation may bring up to 2x additional sl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst:20215,guid,guide,20215,interpreter/llvm-project/llvm/docs/LibFuzzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst,1,['guid'],['guide']
Usability,"An AutoFlush is always done with an AutoSave.; If the interval specified for AutoSave is less than that for; AutoFlush, the AutoSave interval is used for both.; If the AutoFlush interval is less than the AutoSave interval,; the AutoSave interval is adjusted to the largest integer; multiple of the AutoFlush interval that is less than or equal; to the original value of the AutoSave interval. Update MakeProxy so that the resulting skeleton is useable with Proof.; Update MakeProxy, MakeClass and MakeSelector to support more cases of branches names (that includes characters illegal in a C++ symbol); Replace the ReadLeaves virtual function by a fReadLeaves pointer to member function,; this allows the customization of the ReadLeaves function at run-time depending on the; underlying user class layout in TBranchElement. This removes many if statements whose; 'answer' is known at initialization time. Add support for 'array' formula in TTree::Query.; Set the initial value of fCacheSize to zero to indicate clearly that the TreeCache is disabled.; In TChain::SetEntryList use only the treename to lookup the (sub)entryList (instead subdir/treename).; Add support for the branch creation syntax:; TString rootString;; t->Branch(""rootString"",""TString"",&rootString, 1600, 0);; which is 'natural' as it uses the legacy syntax (branch_name,class_name, user_data); but did not work because 'rootString' is an object rather than a pointer to an; object. (However the simplier form:; t->Branch(""rootString"",&rootString, 1600, 0);; works/worked fine). Add type information to the result of TTree::Print in the case of; TBranchElement:; *Br 17 :fH : TH1F* *; *Entries : 20 : Total Size= 19334 bytes File Size = 1671 *; *Baskets : 2 : Basket Size= 16000 bytes Compression= 11.29 *; *............................................................................*; *Br 18 :fTriggerBits : TBits *; *Entries : 20 : Total Size= 1398 bytes File Size = 400 *; *Baskets : 1 : Basket Size= 16000 bytes Compression= 2.23",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/doc/v528/index.html:4261,clear,clearly,4261,tree/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/doc/v528/index.html,1,['clear'],['clearly']
Usability,"AsUnevaluated`` to ``1``. If additional functionality is desired for the semantic form of the attribute,; the ``AdditionalMembers`` field specifies code to be copied verbatim into the; semantic attribute class object, with ``public`` access. If two or more attributes cannot be used in combination on the same declaration; or statement, a ``MutualExclusions`` definition can be supplied to automatically; generate diagnostic code. This will disallow the attribute combinations; regardless of spellings used. Additionally, it will diagnose combinations within; the same attribute list, different attribute list, and redeclarations, as; appropriate. Boilerplate; ^^^^^^^^^^^; All semantic processing of declaration attributes happens in `lib/Sema/SemaDeclAttr.cpp; <https://github.com/llvm/llvm-project/blob/main/clang/lib/Sema/SemaDeclAttr.cpp>`_,; and generally starts in the ``ProcessDeclAttribute()`` function. If the; attribute has the ``SimpleHandler`` field set to ``1`` then the function to; process the attribute will be automatically generated, and nothing needs to be; done here. Otherwise, write a new ``handleYourAttr()`` function, and add that to; the switch statement. Please do not implement handling logic directly in the; ``case`` for the attribute. Unless otherwise specified by the attribute definition, common semantic checking; of the parsed attribute is handled automatically. This includes diagnosing; parsed attributes that do not appertain to the given ``Decl`` or ``Stmt``,; ensuring the correct minimum number of arguments are passed, etc. If the attribute adds additional warnings, define a ``DiagGroup`` in; `include/clang/Basic/DiagnosticGroups.td; <https://github.com/llvm/llvm-project/blob/main/clang/include/clang/Basic/DiagnosticGroups.td>`_; named after the attribute's ``Spelling`` with ""_""s replaced by ""-""s. If there; is only a single diagnostic, it is permissible to use ``InGroup<DiagGroup<""your-attribute"">>``; directly in `DiagnosticSemaKinds.td; <https://git",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:142315,Simpl,SimpleHandler,142315,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['Simpl'],['SimpleHandler']
Usability,"BEGIN_HTML. <center><h1>Gviz3d - Objects Data Structure visualisation in 3D space</h1></center>; <p><hr><p>. The Gviz3d module provides an interface for inspecting objects collections.; TStructViewer represents a class, a struct or any other type as an; object in 3D space.; At the top of the scene we can see objects depending on a pointer root. Under it we see; pointers and collection elements. Collections must inherit from TCollection; or be STL collections. We can change the number of visible levels or objects on the scene with the GUI or; methods. The Size of objects in the geometry scene is proportional to memory taken by this object; or to the number of objects inside this object. An easy way to find some class in the viewer is to change the color of a type.; We can connect for example TF2 class with red color or connect all classes; inheriting from TF2 by adding plus to name. For example typename ""TF2+"" tells us; that all classes inheriting from TF2 will be red. Navigatiion in the viewer is very simple like in usual GLViewer. When you put mouse over; some object you can see some information about it (e.g. name, size, actual level).; When you double click this object, it becames top object on scene.; Undo and redo operations are supported. END_HTML; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gviz3d/doc/index.txt:1017,simpl,simple,1017,graf3d/gviz3d/doc/index.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gviz3d/doc/index.txt,2,"['Undo', 'simpl']","['Undo', 'simple']"
Usability,"BOOTSTRAP=On \; -DCLANG_BOOTSTRAP_PASSTHROUGH=""CMAKE_INSTALL_PREFIX;CMAKE_VERBOSE_MAKEFILE"" \; -DLLVM_ENABLE_PROJECTS=""clang"" \; <path to source>/llvm; $ ninja stage2. CMake options starting by ``BOOTSTRAP_`` will be passed only to the stage2 build.; This gives the opportunity to use Clang specific build flags.; For example, the following CMake call will enabled '-fno-addrsig' only during; the stage2 build for C and C++. .. code-block:: console. $ cmake [..] -DBOOTSTRAP_CMAKE_CXX_FLAGS='-fno-addrsig' -DBOOTSTRAP_CMAKE_C_FLAGS='-fno-addrsig' [..]. The clang build system refers to builds as stages. A stage1 build is a standard; build using the compiler installed on the host, and a stage2 build is built; using the stage1 compiler. This nomenclature holds up to more stages too. In; general a stage*n* build is built using the output from stage*n-1*. Apple Clang Builds (A More Complex Bootstrap); =============================================. Apple's Clang builds are a slightly more complicated example of the simple; bootstrapping scenario. Apple Clang is built using a 2-stage build. The stage1 compiler is a host-only compiler with some options set. The stage1; compiler is a balance of optimization vs build time because it is a throwaway.; The stage2 compiler is the fully optimized compiler intended to ship to users. Setting up these compilers requires a lot of options. To simplify the; configuration the Apple Clang build settings are contained in CMake Cache files.; You can build an Apple Clang compiler using the following commands:. .. code-block:: console. $ cmake -G Ninja -C <path to source>/clang/cmake/caches/Apple-stage1.cmake <path to source>/llvm; $ ninja stage2-distribution. This CMake invocation configures the stage1 host compiler, and sets; CLANG_BOOTSTRAP_CMAKE_ARGS to pass the Apple-stage2.cmake cache script to the; stage2 configuration step. When you build the stage2-distribution target it builds the minimal stage1; compiler and required tools, then configur",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:3461,simpl,simple,3461,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,1,['simpl'],['simple']
Usability,"BUILD_DOCS**:BOOL; Adds all *enabled* documentation targets (i.e. Doxgyen and Sphinx targets) as; dependencies of the default build targets. This results in all of the (enabled); documentation targets being as part of a normal build. If the ``install``; target is run then this also enables all built documentation targets to be; installed. Defaults to OFF. To enable a particular documentation target, see; see LLVM_ENABLE_SPHINX and LLVM_ENABLE_DOXYGEN. **LLVM_BUILD_EXAMPLES**:BOOL; Build LLVM examples. Defaults to OFF. Targets for building each example are; generated in any case. See documentation for *LLVM_BUILD_TOOLS* above for more; details. **LLVM_BUILD_INSTRUMENTED_COVERAGE**:BOOL; If enabled, `source-based code coverage; <https://clang.llvm.org/docs/SourceBasedCodeCoverage.html>`_ instrumentation; is enabled while building llvm. If CMake can locate the code coverage; scripts and the llvm-cov and llvm-profdata tools that pair to your compiler,; the build will also generate the `generate-coverage-report` target to generate; the code coverage report for LLVM, and the `clear-profile-data` utility target; to delete captured profile data. See documentation for; *LLVM_CODE_COVERAGE_TARGETS* and *LLVM_COVERAGE_SOURCE_DIRS* for more; information on configuring code coverage reports. **LLVM_CODE_COVERAGE_TARGETS**:STRING; If set to a semicolon separated list of targets, those targets will be used; to drive the code coverage reports. If unset, the target list will be; constructed using the LLVM build's CMake export list. **LLVM_COVERAGE_SOURCE_DIRS**:STRING; If set to a semicolon separated list of directories, the coverage reports; will limit code coverage summaries to just the listed directories. If unset,; coverage reports will include all sources identified by the tooling. **LLVM_INDIVIDUAL_TEST_COVERAGE**:BOOL; Enable individual test case coverage. When set to ON, code coverage data for; each test case will be generated and stored in a separate directory under the; co",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst:15112,clear,clear-profile-data,15112,interpreter/llvm-project/llvm/docs/CMake.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst,1,['clear'],['clear-profile-data']
Usability,"Binary_Interface_Standards_Manual.pdf>`_. LoongArch; ---------; * `LoongArch Reference Manual - Volume 1: Basic Architecture <https://loongson.github.io/LoongArch-Documentation/LoongArch-Vol1-EN.html>`_; * `LoongArch ELF ABI specification <https://loongson.github.io/LoongArch-Documentation/LoongArch-ELF-ABI-EN.html>`_. SPARC; -----. * `SPARC standards <http://sparc.org/standards>`_; * `SPARC V9 ABI <http://sparc.org/standards/64.psabi.1.35.ps.Z>`_; * `SPARC V8 ABI <http://sparc.org/standards/psABI3rd.pdf>`_. SystemZ; -------. * `z/Architecture Principles of Operation (registration required, free sign-up) <http://www-01.ibm.com/support/docview.wss?uid=isg2b9de5f05a9d57819852571c500428f9a>`_. VE; --. * `NEC SX-Aurora TSUBASA ISA Guide <https://www.hpc.nec/documents/guide/pdfs/Aurora_ISA_guide.pdf>`_; * `NEC SX-Aurora TSUBASA manuals and documentation <https://www.hpc.nec/documentation>`_. X86; ---. * `AMD processor manuals <http://developer.amd.com/resources/developer-guides-manuals/>`_; * `Intel 64 and IA-32 manuals <http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html>`_; * `Intel Itanium documentation <http://www.intel.com/design/itanium/documentation.htm?iid=ipp_srvr_proc_itanium2+techdocs>`_; * `X86 and X86-64 SysV psABI <https://github.com/hjl-tools/x86-psABI/wiki/X86-psABI>`_; * `Calling conventions for different C++ compilers and operating systems <http://www.agner.org/optimize/calling_conventions.pdf>`_. XCore; -----. * `The XMOS XS1 Architecture (ISA) <https://www.xmos.ai/download/The-XMOS-XS1-Architecture%281.0%29.pdf>`_; * `The XMOS XS2 Architecture (ISA) <https://www.xmos.ai/download/xCORE-200:-The-XMOS-XS2-Architecture-%28ISA%29%281.1%29.pdf>`_; * `Tools Development Guide (includes ABI) <https://www.xmos.ai/download/Tools-Development-Guide%282.1%29.pdf>`_. Hexagon; -------. * `Hexagon Programmer's Reference Manuals and Hexagon ABI Specification (registration required, free sign-up) <https://developer.qualcomm.co",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CompilerWriterInfo.rst:5872,guid,guides-manuals,5872,interpreter/llvm-project/llvm/docs/CompilerWriterInfo.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CompilerWriterInfo.rst,1,['guid'],['guides-manuals']
Usability,"Branch probability data in block `successors:` lists can be dropped if the; test doesn't depend on it. Example:; `successors: %bb.1(0x40000000), %bb.2(0x40000000)` can be replaced with; `successors: %bb.1, %bb.2`. - MIR code contains a whole IR module. This is necessary because there are; no equivalents in MIR for global variables, references to external functions,; function attributes, metadata, debug info. Instead some MIR data references; the IR constructs. You can often remove them if the test doesn't depend on; them. - Alias Analysis is performed on IR values. These are referenced by memory; operands in MIR. Example: `:: (load 8 from %ir.foobar, !alias.scope !9)`.; If the test doesn't depend on (good) alias analysis the references can be; dropped: `:: (load 8)`. - MIR blocks can reference IR blocks for debug printing, profile information; or debug locations. Example: `bb.42.myblock` in MIR references the IR block; `myblock`. It is usually possible to drop the `.myblock` reference and simply; use `bb.42`. - If there are no memory operands or blocks referencing the IR then the; IR function can be replaced by a parameterless dummy function like; `define @func() { ret void }`. - It is possible to drop the whole IR section of the MIR file if it only; contains dummy functions (see above). The .mir loader will create the; IR functions automatically in this case. .. _limitations:. Limitations; -----------. Currently the MIR format has several limitations in terms of which state it; can serialize:. - The target-specific state in the target-specific ``MachineFunctionInfo``; subclasses isn't serialized at the moment. - The target-specific ``MachineConstantPoolValue`` subclasses (in the ARM and; SystemZ backends) aren't serialized at the moment. - The ``MCSymbol`` machine operands don't support temporary or local symbols. - A lot of the state in ``MachineModuleInfo`` isn't serialized - only the CFI; instructions and the variable debug information from MMI is serialized righ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MIRLangRef.rst:4877,simpl,simply,4877,interpreter/llvm-project/llvm/docs/MIRLangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MIRLangRef.rst,1,['simpl'],['simply']
Usability,"C++ code; for computing derivatives of the function. It supports both forward-mode and; reverse-mode AD. 4. **Cling for live coding music and musical instruments:**. The artistic live coding community has been growing steadily since around the; year 2000. The Temporary Organisation for the Permanence of Live Art Programming; (TOPLAP) has been around since 2004, Algorave (algorithmic rave parties); recently celebrated its tenth birthday, and six editions of the International; Conference on Live Coding (ICLC) have been held. A great many live coding; systems have been developed during this time, many of them exhibiting exotic and; culturally specific features that professional software developers are mostly; unaware of. In this framework, Cling has been used as the basis for a C++ based; live coding synthesiser (`TinySpec-Cling; <https://github.com/nwoeanhinnogaehr/tinyspec-cling>`_). In another example,; Cling has been installed on a BeagleBoard to bring live coding to the Bela; interactive audio platform (`Using the Cling C++ Interpreter on the Bela; Platform; <https://gist.github.com/jarmitage/6e411ae8746c04d6ecbee1cbc1ebdcd4>`_). These; two examples show the potential mutual benefits for increased engagement between; the Cling community and the artistic live coding community. 5. **Clion:** The `CLion <https://www.jetbrains.com/clion/>`_ platform is a; Integrating Development Environment (`IDE; <https://en.wikipedia.org/wiki/Integrated_development_environment>`_) for C and; C++ by `JetBrains <https://www.jetbrains.com/>`_. It was developed with the aim; to enhance developer's productivity with a smart editor, code quality assurance,; automated refactorings and deep integration with the CMake build system. CLion; integrates Cling, which can be found by clicking on Tool. Cling enables; prototyping and learning C++ in CLion. You can find more information on `CLion's; building instructions; <https://www.jetbrains.com/help/clion/cling-integration.html#install-cling>`_. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/docs/chapters/applications.rst:4060,learn,learning,4060,interpreter/cling/docs/chapters/applications.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/docs/chapters/applications.rst,1,['learn'],['learning']
Usability,"CallArg::SetBinData(void *data, Long_t length)`. The methods could be replaced by equivalent methods with other signature:. * `Bool_t THttpServer::SubmitHttp(std::shared_ptr<THttpCallArg> arg, Bool_t can_run_immediately = kFALSE)`; * `Bool_t THttpServer::ExecuteHttp(std::shared_ptr<THttpCallArg> arg)`; * `Bool_t TRootSniffer::Produce(const std::string &path, const std::string &file, const std::string &options, std::string &res)`; * `const void *THttpCallArg::GetPostData() const`; * `Long_t THttpCallArg::GetPostDataLength() const`; * `std::string THttpCallArg::FillHttpHeader(const char *header = nullptr)`; * `void THttpCallArg::SetContent(std::string &&cont)`. ### Core Libraries; * The `TStringLong` class is deprecated. Please use `std::string` (or, if needeed, `TString`) instead. ## Core Libraries; - Prevent usage of non integer class id in `ClassDef(Inline)` macros with an error prompted at dictionary generation or compile time. ## I/O Libraries. * Added simpler way to retrieve object from `TDirectory` and `TFile`:; ~~~ {.cpp}; auto obj = directory->Get<MyClass>(""some object"");; ~~~. * Added support for read-only `TMemFile`s. ### TNetXNGFile; Added necessary changes to allow [XRootD local redirection](https://github.com/xrootd/xrootd/blob/8c9d0a9cc7f00cbb2db35be275c35126f3e091c0/docs/ReleaseNotes.txt#L14); - Uses standard VectorReadLimits and does not query a XRootD data server (which is unknown in local redirection), when it is redirected to a local file; - Adds a new constructor with a `const char *lurl` to `TNetXNGFile` and passes it to `TFile`, if set. This allows redirection to files that have a different name in the local file system and is important to allow derivation (for example to `TAlien` and `TJAlienFile`) while still keeping functionality via `TArchiveFile` when the file name in the local file system does not match `*.zip`. ### TBufferJSON; Add possibility to convert STL `std::map`, `std::multimap`, `std::unordered_map`,; `std::unordered_multimap` cla",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v618/index.md:5687,simpl,simpler,5687,README/ReleaseNotes/v618/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v618/index.md,1,['simpl'],['simpler']
Usability,"Cint() call is made.; In CINT, all workspace objects will appear as correctly typed references to workspace objects in; a C++ namespace with the same name as the RooWorkspace object. Given e.g. a workspace w, with a Gaussian p.d.f gauss in terms of variables; x,m,s one can now do. RooWorkspace w(""w"",true) ; // workspace with CINT interface activated; // ... fill workspace with RooGaussian gauss(x,m,s) ...; RooPlot* frame = w::x.frame() ;; w::gauss.plotOn(frame) ;. to access the workspace contents. Each reference has the correct type, e.g. w::gauss is; a RooGaussian&. If a workspace is deleted from memory, the corresponding CINT namespace; is removed as well. Note that this feature is strictly available in interpreted C++ only; A new tutorial macro has been added to illustrate this functionality in more detail: rf509_wsinteractive.C.; writeToFile -- A new utility method RooWorkspace::writeToFile() has been added; to simplify the process of saving a workspace to file; Named sets and parameter snapshots -- It is now possible to define and retrieve; named RooArgSets of objects that live in the workspace through methods; defineSet() and set(). While named sets merely group objects logically, methods loadSnapshot and; saveSnapshot allow to make copies of the values, errors and 'constant' status of; sets of variable objects that live in the workspace. A newly added tutorial macro rf510_namedsets.C illustrates the functionality of both; of these features.; Improved printing of contents -- Many operator p.d.f. and function components now show; a more intuitive natural representation of their contents (these changes are mostly in the; respective p.d.f.s, but are most relevant in the context of a workspace). New object factory interface to workspace to facilitate script driven model definition; A object factory has been added to RooFit to simplify the process of creating p.d.f.; and function expressions consisting of multiple objects. The factory has two goals:; the first is t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html:17263,simpl,simplify,17263,roofit/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html,1,['simpl'],['simplify']
Usability,"Cling is (also, but not only) REPL; -----------------------------------. A `read-eval-print-loop <https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop>`_; (**REPL**) is an interactive programming environment that takes user inputs,; executes them, and returns the result to the user. In order to enable; interactivity in C++, Cling provides several extensions to the C++ language:. 1. **Defining functions in the global scope:** Cling redefines expressions at a; global level. C++ provides limited support for this, Cling possesses the; necessary semantics to re-define code while the program is running,; minimizing the impedance mismatch between the **REPL** and the C++ codebase,; and allowing for a seamlessly interactive programing experience. 2. **Allows for implementation of commands** that provide information about the; current state of the environment. e.g., has an `Application Programming; Interface <https://en.wikipedia.org/wiki/API>`_ (**API**) to provide; information about the current state of the environment. 3. **Error recovery:** Cling has an efficient error recovery system which allows; it to handle the errors made by the user without restarting or having to redo; everything from the beginning. 4. **Tight feedback loop:** It provides feedback about the results of the; developer’s choices that is both accurate and fast. 5. **Facilitates debugging:** The programmer can inspect the printed result; before deciding what expression to provide for the next line of code.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/docs/chapters/REPL.rst:1246,feedback,feedback,1246,interpreter/cling/docs/chapters/REPL.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/docs/chapters/REPL.rst,2,['feedback'],['feedback']
Usability,"Cluster Sizes; =============. A cluster contains all the data of a given event range.; As clusters are usually compressed and tied to event boundaries, an exact size cannot be enforced.; Instead, RNTuple uses a *target size* for the compressed data as a guideline for when to flush a cluster. The default cluster target size is 100 MB of compressed data.; The default can be changed by the `RNTupleWriteOptions`.; The default should work well in the majority of cases.; In general, larger clusters provide room for more and larger pages and should improve compression ratio and speed.; However, clusters also need to be buffered during write and (partially) during read,; so larger clusters increase the memory footprint. A second option in `RNTupleWriteOptions` specifies the maximum uncompressed cluster size.; The default is 1 GiB.; This setting acts as an ""emergency break"" and should prevent very compressible clusters from growing too large. Given the two settings, writing works as follows:; when the current cluster is larger than the maximum uncompressed size, it will be flushed unconditionally.; When the current cluster size reaches the estimate for the compressed cluster size, it will be flushed, too.; The estimated compression ratio for the first cluster is 0.5 if compression is used, and 1 otherwise.; The following clusters use the average compression ratio of all so-far written clusters as an estimate.; See the notes below on a discussion of this approximation. Page Sizes; ==========. Pages contain consecutive elements of a certain column.; They are the unit of compression and of addressability on storage.; RNTuple puts a configurable maximum uncompressed size for pages.; This limit is by default set to 1 MiB.; When the limit is reached, a page will be flushed to disk. In addition, RNTuple maintains a memory budget for the combined allocated size of the pages that are currently filled.; By default, this limit is set to twice the compressed target cluster size when comp",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/tuning.md:254,guid,guideline,254,tree/ntuple/v7/doc/tuning.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/tuning.md,1,['guid'],['guideline']
Usability,"Coroutines; DependenceGraphs/index; ExceptionHandling; Extensions; FaultMaps; FuzzingLLVM; GarbageCollection; GetElementPtr; GlobalISel/index; GwpAsan; HowToSetUpLLVMStyleRTTI; HowToUseAttributes; InAlloca; LangRef; LibFuzzer; MarkedUpDisassembly; MIRLangRef; OptBisect; PCSectionsMetadata; PDB/index; PointerAuth; ScudoHardenedAllocator; MemTagSanitizer; Security; SecurityTransparencyReports; SegmentedStacks; StackMaps; SpeculativeLoadHardening; Statepoints; SymbolizerMarkupFormat; SystemLibrary; TestingGuide; TransformMetadata; TypeMetadata; XRay; XRayExample; XRayFDRFormat; YamlIO. API Reference; -------------. `Doxygen generated documentation <https://llvm.org/doxygen/>`_; (`classes <https://llvm.org/doxygen/inherits.html>`_). :doc:`HowToUseAttributes`; Answers some questions about the new Attributes infrastructure. LLVM Reference; --------------. ======================; Command Line Utilities; ======================. :doc:`LLVM Command Guide <CommandGuide/index>`; A reference manual for the LLVM command line utilities (""man"" pages for LLVM; tools). :doc:`Bugpoint`; Automatic bug finder and test-case reducer description and usage; information. :doc:`OptBisect`; A command line option for debugging optimization-induced failures. :doc:`SymbolizerMarkupFormat`; A reference for the log symbolizer markup accepted by ``llvm-symbolizer``. :doc:`The Microsoft PDB File Format <PDB/index>`; A detailed description of the Microsoft PDB (Program Database) file format. ==================; Garbage Collection; ==================. :doc:`GarbageCollection`; The interfaces source-language compilers should use for compiling GC'd; programs. :doc:`Statepoints`; This describes a set of experimental extensions for garbage; collection support. =========; LibFuzzer; =========. :doc:`LibFuzzer`; A library for writing in-process guided fuzzers. :doc:`FuzzingLLVM`; Information on writing and using Fuzzers to find bugs in LLVM. ========; LLVM IR; ========. :doc:`LLVM Language Reference Manual <",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Reference.rst:1212,Guid,Guide,1212,interpreter/llvm-project/llvm/docs/Reference.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Reference.rst,1,['Guid'],['Guide']
Usability,D; Multiple attribute-specifiers in one attribute-list; Unknown. 2280; C++20; Matching a usual deallocation function with placement new; Unknown. 2281; drafting; Consistency of aligned operator delete replacement; Not resolved. 2282; C++20; Consistency with mismatched aligned/non-over-aligned allocation/deallocation functions; Unknown. 2283; drafting; Missing complete type requirements; Not resolved. 2284; open; Sequencing of braced-init-list arguments; Not resolved. 2285; CD5; Issues with structured bindings; Unknown. 2286; NAD; Assignment evaluation order; Unknown. 2287; CD5; Pointer-interconvertibility in non-standard-layout unions; Unknown. 2288; NAD; Contradictory optionality in simple-declaration; Unknown. 2289; CD5; Uniqueness of structured binding names; Unknown. 2290; CD5; Unclear specification for overload resolution and deleted special member functions; Unknown. 2291; dup; Implicit conversion sequences in non-call contexts; Unknown. 2292; CD5; simple-template-id is ambiguous between class-name and type-name; Clang 9. 2293; CD5; Requirements for simple-template-id used as a class-name; Unknown. 2294; CD5; Dependent auto static data members; Unknown. 2295; CD5; Aggregates with deleted defaulted constructors; Unknown. 2296; open; Are default argument instantiation failures in the “immediate context”?; Not resolved. 2297; open; Unclear specification of atomic operations; Not resolved. 2298; open; Actions and expression evaluation; Not resolved. 2299; CD5; constexpr vararg functions; Unknown. 2300; CD5; Lambdas in multiple definitions; Unknown. 2301; open; Value-initialization and constexpr constructor evaluation; Not resolved. 2302; NAD; Address comparison between different member subobjects; Unknown. 2303; CD5; Partial ordering and recursive variadic inheritance; Clang 12. 2304; NAD; Incomplete type vs overload resolution; Unknown. 2305; CD5; Explicit instantiation of constexpr or inline variable template; Unknown. 2306; NAD; Nested friend templates of class,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:156316,simpl,simple-template-id,156316,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['simpl'],['simple-template-id']
Usability,"D<macroname>=<value>. Adds an implicit #define into the predefines buffer which is read before the; source file is preprocessed. .. option:: -U<macroname>. Adds an implicit #undef into the predefines buffer which is read before the; source file is preprocessed. .. option:: -include <filename>. Adds an implicit #include into the predefines buffer which is read before the; source file is preprocessed. .. option:: -I<directory>. Add the specified directory to the search path for include files. .. option:: -F<directory>. Add the specified directory to the search path for framework include files. .. option:: -nostdinc. Do not search the standard system directories or compiler builtin directories; for include files. .. option:: -nostdlibinc. Do not search the standard system directories for include files, but do; search compiler builtin include directories. .. option:: -nobuiltininc. Do not search clang's builtin directory for include files. .. option:: -fkeep-system-includes. Usable only with :option:`-E`. Do not copy the preprocessed content of; ""system"" headers to the output; instead, preserve the #include directive.; This can greatly reduce the volume of text produced by :option:`-E` which; can be helpful when trying to produce a ""small"" reproduceable test case. This option does not guarantee reproduceability, however. If the including; source defines preprocessor symbols that influence the behavior of system; headers (for example, ``_XOPEN_SOURCE``) the operation of :option:`-E` will; remove that definition and thus can change the semantics of the included; header. Also, using a different version of the system headers (especially a; different version of the STL) may result in different behavior. Always verify; the preprocessed file by compiling it separately. ENVIRONMENT; -----------. .. envvar:: TMPDIR, TEMP, TMP. These environment variables are checked, in order, for the location to write; temporary files used during the compilation process. .. envvar:: CPATH. If th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst:19922,Usab,Usable,19922,interpreter/llvm-project/clang/docs/CommandGuide/clang.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst,1,['Usab'],['Usable']
Usability,"DF.fitTo(data, BatchMode(""cuda"")); // can also use ""cuda""; ```. ### User-made PDFs; The easiest and most efficient way of accelerating your PDFs is to request their addition to the official RooFit by submitting a ticket [here](https://github.com/root-project/root/issues/new). The ROOT team will gladly assist you and take care of the details. While your code is integrated, you are able to significantly improve the speed of fitting (but not take full advantage of the RooBatchCompute library), at least by using the batch evaluation feature.; To make use of it, one should override `RooAbsReal::computeBatch()`; ``` {.cpp}; void RooMyPDF::computeBatch(RooBatchCompute::RooBatchComputeInterface*, double* output, size_t nEvents, RooBatchCompute::DataMap& dataMap) const; ```; This method must be implemented so that it fills the `output` array with the **normalized** probabilities computed for `nEvents` events, the data of which can be retrieved from `dataMap`. `dataMap` is a simple `std::map<RooRealVar*, std::span<const double>>`. Note that it is not necessary to evaluate any of the objects that the PDF relies to, because they have already been evaluated by the RooFitDriver, so that their updated results are always present in `dataMap`. The `RooBatchCompute::RooBatchComputeInterface` pointer should be ignored. ``` {.cpp}; void RooMyPDF::computeBatch(RooBatchCompute::RooBatchComputeInterface*, double* output, size_t nEvents, RooBatchCompute::DataMap& dataMap) const; {; // Retrieve `std::span`s for each parameter of the PDF; std::span<const double> span1 = dataMap.at(&*proxyVar1);; // or: auto span1 = dataMap.at(&*proxyVar1);; std::span<const double> span2 = dataMap.at(&*proxyVar2);. // let's assume c is a scalar parameter of the PDF. In this case the dataMap contains a std::span with only one value.; std::span<const double> scalar = dataMap.at(&*c);. // Perform computations in a for-loop; // Use VDT if possible to facilitate auto-vectorization; for (size_t i=0; i<nEvents; ++i)",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/batchcompute.md:4475,simpl,simple,4475,roofit/doc/developers/batchcompute.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/batchcompute.md,1,['simpl'],['simple']
Usability,"Date: Sat, 18 Nov 2000 09:19:35 -0600 (CST); From: Vikram Adve <vadve@cs.uiuc.edu>; To: Chris Lattner <lattner@cs.uiuc.edu>; Subject: a few thoughts. I've been mulling over the virtual machine problem and I had some; thoughts about some things for us to think about discuss:. 1. We need to be clear on our goals for the VM. Do we want to emphasize; portability and safety like the Java VM? Or shall we focus on the; architecture interface first (i.e., consider the code generation and; processor issues), since the architecture interface question is also; important for portable Java-type VMs?. This is important because the audiences for these two goals are very; different. Architects and many compiler people care much more about; the second question. The Java compiler and OS community care much more; about the first one. Also, while the architecture interface question is important for; Java-type VMs, the design constraints are very different. 2. Design issues to consider (an initial list that we should continue; to modify). Note that I'm not trying to suggest actual solutions here,; but just various directions we can pursue:. a. A single-assignment VM, which we've both already been thinking about. b. A strongly-typed VM. One question is do we need the types to be; explicitly declared or should they be inferred by the dynamic compiler?. c. How do we get more high-level information into the VM while keeping; to a low-level VM design?. o Explicit array references as operands? An alternative is; to have just an array type, and let the index computations be; separate 3-operand instructions. o Explicit instructions to handle aliasing, e.g.s:; -- an instruction to say ""I speculate that these two values are not; aliased, but check at runtime"", like speculative execution in; EPIC?; -- or an instruction to check whether two values are aliased and; execute different code depending on the answer, somewhat like; predicated code in EPIC. o (This one is a difficult but powerful idea.); A",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2000-11-18-EarlyDesignIdeas.txt:293,clear,clear,293,interpreter/llvm-project/llvm/docs/HistoricalNotes/2000-11-18-EarlyDesignIdeas.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2000-11-18-EarlyDesignIdeas.txt,1,['clear'],['clear']
Usability,"Date: Sun, 12 May 2002 17:12:53 -0500 (CDT); From: Chris Lattner <sabre@nondot.org>; To: ""Vikram S. Adve"" <vadve@cs.uiuc.edu>; Subject: LLVM change. There is a fairly fundemental change that I would like to make to the LLVM ; infrastructure, but I'd like to know if you see any drawbacks that I ; don't... Basically right now at the basic block level, each basic block contains an ; instruction list (returned by getInstList()) that is a ValueHolder of ; instructions. To iterate over instructions, we must actually iterate over ; the instlist, and access the instructions through the instlist. To add or remove an instruction from a basic block, we need to get an ; iterator to an instruction, which, given just an Instruction*, requires a ; linear search of the basic block the instruction is contained in... just ; to insert an instruction before another instruction, or to delete an ; instruction! This complicates algorithms that should be very simple (like ; simple constant propagation), because they aren't actually sparse anymore,; they have to traverse basic blocks to remove constant propogated ; instructions. Additionally, adding or removing instructions to a basic block ; _invalidates all iterators_ pointing into that block, which is really ; irritating. To fix these problems (and others), I would like to make the ordering of; the instructions be represented with a doubly linked list in the; instructions themselves, instead of an external data structure. This is ; how many other representations do it, and frankly I can't remember why I ; originally implemented it the way I did. Long term, all of the code that depends on the nasty features in the ; instruction list (which can be found by grep'ing for getInstList()) will ; be changed to do nice local transformations. In the short term, I'll ; change the representation, but preserve the interface (including ; getInstList()) so that all of the code doesn't have to change. Iteration over the instructions in a basic block rema",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2002-05-12-InstListChange.txt:950,simpl,simple,950,interpreter/llvm-project/llvm/docs/HistoricalNotes/2002-05-12-InstListChange.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2002-05-12-InstListChange.txt,2,['simpl'],['simple']
Usability,"Date: Sun, 19 Nov 2000 16:23:57 -0600 (CST); From: Chris Lattner <sabre@nondot.org>; To: Vikram Adve <vadve@cs.uiuc.edu>; Subject: Re: a few thoughts. Okay... here are a few of my thoughts on this (it's good to know that we; think so alike!):. > 1. We need to be clear on our goals for the VM. Do we want to emphasize; > portability and safety like the Java VM? Or shall we focus on the; > architecture interface first (i.e., consider the code generation and; > processor issues), since the architecture interface question is also; > important for portable Java-type VMs?. I forsee the architecture looking kinda like this: (which is completely; subject to change). 1. The VM code is NOT guaranteed safe in a java sense. Doing so makes it; basically impossible to support C like languages. Besides that,; certifying a register based language as safe at run time would be a; pretty expensive operation to have to do. Additionally, we would like; to be able to statically eliminate many bounds checks in Java; programs... for example. 2. Instead, we can do the following (eventually): ; * Java bytecode is used as our ""safe"" representation (to avoid; reinventing something that we don't add much value to). When the; user chooses to execute Java bytecodes directly (ie, not; precompiled) the runtime compiler can do some very simple; transformations (JIT style) to convert it into valid input for our; VM. Performance is not wonderful, but it works right.; * The file is scheduled to be compiled (rigorously) at a later; time. This could be done by some background process or by a second; processor in the system during idle time or something...; * To keep things ""safe"" ie to enforce a sandbox on Java/foreign code,; we could sign the generated VM code with a host specific private; key. Then before the code is executed/loaded, we can check to see if; the trusted compiler generated the code. This would be much quicker; than having to validate consistency (especially if bounds checks have; been remo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2000-11-18-EarlyDesignIdeasResp.txt:263,clear,clear,263,interpreter/llvm-project/llvm/docs/HistoricalNotes/2000-11-18-EarlyDesignIdeasResp.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2000-11-18-EarlyDesignIdeasResp.txt,1,['clear'],['clear']
Usability,"Date: Thu, 8 Feb 2001 08:42:04 -0600; From: Vikram S. Adve <vadve@cs.uiuc.edu>; To: Chris Lattner <sabre@nondot.org>; Subject: RE: Type notation debate... Chris,. > Okay before you comment, please look at:; >; > http://www.research.att.com/~bs/devXinterview.html. I read this argument. Even before that, I was already in agreement with you; and him that the C declarator syntax is difficult and confusing. But in fact, if you read the entire answer carefully, he came to the same; conclusion I do: that you have to go with familiar syntax over logical; syntax because familiarity is such a strong force:. ""However, familiarity is a strong force. To compare, in English, we; live; more or less happily with the absurd rules for ""to be"" (am, are, is, been,; was, were, ...) and all attempts to simplify are treated with contempt or; (preferably) humor. It be a curious world and it always beed."". > Basically, my argument for this type construction system is that it is; > VERY simple to use and understand (although it IS different than C, it is; > very simple and straightforward, which C is NOT). In fact, I would assert; > that most programmers TODAY do not understand pointers to member; > functions, and have to look up an example when they have to write them. Again, I don't disagree with this at all. But to some extent this; particular problem is inherently difficult. Your syntax for the above; example may be easier for you to read because this is the way you have been; thinking about it. Honestly, I don't find it much easier than the C syntax.; In either case, I would have to look up an example to write pointers to; member functions. But pointers to member functions are nowhere near as common as arrays. And; the old array syntax:; type [ int, int, ...]; is just much more familiar and clear to people than anything new you; introduce, no matter how logical it is. Introducing a new syntax that may; make function pointers easier but makes arrays much more difficult seems; very risky t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-06-TypeNotationDebateResp1.txt:792,simpl,simplify,792,interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-06-TypeNotationDebateResp1.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-06-TypeNotationDebateResp1.txt,3,['simpl'],"['simple', 'simplify']"
Usability,"Date: Tue, 18 Sep 2001 00:38:37 -0500 (CDT); From: Chris Lattner <sabre@nondot.org>; To: Vikram S. Adve <vadve@cs.uiuc.edu>; Subject: Idea for a simple, useful link time optimization. In C++ programs, exceptions suck, and here's why:. 1. In virtually all function calls, you must assume that the function; throws an exception, unless it is defined as 'nothrow'. This means; that every function call has to have code to invoke dtors on objects; locally if one is thrown by the function. Most functions don't throw; exceptions, so this code is dead [with all the bad effects of dead; code, including icache pollution].; 2. Declaring a function nothrow causes catch blocks to be added to every; call that isnot provably nothrow. This makes them very slow.; 3. Extra extraneous exception edges reduce the opportunity for code; motion.; 4. EH is typically implemented with large lookup tables. Ours is going to; be much smaller (than the ""standard"" way of doing it) to start with,; but eliminating it entirely would be nice. :); 5. It is physically impossible to correctly put (accurate, correct); exception specifications on generic, templated code. But it is trivial; to analyze instantiations of said code.; 6. Most large C++ programs throw few exceptions. Most well designed; programs only throw exceptions in specific planned portions of the; code. Given our _planned_ model of handling exceptions, all of this would be; pretty trivial to eliminate through some pretty simplistic interprocedural; analysis. The DCE factor alone could probably be pretty significant. The; extra code motion opportunities could also be exploited though... Additionally, this optimization can be implemented in a straight forward; conservative manner, allowing libraries to be optimized or individual; files even (if there are leaf functions visible in the translation unit; that are called). I think it's a reasonable optimization that hasn't really been addressed; (because assembly is way too low level for this), and ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-09-18-OptimizeExceptions.txt:145,simpl,simple,145,interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-09-18-OptimizeExceptions.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-09-18-OptimizeExceptions.txt,1,['simpl'],['simple']
Usability,"Date: Tue, 6 Feb 2001 20:27:37 -0600 (CST); From: Chris Lattner <sabre@nondot.org>; To: Vikram S. Adve <vadve@cs.uiuc.edu>; Subject: Type notation debate... This is the way that I am currently planning on implementing types:. Primitive Types: ; type ::= void|bool|sbyte|ubyte|short|ushort|int|uint|long|ulong. Method:; typelist ::= typelisth | /*empty*/; typelisth ::= type | typelisth ',' type; type ::= type (typelist). Arrays (without and with size):; type ::= '[' type ']' | '[' INT ',' type ']'. Pointer:; type ::= type '*'. Structure:; type ::= '{' typelist '}'. Packed:; type ::= '<' INT ',' type '>'. Simple examples:. [[ %4, int ]] - array of (array of 4 (int)); [ { int, int } ] - Array of structure; [ < %4, int > ] - Array of 128 bit SIMD packets; int (int, [[int, %4]]) - Method taking a 2d array and int, returning int. Okay before you comment, please look at:. http://www.research.att.com/~bs/devXinterview.html. Search for ""In another interview, you defined the C declarator syntax as; an experiment that failed. However, this syntactic construct has been; around for 27 years and perhaps more; why do you consider it problematic; (except for its cumbersome syntax)?"" and read that response for me. :). Now with this syntax, his example would be represented as:. [ %10, bool (int, int) * ] *. vs . bool (*(*)[10])(int, int). in C. Basically, my argument for this type construction system is that it is; VERY simple to use and understand (although it IS different than C, it is; very simple and straightforward, which C is NOT). In fact, I would assert; that most programmers TODAY do not understand pointers to member; functions, and have to look up an example when they have to write them. In my opinion, it is critically important to have clear and concise type; specifications, because types are going to be all over the programs. Let me know your thoughts on this. :). -Chris. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-06-TypeNotationDebate.txt:609,Simpl,Simple,609,interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-06-TypeNotationDebate.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-06-TypeNotationDebate.txt,4,"['Simpl', 'clear', 'simpl']","['Simple', 'clear', 'simple']"
Usability,"Date: Wed, 20 Jun 2001 12:32:22 -0500; From: Vikram Adve <vadve@cs.uiuc.edu>; To: Chris Lattner <lattner@cs.uiuc.edu>; Subject: .NET vs. our VM. One significant difference between .NET CLR and our VM is that the CLR; includes full information about classes and inheritance. In fact, I just; sat through the paper on adding templates to .NET CLR, and the speaker; indicated that the goal seems to be to do simple static compilation (very; little lowering or optimization). Also, the templates implementation in CLR; ""relies on dynamic class loading and JIT compilation"". This is an important difference because I think there are some significant; advantages to have a much lower level VM layer, and do significant static; analysis and optimization. I also talked to the lead guy for KAI's C++ compiler (Arch Robison) and he; said that SGI and other commercial compilers have included options to export; their *IR* next to the object code (i.e., .il files) and use them for; link-time code generation. In fact, he said that the .o file was nearly; empty and was entirely generated from the .il at link-time. But he agreed; that this limited the link-time interprocedural optimization to modules; compiled by the same compiler, whereas our approach allows us to link and; optimize modules from multiple different compilers. (Also, of course, they; don't do anything for runtime optimization). All issues to bring up in Related Work. --Vikram. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-06-20-.NET-Differences.txt:405,simpl,simple,405,interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-06-20-.NET-Differences.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-06-20-.NET-Differences.txt,1,['simpl'],['simple']
Usability,"Date: Wed, 31 Jan 2001 12:04:33 -0600; From: Vikram S. Adve <vadve@cs.uiuc.edu>; To: Chris Lattner <lattner@cs.uiuc.edu>; Subject: another thought. I have a budding idea about making LLVM a little more ambitious: a; customizable runtime system that can be used to implement language-specific; virtual machines for many different languages. E.g., a C vm, a C++ vm, a; Java vm, a Lisp vm, .. The idea would be that LLVM would provide a standard set of runtime features; (some low-level like standard assembly instructions with code generation and; static and runtime optimization; some higher-level like type-safety and; perhaps a garbage collection library). Each language vm would select the; runtime features needed for that language, extending or customizing them as; needed. Most of the machine-dependent code-generation and optimization; features as well as low-level machine-independent optimizations (like PRE); could be provided by LLVM and should be sufficient for any language,; simplifying the language compiler. (This would also help interoperability; between languages.) Also, some or most of the higher-level; machine-independent features like type-safety and access safety should be; reusable by different languages, with minor extensions. The language; compiler could then focus on language-specific analyses and optimizations. The risk is that this sounds like a universal IR -- something that the; compiler community has tried and failed to develop for decades, and is; universally skeptical about. No matter what we say, we won't be able to; convince anyone that we have a universal IR that will work. We need to; think about whether LLVM is different or if has something novel that might; convince people. E.g., the idea of providing a package of separable; features that different languages select from. Also, using SSA with or; without type-safety as the intermediate representation. One interesting starting point would be to discuss how a JVM would be; implemented on top of LLV",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-01-31-UniversalIRIdea.txt:988,simpl,simplifying,988,interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-01-31-UniversalIRIdea.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-01-31-UniversalIRIdea.txt,1,['simpl'],['simplifying']
Usability,"Declaring objects as ``const`` is an important tool of enforcing mutation free; algorithms (such as analyses, etc.). For this purpose above iterators come in; constant flavors as ``Value::const_use_iterator`` and; ``Value::const_op_iterator``. They automatically arise when calling; ``use/op_begin()`` on ``const Value*``\ s or ``const User*``\ s respectively.; Upon dereferencing, they return ``const Use*``\ s. Otherwise the above patterns; remain unchanged. .. _iterate_preds:. Iterating over predecessors & successors of blocks; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Iterating over the predecessors and successors of a block is quite easy with the; routines defined in ``""llvm/IR/CFG.h""``. Just use code like this to; iterate over all predecessors of BB:. .. code-block:: c++. #include ""llvm/IR/CFG.h""; BasicBlock *BB = ...;. for (BasicBlock *Pred : predecessors(BB)) {; // ...; }. Similarly, to iterate over successors use ``successors``. .. _simplechanges:. Making simple changes; ---------------------. There are some primitive transformation operations present in the LLVM; infrastructure that are worth knowing about. When performing transformations,; it's fairly common to manipulate the contents of basic blocks. This section; describes some of the common methods for doing so and gives example code. .. _schanges_creating:. Creating and inserting new ``Instruction``\ s; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. *Instantiating Instructions*. Creation of ``Instruction``\ s is straight-forward: simply call the constructor; for the kind of instruction to instantiate and provide the necessary parameters.; For example, an ``AllocaInst`` only *requires* a (const-ptr-to) ``Type``. Thus:. .. code-block:: c++. auto *ai = new AllocaInst(Type::Int32Ty);. will create an ``AllocaInst`` instance that represents the allocation of one; integer in the current stack frame, at run time. Each ``Instruction`` subclass; is likely to have varying default parameters which change th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:113194,simpl,simple,113194,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['simpl'],['simple']
Usability,"Deploying the Virtual Analysis Facility; =======================================. Introduction; ------------. Thanks to CernVM and PROOF on Demand, it is possible to deploy a ready; to use Virtual Analysis Facility on your cloud (either public, private; or even your desktop computer). On the server side, ""configuring"" the Virtual Analysis Facility is; simply a matter of starting a certain number of CernVM virtual machines; that will become part of your PROOF cluster. CernVM uses; contextualization to specialize each virtual machine to be either a head; node or a worker node. The Virtual Analysis Facility comes with many preconfigured things:. - a HTCondor cluster capable of running PROOF on Demand. - certificate authentication. - your experiment's software (if available on CernVM-FS). Obtain the CernVM image and contextualization; ---------------------------------------------. ### Download the CernVM bare image. The Virtual Analysis Facility currently works with *CernVM Batch 2.7.1; 64-bit*. This means that you need to have this CernVM image available; either on your local hard disk (in case of a desktop deployment) or in; your cloud's image repository. > For convenience we provide the direct link for the working versions:; >; > - [CernVM 2.7.1 batch 64-bit for; > **KVM**](https://cernvm.cern.ch/releases/19/cernvm-batch-node-2.7.1-2-3-x86_64.hdd.gz); >; > - [CernVM 2.7.1 batch 64-bit for; > **Xen**](https://cernvm.cern.ch/releases/19/cernvm-batch-node-2.7.1-2-3-x86_64.ext3.gz); >; > Images are gzipped. In most cases you'll need to gunzip them before; > registering to your image repository. ### Create VM configuration profiles. CernVM images are base images supporting boot-time customization via; configuration profiles called ""contexts"". Context creation can be; performed through the [CernVM Online](https://cernvm-online.cern.ch/); website. The site is immediately accessible if you have a CERN account. Go to your [CernVM Online; Dashboard](https://cernvm-online.cern.c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/DeployVirtualAnalysisFacility.md:354,simpl,simply,354,proof/doc/confman/DeployVirtualAnalysisFacility.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/DeployVirtualAnalysisFacility.md,1,['simpl'],['simply']
Usability,"Description; Inputs; =================== =============== =============== =======================================; reserved ``s_trap 0x00`` Reserved by hardware.; ``debugtrap(arg)`` ``s_trap 0x01`` ``SGPR0-1``: Reserved for Finalizer HSA ``debugtrap``; ``queue_ptr`` intrinsic (not implemented).; ``VGPR0``:; ``arg``; ``llvm.trap`` ``s_trap 0x02`` ``SGPR0-1``: Causes wave to be halted with the PC at; ``queue_ptr`` the trap instruction. The associated; queue is signalled to put it into the; error state. When the queue is put in; the error state, the waves executing; dispatches on the queue will be; terminated.; ``llvm.debugtrap`` ``s_trap 0x03`` *none* - If debugger not enabled then behaves; as a no-operation. The trap handler; is entered and immediately returns to; continue execution of the wavefront.; - If the debugger is enabled, causes; the debug trap to be reported by the; debugger and the wavefront is put in; the halt state with the PC at the; instruction. The debugger must; increment the PC and resume the wave.; reserved ``s_trap 0x04`` Reserved.; reserved ``s_trap 0x05`` Reserved.; reserved ``s_trap 0x06`` Reserved.; reserved ``s_trap 0x07`` Reserved.; reserved ``s_trap 0x08`` Reserved.; reserved ``s_trap 0xfe`` Reserved.; reserved ``s_trap 0xff`` Reserved.; =================== =============== =============== =======================================. .. .. table:: AMDGPU Trap Handler for AMDHSA OS Code Object V3; :name: amdgpu-trap-handler-for-amdhsa-os-v3-table. =================== =============== =============== =======================================; Usage Code Sequence Trap Handler Description; Inputs; =================== =============== =============== =======================================; reserved ``s_trap 0x00`` Reserved by hardware.; debugger breakpoint ``s_trap 0x01`` *none* Reserved for debugger to use for; breakpoints. Causes wave to be halted; with the PC at the trap instruction.; The debugger is responsible to resume; the wave, including the instr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:381886,resume,resume,381886,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['resume'],['resume']
Usability,"E.SVGRenderer - no need for patched version; 4. When producing 3D graphical images in batch, use normal THREE.CanvasRenderer; 5. Use WebGL renderer in Chrome headless mode for 3D images generation; 6. Provide possibility to create SVG files for canvas or frame (#172); 7. Support text drawing with TH1 bar option; 8. Fix - when drawing text, reserve extra y range to show it correctly; 9. Migrate to Node.js 8, do not support older versions. ## Changes in 5.5.2; 1. Fix - draw TH2Poly bins outline when no content specified; 2. Fix - always set axis interactive handlers (#170); 3. Fix - take into account zaxis properties when drawing color palette (#171). ## Changes in 5.5.1; 1. Fix - adjust v7 part to new class naming convention, started with R; 2. Fix - show RCanvas title; 3. New - implement 'nocache' option for JSROOT scripts loading. When specified in URL with; JSRootCore.js script, tries to avoid scripts caching problem by adding stamp parameter to all URLs; 4. New - provide simple drawing for TObjString (#164). ## Changes in 5.5.0; 1. Introduce JSROOT.StoreJSON() function. It creates JSON code for the; TCanvas with all drawn objects inside. Allows to store current canvas state; 2. Support ""item=img:file.png"" parameter to insert images in existing layout (#151); 3. Support TTree drawing into TGraph (#153), thanks @cozzyd; 4. Let configure ""&toolbar=right"" in URL to change position of tool buttons; 5. Let configure ""&divsize=500x400"" in URL of size of main div element (default - full browser); 6. Implement ""optstat1001"" and ""optfit101"" draw options for histograms; 7. Remove ""autocol"" options - standard ""plc"" should be used instead; 8. Provide drawing of artificial ""$legend"" item - it creates TLegend for all primitives in pad; Can be used when several histograms or several graphs superimposed; 9. Let configure ""&toolbar=vert"" in URL to change orientation of tool buttons; 10. Improve markers and error bars drawing for TH1/TProfile. ## Changes in 5.4.3; 1. Fix - draw fun",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/changes.md:33404,simpl,simple,33404,js/changes.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/changes.md,1,['simpl'],['simple']
Usability,"ECACHE_SIZE. The resource variable TTreeCache.Prefill sets the default TTreeCache prefilling; type. The prefill type may be: 0 for no prefilling and 1 to prefill all; the branches. It can be overridden by the environment variable ROOT_TTREECACHE_PREFILL. In particular the default can be set back to the same as in version 5 by; setting TTreeCache.Size (or ROOT_TTREECACHE_SIZE) and TTreeCache.Prefill; (or ROOT_TTREECACHE_PREFILL) both to zero. TTree methods which are expected to modify a cache, like AddBranchToCache, will; attempt to setup a cache of default size if one does not exist, irrespective of; whether the auto cache creation is enabled. Additionally several methods giving; control of the cache have changed return type from void to Int_t, to be able to; return a code to indicate if there was an error. Usually TTree::SetCacheSize will no longer reset the list of branches to be; cached (either set or previously learnt) nor restart the learning phase.; The learning phase is restarted when a new cache is created, e.g. after having; removed a cache with SetCacheSize(0). ### TSelectorDraw. The axis titles in case of a `x:y:z` plot with the option `COLZ` were not correct. ### TParallelCoordVar. Change the format used to print the variables limit for ||-Coord to `%g`. It was; `%6.4f` before. ## Histogram Libraries. ### TFormula. - New version of the TFormula class based on Cling. Formula expressions are now used to create functions which are passed to Cling to be Just In Time compiled.; The expression is therefore compiled using Clang/LLVVM which will give execution time as compiled code and in addition correctness of the result obtained.; - This class is not 100% backward compatible with the old TFormula class, which is still available in ROOT as =ROOT::v5::TFormula=.; Some of the TFormula member funtions available in version 5, such as =Analyze= and =AnalyzeFunction= are not available in the new TFormula class.; On the other hand formula expressions which were valid ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v604/index.md:14817,learn,learning,14817,README/ReleaseNotes/v604/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v604/index.md,1,['learn'],['learning']
Usability,"E_BUILD_TYPE=RelWithDebInfo`` instead of; ``-DCMAKE_BUILD_TYPE=Release``. This will grant better coverage of; debug info pieces of clang, but will take longer to complete and will; result in a much larger build directory. It's recommended to build the ``all`` target with your instrumented Clang,; since more coverage is often better. b. You should now have a few ``*.profraw`` files in; ``path/to/stage2/profiles/``. You need to merge these using; ``llvm-profdata`` (even if you only have one! The profile merge transforms; profraw into actual profile data, as well). This can be done with; ``/path/to/stage1/llvm-profdata merge; -output=/path/to/output/profdata.prof path/to/stage2/profiles/*.profraw``. 4. Now, build your final, PGO-optimized Clang. To do this, you'll want to pass; the following additional arguments to CMake. - ``-DLLVM_PROFDATA_FILE=/path/to/output/profdata.prof`` - Use the PGO; profile from the previous step.; - ``-DCMAKE_C_COMPILER=/path/to/stage1/clang`` - Use the Clang we built in; step 1.; - ``-DCMAKE_CXX_COMPILER=/path/to/stage1/clang++`` - Same as above. From here, you can build whatever targets you need. .. note::; You may see warnings about a mismatched profile in the build output. These; are generally harmless. To silence them, you can add; ``-DCMAKE_C_FLAGS='-Wno-backend-plugin'; -DCMAKE_CXX_FLAGS='-Wno-backend-plugin'`` to your CMake invocation. Congrats! You now have a Clang built with profile-guided optimizations, and you; can delete all but the final build directory if you'd like. If this worked well for you and you plan on doing it often, there's a slight; optimization that can be made: LLVM and Clang have a tool called tblgen that's; built and run during the build process. While it's potentially nice to build; this for coverage as part of step 3, none of your other builds should benefit; from building it. You can pass the CMake option; ``-DLLVM_NATIVE_TOOL_DIR=/path/to/stage1/bin``; to steps 2 and onward to avoid these useless rebuilds.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToBuildWithPGO.rst:6712,guid,guided,6712,interpreter/llvm-project/llvm/docs/HowToBuildWithPGO.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToBuildWithPGO.rst,1,['guid'],['guided']
Usability,"E` and `F` will actually position only `A` and; `B `directly into these volumes, taking into account their combined; transformations `A/B` to `C` and `C` to `D/E/F`. This looks much nicer,; is it? In fact, it is and it is not. Of course, we managed to get rid of; the ""unnecessary"" volume `C` in our geometry, but we end-up with a more; flat structure for `D,E` and `F` (more daughters inside). This can get; much worse when extensively used, as in the case: assemblies of; assemblies. For deciding what to choose between using virtual containers or; assemblies for a specific case, one can use for both cases, after the; geometry was closed:. ~~~{.cpp}; gGeoManager->SetTopVolume(ptr_D);; gGeoManager->Test();; gGeoManager->RestoreMasterVolume();; ~~~. The `ptr_D` is a pointer to volume `D` containing the interesting; structure. The test will provide the timing for classifying 1 million; random points inside `D`. \anchor GP01be; #### Examples of Volume Positioning. Now let us make a simple volume representing a copper wire. We suppose; that a medium is already created (see TGeoMedium class on how to; create media). We will create a `TUBE` shape for our wire, having `Rmin=0cm`,; `Rmax=0.01cm` and a half-length `dZ=1cm`:. ~~~{.cpp}; TGeoTube *tube = new TGeoTube(""wire_tube"",0,0.01,1);; ~~~. One may omit the name for the shape `wire_tube,` if no retrieving by; name is further needed during geometry building. Different volumes; having different names and materials can share the same shape. Now let's make the volume for our wire:. ~~~{.cpp}; TGeoVolume *wire_co = new TGeoVolume(""WIRE_CO"",tube,ptrCOPPER); //(*); ~~~. (*) Do not bother to delete the media, shapes or volumes that you; have created since all will be automatically cleaned on exit by the; manager class. If we would have taken a look inside `TGeoManager::MakeTube()` method,; we would have been able to create our wire with a single line:. ~~~{.cpp}; TGeoVolume *wire_co = gGeoManager->MakeTube(""WIRE_CO"",ptrCOPPER,0,0.01,1",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:33427,simpl,simple,33427,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['simpl'],['simple']
Usability,"Emissive. For each of these you can select the component via the radio buttons.; Each component can have the red, green and blue values for the component; adjusted via the sliders. You can apply this adjustment to the shape; itself, or to all shapes sharing a common ‘family'. Shapes of the same; family have external objects with the same **`TObject`** name string.; You can also adjust the ‘Opacity' and ‘Shine' for the shapes materials; via the sliders. #### Geometry. Viewer Controls Pane ‘Geometry' tab. Review and modify the shapes X/Y/Z center and scaling factors via the; edit boxes. Selection and editing of shapes is not available via the API; at present. #### Outputting Viewer Contents. The current viewer rendering can be output to an external `EPS` or; `PDF`, using the options under the ‘File' menu on the top menu bar. The; file is named ‘`viewer.eps`' or ‘`viewer.pdf`' and written to the; current ROOT directory. ### The X3D Viewer. The X3D viewer is a fairly simple and limited viewer, capable of showing; basic lines and polygons. It lacks the quality, performance and more; advanced features of the GL Viewer, and additionally is not supported on; Windows. It is not actively developed and you are encouraged to use the; GL Viewer out of preference. The below table presents the main; interactions - these are repeated in the Help dialog of the viewer. Action KeyActionKey. Wireframe Mode wRotate about xx a. Hidden Line Mode eRotate about yy b. Hidden Surface Mode rRotate about zz c. Move object down uAuto-rotate about x1 2 3. Move object up iAuto-rotate about y4 5 6. Move object left lAuto-rotate about z7 8 9. Move object right hToggle controls styleo. Move object forward jToggle stereo displays. Move object backward kToggle blue stereo viewd. Adjust focus (stereo mode) [ ] { }Toggle double bufferf. Rotate object Left mouse button down + move. ### Common 3D Viewer Architecture. The 3D Viewer Architecture provides a common mechanism for viewer; clients to publish 3D o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:121103,simpl,simple,121103,documentation/users-guide/Graphics.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md,1,['simpl'],['simple']
Usability,"Event.so; if (!TClassTable::GetDict(""Event"")) {; gSystem->Load(""$ROOTSYS/test/libEvent.so"");; }; // read the tree generated with tree4w. // note that we use ""new"" to create the TFile and TTree objects, because we; // want to keep these objects alive when we leave this function.; TFile *f = new TFile(""tree4.root"");; TTree *t4 = (TTree*)f->Get(""t4"");. // create a pointer to an event object for reading the branch values.; Event *event = new Event();; // get two branches and set the branch address; TBranch *bntrack = t4->GetBranch(""fNtrack"");; TBranch *branch = t4->GetBranch(""event_split"");; branch->SetAddress(&event);. Int_t nevent = t4->GetEntries();; Int_t nselected = 0;; Int_t nb = 0;; for (Int_t i=0; i<nevent; i++) {; //read branch ""fNtrack""only; bntrack->GetEntry(i);. // reject events with more than 587 tracks; if (event->GetNtrack() > 587)continue;. // read complete accepted event in memory; nb += t4->GetEntry(i);; nselected++;. // print the first accepted event; if (nselected == 1) t4->Show();; // clear tracks array; event->Clear();; }. if (gROOT->IsBatch()) return;; new TBrowser();; t4->StartViewer();; }; ```. Now, let's see how the tree looks like in the tree viewer. ![The tree viewer with tree4 example](pictures/03000103.png). You can see the two branches in the tree in the left panel: the event; branch is split and hence expands when clicked on. The other branch; event not split is not expandable and we can not browse the data; members. The **`TClonesArray`** of tracks `fTracks` is also split because we set; the split level to 2. The output on the command line is the result of; `tree4->Show()`. It shows the first entry with more than 587 tracks:. ``` {.cpp}; ======> EVENT:26; event_split =; fUniqueID = 0; fBits = 50331648; fType[20] = 116 121 112 101 49 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0; fNtrack = 585; fNseg = 5834; fNvertex = 17; fFlag = 0; fTemperature = 20.044315; fEvtHdr.fEvtNum = 26; fEvtHdr.fRun = 200; fEvtHdr.fDate = 960312; fTracks = 585; fTracks.fUniqueI",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:65333,clear,clear,65333,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,2,"['Clear', 'clear']","['Clear', 'clear']"
Usability,"Example project using cling as library <https://github.com/root-project/cling/tree/master/tools/demo>`_; - *Axel Naumann* 2016 GitHub; - This video showcases how to use Cling as a library, and shows how to set up a simple CMake configuration that uses Cling.; * - `Cling C++ interpreter testdrive <https://www.youtube.com/watch?v=1IGTHusaJ18>`_; - *Mika* 2015 Youtube; - In this tutorial, a developer tries Cling for the first time by uploading a few simple C++ user-cases onto Cling, involving also the loading of external files; * - `Building an Order Book in C++ <https://www.youtube.com/watch?v=fxN4xEZvrxI>`_; - *Dimitri Nesteruk* 2015 Youtube; - This demo shows how to build a simple order book using C++, CLion, Google Test and, of course, Cling. ; * - `Cling C++ interpreter testdrive <https://www.youtube.com/watch?v=1IGTHusaJ18>`_; - Dimitri Nesteruk 2015 Youtube; - This tutorial describes Cling’s general features. You will learn how to start Cling on Ubuntu, how to write a simple expression (N=5, N++) and how to define a Class for calculating body mass index. ; * - `Cling Interactive OpenGL Demo <https://www.youtube.com/watch?v=eoIuqLNvzFs>`_; - *Alexander Penev* 2012 Youtube; - This demo shows how to use Cling for interactive OpenGL. A rotating triangle with changing color, a static figure, and a figure with light effects are created.; ; . .. list-table:: Language Interoperability with Cling:; :widths: 25 25 50; :header-rows: 1. * - Link; - Info ; - Description; * - `Compiler Research - Calling C++ libraries from a D-written DSL: A cling/cppyy-based approach <https://www.youtube.com/watch?v=7teqrCNzrD8>`_; - *Alexandru Militaru* 2021 Compiler-Research Meeting; - This video presents D and C++ interoperability through SIL-Cling architecture. .. list-table:: Interactive CUDA C++ with Cling:; :widths: 25 25 50; :header-rows: 1. * - Link; - Info ; - Description; * - `Adding CUDA® Support to Cling: JIT Compile to GPUs <https://www.youtube.com/watch?v=XjjZRhiFDVs>`_; - *Si",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/docs/chapters/references.rst:5302,learn,learn,5302,interpreter/cling/docs/chapters/references.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/docs/chapters/references.rst,2,"['learn', 'simpl']","['learn', 'simple']"
Usability,"FFailureRoutine: {type: int}; GuardRFFailureRoutineFunctionPointer: {type: int}; DynamicValueRelocTableOffset: {type: int}; DynamicValueRelocTableSection: {type: int}; GuardRFVerifyStackPointerFunctionPointer: {type: int}; HotPatchTableOffset: {type: int}; EnclaveConfigurationPointer: {type: int}; VolatileMetadataPointer: {type: int}; GuardEHContinuationTable: {type: int}; GuardEHContinuationCount: {type: int}; GuardXFGCheckFunctionPointer: {type: int}; GuardXFGDispatchFunctionPointer: {type: int}; GuardXFGTableDispatchFunctionPointer: {type: int}; CastGuardOsDeterminedFailureMode: {type: int}. symbols:; - Name: .text; Value: 0; SectionNumber: 1; SimpleType: IMAGE_SYM_TYPE_NULL # (0); ComplexType: IMAGE_SYM_DTYPE_NULL # (0); StorageClass: IMAGE_SYM_CLASS_STATIC # (3); NumberOfAuxSymbols: 1; AuxiliaryData:; ""\x24\x00\x00\x00\x03\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00"" # |$.................|. - Name: _main; Value: 0; SectionNumber: 1; SimpleType: IMAGE_SYM_TYPE_NULL # (0); ComplexType: IMAGE_SYM_DTYPE_NULL # (0); StorageClass: IMAGE_SYM_CLASS_EXTERNAL # (2). Here's a simplified Kwalify_ schema with an extension to allow alternate types. .. _Kwalify: http://www.kuwata-lab.com/kwalify/ruby/users-guide.html. .. code-block:: yaml. type: map; mapping:; header:; type: map; mapping:; Machine: [ {type: str, enum:; [ IMAGE_FILE_MACHINE_UNKNOWN; , IMAGE_FILE_MACHINE_AM33; , IMAGE_FILE_MACHINE_AMD64; , IMAGE_FILE_MACHINE_ARM; , IMAGE_FILE_MACHINE_ARMNT; , IMAGE_FILE_MACHINE_ARM64; , IMAGE_FILE_MACHINE_EBC; , IMAGE_FILE_MACHINE_I386; , IMAGE_FILE_MACHINE_IA64; , IMAGE_FILE_MACHINE_M32R; , IMAGE_FILE_MACHINE_MIPS16; , IMAGE_FILE_MACHINE_MIPSFPU; , IMAGE_FILE_MACHINE_MIPSFPU16; , IMAGE_FILE_MACHINE_POWERPC; , IMAGE_FILE_MACHINE_POWERPCFP; , IMAGE_FILE_MACHINE_R4000; , IMAGE_FILE_MACHINE_SH3; , IMAGE_FILE_MACHINE_SH3DSP; , IMAGE_FILE_MACHINE_SH4; , IMAGE_FILE_MACHINE_SH5; , IMAGE_FILE_MACHINE_THUMB; , IMAGE_FILE_MACHINE_WCEMIPSV2; ]}; , {type: int}; ]; Characteristics:; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/yaml2obj.rst:2915,Simpl,SimpleType,2915,interpreter/llvm-project/llvm/docs/yaml2obj.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/yaml2obj.rst,1,['Simpl'],['SimpleType']
Usability,"FP::get(*TheContext, APFloat(0.0));; }. AllocaInst *Alloca = CreateEntryBlockAlloca(TheFunction, VarName);; Builder->CreateStore(InitVal, Alloca);. // Remember the old variable binding so that we can restore the binding when; // we unrecurse.; OldBindings.push_back(NamedValues[VarName]);. // Remember this binding.; NamedValues[VarName] = Alloca;; }. There are more comments here than code. The basic idea is that we emit; the initializer, create the alloca, then update the symbol table to; point to it. Once all the variables are installed in the symbol table,; we evaluate the body of the var/in expression:. .. code-block:: c++. // Codegen the body, now that all vars are in scope.; Value *BodyVal = Body->codegen();; if (!BodyVal); return nullptr;. Finally, before returning, we restore the previous variable bindings:. .. code-block:: c++. // Pop all our variables from scope.; for (unsigned i = 0, e = VarNames.size(); i != e; ++i); NamedValues[VarNames[i].first] = OldBindings[i];. // Return the body computation.; return BodyVal;; }. The end result of all of this is that we get properly scoped variable; definitions, and we even (trivially) allow mutation of them :). With this, we completed what we set out to do. Our nice iterative fib; example from the intro compiles and runs just fine. The mem2reg pass; optimizes all of our stack variables into SSA registers, inserting PHI; nodes where needed, and our front-end remains simple: no ""iterated; dominance frontier"" computation anywhere in sight. Full Code Listing; =================. Here is the complete code listing for our running example, enhanced with; mutable variables and var/in support. To build this example, use:. .. code-block:: bash. # Compile; clang++ -g toy.cpp `llvm-config --cxxflags --ldflags --system-libs --libs core orcjit native` -O3 -o toy; # Run; ./toy. Here is the code:. .. literalinclude:: ../../../examples/Kaleidoscope/Chapter7/toy.cpp; :language: c++. `Next: Compiling to Object Code <LangImpl08.html>`_. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst:28956,simpl,simple,28956,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,1,['simpl'],['simple']
Usability,"FT,\; Jonas Rembser, CERN/SFT,\; Enric Tejedor Saavedra, CERN/SFT,\; Aaradhya Saxena, GSOC,\; Oksana Shadura, UNL/CMS,\; Sanjiban Sengupta, GSOC,\; Federico Sossai, CERN/SFT,\; Harshal Shende, GSOC,\; Matevz Tadel, UCSD/CMS,\; Vassil Vassilev, Princeton/CMS,\; Wouter Verkerke, NIKHEF/ATLAS,\; Zef Wolffs, NIKHEF/ATLAS,\; Stefan Wunsch, CERN/SFT. ## Deprecation, Removal, Backward Incompatibilities. - The ""Virtual MonteCarlo"" facility VMC (`montecarlo/vmc`) has been removed from ROOT. The development of this package has moved to a [separate project](https://github.com/vmc-project/). ROOT's copy of VMC was deprecated since v6.18.; - `TTreeProcessorMT::SetMaxTasksPerFilePerWorker` has been removed. `TTreeProcessorMT::SetTasksPerWorkerHint` is a superior alternative.; - `TTree::GetEntry()` and `TTree::GetEvent()` no longer have 0 as the default value for the first parameter `entry`. We are not aware of correct uses of this function without providing an entry number. If you have one, please simply pass `0` from now on.; - `TBufferMerger` is now out of the `Experimental` namespace (`ROOT::Experimental::TBufferMerger` is deprecated, please use `ROOT::TBufferMerger` instead); - RooFit container classes marked as deprecated with this release: `RooHashTable`, `RooNameSet`, `RooSetPair`, and `RooList`. These classes are still available in this release, but will be removed in the next one. Please migrate to STL container classes, such as `std::unordered_map`, `std::set`, and `std::vector`.; - The `RooFit::FitOptions(const char*)` command to steer [RooAbsPdf::fitTo()](https://root.cern.ch/doc/v628/classRooAbsPdf.html) with an option string in now deprecated and will be removed in ROOT v6.28. Please migrate to the RooCmdArg-based fit configuration. The former character flags map to RooFit command arguments as follows:; - `'h'` : RooFit::Hesse(); - `'m'` : RooFit::Minos(); - `'o'` : RooFit::Optimize(1); - `'r'` : RooFit::Save(); - `'t'` : RooFit::Timer(); - `'v'` : RooFit::Verbose();",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md:2303,simpl,simply,2303,README/ReleaseNotes/v626/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md,1,['simpl'],['simply']
Usability,"Focus()` - returns `kTRUE` if the flag `kWidgetWantFocus` is; set. ### TGWindow. **`TGWindow`** is a ROOT GUI window base class. It inherits from; **`TGObject`** and **`TGFrame`** derives from it. The application does; not use it directly. It creates and registers a new window within the; system. This window has common characteristics: existing parent,; location, size in height and width (it has a default minimum size 1, 1; under which it cannot shrink), border with particular view, state,; specific attributes. If there are no specified arguments their values; will be taken from the parent. It receives events from the window system; and can paint a representation of itself on the screen. ![](pictures/02000205.jpg). ### Frames. Most of the frame classes are mainly created for arranging widgets in a; window. The class **`TGFrame`** is a subclass of **`TGWindow`**; providing additional window characteristics and overriding some methods; of **`TGWindow`**. It is a base class for the simple widgets as buttons,; labels, etc. Its only purpose is to draw a frame around widgets that do; not have a frame of their own. The main groups of **`TGFrame`** member; functions are:. - Window's functions: `DoRedraw()`, `DeleteWindow()`, `Activate()`,; etc. - Geometry functions: `Move()`, `Resize()`, `SetSize()`, etc. - Graphics handlers: `ChangeBackground()`, `ChangeOptions()`, etc. - Mouse and keyboard functions: `HandleButton()`,; `HandleFocusChange()`, `HandleKey()`, `HandleMotion()`, etc. - Event handlers: `HandleEvent()`, `ProcessEvent()`, `GetSender()`,; `SendMessage()`,` ProcessMessage()`, `GetLastClick()`, etc. ![The GUI classes hierarchy](pictures/02000206.jpg). Ones of **`TGFrame`** member functions provide direct functionality;; others - will be overridden by **`TGFrame`** subclasses to ensure; particular widget's functionality. There are two constructors provided; in **`TGFrame`** class. One creates a frame using an externally created; window:. ``` {.cpp}; TGFrame(TGClient ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:24516,simpl,simple,24516,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,1,['simpl'],['simple']
Usability,"From: Chris Lattner <sabre@nondot.org>; To: ""Vikram S. Adve"" <vadve@cs.uiuc.edu>; Subject: Re: LLVM Feedback. I've included your feedback in the /home/vadve/lattner/llvm/docs directory; so that it will live in CVS eventually with the rest of LLVM. I've; significantly updated the documentation to reflect the changes you; suggested, as specified below:. > We should consider eliminating the type annotation in cases where it is; > essentially obvious from the instruction type:; > br bool <cond>, label <iftrue>, label <iffalse>; > I think your point was that making all types explicit improves clarity; > and readability. I agree to some extent, but it also comes at the; > cost of verbosity. And when the types are obvious from people's; > experience (e.g., in the br instruction), it doesn't seem to help as; > much. Very true. We should discuss this more, but my reasoning is more of a; consistency argument. There are VERY few instructions that can have all; of the types eliminated, and doing so when available unnecessarily makes; the language more difficult to handle. Especially when you see 'int; %this' and 'bool %that' all over the place, I think it would be; disorienting to see:. br %predicate, %iftrue, %iffalse. for branches. Even just typing that once gives me the creeps. ;) Like I; said, we should probably discuss this further in person... > On reflection, I really like your idea of having the two different; > switch types (even though they encode implementation techniques rather; > than semantics). It should simplify building the CFG and my guess is it; > could enable some significant optimizations, though we should think; > about which. Great. I added a note to the switch section commenting on how the VM; should just use the instruction type as a hint, and that the; implementation may choose altermate representations (such as predicated; branches). > In the lookup-indirect form of the switch, is there a reason not to; > make the val-type uint?. No. This was something",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-09-AdveCommentsResponse.txt:100,Feedback,Feedback,100,interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-09-AdveCommentsResponse.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-09-AdveCommentsResponse.txt,2,"['Feedback', 'feedback']","['Feedback', 'feedback']"
Usability,"Fuzzer; =========. :doc:`LibFuzzer`; A library for writing in-process guided fuzzers. :doc:`FuzzingLLVM`; Information on writing and using Fuzzers to find bugs in LLVM. ========; LLVM IR; ========. :doc:`LLVM Language Reference Manual <LangRef>`; Defines the LLVM intermediate representation and the assembly form of the; different nodes. :doc:`InAlloca`; Description of the ``inalloca`` argument attribute. :doc:`BitCodeFormat`; This describes the file format and encoding used for LLVM ""bc"" files. :doc:`Machine IR (MIR) Format Reference Manual <MIRLangRef>`; A reference manual for the MIR serialization format, which is used to test; LLVM's code generation passes. :doc:`GlobalISel/index`; This describes the prototype instruction selection replacement, GlobalISel. :doc:`ConvergentOperations`; Description of ``convergent`` operation semantics and related intrinsics. =====================; Testing and Debugging; =====================. :doc:`LLVM Testing Infrastructure Guide <TestingGuide>`; A reference manual for using the LLVM testing infrastructure. :doc:`TestSuiteGuide`; Describes how to compile and run the test-suite benchmarks. :doc:`GwpAsan`; A sampled heap memory error detection toolkit designed for production use. ====; XRay; ====. :doc:`XRay`; High-level documentation of how to use XRay in LLVM. :doc:`XRayExample`; An example of how to debug an application with XRay. =================; Additional Topics; =================. :doc:`FaultMaps`; LLVM support for folding control flow into faulting machine instructions. :doc:`Atomics`; Information about LLVM's concurrency model. :doc:`ExceptionHandling`; This document describes the design and implementation of exception handling; in LLVM. :doc:`Extensions`; LLVM-specific extensions to tools and formats LLVM seeks compatibility with. :doc:`HowToSetUpLLVMStyleRTTI`; How to make ``isa<>``, ``dyn_cast<>``, etc. available for clients of your; class hierarchy. :doc:`BlockFrequencyTerminology`; Provides information about termino",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Reference.rst:2999,Guid,Guide,2999,interpreter/llvm-project/llvm/docs/Reference.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Reference.rst,1,['Guid'],['Guide']
Usability,"GUI fully cross-platform. Originally the GUI; classes were based on Hector Peraza's Xclass'95 widget library; <http://xclass.sourceforge.net/>. ## The ROOT GUI Classes. Features of the GUI classes in a nutshell:. - Originally based on the Xclass'95 widget library. - A rich and complete set of widgets. - Win'95 look and feel. - All machine dependent graphics calls abstracted via the; **`TVirtualX`** ""abstract"" class. - Completely scriptable via the C++ interpreter (fast prototyping). - Supports signal/slot event handling as pioneered by Trolltech's Qt. - Full class documentation is generated automatically (as for all ROOT; classes). - Code generation for variety of GUI's. ## Widgets and Frames. The ROOT GUI classes provide of set of components that allow an easy way; to develop cross-platform GUI applications with a Windows look and feel. The main widgets are:. - Simple widgets: labels, icons, push buttons, either with text or; pixmaps, check buttons, radio buttons, menu bars and popup menus,; scroll bars, list boxes, combo boxes, group frames, text entry; widgets, tab widgets, progress bars, sliders, tool tips. - Complex widgets: shutter, toolbar, status bar, list view, list tree. - Common dialogs: File Open/Save, File Properties, Font Selection,; Color Selection, About. - The widgets are shown in frames:. - frame, composite frame, main frame, transient frame, group frame. - Arranged by layout managers:. - horizontal layout, vertical layout, row layout, list layout, tile; layout, matrix layout. Using a combination of layout hints:. - left, right, center x, center y, top, bottom, expand x, expand y,; fixed offsets. Event handling by signals/slots and messaging (as opposed to callbacks):. - in response to actions widgets send messages and emit signals. - associated frames process these messages or the slot methods; connected to the signals are executed. ## TVirtualX. The GUI classes interface to the platform dependent low level graphics; system via the semi-abstract g",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:1250,Simpl,Simple,1250,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,2,"['Simpl', 'progress bar']","['Simple', 'progress bars']"
Usability,"Getting Started/Tutorials; =========================. For those new to the LLVM system. .. toctree::; :hidden:. CompilerWriterInfo; Frontend/PerformanceTips; GettingStarted; GettingStartedVS; ProgrammersManual; tutorial/index; MyFirstTypoFix. :doc:`GettingStarted`; Discusses how to get up and running quickly with the LLVM infrastructure.; Everything from unpacking and compilation of the distribution to execution; of some tools. :doc:`tutorial/index`; Tutorials about using LLVM. Includes a tutorial about making a custom; language with LLVM. :doc:`ProgrammersManual`; Introduction to the general layout of the LLVM sourcebase, important classes; and APIs, and some tips & tricks. :doc:`Frontend/PerformanceTips`; A collection of tips for frontend authors on how to generate IR; which LLVM is able to effectively optimize. :doc:`GettingStartedVS`; An addendum to the main Getting Started guide for those using Visual Studio; on Windows. :doc:`CompilerWriterInfo`; A list of helpful links for compiler writers. :doc:`MyFirstTypoFix`; This tutorial will guide you through the process of making a change to; LLVM, and contributing it back to the LLVM project.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStartedTutorials.rst:891,guid,guide,891,interpreter/llvm-project/llvm/docs/GettingStartedTutorials.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStartedTutorials.rst,2,['guid'],['guide']
Usability,"Git:. - ""The 'branch' I most care about is mainline, and losing the ability to say; 'fixed in r1234' (with some sort of monotonically increasing number) would; be a tragic loss."" [LattnerRevNum]_; - ""I like those results sorted by time and the chronology should be obvious, but; timestamps are incredibly cumbersome and make it difficult to verify that a; given checkout matches a given set of results."" [TrickRevNum]_; - ""There is still the major regression with unreadable version numbers.; Given the amount of Bugzilla traffic with 'Fixed in...', that's a; non-trivial issue."" [JSonnRevNum]_; - ""Sequential IDs are important for LNT and llvmlab bisection tool."" [MatthewsRevNum]_. However, Git can emulate this increasing revision number:; ``git rev-list --count <commit-hash>``. This identifier is unique only; within a single branch, but this means the tuple `(num, branch-name)` uniquely; identifies a commit. We can thus use this revision number to ensure that e.g. `clang -v` reports a; user-friendly revision number (e.g. `main-12345` or `4.0-5321`), addressing; the objections raised above with respect to this aspect of Git. What About Branches and Merges?; -------------------------------. In contrast to SVN, Git makes branching easy. Git's commit history is; represented as a DAG, a departure from SVN's linear history. However, we propose; to mandate making merge commits illegal in our canonical Git repository. Unfortunately, GitHub does not support server side hooks to enforce such a; policy. We must rely on the community to avoid pushing merge commits. GitHub offers a feature called `Status Checks`: a branch protected by; `status checks` requires commits to be explicitly allowed before the push can happen.; We could supply a pre-push hook on the client side that would run and check the; history, before allowing the commit being pushed [statuschecks]_.; However this solution would be somewhat fragile (how do you update a script; installed on every developer machine?) and ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst:5367,user-friendly,user-friendly,5367,interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,1,['user-friendly'],['user-friendly']
Usability,"Html`*** object, ***`gMinuit`***; objects, and the array of contours graphs (**`TGraph`**) created when; calling the `Draw` method of a histogram with the `""CONT`, `LIST""`; option. ### Access to the Collection Contents. The current content for a collection listed above can be accessed with; the corresponding `gROOT->GetListOf` method (for example; `gROOT->GetListOfCanvases`). In addition, `gROOT->GetListOfBrowsables`; returns a collection of all objects visible on the left side panel in; the browser. See the image of the Object Browser in the next figure. ![The ROOT Object Browser](pictures/03000094.png). ## Ownership by Other Objects. When an object creates another, the creating object is the owner of the; created one. For example:. ``` {.cpp}; myHisto->Fit(""gaus""); ```. The call to Fit copies the global **`TF1`** Gaussian function and; attaches the copy to the histogram. When the histogram is deleted, the; copy is deleted also. When a pad is deleted or cleared, all objects in the pad with the; `kCanDelete` bit set are deleted automatically. Currently the objects; created by the `DrawCopy` methods, have the `kCanDelete` bit set and; are therefore owned by the pad. ## Ownership by the User. The user owns all objects not described in one of the above cases.; **`TObject`** has two bits, `kCanDelete` and `kMustCleanup`, that; influence how an object is managed (in `TObject::fBits)`. These are in; an enumeration in `TObject.h.` To set these bits do:. ``` {.cpp}; MyObject->SetBit(kCanDelete); MyObject->SetBit(kMustCleanup); ```. The bits can be reset and tested with the `TObject::ResetBit` and; **`TObject::TestBit` methods.**. ### The kCanDelete Bit. The ***`gROOT`*** collections (see above) own their members and will; delete them regardless of the `kCanDelete` bit. In all other; collections, when the collection `Clear` method is called (i.e.; **`TList::Clear())`**, members with the `kCanDelete` bit set, are; deleted and removed from the collection. If the `kCanDelete` bi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ObjectOwnership.md:4943,clear,cleared,4943,documentation/users-guide/ObjectOwnership.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ObjectOwnership.md,1,['clear'],['cleared']
Usability,"I; might let you click on typedefs to expand them. This application would want to; pass significantly more information about types through to the GUI than a; simple flat string. The interface allows this to happen. .. _internals-diag-translation:. Adding Translations to Clang; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Not possible yet! Diagnostic strings should be written in UTF-8, the client can; translate to the relevant code page if needed. Each translation completely; replaces the format string for the diagnostic. .. _SourceLocation:; .. _SourceManager:. The ``SourceLocation`` and ``SourceManager`` classes; ----------------------------------------------------. Strangely enough, the ``SourceLocation`` class represents a location within the; source code of the program. Important design points include:. #. ``sizeof(SourceLocation)`` must be extremely small, as these are embedded; into many AST nodes and are passed around often. Currently it is 32 bits.; #. ``SourceLocation`` must be a simple value object that can be efficiently; copied.; #. We should be able to represent a source location for any byte of any input; file. This includes in the middle of tokens, in whitespace, in trigraphs,; etc.; #. A ``SourceLocation`` must encode the current ``#include`` stack that was; active when the location was processed. For example, if the location; corresponds to a token, it should contain the set of ``#include``\ s active; when the token was lexed. This allows us to print the ``#include`` stack; for a diagnostic.; #. ``SourceLocation`` must be able to describe macro expansions, capturing both; the ultimate instantiation point and the source of the original character; data. In practice, the ``SourceLocation`` works together with the ``SourceManager``; class to encode two pieces of information about a location: its spelling; location and its expansion location. For most tokens, these will be the; same. However, for a macro expansion (or tokens that came from a ``_Pragma``; directive) the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:23506,simpl,simple,23506,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['simpl'],['simple']
Usability,"IRgen optimization opportunities. //===---------------------------------------------------------------------===//. The common pattern of; --; short x; // or char, etc; (x == 10); --; generates an zext/sext of x which can easily be avoided. //===---------------------------------------------------------------------===//. Bitfields accesses can be shifted to simplify masking and sign; extension. For example, if the bitfield width is 8 and it is; appropriately aligned then is is a lot shorter to just load the char; directly. //===---------------------------------------------------------------------===//. It may be worth avoiding creation of alloca's for formal arguments; for the common situation where the argument is never written to or has; its address taken. The idea would be to begin generating code by using; the argument directly and if its address is taken or it is stored to; then generate the alloca and patch up the existing code. In theory, the same optimization could be a win for block local; variables as long as the declaration dominates all statements in the; block. NOTE: The main case we care about this for is for -O0 -g compile time; performance, and in that scenario we will need to emit the alloca; anyway currently to emit proper debug info. So this is blocked by; being able to emit debug information which refers to an LLVM; temporary, not an alloca. //===---------------------------------------------------------------------===//. We should try and avoid generating basic blocks which only contain; jumps. At -O0, this penalizes us all the way from IRgen (malloc &; instruction overhead), all the way down through code generation and; assembly time. On 176.gcc:expr.ll, it looks like over 12% of basic blocks are just; direct branches!. //===---------------------------------------------------------------------===//; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/README.txt:358,simpl,simplify,358,interpreter/llvm-project/clang/lib/CodeGen/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/README.txt,1,['simpl'],['simplify']
Usability,"I`` to; ``rootcling``/``genreflex`` during build time).; When relocating the shared library, move the .pcm with it.; Once support for C++ modules is fully fleshed out, access to the header file; will no longer be needed. .. _`rootcling manual`: https://root.cern.ch/root/html/guides/users-guide/AddingaClass.html#the-linkdef.h-file; .. _`helper script`: https://github.com/wlav/cppyy/blob/master/test/make_dict_win32.py. Class loader; ^^^^^^^^^^^^. Explicitly loading dictionaries is fine if this is hidden under the hood of; a Python package and thus transparently done on ``import``.; Otherwise, the automatic class loader is more convenient, as it allows direct; use without having to manually find and load dictionaries (assuming these are; locatable by the dynamic loader). The class loader utilizes so-called rootmap files, which by convention should; live alongside the dictionary shared library (and C++ module file).; These are simple text files, which map C++ entities (such as classes) to the; dictionaries and other libraries that need to be loaded for their use. With ``genreflex``, the mapping file can be automatically created with; ``--rootmap-lib=MyClassDict``, where ""MyClassDict"" is the name of the shared; library (without the extension) build from the dictionary file.; With ``rootcling``, create the same mapping file with; ``-rmf MyClassDict.rootmap -rml MyClassDict``.; It is necessary to provide the final library name explicitly, since it is; only in the separate linking step where these names are fixed and those names; may not match the default choice. With the mapping file in place, the above example can be rerun without; explicit loading of the dictionary:. .. code-block:: python. >>> import cppyy; >>> from cppyy.gbl import MyClass; >>> MyClass(42).get_int(); 42; >>>. .. _cppyy-generator:. Bindings collection; -------------------. ``cppyy-generator`` is a clang-based utility program which takes a set of C++; header files and generates a JSON output file describ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/utilities.rst:8669,simpl,simple,8669,bindings/pyroot/cppyy/cppyy/doc/source/utilities.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/utilities.rst,1,['simpl'],['simple']
Usability,"If none is available, the; default implementation is created for the pass to use. All standard rules for; :ref:`interaction between passes <writing-an-llvm-pass-interaction>` still; apply. Although :ref:`Pass Registration <writing-an-llvm-pass-registration>` is; optional for normal passes, all analysis group implementations must be; registered, and must use the :ref:`INITIALIZE_AG_PASS; <writing-an-llvm-pass-RegisterAnalysisGroup>` template to join the; implementation pool. Also, a default implementation of the interface **must**; be registered with :ref:`RegisterAnalysisGroup; <writing-an-llvm-pass-RegisterAnalysisGroup>`. As a concrete example of an Analysis Group in action, consider the; `AliasAnalysis <https://llvm.org/doxygen/classllvm_1_1AliasAnalysis.html>`_; analysis group. The default implementation of the alias analysis interface; (the `basic-aa <https://llvm.org/doxygen/structBasicAliasAnalysis.html>`_ pass); just does a few simple checks that don't require significant analysis to; compute (such as: two different globals can never alias each other, etc).; Passes that use the `AliasAnalysis; <https://llvm.org/doxygen/classllvm_1_1AliasAnalysis.html>`_ interface (for; example the `gvn <https://llvm.org/doxygen/classllvm_1_1GVN.html>`_ pass), do not; care which implementation of alias analysis is actually provided, they just use; the designated interface. From the user's perspective, commands work just like normal. Issuing the; command ``opt -gvn ...`` will cause the ``basic-aa`` class to be instantiated; and added to the pass sequence. Issuing the command ``opt -somefancyaa -gvn; ...`` will cause the ``gvn`` pass to use the ``somefancyaa`` alias analysis; (which doesn't actually exist, it's just a hypothetical example) instead. .. _writing-an-llvm-pass-RegisterAnalysisGroup:. Using ``RegisterAnalysisGroup``; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``RegisterAnalysisGroup`` template is used to register the analysis group; itself, while the ``INITIALIZE_AG_PASS`",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst:37299,simpl,simple,37299,interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,1,['simpl'],['simple']
Usability,"If you have commit access, there are multiple workflows to commit the; change. Whichever method you follow it is recommended that your commit message; ends with the line:. ::. Differential Revision: <URL>. where ``<URL>`` is the URL for the code review, starting with; ``https://reviews.llvm.org/``. This allows people reading the version history to see the review for; context. This also allows Phabricator to detect the commit, close the; review, and add a link from the review to the commit. Note that if you use the Arcanist tool the ``Differential Revision`` line will; be added automatically. If you don't want to use Arcanist, you can add the; ``Differential Revision`` line (as the last line) to the commit message; yourself. Using the Arcanist tool can simplify the process of committing reviewed code as; it will retrieve reviewers, the ``Differential Revision``, etc from the review; and place it in the commit message. You may also commit an accepted change; directly using ``git push``, per the section in the :ref:`getting started; guide <commit_from_git>`. Note that if you commit the change without using Arcanist and forget to add the; ``Differential Revision`` line to your commit message then it is recommended; that you close the review manually. In the web UI, under ""Leap Into Action"" put; the git revision number in the Comment, set the Action to ""Close Revision"" and; click Submit. Note the review must have been Accepted first. Committing someone's change from Phabricator; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. On a clean Git repository on an up to date ``main`` branch run the; following (where ``<Revision>`` is the Phabricator review number):. ::. arc patch D<Revision>. This will create a new branch called ``arcpatch-D<Revision>`` based on the; current ``main`` and will create a commit corresponding to ``D<Revision>`` with a; commit message derived from information in the Phabricator review. Check you are happy with the commit message and amend it if necessa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst:14546,guid,guide,14546,interpreter/llvm-project/llvm/docs/Phabricator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst,1,['guid'],['guide']
Usability,"ImageN), /*ImageEnd*/; __start_omp_offloading_entries, /*EntriesBegin*/; __stop_omp_offloading_entries /*EntriesEnd*/; }; };; static const __tgt_bin_desc BinDesc = {; sizeof(Images) / sizeof(Images[0]), /*NumDeviceImages*/; Images, /*DeviceImages*/; __start_omp_offloading_entries, /*HostEntriesBegin*/; __stop_omp_offloading_entries /*HostEntriesEnd*/; };. Global Constructor and Destructor; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The global constructor (``.omp_offloading.descriptor_reg()``) registers the; device images with the runtime by calling the ``__tgt_register_lib()`` runtime; function. The constructor is explicitly defined in ``.text.startup`` section and; is run once when the program starts. Similarly, the global destructor; (``.omp_offloading.descriptor_unreg()``) calls ``__tgt_unregister_lib()`` for; the destructor and is also defined in ``.text.startup`` section and run when the; program exits. Offloading Example; ------------------. This section contains a simple example of generating offloading code using; OpenMP offloading. We will use a simple ``ZAXPY`` BLAS routine. .. code-block:: c++. #include <complex>. using complex = std::complex<double>;. void zaxpy(complex *X, complex *Y, complex D, std::size_t N) {; #pragma omp target teams distribute parallel for; for (std::size_t i = 0; i < N; ++i); Y[i] = D * X[i] + Y[i];; }. int main() {; const std::size_t N = 1024;; complex X[N], Y[N], D;; #pragma omp target data map(to:X[0 : N]) map(tofrom:Y[0 : N]); zaxpy(X, Y, D, N);; }. This code is compiled using the following Clang flags. .. code-block:: console. $ clang++ -fopenmp -fopenmp-targets=nvptx64 -O3 zaxpy.cpp -c. The output section in the object file can be seen using the ``readelf`` utility.; The ``.llvm.offloading`` section has the ``SHF_EXCLUDE`` flag so it will be; removed from the final executable or shared library by the linker. .. code-block:: text. $ llvm-readelf -WS zaxpy.o; Section Headers:; [Nr] Name Type Address Off Size ES Flg Lk Inf Al; [11] omp_",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OffloadingDesign.rst:21753,simpl,simple,21753,interpreter/llvm-project/clang/docs/OffloadingDesign.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OffloadingDesign.rst,1,['simpl'],['simple']
Usability,"Inlining; ========. There are several options that control which calls the analyzer will consider for; inlining. The major one is ``-analyzer-config ipa``:. * ``analyzer-config ipa=none`` - All inlining is disabled. This is the only mode; available in LLVM 3.1 and earlier and in Xcode 4.3 and earlier. * ``analyzer-config ipa=basic-inlining`` - Turns on inlining for C functions, C++; static member functions, and blocks -- essentially, the calls that behave; like simple C function calls. This is essentially the mode used in; Xcode 4.4. * ``analyzer-config ipa=inlining`` - Turns on inlining when we can confidently find; the function/method body corresponding to the call. (C functions, static; functions, devirtualized C++ methods, Objective-C class methods, Objective-C; instance methods when ExprEngine is confident about the dynamic type of the; instance). * ``analyzer-config ipa=dynamic`` - Inline instance methods for which the type is; determined at runtime and we are not 100% sure that our type info is; correct. For virtual calls, inline the most plausible definition. * ``analyzer-config ipa=dynamic-bifurcate`` - Same as -analyzer-config ipa=dynamic,; but the path is split. We inline on one branch and do not inline on the; other. This mode does not drop the coverage in cases when the parent class; has code that is only exercised when some of its methods are overridden. Currently, ``-analyzer-config ipa=dynamic-bifurcate`` is the default mode. While ``-analyzer-config ipa`` determines in general how aggressively the analyzer; will try to inline functions, several additional options control which types of; functions can inlined, in an all-or-nothing way. These options use the; analyzer's configuration table, so they are all specified as follows:. ``-analyzer-config OPTION=VALUE``. c++-inlining; ------------. This option controls which C++ member functions may be inlined. ``-analyzer-config c++-inlining=[none | methods | constructors | destructors]``. Each of these modes",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst:466,simpl,simple,466,interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst,1,['simpl'],['simple']
Usability,"Inspect' menu title to 'Tools'; Added 'Event Recorder' menu entry. Here is a screenshot of TGRecorder (GUI interface of the recorder):. New Class: TGPack; New Container class for vertical and horizontal grouping of frames.; It enforces a predictable resizing behaviour on children.; For an example of how to use it, see tutorials/eve/pack.C. TRootBrowser. Make the default url for the HTML plugin of TRootBrowser configurable via rootrc. TGTab. Added a 'Close Tab' icon in TGTabElement, allowing to close a tab element, and emitting a CloseTab(Int_t id) signal. The icon is active only on the actually activated tab.; Implement CloseTab slot usage in TRootBrowser and in TGRootIDE. TGTextEditor. Allow to execute a macro without having to save it first. TGSplitFrame. Added a new signal method Docked(TGFrame*) to notify when a embedded frame has been docked.; Added a new signal method Undocked(TGFrame*) to notify when a embedded frame has been undocked.; Added a new getter method GetUndocked() returning a pointer on undocked frame, if any. TGToolTip. Added new constructor with global x, y position.; If neither fWindow nor fPad are set use global fX, fY that was passed from outside. TGSplitter. Added option to handle frame resizing externally. TGView. Added a protection against possible negative scroll values. TGTextView. Fix bottom line not being properly updated while scrolling.; Solve a problem with vertical slider (avoid negative value when scrolling). TGTextEdit. Fix blinking cursor on some platforms/compilers. TGTextEntry. Added optional parameter 'Bool_t emit' to TGTextEntry::SetText(const char* text, Bool_t emit = kTRUE);; Made the same extension in sub-class TGNumberEntryField. TGCompositeFrame. Added new method virtual TGFrameElement* FindFrameElement(TGFrame *f) const; and use it in several TGCompositeFrame methods to simplify the code. GUIHTML; TGHtml. Implemented HTML <select> with TGListBox/TGCombobox and emit InputSelected(const char *name, const char *val) when ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/doc/v522/index.html:1422,undo,undocked,1422,gui/doc/v522/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/doc/v522/index.html,1,['undo'],['undocked']
Usability,"Interactivity in C++ with Cling; -------------------------------. **Interactive programming** is a programming approach that allows developers to; change and modify the program as it runs. The final result is a program that; actively responds to a developers’ intuitions, allowing them to make changes in; their code, and to see the result of these changes without interrupting the; running program. Interactive programming gives programmers the freedom to; explore different scenarios while developing software, writing one expression; at a time, figuring out what to do next at each step, and enabling them to; quickly identify and fix bugs whenever they arise. As an example, the; High-Energy Physics community includes professionals with a variety of; backgrounds, including physicists, nuclear engineers, and software; engineers. Cling allows for interactive data analysis in `ROOT; <https://root.cern/>`_ by giving researchers a way to prototype their C++ code,; allowing them to tailor it to the particular scope of the analysis they want to; pursue on a particular set of data before being added to the main framework. **Interpreted language** is a way to achieve interactive programming. In; statically compiled language, all source code is converted into native machine; code and then executed by the processor before being run. An interpreted; language instead runs through source programs line by line, taking an; executable segment of source code, turning it into machine code, and then; executing it. With this approach, when a change is made by the programmer, the; interpreter will convey it without the need for the entire source code to be; manually compiled. Interpreted languages are flexible, and offer features like; dynamic typing and smaller program size. **Cling** is not an interpreter, it is a Just-In-Time (JIT) compiler that feels; like an interpreter, and allows C++, a language designed to be compiled, to be; interpreted. When using Cling, the programmer benefits from ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/docs/chapters/interactivity.rst:260,intuit,intuitions,260,interpreter/cling/docs/chapters/interactivity.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/docs/chapters/interactivity.rst,1,['intuit'],['intuitions']
Usability,"It should also have a defined character as its unique access key. The; second parameter is the popup menu we would like to add. The third one; is an object of **`TGLayoutHints`** type that defines how the menu title; will be laid out in the menu bar. In our example the *`File`* and `Test`; menus will be laid out to the left of the menu bar with 4 pixels; distance in between, the `Help` menu - will be laid out to the right. The menu classes provide a very flexible menu system: you can enable,; disable, add or remove menu items dynamically. The method; `HideEntry(menuID)` hides the menu entry (the entry will not be shown in; the popup menu). To enable a hidden entry you should call; `EnableEntry(menuID)` method. By default all entries are enabled. The; method `DisableEntry(menuID)` helps you to disable a menu entry - it; will appear in sunken relieve. The `DeleteEntry(menuID)` method will; delete the specified entry from the menu. A few words about the menu design. A menu should be kept consistent and; simple. All related items need to be in a popup menu. The cascade menus; should be used judiciously. Try to limit them to one, maximum two; levels. There are some rules for naming the menu objects:. - Define unique names within a menu. - Use capitalized one-word names allowing the quick scan of the menu. - Define unique access key for any menu item. - Indicate by ellipsis (...) after the title with no space when a menu; item will pop-up a dialog box. The proper kind of graphical menus is a critical point to every; application success and depends of three main factors:. - number of presented items in the menu. - how often the menu is used. - how often the menu contents may change. ### Toolbar. ![](pictures/03000217.png). A toolbar (**`TGToolBar`**) is a composite frame that contains; **`TGPictureButton `**objects. It provides an easy and fast access to; most frequently used commands or options across multiple application; screens. Also, it invokes easily a sub applicatio",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:73432,simpl,simple,73432,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,1,['simpl'],['simple']
Usability,"Itanium Name Demangler Library; ==============================. Introduction; ------------. This directory contains the generic itanium name demangler; library. The main purpose of the library is to demangle C++ symbols,; i.e. convert the string ""_Z1fv"" into ""f()"". You can also use the CRTP; base ManglingParser to perform some simple analysis on the mangled; name, or (in LLVM) use the opaque ItaniumPartialDemangler to query the; demangled AST. Why are there multiple copies of the this library in the source tree?; ---------------------------------------------------------------------. The canonical sources are in libcxxabi/src/demangle and some of the; files are copied to llvm/include/llvm/Demangle. The simple reason for; this comes from before the monorepo, and both [sub]projects need to; demangle symbols, but neither can depend on each other. * libcxxabi needs the demangler to implement __cxa_demangle, which is; part of the itanium ABI spec. * LLVM needs a copy for a bunch of places, and cannot rely on the; system's __cxa_demangle because it a) might not be available (i.e.,; on Windows), and b) may not be up-to-date on the latest language; features. The copy of the demangler in LLVM has some extra stuff that aren't; needed in libcxxabi (ie, the MSVC demangler, ItaniumPartialDemangler),; which depend on the shared generic components. Despite these; differences, we want to keep the ""core"" generic demangling library; identical between both copies to simplify development and testing. If you're working on the generic library, then do the work first in; libcxxabi, then run libcxxabi/src/demangle/cp-to-llvm.sh. This; script takes as an optional argument the path to llvm, and copies the; changes you made to libcxxabi over. Note that this script just; blindly overwrites all changes to the generic library in llvm, so be; careful. Because the core demangler needs to work in libcxxabi, everything; needs to be declared in an anonymous namespace (see; DEMANGLE_NAMESPACE_BEGIN), an",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Demangle/README.txt:329,simpl,simple,329,interpreter/llvm-project/llvm/include/llvm/Demangle/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Demangle/README.txt,2,['simpl'],['simple']
Usability,"Just like physical; security keys, a thread cannot make copy of a capability, nor can it destroy; one. A thread can only release a capability to another thread, or acquire one; from another thread. The annotations are deliberately agnostic about the; exact mechanism used to acquire and release capabilities; it assumes that the; underlying implementation (e.g. the Mutex implementation) does the handoff in; an appropriate manner. The set of capabilities that are actually held by a given thread at a given; point in program execution is a run-time concept. The static analysis works; by calculating an approximation of that set, called the *capability; environment*. The capability environment is calculated for every program point,; and describes the set of capabilities that are statically known to be held, or; not held, at that particular point. This environment is a conservative; approximation of the full set of capabilities that will actually held by a; thread at run-time. Reference Guide; ===============. The thread safety analysis uses attributes to declare threading constraints.; Attributes must be attached to named declarations, such as classes, methods,; and data members. Users are *strongly advised* to define macros for the various; attributes; example definitions can be found in :ref:`mutexheader`, below.; The following documentation assumes the use of macros. The attributes only control assumptions made by thread safety analysis and the; warnings it issues. They don't affect generated code or behavior at run-time. For historical reasons, prior versions of thread safety used macro names that; were very lock-centric. These macros have since been renamed to fit a more; general capability model. The prior names are still in use, and will be; mentioned under the tag *previously* where appropriate. GUARDED_BY(c) and PT_GUARDED_BY(c); ----------------------------------. ``GUARDED_BY`` is an attribute on data members, which declares that the data; member is protected by",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:5908,Guid,Guide,5908,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,1,['Guid'],['Guide']
Usability,"K:10000000""); set_property(TARGET dataframe_interface APPEND_STRING PROPERTY LINK_FLAGS "" -STACK:10000000""); endif(). ROOT_ADD_GTEST(dataframe_splitcoll_arrayview dataframe_splitcoll_arrayview.cxx LIBRARIES ROOTDataFrame); target_include_directories(dataframe_splitcoll_arrayview PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}); ROOT_GENERATE_DICTIONARY(TwoFloatsDict ${CMAKE_CURRENT_SOURCE_DIR}/TwoFloats.h MODULE dataframe_splitcoll_arrayview LINKDEF TwoFloatsLinkDef.h OPTIONS -inlineInputHeader DEPENDENCIES RIO). ROOT_ADD_GTEST(dataframe_redefine dataframe_redefine.cxx LIBRARIES ROOTDataFrame); ROOT_ADD_GTEST(dataframe_definepersample dataframe_definepersample.cxx LIBRARIES ROOTDataFrame). if(NOT MSVC OR win_broken_tests); ROOT_ADD_GTEST(dataframe_simple dataframe_simple.cxx LIBRARIES ROOTDataFrame GenVector); target_include_directories(dataframe_simple PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}); ROOT_GENERATE_DICTIONARY(DataFrameSimpleDict ${CMAKE_CURRENT_SOURCE_DIR}/MaxSlotHelper.h ${CMAKE_CURRENT_SOURCE_DIR}/SimpleFiller.h MODULE dataframe_simple; LINKDEF DataFrameSimpleLinkDef.h OPTIONS -inlineInputHeader DEPENDENCIES ROOTDataFrame Hist); endif(); ROOT_ADD_GTEST(dataframe_vecops dataframe_vecops.cxx LIBRARIES ROOTDataFrame); ROOT_ADD_GTEST(dataframe_helpers dataframe_helpers.cxx LIBRARIES ROOTDataFrame); if(MSVC); set_source_files_properties(dataframe_helpers.cxx PROPERTIES COMPILE_FLAGS /bigobj); set_source_files_properties(dataframe_cache.cxx PROPERTIES COMPILE_FLAGS /bigobj); endif(). if(NOT (MSVC OR (APPLE AND CMAKE_SYSTEM_PROCESSOR MATCHES arm64)) OR win_broken_tests OR M1_BROKEN_TESTS); ROOT_ADD_GTEST(dataframe_snapshot dataframe_snapshot.cxx LIBRARIES ROOTDataFrame); endif(). ROOT_ADD_GTEST(dataframe_datasetspec dataframe_datasetspec.cxx LIBRARIES ROOTDataFrame); if(builtin_nlohmannjson); target_include_directories(dataframe_datasetspec PRIVATE ${CMAKE_SOURCE_DIR}/builtins); else(); target_link_libraries(dataframe_datasetspec nlohmann_json::nlohmann_json); endif(). ROOT_ADD",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/CMakeLists.txt:2385,Simpl,SimpleFiller,2385,tree/dataframe/test/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/CMakeLists.txt,1,['Simpl'],['SimpleFiller']
Usability,"Known Bits Analysis; ===================. The Known Bits Analysis pass makes information about the known values of bits; available to other passes to enable transformations like those in the examples; below. The information is lazily computed so you should only pay for what you; use. Examples; --------. A simple example is that transforming::. a + 1. into::. a | 1. is only valid when the addition doesn't carry. In other words it's only valid; if ``a & 1`` is zero. Another example is:. .. code-block:: none. %1:(s32) = G_CONSTANT i32 0xFF0; %2:(s32) = G_AND %0, %1; %3:(s32) = G_CONSTANT i32 0x0FF; %4:(s32) = G_AND %2, %3. We can use the constants and the definition of ``G_AND`` to determine the known; bits:. .. code-block:: none. ; %0 = 0x????????; %1:(s32) = G_CONSTANT i32 0xFF0 ; %1 = 0x00000FF0; %2:(s32) = G_AND %0, %1 ; %2 = 0x00000??0; %3:(s32) = G_CONSTANT i32 0x0FF ; %3 = 0x000000FF; %4:(s32) = G_AND %2, %3 ; %4 = 0x000000?0. and then use this to simplify the expression:. .. code-block:: none. ; %0 = 0x????????; %5:(s32) = G_CONSTANT i32 0x0F0 ; %5 = 0x00000FF0; %4:(s32) = G_AND %0, %5 ; %4 = 0x000000?0. Note that ``%4`` still has the same known bits as before the transformation.; Many transformations share this property. The main exception being when the; transform causes undefined bits to become defined to either zero, one, or; defined but unknown. Usage; -----. To use Known Bits Analysis in a pass, first include the header and register the; dependency with ``INITIALIZE_PASS_DEPENDENCY``. .. code-block:: c++. #include ""llvm/CodeGen/GlobalISel/GISelKnownBits.h"". ... INITIALIZE_PASS_BEGIN(...); INITIALIZE_PASS_DEPENDENCY(GISelKnownBitsAnalysis); INITIALIZE_PASS_END(...). and require the pass in ``getAnalysisUsage``. .. code-block:: c++. void MyPass::getAnalysisUsage(AnalysisUsage &AU) const {; AU.addRequired<GISelKnownBitsAnalysis>();; // Optional: If your pass preserves known bits analysis (many do) then; // indicate that it's preserved for re-use by another pa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GlobalISel/KnownBits.rst:307,simpl,simple,307,interpreter/llvm-project/llvm/docs/GlobalISel/KnownBits.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GlobalISel/KnownBits.rst,2,['simpl'],"['simple', 'simplify']"
Usability,"LE macros/slits.C; ```; [f21]: figures/TF1_DoubleSlit.png ""f21""; <a name=""f21""></a>. ![Output of slits.C with parameters 0.2 and 2.\label{f21}][f21]. The example first asks for user input, namely the ratio of slit width; over slit distance, and the number of slits. After entering this; information, you should see the graphical output as is shown in Figure [2.1](#f21). This is a more complicated example than the ones we have seen before, so; spend some time analysing it carefully, you should have understood it; before continuing. Let us go through it in detail:. Lines *7-18* define the necessary functions in `C++` code, split into; three separate functions, as suggested by the problem considered. The; full interference pattern is given by the product of a function; depending on the ratio of the width and distance of the slits, and a; second one depending on the number of slits. More important for us here; is the definition of the interface of these functions to make them; usable for the ROOT class `TF1`: the first argument is the pointer to; *x*, the second one points to the array of parameters. The main program starts at line 21 with the definition of a function; `slits()` of type `void`. After asking for user input, a ROOT function; is defined using the C-type function given in the beginning. We can now; use all methods of the `TF1` class to control the behaviour of our; function -- nice, isn't it ?. If you like, you can easily extend the example to also plot the; interference pattern of a single slit, using function `double single`,; or of a grid with narrow slits, function `double nslit0`, in `TF1`; instances. Here, we used a macro, some sort of lightweight program, that the; interpreter distributed with ROOT, Cling, is able to execute. This is a; rather extraordinary situation, since `C++` is not natively an interpreted; language! There is much more to say: chapter is indeed dedicated to; macros. ## Controlling ROOT ##. One more remark at this point: as every co",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md:6596,usab,usable,6596,documentation/primer/ROOT_as_calculator.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md,1,['usab'],['usable']
Usability,"LLVM Command Guide; ------------------. The following documents are command descriptions for all of the LLVM tools.; These pages describe how to use the LLVM commands and what their options are.; Note that these pages do not describe all of the options available for all; tools. To get a complete listing, pass the ``--help`` (general options) or; ``--help-hidden`` (general and debugging options) arguments to the tool you are; interested in. Basic Commands; ~~~~~~~~~~~~~~. .. toctree::; :maxdepth: 1. dsymutil; llc; lli; llvm-as; llvm-config; llvm-cov; llvm-cxxmap; llvm-debuginfo-analyzer; llvm-diff; llvm-dis; llvm-dwarfdump; llvm-dwarfutil; llvm-lib; llvm-libtool-darwin; llvm-link; llvm-lipo; llvm-mc; llvm-mca; llvm-opt-report; llvm-otool; llvm-profdata; llvm-readobj; llvm-reduce; llvm-stress; llvm-symbolizer; opt. GNU binutils replacements; ~~~~~~~~~~~~~~~~~~~~~~~~~. .. toctree::; :maxdepth: 1. llvm-addr2line; llvm-ar; llvm-cxxfilt; llvm-install-name-tool; llvm-nm; llvm-objcopy; llvm-objdump; llvm-ranlib; llvm-readelf; llvm-size; llvm-strings; llvm-strip. Debugging Tools; ~~~~~~~~~~~~~~~. .. toctree::; :maxdepth: 1. bugpoint; llvm-extract; llvm-bcanalyzer. Developer Tools; ~~~~~~~~~~~~~~~. .. toctree::; :maxdepth: 1. FileCheck; tblgen; clang-tblgen; lldb-tblgen; llvm-tblgen; mlir-tblgen; lit; llvm-exegesis; llvm-ifs; llvm-locstats; llvm-pdbutil; llvm-profgen; llvm-tli-checker. Remarks Tools; ~~~~~~~~~~~~~~. .. toctree::; :maxdepth: 1. llvm-remarkutil; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/index.rst:13,Guid,Guide,13,interpreter/llvm-project/llvm/docs/CommandGuide/index.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/index.rst,1,['Guid'],['Guide']
Usability,"LVM source tree. Note that code ownership is completely different than reviewers: anyone can; review a piece of code, and we welcome code review from anyone who is; interested. Code owners are the ""last line of defense"" to guarantee that all; patches that are committed are actually reviewed. Being a code owner is a somewhat unglamorous position, but it is incredibly; important for the ongoing success of the project. Because people get busy,; interests change, and unexpected things happen, code ownership is purely opt-in,; and anyone can choose to resign their ""title"" at any time. For now, we do not; have an official policy on how one gets elected to be a code owner. .. _include a testcase:. Test Cases; ----------. Developers are required to create test cases for any bugs fixed and any new; features added. Some tips for getting your testcase approved:. * All feature and regression test cases are added to the ``llvm/test``; directory. The appropriate sub-directory should be selected (see the; :doc:`Testing Guide <TestingGuide>` for details). * Test cases should be written in :doc:`LLVM assembly language <LangRef>`. * Test cases, especially for regressions, should be reduced as much as possible,; by :doc:`bugpoint <Bugpoint>` or manually. It is unacceptable to place an; entire failing program into ``llvm/test`` as this creates a *time-to-test*; burden on all developers. Please keep them short. * Avoid adding links to resources that are not available to the entire; community, such as links to private bug trackers, internal corporate; documentation, etc. Instead, add sufficient comments to the test to provide; the context behind such links. Note that llvm/test and clang/test are designed for regression and small feature; tests only. More extensive test cases (e.g., entire applications, benchmarks,; etc) should be added to the ``llvm-test`` test suite. The llvm-test suite is; for coverage (correctness, performance, etc) testing, not feature or regression; testing. Release ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst:9808,Guid,Guide,9808,interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,1,['Guid'],['Guide']
Usability,LaInverse.h; LaOuterProduct.h; LaProd.h; LaSum.h; MPIProcess.h; MatrixInverse.h; MinimumBuilder.h; MinimumError.h; MinimumErrorUpdator.h; MinimumParameters.h; MinimumSeed.h; MinimumSeedGenerator.h; MinimumState.h; MinosError.h; Minuit2Minimizer.h; MinuitParameter.h; MnApplication.h; MnConfig.h; MnContours.h; MnCovarianceSqueeze.h; MnCross.h; MnEigen.h; MnFcn.h; MnFumiliMinimize.h; MnFunctionCross.h; MnGlobalCorrelationCoeff.h; MnHesse.h; MnLineSearch.h; MnMachinePrecision.h; MnMatrix.h; MnMatrixfwd.h; MnMigrad.h; MnMinimize.h; MnMinos.h; MnParabola.h; MnParabolaFactory.h; MnParabolaPoint.h; MnParameterScan.h; MnPlot.h; MnPosDef.h; MnPrint.h; MnScan.h; MnSeedGenerator.h; MnSimplex.h; MnStrategy.h; MnTiny.h; MnTraceObject.h; MnUserCovariance.h; MnUserFcn.h; MnUserParameterState.h; MnUserParameters.h; MnUserTransformation.h; MnVectorTransform.h; ModularFunctionMinimizer.h; NegativeG2LineSearch.h; Numerical2PGradientCalculator.h; ParametricFunction.h; ScanBuilder.h; ScanMinimizer.h; SimplexBuilder.h; SimplexMinimizer.h; SimplexParameters.h; SimplexSeedGenerator.h; SinParameterTransformation.h; SqrtLowParameterTransformation.h; SqrtUpParameterTransformation.h; StackAllocator.h; VariableMetricBuilder.h; VariableMetricEDMEstimator.h; VariableMetricMinimizer.h; VectorOuterProduct.h; ). set(MINUIT2_SOURCES; AnalyticalGradientCalculator.cxx; BFGSErrorUpdator.cxx; CombinedMinimumBuilder.cxx; DavidonErrorUpdator.cxx; ExternalInternalGradientCalculator.cxx; FumiliBuilder.cxx; FumiliErrorUpdator.cxx; FumiliGradientCalculator.cxx; FumiliMinimizer.cxx; FumiliStandardChi2FCN.cxx; FumiliStandardMaximumLikelihoodFCN.cxx; HessianGradientCalculator.cxx; InitialGradientCalculator.cxx; LaEigenValues.cxx; LaInnerProduct.cxx; LaInverse.cxx; LaOuterProduct.cxx; LaSumOfElements.cxx; LaVtMVSimilarity.cxx; MPIProcess.cxx; MinimumBuilder.cxx; Minuit2Minimizer.cxx; MnApplication.cxx; MnContours.cxx; MnCovarianceSqueeze.cxx; MnEigen.cxx; MnFcn.cxx; MnFumiliMinimize.cxx; MnFunctionCross.cxx; MnGlob,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/CMakeLists.txt:1931,Simpl,SimplexBuilder,1931,math/minuit2/src/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/CMakeLists.txt,1,['Simpl'],['SimplexBuilder']
Usability,"LangRef.html#id311>`_:; ""the use of each incoming value is deemed to occur on the edge from the; corresponding predecessor block to the current block"". Now, an; edge to an exit block is considered outside of the loop because; if we take that edge, it leads us clearly out of the loop. However, an edge doesn't actually contain any IR, so in source code,; we have to choose a convention of whether the use happens in; the current block or in the respective predecessor. For LCSSA's purpose,; we consider the use happens in the latter (so as to consider the; use inside) [#point-of-use-phis]_. The major benefit of LCSSA is that it makes many other loop optimizations; simpler. First of all, a simple observation is that if one needs to see all; the outside users, they can just iterate over all the (loop closing); PHI nodes in the exit blocks (the alternative would be to; scan the def-use chain [#def-use-chain]_ of all instructions in the loop). Then, consider for example; :ref:`simple-loop-unswitch <passes-simple-loop-unswitch>` ing the loop above.; Because it is in LCSSA form, we know that any value defined inside of; the loop will be used either only inside the loop or in a loop closing; PHI node. In this case, the only loop closing PHI node is X4.; This means that we can just copy the loop and change the X4; accordingly, like so:. .. code-block:: C. c = ...;; if (c) {; for (...) {; if (true); X1 = ...; else; X2 = ...; X3 = phi(X1, X2);; }; } else {; for (...) {; if (false); X1' = ...; else; X2' = ...; X3' = phi(X1', X2');; }; }; X4 = phi(X3, X3'). Now, all uses of X4 will get the updated value (in general,; if a loop is in LCSSA form, in any loop transformation,; we only need to update the loop closing PHI nodes for the changes; to take effect). If we did not have Loop Closed SSA form, it means that X3 could; possibly be used outside the loop. So, we would have to introduce the; X4 (which is the new X3) and replace all uses of X3 with that.; However, we should note that bec",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LoopTerminology.rst:13252,simpl,simple-loop-unswitch,13252,interpreter/llvm-project/llvm/docs/LoopTerminology.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LoopTerminology.rst,2,['simpl'],['simple-loop-unswitch']
Usability,"LevelDebugging`. Rules for updating debug locations; ==================================. .. _WhenToPreserveLocation:. When to preserve an instruction location; ----------------------------------------. A transformation should preserve the debug location of an instruction if the; instruction either remains in its basic block, or if its basic block is folded; into a predecessor that branches unconditionally. The APIs to use are; ``IRBuilder``, or ``Instruction::setDebugLoc``. The purpose of this rule is to ensure that common block-local optimizations; preserve the ability to set breakpoints on source locations corresponding to; the instructions they touch. Debugging, crash logs, and SamplePGO accuracy; would be severely impacted if that ability were lost. Examples of transformations that should follow this rule include:. * Instruction scheduling. Block-local instruction reordering should not drop; source locations, even though this may lead to jumpy single-stepping; behavior. * Simple jump threading. For example, if block ``B1`` unconditionally jumps to; ``B2``, *and* is its unique predecessor, instructions from ``B2`` can be; hoisted into ``B1``. Source locations from ``B2`` should be preserved. * Peephole optimizations that replace or expand an instruction, like ``(add X; X) => (shl X 1)``. The location of the ``shl`` instruction should be the same; as the location of the ``add`` instruction. * Tail duplication. For example, if blocks ``B1`` and ``B2`` both; unconditionally branch to ``B3`` and ``B3`` can be folded into its; predecessors, source locations from ``B3`` should be preserved. Examples of transformations for which this rule *does not* apply include:. * LICM. E.g., if an instruction is moved from the loop body to the preheader,; the rule for :ref:`dropping locations<WhenToDropLocation>` applies. In addition to the rule above, a transformation should also preserve the debug; location of an instruction that is moved between basic blocks, if the; destination b",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToUpdateDebugInfo.rst:1646,Simpl,Simple,1646,interpreter/llvm-project/llvm/docs/HowToUpdateDebugInfo.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToUpdateDebugInfo.rst,1,['Simpl'],['Simple']
Usability,"Low-level code; ==============. .. toctree::; :hidden:. C code and older C++ code sometimes makes use of low-level features such as; pointers to builtin types, some of which do not have any Python equivalent; (e.g. ``unsigned short*``).; Furthermore, such codes tend to be ambiguous: the information from header; file is not sufficient to determine the full purpose.; For example, an ``int*`` type may refer to the address of a single ``int``; (an out-parameter, say) or it may refer to an array of ``int``, the ownership; of which is not clear either.; cppyy provides a few low-level helpers and integration with the Python; `ctypes module`_ to cover these cases. Use of these low-level helpers will obviously lead to very ""C-like"" code and; it is recommended to :doc:`pythonize <pythonizations>` the code, perhaps; using the Cling JIT and embedded C++. Note: the low-level module is not loaded by default (since its use is, or; should be, uncommon).; It needs to be imported explicitly:. .. code-block:: python. >>> import cppyy.ll; >>>. `LowLevelView`; --------------. Python has an elaborate array interface (buffer) specification, but no; standard library array type that completely implements it; instead, the; canonical Python array type is the NumPy one.; cppyy introduces the basic ``LowLevelView`` array class to avoid having a; direct dependency on NumPy and to guarantee zero copy.; The ``LowLevelView`` type gives access to array details such as the size,; type, etc. and allows reading/writing of array elements, both for interactive; use and through the buffer interface to allow NumPy to interface with them.; For more complex operations, it's recommended to copy from the; ``LowLevelView`` inta a NumPy array, or to create a NumPy view (see below,; under :ref:`NumPy Casts <npcasts>`). `C/C++ casts`; -------------. C++ instances are auto-casted to the most derived available type, so do not; require explicit casts even when a function returns a pointer to a base; class or interface",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/lowlevel.rst:539,clear,clear,539,bindings/pyroot/cppyy/cppyy/doc/source/lowlevel.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/lowlevel.rst,1,['clear'],['clear']
Usability,"Lowering``'s ``emitPrologue``, you have to emit `CFI; directives <https://sourceware.org/binutils/docs/as/CFI-directives.html>`_; to specify how to calculate the CFA (Canonical Frame Address) and how register; is restored from the address pointed by the CFA with an offset. The assembler; is instructed by CFI directives to build ``.eh_frame`` section, which is used; by th unwinder to unwind stack during exception handling. * ``getExceptionPointerRegister`` and ``getExceptionSelectorRegister``. ``TargetLowering`` must implement both functions. The *personality function*; passes the *exception structure* (a pointer) and *selector value* (an integer); to the landing pad through the registers specified by ``getExceptionPointerRegister``; and ``getExceptionSelectorRegister`` respectively. On most platforms, they; will be GPRs and will be the same as the ones specified in the calling convention. * ``EH_RETURN``. The ISD node represents the undocumented GCC extension ``__builtin_eh_return (offset, handler)``,; which adjusts the stack by offset and then jumps to the handler. ``__builtin_eh_return``; is used in GCC unwinder (`libgcc <https://gcc.gnu.org/onlinedocs/gccint/Libgcc.html>`_),; but not in LLVM unwinder (`libunwind <https://clang.llvm.org/docs/Toolchain.html#unwind-library>`_).; If you are on the top of ``libgcc`` and have particular requirement on your target,; you have to handle ``EH_RETURN`` in ``TargetLowering``. If you don't leverage the existing runtime (``libstdc++`` and ``libgcc``),; you have to take a look on `libc++ <https://libcxx.llvm.org/>`_ and; `libunwind <https://clang.llvm.org/docs/Toolchain.html#unwind-library>`_; to see what have to be done there. For ``libunwind``, you have to do the following. * ``__libunwind_config.h``. Define macros for your target. * ``include/libunwind.h``. Define enum for the target registers. * ``src/Registers.hpp``. Define ``Registers`` class for your target, implement setter and getter functions. * ``src/UnwindCursor.hpp",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ExceptionHandling.rst:36266,undo,undocumented,36266,interpreter/llvm-project/llvm/docs/ExceptionHandling.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ExceptionHandling.rst,1,['undo'],['undocumented']
Usability,"M does not:. - histogramming. - data handling. - graphics. M is kept as a low-level package with optimal performance. The main usages of M are. - from a user's program (such as int main()...). - from a graphical data analysis tool such as HippoDraw@bib-HippoDraw. The most important goals of M in are. - its numerical accuracy (equivalent to its Fortran version). - its computational performance (equivalent to its Fortran version). For the design of the application programming interface (API) of M a; two-way strategy was imposed:. - a minimal required interface with minimum interaction with M objects; and with appropriate usage of the standard library (STL): the user's; implementation of the FCNBase class, initial parameter values and; uncertainties are provided by the to M user via std::vectors. - a rich interface which provides the user with more functionality; such as interaction with parameters. The core of the minimization functionality and related tools (the kernel; of M ) should be clearly separated from the user, who is interfacing via; defined user interfaces (the API). ## Internal and external parameters ##. Each of the parameters to the $\mbox{FCN}$ is defined by the user as; belonging to one of the following types:. - Freely variable: allowed to take on any value. - Variable with double sided limits: allowed to vary only between two; limits specified by the user. - Variable with single sided limits: allowed to vary only between one; upper or one lower limit specified by the user and unlimited to the; other side. - Fixed: originally defined as variable, but now taking on only the; value the parameter had at the moment it was fixed, or a value later; assigned by the user. - Constant: taking on only one value as specified by the user. When using the minimal required interface, all variable parameters are; free and unbound. The user, in their $\mbox{FCN}$, must of course be able to ""see"" all; types of defined parameters, and they therefore have access to what we",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:4897,clear,clearly,4897,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['clear'],['clearly']
Usability,"M library. For example, ``llvm::DenseMap`` should; almost always be used instead of ``std::map`` or ``std::unordered_map``, and; ``llvm::SmallVector`` should usually be used instead of ``std::vector``. We explicitly avoid some standard facilities, like the I/O streams, and instead; use LLVM's streams library (raw_ostream_). More detailed information on these; subjects is available in the :doc:`ProgrammersManual`. For more information about LLVM's data structures and the tradeoffs they make,; please consult `that section of the programmer's manual; <https://llvm.org/docs/ProgrammersManual.html#picking-the-right-data-structure-for-a-task>`_. Python version and Source Code Formatting; -----------------------------------------. The current minimum version of Python required is documented in the :doc:`GettingStarted`; section. Python code in the LLVM repository should only use language features; available in this version of Python. The Python code within the LLVM repository should adhere to the formatting guidelines; outlined in `PEP 8 <https://peps.python.org/pep-0008/>`_. For consistency and to limit churn, code should be automatically formatted with; the `black <https://github.com/psf/black>`_ utility, which is PEP 8 compliant.; Use its default rules. For example, avoid specifying ``--line-length`` even; though it does not default to 80. The default rules can change between major; versions of black. In order to avoid unnecessary churn in the formatting rules,; we currently use black version 23.x in LLVM. When contributing a patch unrelated to formatting, you should format only the; Python code that the patch modifies. For this purpose, use the `darker; <https://pypi.org/project/darker/>`_ utility, which runs default black rules; over only the modified Python code. Doing so should ensure the patch will pass; the Python format checks in LLVM's pre-commit CI, which also uses darker. When; contributing a patch specifically for reformatting Python files, use black,; which c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst:4929,guid,guidelines,4929,interpreter/llvm-project/llvm/docs/CodingStandards.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst,1,['guid'],['guidelines']
Usability,"M when running into troubles. Problems can be:. - a bug in M. - an error in the $\mbox{FCN}$. - a highly difficult problem (usually strong correlations among; parameters). - floating–point precision. ## The output from minimization ##. ### The FunctionMinimum ###. The output of the minimizers is the FunctionMinimum. The FunctionMinimum; contains the result of the minimization in both internal parameter; representation and external parameter representation. ### User representable format: MnUserParameterState ###. On request, the result of the minimization is transformed into a user; representable format for parameters and errors, the; MnUserParameterState. ### Access values, errors, covariance ###. The result can be accessed via methods like; MnUserParameterState::value(unsigned int n) and; MnUserParameterState::error(unsigned int n), where $n$ is the index of; the parameter in the list of parameters defined by the user. ### Printout of the result ###. The FunctionMinimum can be printed on the output simply via std::cout.; It will print both the internal and external state, that is parameters,; errors and the covariance matrix (if available). It also tells the user; if M did converge or not by issuing an appropriate message. If a; covariance matrix is available, the global correlation coefficients are; printed as well. ### Global correlation coefficients ###. The global correlation coefficient for parameter $n$ is a number between; zero and one which gives the correlation between parameter $n$ and that; linear combination of all other parameters which is most strongly; correlated with $n$. # M application programming interface (API) #. [api:api]. ## FunctionMinimum ##. [api:fm] The FunctionMinimum is the output of the minimizers and; contains the minimization result. The state at the minimum is available; both in internal and external representations. For the external; representations the return methods. - FunctionMinimum::userState(),. - FunctionMinimum::userParamete",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:36406,simpl,simply,36406,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['simpl'],['simply']
Usability,"M, Alpha, and X86) can be; examined as models for your own ``analyzeBranch`` implementation. Since SPARC; does not implement a useful ``analyzeBranch``, the ARM target implementation is; shown below. ``analyzeBranch`` returns a Boolean value and takes four parameters:. * ``MachineBasicBlock &MBB`` --- The incoming block to be examined. * ``MachineBasicBlock *&TBB`` --- A destination block that is returned. For a; conditional branch that evaluates to true, ``TBB`` is the destination. * ``MachineBasicBlock *&FBB`` --- For a conditional branch that evaluates to; false, ``FBB`` is returned as the destination. * ``std::vector<MachineOperand> &Cond`` --- List of operands to evaluate a; condition for a conditional branch. In the simplest case, if a block ends without a branch, then it falls through; to the successor block. No destination blocks are specified for either ``TBB``; or ``FBB``, so both parameters return ``NULL``. The start of the; ``analyzeBranch`` (see code below for the ARM target) shows the function; parameters and the code for the simplest case. .. code-block:: c++. bool ARMInstrInfo::analyzeBranch(MachineBasicBlock &MBB,; MachineBasicBlock *&TBB,; MachineBasicBlock *&FBB,; std::vector<MachineOperand> &Cond) const; {; MachineBasicBlock::iterator I = MBB.end();; if (I == MBB.begin() || !isUnpredicatedTerminator(--I)); return false;. If a block ends with a single unconditional branch instruction, then; ``analyzeBranch`` (shown below) should return the destination of that branch in; the ``TBB`` parameter. .. code-block:: c++. if (LastOpc == ARM::B || LastOpc == ARM::tB) {; TBB = LastInst->getOperand(0).getMBB();; return false;; }. If a block ends with two unconditional branches, then the second branch is; never reached. In that situation, as shown below, remove the last branch; instruction and return the penultimate branch in the ``TBB`` parameter. .. code-block:: c++. if ((SecondLastOpc == ARM::B || SecondLastOpc == ARM::tB) &&; (LastOpc == ARM::B || LastOpc =",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst:48701,simpl,simplest,48701,interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst,1,['simpl'],['simplest']
Usability,"MPILER_RT_DEFAULT_TARGET_ONLY=ON``; * ``-DLLVM_CONFIG_PATH=/path/to/llvm-config``. The ``build-c-flags`` need to be sufficient to pass the C-make compiler check,; compile compiler-rt, and if you are running the tests, compile and link the; tests. When cross-compiling with clang we will need to pass sufficient; information to generate code for the Arm architecture we are targeting. We will; need to select the Arm target, select the Armv7-A architecture and choose; between using Arm or Thumb.; instructions. For example:. * ``--target=arm-linux-gnueabihf``; * ``-march=armv7a``; * ``-mthumb``. When using a GCC arm-linux-gnueabihf toolchain the following flags are; needed to pick up the includes and libraries:. * ``--gcc-toolchain=/path/to/dir/toolchain``; * ``--sysroot=/path/to/toolchain/arm-linux-gnueabihf/libc``. In this example we will be adding all of the command line options to both; ``CMAKE_C_FLAGS`` and ``CMAKE_ASM_FLAGS``. There are cmake flags to pass some of; these options individually which can be used to simplify the ``build-c-flags``:. * ``-DCMAKE_C_COMPILER_TARGET=""arm-linux-gnueabihf""``; * ``-DCMAKE_ASM_COMPILER_TARGET=""arm-linux-gnueabihf""``; * ``-DCMAKE_C_COMPILER_EXTERNAL_TOOLCHAIN=/path/to/dir/toolchain``; * ``-DCMAKE_SYSROOT=/path/to/dir/toolchain/arm-linux-gnueabihf/libc``. Once cmake has completed the builtins can be built with ``ninja builtins``. Testing compiler-rt builtins using qemu-arm; ===========================================; To test the builtins library we need to add a few more cmake flags to enable; testing and set up the compiler and flags for test case. We must also tell; cmake that we wish to run the tests on ``qemu-arm``. * ``-DCOMPILER_RT_EMULATOR=""qemu-arm -L /path/to/armhf/sysroot``; * ``-DCOMPILER_RT_INCLUDE_TESTS=ON``; * ``-DCOMPILER_RT_TEST_COMPILER=""/path/to/clang""``; * ``-DCOMPILER_RT_TEST_COMPILER_CFLAGS=""test-c-flags""``. The ``/path/to/armhf/sysroot`` should be the same as the one passed to; ``--sysroot`` in the ""build-c-",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToCrossCompileBuiltinsOnArm.rst:4298,simpl,simplify,4298,interpreter/llvm-project/llvm/docs/HowToCrossCompileBuiltinsOnArm.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToCrossCompileBuiltinsOnArm.rst,1,['simpl'],['simplify']
Usability,"MakeSelector to support more cases of branches names (that includes characters illegal in a C++ symbol); Replace the ReadLeaves virtual function by a fReadLeaves pointer to member function,; this allows the customization of the ReadLeaves function at run-time depending on the; underlying user class layout in TBranchElement. This removes many if statements whose; 'answer' is known at initialization time. Add support for 'array' formula in TTree::Query.; Set the initial value of fCacheSize to zero to indicate clearly that the TreeCache is disabled.; In TChain::SetEntryList use only the treename to lookup the (sub)entryList (instead subdir/treename).; Add support for the branch creation syntax:; TString rootString;; t->Branch(""rootString"",""TString"",&rootString, 1600, 0);; which is 'natural' as it uses the legacy syntax (branch_name,class_name, user_data); but did not work because 'rootString' is an object rather than a pointer to an; object. (However the simplier form:; t->Branch(""rootString"",&rootString, 1600, 0);; works/worked fine). Add type information to the result of TTree::Print in the case of; TBranchElement:; *Br 17 :fH : TH1F* *; *Entries : 20 : Total Size= 19334 bytes File Size = 1671 *; *Baskets : 2 : Basket Size= 16000 bytes Compression= 11.29 *; *............................................................................*; *Br 18 :fTriggerBits : TBits *; *Entries : 20 : Total Size= 1398 bytes File Size = 400 *; *Baskets : 1 : Basket Size= 16000 bytes Compression= 2.23 *; *............................................................................*; *Br 19 :fIsValid : Bool_t *; *Entries : 20 : Total Size= 582 bytes File Size = 92 *; *Baskets : 1 : Basket Size= 16000 bytes Compression= 1.00 *. Add a new function TBranch::SetStatus It is much faster to call this function in case of a Tree with many branches; instead of calling TTree::SetBranchStatus.; Implement TTreeCache::Print that shows information like:; // ******TreeCache statistics for file: cms2.roo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/doc/v528/index.html:4714,simpl,simplier,4714,tree/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/doc/v528/index.html,1,['simpl'],['simplier']
Usability,"Matching LLVM code would look like (with the rest of the code remaining the same; as the code in the previous section):. .. code-block:: llvm. loop:; %n.addr = phi i32 [ %n, %entry ], [ %inc, %loop.resume ]; call void @print(i32 %n.addr) #4; %2 = call i8 @llvm.coro.suspend(token none, i1 false); switch i8 %2, label %suspend [i8 0, label %loop.resume; i8 1, label %cleanup]; loop.resume:; %inc = add nsw i32 %n.addr, 1; %sub = xor i32 %n.addr, -1; call void @print(i32 %sub); %3 = call i8 @llvm.coro.suspend(token none, i1 false); switch i8 %3, label %suspend [i8 0, label %loop; i8 1, label %cleanup]. In this case, the coroutine frame would include a suspend index that will; indicate at which suspend point the coroutine needs to resume. .. code-block:: llvm. %f.frame = type { ptr, ptr, i32, i32 }. The resume function will use an index to jump to an appropriate basic block and will look; as follows:. .. code-block:: llvm. define internal fastcc void @f.Resume(ptr %FramePtr) {; entry.Resume:; %index.addr = getelementptr inbounds %f.Frame, ptr %FramePtr, i64 0, i32 2; %index = load i8, ptr %index.addr, align 1; %switch = icmp eq i8 %index, 0; %n.addr = getelementptr inbounds %f.Frame, ptr %FramePtr, i64 0, i32 3; %n = load i32, ptr %n.addr, align 4. br i1 %switch, label %loop.resume, label %loop. loop.resume:; %sub = sub nsw i32 0, %n; call void @print(i32 %sub); br label %suspend; loop:; %inc = add nsw i32 %n, 1; store i32 %inc, ptr %n.addr, align 4; tail call void @print(i32 %inc); br label %suspend. suspend:; %storemerge = phi i8 [ 0, %loop ], [ 1, %loop.resume ]; store i8 %storemerge, ptr %index.addr, align 1; ret void; }. If different cleanup code needs to get executed for different suspend points,; a similar switch will be in the `f.destroy` function. .. note ::. Using suspend index in a coroutine state and having a switch in `f.resume` and; `f.destroy` is one of the possible implementation strategies. We explored; another option where a distinct `f.resume1`, `f.resum",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:19180,Resume,Resume,19180,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['Resume'],['Resume']
Usability,"Meeting notes: Implementation idea: Exception Handling in C++/Java. The 5/18/01 meeting discussed ideas for implementing exceptions in LLVM.; We decided that the best solution requires a set of library calls provided by; the VM, as well as an extension to the LLVM function invocation syntax. The LLVM function invocation instruction previously looks like this (ignoring; types):. call func(arg1, arg2, arg3). The extension discussed today adds an optional ""with"" clause that ; associates a label with the call site. The new syntax looks like this:. call func(arg1, arg2, arg3) with funcCleanup. This funcHandler always stays tightly associated with the call site (being; encoded directly into the call opcode itself), and should be used whenever; there is cleanup work that needs to be done for the current function if ; an exception is thrown by func (or if we are in a try block). To support this, the VM/Runtime provide the following simple library ; functions (all syntax in this document is very abstract):. typedef struct { something } %frame;; The VM must export a ""frame type"", that is an opaque structure used to ; implement different types of stack walking that may be used by various; language runtime libraries. We imagine that it would be typical to ; represent a frame with a PC and frame pointer pair, although that is not ; required. %frame getStackCurrentFrame();; Get a frame object for the current function. Note that if the current; function was inlined into its caller, the ""current"" frame will belong to; the ""caller"". bool isFirstFrame(%frame f);; Returns true if the specified frame is the top level (first activated) frame; for this thread. For the main thread, this corresponds to the main() ; function, for a spawned thread, it corresponds to the thread function. %frame getNextFrame(%frame f);; Return the previous frame on the stack. This function is undefined if f; satisfies the predicate isFirstFrame(f). Label *getFrameLabel(%frame f);; If a label was associated with",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-05-18-ExceptionHandling.txt:938,simpl,simple,938,interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-05-18-ExceptionHandling.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-05-18-ExceptionHandling.txt,1,['simpl'],['simple']
Usability,"MnContours). # Introduction: M basic concepts #. [sec:intro]. ## The organization of M ##. The M package acts on a multiparameter *objective function* which is; called — for historical reasons — the $\mbox{FCN}$ function (see; [howto:fcn]). This function is usually a chisquared or a log–likelihood,; but it could also be a mathematical function. The $\mbox{FCN}$; function needs to be written in for which M defines the pure abstract; base class FCNBase as interface. The user must define and implement the; $\mbox{FCN}$ function in a derived class from FCNBase. Sometimes; this is done by an intermediate program such as HippoDraw@bib-HippoDraw,; in which case M is being used under the control of such an intermediate; program[^1]. The value of the $\mbox{FCN}$ function will in general; depend on one or more variable parameters whose meaning is defined by; the user (or by the intermediate program), but whose trial values are; determined by M . To take a simple example, suppose the problem is to fit a polynomial; through a set of data points. Then the user would write a; $\mbox{FCN}$ which calculates the $\chi^2$ between a polynomial and; the data; the variable parameters of $\mbox{FCN}$ would be the; coefficients of the polynomials. Using objects for minimization from M ,; the user would request M to minimize the $\mbox{FCN}$ with respect; to the parameters, that is, find those values of the coefficients which; give the lowest value of chisquare. The user must therefore supply, in addition to the function to be; analyzed, via a set or sequence of M applications the instructions which; analysis is wanted. The instructions are coded in in the calling program; (main.cpp), which allows looping, conditional execution, and all the; other possibilities of , but not interactivity, since it must be; compiled before execution. ## Design aspects of M in ##. What M is:. - platform independent. - written in an object-oriented way using standard. - independent of any external package. T",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:2582,simpl,simple,2582,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['simpl'],['simple']
Usability,"Module));; checkCudaErrors(cuCtxDestroy(context));. return 0;; }. You will need to link with the CUDA driver and specify the path to cuda.h. .. code-block:: text. # clang++ sample.cpp -o sample -O2 -g -I/usr/local/cuda-5.5/include -lcuda. We don't need to specify a path to ``libcuda.so`` since this is installed in a; system location by the driver, not the CUDA toolkit. If everything goes as planned, you should see the following output when; running the compiled program:. .. code-block:: text. Using CUDA Device [0]: GeForce GTX 680; Device Compute Capability: 3.0; Launching kernel; Results:; 0 + 0 = 0; 1 + 2 = 3; 2 + 4 = 6; 3 + 6 = 9; 4 + 8 = 12; 5 + 10 = 15; 6 + 12 = 18; 7 + 14 = 21; 8 + 16 = 24; 9 + 18 = 27; 10 + 20 = 30; 11 + 22 = 33; 12 + 24 = 36; 13 + 26 = 39; 14 + 28 = 42; 15 + 30 = 45. .. note::. You will likely see a different device identifier based on your hardware. Tutorial: Linking with Libdevice; ================================. In this tutorial, we show a simple example of linking LLVM IR with the; libdevice library. We will use the same kernel as the previous tutorial,; except that we will compute ``C = pow(A, B)`` instead of ``C = A + B``.; Libdevice provides an ``__nv_powf`` function that we will use. .. code-block:: llvm. target datalayout = ""e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v16:16:16-v32:32:32-v64:64:64-v128:128:128-n16:32:64""; target triple = ""nvptx64-nvidia-cuda"". ; Intrinsic to read X component of thread ID; declare i32 @llvm.nvvm.read.ptx.sreg.tid.x() readnone nounwind; ; libdevice function; declare float @__nv_powf(float, float). define void @kernel(float addrspace(1)* %A,; float addrspace(1)* %B,; float addrspace(1)* %C) {; entry:; ; What is my ID?; %id = tail call i32 @llvm.nvvm.read.ptx.sreg.tid.x() readnone nounwind. ; Compute pointers into A, B, and C; %ptrA = getelementptr float, float addrspace(1)* %A, i32 %id; %ptrB = getelementptr float, float addrspace(1)* %B, i32 %id; %ptrC = getelementptr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NVPTXUsage.rst:23493,simpl,simple,23493,interpreter/llvm-project/llvm/docs/NVPTXUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NVPTXUsage.rst,1,['simpl'],['simple']
Usability,"Modulo,; - 2 = CMY Smooth,; - 3 = CMY Modulo,; - 4 = CIE Smooth; - 5 = CIE Modulo,; - 6 = YIQ Smooth,; - 7 = YIQ Modulo,; - 8 = HVS Smooth,; - 9 = HVS Modulo. This function does not apply on Simple display modes group. Default; value is 0. Example choosing CMY Modulo to paint the 2D histogram:. ``` {.cpp}; h2->Draw(""SPEC c1(3) dm(0,1) a(30,30,0)"");; ```. The operator ""`lp(x,y,z)`"" sets the light position. In Light and; LightHeight display modes groups the color palette is calculated; according to the fictive light source position in 3-d space. Using; this function one can change the source's position and thus achieve; various graphical effects. This function does not apply for Simple and; Height display modes groups. Default is: `lp(1000,1000,100)` . The operator ""`s(shading,shadow)`"" allows to set the shading. The; surface picture is composed of triangles. The edges of the neighboring; triangles can be smoothed (shaded). The shadow can be painted as well.; The function does not apply on Simple display modes group. The; possible values for shading are:. - 0 = Not Shaded,; - 1 = Shaded. The possible values for shadow are:. - 0 = Shadows are not painted,; - 1 = Shadows are painted. Default values: `s(1,0)` . The operator ""`b(bezier)`"" sets the Bezier smoothing. For Simple; display modes group and for Grid, LinesX and LinesY display modes one; can smooth data using Bezier smoothing algorithm. The function does; not apply on other display modes groups and display modes. Possible; values are: 0 = No bezier smoothing, 1 = Bezier smoothing. Default; value is: `b(0)`. The operator ""`cw(width)`"" sets the contour width. This function; applies only on for the Contours display mode. One can change the; width between horizontal slices and thus their density. Default value:; `cw(50)` . The operator ""`lhw(weight)`"" sets the light height weight. For; LightHeight display modes group one can change the weight between both; shading algorithms. The function does not apply on other disp",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:40028,Simpl,Simple,40028,documentation/users-guide/Histograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md,1,['Simpl'],['Simple']
Usability,"NSNumber numberWithLongLong:42LL]. // floating point literals.; NSNumber *piFloat = @3.141592654F; // equivalent to [NSNumber numberWithFloat:3.141592654F]; NSNumber *piDouble = @3.1415926535; // equivalent to [NSNumber numberWithDouble:3.1415926535]. // BOOL literals.; NSNumber *yesNumber = @YES; // equivalent to [NSNumber numberWithBool:YES]; NSNumber *noNumber = @NO; // equivalent to [NSNumber numberWithBool:NO]. #ifdef __cplusplus; NSNumber *trueNumber = @true; // equivalent to [NSNumber numberWithBool:(BOOL)true]; NSNumber *falseNumber = @false; // equivalent to [NSNumber numberWithBool:(BOOL)false]; #endif; }. Discussion; ----------. NSNumber literals only support literal scalar values after the ``'@'``.; Consequently, ``@INT_MAX`` works, but ``@INT_MIN`` does not, because; they are defined like this:. .. code-block:: objc. #define INT_MAX 2147483647 /* max value for an int */; #define INT_MIN (-2147483647-1) /* min value for an int */. The definition of ``INT_MIN`` is not a simple literal, but a; parenthesized expression. Parenthesized expressions are supported using; the `boxed expression <#objc_boxed_expressions>`_ syntax, which is; described in the next section. Because ``NSNumber`` does not currently support wrapping ``long double``; values, the use of a ``long double NSNumber`` literal (e.g.; ``@123.23L``) will be rejected by the compiler. Previously, the ``BOOL`` type was simply a typedef for ``signed char``,; and ``YES`` and ``NO`` were macros that expand to ``(BOOL)1`` and; ``(BOOL)0`` respectively. To support ``@YES`` and ``@NO`` expressions,; these macros are now defined using new language keywords in; ``<objc/objc.h>``:. .. code-block:: objc. #if __has_feature(objc_bool); #define YES __objc_yes; #define NO __objc_no; #else; #define YES ((BOOL)1); #define NO ((BOOL)0); #endif. The compiler implicitly converts ``__objc_yes`` and ``__objc_no`` to; ``(BOOL)1`` and ``(BOOL)0``. The keywords are used to disambiguate; ``BOOL`` and integer literals. Object",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst:3071,simpl,simple,3071,interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst,1,['simpl'],['simple']
Usability,"NSTANT i32 2, debug-location !14; DBG_VALUE %2(s32), $noreg, !9, !DIExpression(), debug-location !14; %3:_(s32) = G_ADD %0, %2, debug-location !DILocation(line: 4, column: 1, scope: !6); DBG_VALUE %3(s32), $noreg, !9, !DIExpression(), debug-location !DILocation(line: 4, column: 1, scope: !6); %4:_(s32) = G_SUB %3, %1, debug-location !DILocation(line: 5, column: 1, scope: !6); DBG_VALUE %4(s32), $noreg, !9, !DIExpression(), debug-location !DILocation(line: 5, column: 1, scope: !6). By default, ``mir-debugify`` inserts ``DBG_VALUE`` instructions **everywhere**; it is legal to do so. In particular, every (non-PHI) machine instruction that; defines a register must be followed by a ``DBG_VALUE`` use of that def. If; an instruction does not define a register, but can be followed by a debug inst,; MIRDebugify inserts a ``DBG_VALUE`` that references a constant. Insertion of; ``DBG_VALUE``'s can be disabled by setting ``-debugify-level=locations``. To run MIRDebugify once, simply insert ``mir-debugify`` into your ``llc``; invocation, like:. .. code-block:: bash. # Before some other pass.; $ llc -run-pass=mir-debugify,other-pass ... # After some other pass.; $ llc -run-pass=other-pass,mir-debugify ... To run MIRDebugify before each pass in a pipeline, use; ``-debugify-and-strip-all-safe``. This can be combined with ``-start-before``; and ``-start-after``. For example:. .. code-block:: bash. $ llc -debugify-and-strip-all-safe -run-pass=... <other llc args>; $ llc -debugify-and-strip-all-safe -O1 <other llc args>. If you want to check it after each pass in a pipeline, use; ``-debugify-check-and-strip-all-safe``. This can also be combined with; ``-start-before`` and ``-start-after``. For example:. .. code-block:: bash. $ llc -debugify-check-and-strip-all-safe -run-pass=... <other llc args>; $ llc -debugify-check-and-strip-all-safe -O1 <other llc args>. To check all debug info from a test, use ``mir-check-debugify``, like:. .. code-block:: bash. $ llc -run-pass=mir-debugify,other",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToUpdateDebugInfo.rst:17725,simpl,simply,17725,interpreter/llvm-project/llvm/docs/HowToUpdateDebugInfo.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToUpdateDebugInfo.rst,1,['simpl'],['simply']
Usability,"NU old-style field designator extension; struct point origin = { x: 0.0, y: 0.0 };; ~~ ^; .x = ; t.c:5:36: warning: use of GNU old-style field designator extension; struct point origin = { x: 0.0, y: 0.0 };; ~~ ^; .y = . ""Fix-it"" hints are most useful for; working around common user errors and misconceptions. For example, C++ users; commonly forget the syntax for explicit specialization of class templates,; as in the error in the following example. Again, after describing the problem,; Clang provides the fix--add template<>--as part of the; diagnostic. $ clang t.cpp; t.cpp:9:3: error: template specialization requires 'template<>'; struct iterator_traits<file_iterator> {; ^; template<> . Template Type Diffing; Templates types can be long and difficult to read. More so when part of an; error message. Instead of just printing out the type name, Clang has enough; information to remove the common elements and highlight the differences. To; show the template structure more clearly, the templated type can also be; printed as an indented text tree. Default: template diff with type elision. t.cc:4:5: note: candidate function not viable: no known conversion from 'vector<map<[...], float>>' to 'vector<map<[...], double>>' for 1st argument;. -fno-elide-type: template diff without elision. t.cc:4:5: note: candidate function not viable: no known conversion from 'vector<map<int, float>>' to 'vector<map<int, double>>' for 1st argument;. -fdiagnostics-show-template-tree: template tree printing with elision. t.cc:4:5: note: candidate function not viable: no known conversion for 1st argument;; vector<; map<; [...],; [float != double]>>. -fdiagnostics-show-template-tree -fno-elide-type: template tree printing with no elision. t.cc:4:5: note: candidate function not viable: no known conversion for 1st argument;; vector<; map<; int,; [float != double]>>. Automatic Macro Expansion; Many errors happen in macros that are sometimes deeply nested. With; traditional compilers, you need to dig d",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html:7763,clear,clearly,7763,interpreter/llvm-project/clang/www/diagnostics.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html,1,['clear'],['clearly']
Usability,"Name"");. if (!areSameVariable(IncVar, CondVar) || !areSameVariable(IncVar, InitVar)); return;; llvm::outs() << ""Potential array-based loop discovered.\n"";; }. Clang associates a ``VarDecl`` with each variable to represent the variable's; declaration. Since the ""canonical"" form of each declaration is unique by; address, all we need to do is make sure neither ``ValueDecl`` (base class of; ``VarDecl``) is ``NULL`` and compare the canonical Decls. .. code-block:: c++. static bool areSameVariable(const ValueDecl *First, const ValueDecl *Second) {; return First && Second &&; First->getCanonicalDecl() == Second->getCanonicalDecl();; }. If execution reaches the end of ``LoopPrinter::run()``, we know that the; loop shell looks like. .. code-block:: c++. for (int i= 0; i < expr(); ++i) { ... }. For now, we will just print a message explaining that we found a loop.; The next section will deal with recursively traversing the AST to; discover all changes needed. As a side note, it's not as trivial to test if two expressions are the same,; though Clang has already done the hard work for us by providing a way to; canonicalize expressions:. .. code-block:: c++. static bool areSameExpr(ASTContext *Context, const Expr *First,; const Expr *Second) {; if (!First || !Second); return false;; llvm::FoldingSetNodeID FirstID, SecondID;; First->Profile(FirstID, *Context, true);; Second->Profile(SecondID, *Context, true);; return FirstID == SecondID;; }. This code relies on the comparison between two; ``llvm::FoldingSetNodeIDs``. As the documentation for; ``Stmt::Profile()`` indicates, the ``Profile()`` member function builds; a description of a node in the AST, based on its properties, along with; those of its children. ``FoldingSetNodeID`` then serves as a hash we can; use to compare expressions. We will need ``areSameExpr`` later. Before; you run the new code on the additional loops added to; test-files/simple.cpp, try to figure out which ones will be considered; potentially convertible.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst:19649,simpl,simple,19649,interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,1,['simpl'],['simple']
Usability,"NamedDecl> InnerMatcher; Matches a using shadow declaration where the target declaration is; matched by the given matcher. Given; namespace X { int a; void b(); }; using X::a;; using X::b;; usingDecl(hasAnyUsingShadowDecl(hasTargetDecl(functionDecl()))); matches using X::b but not using X::a ; Matcher<UsingType>hasUnderlyingTypeMatcher<Type>; Matches DecltypeType or UsingType nodes to find the underlying type. Given; decltype(1) a = 1;; decltype(2.0) b = 2.0;; decltypeType(hasUnderlyingType(isInteger())); matches the type of ""a"". Usable as: Matcher<DecltypeType>, Matcher<UsingType>. Matcher<UsingType>throughUsingDeclMatcher<UsingShadowDecl> Inner; Matches if a node refers to a declaration through a specific; using shadow declaration. Examples:; namespace a { int f(); }; using a::f;; int x = f();; declRefExpr(throughUsingDecl(anything())); matches f. namespace a { class X{}; }; using a::X;; X x;; typeLoc(loc(usingType(throughUsingDecl(anything())))); matches X. Usable as: Matcher<DeclRefExpr>, Matcher<UsingType>. Matcher<ValueDecl>hasTypeMatcher<Decl> InnerMatcher; Overloaded to match the declaration of the expression's or value; declaration's type. In case of a value declaration (for example a variable declaration),; this resolves one layer of indirection. For example, in the value; declaration ""X x;"", cxxRecordDecl(hasName(""X"")) matches the declaration of; X, while varDecl(hasType(cxxRecordDecl(hasName(""X"")))) matches the; declaration of x. Example matches x (matcher = expr(hasType(cxxRecordDecl(hasName(""X""))))); and z (matcher = varDecl(hasType(cxxRecordDecl(hasName(""X""))))); and friend class X (matcher = friendDecl(hasType(""X"")); and public virtual X (matcher = cxxBaseSpecifier(hasType(; cxxRecordDecl(hasName(""X"")))); class X {};; void y(X &x) { x; X z; }; class Y { friend class X; };; class Z : public virtual X {};. Example matches class Derived; (matcher = cxxRecordDecl(hasAnyBase(hasType(cxxRecordDecl(hasName(""Base"")))))); class Base {};; class Derived : Base {",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:251925,Usab,Usable,251925,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['Usab'],['Usable']
Usability,"None. Semantics:; """""""""""""""""""". This intrinsic is lowered to refer to a private constant coroutine frame. The; resume and destroy handlers for this frame are empty functions that do nothing.; Note that in different translation units llvm.coro.noop may return different pointers. .. _coro.frame:. 'llvm.coro.frame' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; ::. declare ptr @llvm.coro.frame(). Overview:; """""""""""""""""". The '``llvm.coro.frame``' intrinsic returns an address of the coroutine frame of; the enclosing coroutine. Arguments:; """""""""""""""""""". None. Semantics:; """""""""""""""""""". This intrinsic is lowered to refer to the `coro.begin`_ instruction. This is; a frontend convenience intrinsic that makes it easier to refer to the; coroutine frame. .. _coro.id:. 'llvm.coro.id' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; ::. declare token @llvm.coro.id(i32 <align>, ptr <promise>, ptr <coroaddr>,; ptr <fnaddrs>). Overview:; """""""""""""""""". The '``llvm.coro.id``' intrinsic returns a token identifying a; switched-resume coroutine. Arguments:; """""""""""""""""""". The first argument provides information on the alignment of the memory returned; by the allocation function and given to `coro.begin` by the first argument. If; this argument is 0, the memory is assumed to be aligned to 2 * sizeof(ptr).; This argument only accepts constants. The second argument, if not `null`, designates a particular alloca instruction; to be a `coroutine promise`_. The third argument is `null` coming out of the frontend. The CoroEarly pass sets; this argument to point to the function this coro.id belongs to. The fourth argument is `null` before coroutine is split, and later is replaced; to point to a private global constant array containing function pointers to; outlined resume and destroy parts of the coroutine. Semantics:; """""""""""""""""""". The purpose of this intrinsic is to tie together `coro.id`, `coro.alloc` and; `coro.begin` belonging to the same coroutine to prevent optimization passes from; duplicating an",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:37087,resume,resume,37087,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"Note that the; definition of ""storage"" here refers to the outermost enclosing allocation of any; particular object (so for example, it's never correct to call this function; passing the addresses of fields in the same struct, elements of the same array,; etc.). Query for this feature with ``__has_builtin(__builtin_assume_separate_storage)``. ``__builtin_offsetof``; ----------------------. ``__builtin_offsetof`` is used to implement the ``offsetof`` macro, which; calculates the offset (in bytes) to a given member of the given type. **Syntax**:. .. code-block:: c++. __builtin_offsetof(type-name, member-designator). **Example of Use**:. .. code-block:: c++. struct S {; char c;; int i;; struct T {; float f[2];; } t;; };. const int offset_to_i = __builtin_offsetof(struct S, i);; const int ext1 = __builtin_offsetof(struct U { int i; }, i); // C extension; const int offset_to_subobject = __builtin_offsetof(struct S, t.f[1]);. **Description**:. This builtin is usable in an integer constant expression which returns a value; of type ``size_t``. The value returned is the offset in bytes to the subobject; designated by the member-designator from the beginning of an object of type; ``type-name``. Clang extends the required standard functionality in the; following way:. * In C language modes, the first argument may be the definition of a new type.; Any type declared this way is scoped to the nearest scope containing the call; to the builtin. Query for this feature with ``__has_builtin(__builtin_offsetof)``. ``__builtin_call_with_static_chain``; ------------------------------------. ``__builtin_call_with_static_chain`` is used to perform a static call while; setting updating the static chain register. **Syntax**:. .. code-block:: c++. T __builtin_call_with_static_chain(T expr, void* ptr). **Example of Use**:. .. code-block:: c++. auto v = __builtin_call_with_static_chain(foo(3), foo);. **Description**:. This builtin returns ``expr`` after checking that ``expr`` is a non-member; st",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:101419,usab,usable,101419,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['usab'],['usable']
Usability,"OAD_ROOTR_MODULE(MyFunctorModule);. //creating a class variable from the module; r<<""MyFunctor <- MyFunctorModule$MyFunctor"";; //creating a MyFunctor's object; r<<""u <- new(MyFunctor)"";. //printing status; r<<""print(u$getStatus())"";. //printing values from Functor and Function; r<<""print(sprintf('value in R = %f',u$doEval( 1 )))"";; std::cout<<""value in ROOT = ""<<TMath::BesselY1(1)<<std::endl;. ////////////////////////////////////////////////////////////; //creating a MyFunctor's object and passing object to R's //; //environment, the status should be true because is not //; //using the default function //; ////////////////////////////////////////////////////////////; MyFunctor functor;; functor.setFunction(TMath::Erf);; r[""functor""]<<functor;; //printing the status that should be true; r<<""print(functor$getStatus())"";; r<<""print(sprintf('value in R = %f',functor$doEval( 1 )))"";; std::cout<<""value in ROOT = ""<<TMath::Erf(1)<<std::endl;; }; ~~~. ## Simple fitting in R and plot in ROOT; The next example creates an exponential fit.; The idea is to create a set of numbers x,y with noise from ROOT,; pass them to R and fit the data to `x^3`,; get the fitted coefficient(power) and plot the data,; the known function and the fitted function using ROOT's classes. ~~~{.cxx}; #include<TRInterface.h>; #include<TRandom.h>. TCanvas *SimpleFitting(){; TCanvas *c1 = new TCanvas(""c1"",""Curve Fitting"",700,500);; c1->SetGrid();. // draw a frame to define the range; TMultiGraph *mg = new TMultiGraph();. // create the first graph (points with gaussian noise); const Int_t n = 24;; Double_t x1[n] ;; Double_t y1[n] ;; //Generate the points along a X^3 with noise; TRandom rg;; rg.SetSeed(520);; for (Int_t i = 0; i < n; i++) {; x1[i] = rg.Uniform(0, 1);; y1[i] = TMath::Power(x1[i], 3) + rg.Gaus() * 0.06;; }. TGraph *gr1 = new TGraph(n,x1,y1);; gr1->SetMarkerColor(kBlue);; gr1->SetMarkerStyle(8);; gr1->SetMarkerSize(1);; mg->Add(gr1);. // create the second graph; TF1 *f_known=new TF1(""f_known"",""",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/r/doc/users-guide/ROOTR_Users_Guide.md:14479,Simpl,Simple,14479,bindings/r/doc/users-guide/ROOTR_Users_Guide.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/r/doc/users-guide/ROOTR_Users_Guide.md,1,['Simpl'],['Simple']
Usability,"OPERTY_class | 0x4000|; +--------------------------------------+-------+. Name Accelerator Tables; -----------------------. Introduction; ^^^^^^^^^^^^. The ""``.debug_pubnames``"" and ""``.debug_pubtypes``"" formats are not what a; debugger needs. The ""``pub``"" in the section name indicates that the entries; in the table are publicly visible names only. This means no static or hidden; functions show up in the ""``.debug_pubnames``"". No static variables or private; class variables are in the ""``.debug_pubtypes``"". Many compilers add different; things to these tables, so we can't rely upon the contents between gcc, icc, or; clang. The typical query given by users tends not to match up with the contents of; these tables. For example, the DWARF spec states that ""In the case of the name; of a function member or static data member of a C++ structure, class or union,; the name presented in the ""``.debug_pubnames``"" section is not the simple name; given by the ``DW_AT_name attribute`` of the referenced debugging information; entry, but rather the fully qualified name of the data or function member.""; So the only names in these tables for complex C++ entries is a fully; qualified name. Debugger users tend not to enter their search strings as; ""``a::b::c(int,const Foo&) const``"", but rather as ""``c``"", ""``b::c``"" , or; ""``a::b::c``"". So the name entered in the name table must be demangled in; order to chop it up appropriately and additional names must be manually entered; into the table to make it effective as a name lookup table for debuggers to; use. All debuggers currently ignore the ""``.debug_pubnames``"" table as a result of; its inconsistent and useless public-only name content making it a waste of; space in the object file. These tables, when they are written to disk, are not; sorted in any way, leaving every debugger to do its own parsing and sorting.; These tables also include an inlined copy of the string values in the table; itself making the tables much larger than they ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:57285,simpl,simple,57285,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['simpl'],['simple']
Usability,"OP_LLVM_entry_value, 1, ...)`` is lowered to; ``DW_OP_entry_value [reg], ...``, which pushes the value ``reg`` had upon; function entry onto the DWARF expression stack. The next ``(N - 1)`` operations will be part of the ``DW_OP_entry_value``; block argument. For example, ``!DIExpression(DW_OP_LLVM_entry_value, 1,; DW_OP_plus_uconst, 123, DW_OP_stack_value)`` specifies an expression where; the entry value of ``reg`` is pushed onto the stack, and is added with 123.; Due to framework limitations ``N`` must be 1, in other words,; ``DW_OP_entry_value`` always refers to the value/address operand of the; instruction. Because ``DW_OP_LLVM_entry_value`` is defined in terms of registers, it is; usually used in MIR, but it is also allowed in LLVM IR when targeting a; :ref:`swiftasync <swiftasync>` argument. The operation is introduced by:. - ``LiveDebugValues`` pass, which applies it to function parameters that; are unmodified throughout the function. Support is limited to simple; register location descriptions, or as indirect locations (e.g.,; parameters passed-by-value to a callee via a pointer to a temporary copy; made in the caller).; - ``AsmPrinter`` pass when a call site parameter value; (``DW_AT_call_site_parameter_value``) is represented as entry value of; the parameter.; - ``CoroSplit`` pass, which may move variables from allocas into a; coroutine frame. If the coroutine frame is a; :ref:`swiftasync <swiftasync>` argument, the variable is described with; an ``DW_OP_LLVM_entry_value`` operation. - ``DW_OP_LLVM_arg, N`` is used in debug intrinsics that refer to more than one; value, such as one that calculates the sum of two registers. This is always; used in combination with an ordered list of values, such that; ``DW_OP_LLVM_arg, N`` refers to the ``N``\ :sup:`th` element in that list. For; example, ``!DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus,; DW_OP_stack_value)`` used with the list ``(%reg1, %reg2)`` would evaluate to; ``%reg1 - reg2``. This lis",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:264132,simpl,simple,264132,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['simpl'],['simple']
Usability,"Object(""hpxpy;1"");; await draw(""drawing"", obj, ""colz"");; </script>; ```. Here the default location `https://root.cern/js/latest/` is specified. One always can install JSROOT on private web server.; When JSROOT is used with THttpServer, the address looks like:. ```javascript; <script type='module'>; import { httpRequest, draw } from 'http://your_root_server:8080/jsrootsys/modules/main.mjs';; let obj = await httpRequest('http://your_root_server:8080/Objects/hist/root.json','object');; await draw('drawing', obj, 'hist');; </script>; ```. Loading main module is enough to get public JSROOT functionality - reading files and drawing objects.; One also can load some special components directly like:. ```javascript; <script type='module'>; import { HierarchyPainter } from 'https://root.cern/js/latest/modules/gui.mjs';. let h = new HierarchyPainter(""example"", ""myTreeDiv"");. // configure 'simple' in provided <div> element; // one also can specify ""grid2x2"" or ""flex"" or ""tabs""; h.setDisplay(""simple"", ""myMainDiv"");. // open file and display element; await h.openRootFile('../../files/hsimple.root');; await h.display('hpxpy;1"",""colz');; </script>; ```. After script loading one can configure different parameters in `gStyle` object.; It is instance of the `TStyle` object and behaves like `gStyle` variable in ROOT. For instance,; to change stat format using to display value in stats box:. ```javascript; import { gStyle } from 'https://root.cern/js/latest/modules/main.mjs';; gStyle.fStatFormat = '7.5g';; ```. There is also `settings` object which contains all other JSROOT settings. For instance,; one can configure custom format for different axes:. ```javascript; import { settings } from 'https://root.cern/js/latest/modules/main.mjs';; settings.XValuesFormat = '4.2g';; settings.YValuesFormat = '6.1f';; ```. One also can use `build/jsroot.js` bundle to load all functionality at one and access it via `JSROOT` global handle:. ```javascript; <script src=""https://root.cern/js/latest/build/j",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/JSROOT/JSROOT.md:35412,simpl,simple,35412,documentation/JSROOT/JSROOT.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/JSROOT/JSROOT.md,1,['simpl'],['simple']
Usability,"Of(hasOverloadedOperatorName(""+""), hasOverloadedOperatorName(""-"")). Matcher<CXXOperatorCallExpr>hasOperatorNamestd::string Name; Matches the operator Name of operator expressions and fold expressions; (binary or unary). Example matches a || b (matcher = binaryOperator(hasOperatorName(""||""))); !(a || b). Example matches `(0 + ... + args)`; (matcher = cxxFoldExpr(hasOperatorName(""+""))); template <typename... Args>; auto sum(Args... args) {; return (0 + ... + args);; }. Matcher<CXXOperatorCallExpr>hasOverloadedOperatorNameStringRef Name; Matches overloaded operator names. Matches overloaded operator names specified in strings without the; ""operator"" prefix: e.g. ""<<"". Given:; class A { int operator*(); };; const A &operator<<(const A &a, const A &b);; A a;; a << a; // <-- This matches. cxxOperatorCallExpr(hasOverloadedOperatorName(""<<""))) matches the; specified line and; cxxRecordDecl(hasMethod(hasOverloadedOperatorName(""*""))); matches the declaration of A. Usable as: Matcher<CXXOperatorCallExpr>, Matcher<FunctionDecl>. Matcher<CXXOperatorCallExpr>isAssignmentOperator; Matches all kinds of assignment operators. Example 1: matches a += b (matcher = binaryOperator(isAssignmentOperator())); if (a == b); a += b;. Example 2: matches s1 = s2; (matcher = cxxOperatorCallExpr(isAssignmentOperator())); struct S { S& operator=(const S&); };; void x() { S s1, s2; s1 = s2; }. Matcher<CXXOperatorCallExpr>isComparisonOperator; Matches comparison operators. Example 1: matches a == b (matcher = binaryOperator(isComparisonOperator())); if (a == b); a += b;. Example 2: matches s1 < s2; (matcher = cxxOperatorCallExpr(isComparisonOperator())); struct S { bool operator<(const S& other); };; void x(S s1, S s2) { bool b1 = s1 < s2; }. Matcher<CXXRecordDecl>hasDefinition; Matches a class declaration that is defined. Example matches x (matcher = cxxRecordDecl(hasDefinition())); class x {};; class y;. Matcher<CXXRecordDecl>isDerivedFromstd::string BaseName; Overloaded method as shortcut for isDe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:72235,Usab,Usable,72235,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['Usab'],['Usable']
Usability,"OverloadedOperatorName(""+""), hasOverloadedOperatorName(""-"")). Matcher<FunctionDecl>hasDynamicExceptionSpec; Matches functions that have a dynamic exception specification. Given:; void f();; void g() noexcept;; void h() noexcept(true);; void i() noexcept(false);; void j() throw();; void k() throw(int);; void l() throw(...);; functionDecl(hasDynamicExceptionSpec()) and; functionProtoType(hasDynamicExceptionSpec()); match the declarations of j, k, and l, but not f, g, h, or i. Matcher<FunctionDecl>hasOverloadedOperatorNameStringRef Name; Matches overloaded operator names. Matches overloaded operator names specified in strings without the; ""operator"" prefix: e.g. ""<<"". Given:; class A { int operator*(); };; const A &operator<<(const A &a, const A &b);; A a;; a << a; // <-- This matches. cxxOperatorCallExpr(hasOverloadedOperatorName(""<<""))) matches the; specified line and; cxxRecordDecl(hasMethod(hasOverloadedOperatorName(""*""))); matches the declaration of A. Usable as: Matcher<CXXOperatorCallExpr>, Matcher<FunctionDecl>. Matcher<FunctionDecl>hasTrailingReturn; Matches a function declared with a trailing return type. Example matches Y (matcher = functionDecl(hasTrailingReturn())); int X() {}; auto Y() -> int {}. Matcher<FunctionDecl>isConsteval; Matches consteval function declarations and if consteval/if ! consteval; statements. Given:; consteval int a();; void b() { if consteval {} }; void c() { if ! consteval {} }; void d() { if ! consteval {} else {} }; functionDecl(isConsteval()); matches the declaration of ""int a()"".; ifStmt(isConsteval()); matches the if statement in ""void b()"", ""void c()"", ""void d()"". Matcher<FunctionDecl>isConstexpr; Matches constexpr variable and function declarations,; and if constexpr. Given:; constexpr int foo = 42;; constexpr int bar();; void baz() { if constexpr(1 > 0) {} }; varDecl(isConstexpr()); matches the declaration of foo.; functionDecl(isConstexpr()); matches the declaration of bar.; ifStmt(isConstexpr()); matches the if statement i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:90239,Usab,Usable,90239,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['Usab'],['Usable']
Usability,"P02c; ### Initializing the Direction. In order to move inside geometry starting with the current point, the; modeller needs to know the current direction `(nx,ny,nz)`. This; direction is stored as `Double_t fCurrentDirection[3]` by the navigator; and it represents a direction in the global frame. It can be retrieved; with:. ~~~{.cpp}; Const Double_t *cdir = gGeoManager->GetCurrentDirection();; ~~~. The direction can be initialized in a similar manner as the current; point:. ~~~{.cpp}; gGeoManager->SetCurrentDirection(nx,ny,nz);; // or:; gGeoManager->SetCurrentDirection(Double_t *dir);; ~~~. \anchor GP02d; ### Initializing the State. Setting the initial point and direction is not enough for initializing; tracking. The modeller needs to find out where the initial point is; located in the geometrical hierarchy. Due to the containment based; architecture of the model, this is the deepest positioned object; containing the point. For illustrating this, imagine that we have a; simple structure with a top volume `A` and another one `B `positioned; inside. Since `A `is a top volume, its associated node `A_1` will define; `MARS` and our simple hierarchy of nodes (positioned volumes) will be:; `/A_1/B_1`. Suppose now that the initial point is contained by `B_1`.; This implies by default that the point is also contained by `A_1`, since; `B_1` have to be fully contained by this. After searching the point; location, the modeller will consider that the point is located inside; `B_1`, which will be considered as the representative object (node) for; the current state. This is stored as: `TGeoNode *TGeoNavigator::%fCurrentNode`; and can be asked from the manager class; only after the `'Where am I?'` was completed:. ~~~{.cpp}; TGeoNode *current = gGeoManager->GetCurrentNode();; ~~~. In order to find the location of the current point inside the hierarchy; of nodes, after setting this point it is mandatory to call the; `‘Where am I?'` method:. ~~~{.cpp}; gGeoManager->FindNode();; ~~~. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:65874,simpl,simple,65874,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['simpl'],['simple']
Usability,"ParallelStartup: no; ```. ``` {.cpp}; Proof.StatsHist: no; Proof.StatsTrace: no; Proof.SlaveStatsTrace: no; ```. ``` {.cpp}; Proof.CondorHome: /opt/condor; Proof.CondorConfig: /opt/condor/etc/condor_config; ```. ``` {.cpp}; PEAC.GmUrl: http://somewhere:8080/clarens/; PEAC.LmUrl: http://elsewhere:8080/clarens/; ```. #### Server Authentication in TServerSocket. General setting: file with server access rules. ``` {.cpp}; SrvAuth.DaemonRc: /etc/root/system.daemonrc; ```. Check of host equivalence via `/etc/hosts`.`equiv` or `$HOME/.rhosts`. ``` {.cpp}; SrvAuth.CheckHostsEquivalence: 1; ```. Force file opening via **`TNetFile`** (**`TNetXNGFile`**) if a hostname is; specified in the Url. By default, for local files `TFile::Open()`; invokes directly **`TFile.`**. ``` {.cpp}; TFile.ForceRemote: yes; ```. Special cases for the **`TUrl`** parser, where the special cases are; parsed in a protocol + file part, like rfio:host:/path/file.root,; castor:/path/file.root or /alien/path/file.root. In case the file; namespace descriptor ends with - the namespace is not a part of the; filename. Extend in private .rootrc with a +Url.Special line. ``` {.cpp}; Url.Special: file: rfio: hpss: castor: dcache:; +Url.Special: /alien/- /castor/; ```. #### PROOF XRD Client Variables. Debug level (if \<=0 : none, 1 : low, 2 : medium, 3 : high). ``` {.cpp}; XProof.Debug: 0; ```. Socket read timeout [in secs: default 10 secs]. ``` {.cpp}; XProof.ReadTimeout: 10; ```. `XNet.PrintTAG` - Print a particular string the developers can choose to; quickly recognize the version at run time [default - 0]. Example of custom setting for the Rint application (root.exe). This; overrides the default specified above for a generic application. Color 5; is yellow. ``` {.cpp}; Rint.Canvas.HighLightColor: 5; ```. ## Documentation to Download. - The latest ROOT Users Guide. - <https://root.cern.ch/root/htmldoc/guides/users-guide/ROOTUsersGuide.html>. - ROOT Reference Guide. - <http://root.cern.ch/root/Reference.html>. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InstallandBuild.md:15635,Guid,Guide,15635,documentation/users-guide/InstallandBuild.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InstallandBuild.md,4,"['Guid', 'guid']","['Guide', 'guide', 'guides']"
Usability,"ParenExpr();; }; }. Now that you see the definition of this function, it is more obvious why; we can assume the state of CurTok in the various functions. This uses; look-ahead to determine which sort of expression is being inspected, and; then parses it with a function call. Now that basic expressions are handled, we need to handle binary; expressions. They are a bit more complex. Binary Expression Parsing; =========================. Binary expressions are significantly harder to parse because they are; often ambiguous. For example, when given the string ""x+y\*z"", the parser; can choose to parse it as either ""(x+y)\*z"" or ""x+(y\*z)"". With common; definitions from mathematics, we expect the later parse, because ""\*""; (multiplication) has higher *precedence* than ""+"" (addition). There are many ways to handle this, but an elegant and efficient way is; to use `Operator-Precedence; Parsing <http://en.wikipedia.org/wiki/Operator-precedence_parser>`_.; This parsing technique uses the precedence of binary operators to guide; recursion. To start with, we need a table of precedences:. .. code-block:: c++. /// BinopPrecedence - This holds the precedence for each binary operator that is; /// defined.; static std::map<char, int> BinopPrecedence;. /// GetTokPrecedence - Get the precedence of the pending binary operator token.; static int GetTokPrecedence() {; if (!isascii(CurTok)); return -1;. // Make sure it's a declared binop.; int TokPrec = BinopPrecedence[CurTok];; if (TokPrec <= 0) return -1;; return TokPrec;; }. int main() {; // Install standard binary operators.; // 1 is lowest precedence.; BinopPrecedence['<'] = 10;; BinopPrecedence['+'] = 20;; BinopPrecedence['-'] = 20;; BinopPrecedence['*'] = 40; // highest.; ...; }. For the basic form of Kaleidoscope, we will only support 4 binary; operators (this can obviously be extended by you, our brave and intrepid; reader). The ``GetTokPrecedence`` function returns the precedence for; the current token, or -1 if the token is not a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst:12692,guid,guide,12692,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst,1,['guid'],['guide']
Usability,"Probing /cvmfs/sft.cern.ch... OK. > You might need special configurations for some custom software; > repositories! Special cases are not covered in this guide. ### Firewall configuration. [PROOF on Demand](http://pod.gsi.de/) is very flexible in handling; various cases of network topologies. The best solution would be to allow; all TCP communications between the cluster machines. No other incoming communication is required from the outside. Configuration steps for the head node only; ------------------------------------------. ### Setup HTTPS+SSH (sshcertauth) authentication. > Latest recommended sshcertauth version is 0.8.5.; >; > [Download](https://github.com/dberzano/sshcertauth/archive/v0.8.5.zip); > and [read the; > instructions](http://newton.ph.unito.it/~berzano/w/doku.php?id=proof:sshcertauth). If you want your users to connect to the PROOF cluster using their Grid; user certificate and private key you might be interested in installing; sshcertauth. Please refer to the [installation; guide](http://newton.ph.unito.it/~berzano/w/doku.php?id=proof:sshcertauth); for further information. ### PROOF on Demand. > Latest recommended PROOF on Demand version is 3.12.; >; > **On CernVM-FS:** `/cvmfs/sft.cern.ch/lcg/external/PoD/3.12`; >; > **Source code:** [PoD download page](http://pod.gsi.de/download.html); > and [Installation; > instructions](http://pod.gsi.de/doc/3.12/Installation.html). [PROOF on Demand](http://pod.gsi.de/) is required on the head node and on the; user's client. In case your experiment provides a version of PoD on CernVM-FS you can use; that one. Experiment-independent versions are available from the PH-SFT; cvmfs repository. Only if you have specific reasons while you want to use a customly built; PoD version, download the source code and compile it using the; installation instructions. Please note that [CMake](http://www.cmake.org/) and; [Boost](http://www.boost.org/) are required to build PoD. - After you have built PoD, install it with:. make i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/ConfigProofPoD.md:4516,guid,guide,4516,proof/doc/confman/ConfigProofPoD.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/ConfigProofPoD.md,1,['guid'],['guide']
Usability,"Proof(10000,"""") ; // execute 10000 toys through PROOF-lite. gfs.summaryData()->Print() ;. Workspace and factory improvements. The workspace class RooWorkspace has been augmented with several; new features. The import() method now supports a new argument RenameAllVariablesExcept(const char* suffix, const char keepList) which; will rename all variables of the imported function by extended them with a supplied suffix,; except for a given list of variables, which are not renamed.; A new utility function importFromFile() has been added, which is similar to import, except that it take a string; specifier for the object to be imported rather than a reference. The string is expected to be of the form ; fileName:workspaceName:objectName and simplifies import of objects from other workspaces on file. The importFromFile; accepts all arguments accepted by the standard import() method.; Generic objects (inheriting from TObject) can now also be stored in the workspace under an alias name, rather; under their own name, which simplifies management of objects of types like TMatrixD that do not have a settable name. ws.import(matrix,""cov_matrix"") ;. New accessors have been added that return a RooArgSet of all elements of the workspace of a given type, e.g.; allVars(), allPdfs(). The Print() method now accepts option ""t"", which prints the contents tree-style instead of a flat list of components,; as illustrated below. *** Print() ***. p.d.f.s; -------; RooProdPdf::bkg[ ptBkgPdf * mllBkgPdf * effBkgPdf|pt ] = 0.267845; RooEfficiency::effBkgPdf[ cat=cut effFunc=effBkg ] = 0.76916; RooEfficiency::effSigPdf[ cat=cut effFunc=effSig ] = 0.899817; RooAddPdf::genmodel[ Nsig * sig + Nbkg * bkg ] = 0.502276; RooPolynomial::mllBkgPdf[ x=mll coefList=(mbkg_slope) ] = 0.775; RooGaussian::mllSigPdf[ x=mll mean=msig_mean sigma=msig_sigma ] = 1; RooExponential::ptBkgPdf[ x=pt c=pbkg_slope ] = 0.449329; RooExponential::ptSigPdf[ x=pt c=psig_slope ] = 0.818731; RooProdPdf::sig[ ptSigPdf * mllSigPdf * e",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v526/index.html:2715,simpl,simplifies,2715,roofit/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v526/index.html,1,['simpl'],['simplifies']
Usability,"R (note that; this dump is generated with optimizations disabled for clarity):. .. code-block:: llvm. declare double @putchard(double). define double @printstar(double %n) {; entry:; ; initial value = 1.0 (inlined into phi); br label %loop. loop: ; preds = %loop, %entry; %i = phi double [ 1.000000e+00, %entry ], [ %nextvar, %loop ]; ; body; %calltmp = call double @putchard(double 4.200000e+01); ; increment; %nextvar = fadd double %i, 1.000000e+00. ; termination test; %cmptmp = fcmp ult double %i, %n; %booltmp = uitofp i1 %cmptmp to double; %loopcond = fcmp one double %booltmp, 0.000000e+00; br i1 %loopcond, label %loop, label %afterloop. afterloop: ; preds = %loop; ; loop always returns 0.0; ret double 0.000000e+00; }. This loop contains all the same constructs we saw before: a phi node,; several expressions, and some basic blocks. Let's see how this fits; together. Code Generation for the 'for' Loop; ----------------------------------. The first part of codegen is very simple: we just output the start; expression for the loop value:. .. code-block:: c++. Value *ForExprAST::codegen() {; // Emit the start code first, without 'variable' in scope.; Value *StartVal = Start->codegen();; if (!StartVal); return nullptr;. With this out of the way, the next step is to set up the LLVM basic; block for the start of the loop body. In the case above, the whole loop; body is one block, but remember that the body code itself could consist; of multiple blocks (e.g. if it contains an if/then/else or a for/in; expression). .. code-block:: c++. // Make the new basic block for the loop header, inserting after current; // block.; Function *TheFunction = Builder->GetInsertBlock()->getParent();; BasicBlock *PreheaderBB = Builder->GetInsertBlock();; BasicBlock *LoopBB =; BasicBlock::Create(*TheContext, ""loop"", TheFunction);. // Insert an explicit fall through from the current block to the LoopBB.; Builder->CreateBr(LoopBB);. This code is similar to what we saw for if/then/else. Because we ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst:20443,simpl,simple,20443,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst,1,['simpl'],['simple']
Usability,"R9 Processor User's Manual <https://openpowerfoundation.org/?resource_lib=power9-processor-users-manual>`_. * `Power Instruction Set Architecture, Version 2.07B <https://openpowerfoundation.org/?resource_lib=ibm-power-isa-version-2-07-b>`_. * `POWER8 Processor User's Manual <https://openpowerfoundation.org/?resource_lib=power8-processor-users-manual>`_. * `Power Instruction Set Architecture, Versions 2.03 through 2.06 (Internet Archive) <https://web.archive.org/web/20121124005736/https://www.power.org/technology-introduction/standards-specifications>`_. * `IBM AIX 7.2 POWER Assembly Reference <https://www.ibm.com/support/knowledgecenter/en/ssw_aix_72/assembler/alangref_kickoff.html>`_. * `IBM AIX/5L for POWER Assembly Reference <http://publibn.boulder.ibm.com/doc_link/en_US/a_doc_lib/aixassem/alangref/alangreftfrm.htm>`_. Embedded PowerPC Processors manuals and docs; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. * `Book E: Enhanced PowerPC Architecture <https://www.nxp.com/docs/en/user-guide/BOOK_EUM.pdf>`_. * `EREF: A Programmer's Reference Manual for Freescale Embedded Processors (EREFRM) <https://www.nxp.com/files-static/32bit/doc/ref_manual/EREF_RM.pdf>`_. * `Signal Processing Engine (SPE) Programming Environments Manual: A Supplement to the EREF <https://www.nxp.com/docs/en/reference-manual/SPEPEM.pdf>`_. * `Variable-Length Encoding (VLE) Programming Environments Manual: A Supplement to the EREF <https://www.nxp.com/docs/en/reference-manual/VLEPEM.pdf>`_. Other documents, collections, notes; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. * `PowerPC Compiler Writer's Guide <http://www.ibm.com/chips/techlib/techlib.nsf/techdocs/852569B20050FF7785256996007558C6>`_; * `Intro to PowerPC Architecture <http://www.ibm.com/developerworks/linux/library/l-powarch/>`_; * `Various IBM specifications and white papers <https://www.power.org/documentation/?document_company=105&document_category=all&publish_year=all&grid_order=DESC&grid_sort=title>`_; * `PowerPC ABI documents <http://pen",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CompilerWriterInfo.rst:3237,guid,guide,3237,interpreter/llvm-project/llvm/docs/CompilerWriterInfo.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CompilerWriterInfo.rst,1,['guid'],['guide']
Usability,"R; ========================================. .. contents::; :local:. Chapter 3 Introduction; ======================. Welcome to Chapter 3 of the ""`Implementing a language with; LLVM <index.html>`_"" tutorial. This chapter shows you how to transform; the `Abstract Syntax Tree <LangImpl02.html>`_, built in Chapter 2, into; LLVM IR. This will teach you a little bit about how LLVM does things, as; well as demonstrate how easy it is to use. It's much more work to build; a lexer and parser than it is to generate LLVM IR code. :). **Please note**: the code in this chapter and later require LLVM 3.7 or; later. LLVM 3.6 and before will not work with it. Also note that you; need to use a version of this tutorial that matches your LLVM release:; If you are using an official LLVM release, use the version of the; documentation included with your release or on the `llvm.org releases; page <https://llvm.org/releases/>`_. Code Generation Setup; =====================. In order to generate LLVM IR, we want some simple setup to get started.; First we define virtual code generation (codegen) methods in each AST; class:. .. code-block:: c++. /// ExprAST - Base class for all expression nodes.; class ExprAST {; public:; virtual ~ExprAST() = default;; virtual Value *codegen() = 0;; };. /// NumberExprAST - Expression class for numeric literals like ""1.0"".; class NumberExprAST : public ExprAST {; double Val;. public:; NumberExprAST(double Val) : Val(Val) {}; Value *codegen() override;; };; ... The codegen() method says to emit IR for that AST node along with all; the things it depends on, and they all return an LLVM Value object.; ""Value"" is the class used to represent a ""`Static Single Assignment; (SSA) <http://en.wikipedia.org/wiki/Static_single_assignment_form>`_; register"" or ""SSA value"" in LLVM. The most distinct aspect of SSA values; is that their value is computed as the related instruction executes, and; it does not get a new value until (and if) the instruction re-executes.; In other",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst:1089,simpl,simple,1089,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst,1,['simpl'],['simple']
Usability,"RNTuple Introduction; ====================. RNTuple (for n-tuple and nested tuple) is the experimental evolution of TTree columnar data storage. RNTuple introduces; new interfaces that aim to be more robust. In particular, the new interfaces are type-safe through the use of; templates, and the ownership is well-defined through the use of smart pointers. For instance. tree->Branch(""px"", &Category, ""px/F"");. becomes. auto px = model->MakeField<float>(""px"");; // px is std::shared_ptr<float>. The physical layout changes slightly from big endian to little endian so that it matches the in-memory layout on; most modern architectures. Combined with a clear separation of offset/index data and payload data for collections,; uncompressed RNTuple data can be directly mapped to memory without further copies. Goals; -----. RNTuple shall investigate improvements of the TTree I/O in the following ways. 1. More speed; * Improve mapping to vectorized and parallel hardware; * For types known at compile / JIT time: generate optimized code; * Optimized for simple types (float, int, and vectors of them); * Better memory control: work with a fixed budget of pre-defined I/O buffers; * Naturally thread-safe and asynchronous interfaces. 2. More robust interfaces; * Compile-time type safety by default; * Decomposition into layers: logical layer, primitives layer, storage layer; * Separation of data model and live data; * Self-contained I/O code to support creation of a standalone I/O library. Concepts; --------. At the **logical layer**, the user defines a data model using the RNTupleModel class.; The data model is a collection of serializable C++ types with associated names, similar to branches in a TTree.; The data model can contain (nested) collections, e.g., a type can be `std::vector<std::vector<float>>`. Each serializable type is represented by a **field**, concretely by a templated version of RField,; e.g. `RField<double>`. A field can generate or adopt an associated **value**, which re",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/README.md:651,clear,clear,651,tree/ntuple/v7/doc/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/README.md,1,['clear'],['clear']
Usability,"ROOT. Since it is an extension module, the usage of `PyROOT` probably comes; naturally if you're used to Python. In general, `PyROOT` attempts to; allow working in both Python and ROOT style, and although it is; succeeding, it isn't perfect: there are edges. The following sections; explain in some detail what you can expect, and what you need to watch; out for. #### Access to ROOT Classes. Before a ROOT class can be used from Python, its dictionary needs to be; loaded into the current process. Starting with ROOT version 4.00/06,; this happens automatically for all classes that are declared to the; auto-loading mechanism through so-called `rootmap` files. Effectively,; this means that all classes in the ROOT distributions are directly; available for import. For example:. ``` {.cpp}; from ROOT import TCanvas # available at startup; c = TCanvas(). from ROOT import TLorentzVector # triggers auto-load of libPhysics; l = TLorentzVector(); ```. Although it is not recommended, a simple way of working with `PyROOT` is; doing a global import:. ``` {.cpp}; from ROOT import *. c = TCanvas(); l = TLorentzVector(); ```. Keeping the ROOT namespace (""`import ROOT`""), or only importing from; ROOT those classes that you will actually use (see above), however, will; always be cleaner and clearer:. ``` {.cpp}; import ROOT. c = ROOT.TCanvas(); l = ROOT.TLorentzVector(); ```. Since it is foreseen that most people will use the simple approach; anyway, the request to copy all from module ROOT will not actually; result in copying all ROOT classes into the current namespace. Instead,; classes will still be bound (and possibly loaded) on an as-needed basis.; Note carefully how this is different from other Python (extension); modules, and what to expect if you use the normal inspection tools (such; as e.g. '`dir()`'). This feature prevents the inspection tools from; being swamped by an enormous amount of classes, but they can no longer; be used to explore unknown parts of the system (e.g. to f",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:9984,simpl,simple,9984,documentation/users-guide/PythonRuby.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md,1,['simpl'],['simple']
Usability,"RSE tutorials_rcanvas RELATIVE ${CMAKE_CURRENT_SOURCE_DIR} rcanvas/*.cxx); list(APPEND tutorials ${tutorials_rcanvas}); endif(); file(GLOB tutorials_veto RELATIVE ${CMAKE_CURRENT_SOURCE_DIR} ${all_veto}). list(LENGTH tutorials nTotal); list(REMOVE_ITEM tutorials ${tutorials_veto}); list(LENGTH tutorials nAfterVeto); message(STATUS ""${nAfterVeto}/${nTotal} C++ tutorials have been activated.""). if(mpi); set (temp_list ${tutorials}); list(FILTER tutorials INCLUDE REGEX ""MPI""); set(mpi_tutorials ${tutorials}); set(tutorials ${temp_list}); list(REMOVE_ITEM tutorials ${mpi_tutorials}); endif(). #---Special return code------------------------------------------------; set(returncode_1 fit/fit2a.C; graphics/earth.C; graphics/pavetext.C; graphics/tmathtext.C graphics/tmathtext2.C; graphs/exclusiongraph.C; graphs/graphstruct.C; hist/ContourList.C; hist/hbars.C; hist/th2polyBoxes.C; hist/statsEditing.C; hist/cumulative.C; hist/hlabels1.C; hist/hlabels2.C; tree/h1analysis.C; math/chi2test.C; r/SimpleFitting.C); #---Dependencies------------------------------------------------------; set(unfold-testUnfold5d-depends tutorial-unfold-testUnfold5c); set(unfold-testUnfold5c-depends tutorial-unfold-testUnfold5b); set(unfold-testUnfold5b-depends tutorial-unfold-testUnfold5a); set(unfold-testUnfold7d-depends tutorial-unfold-testUnfold7c); set(unfold-testUnfold7c-depends tutorial-unfold-testUnfold7b); set(unfold-testUnfold7b-depends tutorial-unfold-testUnfold7a); set(xml-xmlmodifyfile-depends tutorial-xml-xmlnewfile); set(xml-xmlreadfile-depends tutorial-xml-xmlnewfile); set(roofit-rf503_wspaceread-depends tutorial-roofit-rf502_wspacewrite); set(io-readCode-depends tutorial-io-importCode); set(fit-fit1-depends tutorial-hist-fillrandom); set(fit-myfit-depends tutorial-fit-fitslicesy); set(foam-foam_demopers-depends tutorial-foam-foam_demo); set(tree-staff-depends tutorial-tree-cernbuild); set(tree-cernstaff-depends tutorial-tree-cernbuild); set(hist-hbars-depends tutorial-tree-cernbuild); se",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/CMakeLists.txt:16617,Simpl,SimpleFitting,16617,tutorials/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/CMakeLists.txt,1,['Simpl'],['SimpleFitting']
Usability,"Run preprocessor stage.""),; cl::cat(StageSelectionCat));. cl::opt<bool> NoLink(""c"",cl::desc(""Run all stages except linking.""),; cl::cat(StageSelectionCat));. The output of ``-help`` will become categorized if an option category is; declared. The output looks something like ::. OVERVIEW: This is a small program to demo the LLVM CommandLine API; USAGE: Sample [options]. OPTIONS:. General options:. -help - Display available options (-help-hidden for more); -help-list - Display list of available options (-help-list-hidden for more). Stage Selection Options:; These control which stages are run. -E - Run preprocessor stage.; -c - Run all stages except linking. In addition to the behaviour of ``-help`` changing when an option category is; declared, the command line option ``-help-list`` becomes visible which will; print the command line options as uncategorized list. Note that Options that are not explicitly categorized will be placed in the; ``cl::getGeneralCategory()`` category. .. _Reference Guide:. Reference Guide; ===============. Now that you know the basics of how to use the CommandLine library, this section; will give you the detailed information you need to tune how command line options; work, as well as information on more ""advanced"" command line option processing; capabilities. .. _positional:; .. _positional argument:; .. _Positional Arguments:; .. _Positional arguments section:; .. _positional options:. Positional Arguments; --------------------. Positional arguments are those arguments that are not named, and are not; specified with a hyphen. Positional arguments should be used when an option is; specified by its position alone. For example, the standard Unix ``grep`` tool; takes a regular expression argument, and an optional filename to search through; (which defaults to standard input if a filename is not specified). Using the; CommandLine library, this would be specified as:. .. code-block:: c++. cl::opt<string> Regex (cl::Positional, cl::desc(""<regular exp",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst:25773,Guid,Guide,25773,interpreter/llvm-project/llvm/docs/CommandLine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst,1,['Guid'],['Guide']
Usability,"SCN_CNT_UNINITIALIZED_DATA; , IMAGE_SCN_LNK_OTHER; , IMAGE_SCN_LNK_INFO; , IMAGE_SCN_LNK_REMOVE; , IMAGE_SCN_LNK_COMDAT; , IMAGE_SCN_GPREL; , IMAGE_SCN_MEM_PURGEABLE; , IMAGE_SCN_MEM_16BIT; , IMAGE_SCN_MEM_LOCKED; , IMAGE_SCN_MEM_PRELOAD; , IMAGE_SCN_ALIGN_1BYTES; , IMAGE_SCN_ALIGN_2BYTES; , IMAGE_SCN_ALIGN_4BYTES; , IMAGE_SCN_ALIGN_8BYTES; , IMAGE_SCN_ALIGN_16BYTES; , IMAGE_SCN_ALIGN_32BYTES; , IMAGE_SCN_ALIGN_64BYTES; , IMAGE_SCN_ALIGN_128BYTES; , IMAGE_SCN_ALIGN_256BYTES; , IMAGE_SCN_ALIGN_512BYTES; , IMAGE_SCN_ALIGN_1024BYTES; , IMAGE_SCN_ALIGN_2048BYTES; , IMAGE_SCN_ALIGN_4096BYTES; , IMAGE_SCN_ALIGN_8192BYTES; , IMAGE_SCN_LNK_NRELOC_OVFL; , IMAGE_SCN_MEM_DISCARDABLE; , IMAGE_SCN_MEM_NOT_CACHED; , IMAGE_SCN_MEM_NOT_PAGED; , IMAGE_SCN_MEM_SHARED; , IMAGE_SCN_MEM_EXECUTE; , IMAGE_SCN_MEM_READ; , IMAGE_SCN_MEM_WRITE; ]; - type: int; SectionData: {type: str}; symbols:; type: seq; sequence:; - type: map; mapping:; Name: {type: str}; Value: {type: int}; SectionNumber: {type: int}; SimpleType: [ {type: str, enum: [ IMAGE_SYM_TYPE_NULL; , IMAGE_SYM_TYPE_VOID; , IMAGE_SYM_TYPE_CHAR; , IMAGE_SYM_TYPE_SHORT; , IMAGE_SYM_TYPE_INT; , IMAGE_SYM_TYPE_LONG; , IMAGE_SYM_TYPE_FLOAT; , IMAGE_SYM_TYPE_DOUBLE; , IMAGE_SYM_TYPE_STRUCT; , IMAGE_SYM_TYPE_UNION; , IMAGE_SYM_TYPE_ENUM; , IMAGE_SYM_TYPE_MOE; , IMAGE_SYM_TYPE_BYTE; , IMAGE_SYM_TYPE_WORD; , IMAGE_SYM_TYPE_UINT; , IMAGE_SYM_TYPE_DWORD; ]}; , {type: int}; ]; ComplexType: [ {type: str, enum: [ IMAGE_SYM_DTYPE_NULL; , IMAGE_SYM_DTYPE_POINTER; , IMAGE_SYM_DTYPE_FUNCTION; , IMAGE_SYM_DTYPE_ARRAY; ]}; , {type: int}; ]; StorageClass: [ {type: str, enum:; [ IMAGE_SYM_CLASS_END_OF_FUNCTION; , IMAGE_SYM_CLASS_NULL; , IMAGE_SYM_CLASS_AUTOMATIC; , IMAGE_SYM_CLASS_EXTERNAL; , IMAGE_SYM_CLASS_STATIC; , IMAGE_SYM_CLASS_REGISTER; , IMAGE_SYM_CLASS_EXTERNAL_DEF; , IMAGE_SYM_CLASS_LABEL; , IMAGE_SYM_CLASS_UNDEFINED_LABEL; , IMAGE_SYM_CLASS_MEMBER_OF_STRUCT; , IMAGE_SYM_CLASS_ARGUMENT; , IMAGE_SYM_CLASS_STRUCT_TAG; , IMAGE_SYM_CLASS_MEMBER_OF_",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/yaml2obj.rst:5689,Simpl,SimpleType,5689,interpreter/llvm-project/llvm/docs/yaml2obj.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/yaml2obj.rst,1,['Simpl'],['SimpleType']
Usability,"SVDUnfold class; TSVDUnfold implements the singular value decomposition based; unfolding method proposed in NIM A372, 469 (1996); [hep-ph/9509307]. The regularisation is implemented as; a discrete minimum curvature condition. This minimal implementation of; TSVDUnfold provides unfolding of one-dimensional histograms with; equal number of, not necessarily equidistant, bins in the measured and; unfolded distributions. In addition to the unfolding itself,; TSVDUnfold provides. Propagation of covariance matrices from the measured to the unfolded; spectrum via GetUnfoldCovMatrix; Evaluation of covariance matrix due to finite statistics in detector; response via GetAdetCovMatrix; Access to distribution of |d_i| useful for determining the proper; regularisation via GetD; Access to singular values via GetSV. A toy example for the use of TSVDUnfold is included in the math; tutorials (TSVDUnfoldExample.C). New TH2Poly class; TH2Poly is a 2D Histogram class, inheriting from TH2,; allowing to define polygonal bins of arbitary shape. Each bin, in a TH2Poly histogram, is a TH2PolyBin object.; TH2PolyBin is a very simple class containing the vertices, stored; as TGraphs and TMultiGraphs, and the content of the polygonal; bin. Bins are defined using one of the AddBin() methods. The bins definition; should be done before filling. TH2Poly implements a partitioning algorithm to speed up bins' filling.; The following very simple macro shows how to build and fill a TH2Poly:. {; TH2Poly *h2p = new TH2Poly();. Double_t x1[] = {0, 5, 5};; Double_t y1[] = {0, 0, 5};; Double_t x2[] = {0, -1, -1, 0};; Double_t y2[] = {0, 0, -1, -1};; Double_t x3[] = {4, 3, 0, 1, 2.4};; Double_t y3[] = {4, 3.7, 1, 4.7, 3.5};. h2p->AddBin(3, x1, y1);; h2p->AddBin(3, x2, y2);; h2p->AddBin(3, x3, y3);. h2p->Fill( 3, 1, 3); // fill bin 1; h2p->Fill(-0.5, -0.5, 7); // fill bin 2; h2p->Fill(-0.7, -0.5, 1); // fill bin 2; h2p->Fill( 1, 3, 5); // fill bin 3; }. More examples can be found in $ROOTSYS/tutorials/hist/:. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v528/index.html:12685,simpl,simple,12685,hist/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v528/index.html,2,['simpl'],['simple']
Usability,"S_TO_BUILD; Set this equal to the target you wish to build. You may wish to set this to; X86; however, you will find a full list of targets within the; llvm-project/llvm/lib/Target directory. * -DLLVM_OPTIMIZED_TABLEGEN; Set this to ON to generate a fully optimized tablegen during your build. This; will significantly improve your build time. This is only useful if you are; using the Debug build type. * -DLLVM_ENABLE_PROJECTS; Set this equal to the projects you wish to compile (e.g. clang, lld, etc.) If; compiling more than one project, separate the items with a semicolon. Should; you run into issues with the semicolon, try surrounding it with single quotes. * -DLLVM_ENABLE_RUNTIMES; Set this equal to the runtimes you wish to compile (e.g. libcxx, libcxxabi, etc.); If compiling more than one runtime, separate the items with a semicolon. Should; you run into issues with the semicolon, try surrounding it with single quotes. * -DCLANG_ENABLE_STATIC_ANALYZER; Set this option to OFF if you do not require the clang static analyzer. This; should improve your build time slightly. * -DLLVM_USE_SPLIT_DWARF; Consider setting this to ON if you require a debug build, as this will ease; memory pressure on the linker. This will make linking much faster, as the; binaries will not contain any of the debug information; however, this will; generate the debug information in the form of a DWARF object file (with the; extension .dwo). This only applies to host platforms using ELF, such as Linux. .. _links:. Links; =====. This document is just an **introduction** on how to use LLVM to do some simple; things... there are many more interesting and complicated things that you can do; that aren't documented here (but we'll gladly accept a patch if you want to; write something up!). For more information about LLVM, check out:. * `LLVM Homepage <https://llvm.org/>`_; * `LLVM Doxygen Tree <https://llvm.org/doxygen/>`_; * `Starting a Project that Uses LLVM <https://llvm.org/docs/Projects.html>`_; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst:47204,simpl,simple,47204,interpreter/llvm-project/llvm/docs/GettingStarted.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst,1,['simpl'],['simple']
Usability,"Selector to process tree friends. Example of TSelector implementation to process tree friends in PROOF.; See tutorials/proof/runProof.C, option ""eventproc"", for; an example of how to run this selector. \defgroup tutorial_ProofNtuple ProofNtuple; \ingroup tutorial_proof; \brief Selector to fill a simple ntuple. Example of TSelector implementation to do generic processing; (filling a simple ntuple, in this case).; See tutorials/proof/runProof.C, option ""ntuple"", for an; example of how to run this selector. \defgroup tutorial_ProofPythia ProofPythia; \ingroup tutorial_proof; \brief Selector to generate Monte Carlo events with Pythia8. Example of TSelector implementation to do a Monte Carlo; generation using Pythia8.; See tutorials/proof/runProof.C, option ""pythia8"", for an; example of how to run this selector. \defgroup tutorial_ProofSimple ProofSimple; \ingroup tutorial_proof; \brief Selector to fill a set of histograms. Example of TSelector implementation to do generic processing (filling a; set of histograms in this case).; See tutorials/proof/runProof.C, option ""simple"", for an; example of how to run this selector. \defgroup tutorial_ProofSimpleFile ProofSimpleFile; \ingroup tutorial_proof; \brief Selector to fill a set of histograms and merging via file. Example of TSelector implementation to do generic processing; (filling a set of histograms in this case) and merging via; a file, with part of the objects saved in a sub-directory.; See tutorials/proof/runProof.C, option ""simplefile"", for an; example of how to run this selector. \defgroup tutorial_ProofStdVec ProofStdVec; \ingroup tutorial_proof; \brief Selector for generic processing with stdlib collections. Example of TSelector implementation to do generic; processing with stdlib collections.; See tutorials/proof/runProof.C, option ""stdlib"", for an; example of how to run this selector. \defgroup tutorial_ProofTests ProofTests; \ingroup tutorial_proof; \brief Auxilliary selector used to test PROOF functionality; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/proof/index.md:2137,simpl,simple,2137,tutorials/proof/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/proof/index.md,2,['simpl'],"['simple', 'simplefile']"
Usability,"SetDepthLocal() has been added to provide the same; functionality. This allows for the 2d/3d check to be done in place only.; New projection class has been introduced: TEve3DProjection.; It performs pre-scaling and offsets the center.; To simplify the projection of lists TEveElementList has been made; projectable and corresponding TEveElementListProjected class; introduced. This also fixed the problem with render-state not being; propagated to projected classes. The check whether to project a sub-tree of elements is still performed.; TEveGeoShapeProjected has been introduced to represent the 3D; projection of a TEveGeoShape (2D projection is handled by; TEvePolygonSetProjected). Points, lines and tracks use the same projected class for both 2D; and 3D projections. An example showing this functionality has been added as a new tab in; projection_prescale.C.; TEveManager now allows simultaneous usage of several objects; editors. Simply click on the top name-button in object editor to; create a standalone editor for this object in a separate window. This; facilitates operation when several objects need to be modifed in; parallel.; New tutorial alice_vsd.C has been added. It shows; how to read Visualization Summary Data files (VSD).; Code for operating three view configuration (3D / RPhi / Rhoz); has been extracted from alice_esd.C tutorial; into MultiView.C tutorial. This is now also used; by alice_vsd.C and can serve as an example to those that; need to implement similar functionality. Screenshot of calorimeters.C tutorial. Note the; individual tower selection propagated accross all the views. Screenshot of alice_vsd.C tutorial also showing the; functionality of the MultiView class. New title is also; visible in the GUI editor. Minor changes. Object editors in Eve now show the title as button.; ; Left mouse opens a floating editor that can be positioned; anywhere on the screen. This allows a user to have commonly used; editors always accessible. Maximum number of float",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/doc/v526/index.html:3279,Simpl,Simply,3279,graf3d/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/doc/v526/index.html,1,['Simpl'],['Simply']
Usability,"Setup a static PROOF cluster with PROOF on Demand; =================================================. Introduction; ------------. Using PROOF on Demand is our current recommended way of running a PROOF; cluster. The usage of PoD is in particular helpful for the following; reasons:. - **Sandboxing.** Each user get their own personal PROOF cluster,; separated from the others: a problem occurring on one personal; cluster does not affect the workflow of other users. - **Easier administration and self-servicing.** A user can restart their; personal PROOF cluster in case of troubles without waiting for a; system administrator's intervention. - **Efficient multiuser scheduling.** PROOF on Demand makes PROOF run on; top of an existing resource management system, moving the problem of; scheduling many concurrent users outside of PROOF. This guide particularly refers to the setup of a static PROOF cluster; running on physical hosts: the recommended setup is in practice the same; as the ready-to-go Virtual Analysis Facility. If you want to use PROOF; on the clouds there is no configuration to go through. Setup a resource management system; ----------------------------------. Although PROOF on Demand can run on a cluster of nodes without using a; resource management system (using `pod-ssh`), it is recommended to setup a; dedicated one to benefit from the scheduling in a multiuser environment, or a; dedicated queue on an existing one. As there's a variety of resource management systems, this guide does not cover; their setup. The RMS preconfigured for the Virtual Analysis Facility is; [HTCondor](http://research.cs.wisc.edu/htcondor/), which we recommend primarily; because it has dynamic addition of workers built in. Configuration steps for all nodes; ---------------------------------. ### Setup CernVM-FS. [CernVM-FS](http://cernvm.cern.ch/portal/filesystem) should be installed; on all machines as the preferred method for software distribution. > Configuration instructions for the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/ConfigProofPoD.md:844,guid,guide,844,proof/doc/confman/ConfigProofPoD.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/ConfigProofPoD.md,1,['guid'],['guide']
Usability,"Simulation of expected data is another important aspect in data; analysis. By repeated generation of ""pseudo-data"", which are analysed in; the same manner as intended for the real data, analysis procedures can; be validated or compared. In many cases, the distribution of the; measurement errors is not precisely known, and simulation offers the; possibility to test the effects of different assumptions. A powerful software framework addressing all of the above requirements; is ROOT, an open source project coordinated by the European Organisation for; Nuclear Research, CERN in Geneva. ROOT is very flexible and provides both a programming interface to use in own; applications and a graphical user interface for interactive data analysis. The; purpose of this document is to serve as a beginners guide and provides extendable; examples for your own use cases, based on typical problems addressed in; student labs. This guide will hopefully lay the ground for more complex; applications in your future scientific work building on a modern,; state-of the art tool for data analysis. This guide in form of a tutorial is intended to introduce you quickly to the; ROOT package. This goal will be accomplished using concrete examples, according; to the ""learning by doing"" principle. Also because of this reason, this guide; cannot cover all the complexity of the ROOT package. Nevertheless, once you feel; confident with the concepts presented in the following chapters, you will be; able to appreciate the ROOT Users Guide [@ROOT_Users_Guide] and navigate through; the Class Reference [@ROOT_Class_Reference] to find all the details you might be; interested in. You can even look at the code itself, since ROOT is a; free, open-source product. Use these documents in parallel to this; tutorial!. The ROOT Data Analysis Framework itself is written in and heavily relies; on the `C++` programming language: some knowledge about `C++` is required.; Jus take advantage from the immense available literatur",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/Introduction.md:3484,guid,guide,3484,documentation/primer/Introduction.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/Introduction.md,1,['guid'],['guide']
Usability,"Support/``. ``llvm/bindings``; ----------------------. Contains bindings for the LLVM compiler infrastructure to allow; programs written in languages other than C or C++ to take advantage of the LLVM; infrastructure.; LLVM project provides language bindings for OCaml and Python. ``llvm/projects``; -----------------. Projects not strictly part of LLVM but shipped with LLVM. This is also the; directory for creating your own LLVM-based projects which leverage the LLVM; build system. ``llvm/test``; -------------. Feature and regression tests and other sanity checks on LLVM infrastructure. These; are intended to run quickly and cover a lot of territory without being exhaustive. ``test-suite``; --------------. A comprehensive correctness, performance, and benchmarking test suite; for LLVM. This comes in a ``separate git repository; <https://github.com/llvm/llvm-test-suite>``, because it contains a; large amount of third-party code under a variety of licenses. For; details see the :doc:`Testing Guide <TestingGuide>` document. .. _tools:. ``llvm/tools``; --------------. Executables built out of the libraries; above, which form the main part of the user interface. You can always get help; for a tool by typing ``tool_name -help``. The following is a brief introduction; to the most important tools. More detailed information is in; the `Command Guide <CommandGuide/index.html>`_. ``bugpoint``. ``bugpoint`` is used to debug optimization passes or code generation backends; by narrowing down the given test case to the minimum number of passes and/or; instructions that still cause a problem, whether it is a crash or; miscompilation. See `<HowToSubmitABug.html>`_ for more information on using; ``bugpoint``. ``llvm-ar``. The archiver produces an archive containing the given LLVM bitcode files,; optionally with an index for faster lookup. ``llvm-as``. The assembler transforms the human readable LLVM assembly to LLVM bitcode. ``llvm-dis``. The disassembler transforms the LLVM bitcode to ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst:38475,Guid,Guide,38475,interpreter/llvm-project/llvm/docs/GettingStarted.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst,1,['Guid'],['Guide']
Usability,"Support; ============. .. contents::; :local:. Introduction; ============. HLSL Support is under active development in the Clang codebase. This document; describes the high level goals of the project, the guiding principles, as well; as some idiosyncrasies of the HLSL language and how we intend to support them in; Clang. Project Goals; =============. The long term goal of this project is to enable Clang to function as a; replacement for the `DirectXShaderCompiler (DXC); <https://github.com/microsoft/DirectXShaderCompiler/>`_ in all its supported; use cases. Accomplishing that goal will require Clang to be able to process most; existing HLSL programs with a high degree of source compatibility. Non-Goals; ---------. HLSL ASTs do not need to be compatible between DXC and Clang. We do not expect; identical code generation or that features will resemble DXC's implementation or; architecture. In fact, we explicitly expect to deviate from DXC's implementation; in key ways. Guiding Principles; ==================. This document lacks details for architectural decisions that are not yet; finalized. Our top priorities are quality, maintainability, and flexibility. In; accordance with community standards we are expecting a high level of test; coverage, and we will engineer our solutions with long term maintenance in mind.; We are also working to limit modifications to the Clang C++ code paths and; share as much functionality as possible. Architectural Direction; =======================. HLSL support in Clang is expressed as C++ minus unsupported C and C++ features.; This is different from how other Clang languages are implemented. Most languages; in Clang are additive on top of C. HLSL is not a formally or fully specified language, and while our goals require; a high level of source compatibility, implementations can vary and we have some; flexibility to be more or less permissive in some cases. For modern HLSL DXC is; the reference implementation. The HLSL effort prioritizes f",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HLSL/HLSLSupport.rst:1000,Guid,Guiding,1000,interpreter/llvm-project/clang/docs/HLSL/HLSLSupport.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HLSL/HLSLSupport.rst,1,['Guid'],['Guiding']
Usability,"Suppose we want to position the; same box inside 2 different volumes and we want the Z size to match the; one of each container:. ~~~{.cpp}; TGeoVolume *container1 = gGeoManager->MakeBox(""C1"",imed,10,10,30);; TGeoVolume *container2 = gGeoManager->MakeBox(""C2"",imed,10,10,20);; TGeoVolume *pvol = gGeoManager->MakeBox(""PVOL"",jmed,3,3,-1);; container1->AddNode(pvol,1);; container2->AddNode(pvol,1);; ~~~. Note that the third parameter of `PVOL` is negative, which does not make; sense as half-length on Z. This is interpreted as: when positioned,; create a box replacing all invalid parameters with the corresponding; dimensions of the container. This is also internally handled by the; **`TGeoVolumeMulti`** class, which does not need to be instantiated by; users. \anchor GP01bi; #### Dividing Volumes. Volumes can be divided according a pattern. The simplest division can be; done along one axis that can be: `X,Y,Z,Phi,Rxy or Rxyz`. Let's take a; simple case: we would like to divide a box in N equal slices along X; coordinate, representing a new volume family. Supposing we already have; created the initial box, this can be done like:. ~~~{.cpp}; TGeoVolume *slicex = box->Divide(""SLICEX"",1,N);; ~~~. Here `SLICEX` is the name of the new family representing all slices and; 1 is the slicing axis. The meaning of the axis index is the following:; for all volumes having shapes like `box`, `trd1`, `trd2`, `trap`,; `gtra `or` para - `1, 2, 3 mean X, Y, Z; for `tube`, `tubs`, `cone`,; `cons - `1 means `Rxy`, 2 means `phi` and 3 means Z; for `pcon` and; `pgon` - 2 means `phi` and 3 means Z; for spheres 1 means `R `and 2; means `phi.`. In fact, the division operation has the same effect as positioning; volumes in a given order inside the divided container - the advantage; being that the navigation in such a structure is much faster. When a; volume is divided, a volume family corresponding to the slices is; created. In case all slices can be represented by a single shape, only; one volume ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:44329,simpl,simple,44329,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['simpl'],['simple']
Usability,"T, BOU_TRUE and BOU_FALSE.; This parser accepts the same strings as **``parser<bool>``**. .. _strings:. * The **parser<string> specialization** simply stores the parsed string into the; string value specified. No conversion or modification of the data is; performed. .. _integers:; .. _int:. * The **parser<int> specialization** uses the C ``strtol`` function to parse the; string input. As such, it will accept a decimal number (with an optional '+'; or '-' prefix) which must start with a non-zero digit. It accepts octal; numbers, which are identified with a '``0``' prefix digit, and hexadecimal; numbers with a prefix of '``0x``' or '``0X``'. .. _doubles:; .. _float:; .. _double:. * The **parser<double>** and **parser<float> specializations** use the standard; C ``strtod`` function to convert floating point strings into floating point; values. As such, a broad range of string formats is supported, including; exponential notation (ex: ``1.7e15``) and properly supports locales. .. _Extension Guide:; .. _extending the library:. Extension Guide; ===============. Although the CommandLine library has a lot of functionality built into it; already (as discussed previously), one of its true strengths lie in its; extensibility. This section discusses how the CommandLine library works under; the covers and illustrates how to do some simple, common, extensions. .. _Custom parsers:; .. _custom parser:; .. _Writing a Custom Parser:. Writing a custom parser; -----------------------. One of the simplest and most common extensions is the use of a custom parser.; As `discussed previously`_, parsers are the portion of the CommandLine library; that turns string input from the user into a particular parsed data type,; validating the input in the process. There are two ways to use a new parser:. #. Specialize the `cl::parser`_ template for your custom data type. This approach has the advantage that users of your custom data type will; automatically use your custom parser whenever they define",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst:61359,Guid,Guide,61359,interpreter/llvm-project/llvm/docs/CommandLine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst,1,['Guid'],['Guide']
Usability,"T:; call void %FP(); ret void; F:; call fastcc void %FP(); ret void; }; define void @test() {; %X = or i1 false, false; call void @bar(void()* @foo, i1 %X); ret void; }. In this example, ""test"" always passes ``@foo``/``false`` into ``bar``, which; ensures that it is dynamically called with the right calling conv (thus, the; code is perfectly well defined). If you run this through the inliner, you; get this (the explicit ""or"" is there so that the inliner doesn't dead code; eliminate a bunch of stuff):. .. code-block:: llvm. define fastcc void @foo() {; ret void; }; define void @test() {; %X = or i1 false, false; br i1 %X, label %T.i, label %F.i; T.i:; call void @foo(); br label %bar.exit; F.i:; call fastcc void @foo(); br label %bar.exit; bar.exit:; ret void; }. Here you can see that the inlining pass made an undefined call to ``@foo``; with the wrong calling convention. We really don't want to make the inliner; have to know about this sort of thing, so it needs to be valid code. In this; case, dead code elimination can trivially remove the undefined code. However,; if ``%X`` was an input argument to ``@test``, the inliner would produce this:. .. code-block:: llvm. define fastcc void @foo() {; ret void; }. define void @test(i1 %X) {; br i1 %X, label %T.i, label %F.i; T.i:; call void @foo(); br label %bar.exit; F.i:; call fastcc void @foo(); br label %bar.exit; bar.exit:; ret void; }. The interesting thing about this is that ``%X`` *must* be false for the; code to be well-defined, but no amount of dead code elimination will be able; to delete the broken call as unreachable. However, since; ``instcombine``/``simplifycfg`` turns the undefined call into unreachable, we; end up with a branch on a condition that goes to unreachable: a branch to; unreachable can never happen, so ""``-inline -instcombine -simplifycfg``"" is; able to produce:. .. code-block:: llvm. define fastcc void @foo() {; ret void; }; define void @test(i1 %X) {; F.i:; call fastcc void @foo(); ret void; }; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/FAQ.rst:12284,simpl,simplifycfg,12284,interpreter/llvm-project/llvm/docs/FAQ.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/FAQ.rst,2,['simpl'],['simplifycfg']
Usability,"T>('+', std::move(LHS),; std::move(RHS));. In order to do this, we'll start by defining some basic helper routines:. .. code-block:: c++. /// CurTok/getNextToken - Provide a simple token buffer. CurTok is the current; /// token the parser is looking at. getNextToken reads another token from the; /// lexer and updates CurTok with its results.; static int CurTok;; static int getNextToken() {; return CurTok = gettok();; }. This implements a simple token buffer around the lexer. This allows us; to look one token ahead at what the lexer is returning. Every function; in our parser will assume that CurTok is the current token that needs to; be parsed. .. code-block:: c++. /// LogError* - These are little helper functions for error handling.; std::unique_ptr<ExprAST> LogError(const char *Str) {; fprintf(stderr, ""Error: %s\n"", Str);; return nullptr;; }; std::unique_ptr<PrototypeAST> LogErrorP(const char *Str) {; LogError(Str);; return nullptr;; }. The ``LogError`` routines are simple helper routines that our parser will; use to handle errors. The error recovery in our parser will not be the; best and is not particular user-friendly, but it will be enough for our; tutorial. These routines make it easier to handle errors in routines; that have various return types: they always return null. With these basic helper functions, we can implement the first piece of; our grammar: numeric literals. Basic Expression Parsing; ========================. We start with numeric literals, because they are the simplest to; process. For each production in our grammar, we'll define a function; which parses that production. For numeric literals, we have:. .. code-block:: c++. /// numberexpr ::= number; static std::unique_ptr<ExprAST> ParseNumberExpr() {; auto Result = std::make_unique<NumberExprAST>(NumVal);; getNextToken(); // consume the number; return std::move(Result);; }. This routine is very simple: it expects to be called when the current; token is a ``tok_number`` token. It takes the curre",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst:6646,simpl,simple,6646,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst,1,['simpl'],['simple']
Usability,"TTree::MakeClass` and; `TTree::MakeSelector` are available for data analysis using trees. The; **`TTree::Draw`** method is a powerful yet simple way to look and draw the; trees contents. It enables you to plot a variable (a leaf) with just one; line of code. However, the Draw method falls short once you want to look; at each entry and design more sophisticated acceptance criteria for your; analysis. For these cases, you can use `TTree::MakeClass`. It creates a; class that loops over the trees entries one by one. You can then expand; it to do the logic of your analysis. The `TTree::MakeSelector` is the recommended method for ROOT data; analysis. It is especially important for large data set in a parallel; processing configuration where the analysis is distributed over several; processors and you can specify which entries to send to each processor.; With `MakeClass` the user has control over the event loop, with; `MakeSelector `the tree is in control of the event loop. ## Simple Analysis Using TTree::Draw. We will use the tree in `cernstaff.root` that was made by the macro in; `$ROOTSYS/tutorials/tree/staff.C`. First, open the file and lists its contents. ``` {.cpp}; root[] TFile f (""cernstaff.root""); root[] f.ls(); TFile** cernstaff.root; TFile* cernstaff.root; KEY: TTree T;1 staff data from ascii file; ```. We can see the **`TTree `**""`T`"" in the file. We will use it to; experiment with the **`TTree::Draw`** method, so let's create a pointer to it:. ``` {.cpp}; root[] TTree *MyTree = T; ```. Cling allows us to get simply the object by using it. Here we define a; pointer to a **`TTree`** object and assign it the value of ""`T`"", the; **`TTree`** in the file. Cling looks for an object named ""`T`"" in the; current ROOT file and returns it (this assumes that ""T"" has not; previously been used to declare a variable or function). In contrast, in compiled code, you can use:. ``` {.cpp}; TTree *MyTree;f.GetObject(""T"",MyTree);; ```. To show the different `Draw` options, we crea",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:68561,Simpl,Simple,68561,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['Simpl'],['Simple']
Usability,"The C API is, in general, a ""best effort"" for stability.; This means that we make every attempt to keep the C API stable, but that; stability will be limited by the abstractness of the interface and the; stability of the C++ API that it wraps. In practice, this means that things; like ""create debug info"" or ""create this type of instruction"" are likely to be; less stable than ""take this IR file and JIT it for my current machine"". * Release stability: We won't break the C API on the release branch with patches; that go on that branch, with the exception that we will fix an unintentional; C API break that will keep the release consistent with both the previous and; next release. * Testing: Patches to the C API are expected to come with tests just like any; other patch. * Including new things into the API: If an LLVM subcomponent has a C API already; included, then expanding that C API is acceptable. Adding C API for; subcomponents that don't currently have one needs to be discussed on the; `LLVM Discourse forums`_ for design and maintainability feedback prior to implementation. * Documentation: Any changes to the C API are required to be documented in the; release notes so that it's clear to external users who do not follow the; project how the C API is changing and evolving. .. _toolchain:. Updating Toolchain Requirements; -------------------------------. We intend to require newer toolchains as time goes by. This means LLVM's; codebase can use newer versions of C++ as they get standardized. Requiring newer; toolchains to build LLVM can be painful for those building LLVM; therefore, it; will only be done through the following process:. * It is a general goal to support LLVM and GCC versions from the last 3 years; at a minimum. This time-based guideline is not strict: we may support much; older compilers, or decide to support fewer versions. * An RFC is sent to the `LLVM Discourse forums`_. - Detail upsides of the version increase (e.g. which newer C++ language or; lib",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst:33661,feedback,feedback,33661,interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,1,['feedback'],['feedback']
Usability,"There are a couple of special cases for easier typing:. * If the first pass is not a module pass, a pass manager of the first pass is; implicitly created. * For example, the following are equivalent. .. code-block:: shell. $ opt -passes='no-op-function,no-op-function' /tmp/a.ll -S; $ opt -passes='function(no-op-function,no-op-function)' /tmp/a.ll -S. * If there is an adaptor for a pass that lets it fit in the previous pass; manager, that is implicitly created. * For example, the following are equivalent. .. code-block:: shell. $ opt -passes='no-op-function,no-op-loop' /tmp/a.ll -S; $ opt -passes='no-op-function,loop(no-op-loop)' /tmp/a.ll -S. For a list of available passes and analyses, including the IR unit (module,; CGSCC, function, loop) they operate on, run. .. code-block:: shell. $ opt --print-passes. or take a look at ``PassRegistry.def``. To make sure an analysis named ``foo`` is available before a pass, add; ``require<foo>`` to the pass pipeline. This adds a pass that simply requests; that the analysis is run. This pass is also subject to proper nesting. For; example, to make sure some function analysis is already computed for all; functions before a module pass:. .. code-block:: shell. $ opt -passes='function(require<my-function-analysis>),my-module-pass' /tmp/a.ll -S. Status of the New and Legacy Pass Managers; ==========================================. LLVM currently contains two pass managers, the legacy PM and the new PM. The; optimization pipeline (aka the middle-end) uses the new PM, whereas the backend; target-dependent code generation uses the legacy PM. The legacy PM somewhat works with the optimization pipeline, but this is; deprecated and there are ongoing efforts to remove its usage. Some IR passes are considered part of the backend codegen pipeline even if; they are LLVM IR passes (whereas all MIR passes are codegen passes). This; includes anything added via ``TargetPassConfig`` hooks, e.g.; ``TargetPassConfig::addCodeGenPrepare()``. The ``Targ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NewPassManager.rst:20275,simpl,simply,20275,interpreter/llvm-project/llvm/docs/NewPassManager.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NewPassManager.rst,1,['simpl'],['simply']
Usability,"There are few key implications of the definitions given above which; are important for working successfully with this interface. * LoopInfo does not contain information about non-loop cycles. As a; result, it is not suitable for any algorithm which requires complete; cycle detection for correctness. * LoopInfo provides an interface for enumerating all top level loops; (e.g. those not contained in any other loop). From there, you may; walk the tree of sub-loops rooted in that top level loop. * Loops which become statically unreachable during optimization *must*; be removed from LoopInfo. If this can not be done for some reason,; then the optimization is *required* to preserve the static; reachability of the loop. .. _loop-terminology-loop-simplify:. Loop Simplify Form; ==================. The Loop Simplify Form is a canonical form that makes; several analyses and transformations simpler and more effective.; It is ensured by the LoopSimplify; (:ref:`-loop-simplify <passes-loop-simplify>`) pass and is automatically; added by the pass managers when scheduling a LoopPass.; This pass is implemented in; `LoopSimplify.h <https://llvm.org/doxygen/LoopSimplify_8h_source.html>`_.; When it is successful, the loop has:. * A preheader.; * A single backedge (which implies that there is a single latch).; * Dedicated exits. That is, no exit block for the loop; has a predecessor that is outside the loop. This implies; that all exit blocks are dominated by the loop header. .. _loop-terminology-lcssa:. Loop Closed SSA (LCSSA); =======================. A program is in Loop Closed SSA Form if it is in SSA form; and all values that are defined in a loop are used only inside; this loop. Programs written in LLVM IR are always in SSA form but not necessarily; in LCSSA. To achieve the latter, for each value that is live across the; loop boundary, single entry PHI nodes are inserted to each of the exit blocks; [#lcssa-construction]_ in order to ""close"" these values inside the loop.; In particul",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LoopTerminology.rst:10148,simpl,simplify,10148,interpreter/llvm-project/llvm/docs/LoopTerminology.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LoopTerminology.rst,2,['simpl'],['simplify']
Usability,"These pages contain the documentation for all ROOT classes, and the conceptual structure of the ROOT classes, its modules.; The documentation can be accessed by browsing the modules below,; by accessing a certain class directly using the Class Index,; or by simply searching the reference guide (see search field above).; The ROOT Tutorials show how to use many of ROOT's classes. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/doc/index.html:258,simpl,simply,258,doc/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/doc/index.html,2,"['guid', 'simpl']","['guide', 'simply']"
Usability,"These provide simplified access; to an underlying container but don't affect the cost of the container itself. .. _ds_string:. String-like containers; ----------------------. There are a variety of ways to pass around and use strings in C and C++, and; LLVM adds a few new options to choose from. Pick the first option on this list; that will do what you need, they are ordered according to their relative cost. Note that it is generally preferred to *not* pass strings around as ``const; char*``'s. These have a number of problems, including the fact that they; cannot represent embedded nul (""\0"") characters, and do not have a length; available efficiently. The general replacement for '``const char*``' is; StringRef. For more information on choosing string containers for APIs, please see; :ref:`Passing Strings <string_apis>`. .. _dss_stringref:. llvm/ADT/StringRef.h; ^^^^^^^^^^^^^^^^^^^^. The StringRef class is a simple value class that contains a pointer to a; character and a length, and is quite related to the :ref:`ArrayRef; <dss_arrayref>` class (but specialized for arrays of characters). Because; StringRef carries a length with it, it safely handles strings with embedded nul; characters in it, getting the length does not require a strlen call, and it even; has very convenient APIs for slicing and dicing the character range that it; represents. StringRef is ideal for passing simple strings around that are known to be live,; either because they are C string literals, std::string, a C array, or a; SmallVector. Each of these cases has an efficient implicit conversion to; StringRef, which doesn't result in a dynamic strlen being executed. StringRef has a few major limitations which make more powerful string containers; useful:. #. You cannot directly convert a StringRef to a 'const char*' because there is; no way to add a trailing nul (unlike the .c_str() method on various stronger; classes). #. StringRef doesn't own or keep alive the underlying string bytes.; As such it",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:71717,simpl,simple,71717,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['simpl'],['simple']
Usability,"This allows ``ptrtoint`` and arithmetic to be; performed on these values so long as the original value is reconstituted before; the ``indirectbr`` instruction. Finally, some targets may provide defined semantics when using the value; as the operand to an inline assembly, but that is target specific. .. _dso_local_equivalent:. DSO Local Equivalent; --------------------. ``dso_local_equivalent @func``. A '``dso_local_equivalent``' constant represents a function which is; functionally equivalent to a given function, but is always defined in the; current linkage unit. The resulting pointer has the same type as the underlying; function. The resulting pointer is permitted, but not required, to be different; from a pointer to the function, and it may have different values in different; translation units. The target function may not have ``extern_weak`` linkage. ``dso_local_equivalent`` can be implemented as such:. - If the function has local linkage, hidden visibility, or is; ``dso_local``, ``dso_local_equivalent`` can be implemented as simply a pointer; to the function.; - ``dso_local_equivalent`` can be implemented with a stub that tail-calls the; function. Many targets support relocations that resolve at link time to either; a function or a stub for it, depending on if the function is defined within the; linkage unit; LLVM will use this when available. (This is commonly called a; ""PLT stub"".) On other targets, the stub may need to be emitted explicitly. This can be used wherever a ``dso_local`` instance of a function is needed without; needing to explicitly make the original function ``dso_local``. An instance where; this can be used is for static offset calculations between a function and some other; ``dso_local`` symbol. This is especially useful for the Relative VTables C++ ABI,; where dynamic relocations for function pointers in VTables can be replaced with; static relocations for offsets between the VTable and virtual functions which; may not be ``dso_local``. This",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:201688,simpl,simply,201688,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['simpl'],['simply']
Usability,"This directory contains all the basic classes for creating/manipulating Trees.; BEGIN_HTML; Several documents describing the TTree classes are listed below:; <ul>; <li>The TTree data structure is documented in class TTree.</li>; <li><a href=""ftp://root.cern/root/doc/12Trees.pdf"">The Chapter about Trees in the Users Guide </a></li>; <li><a href=""ftp://root.cern/root/doc/21ExampleAnalysis.pdf"">The Chapter about Selectors in the Users Guide </a></li>; <li><a href=""ftp://root.cern/root/doc/24PROOF.pdf"">The Chapter about PROOF in the Users Guide </a></li>; <li><a href=""ftp://root.cern/root/doc/11InputOutput.pdf"">The Chapter about IO in the Users Guide </a></li>; <li><a href=""https://root.cern/manual/trees/#introducing-ttree"">Introducing TTree</a></li>; <li><a href=""https://root.cern/manual/trees/#reading-a-tree"">Reading a Tree </a></li>; <li><a href=""https://root.cern/manual/trees/#appending-ttrees-as-a-tchain"">Appending TTrees as a TChain</a></li>; </ul>; END_HTML; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/doc/index.txt:317,Guid,Guide,317,tree/tree/doc/index.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/doc/index.txt,4,['Guid'],['Guide']
Usability,This directory contains all the hbook interface classes. See:. - [How to convert Hbook/PAW files to ROOT](https://root-forum.cern.ch/t/how-to-convert-hbook-paw-files-to-root/); - [The Chapter about the Histogram classes in the Users Guide](ftp://root.cern.ch/root/doc/3Histograms.pdf); - [The Chapter about Fitting Histogram in the Users Guide](ftp://root.cern.ch/root/doc/5FittingHistograms.pdf); - [How to use the Histogram classes](https://root.cern/manual/histograms/); - [How to Merge files with histograms and Trees](https://root.cern/manual/storing_root_objects/#merging-root-files-with-hadd); - [How to Fit Histograms](https://root.cern/manual/fitting/); - [How to Fit find peaks in histograms](https://root.cern/doc/master/peaks_8C.html); ,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hbook/doc/index.md:233,Guid,Guide,233,hist/hbook/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hbook/doc/index.md,2,['Guid'],['Guide']
Usability,"This directory contains all the network classes.; BEGIN_HTML; See:; <ul>; <li><a href=""ftp://root.cern/root/doc/22Networking.pdf"">The Chapter about the Networking classes in the Users Guide; </a></li>; </ul>; END_HTML; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/doc/index.txt:184,Guid,Guide,184,net/net/doc/index.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/doc/index.txt,1,['Guid'],['Guide']
Usability,"This directory contains all the thread classes.; BEGIN_HTML; See:; <ul>; <li><a href=""ftp://root.cern.ch/root/doc/23Threads.pdf"">The Chapter about the Thread classes in the Users Guide; </a></li>; <li><a href=""http://root.cern.ch/root/HowtoThread.html"">How to use the ROOT Thread classes; </a></li>; </ul>; END_HTML; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/thread/doc/index.txt:179,Guid,Guide,179,core/thread/doc/index.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/thread/doc/index.txt,1,['Guid'],['Guide']
Usability,"This directory contains the PROOF classes.; BEGIN_HTML; See:; <ul>; <li><a href=""ftp://root.cern.ch/root/doc/24PROOF.pdf"">The Chapter about PROOF in the Users Guide; </a></li>; <li><a href=""http://root.cern.ch/twiki/bin/view/ROOT/PROOF"">The PROOF system; </a></li>; <li><a href=""ftp://root.cern.ch/root/doc/21ExampleAnalysis.pdf"">The Chapter about Selectors in the Users Guide; </a></li>; </ul>; END_HTML; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/doc/index.txt:159,Guid,Guide,159,proof/proof/doc/index.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/doc/index.txt,2,['Guid'],['Guide']
Usability,"This directory contains the ROOT Tree Viewer classes.; BEGIN_HTML; See:; <ul>; <li>The main tree viewer class is documented in class TTreeViewer.</li>; <li><a href=""ftp://root.cern/root/doc/12Trees.pdf"">The Chapter about Trees and Treeviewer in the Users Guide; </a></li>; </ul>; END_HTML; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeviewer/doc/index.txt:255,Guid,Guide,255,tree/treeviewer/doc/index.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeviewer/doc/index.txt,1,['Guid'],['Guide']
Usability,"This directory contains the ROOT::Math::GeneticMinimizer class; BEGIN_HTML; The GeneticMinimizer class is used to implement a genetic minimizer algorithm.; The algorithm is based on an algorithm implemented in the TMVA package; (TMVA::GeneticAlgorithm class).; <p>; The ROOT::Math:GeneticMinimizer class implements the; ROOT::Math::Minimizer interface, as a new plugin with name ""Genetic"".; The class can be used when fitting histograms or graph by selecting it; as default minimizer. This can be done via:; <pre>; ROOT::Math::MinimizerOptions::SetDefaultMinimizer(""Genetic"");; </pre>; Via the MinimizerOptions, one can control the possible options for the; class. These are described in the TMVA user guide, Option Table 7.; A list of the default options can be obtained by doing:; <pre>; ROOT::Math::Minimizer * min =ROOT::Math::Factory::CreateMinimizer(""Genetic"");; min->Options().Print();; </pre>; The user can change a default option, like the population size to 500; and the steps to 60 by doing:; <pre>; ROOT::Math::MinimizerOptions::Default(""Genetic"").SetValue(""PopSize"",500);; ROOT::Math::MinimizerOptions::Default(""Genetic"").SetValue(""Steps"",60);; </pre>. END_HTML. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/genetic/doc/index.txt:702,guid,guide,702,math/genetic/doc/index.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/genetic/doc/index.txt,1,['guid'],['guide']
Usability,"This directory contains the internal classes used for PROOF processing.; BEGIN_HTML; See:; <ul>; <li><a href=""http://root.cern.ch/twiki/bin/view/ROOT/PROOF"">The PROOF system; </a></li>; <li><a href=""ftp://root.cern.ch/root/doc/21ExampleAnalysis.pdf"">The Chapter about Selectors in the Users Guide; </a></li>; </ul>; END_HTML; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/doc/index.txt:291,Guid,Guide,291,proof/proofplayer/doc/index.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/doc/index.txt,1,['Guid'],['Guide']
Usability,"This directory contains three utilities for fuzzing Clang: clang-fuzzer,; clang-objc-fuzzer, and clang-proto-fuzzer. All use libFuzzer to generate inputs; to clang via coverage-guided mutation. The three utilities differ, however, in how they structure inputs to Clang.; clang-fuzzer makes no attempt to generate valid C++ programs and is therefore; primarily useful for stressing the surface layers of Clang (i.e. lexer, parser). clang-objc-fuzzer is similar but for Objective-C: it makes no attempt to; generate a valid Objective-C program. clang-proto-fuzzer uses a protobuf class to describe a subset of the C++; language and then uses libprotobuf-mutator to mutate instantiations of that; class, producing valid C++ programs in the process. As a result,; clang-proto-fuzzer is better at stressing deeper layers of Clang and LLVM. Some of the fuzzers have example corpuses inside the corpus_examples directory. ===================================; Building clang-fuzzer; ===================================; Within your LLVM build directory, run CMake with the following variable; definitions:; - CMAKE_C_COMPILER=clang; - CMAKE_CXX_COMPILER=clang++; - LLVM_USE_SANITIZE_COVERAGE=YES; - LLVM_USE_SANITIZER=Address. Then build the clang-fuzzer target. Example:; cd $LLVM_SOURCE_DIR; mkdir build && cd build; cmake .. -GNinja -DCMAKE_C_COMPILER=clang -DCMAKE_CXX_COMPILER=clang++ \; -DLLVM_USE_SANITIZE_COVERAGE=YES -DLLVM_USE_SANITIZER=Address; ninja clang-fuzzer. ======================; Running clang-fuzzer; ======================; bin/clang-fuzzer CORPUS_DIR. ===================================; Building clang-objc-fuzzer; ===================================; Within your LLVM build directory, run CMake with the following variable; definitions:; - CMAKE_C_COMPILER=clang; - CMAKE_CXX_COMPILER=clang++; - LLVM_USE_SANITIZE_COVERAGE=YES; - LLVM_USE_SANITIZER=Address. Then build the clang-objc-fuzzer target. Example:; cd $LLVM_SOURCE_DIR; mkdir build && cd build; cmake .. -GNinja -DCMAKE_C_C",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-fuzzer/README.txt:177,guid,guided,177,interpreter/llvm-project/clang/tools/clang-fuzzer/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-fuzzer/README.txt,1,['guid'],['guided']
Usability,"This is a simple N^2 alias analysis accuracy evaluator. Basically, for each; function in the program, it simply queries to see how the alias analysis; implementation answers alias queries between each pair of pointers in the; function. This is inspired and adapted from code by: Naveen Neelakantam, Francesco; Spadini, and Wojciech Stryjewski. ``basic-aa``: Basic Alias Analysis (stateless AA impl); ------------------------------------------------------. A basic alias analysis pass that implements identities (two different globals; cannot alias, etc), but does no stateful analysis. ``basiccg``: Basic CallGraph Construction; -----------------------------------------. Yet to be written. .. _passes-da:. ``da``: Dependence Analysis; ---------------------------. Dependence analysis framework, which is used to detect dependences in memory; accesses. ``domfrontier``: Dominance Frontier Construction; ------------------------------------------------. This pass is a simple dominator construction algorithm for finding forward; dominator frontiers. ``domtree``: Dominator Tree Construction; ----------------------------------------. This pass is a simple dominator construction algorithm for finding forward; dominators. ``dot-callgraph``: Print Call Graph to ""dot"" file; -------------------------------------------------. This pass, only available in ``opt``, prints the call graph into a ``.dot``; graph. This graph can then be processed with the ""dot"" tool to convert it to; postscript or some other suitable format. ``dot-cfg``: Print CFG of function to ""dot"" file; ------------------------------------------------. This pass, only available in ``opt``, prints the control flow graph into a; ``.dot`` graph. This graph can then be processed with the :program:`dot` tool; to convert it to postscript or some other suitable format.; Additionally the ``-cfg-func-name=<substring>`` option can be used to filter the; functions that are printed. All functions that contain the specified substring; wil",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst:2221,simpl,simple,2221,interpreter/llvm-project/llvm/docs/Passes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst,1,['simpl'],['simple']
Usability,"This is a simple example demonstrating how to use clang's facility for; providing AST consumers using a plugin. Build the plugin by running `make` in this directory. Once the plugin is built, you can run it using:; --; Linux:; $ clang -cc1 -load ../../Debug+Asserts/lib/libPrintFunctionNames.so -plugin print-fns some-input-file.c; $ clang -cc1 -load ../../Debug+Asserts/lib/libPrintFunctionNames.so -plugin print-fns -plugin-arg-print-fns help -plugin-arg-print-fns --example-argument some-input-file.c; $ clang -cc1 -load ../../Debug+Asserts/lib/libPrintFunctionNames.so -plugin print-fns -plugin-arg-print-fns -an-error some-input-file.c. Mac:; $ clang -cc1 -load ../../Debug+Asserts/lib/libPrintFunctionNames.dylib -plugin print-fns some-input-file.c; $ clang -cc1 -load ../../Debug+Asserts/lib/libPrintFunctionNames.dylib -plugin print-fns -plugin-arg-print-fns help -plugin-arg-print-fns --example-argument some-input-file.c; $ clang -cc1 -load ../../Debug+Asserts/lib/libPrintFunctionNames.dylib -plugin print-fns -plugin-arg-print-fns -an-error some-input-file.c; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/examples/PrintFunctionNames/README.txt:10,simpl,simple,10,interpreter/llvm-project/clang/examples/PrintFunctionNames/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/examples/PrintFunctionNames/README.txt,1,['simpl'],['simple']
Usability,"This means we have to support multiple live argument; allocations. Consider the evaluation of:. .. code-block:: c++. // Foo is non-trivial.; struct Foo { int a; Foo(); Foo(const &Foo); ~Foo(); };; Foo bar(Foo b);; int main() {; bar(bar(Foo()));; }. In this case, we want to be able to elide copies into ``bar``'s argument; slots. That means we need to have more than one set of argument frames; active at the same time. First, we need to allocate the frame for the; outer call so we can pass it in as the hidden struct return pointer to; the middle call. Then we do the same for the middle call, allocating a; frame and passing its address to ``Foo``'s default constructor. By; wrapping the evaluation of the inner ``bar`` with stack save and; restore, we can have multiple overlapping active call frames. Callee-cleanup Calling Conventions; ----------------------------------. Another wrinkle is the existence of callee-cleanup conventions. On; Windows, all methods and many other functions adjust the stack to clear; the memory used to pass their arguments. In some sense, this means that; the allocas are automatically cleared by the call. However, LLVM; instead models this as a write of undef to all of the inalloca values; passed to the call instead of a stack adjustment. Frontends should; still restore the stack pointer to avoid a stack leak. Exceptions; ----------. There is also the possibility of an exception. If argument evaluation; or copy construction throws an exception, the landing pad must do; cleanup, which includes adjusting the stack pointer to avoid a stack; leak. This means the cleanup of the stack memory cannot be tied to the; call itself. There needs to be a separate IR-level instruction that can; perform independent cleanup of arguments. Efficiency; ----------. Eventually, it should be possible to generate efficient code for this; construct. In particular, using inalloca should not require a base; pointer. If the backend can prove that all points in the CFG only ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/InAlloca.rst:5059,clear,clear,5059,interpreter/llvm-project/llvm/docs/InAlloca.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/InAlloca.rst,1,['clear'],['clear']
Usability,"ThreadSanitizer; ===============. Introduction; ------------. ThreadSanitizer is a tool that detects data races. It consists of a compiler; instrumentation module and a run-time library. Typical slowdown introduced by; ThreadSanitizer is about **5x-15x**. Typical memory overhead introduced by; ThreadSanitizer is about **5x-10x**. How to build; ------------. Build LLVM/Clang with `CMake <https://llvm.org/docs/CMake.html>`_. Supported Platforms; -------------------. ThreadSanitizer is supported on the following OS:. * Android aarch64, x86_64; * Darwin arm64, x86_64; * FreeBSD; * Linux aarch64, x86_64, powerpc64, powerpc64le; * NetBSD. Support for other 64-bit architectures is possible, contributions are welcome.; Support for 32-bit platforms is problematic and is not planned. Usage; -----. Simply compile and link your program with ``-fsanitize=thread``. To get a; reasonable performance add ``-O1`` or higher. Use ``-g`` to get file names; and line numbers in the warning messages. Example:. .. code-block:: console. % cat projects/compiler-rt/lib/tsan/lit_tests/tiny_race.c; #include <pthread.h>; int Global;; void *Thread1(void *x) {; Global = 42;; return x;; }; int main() {; pthread_t t;; pthread_create(&t, NULL, Thread1, NULL);; Global = 43;; pthread_join(t, NULL);; return Global;; }. $ clang -fsanitize=thread -g -O1 tiny_race.c. If a bug is detected, the program will print an error message to stderr.; Currently, ThreadSanitizer symbolizes its output using an external; ``addr2line`` process (this will be fixed in future). .. code-block:: bash. % ./a.out; WARNING: ThreadSanitizer: data race (pid=19219); Write of size 4 at 0x7fcf47b21bc0 by thread T1:; #0 Thread1 tiny_race.c:4 (exe+0x00000000a360). Previous write of size 4 at 0x7fcf47b21bc0 by main thread:; #0 main tiny_race.c:10 (exe+0x00000000a3b4). Thread T1 (running) created at:; #0 pthread_create tsan_interceptors.cc:705 (exe+0x00000000c790); #1 main tiny_race.c:9 (exe+0x00000000a3a4). ``__has_feature(thread_sanitizer",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSanitizer.rst:799,Simpl,Simply,799,interpreter/llvm-project/clang/docs/ThreadSanitizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSanitizer.rst,1,['Simpl'],['Simply']
Usability,"Tips.html>`_ recommends; this. Optimizations benefit from knowing about the target and data; layout. .. code-block:: c++. TheModule->setDataLayout(TargetMachine->createDataLayout());; TheModule->setTargetTriple(TargetTriple);. Emit Object Code; ================. We're ready to emit object code! Let's define where we want to write; our file to:. .. code-block:: c++. auto Filename = ""output.o"";; std::error_code EC;; raw_fd_ostream dest(Filename, EC, sys::fs::OF_None);. if (EC) {; errs() << ""Could not open file: "" << EC.message();; return 1;; }. Finally, we define a pass that emits object code, then we run that; pass:. .. code-block:: c++. legacy::PassManager pass;; auto FileType = CodeGenFileType::ObjectFile;. if (TargetMachine->addPassesToEmitFile(pass, dest, nullptr, FileType)) {; errs() << ""TargetMachine can't emit a file of this type"";; return 1;; }. pass.run(*TheModule);; dest.flush();. Putting It All Together; =======================. Does it work? Let's give it a try. We need to compile our code, but; note that the arguments to ``llvm-config`` are different to the previous chapters. ::. $ clang++ -g -O3 toy.cpp `llvm-config --cxxflags --ldflags --system-libs --libs all` -o toy. Let's run it, and define a simple ``average`` function. Press Ctrl-D; when you're done. ::. $ ./toy; ready> def average(x y) (x + y) * 0.5;; ^D; Wrote output.o. We have an object file! To test it, let's write a simple program and; link it with our output. Here's the source code:. .. code-block:: c++. #include <iostream>. extern ""C"" {; double average(double, double);; }. int main() {; std::cout << ""average of 3.0 and 4.0: "" << average(3.0, 4.0) << std::endl;; }. We link our program to output.o and check the result is what we; expected:. ::. $ clang++ main.cpp output.o -o main; $ ./main; average of 3.0 and 4.0: 3.5. Full Code Listing; =================. .. literalinclude:: ../../../examples/Kaleidoscope/Chapter8/toy.cpp; :language: c++. `Next: Adding Debug Information <LangImpl09.html>`_; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl08.rst:4846,simpl,simple,4846,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl08.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl08.rst,2,['simpl'],['simple']
Usability,"To-do; -----. * Keep the address of the constant pool in a register instead of forming its; address all of the time.; * We can fold small constant offsets into the %hi/%lo references to constant; pool addresses as well.; * When in V9 mode, register allocate %icc[0-3].; * Add support for isel'ing UMUL_LOHI instead of marking it as Expand.; * Emit the 'Branch on Integer Register with Prediction' instructions. It's; not clear how to write a pattern for this though:. float %t1(int %a, int* %p) {; %C = seteq int %a, 0; br bool %C, label %T, label %F; T:; store int 123, int* %p; br label %F; F:; ret float undef; }. codegens to this:. t1:; save -96, %o6, %o6; 1) subcc %i0, 0, %l0; 1) bne .LBBt1_2 ! F; nop; .LBBt1_1: ! T; or %g0, 123, %l0; st %l0, [%i1]; .LBBt1_2: ! F; restore %g0, %g0, %g0; retl; nop. 1) should be replaced with a brz in V9 mode. * Same as above, but emit conditional move on register zero (p192) in V9; mode. Testcase:. int %t1(int %a, int %b) {; %C = seteq int %a, 0; %D = select bool %C, int %a, int %b; ret int %D; }. * Emit MULX/[SU]DIVX instructions in V9 mode instead of fiddling; with the Y register, if they are faster. * Codegen bswap(load)/store(bswap) -> load/store ASI. * Implement frame pointer elimination, e.g. eliminate save/restore for; leaf fns.; * Fill delay slots. * Use %g0 directly to materialize 0. No instruction is required.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/README.txt:421,clear,clear,421,interpreter/llvm-project/llvm/lib/Target/Sparc/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/README.txt,1,['clear'],['clear']
Usability,"Type to be able to use; the preprocessor to synthesize the relevant cast operations. For example,; ``X(char, Char_S)``, where ``char`` is the type from the language's type system; and ``Char_S`` is the Clang builtin type which represents it. This mapping helps; to import execution results from the interpreter in a compiled program and vice; versa. The ``Value.h`` header file can be included at runtime and this is why it; has a very low token count and was developed with strict constraints in mind. This also enables the user to receive the computed 'type' back in their code; and then transform the type into something else (e.g., re-cast a double into; a float). Normally, the compiler can handle these conversions transparently,; but in interpreter mode, the compiler cannot see all the 'from' and 'to' types,; so it cannot implicitly do the conversions. So this logic enables providing; these conversions on request. On-request conversions can help improve the user experience, by allowing; conversion to a desired 'to' type, when the 'from' type is unknown or unclear. Significance of this Feature; ----------------------------. The 'Value' object enables wrapping a memory region that comes from the; JIT, and bringing it back to the compiled code (and vice versa).; This is a very useful functionality when:. - connecting an interpreter to the compiled code, or; - connecting an interpreter in another language. For example, this feature helps transport values across boundaries. A notable; example is the cppyy project code makes use of this feature to enable running C++; within Python. It enables transporting values/information between C++; and Python. Note: `cppyy <https://github.com/wlav/cppyy/>`_ is an automatic, run-time,; Python-to-C++ bindings generator, for calling C++ from Python and Python from C++.; It uses LLVM along with a C++ interpreter (e.g., Cling) to enable features like; run-time instantiation of C++ templates, cross-inheritance, callbacks,; auto-casting, transp",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst:10180,user experience,user experience,10180,interpreter/llvm-project/clang/docs/ClangRepl.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst,1,['user experience'],['user experience']
Usability,"ULT_PATH). # We need to consider not just the direct link dependencies, but also the; # transitive link dependencies. Do this by starting with the set of direct; # dependencies, then the dependencies of those dependencies, and so on.; set(new_libs ""clingMetaProcessor""); set(link_libs ${new_libs}); while(NOT ""${new_libs}"" STREQUAL """"); foreach(lib ${new_libs}); if(TARGET ${lib}); get_target_property(lib_type ${lib} TYPE); if(""${lib_type}"" STREQUAL ""STATIC_LIBRARY""); list(APPEND static_libs ${lib}); else(); list(APPEND other_libs ${lib}); endif(); get_target_property(transitive_libs ${lib} INTERFACE_LINK_LIBRARIES); if (NOT transitive_libs); continue(); endif(); foreach(transitive_lib ${transitive_libs}); list(FIND link_libs ${transitive_lib} idx); #if(TARGET ${transitive_lib} AND idx EQUAL -1); if(idx EQUAL -1); list(APPEND newer_libs ${transitive_lib}); list(APPEND link_libs ${transitive_lib}); endif(); endforeach(transitive_lib); endif(); endforeach(lib); set(new_libs ${newer_libs}); set(newer_libs """"); endwhile(); set(CLING_DEPEND_LIBS ${link_libs} CACHE STRING """"); endif(builtin_cling). #---Avoid to dependencies to system (e.g. atomic) libraries without modifying the LLVM code----------; if(CMAKE_SYSTEM_NAME STREQUAL Darwin); get_target_property(__libs LLVMSupport INTERFACE_LINK_LIBRARIES); list(REMOVE_ITEM __libs atomic); set_target_properties(LLVMSupport PROPERTIES INTERFACE_LINK_LIBRARIES ""${__libs}""); endif(). #---Mark the LLVM/CLANG variables as advanced--------------------------------------------------------; get_cmake_property(variables CACHE_VARIABLES); foreach(var ${variables}); if(var MATCHES ""^(CLANG|LLVM|CLING)_""); mark_as_advanced(FORCE ${var}); endif(); endforeach(); mark_as_advanced(FORCE BUG_REPORT_URL BUILD_CLANG_FORMAT_VS_PLUGIN BUILD_SHARED_LIBS BUILD_TESTING; C_INCLUDE_DIRS DEFAULT_SYSROOT FFI_INCLUDE_DIR FFI_LIBRARY_DIR; GCC_INSTALL_PREFIX LIBCLANG_BUILD_STATIC TOOL_INFO_PLIST); mark_as_advanced(CLEAR LLVM_ENABLE_ASSERTIONS LLVM_BUILD_TYPE); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/CMakeLists.txt:25040,CLEAR,CLEAR,25040,interpreter/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/CMakeLists.txt,1,['CLEAR'],['CLEAR']
Usability,"Usable as: Any Matcher. Matcher<*>anything; Matches any node. Useful when another matcher requires a child matcher, but there's no; additional constraint. This will often be used with an explicit conversion; to an internal::Matcher<> type such as TypeMatcher. Example: DeclarationMatcher(anything()) matches all declarations, e.g.,; ""int* p"" and ""void f()"" in; int* p;; void f();. Usable as: Any Matcher. unspecifiedmapAnyOfnodeMatcherFunction...; Matches any of the NodeMatchers with InnerMatchers nested within. Given; if (true);; for (; true; );; with the matcher; mapAnyOf(ifStmt, forStmt).with(; hasCondition(cxxBoolLiteralExpr(equals(true))); ).bind(""trueCond""); matches the if and the for. It is equivalent to:; auto trueCond = hasCondition(cxxBoolLiteralExpr(equals(true)));; anyOf(; ifStmt(trueCond).bind(""trueCond""),; forStmt(trueCond).bind(""trueCond""); );. The with() chain-call accepts zero or more matchers which are combined; as-if with allOf() in each of the node matchers.; Usable as: Any Matcher. Matcher<*>unlessMatcher<*>; Matches if the provided matcher does not match. Example matches Y (matcher = cxxRecordDecl(unless(hasName(""X"")))); class X {};; class Y {};. Usable as: Any Matcher. Matcher<Attr>isImplicit; Matches an entity that has been implicitly added by the compiler (e.g.; implicit default/copy constructors). Matcher<BinaryOperator>hasAnyOperatorNameStringRef, ..., StringRef; Matches operator expressions (binary or unary) that have any of the; specified names. hasAnyOperatorName(""+"", ""-""); Is equivalent to; anyOf(hasOperatorName(""+""), hasOperatorName(""-"")). Matcher<BinaryOperator>hasOperatorNamestd::string Name; Matches the operator Name of operator expressions and fold expressions; (binary or unary). Example matches a || b (matcher = binaryOperator(hasOperatorName(""||""))); !(a || b). Example matches `(0 + ... + args)`; (matcher = cxxFoldExpr(hasOperatorName(""+""))); template <typename... Args>; auto sum(Args... args) {; return (0 + ... + args);; }. Matcher<",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:54862,Usab,Usable,54862,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['Usab'],['Usable']
Usability,"Used Technology; ---------------. `LLVM <https://llvm.org/>`_ is a free, open-source compiler infrastructure under; the `Apache License 2.0 <https://www.apache.org/licenses/LICENSE-2.0>`_. It is; designed as a collection of tools including Front Ends parsers, Middle Ends; optimizers, and Back Ends to produce machine code out of those programs. `Clang <https://clang.llvm.org/>`_ is a front-end that uses a LLVM; license. Clang works by taking the source language (e.g. C++) and translating it; into an intermediate representation that is then received by the compiler back; end (i.e., the LLVM backend). Its library-based architecture makes it relatively; easy to adapt Clang and build new tools based on it. Cling inherits a number of; features from LLVM and Clang, such as: fast compiling and low memory use,; efficient C++ parsing, extremely clear and concise diagnostics, Just-In-Time; compilation, pluggable optimizers, and support for `GCC <https://gcc.gnu.org/>`_; extensions. Interpreters allow for exploration of software development at the rate of human; thought. Nevertheless, interpreter code can be slower than compiled code due to; the fact that translating code at run time adds to the overhead and therefore; causes the execution speed to be slower. This issue is overcome by exploiting; the *Just-In-Time* (`JIT; <https://en.wikipedia.org/wiki/Just-in-time_compilation>`_) compilation method,; which allows an efficient memory management (for example, by evaluating whether; a certain part of the source code is executed often, and then compile this part,; therefore reducing the overall execution time). With the JIT approach, the developer types the code in Cling's command; prompt. The input code is then lowered to Clang, where is compiled and; eventually transformed in order to attach specific behavior. Clang compiles then; the input into an AST representation, that is then lowered to LLVM IR, an; `intermediate language; <https://en.wikipedia.org/wiki/Common_Intermediate_L",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/docs/chapters/implementation.rst:847,clear,clear,847,interpreter/cling/docs/chapters/implementation.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/docs/chapters/implementation.rst,1,['clear'],['clear']
Usability,"User Guides; ===========. NOTE: If you are a user who is only interested in using an LLVM-based compiler,; you should look into `Clang <https://clang.llvm.org>`_ instead. The; documentation here is intended for users who have a need to work with the; intermediate LLVM representation. .. contents::; :local:. .. toctree::; :hidden:. AArch64SME; AddingConstrainedIntrinsics; AdvancedBuilds; AliasAnalysis; AMDGPUUsage; Benchmarking; BigEndianNEON; BuildingADistribution; CFIVerify; CMake; CMakePrimer; CodeGenerator; CodeOfConduct; CommandLine; CompileCudaWithLLVM; CoverageMappingFormat; CycleTerminology; DebuggingJITedCode; DirectXUsage; Docker; FatLTO; ExtendingLLVM; GitHub; GoldPlugin; GlobalISel/MIRPatterns; HowToBuildOnARM; HowToBuildWithPGO; HowToBuildWindowsItaniumPrograms; HowToCrossCompileBuiltinsOnArm; HowToCrossCompileLLVM; HowToUpdateDebugInfo; InstrProfileFormat; InstrRefDebugInfo; LinkTimeOptimization; LoopTerminology; MarkdownQuickstartTemplate; MemorySSA; MergeFunctions; MCJITDesignAndImplementation; MisExpect; ORCv2; OpaquePointers; JITLink; NewPassManager; NVPTXUsage; Phabricator; Passes; ReportingGuide; ResponseGuide; Remarks; RemoveDIsDebugInfo; RISCVUsage; SourceLevelDebugging; SPIRVUsage; StackSafetyAnalysis; SupportLibrary; TableGen/index; TableGenFundamentals; Vectorizers; WritingAnLLVMPass; WritingAnLLVMNewPMPass; WritingAnLLVMBackend; yaml2obj. Clang; -----. :doc:`HowToBuildOnARM`; Notes on building and testing LLVM/Clang on ARM. :doc:`HowToBuildWithPGO`; Notes on building LLVM/Clang with PGO. :doc:`HowToCrossCompileLLVM`; Notes on cross-building and testing LLVM/Clang. `How to build the C, C++, ObjC, and ObjC++ front end`__; Instructions for building the clang front-end from source. .. __: https://clang.llvm.org/get_started.html. :doc:`CoverageMappingFormat`; This describes the format and encoding used for LLVM’s code coverage mapping. :doc:`CFIVerify`; A description of the verification tool for Control Flow Integrity. LLVM Builds and Distribution",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/UserGuides.rst:5,Guid,Guides,5,interpreter/llvm-project/llvm/docs/UserGuides.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/UserGuides.rst,1,['Guid'],['Guides']
Usability,"UsesWith`` to rewrite the debug uses of that; operand. Consider the following example function:. .. code-block:: llvm. define i16 @foo(i16 %a) {; %b = sext i16 %a to i32; %c = and i32 %b, 15; call void @llvm.dbg.value(metadata i32 %c, ...); %d = trunc i32 %c to i16; ret i16 %d; }. Now, here's what happens after the unnecessary truncation instruction ``%d`` is; replaced with a simplified instruction:. .. code-block:: llvm. define i16 @foo(i16 %a) {; call void @llvm.dbg.value(metadata i32 undef, ...); %simplified = and i16 %a, 15; ret i16 %simplified; }. Note that after deleting ``%d``, all uses of its operand ``%c`` become; trivially dead. The debug use which used to point to ``%c`` is now ``undef``,; and debug info is needlessly lost. To solve this problem, do:. .. code-block:: cpp. llvm::replaceAllDbgUsesWith(%c, theSimplifiedAndInstruction, ...). This results in better debug info because the debug use of ``%c`` is preserved:. .. code-block:: llvm. define i16 @foo(i16 %a) {; %simplified = and i16 %a, 15; call void @llvm.dbg.value(metadata i16 %simplified, ...); ret i16 %simplified; }. You may have noticed that ``%simplified`` is narrower than ``%c``: this is not; a problem, because ``llvm::replaceAllDbgUsesWith`` takes care of inserting the; necessary conversion operations into the DIExpressions of updated debug uses. Deleting a MIR-level MachineInstr; ---------------------------------. TODO. Rules for updating ``DIAssignID`` Attachments; =============================================. ``DIAssignID`` metadata attachments are used by Assignment Tracking, which is; currently an experimental debug mode. See :doc:`AssignmentTracking` for how to update them and for more info on; Assignment Tracking. How to automatically convert tests into debug info tests; ========================================================. .. _IRDebugify:. Mutation testing for IR-level transformations; ---------------------------------------------. An IR test case for a transformation can, in many",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToUpdateDebugInfo.rst:8421,simpl,simplified,8421,interpreter/llvm-project/llvm/docs/HowToUpdateDebugInfo.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToUpdateDebugInfo.rst,1,['simpl'],['simplified']
Usability,Utility/StringLexerTest.cpp; lldb/unittests/Utility/StringListTest.cpp; lldb/unittests/Utility/StructuredDataTest.cpp; lldb/unittests/Utility/SubsystemRAIITest.cpp; lldb/unittests/Utility/TildeExpressionResolverTest.cpp; lldb/unittests/Utility/TimeoutTest.cpp; lldb/unittests/Utility/UriParserTest.cpp; lldb/unittests/Utility/UserIDResolverTest.cpp; lldb/unittests/Utility/UUIDTest.cpp; lldb/unittests/Utility/VMRangeTest.cpp; lldb/utils/TableGen/LLDBOptionDefEmitter.cpp; lldb/utils/TableGen/LLDBPropertyDefEmitter.cpp; lldb/utils/TableGen/LLDBTableGen.cpp; lldb/utils/TableGen/LLDBTableGenBackends.h; lldb/utils/TableGen/LLDBTableGenUtils.cpp; lldb/utils/TableGen/LLDBTableGenUtils.h; llvm/bindings/ocaml/llvm/llvm_ocaml.h; llvm/cmake/dummy.cpp; llvm/cmake/unwind.h; llvm/examples/Bye/Bye.cpp; llvm/examples/HowToUseLLJIT/HowToUseLLJIT.cpp; llvm/examples/IRTransforms/InitializePasses.cpp; llvm/examples/IRTransforms/InitializePasses.h; llvm/examples/IRTransforms/SimplifyCFG.cpp; llvm/examples/IRTransforms/SimplifyCFG.h; llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/KaleidoscopeJIT.h; llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/KaleidoscopeJIT.h; llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/KaleidoscopeJIT.h; llvm/examples/Kaleidoscope/Chapter2/toy.cpp; llvm/examples/Kaleidoscope/include/KaleidoscopeJIT.h; llvm/examples/OrcV2Examples/ExampleModules.h; llvm/examples/OrcV2Examples/LLJITDumpObjects/LLJITDumpObjects.cpp; llvm/examples/OrcV2Examples/LLJITWithCustomObjectLinkingLayer/LLJITWithCustomObjectLinkingLayer.cpp; llvm/examples/OrcV2Examples/LLJITWithExecutorProcessControl/LLJITWithExecutorProcessControl.cpp; llvm/examples/OrcV2Examples/LLJITWithGDBRegistrationListener/LLJITWithGDBRegistrationListener.cpp; llvm/examples/OrcV2Examples/LLJITWithInitializers/LLJITWithInitializers.cpp; llvm/examples/OrcV2Examples/LLJITWithLazyReexports/LLJITWithLazyReexports.cpp; llvm/examples/OrcV2Examples/LLJITWithObjectCache/LLJITWithObjectCache.cpp; llvm/examples/OrcV2Examples/LLJ,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt:234804,Simpl,SimplifyCFG,234804,interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,1,['Simpl'],['SimplifyCFG']
Usability,"VM_PROFILE_FILE`` for each invocation. The pattern strings ""%p"" or ""%Nm""; may help to avoid corruption due to concurrency. Note that ""%p"" is also a Lit; token and needs to be escaped as ""%%p"". .. code-block:: console. % clang++ -fprofile-instr-generate -fcoverage-mapping -mllvm -runtime-counter-relocation foo.cc -o foo. Creating coverage reports; =========================. Raw profiles have to be **indexed** before they can be used to generate; coverage reports. This is done using the ""merge"" tool in ``llvm-profdata``; (which can combine multiple raw profiles and index them at the same time):. .. code-block:: console. # Step 3(a): Index the raw profile.; % llvm-profdata merge -sparse foo.profraw -o foo.profdata. For an example of merging multiple profiles created by testing,; see the LLVM `coverage build script <https://github.com/llvm/llvm-zorg/blob/main/zorg/jenkins/jobs/jobs/llvm-coverage>`_. There are multiple different ways to render coverage reports. The simplest; option is to generate a line-oriented report:. .. code-block:: console. # Step 3(b): Create a line-oriented coverage report.; % llvm-cov show ./foo -instr-profile=foo.profdata. This report includes a summary view as well as dedicated sub-views for; templated functions and their instantiations. For our example program, we get; distinct views for ``foo<int>(...)`` and ``foo<float>(...)``. If; ``-show-line-counts-or-regions`` is enabled, ``llvm-cov`` displays sub-line; region counts (even in macro expansions):. .. code-block:: none. 1| 20|#define BAR(x) ((x) || (x)); ^20 ^2; 2| 2|template <typename T> void foo(T x) {; 3| 22| for (unsigned I = 0; I < 10; ++I) { BAR(I); }; ^22 ^20 ^20^20; 4| 2|}; ------------------; | void foo<int>(int):; | 2| 1|template <typename T> void foo(T x) {; | 3| 11| for (unsigned I = 0; I < 10; ++I) { BAR(I); }; | ^11 ^10 ^10^10; | 4| 1|}; ------------------; | void foo<float>(int):; | 2| 1|template <typename T> void foo(T x) {; | 3| 11| for (unsigned I = 0; I < 10; ++I) { BAR(I)",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst:6500,simpl,simplest,6500,interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst,1,['simpl'],['simplest']
Usability,"Validate and push \n to dump()"", shape=""box""];; callp [label="" call print() function "", shape=""box""];; type [label="" Print the Type \n ReplPrintTypeImpl()"", shape=""box""];; data [label="" Print the Data \n ReplPrintDataImpl() "", shape=""box""];; output [label="" Output Pretty Print \n to the user "", shape=""box"", fontcolor=white, fillcolor=""#3333ff"", style=filled];. parse -> capture [label=""Optional 'Value' Parameter""];; capture -> use [label=""Yes""];; use -> End;; capture -> dump [label=""No""];; dump -> callp;; callp -> type;; callp -> data;; type -> output;; data -> output;; }. **Note:** Following is a sample code snippet. Actual code may vary over time. .. code-block:: console. llvm::Error Interpreter::ParseAndExecute(llvm::StringRef Code, Value *V) {. auto PTU = Parse(Code);; if (!PTU); return PTU.takeError();; if (PTU->TheModule); if (llvm::Error Err = Execute(*PTU)); return Err;. if (LastValue.isValid()) {; if (!V) {; LastValue.dump();; LastValue.clear();; } else; *V = std::move(LastValue);; }; return llvm::Error::success();; }. The ``dump()`` function (in ``value.cpp``) calls the ``print()`` function. Printing the Data and Type are handled in their respective functions:; ``ReplPrintDataImpl()`` and ``ReplPrintTypeImpl()``. Annotation Token (annot_repl_input_end); ---------------------------------------. This feature uses a new token (``annot_repl_input_end``) to consider printing the; value of an expression if it doesn't end with a semicolon. When parsing an; Expression Statement, if the last semicolon is missing, then the code will; pretend that there one and set a marker there for later utilization, and; continue parsing. A semicolon is normally required in C++, but this feature expands the C++; syntax to handle cases where a missing semicolon is expected (i.e., when; handling an expression statement). It also makes sure that an error is not; generated for the missing semicolon in this specific case. This is accomplished by identifying the end position of the user i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst:17601,clear,clear,17601,interpreter/llvm-project/clang/docs/ClangRepl.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst,1,['clear'],['clear']
Usability,WARF/DWARFAcceleratorTableTest.cpp; llvm/unittests/DebugInfo/DWARF/DWARFDataExtractorTest.cpp; llvm/unittests/DebugInfo/DWARF/DWARFDebugArangeSetTest.cpp; llvm/unittests/DebugInfo/DWARF/DWARFDebugFrameTest.cpp; llvm/unittests/DebugInfo/DWARF/DWARFDieManualExtractTest.cpp; llvm/unittests/DebugInfo/DWARF/DWARFDieTest.cpp; llvm/unittests/DebugInfo/DWARF/DWARFExpressionCompactPrinterTest.cpp; llvm/unittests/DebugInfo/DWARF/DWARFExpressionCopyBytesTest.cpp; llvm/unittests/DebugInfo/DWARF/DwarfGenerator.h; llvm/unittests/DebugInfo/DWARF/DWARFListTableTest.cpp; llvm/unittests/DebugInfo/DWARF/DWARFLocationExpressionTest.cpp; llvm/unittests/DebugInfo/DWARF/DwarfUtils.cpp; llvm/unittests/DebugInfo/DWARF/DwarfUtils.h; llvm/unittests/DebugInfo/MSF/MSFBuilderTest.cpp; llvm/unittests/DebugInfo/MSF/MSFCommonTest.cpp; llvm/unittests/DebugInfo/PDB/NativeSessionTest.cpp; llvm/unittests/DebugInfo/PDB/NativeSymbolReuseTest.cpp; llvm/unittests/DebugInfo/PDB/StringTableBuilderTest.cpp; llvm/unittests/DebugInfo/PDB/Inputs/SimpleTest.cpp; llvm/unittests/Debuginfod/DebuginfodTests.cpp; llvm/unittests/Debuginfod/HTTPClientTests.cpp; llvm/unittests/Demangle/DemangleTest.cpp; llvm/unittests/Demangle/DLangDemangleTest.cpp; llvm/unittests/Demangle/OutputBufferTest.cpp; llvm/unittests/Demangle/RustDemangleTest.cpp; llvm/unittests/Demangle/StringViewTest.cpp; llvm/unittests/ExecutionEngine/JITLink/LinkGraphTests.cpp; llvm/unittests/ExecutionEngine/Orc/EPCGenericJITLinkMemoryManagerTest.cpp; llvm/unittests/ExecutionEngine/Orc/EPCGenericMemoryAccessTest.cpp; llvm/unittests/ExecutionEngine/Orc/ExecutionSessionWrapperFunctionCallsTest.cpp; llvm/unittests/ExecutionEngine/Orc/ExecutorAddressTest.cpp; llvm/unittests/ExecutionEngine/Orc/JITTargetMachineBuilderTest.cpp; llvm/unittests/ExecutionEngine/Orc/LazyCallThroughAndReexportsTest.cpp; llvm/unittests/ExecutionEngine/Orc/LookupAndRecordAddrsTest.cpp; llvm/unittests/ExecutionEngine/Orc/ObjectLinkingLayerTest.cpp; llvm/unittests/ExecutionEngine/Orc/OrcCA,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt:344947,Simpl,SimpleTest,344947,interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,1,['Simpl'],['SimpleTest']
Usability,"W_AT_location``; attribute that is encoded as a ``loclist`` or ``loclistsptr``, and the; specified location list expression E' matches a single location list; entry with operation expression E, the same as the ``exprloc`` case and; evaluate on the same stack. But this is not attractive as if the attribute is for a variable that; happens to end with a non-singleton stack, it will not simply put a; location description on the stack. Presumably the intent of using; ``DW_OP_call*`` on a variable or formal parameter debugger information; entry is to push just one location description on the stack. That; location description may have more than one single location description. The previous rule for ``exprloc`` also has the same problem, as normally; a variable or formal parameter location expression may leave multiple; entries on the stack and only return the top entry. GDB implements ``DW_OP_call*`` by always executing E on the same stack.; If the location list has multiple matching entries, it simply picks the; first one and ignores the rest. This seems fundamentally at odds with; the desire to support multiple places for variables. So, it feels like ``DW_OP_call*`` should both support pushing a location; description on the stack for a variable or formal parameter, and also; support being able to execute an operation expression on the same stack.; Being able to specify a different operation expression for different; program locations seems a desirable feature to retain. A solution to that is to have a distinct ``DW_AT_LLVM_proc`` attribute; for the ``DW_TAG_dwarf_procedure`` debugging information entry. Then the; ``DW_AT_location`` attribute expression is always executed separately; and pushes a location description (that may have multiple single; location descriptions), and the ``DW_AT_LLVM_proc`` attribute expression; is always executed on the same stack and can leave anything on the; stack. The ``DW_AT_LLVM_proc`` attribute could have the new classes; ``exprproc``, ``",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:77529,simpl,simply,77529,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['simpl'],['simply']
Usability,"Why interpreting C++ with Cling?; -----------------------------------. 1. **Learning C++:**; ; One use case of Cling is to aid the C++ learning process. Offering imediate; feedback the user can easily get familiar with the structures and spelling of; the language. 2. **Creating scripts:**; ; The power of an interpreter lays as well in the compactness and ease of; repeatedly running a small snippet of code - aka a script. This can be done in; Cling by inserting the bash-like style line:. .. code:: bash; ; #!/usr/bin/cling; ; 3. **Rapid Application Development (RAD):**. Cling can be used successfully for Rapid Application Development allowing for; prototyping and proofs of concept taking advantage of dynamicity and feedback; during the implementation process. 4. **Runtime-Generated Code**. Sometime it's convenient to create code as a reaction to input; (user/network/configuration). Runtime-generated code can interface with C++; libraries. 5. **Embedding Cling:**. The functionality of an application can be enriched by embedding Cling. To embed; Cling, the main program has to be provided. One of the things this main program; has to do is initialize the Cling interpreter. There are optional calls to pass; command line arguments to Cling. Afterwards, you can call the interpreter from; any anywhere within the application. For compilation and linkage the application needs the path to the Clang and LLVM; libraries and the invocation is order dependent since the linker cannot do; backward searches. .. code:: bash. g++ embedcling.cxx -std=c++11 -L/usr/local/lib; -lclingInterpreter -lclingUtils ; -lclangFrontend -lclangSerialization -lclangParse -lclangSema ; -lclangAnalysis -lclangEdit -lclangLex -lclangDriver -lclangCodeGen ; -lclangBasic -lclangAST ; `llvm-config ; --libs bitwriter mcjit orcjit native option ; ipo profiledata instrumentation objcarcopts` ; -lz -pthread -ldl -ltinfo ; -o embedcling; . Embedding Cling requires the creation of the interpreter. Optionally compile",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/docs/chapters/why_interpreting.rst:76,Learn,Learning,76,interpreter/cling/docs/chapters/why_interpreting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/docs/chapters/why_interpreting.rst,4,"['Learn', 'feedback', 'learn']","['Learning', 'feedback', 'learning']"
Usability,"Write up design. Interface; ---------. The core routine of LibFormat is ``reformat()``:. .. code-block:: c++. tooling::Replacements reformat(const FormatStyle &Style, Lexer &Lex,; SourceManager &SourceMgr,; std::vector<CharSourceRange> Ranges);. This reads a token stream out of the lexer ``Lex`` and reformats all the code; ranges in ``Ranges``. The ``FormatStyle`` controls basic decisions made during; formatting. A list of options can be found under :ref:`style-options`. The style options are described in :doc:`ClangFormatStyleOptions`. .. _style-options:. Style Options; -------------. The style options describe specific formatting options that can be used in; order to make `ClangFormat` comply with different style guides. Currently,; several style guides are hard-coded:. .. code-block:: c++. /// Returns a format style complying with the LLVM coding standards:; /// https://llvm.org/docs/CodingStandards.html.; FormatStyle getLLVMStyle();. /// Returns a format style complying with Google's C++ style guide:; /// http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml.; FormatStyle getGoogleStyle();. /// Returns a format style complying with Chromium's style guide:; /// https://chromium.googlesource.com/chromium/src/+/refs/heads/main/styleguide/styleguide.md; FormatStyle getChromiumStyle();. /// Returns a format style complying with the GNU coding standards:; /// https://www.gnu.org/prep/standards/standards.html; FormatStyle getGNUStyle();. /// Returns a format style complying with Mozilla's style guide; /// https://firefox-source-docs.mozilla.org/code-quality/coding-style/index.html; FormatStyle getMozillaStyle();. /// Returns a format style complying with Webkit's style guide:; /// https://webkit.org/code-style-guidelines/; FormatStyle getWebkitStyle();. /// Returns a format style complying with Microsoft's style guide:; /// https://docs.microsoft.com/en-us/visualstudio/ide/editorconfig-code-style-settings-reference; FormatStyle getMicrosoftStyle();. These optio",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibFormat.rst:1369,guid,guide,1369,interpreter/llvm-project/clang/docs/LibFormat.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibFormat.rst,1,['guid'],['guide']
Usability,"X axis. The return histogram will have as bin error an approximate error on the quantile assuming a normal distribution of the; bin contents in the other axis. - Update Projection methods of both TH2 and TH3 to not return a null; pointer when an histogram with the same name already existed and it; was not compatible. Now just set the new correct binning on the; previously existing histogram. ### TGraph. - `TGraph::Draw()` needed at least the option `AL` to draw the graph; axis even when there was no active canvas or when the active canvas; did not have any axis defined. This was counter-intuitive. Now if; `TGraph::Draw()` is invoked without parameter and if there is no; axis defined in the current canvas, the option `ALP` is automatically; set.; - Change `SavePrimtive()` to improve speed compilation on generated macros. ### TGraph2D. - When `GetX(YZ)axis` were called on a `TGraph2D`, the frame limit and; plotting options were changed.; - Modify the `Clear` function in order to be able to reuse a; `TGraph2D` after a `Clear` is performed.; - In `GetHistogram()` the lower and higher axis limits are always; different.; - Protection added to avoid a Seg Fault on `.q` when `SetHistogram()`; is called on a `TGraph2D`. ### TMultiGraph. - In `TMultiGraph::Add(TMultiGraph *multigraph, Option_t *chopt)`; If `chopt` is defined all the graphs in `multigraph` will be added; with the `chopt` option. If `chopt` is undefined each graph will; be added with the option it had in `multigraph`.; - The option ""A"" in the `Draw()` was not cleaning properly the; current pad.; - Implement this option `pads`. This option is equivalent to the one in; `THStack`. It allows to draw all the `TGraphs` in separated pads. ### THStack. - By default the background of the histograms is erased before drawing the; histograms. The new option `noclear` avoid this behaviour. This is useful; when drawing a `THStack` on top of an other plot. If the patterns used to; draw the histograms in the stack are transpar",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v600/index.md:11215,Clear,Clear,11215,hist/doc/v600/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v600/index.md,2,['Clear'],['Clear']
Usability,"[tree]` indicates a; change to TTree, `[RF]` indicates a change to RooFit). If you are unsure about which scope tags to use, we are happy to; point you in the right direction! See also the [commit log](https://github.com/root-project/root/commits/master/) for; examples. The summary itself should not exceed 50 characters (excluding the scope tag), be meaningful (i.e., it; describes the change) and should be written in the; [present imperative mood](https://git.kernel.org/pub/scm/git/git.git/tree/Documentation/SubmittingPatches?id=HEAD#n239); (e.g. `Add this awesome feature` instead of `Adds this awesome feature` or `Added this awesome feature`). The commit message that follow the summary can be used to provide more context to the change.; It should describe the **why**, rather than the **what** and **how** (we can gather this from the commit summary and the; change diff, respectively).; The commit message should be wrapped at 72 characters. > [!TIP]; > We provide a commit message template to help with following the above guidelines. It can be found in the root of this; > repository as [`.git-commit-template`](https://github.com/root-project/root/blob/master/.git-commit-template),; > and can be set to automatically be used for every commit with the following command:; > ```sh; > $ git config commit.template .git-commit-template; > ```. ## Your Pull Request. > [!NOTE]; > For the mechanics on how to create pull requests, please visit; > [this page](https://root.cern/for_developers/creating_pr). The title of your PR follows the same principle as the commit summary. If your PR only involves one commit, you can; reuse this summary. For non-functional changes (e.g. to the documentation) or changes for which you want to; **temporarily** prevent Jenkins from being triggered (e.g., for a draft PR), use `[skip-CI]` as the first tag.; Note that for functional changes this tag needs to be removed and it has to pass the CI before merging to ensure; the change does not break anythi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/CONTRIBUTING.md:3577,guid,guidelines,3577,CONTRIBUTING.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/CONTRIBUTING.md,1,['guid'],['guidelines']
Usability,"\addtogroup tutorial_FOAM. @{. ### What is FOAM ?. FOAM is simplified version of multi-dimensional general; purpose Monte Carlo event generator (integrator) with hyper-cubical; ""foam of cells"". Certain features of full version of FOAM are omitted.; mFOAM is intended as an easy to use tool for MC; simulation/integration in few dimensions. It relies heavily on ROOT package,; borrowing persistency of classes from ROOT. mFOAM can be easily used from; the ROOT shell. For more difficult problems the full FOAM may be better. ### How to run application programs ?. The application program can be run in two modes: it can be simply; interpreted by CLING or compiled. The first method is simpler but; results in slower execution. The second method employs ACLiC -; The Automatic Compiler of Libraries, which automatizes the; process of compilation and linking. In $(ROOTSYS)/tutorials there are 3 demonstration programs:. #### foam_kanwa.C; is a simple example how to run FOAM in interactive; mode. To run this macro issue the following simple command from the; Linux shell:. ```; root foam_kanwa.C; ```. or from CLING:. ```; root [0] .x foam_kanwa.C; ```. Simulation will start and graphical canvas with plot; of the distribution function appear. In this example; we defined the distribution function simply as a global; function function Camel2. #### foam_demo.C; shows usage of FOAM in compiled mode, which is; the preferred method. The integrand function is defined; now as a Density method from class TFDISTR inheriting from; abstract class TFoamIntegrand. User can modify interface to; integrand function according to their needs but they should; always remember to define Density method which provides the; density distribution.; Enter CLING interpreter and type:. ```; root [0] gSystem->Load(""libFoam.so""); root [1] .x foam_demo.C+; ```. to load FOAM library, compile and execute macro foam_demo.C.; A shared object foam_demo_C.so is created in the current; directory. At the end of exploration ph",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/foam/index.md:59,simpl,simplified,59,tutorials/foam/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/foam/index.md,4,['simpl'],"['simple', 'simpler', 'simplified', 'simply']"
Usability,"\addtogroup tutorial_dataframe. @{. [RDataFrame](classROOT_1_1RDataFrame.html) offers a high level interface for the analysis of data stored in [TTree](classTTree.html)s, [CSV files](classROOT_1_1RDF_1_1RCsvDS.html) and [other data formats](classROOT_1_1RDF_1_1RDataSource.html). In addition, multi-threading and other low-level optimisations allow users to exploit all the resources available on their machines transparently. In a nutshell:; ~~~{.cpp}; ROOT::EnableImplicitMT(); // Enable ROOT's implicit multi-threading; ROOT::RDataFrame d(""myTree"", ""file_*.root""); // Interface to TTree and TChain; auto histoA = d.Histo1D(""Branch_A""); // Book the filling of a histogram; auto histoB = d.Histo1D(""Branch_B""); // Book the filling of another histogram; // Data processing is triggered by the next line, which accesses a booked result for the first time; // All booked results are evaluated during the same parallel event loop.; histoA->Draw(); // <-- event loop runs here!; histoB->Draw(); // HistoB has already been filled, no event loop is run here; ~~~. Explore the examples below or go to [RDataFrame's user guide](classROOT_1_1RDataFrame.html). @}",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/dataframe/index.md:1113,guid,guide,1113,tutorials/dataframe/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/dataframe/index.md,1,['guid'],['guide']
Usability,\addtogroup tutorial_v7. @{. \warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback is welcome!. @}. \defgroup tutorial_rcanvas RCanvas examples; \ingroup tutorial_v7; \brief These are RCanvas examples ...; ,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/v7/index.md:137,Feedback,Feedback,137,tutorials/v7/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/v7/index.md,1,['Feedback'],['Feedback']
Usability,\addtogroup tutorial_vecops. @{. Please note that you can find the exhaustive documentation [here in the reference guide](<https://root.cern/doc/master/classROOT_1_1VecOps_1_1RVec.html>). @}; ,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/vecops/index.md:115,guid,guide,115,tutorials/vecops/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/vecops/index.md,1,['guid'],['guide']
Usability,"\clang.EXE'; -- Testing: Testing: 2534 tests, 4 threads --; Testing: 0 .. 10.. 20.. 30.. 40.. 50.. 60.. 70.. 80.. 90..; Testing Time: 81.52s; Passed : 2503; Expectedly Failed: 28; Unsupported : 3. The statistic, ""Failed"" (not shown if all tests pass), is the important one. Testing changes affecting libc++. Some changes in Clang affect libc++,; for example:. Changing the output of Clang's diagnostics.; Changing compiler builtins, especially the builtins used for type traits; or replacements of library functions like std::move or; std::forward. After adjusting libc++ to work with the changes, the next revision will be; tested by libc++'s; pre-commit CI. For most configurations, the pre-commit CI uses a recent; nightly build of Clang from LLVM's main; branch. These configurations do not use the Clang changes in the; patch. They only use the libc++ changes.; The ""Bootstrapping build"" builds Clang and uses it to build and; test libc++. This build does use the Clang changes in the patch.; Libc++ supports multiple versions of Clang. Therefore when a patch changes; the diagnostics it might be required to use a regex in the; ""expected"" tests to make it pass the CI.; Libc++ has more; ; documentation about the pre-commit CI. For questions regarding; libc++, the best place to ask is the #libcxx channel on; LLVM's Discord server. Creating Patch Files. To contribute changes to Clang see; LLVM's Getting Started page. LLVM IR Generation. The LLVM IR generation part of clang handles conversion of the; AST nodes output by the Sema module to the LLVM Intermediate; Representation (IR). Historically, this was referred to as; ""codegen"", and the Clang code for this lives; in lib/CodeGen.; The output is most easily inspected using the -emit-llvm; option to clang (possibly in conjunction with -o -). You; can also use -emit-llvm-bc to write an LLVM bitcode file; which can be processed by the suite of LLVM tools; like llvm-dis, llvm-nm, etc. See the LLVM; Command Guide; for more information. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html:9585,Guid,Guide,9585,interpreter/llvm-project/clang/www/hacking.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html,1,['Guid'],['Guide']
Usability,\defgroup HistV7 ROOT 7 histogram classes.; \ingroup Hist. \warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback; ,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/doc/index.md:167,Feedback,Feedback,167,hist/histv7/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/doc/index.md,1,['Feedback'],['Feedback']
Usability,\defgroup Histpainter Histograms and graphs painting classes.; \ingroup HistPainting. The histograms and graphs plotting options are described in details in the THistPainter and TGraphPainter classes.; Some related tutorials:. - graph.C: Using and drawing a simple TGraph.; - graph2derrorsfit.C: TGraph2D with errors drawing.; - h1draw.C: Drawing Options for 1D Histograms.; - hbars.C: Demo of option bar with histograms.; - hsimple.C: Simple drawing of a 1D Histograms.; - hsum.C: Filling several histograms and some graphics options.; - surfaces.C: Drawing a TH2 as a 2-D surface. Some related HowTos:; - [How to Draw objects ?](https://root-forum.cern.ch/t/how-to-draw-objects/28249); - [How to change the position of the statistics box on histogram plot ?](https://root-forum.cern.ch/t/how-to-change-the-position-of-the-statistics-box-on-histogram-plot/28262); - [How to draw several TGraph in one common axis system ?](https://root-forum.cern.ch/t/how-to-draw-several-tgraph-in-one-common-axis-system/28261); ,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/doc/index.md:258,simpl,simple,258,hist/histpainter/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/doc/index.md,2,"['Simpl', 'simpl']","['Simple', 'simple']"
Usability,"\defgroup MinuitOld TMinuit; \ingroup Math; \brief The Minuit Minimization package.; \see Minuit2 for a newer version of this package. Direct C++ implementation of the Minuit minimization package. This package was originally written in Fortran by Fred James; and part of PACKLIB (patch D506). It has been converted to a C++ class, TMinuit, by R.Brun. See also:. - The main documentation is in the class TMinuit; - [The Chapter about Fitting Histogram in the Users Guide](https://root.cern/manual/fitting/#fitting-1-d-histograms-with-pre-defined-functions); - [The MINUIT documentation in CERNLIB](https://root.cern.ch/download/minuit.pdf); - [How to Fit Histograms](https://root-forum.cern.ch/t/how-to-fit-histograms-or-data-points/38870); - peaks.C How to Fit find peaks in histograms; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit/doc/index.md:464,Guid,Guide,464,math/minuit/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit/doc/index.md,1,['Guid'],['Guide']
Usability,\defgroup ROOT7Graphics ROOT7 Graphics; \ingroup Graphics; \brief Classes for ROOT7 graphics. \warning This is part of the ROOT7 prototype! It will change without notice. It might trigger earthquakes. Feedback is welcome!. \defgroup GpadROOT7 ROOT7 Pad related classes; \ingroup ROOT7Graphics; \brief The ROOT7 Pad related classes. \defgroup BaseROOT7 ROOT7 Base graphics classes; \ingroup ROOT7Graphics; \brief The ROOT7 Base graphics classes. \defgroup CanvasPainterROOT7 ROOT7 Canvas painting classes; \ingroup ROOT7Graphics; \brief The ROOT7 Canvas painting classes. \defgroup GrafROOT7 ROOT7 Graphics primitives; \ingroup ROOT7Graphics; \brief The ROOT7 Graphics primitives.; ,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpadv7/doc/index.md:201,Feedback,Feedback,201,graf2d/gpadv7/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpadv7/doc/index.md,1,['Feedback'],['Feedback']
Usability,"\defgroup Roofit RooFit; \brief RooFit main classes for building likelihood models, mainly PDFs.; \ingroup Roofitmain. For an introduction check the [user's guides](https://root.cern.ch/root-user-guides-and-manuals),; [courses](https://root.cern.ch/learn/courses) or [the RooFit chapter of the Manual](https://root.cern/manual/roofit/). For tutorials see \ref tutorial_roofit.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/doc/index.md:157,guid,guides,157,roofit/roofit/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/doc/index.md,3,"['guid', 'learn']","['guides', 'guides-and-manuals', 'learn']"
Usability,"\defgroup Roofitmain RooFit; \brief RooFit is a package for building likelihood models and fitting these to data. For an introduction check the \ref tutorial_roofit, [user's guides](https://root.cern.ch/root-user-guides-and-manuals),; [courses](https://root.cern.ch/learn/courses) or [the RooFit chapter of the Manual](https://root.cern/manual/roofit/). For developers, there is also the \ref roofit_dev_docs, which serves as a reference on how to extend %RooFit with custom classes or for contributing to %RooFit itself. \defgroup roofit_dev_docs RooFit Developer Documentation; \brief How-to guides on how to extend \ref Roofitmain with custom classes or to work on %RooFit itself.; \ingroup Roofitmain; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/index.md:174,guid,guides,174,roofit/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/index.md,4,"['guid', 'learn']","['guides', 'guides-and-manuals', 'learn']"
Usability,\defgroup Roostats RooStats; \brief RooStats is a toolkit for statistical tests built on top of RooFit.; \ingroup Roofitmain. RooStats is a package containing statistical tools built on top of RooFit.; See the RooStats [Twiki Page](https://twiki.cern.ch/twiki/bin/view/RooStats/WebHome) or the [courses](https://root.cern/learn/courses) for more information. For tutorials see \ref tutorial_roostats. ; ,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/doc/index.md:322,learn,learn,322,roofit/roostats/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/doc/index.md,1,['learn'],['learn']
Usability,"\defgroup TMVA TMVA; \brief The Multi Variate Analysis package. The TMVA Multi-Variate-Analysis classes. See:. - [The TMVA Web manual in ROOT Web site](https://root.cern/manual/tmva/); - [The TMVA Users Guide.](https://github.com/root-project/root/blob/master/documentation/tmva/UsersGuide/TMVAUsersGuide.pdf). Old links, referring to old TMVA versions, but they can still be useful for some of the TMVA methods:. - [Description of the traditional TMVA Methods](http://tmva.sourceforge.net/old_site); - [The TMVA Options Reference.](http://tmva.sourceforge.net/old_site/optionRef.html). ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/doc/index.md:203,Guid,Guide,203,tmva/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/doc/index.md,1,['Guid'],['Guide']
Usability,"\defgroup Tutorials Tutorials; \brief A collection of C++ macros, Python scripts and notebooks helping to learn ROOT by example. You can execute the scripts in `$ROOTSYS/tutorials` (or sub-directories); by setting your current directory in the script directory or from any; user directory with write access. Several tutorials create new files. If you have write access to; the tutorials directory, the new files will be created in the tutorials; directory, otherwise they will be created in the user directory. You can start by executing the standard ROOT demos with a session like:. ```; root > .x demos.C; ```; or. ```; root > .x $ROOTSYS/tutorials/demos.C; ```. You can execute the standard ROOT graphics benchmark with. ```; root > .x benchmarks.C; ```. or. ```; root > .x $ROOTSYS/tutorials/benchmarks.C; ```. The `$ROOTSYS/tutorials` directory includes several sub-directories:. \defgroup tutorial_hist Histograms tutorials; \ingroup Tutorials; \brief Examples showing the ""histograms' classes"" usage. \defgroup tutorial_tree Tree tutorials; \ingroup Tutorials; \brief Example code which illustrates how to use ROOT trees and ntuples. \defgroup tutorial_dataframe Dataframe tutorials; \ingroup Tutorials; \brief These examples show various features of [RDataFrame](classROOT_1_1RDataFrame.html): ROOT's declarative analysis interface. \defgroup tutorial_v7 ROOT 7 tutorials; \ingroup Tutorials; \brief Various examples showing the ROOT 7 interface. \defgroup tutorial_FOAM FOAM tutorials; \ingroup Tutorials; \brief Examples showing how to use FOAM. \defgroup tutorial_cont Containers tutorials; \ingroup Tutorials; \brief Examples showing the ""containers' classes"" usage. \defgroup tutorial_eve Event display tutorials; \ingroup Tutorials; \brief Examples showing the ""Event display classes"" usage. \defgroup tutorial_eve7 Event display ROOT7 tutorials; \ingroup Tutorials; \brief Examples showing the ""Event display classes"" usage with ROOT7. \defgroup tutorial_geom Geometry tutorials; \ingro",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/index.md:106,learn,learn,106,tutorials/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/index.md,1,['learn'],['learn']
Usability,\defgroup guihtml HTML visualizer; \ingroup gui; \brief A very simple HTML browser.; ,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/doc/index.md:63,simpl,simple,63,gui/guihtml/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/doc/index.md,1,['simpl'],['simple']
Usability,"\defgroup roofit_dev_docs_ad How to extend the use of Automatic Differentiation in RooFit; \ingroup roofit_dev_docs; \date October 2023; \brief Developer guide on how to add support for Automatic Differentiation via code generation. # How to extend the use of Automatic Differentiation in RooFit. ## What is RooFit?. [RooFit] is a statistical data analysis tool, widely used in scientific; research, especially in the high-energy physics (HEP) field. It is an; extension of the ROOT framework, a C++ based data analysis framework that; provides tools for data storage, analysis, and visualization. RooFit provides; a set of tools/classes to define and evaluate probability density functions; (PDFs), perform maximum likelihood fits, perform statistical tests, etc. ## Proof of Concept: Speeding up RooFit using Automatic Differentiation (AD). RooFit is used to reduce statistical models (functions) to find a set of; parameters that minimize the value of the function. This minimization happens; via one of several methods relying heavily on the computation of derivatives; of the function with respect to its free parameters. Currently, the; computation of Numerical Derivatives is the most time-consuming component of; RooFit [^1]. On the other hand, derivatives computed using the Automatic; Differentiation tool [Clad] have been shown to be far more efficient [^2]. \htmlonly; <div class=""pyrootbox"">; \endhtmlonly. Main Advantage of using AD with RooFit: efficient and more precise; derivatives. It computes derivatives with high precision, avoiding the errors; that may arise from approximating derivatives using finite differences. \htmlonly; </div>; \endhtmlonly. ### AD Support essentially requires Code Generation. As we'll discuss in upcoming sections, *AD support* can be added using *C++; Code generation*.; These two terms may be used interchangeably in this document, since the term; *Code Generation* better helps visualize the transformation that is enabling; AD support. ## Current S",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md:154,guid,guide,154,roofit/doc/developers/roofit_ad.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md,1,['guid'],['guide']
Usability,"\defgroup roofit_dev_docs_batchcompute RooBatchCompute library guide; \ingroup roofit_dev_docs; \date September 2021; \author Emmanouil Michalainas; \brief Overview of the RooBatchCompute library. ## RooBatchCompute Library; _Contains optimized computation functions for PDFs that enable significantly faster fittings._; #### Note: This library is still at an experimental stage. Tests are being conducted continuously to ensure correctness of the results, but the interfaces and the instructions on how to use might change. ### Purpose; While fitting, a significant amount of time and processing power is spent on computing the probability function for every event and PDF involved in the fitting model. To speed up this process, roofit can use the computation functions provided in this library. The functions provided here process whole data arrays (batches) instead of a single event at a time, as in the legacy evaluate() function in roofit. In addition, the code is written in a manner that allows for compiler optimizations, notably auto-vectorization. This library is compiled multiple times for different [vector instruction set architectures](https://en.wikipedia.org/wiki/SIMD) and the optimal code is executed during runtime, as a result of an automatic hardware detection mechanism that this library contains. **As a result, fits can benefit by a speedup of 3x-16x.**. As of ROOT v6.26, RooBatchComputes also provides multithread and [CUDA](https://en.wikipedia.org/wiki/CUDA) instances of the computation functions, resulting in even greater improvements for fitting times. ### How to use; This library is an internal component of RooFit, so users are not supposed to actively interact with it. Instead, they can benefit from significantly faster times for fitting by calling `fitTo()` and providing a `BatchMode(""cpu"")` or a `BatchMode(""cuda"")` option.; ``` {.cpp}; // fit using the most efficient library that the computer's CPU can support; RooMyPDF.fitTo(data, BatchMode(""cpu""));. //",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/batchcompute.md:63,guid,guide,63,roofit/doc/developers/batchcompute.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/batchcompute.md,1,['guid'],['guide']
Usability,"\defgroup roofit_dev_docs_hs3 Implement JSON I/O for a RooFit class with RooFit HS3; \ingroup roofit_dev_docs; \date March 2023; \author Carsten Burgard; \brief Guide on how to add JSON IO for you RooFit classes. ## RooFitHS3 Library; _Contains facilities to serialize and deserialize RooWorkspaces to and from JSON and YML._; #### Note: This library is still at an experimental stage. ### Purpose. When using `RooFit`, statistical models can be conveniently handled and; stored as a `RooWorkspace`. However, for the sake of interoperability; with other statistical frameworks, and also ease of manipulation, it; may be useful to store statistical models in text form. This library; sets out to achieve exactly that, exporting to and importing from JSON; and YML. ### Backend. The default backend for this is the `nlohmann` JSON implementation,; which ships with ROOT as a builtin dependency and will import from and; export to JSON. Alternatively, the RapidYAML (`RYML`) implementation; can be used to also import from and export to YML. This implementation; can be selected at compile time with the `cmake` flag; `roofit_hs3_ryml`. ### Usage. The main class providing import from and export to JSON and YML is the; RooJSONFactoryWSTool. ### Open-world philosophy. One of the most challenging aspects of providing serialization and; deserialization for `RooFit` is the fact that `RooFit` follows an; ""open-world"" philosophy with respect to the functions and pdfs it can; handle. Over the years, `RooFit` has also accumulated a significant; number of different pre-implemented functions and pdfs. What is more,; you can easily create your own `RooFit` function by inheriting from; `RooAbsReal` or your own `RooFit` pdf by inheriting from; `RooAbsPdf`. This means that feature-complete serialization and; deserialization to and from JSON and YML will probably never be fully; achieved. However, this may not impede your usage of this library, as; it was written in such a way as to allow users (that is",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_hs3.md:161,Guid,Guide,161,roofit/doc/developers/roofit_hs3.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_hs3.md,1,['Guid'],['Guide']
Usability,\defgroup tutorial_ntuple ROOT 7 ntuple tutorials; \ingroup tutorial_v7; \brief Various examples showing the ROOT 7 ntuples.; \warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback is welcome!; ,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/v7/ntuple/index.md:234,Feedback,Feedback,234,tutorials/v7/ntuple/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/v7/ntuple/index.md,1,['Feedback'],['Feedback']
Usability,"\mainpage %ROOT Reference Documentation. ### Introduction; Welcome to %ROOT!. This is the Reference Guide of the ROOT software toolkit.; You can find in the [reference documentation page](https://root.cern/reference/) pointers; to Reference Guides for all %ROOT versions. ### Manuals. - The [Manual](https://root.cern/manual/) provides a more in depth explanation of; concepts and functionality available in the %ROOT system. It is closely linked to the; Reference Guide.; - A number of topical [User Guides and Manuals](https://root.cern/topical/) for various; components of the system. ### Tutorials and courses. - A rich set of %ROOT [tutorials and code examples](https://root.cern/doc/master/group__Tutorials.html) are offered to developers to exercise specific functionality.; - [ROOT Primer](https://root.cern/primer/).; - [ROOT Introductory Course](https://github.com/root-project/training/tree/master/BasicCourse). ### Provide your feedback; If you have suggestions about how to improve this documentation, you can let us know:. - With a [PR](https://github.com/root-project/root); - On the [ROOT Forum](https://root-forum.cern.ch); - On [our tracker](https://github.com/root-project/root/issues); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/doxygen/mainpage.md:100,Guid,Guide,100,documentation/doxygen/mainpage.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/doxygen/mainpage.md,5,"['Guid', 'feedback']","['Guide', 'Guides', 'feedback']"
Usability,"\theta_i^2$ instead of $\theta_i$. FUMILI will fail if; one tries minimize $\chi^2 = g^2(\vec\theta)$ where g is arbitrary; function. Approximate value is:. $$; {\frac{\partial^2\chi^2}{\partial\theta_i\partial\theta_k}}\approx Z_{ik}=; \sum^n_{j=1}{\frac{1}{\sigma^2_j}}{\frac{\partial f_j}{\theta_i}}; {\frac{\partial f_j}{\theta_k}}; $$. Then the equations for parameter increments are:. $$; \left(\frac{\partial\chi^2}{\partial\theta_i}\right)_; {\vec\theta={\vec\theta}^0} +\sum_k Z_{ik}\cdot(\theta_k-\theta^0_k) =; 0, \qquad i=1\ldots m; $$. Remarkable feature of algorithm is the technique for step restriction.; For an initial value of parameter ${\vec\theta}^0$ a parallelepiped; $P_0$ is built with the center at ${\vec\theta}^0$ and axes parallel; to coordinate axes $\theta_i$. The lengths of parallelepiped sides; along i-th axis is $2b_i$, where $b_i$ is such a value that the; functions $f_j(\vec\theta)$ are quasi-linear all over the; parallelepiped. FUMILI takes into account simple linear inequalities in the form:. $$ \theta_i^{min}\le\theta_i\le\theta^{max}_i$$. They form parallelepiped $P$ ($P_0$ may be deformed by $P$). Very; similar step formulae are used in FUMILI for negative logarithm of; the likelihood function with the same idea - linearization of function; argument. ## Neural Networks. ### Introduction. Neural Networks are used in various fields for data analysis and; classification, both for research and commercial institutions. Some; randomly chosen examples are image analysis, financial movements'; predictions and analysis, or sales forecast and product shipping; optimization. In particles physics neural networks are mainly used for; classification tasks (signal over background discrimination). A vast; majority of commonly used neural networks are multilayer perceptrons.; This implementation of multilayer perceptrons is inspired from the; `MLPfit` package, which remains one of the fastest tools for neural; networks studies. ### The MLP. The multilaye",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:69501,simpl,simple,69501,documentation/users-guide/FittingHistograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md,1,['simpl'],['simple']
Usability,"]. :program:`lldb-tblgen` [*options*] [*filename*]. :program:`llvm-tblgen` [*options*] [*filename*]. :program:`mlir-tblgen` [*options*] [*filename*]. DESCRIPTION; -----------. :program:`*-tblgen` is a family of programs that translates target; description (``.td``) files into C++ code and other output formats. Most; users of LLVM will not need to use this program. It is used only for; writing parts of the compiler, debugger, and LLVM target backends. The details of the input and output of the :program:`*-tblgen` programs is; beyond the scope of this short introduction; please see the :doc:`TableGen; Overview <../TableGen/index>` for an introduction and for references to; additional TableGen documents. The *filename* argument specifies the name of the Target Description (``.td``); file that TableGen processes. OPTIONS; -------. General Options; ~~~~~~~~~~~~~~~. .. option:: -help. Print a description of the command line options. .. option:: -help-list. Print a description of the command line options in a simple list format. .. option:: -D=macroname. Specify the name of a macro to be defined. The name is defined, but it; has no particular value. .. option:: -d=filename. Specify the name of the dependency filename. .. option:: -debug. Enable debug output. .. option:: -dump-json. Print a JSON representation of all records, suitable for further; automated processing. .. option:: -I directory. Specify where to find other target description files for inclusion. The; ``directory`` value should be a full or partial path to a directory that; contains target description files. .. option:: -null-backend. Parse the source files and build the records, but do not run any; backend. This is useful for timing the frontend. .. option:: -o filename. Specify the output file name. If ``filename`` is ``-``, then; :program:`*-tblgen` sends its output to standard output. .. option:: -print-records. Print all classes and records to standard output (default backend option). .. option:: -print-d",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/tblgen.rst:1174,simpl,simple,1174,interpreter/llvm-project/llvm/docs/CommandGuide/tblgen.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/tblgen.rst,1,['simpl'],['simple']
Usability,"]; %hdl = call noalias ptr @llvm.coro.begin(token %id, ptr %phi); br label %loop; loop:; %n.val = phi i32 [ %n, %coro.begin ], [ %inc, %loop ]; %inc = add nsw i32 %n.val, 1; store i32 %n.val, ptr %promise; %0 = call i8 @llvm.coro.suspend(token none, i1 false); switch i8 %0, label %suspend [i8 0, label %loop; i8 1, label %cleanup]; cleanup:; %mem = call ptr @llvm.coro.free(token %id, ptr %hdl); call void @free(ptr %mem); br label %suspend; suspend:; %unused = call i1 @llvm.coro.end(ptr %hdl, i1 false, token none); ret ptr %hdl; }. A coroutine consumer can rely on the `coro.promise`_ intrinsic to access the; coroutine promise. .. code-block:: llvm. define i32 @main() {; entry:; %hdl = call ptr @f(i32 4); %promise.addr = call ptr @llvm.coro.promise(ptr %hdl, i32 4, i1 false); %val0 = load i32, ptr %promise.addr; call void @print(i32 %val0); call void @llvm.coro.resume(ptr %hdl); %val1 = load i32, ptr %promise.addr; call void @print(i32 %val1); call void @llvm.coro.resume(ptr %hdl); %val2 = load i32, ptr %promise.addr; call void @print(i32 %val2); call void @llvm.coro.destroy(ptr %hdl); ret i32 0; }. After example in this section is compiled, result of the compilation will be:. .. code-block:: llvm. define i32 @main() {; entry:; tail call void @print(i32 4); tail call void @print(i32 5); tail call void @print(i32 6); ret i32 0; }. .. _final:; .. _final suspend:. Final Suspend; -------------. A coroutine author or a frontend may designate a particular suspend to be final,; by setting the second argument of the `coro.suspend`_ intrinsic to `true`.; Such a suspend point has two properties:. * it is possible to check whether a suspended coroutine is at the final suspend; point via `coro.done`_ intrinsic;. * a resumption of a coroutine stopped at the final suspend point leads to; undefined behavior. The only possible action for a coroutine at a final; suspend point is destroying it via `coro.destroy`_ intrinsic. From the user perspective, the final suspend point represents an",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:24074,resume,resume,24074,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"^. A member of a struct or union may be declared to have ownership-qualified; type. If the type is qualified with ``__unsafe_unretained``, the semantics; of the containing aggregate are unchanged from the semantics of an unqualified type in a non-ARC mode. If the type is qualified with ``__autoreleasing``, the program is ill-formed. Otherwise, if the type is nontrivially ownership-qualified, additional rules apply. Both Objective-C and Objective-C++ support nontrivially ownership-qualified; fields. Due to formal differences between the standards, the formal; treatment is different; however, the basic language model is intended to; be the same for identical code. .. admonition:: Rationale. Permitting ``__strong`` and ``__weak`` references in aggregate types; allows programmers to take advantage of the normal language tools of; C and C++ while still automatically managing memory. While it is; usually simpler and more idiomatic to use Objective-C objects for; secondary data structures, doing so can introduce extra allocation; and message-send overhead, which can cause to unacceptable; performance. Using structs can resolve some of this tension. ``__autoreleasing`` is forbidden because it is treacherous to rely; on autoreleases as an ownership tool outside of a function-local; contexts. Earlier releases of Clang permitted ``__strong`` and ``__weak`` only; references in Objective-C++ classes, not in Objective-C. This; restriction was an undesirable short-term constraint arising from the; complexity of adding support for non-trivial struct types to C. In Objective-C++, nontrivially ownership-qualified types are treated; for nearly all purposes as if they were class types with non-trivial; default constructors, copy constructors, move constructors, copy assignment; operators, move assignment operators, and destructors. This includes the; determination of the triviality of special members of classes with a; non-static data member of such a type. In Objective-C, the definitio",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:52219,simpl,simpler,52219,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['simpl'],['simpler']
Usability,"^^^^^^^^. After talking about namespaces in general, you may be wondering about anonymous; namespaces in particular. Anonymous namespaces are a great language feature; that tells the C++ compiler that the contents of the namespace are only visible; within the current translation unit, allowing more aggressive optimization and; eliminating the possibility of symbol name collisions. Anonymous namespaces are; to C++ as ""static"" is to C functions and global variables. While ""``static``""; is available in C++, anonymous namespaces are more general: they can make entire; classes private to a file. The problem with anonymous namespaces is that they naturally want to encourage; indentation of their body, and they reduce locality of reference: if you see a; random function definition in a C++ file, it is easy to see if it is marked; static, but seeing if it is in an anonymous namespace requires scanning a big; chunk of the file. Because of this, we have a simple guideline: make anonymous namespaces as small; as possible, and only use them for class declarations. For example:. .. code-block:: c++. namespace {; class StringSort {; ...; public:; StringSort(...); bool operator<(const char *RHS) const;; };; } // namespace. static void runHelper() {; ...; }. bool StringSort::operator<(const char *RHS) const {; ...; }. Avoid putting declarations other than classes into anonymous namespaces:. .. code-block:: c++. namespace {. // ... many declarations ... void runHelper() {; ...; }. // ... many declarations ... } // namespace. When you are looking at ""``runHelper``"" in the middle of a large C++ file,; you have no immediate way to tell if this function is local to the file. In; contrast, when the function is marked static, you don't need to cross-reference; faraway places in the file to tell that the function is local. Don't Use Braces on Simple Single-Statement Bodies of if/else/loop Statements; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. When writin",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst:60582,simpl,simple,60582,interpreter/llvm-project/llvm/docs/CodingStandards.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst,2,"['guid', 'simpl']","['guideline', 'simple']"
Usability,"^^^^^^^^. There is only type of public symbol, an ``S_PUB32`` which describes a mangled; name, a flag indicating what kind of symbol it is (e.g. function, variable), and; the symbol's address. The :ref:`dbi_section_map_substream` of the; :doc:`DBI Stream <DbiStream>` can be consulted to determine what module this address; corresponds to, and from there that module's :doc:`module debug stream <ModiStream>`; can be consulted to locate full information for the symbol with the given address. .. _global_symbols:. Global Symbols; --------------. While there is one :ref:`public symbol <public_symbols>` for every symbol in the; program with `external` linkage, there is one global symbol for every symbol in the; program with linkage (including internal linkage). As a result, global symbols do; not describe a mangled name *or* an address, since symbols with internal linkage; need not have any mangling at all, and also may not have an address. Thus, all; global symbols simply refer directly to the full symbol record via a module/offset; combination. Similarly to :ref:`public symbols <public_symbols>`, all global symbols are contained; in a single :doc:`Globals Stream <GlobalStream>`, which contains a hash table mapping; fully qualified name to the corresponding record in the globals stream (which as; mentioned, then contains information allowing one to locate the full record in the; corresponding module symbol stream). Note that a consequence and limitation of this design is that program-wide lookup; by anything other than an exact textually matching fully-qualified name of whatever; the compiler decided to emit is impractical. This differs from DWARF, where even; though we don't necessarily have O(1) lookup by basename within a given scope (including; O(1) scope, we at least have O(n) access within a given scope). .. important::; Program-wide lookup of names by anything other than an exact textually matching fully; qualified name is not possible. S_GDATA32; ^^^^^^^^^^. S_GTHR",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PDB/CodeViewSymbols.rst:3763,simpl,simply,3763,interpreter/llvm-project/llvm/docs/PDB/CodeViewSymbols.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PDB/CodeViewSymbols.rst,1,['simpl'],['simply']
Usability,"^^^^^^^^^^^^. The Select phase is the bulk of the target-specific code for instruction; selection. This phase takes a legal SelectionDAG as input, pattern matches the; instructions supported by the target to this DAG, and produces a new DAG of; target code. For example, consider the following LLVM fragment:. .. code-block:: llvm. %t1 = fadd float %W, %X; %t2 = fmul float %t1, %Y; %t3 = fadd float %t2, %Z. This LLVM code corresponds to a SelectionDAG that looks basically like this:. .. code-block:: text. (fadd:f32 (fmul:f32 (fadd:f32 W, X), Y), Z). If a target supports floating point multiply-and-add (FMA) operations, one of; the adds can be merged with the multiply. On the PowerPC, for example, the; output of the instruction selector might look like this DAG:. ::. (FMADDS (FADDS W, X), Y, Z). The ``FMADDS`` instruction is a ternary instruction that multiplies its first; two operands and adds the third (as single-precision floating-point numbers).; The ``FADDS`` instruction is a simple binary single-precision add instruction.; To perform this pattern match, the PowerPC backend includes the following; instruction definitions:. .. code-block:: text; :emphasize-lines: 4-5,9. def FMADDS : AForm_1<59, 29,; (ops F4RC:$FRT, F4RC:$FRA, F4RC:$FRC, F4RC:$FRB),; ""fmadds $FRT, $FRA, $FRC, $FRB"",; [(set F4RC:$FRT, (fadd (fmul F4RC:$FRA, F4RC:$FRC),; F4RC:$FRB))]>;; def FADDS : AForm_2<59, 21,; (ops F4RC:$FRT, F4RC:$FRA, F4RC:$FRB),; ""fadds $FRT, $FRA, $FRB"",; [(set F4RC:$FRT, (fadd F4RC:$FRA, F4RC:$FRB))]>;. The highlighted portion of the instruction definitions indicates the pattern; used to match the instructions. The DAG operators (like ``fmul``/``fadd``); are defined in the ``include/llvm/Target/TargetSelectionDAG.td`` file.; ""``F4RC``"" is the register class of the input and result values. The TableGen DAG instruction selector generator reads the instruction patterns; in the ``.td`` file and automatically builds parts of the pattern matching code; for your target. It has the ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:47597,simpl,simple,47597,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,1,['simpl'],['simple']
Usability,"^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Iterating over the predecessors and successors of a block is quite easy with the; routines defined in ``""llvm/IR/CFG.h""``. Just use code like this to; iterate over all predecessors of BB:. .. code-block:: c++. #include ""llvm/IR/CFG.h""; BasicBlock *BB = ...;. for (BasicBlock *Pred : predecessors(BB)) {; // ...; }. Similarly, to iterate over successors use ``successors``. .. _simplechanges:. Making simple changes; ---------------------. There are some primitive transformation operations present in the LLVM; infrastructure that are worth knowing about. When performing transformations,; it's fairly common to manipulate the contents of basic blocks. This section; describes some of the common methods for doing so and gives example code. .. _schanges_creating:. Creating and inserting new ``Instruction``\ s; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. *Instantiating Instructions*. Creation of ``Instruction``\ s is straight-forward: simply call the constructor; for the kind of instruction to instantiate and provide the necessary parameters.; For example, an ``AllocaInst`` only *requires* a (const-ptr-to) ``Type``. Thus:. .. code-block:: c++. auto *ai = new AllocaInst(Type::Int32Ty);. will create an ``AllocaInst`` instance that represents the allocation of one; integer in the current stack frame, at run time. Each ``Instruction`` subclass; is likely to have varying default parameters which change the semantics of the; instruction, so refer to the `doxygen documentation for the subclass of; Instruction <https://llvm.org/doxygen/classllvm_1_1Instruction.html>`_ that; you're interested in instantiating. *Naming values*. It is very useful to name the values of instructions when you're able to, as; this facilitates the debugging of your transformations. If you end up looking; at generated LLVM machine code, you definitely want to have logical names; associated with the results of instructions! By supplying a value for the; ``Name`` (default) param",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:113735,simpl,simply,113735,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['simpl'],['simply']
Usability,"^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This section mostly applies to Linux and older BSDs. On macOS, you should; have a sufficiently modern Xcode, or you will likely need to upgrade until you; do. Windows does not have a ""system compiler"", so you must install either Visual; Studio 2019 (or later), or a recent version of mingw64. FreeBSD 10.0 and newer; have a modern Clang as the system compiler. However, some Linux distributions and some other or older BSDs sometimes have; extremely old versions of GCC. These steps attempt to help you upgrade you; compiler even on such a system. However, if at all possible, we encourage you; to use a recent version of a distribution with a modern system compiler that; meets these requirements. Note that it is tempting to install a prior; version of Clang and libc++ to be the host compiler, however libc++ was not; well tested or set up to build on Linux until relatively recently. As; a consequence, this guide suggests just using libstdc++ and a modern GCC as the; initial host in a bootstrap, and then using Clang (and potentially libc++). The first step is to get a recent GCC toolchain installed. The most common; distribution on which users have struggled with the version requirements is; Ubuntu Precise, 12.04 LTS. For this distribution, one easy option is to install; the `toolchain testing PPA`_ and use it to install a modern GCC. There is; a really nice discussions of this on the `ask ubuntu stack exchange`_ and a; `github gist`_ with updated commands. However, not all users can use PPAs and; there are many other distributions, so it may be necessary (or just useful, if; you're here you *are* doing compiler development after all) to build and install; GCC from source. It is also quite easy to do these days. .. _toolchain testing PPA:; https://launchpad.net/~ubuntu-toolchain-r/+archive/test; .. _ask ubuntu stack exchange:; https://askubuntu.com/questions/466651/how-do-i-use-the-latest-gcc-on-ubuntu/581497#58149; .. _github gist:; https://g",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst:15837,guid,guide,15837,interpreter/llvm-project/llvm/docs/GettingStarted.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst,1,['guid'],['guide']
Usability,"_5; ...; ```. Returns have a simple mitigation technique on x86-64 (or other ABIs which have; what is called a ""red zone"" region beyond the end of the stack). This region is; guaranteed to be preserved across interrupts and context switches, making the; return address used in returning to the current code remain on the stack and; valid to read. We can emit code in the caller to verify that a return edge was; not mispredicted:; ```; callq other_function; return_addr:; testq -8(%rsp), return_addr # Validate return address.; cmovneq %r8, %rax # Update predicate state.; ```. For an ABI without a ""red zone"" (and thus unable to read the return address; from the stack), we can compute the expected return address prior to the call; into a register preserved across the call and use that similarly to the above. Indirect calls (and returns in the absence of a red zone ABI) pose the most; significant challenge to propagate. The simplest technique would be to define a; new ABI such that the intended call target is passed into the called function; and checked in the entry. Unfortunately, new ABIs are quite expensive to deploy; in C and C++. While the target function could be passed in TLS, we would still; require complex logic to handle a mixture of functions compiled with and; without this extra logic (essentially, making the ABI backwards compatible).; Currently, we suggest using retpolines here and will continue to investigate; ways of mitigating this. ##### Optimizations, Alternatives, and Tradeoffs. Merely accumulating predicate state involves significant cost. There are; several key optimizations we employ to minimize this and various alternatives; that present different tradeoffs in the generated code. First, we work to reduce the number of instructions used to track the state:; * Rather than inserting a `cmovCC` instruction along every conditional edge in; the original program, we track each set of condition flags we need to capture; prior to entering each basic block and",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md:20008,simpl,simplest,20008,interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,1,['simpl'],['simplest']
Usability,"_DIR} ${CMAKE_BINARY_DIR}/profiles/; COMMENT ""Merging profdata""; DEPENDS generate-profraw); if (CLANG_PGO_TRAINING_DATA_SOURCE_DIR); llvm_ExternalProject_Add(generate-profraw-external ${CLANG_PGO_TRAINING_DATA_SOURCE_DIR}; USE_TOOLCHAIN EXLUDE_FROM_ALL NO_INSTALL DEPENDS generate-profraw); add_dependencies(generate-profdata generate-profraw-external); endif(); endif(); endif(). find_program(DTRACE dtrace); # TODO: Look into supporting this for the driver build. It will require changing; # the perf-helper.py file to understand to call `llvm` as `llvm clang`.; if(APPLE AND DTRACE AND NOT LLVM_TOOL_LLVM_DRIVER_BUILD); configure_lit_site_cfg(; ${CMAKE_CURRENT_SOURCE_DIR}/order-files.lit.site.cfg.in; ${CMAKE_CURRENT_BINARY_DIR}/order-files/lit.site.cfg; ). add_lit_testsuite(generate-dtrace-logs ""Generating clang dtrace data""; ${CMAKE_CURRENT_BINARY_DIR}/order-files/; EXCLUDE_FROM_CHECK_ALL; ARGS -j 1; DEPENDS clang clear-dtrace-logs; ). add_custom_target(clear-dtrace-logs; COMMAND ""${Python3_EXECUTABLE}"" ${CMAKE_CURRENT_SOURCE_DIR}/perf-helper.py clean ${CMAKE_CURRENT_BINARY_DIR} dtrace; COMMENT ""Clearing old dtrace data""). if(NOT CLANG_ORDER_FILE); message(FATAL_ERROR ""Output clang order file is not set""); endif(). add_custom_target(generate-order-file; COMMAND ""${Python3_EXECUTABLE}"" ${CMAKE_CURRENT_SOURCE_DIR}/perf-helper.py gen-order-file --binary $<TARGET_FILE:clang> --output ${CLANG_ORDER_FILE} ${CMAKE_CURRENT_BINARY_DIR}; COMMENT ""Generating order file""; DEPENDS generate-dtrace-logs); endif(). if(CLANG_BOLT_INSTRUMENT AND NOT LLVM_BUILD_INSTRUMENTED); configure_lit_site_cfg(; ${CMAKE_CURRENT_SOURCE_DIR}/bolt.lit.site.cfg.in; ${CMAKE_CURRENT_BINARY_DIR}/bolt-fdata/lit.site.cfg; ). add_lit_testsuite(generate-bolt-fdata ""Generating BOLT profile for Clang""; ${CMAKE_CURRENT_BINARY_DIR}/bolt-fdata/; EXCLUDE_FROM_CHECK_ALL; DEPENDS clang-instrumented clear-bolt-fdata; ). add_custom_target(clear-bolt-fdata; COMMAND ""${Python3_EXECUTABLE}"" ${CMAKE_CURRENT_SOURCE_DIR}/perf-",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/perf-training/CMakeLists.txt:2375,clear,clear-dtrace-logs,2375,interpreter/llvm-project/clang/utils/perf-training/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/perf-training/CMakeLists.txt,1,['clear'],['clear-dtrace-logs']
Usability,"_INCLUDE_FILE macros/read_from_file.C; ```. ## N-tuples in ROOT ##. ### Storing simple N-tuples ###. Up to now we have seen how to manipulate input read from ASCII files.; ROOT offers the possibility to do much better than that, with its own; n-tuple classes. Among the many advantages provided by these classes one; could cite. - Optimised disk I/O. - Possibility to store many n-tuple rows. - Write the n-tuples in ROOT files. - Interactive inspection with `TBrowser`. - Store not only numbers, but also *objects* in the columns. In this section we will discuss briefly the `TNtuple` class, which is a; simplified version of the `TTree` class. A ROOT `TNtuple` object can; store rows of float entries. Let's tackle the problem according to the; usual strategy commenting a minimal example. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/write_ntuple_to_file.C; ```. This data written to this example n-tuple represents, in the statistical; sense, three independent variables (Potential or Voltage, Pressure and; Temperature), and one variable (Current) which depends on the others; according to very simple laws, and an additional Gaussian smearing. This; set of variables mimics a measurement of an electrical resistance while; varying pressure and temperature. Imagine your task now consists in finding the relations among the; variables -- of course without knowing the code used to generate them.; You will see that the possibilities of the `NTuple` class enable you to; perform this analysis task. Open the ROOT file (`cond_data.root`); written by the macro above in an interactive session and use a; `TBrowser` to interactively inspect it:. ``` {.cpp}; root[0] TBrowser b; ```; You find the columns of your n-tuple written as *leafs*. Simply clicking; on them you can obtain histograms of the variables!. Next, try the following commands at the shell prompt and in the; interactive ROOT shell, respectively:. ``` {.cpp}; > root conductivity_experiment.root; Attaching file conductivity_experiment.root",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md:2527,simpl,simple,2527,documentation/primer/filio.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md,1,['simpl'],['simple']
Usability,"_alpha-unix-PthreadLock:. alpha.unix.PthreadLock (C); """"""""""""""""""""""""""""""""""""""""""""""""""""; Simple lock -> unlock checker.; Applies to: ``pthread_mutex_lock, pthread_rwlock_rdlock, pthread_rwlock_wrlock, lck_mtx_lock, lck_rw_lock_exclusive``; ``lck_rw_lock_shared, pthread_mutex_trylock, pthread_rwlock_tryrdlock, pthread_rwlock_tryrwlock, lck_mtx_try_lock,; lck_rw_try_lock_exclusive, lck_rw_try_lock_shared, pthread_mutex_unlock, pthread_rwlock_unlock, lck_mtx_unlock, lck_rw_done``. .. code-block:: c. pthread_mutex_t mtx;. void test() {; pthread_mutex_lock(&mtx);; pthread_mutex_lock(&mtx);; // warn: this lock has already been acquired; }. lck_mtx_t lck1, lck2;. void test() {; lck_mtx_lock(&lck1);; lck_mtx_lock(&lck2);; lck_mtx_unlock(&lck1);; // warn: this was not the most recently acquired lock; }. lck_mtx_t lck1, lck2;. void test() {; if (lck_mtx_try_lock(&lck1) == 0); return;. lck_mtx_lock(&lck2);; lck_mtx_unlock(&lck1);; // warn: this was not the most recently acquired lock; }. .. _alpha-unix-SimpleStream:. alpha.unix.SimpleStream (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""; Check for misuses of stream APIs. Check for misuses of stream APIs: ``fopen, fclose``; (demo checker, the subject of the demo (`Slides <https://llvm.org/devmtg/2012-11/Zaks-Rose-Checker24Hours.pdf>`_ ,; `Video <https://youtu.be/kdxlsP5QVPw>`_) by Anna Zaks and Jordan Rose presented at the; `2012 LLVM Developers' Meeting <https://llvm.org/devmtg/2012-11/>`_). .. code-block:: c. void test() {; FILE *F = fopen(""myfile.txt"", ""w"");; } // warn: opened file is never closed. void test() {; FILE *F = fopen(""myfile.txt"", ""w"");. if (F); fclose(F);. fclose(F); // warn: closing a previously closed file stream; }. .. _alpha-unix-Stream:. alpha.unix.Stream (C); """"""""""""""""""""""""""""""""""""""""""; Check stream handling functions: ``fopen, tmpfile, fclose, fread, fwrite, fseek, ftell, rewind, fgetpos,``; ``fsetpos, clearerr, feof, ferror, fileno``. .. code-block:: c. void test() {; FILE *p = fopen(""foo"", ""r"");; } // warn: opened file is never c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:76237,Simpl,SimpleStream,76237,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['Simpl'],['SimpleStream']
Usability,"_postdec__``; ``operator--()`` ``__predec__``; ``unary operator*`` ``__deref__``; ``operator->`` ``__follow__``; ``operator&&`` ``__dand__``; ``operator||`` ``__dor__``; ``operator,`` ``__comma__``; =================== ===================. Here is an example of operator usage, using STL iterators directly (note that; this is not necessary in practice as STL and STL-like containers work; transparently in Python for-loops):. .. code-block:: python. >>> v = cppyy.gbl.std.vector[int](range(3)); >>> i = v.begin(); >>> while (i != v.end()):; ... print(i.__deref__()); ... _ = i.__preinc__(); ...; 0; 1; 2; >>>. Overridden ``operator new`` and ``operator delete``, as well as their array; equivalents, are not accessible but will be called as appropriate. `Templates`; -----------. Templated classes are instantiated using square brackets.; (For backwards compatibility reasons, parentheses work as well.); The instantiation of a templated class yields a class, which can then; be used to create instances. Templated classes need not pre-exist in the bound code, just their; declaration needs to be available.; This is true for e.g. all of STL:. .. code-block:: python. >>> cppyy.gbl.std.vector # template metatype; <cppyy.Template 'std::vector' object at 0x7fffed2674d0>; >>> cppyy.gbl.std.vector(int) # instantiates template -> class; <class cppyy.gbl.std.vector<int> at 0x1532190>; cppyy.gbl.std.vector[int]() # instantiates class -> object; <cppyy.gbl.std.vector<int> object at 0x2341ec0>; >>>. The template arguments may be actual types or their names as a string,; whichever is more convenient.; Thus, the following are equivalent:. .. code-block:: python. >>> from cppyy.gbl.std import vector; >>> type1 = vector[Concrete]; >>> type2 = vector['Concrete']; >>> type1 == type2; True; >>>. `Typedefs`; ----------. Typedefs are simple python references to the actual classes to which; they refer. .. code-block:: python. >>> from cppyy.gbl import Concrete_t; >>> Concrete is Concrete_t; True; >>>. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/classes.rst:12145,simpl,simple,12145,bindings/pyroot/cppyy/cppyy/doc/source/classes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/classes.rst,1,['simpl'],['simple']
Usability,"` from the menu line of the window. It will pop up a file; selector box to allow you to choose the format, file name and target; directory to store the image. There is one very noticeable feature here:; you can store a plot as a root macro! In this macro, you find the C++; representation of all methods and classes involved in generating the; plot. This is a valuable source of information for your own macros,; which you will hopefully write after having worked through this; tutorial. Using ROOT's interactive capabilities is useful for a first exploration; of possibilities. Other ROOT classes you will encounter in this tutorial; have such graphical interfaces. We will not comment further on this,; just be aware of the existence of ROOT's interactive features and use; them if you find them convenient. Some trial-and-error is certainly necessary; to find your way through the huge number of menus and parameter; settings. ## ROOT Beginners' FAQ ##. At this point of the guide, some basic questions could have already come; to your mind. We will try to clarify some of them with further; explanations in the following. ### ROOT type declarations for basic data types ###. In the official ROOT documentation, you find special data types; replacing the normal ones, e.g. `Double_t`, `Float_t` or `Int_t`; replacing the standard `double`, `float` or `int` types. Using the ROOT; types makes it easier to port code between platforms (64/32 bit) or; operating systems (windows/Linux), as these types are mapped to suitable; ones in the ROOT header files. If you want adaptive code of this type,; use the ROOT type declarations. However, usually you do not need such; adaptive code, and you can safely use the standard C type declarations; for your private code, as we did and will do throughout this guide. If; you intend to become a ROOT developer, however, you better stick to the; official coding rules!. ### Configure ROOT at start-up ###. The behaviour of a ROOT session can be tailored with t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md:16942,guid,guide,16942,documentation/primer/ROOT_as_calculator.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md,1,['guid'],['guide']
Usability,"` nor allow it to be; declared. Instead it should provide its own interface to discovering; information about files and directories. Those interfaces may be implemented in; terms of ``stat`` but that is strictly an implementation detail. The interface; provided by the Support Library must be implemented on all platforms (even; those without ``stat``). No Exposed Data; ---------------. Any data defined by system libraries (i.e. not defined by ``lib/Support``) must; not be exposed through the ``lib/Support`` interface, even if the header file; for that function is not exposed. As with functions, this prevents inadvertent; use of data that might not exist on all platforms. Minimize Soft Errors; --------------------. Operating system interfaces will generally provide error results for every; little thing that could go wrong. In almost all cases, you can divide these; error results into two groups: normal/good/soft and abnormal/bad/hard. That is,; some of the errors are simply information like ""file not found"", ""insufficient; privileges"", etc. while other errors are much harder like ""out of space"", ""bad; disk sector"", or ""system call interrupted"". We'll call the first group ""*soft*""; errors and the second group ""*hard*"" errors. ``lib/Support`` must always attempt to minimize soft errors. This is a design; requirement because the minimization of soft errors can affect the granularity; and the nature of the interface. In general, if you find that you're wanting to; throw soft errors, you must review the granularity of the interface because it; is likely you're trying to implement something that is too low level. The rule; of thumb is to provide interface functions that **can't** fail, except when; faced with hard errors. For a trivial example, suppose we wanted to add an ""``OpenFileForWriting``""; function. For many operating systems, if the file doesn't exist, attempting to; open the file will produce an error. However, ``lib/Support`` should not simply; throw that error i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportLibrary.rst:7510,simpl,simply,7510,interpreter/llvm-project/llvm/docs/SupportLibrary.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportLibrary.rst,1,['simpl'],['simply']
Usability,"` operand to the convergent call. The semantics of the; ``loop`` intrinsic ensures that the convergent call is performed convergently; only by those threads that convergently exited the loop in a given iteration. .. code-block:: llvm. define void @example() convergent {; %entry = call token @llvm.experimental.convergence.entry(); br label %for. for:; %inner = call token @llvm.experimental.convergence.loop() [""convergencectrl""(token %entry)]; %for.cond = i1 ...; br i1 %for.cond, label %B, label %E. B:; ...; %condition = i1 ...; br i1 %condition, label %C, label %D. C:; call void @convergent_op() [""convergencectrl""(token %inner)]; br label %E. D:; ...; br label %for. E:; ...; ret void; }. The LLVM IR version of the same program shows a cycle consisting of the basic; blocks ``%for``, ``%B`` and ``%D``, while ``%C`` is an exit reached by the; divergent branch at the end of the exiting block ``%B``. But the use of; convergence control tokens makes it clear that block ``%C`` must be executed; convergently only by those threads that convergently take the exit edge from %B; to ``%C``. In other words, the convergent execution of ``%C`` is governed by the; call to the :ref:`llvm.experimental.convergence.loop; <llvm.experimental.convergence.loop>` intrinsic inside the cycle. The cycle is; effectively extended to include all uses of this token that lie outside the; cycle. .. _dynamic_instances_and_convergence_tokens:. Dynamic Instances and Convergence Tokens; ========================================. Every execution of an LLVM IR instruction occurs in a :ref:`dynamic instance; <convergence-dynamic-instances>` of the instruction. Dynamic instances are the; formal objects by which we talk about communicating threads in convergent; operations. Dynamic instances are defined for *all* operations in an LLVM; program, whether convergent or not. Convergence control is primarily about the; dynamic instances of convergent operations since they affect execution of the; program through int",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergentOperations.rst:18111,clear,clear,18111,interpreter/llvm-project/llvm/docs/ConvergentOperations.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergentOperations.rst,1,['clear'],['clear']
Usability,"` tab. - `e` ASCII ESC character ('033'). - `DDD` number formed of 1-3 octal digits. - `xDD` number formed of 1-2 hex digits. - `^C` C = any letter. Control code. The class **`TRegexp`** can be used to create a regular expression; from an input string. If `wildcard` is true then the input string; contains a wildcard expression. ``` {.cpp}; TRegexp(const char *re, Bool_t wildcard); ```. Regular expression and wildcards can be easily used in methods like:. ``` {.cpp}; Ssiz_t Index(const TString& string,Ssiz_t* len,Ssiz_t i) const; ```. The method finds the first occurrence of the regular expression in the; `string` and returns its position. ## Conventions. In this paragraph, we will explain some of the conventions used in; ROOT source and examples. ### Coding Conventions. From the first days of ROOT development, it was decided to use a set; of coding conventions. This allows a consistency throughout the source; code. Learning these will help you identify what type of information; you are dealing with and enable you to understand the code better and; quicker. Of course, you can use whatever convention you want but if; you are going to submit some code for inclusion into the ROOT sources,; you will need to use these. These are the coding conventions:. - Classes begin with **`T`**: **`TLine`**, **`TTree`**. - Non-class types end with **`_t`**: `Int_t`. - Data members begin with **`f`**: `fTree`. - Member functions begin with a capital: `Loop()`. - Constants begin with **`k`**: `kInitialSize`, `kRed `. - Global variables begin with **`g`**: ***`gEnv`***. - Static data members begin with **`fg`**: `fgTokenClient `. - Enumeration types begin with **`E`**: `EColorLevel`. - Locals and parameters begin with a lower case: `nbytes`. - Getters and setters begin with **`Get`** and **`Set`**:; `SetLast`(), `GetFirst`(). ### Machine Independent Types. Different machines may have different lengths for the same type. The; most famous example is the `int` type. It may be 16 bits on som",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:29199,Learn,Learning,29199,documentation/users-guide/GettingStarted.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md,1,['Learn'],['Learning']
Usability,"`**` ::Draw` ); for the first time, it creates a **`THistPainter`** object and saves a; pointer to painter as a data member of the histogram. The; **`THistPainter`** class specializes in the drawing of histograms. It; allows logarithmic axes (x, y, z) when the CONT drawing option is; using. The **`THistPainter`** class is separated from the histogram so; that one can have histograms without the graphics overhead, for; example in a batch program. The choice to give each histogram has its; own painter rather than a central singleton painter, allows two; histograms to be drawn in two threads without overwriting the; painter's values. When a displayed histogram is filled again, you do; not have to call the `Draw` method again. The image is refreshed the; next time the pad is updated. A pad is updated after one of these; three actions:. - A carriage control on the ROOT command line. - A click inside the pad. - A call to **`TPad`**`::Update()`. By default, the **`TH1`**`::Draw` clears the pad before drawing the; new image of the histogram. You can use the `""SAME""` option to leave; the previous display intact and superimpose the new histogram. The; same histogram can be drawn with different graphics options in; different pads. When a displayed histogram is deleted, its image is; automatically removed from the pad. To create a copy of the histogram; when drawing it, you can use **`TH1`**`::DrawClone()`. This will clone; the histogram and allow you to change and delete the original one; without affecting the clone. You can use **`TH1`**`::DrawNormalized()`; to draw a normalized copy of a histogram. ``` {.cpp}; TH1 *TH1::DrawNormalized(Option_t *option,Double_t norm) const; ```. A clone of this histogram is normalized to norm and drawn with option.; A pointer to the normalized histogram is returned. The contents of the; histogram copy are scaled such that the new sum of weights (excluding; under and overflow) is equal to `norm` . Note that the returned normalized histogram is ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:13927,clear,clears,13927,documentation/users-guide/Histograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md,1,['clear'],['clears']
Usability,"`BranchFolding.cpp`` and; ``IfConversion.cpp`` in the ``lib/CodeGen`` directory) call ``analyzeBranch``; to improve the control flow graph that represents the instructions. Several implementations of ``analyzeBranch`` (for ARM, Alpha, and X86) can be; examined as models for your own ``analyzeBranch`` implementation. Since SPARC; does not implement a useful ``analyzeBranch``, the ARM target implementation is; shown below. ``analyzeBranch`` returns a Boolean value and takes four parameters:. * ``MachineBasicBlock &MBB`` --- The incoming block to be examined. * ``MachineBasicBlock *&TBB`` --- A destination block that is returned. For a; conditional branch that evaluates to true, ``TBB`` is the destination. * ``MachineBasicBlock *&FBB`` --- For a conditional branch that evaluates to; false, ``FBB`` is returned as the destination. * ``std::vector<MachineOperand> &Cond`` --- List of operands to evaluate a; condition for a conditional branch. In the simplest case, if a block ends without a branch, then it falls through; to the successor block. No destination blocks are specified for either ``TBB``; or ``FBB``, so both parameters return ``NULL``. The start of the; ``analyzeBranch`` (see code below for the ARM target) shows the function; parameters and the code for the simplest case. .. code-block:: c++. bool ARMInstrInfo::analyzeBranch(MachineBasicBlock &MBB,; MachineBasicBlock *&TBB,; MachineBasicBlock *&FBB,; std::vector<MachineOperand> &Cond) const; {; MachineBasicBlock::iterator I = MBB.end();; if (I == MBB.begin() || !isUnpredicatedTerminator(--I)); return false;. If a block ends with a single unconditional branch instruction, then; ``analyzeBranch`` (shown below) should return the destination of that branch in; the ``TBB`` parameter. .. code-block:: c++. if (LastOpc == ARM::B || LastOpc == ARM::tB) {; TBB = LastInst->getOperand(0).getMBB();; return false;; }. If a block ends with two unconditional branches, then the second branch is; never reached. In that situation, a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst:48377,simpl,simplest,48377,interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst,1,['simpl'],['simplest']
Usability,"`LLVMConfig.cmake`` file sets various useful variables. Notable variables; include. ``LLVM_CMAKE_DIR``; The path to the LLVM CMake directory (i.e. the directory containing; LLVMConfig.cmake). ``LLVM_DEFINITIONS``; A list of preprocessor defines that should be used when building against LLVM. ``LLVM_ENABLE_ASSERTIONS``; This is set to ON if LLVM was built with assertions, otherwise OFF. ``LLVM_ENABLE_EH``; This is set to ON if LLVM was built with exception handling (EH) enabled,; otherwise OFF. ``LLVM_ENABLE_RTTI``; This is set to ON if LLVM was built with run time type information (RTTI),; otherwise OFF. ``LLVM_INCLUDE_DIRS``; A list of include paths to directories containing LLVM header files. ``LLVM_PACKAGE_VERSION``; The LLVM version. This string can be used with CMake conditionals, e.g., ``if; (${LLVM_PACKAGE_VERSION} VERSION_LESS ""3.5"")``. ``LLVM_TOOLS_BINARY_DIR``; The path to the directory containing the LLVM tools (e.g. ``llvm-as``). Notice that in the above example we link ``simple-tool`` against several LLVM; libraries. The list of libraries is determined by using the; ``llvm_map_components_to_libnames()`` CMake function. For a list of available; components look at the output of running ``llvm-config --components``. Note that for LLVM < 3.5 ``llvm_map_components_to_libraries()`` was; used instead of ``llvm_map_components_to_libnames()``. This is now deprecated; and will be removed in a future version of LLVM. .. _cmake-out-of-source-pass:. Developing LLVM passes out of source; ------------------------------------. It is possible to develop LLVM passes out of LLVM's source tree (i.e. against an; installed or built LLVM). An example of a project layout is provided below. .. code-block:: none. <project dir>/; |; CMakeLists.txt; <pass name>/; |; CMakeLists.txt; Pass.cpp; ... Contents of ``<project dir>/CMakeLists.txt``:. .. code-block:: cmake. find_package(LLVM REQUIRED CONFIG). separate_arguments(LLVM_DEFINITIONS_LIST NATIVE_COMMAND ${LLVM_DEFINITIONS}); add_",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst:44455,simpl,simple-tool,44455,interpreter/llvm-project/llvm/docs/CMake.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst,1,['simpl'],['simple-tool']
Usability,"`TableGen; Backend Developer's Guide <./BackGuide>` for a guide to writing a new; backend. Here are a few of the things backends can do. * Generate the register file information for a particular target machine. * Generate the instruction definitions for a target. * Generate the patterns that the code generator uses to match instructions; to intermediate representation (IR) nodes. * Generate semantic attribute identifiers for Clang. * Generate abstract syntax tree (AST) declaration node definitions for Clang. * Generate AST statement node definitions for Clang. Concepts; --------. TableGen source files contain two primary items: *abstract records* and; *concrete records*. In this and other TableGen documents, abstract records; are called *classes.* (These classes are different from C++ classes and do; not map onto them.) In addition, concrete records are usually just called; records, although sometimes the term *record* refers to both classes and; concrete records. The distinction should be clear in context. Classes and concrete records have a unique *name*, either chosen by; the programmer or generated by TableGen. Associated with that name; is a list of *fields* with values and an optional list of *parent classes*; (sometimes called base or super classes). The fields are the primary data that; backends will process. Note that TableGen assigns no meanings to fields; the; meanings are entirely up to the backends and the programs that incorporate; the output of those backends. .. note::. The term ""parent class"" can refer to a class that is a parent of another; class, and also to a class from which a concrete record inherits. This; nonstandard use of the term arises because TableGen treats classes and; concrete records similarly. A backend processes some subset of the concrete records built by the; TableGen parser and emits the output files. These files are usually C++; ``.inc`` files that are included by the programs that require the data in; those records. However, a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst:2464,clear,clear,2464,interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,1,['clear'],['clear']
Usability,"`__; This list gets emailed every time a bug is opened and closed. It is; higher volume than the LLVM-dev list. .. __: http://lists.llvm.org/pipermail/llvm-bugs/. `LLVM Announcements`__; If you just want project wide announcements such as releases, developers meetings, or blog posts, then you should check out the Announcement category on LLVM Discourse. .. __: https://discourse.llvm.org/c/announce/46. .. _online-sync-ups:. Online Sync-Ups; ---------------. A number of regular calls are organized on specific topics. It should be; expected that the range of topics will change over time. At the time of; writing, the following sync-ups are organized.; The :doc:`CodeOfConduct` applies to all online sync-ups. If you'd like to organize a new sync-up, please add the info in the table; below. Please also create a calendar event for it and invite calendar@llvm.org; to the event, so that it'll show up on the :ref:`llvm-community-calendar`.; Please see :ref:`llvm-community-calendar-host-guidance` for more guidance on; what to add to your calendar invite. .. list-table:: LLVM regular sync-up calls; :widths: 25 25 25 25; :header-rows: 1. * - Topic; - Frequency; - Calendar link; - Minutes/docs link; * - Loop Optimization Working Group; - Every 2 weeks on Wednesday; - `ics <./_static/LoopOptWG_invite.ics>`__; - `Minutes/docs <https://docs.google.com/document/d/1sdzoyB11s0ccTZ3fobqctDpgJmRoFcz0sviKxqczs4g/edit>`__; * - RISC-V; - Every 2 weeks on Thursday; - `ics <https://calendar.google.com/calendar/ical/lowrisc.org_0n5pkesfjcnp0bh5hps1p0bd80%40group.calendar.google.com/public/basic.ics>`__; `gcal <https://calendar.google.com/calendar/b/1?cid=bG93cmlzYy5vcmdfMG41cGtlc2ZqY25wMGJoNWhwczFwMGJkODBAZ3JvdXAuY2FsZW5kYXIuZ29vZ2xlLmNvbQ>`__; - `Minutes/docs <https://docs.google.com/document/d/1G3ocHm2zE6AYTS2N3_3w2UxFnSEyKkcF57siLWe-NVs>`__; * - Scalable Vectors and Arm SVE; - Monthly, every 3rd Tuesday; - `ics <https://calendar.google.com/calendar/ical/bjms39pe6k6bo5egtsp7don414%40group.cal",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingInvolved.rst:4324,guid,guidance,4324,interpreter/llvm-project/llvm/docs/GettingInvolved.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingInvolved.rst,2,['guid'],['guidance']
Usability,"``%X`` has a zero bit, then the output of the; '``and``' operation will always be a zero for that bit, no matter what; the corresponding bit from the '``undef``' is. As such, it is unsafe to; optimize or assume that the result of the '``and``' is '``undef``'.; However, it is safe to assume that all bits of the '``undef``' could be; 0, and optimize the '``and``' to 0. Likewise, it is safe to assume that; all the bits of the '``undef``' operand to the '``or``' could be set,; allowing the '``or``' to be folded to -1. .. code-block:: llvm. %A = select undef, %X, %Y; %B = select undef, 42, %Y; %C = select %X, %Y, undef; Safe:; %A = %X (or %Y); %B = 42 (or %Y); %C = %Y (if %Y is provably not poison; unsafe otherwise); Unsafe:; %A = undef; %B = undef; %C = undef. This set of examples shows that undefined '``select``' (and conditional; branch) conditions can go *either way*, but they have to come from one; of the two operands. In the ``%A`` example, if ``%X`` and ``%Y`` were; both known to have a clear low bit, then ``%A`` would have to have a; cleared low bit. However, in the ``%C`` example, the optimizer is; allowed to assume that the '``undef``' operand could be the same as; ``%Y`` if ``%Y`` is provably not '``poison``', allowing the whole '``select``'; to be eliminated. This is because '``poison``' is stronger than '``undef``'. .. code-block:: llvm. %A = xor undef, undef. %B = undef; %C = xor %B, %B. %D = undef; %E = icmp slt %D, 4; %F = icmp gte %D, 4. Safe:; %A = undef; %B = undef; %C = undef; %D = undef; %E = undef; %F = undef. This example points out that two '``undef``' operands are not; necessarily the same. This can be surprising to people (and also matches; C semantics) where they assume that ""``X^X``"" is always zero, even if; ``X`` is undefined. This isn't true for a number of reasons, but the; short answer is that an '``undef``' ""variable"" can arbitrarily change; its value over its ""live range"". This is true because the variable; doesn't actually *have a live r",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:193150,clear,clear,193150,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,2,['clear'],"['clear', 'cleared']"
Usability,"``. Subdirectory; names known to LLVM include:. * spec95. * speccpu2000. * speccpu2006. * povray31. Others are added from time to time, and can be determined from; ``configure``. Running Different Tests; =======================. In addition to the regular ""whole program"" tests, the ``test-suite``; module also provides a mechanism for compiling the programs in different; ways. If the variable TEST is defined on the ``gmake`` command line, the; test system will include a Makefile named; ``TEST.<value of TEST variable>.Makefile``. This Makefile can modify; build rules to yield different results. For example, the LLVM nightly tester uses ``TEST.nightly.Makefile`` to; create the nightly test reports. To run the nightly tests, run; ``gmake TEST=nightly``. There are several TEST Makefiles available in the tree. Some of them are; designed for internal LLVM research and will not work outside of the; LLVM research group. They may still be valuable, however, as a guide to; writing your own TEST Makefile for any optimization or analysis passes; that you develop with LLVM. Generating Test Output; ======================. There are a number of ways to run the tests and generate output. The; most simple one is simply running ``gmake`` with no arguments. This will; compile and run all programs in the tree using a number of different; methods and compare results. Any failures are reported in the output,; but are likely drowned in the other output. Passes are not reported; explicitly. Somewhat better is running ``gmake TEST=sometest test``, which runs the; specified test and usually adds per-program summaries to the output; (depending on which sometest you use). For example, the ``nightly`` test; explicitly outputs TEST-PASS or TEST-FAIL for every test after each; program. Though these lines are still drowned in the output, it's easy; to grep the output logs in the Output directories. Even better are the ``report`` and ``report.format`` targets (where; ``format`` is one of ``html``, `",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestSuiteMakefileGuide.rst:3538,guid,guide,3538,interpreter/llvm-project/llvm/docs/TestSuiteMakefileGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestSuiteMakefileGuide.rst,1,['guid'],['guide']
Usability,"``; interface. All of these :ref:`chain <aliasanalysis-chaining>` to other; alias analysis implementations. The ``-basic-aa`` pass; ^^^^^^^^^^^^^^^^^^^^^^. The ``-basic-aa`` pass is an aggressive local analysis that *knows* many; important facts:. * Distinct globals, stack allocations, and heap allocations can never alias.; * Globals, stack allocations, and heap allocations never alias the null pointer.; * Different fields of a structure do not alias.; * Indexes into arrays with statically differing subscripts cannot alias.; * Many common standard C library functions `never access memory or only read; memory`_.; * Pointers that obviously point to constant globals ""``pointToConstantMemory``"".; * Function calls can not modify or references stack allocations if they never; escape from the function that allocates them (a common case for automatic; arrays). The ``-globalsmodref-aa`` pass; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This pass implements a simple context-sensitive mod/ref and alias analysis for; internal global variables that don't ""have their address taken"". If a global; does not have its address taken, the pass knows that no pointers alias the; global. This pass also keeps track of functions that it knows never access; memory or never read memory. This allows certain optimizations (e.g. GVN) to; eliminate call instructions entirely. The real power of this pass is that it provides context-sensitive mod/ref; information for call instructions. This allows the optimizer to know that calls; to a function do not clobber or read the value of the global, allowing loads and; stores to be eliminated. .. note::. This pass is somewhat limited in its scope (only support non-address taken; globals), but is very quick analysis. The ``-steens-aa`` pass; ^^^^^^^^^^^^^^^^^^^^^^^. The ``-steens-aa`` pass implements a variation on the well-known ""Steensgaard's; algorithm"" for interprocedural alias analysis. Steensgaard's algorithm is a; unification-based, flow-insensitive, context-insen",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:24587,simpl,simple,24587,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,1,['simpl'],['simple']
Usability,"``ADD %EAX, %EBX``, in X86 is actually equivalent to ``%EAX = %EAX +; %EBX``. In order to produce correct code, LLVM must convert three address instructions; that represent two address instructions into true two address instructions. LLVM; provides the pass ``TwoAddressInstructionPass`` for this specific purpose. It; must be run before register allocation takes place. After its execution, the; resulting code may no longer be in SSA form. This happens, for instance, in; situations where an instruction such as ``%a = ADD %b %c`` is converted to two; instructions such as:. ::. %a = MOVE %b; %a = ADD %a %c. Notice that, internally, the second instruction is represented as ``ADD; %a[def/use] %c``. I.e., the register operand ``%a`` is both used and defined by; the instruction. The SSA deconstruction phase; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. An important transformation that happens during register allocation is called; the *SSA Deconstruction Phase*. The SSA form simplifies many analyses that are; performed on the control flow graph of programs. However, traditional; instruction sets do not implement PHI instructions. Thus, in order to generate; executable code, compilers must replace PHI instructions with other instructions; that preserve their semantics. There are many ways in which PHI instructions can safely be removed from the; target code. The most traditional PHI deconstruction algorithm replaces PHI; instructions with copy instructions. That is the strategy adopted by LLVM. The; SSA deconstruction algorithm is implemented in; ``lib/CodeGen/PHIElimination.cpp``. In order to invoke this pass, the identifier; ``PHIEliminationID`` must be marked as required in the code of the register; allocator. Instruction folding; ^^^^^^^^^^^^^^^^^^^. *Instruction folding* is an optimization performed during register allocation; that removes unnecessary copy instructions. For instance, a sequence of; instructions such as:. ::. %EBX = LOAD %mem_address; %EAX = COPY %EBX. can be safely subs",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:67820,simpl,simplifies,67820,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,1,['simpl'],['simplifies']
Usability,"``DW_AT_LLVM_iterations``; ``DW_TAG_subprogram`` * ``DW_AT_LLVM_active_lane``; * ``DW_AT_LLVM_lane_pc``; * ``DW_AT_LLVM_lanes``; * ``DW_AT_LLVM_iterations``; ================================== =============================. D. Examples (Informative); -------------------------. .. note::. This modifies the corresponding DWARF Version 5 Appendix D examples. D.1 General Description Examples; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. D.1.3 DWARF Location Description Examples; +++++++++++++++++++++++++++++++++++++++++. ``DW_OP_offset_uconst 4``; A structure member is four bytes from the start of the structure instance. The; location description of the base of the structure instance is assumed to be; already on the stack. ``DW_OP_entry_value 1 DW_OP_reg5 DW_OP_offset_uconst 16``; The address of the memory location is calculated by adding 16 to the value; contained in register 5 upon entering the current subprogram. D.2 Aggregate Examples; ~~~~~~~~~~~~~~~~~~~~~~. D.2.1 Fortran Simple Array Example; ++++++++++++++++++++++++++++++++++. Figure D.4: Fortran array example: DWARF description. .. code::; :number-lines:. -------------------------------------------------------------------------------; ! Description for type of 'ap'; !; 1$: DW_TAG_array_type; ! No name, default (Fortran) ordering, default stride; DW_AT_type(reference to REAL); DW_AT_associated(expression= ! Test 'ptr_assoc' flag; DW_OP_push_object_address; DW_OP_lit<n> ! where n == offset(ptr_assoc); DW_OP_offset; DW_OP_deref; DW_OP_lit1 ! mask for 'ptr_assoc' flag; DW_OP_and); DW_AT_data_location(expression= ! Get raw data address; DW_OP_push_object_address; DW_OP_lit<n> ! where n == offset(base); DW_OP_offset; DW_OP_deref) ! Type of index of array 'ap'; 2$: DW_TAG_subrange_type; ! No name, default stride; DW_AT_type(reference to INTEGER); DW_AT_lower_bound(expression=; DW_OP_push_object_address; DW_OP_lit<n> ! where n ==; ! offset(desc, dims) +; ! offset(dims_str, lower_bound); DW_OP_offset; DW_OP_deref); DW_AT_upper_bound",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:227656,Simpl,Simple,227656,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['Simpl'],['Simple']
Usability,"```. To correctly cleanup JSROOT drawings from HTML element, one should call:. ```javascript; cleanup(""drawing"");; ```. ### File API. JSROOT defines the TFile class, which can be used to access binary ROOT files.; One should always remember that all I/O operations are asynchronous in JSROOT.; Therefore promises are used to retrieve results when the I/O operation is completed.; For example, reading an object from a file and displaying it will look like:. ```javascript; import { openFile, draw } from 'https://root.cern/js/latest/modules/main.mjs';; let filename = ""https://root.cern/js/files/hsimple.root"";; let file = await openFile(filename);; let obj = await file.readObject(""hpxpy;1"");; await draw(""drawing"", obj, ""colz"");; console.log('drawing completed');; ```. Here is [running example](https://root.cern/js/latest/api.htm#custom_html_read_root_file) and [source code](https://github.com/root-project/jsroot/blob/master/demo/read_file.htm). ### TTree API. Simple TTree::Draw operation can be performed with following code:. ```javascript; import { openFile } from 'https://root.cern/js/latest/modules/io.mjs';; import { draw } from 'https://root.cern/js/latest/modules/draw.mjs';; let file = await openFile(""https://root.cern/js/files/hsimple.root"");; let tree = await file.readObject(""ntuple;1"");; draw(""drawing"", tree, ""px:py::pz>5"");; ```. To get access to selected branches, one should use `TSelector` class:. ```javascript; import { openFile } from 'https://root.cern/js/latest/modules/io.mjs';; import { draw } from 'https://root.cern/js/latest/modules/draw.mjs';; import { TSelector, treeProcess } from 'https://root.cern/js/latest/modules/tree.mjs';. let file = await openFile(""https://root.cern/js/files/hsimple.root"");; let tree = await file.readObject(""ntuple;1"");; let selector = new TSelector();. selector.AddBranch(""px"");; selector.AddBranch(""py"");. let cnt = 0, sumpx = 0, sumpy = 0;. selector.Begin = function() {; // function called before reading of TTree starts; }. sele",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/JSROOT/JSROOT.md:40551,Simpl,Simple,40551,documentation/JSROOT/JSROOT.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/JSROOT/JSROOT.md,1,['Simpl'],['Simple']
Usability,"``mu`` before calling ``withdrawImpl``.; Because the caller is assumed to have locked ``mu``, it is safe to modify; ``balance`` within the body of the method. The ``depositImpl()`` method does not have ``REQUIRES``, so the; analysis issues a warning. Thread safety analysis is not inter-procedural, so; caller requirements must be explicitly declared.; There is also a warning in ``transferFrom()``, because although the method; locks ``this->mu``, it does not lock ``b.mu``. The analysis understands; that these are two separate mutexes, in two different objects. Finally, there is a warning in the ``withdraw()`` method, because it fails to; unlock ``mu``. Every lock must have a corresponding unlock, and the analysis; will detect both double locks, and double unlocks. A function is allowed to; acquire a lock without releasing it, (or vice versa), but it must be annotated; as such (using ``ACQUIRE``/``RELEASE``). Running The Analysis; --------------------. To run the analysis, simply compile with the ``-Wthread-safety`` flag, e.g. .. code-block:: bash. clang -c -Wthread-safety example.cpp. Note that this example assumes the presence of a suitably annotated; :ref:`mutexheader` that declares which methods perform locking,; unlocking, and so on. Basic Concepts: Capabilities; ============================. Thread safety analysis provides a way of protecting *resources* with; *capabilities*. A resource is either a data member, or a function/method; that provides access to some underlying resource. The analysis ensures that; the calling thread cannot access the *resource* (i.e. call the function, or; read/write the data) unless it has the *capability* to do so. Capabilities are associated with named C++ objects which declare specific; methods to acquire and release the capability. The name of the object serves; to identify the capability. The most common example is a mutex. For example,; if ``mu`` is a mutex, then calling ``mu.Lock()`` causes the calling thread; to acquire the ca",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:3180,simpl,simply,3180,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,1,['simpl'],['simply']
Usability,"`dot-post-dom``: Print postdominance tree of function to ""dot"" file; --------------------------------------------------------------------. This pass, only available in ``opt``, prints the post dominator tree into a; ``.dot`` graph. This graph can then be processed with the :program:`dot` tool; to convert it to postscript or some other suitable format. ``dot-post-dom-only``: Print postdominance tree of function to ""dot"" file (with no function bodies); ---------------------------------------------------------------------------------------------------. This pass, only available in ``opt``, prints the post dominator tree into a; ``.dot`` graph, omitting the function bodies. This graph can then be processed; with the :program:`dot` tool to convert it to postscript or some other suitable; format. ``globals-aa``: Simple mod/ref analysis for globals; ---------------------------------------------------. This simple pass provides alias and mod/ref information for global values that; do not have their address taken, and keeps track of whether functions read or; write memory (are ""pure""). For this simple (but very common) case, we can; provide pretty accurate and useful information. ``instcount``: Counts the various types of ``Instruction``\ s; -------------------------------------------------------------. This pass collects the count of all instructions and reports them. ``iv-users``: Induction Variable Users; --------------------------------------. Bookkeeping for ""interesting"" users of expressions computed from induction; variables. ``lazy-value-info``: Lazy Value Information Analysis; ----------------------------------------------------. Interface for lazy computation of value constraint information. ``lint``: Statically lint-checks LLVM IR; ----------------------------------------. This pass statically checks for common and easily-identified constructs which; produce undefined or likely unintended behavior in LLVM IR. It is not a guarantee of correctness, in two ways. Firs",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst:5525,simpl,simple,5525,interpreter/llvm-project/llvm/docs/Passes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst,1,['simpl'],['simple']
Usability,"`llc``, then pipe the output of ``llc`` into ``FileCheck``. This; means that FileCheck will be verifying its standard input (the llc output); against the filename argument specified (the original ``.ll`` file specified by; ""``%s``""). To see how this works, let's look at the rest of the ``.ll`` file; (after the RUN line):. .. code-block:: llvm. define void @sub1(i32* %p, i32 %v) {; entry:; ; CHECK: sub1:; ; CHECK: subl; %0 = tail call i32 @llvm.atomic.load.sub.i32.p0i32(i32* %p, i32 %v); ret void; }. define void @inc4(i64* %p) {; entry:; ; CHECK: inc4:; ; CHECK: incq; %0 = tail call i64 @llvm.atomic.load.add.i64.p0i64(i64* %p, i64 1); ret void; }. Here you can see some ""``CHECK:``"" lines specified in comments. Now you can; see how the file is piped into ``llvm-as``, then ``llc``, and the machine code; output is what we are verifying. FileCheck checks the machine code output to; verify that it matches what the ""``CHECK:``"" lines specify. The syntax of the ""``CHECK:``"" lines is very simple: they are fixed strings that; must occur in order. FileCheck defaults to ignoring horizontal whitespace; differences (e.g. a space is allowed to match a tab) but otherwise, the contents; of the ""``CHECK:``"" line is required to match some thing in the test file exactly. One nice thing about FileCheck (compared to grep) is that it allows merging; test cases together into logical groups. For example, because the test above; is checking for the ""``sub1:``"" and ""``inc4:``"" labels, it will not match; unless there is a ""``subl``"" in between those labels. If it existed somewhere; else in the file, that would not count: ""``grep subl``"" matches if ""``subl``""; exists anywhere in the file. The FileCheck -check-prefix option; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. The FileCheck `-check-prefix` option allows multiple test; configurations to be driven from one `.ll` file. This is useful in many; circumstances, for example, testing different architectural variants with; :program:`llc`. Here's a simple e",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst:9137,simpl,simple,9137,interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,1,['simpl'],['simple']
Usability,"`remarkEmitter``; or even ``remarker``. The following is a list of longer class names and the associated shorter; variable name. ========================= =============; Class name Variable name; ========================= =============; BasicBlock block; ConstantExpr expr; ExecutionEngine engine; MachineOperand operand; OptimizationRemarkEmitter remarker; PreservedAnalyses analyses; PreservedAnalysesChecker checker; TargetLowering lowering; TargetMachine machine; ========================= =============. Transition Options; ==================. There are three main options for transitioning:. 1. Keep the current coding standard; 2. Laissez faire; 3. Big bang. Keep the current coding standard; --------------------------------. Proponents of keeping the current coding standard (i.e. not transitioning at; all) question whether the cost of transition outweighs the benefit; [EmersonConcern]_ [ReamesConcern]_ [BradburyConcern]_.; The costs are that ``git blame`` will become less usable; and that merging the; changes will be costly for downstream maintainers. See `Big bang`_ for potential; mitigations. Laissez faire; -------------. The coding standard could allow both ``CamelCase`` and ``camelBack`` styles for; variable names [LattnerTransition]_. A code review to implement this is at https://reviews.llvm.org/D57896. Advantages; **********. * Very easy to implement initially. Disadvantages; *************. * Leads to inconsistency [BradburyConcern]_ [AminiInconsistent]_.; * Inconsistency means it will be hard to know at a guess what name a variable; will have [DasInconsistent]_ [CarruthInconsistent]_.; * Some large-scale renaming may happen anyway, leading to its disadvantages; without any mitigations. Big bang; --------. With this approach, variables will be renamed by an automated script in a series; of large commits. The principle advantage of this approach is that it minimises the cost of; inconsistency [BradburyTransition]_ [RobinsonTransition]_. It goes against a policy",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst:7785,usab,usable,7785,interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst,1,['usab'],['usable']
Usability,"`vptr``. This flag is enabled by default for sanitizers in the ``cfi`` group. .. option:: -fsanitize-ignorelist=/path/to/ignorelist/file. Disable or modify sanitizer checks for objects (source files, functions,; variables, types) listed in the file. See; :doc:`SanitizerSpecialCaseList` for file format description. .. option:: -fno-sanitize-ignorelist. Don't use ignorelist file, if it was specified earlier in the command line. .. option:: -f[no-]sanitize-coverage=[type,features,...]. Enable simple code coverage in addition to certain sanitizers.; See :doc:`SanitizerCoverage` for more details. .. option:: -f[no-]sanitize-address-outline-instrumentation. Controls how address sanitizer code is generated. If enabled will always use; a function call instead of inlining the code. Turning this option on could; reduce the binary size, but might result in a worse run-time performance. See :doc: `AddressSanitizer` for more details. .. option:: -f[no-]sanitize-stats. Enable simple statistics gathering for the enabled sanitizers.; See :doc:`SanitizerStats` for more details. .. option:: -fsanitize-undefined-trap-on-error. Deprecated alias for ``-fsanitize-trap=undefined``. .. option:: -fsanitize-cfi-cross-dso. Enable cross-DSO control flow integrity checks. This flag modifies; the behavior of sanitizers in the ``cfi`` group to allow checking; of cross-DSO virtual and indirect calls. .. option:: -fsanitize-cfi-icall-generalize-pointers. Generalize pointers in return and argument types in function type signatures; checked by Control Flow Integrity indirect call checking. See; :doc:`ControlFlowIntegrity` for more details. .. option:: -fsanitize-cfi-icall-experimental-normalize-integers. Normalize integers in return and argument types in function type signatures; checked by Control Flow Integrity indirect call checking. See; :doc:`ControlFlowIntegrity` for more details. This option is currently experimental. .. option:: -fstrict-vtable-pointers. Enable optimizations based on the stric",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:79257,simpl,simple,79257,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['simpl'],['simple']
Usability,"a coroutine function, which; // would return a coroutine type 'Task'. In practice, we typically say ""`Coros` contains 3 coroutines"" in the above; example, though this is not strictly correct. More technically, this should; say ""`Coros` contains 3 coroutine instances"" or ""Coros contains 3 coroutine; objects."". In this document, we follow the common practice of using `coroutine` to refer; to an individual `coroutine instance`, since the terms `coroutine instance` and; `coroutine object` aren't sufficiently defined in this case. coroutine frame; ---------------. The C++ Standard uses `coroutine state` to describe the allocated storage. In; the compiler, we use `coroutine frame` to describe the generated data structure; that contains the necessary information. The structure of coroutine frames; =================================. The structure of coroutine frames is defined as:. .. code-block:: c++. struct {; void (*__r)(); // function pointer to the `resume` function; void (*__d)(); // function pointer to the `destroy` function; promise_type; // the corresponding `promise_type`; ... // Any other needed information; }. In the debugger, the function's name is obtainable from the address of the; function. And the name of `resume` function is equal to the name of the; coroutine function. So the name of the coroutine is obtainable once the; address of the coroutine is known. Print promise_type; ==================. Every coroutine has a `promise_type`, which defines the behavior; for the corresponding coroutine. In other words, if two coroutines have the; same `promise_type`, they should behave in the same way.; To print a `promise_type` in a debugger when stopped at a breakpoint inside a; coroutine, printing the `promise_type` can be done by:. .. parsed-literal::. print __promise. It is also possible to print the `promise_type` of a coroutine from the address; of the coroutine frame. For example, if the address of a coroutine frame is; 0x416eb0, and the type of the `promise_",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst:2869,resume,resume,2869,interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst,1,['resume'],['resume']
Usability,"a is owned by the enclosing object. No inlining.; ------------. Thread safety analysis is strictly intra-procedural, just like ordinary type; checking. It relies only on the declared attributes of a function, and will; not attempt to inline any method calls. As a result, code such as the; following will not work:. .. code-block:: c++. template<class T>; class AutoCleanup {; T* object;; void (T::*mp)();. public:; AutoCleanup(T* obj, void (T::*imp)()) : object(obj), mp(imp) { }; ~AutoCleanup() { (object->*mp)(); }; };. Mutex mu;; void foo() {; mu.Lock();; AutoCleanup<Mutex>(&mu, &Mutex::Unlock);; // ...; } // Warning, mu is not unlocked. In this case, the destructor of ``Autocleanup`` calls ``mu.Unlock()``, so; the warning is bogus. However,; thread safety analysis cannot see the unlock, because it does not attempt to; inline the destructor. Moreover, there is no way to annotate the destructor,; because the destructor is calling a function that is not statically known.; This pattern is simply not supported. No alias analysis.; ------------------. The analysis currently does not track pointer aliases. Thus, there can be; false positives if two pointers both point to the same mutex. .. code-block:: c++. class MutexUnlocker {; Mutex* mu;. public:; MutexUnlocker(Mutex* m) RELEASE(m) : mu(m) { mu->Unlock(); }; ~MutexUnlocker() ACQUIRE(mu) { mu->Lock(); }; };. Mutex mutex;; void test() REQUIRES(mutex) {; {; MutexUnlocker munl(&mutex); // unlocks mutex; doSomeIO();; } // Warning: locks munl.mu; }. The MutexUnlocker class is intended to be the dual of the MutexLocker class,; defined in :ref:`mutexheader`. However, it doesn't work because the analysis; doesn't know that munl.mu == mutex. The SCOPED_CAPABILITY attribute handles; aliasing for MutexLocker, but does so only for that particular pattern. ACQUIRED_BEFORE(...) and ACQUIRED_AFTER(...) are currently unimplemented.; -------------------------------------------------------------------------. To be fixed in a future update. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:23699,simpl,simply,23699,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,1,['simpl'],['simply']
Usability,"a local notebook server customised with all the ROOT features. New tutorials and code examples have been provided. The simplest example showing the integration of ROOT with the notebook technology can be found [here](https://root.cern.ch/notebooks/HowTos/HowTo_ROOT-Notebooks.html) and many more snippets [here](https://root.cern.ch/code-examples#notebooks). Support for capturing large outputs (stderr/stdout) coming from C++ libraries has been added. ## JavaScript ROOT. - support registered in THttpServer commands with arguments.; - provide workaround for websites using require.js and older jquery-ui; - support custom requests to remote objects, demonstrated in httptextlog.C tutorial; - rewrite draw.htm (page for individual object drawing) to support all custom features as main gui does; - See also the [JSRoot 3.9 examples page](https://root.cern.ch/js/3.9/) and the [JSRoot 3.9 release notes](https://github.com/linev/jsroot/releases/tag/3.9). ## Class Reference Guide. The ROOT [reference guide](https://root.cern.ch/doc/master/index.html) is moving; to the Doxygen system. Doxygen is the de-facto standard for code documentation. It offers; many nice features we are now exploring and trying to get the best of them. Having; [MathJax rendered math formula](https://root.cern.ch/doc/master/classTSpectrum2.html#a482a7f144b9cc1b0405d0ac0d8cc9bbb); is one of them. The documentation can be structured in a more logical way; [using groups](https://root.cern.ch/doc/master/modules.html). Still there is a lot; to do but big progresses have been done. We developed also a Doxygen filter allowing; to execute macros given as examples in the documentation and show the; [resulting picture directly in the documentation](https://root.cern.ch/doc/master/classTHistPainter.html#HP16). ## Tutorials. [The tutorials](https://root.cern.ch/doc/master/group__Tutorials.html) in; `$ROOTSYS/tutorials` are also presented on the web thanks to Doxygen. They; are now part of the reference guide allowing nice",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v606/index.md:23577,guid,guide,23577,README/ReleaseNotes/v606/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v606/index.md,1,['guid'],['guide']
Usability,"a multi-line command:. ``` {.cpp}; root [] {; root [] ? TLine l;; root [] ? for (int i = 0; i < 5; i++) {; root [] ? l.SetX1(i);; root [] ? l.SetY1(i+1);; root [] ? l.Print();; root [] ? }; root [] ? }; TLine X1=0.000000 Y1=1.000000 X2=0.000000 Y2=0.000000; TLine X1=1.000000 Y1=2.000000 X2=0.000000 Y2=0.000000; TLine X1=2.000000 Y1=3.000000 X2=0.000000 Y2=0.000000; TLine X1=3.000000 Y1=4.000000 X2=0.000000 Y2=0.000000; TLine X1=4.000000 Y1=5.000000 X2=0.000000 Y2=0.000000; root [] .q; ```. Here we note:. - A multi-line command starts with a { and ends with a }.; - Inside continuation, every line has to be correctly terminated with a ; (like in ""real''; C++).; - All objects are created in *global* scope.; - There is no way to back up; you are better off writing a script.; - Use `.q` to exit root. ## Feeding Sources Files To ROOT: C++ Scripts. ROOT script files (often called ""Macros"") contain pure C++ code. They can contain a simple; sequence of statements like in the multi command line example given; above, but also arbitrarily complex class and function definitions. The most frequent interaction with the ROOT prompt uses `.x` to ""run"" a file:. ```; root [] .x myScript.C; ```. This loads myScript.C into the interpreter and calls the function `myScript()`.; You can pass arguments using `.x myScript.C(12, ""A String"")`. Alternatively you can load the script and then run a function explicitly:. ```; root [] .L myScript.C; root [] myScript(); ```. The above is equivalent to `.x myScript.C`. In a named script, the objects created on the stack are deleted when; the function exits. In a common scenario you; create a histogram in a named script on the stack. You draw the; histogram, but when the function exits the canvas is empty and the; histogram has disappeared. To avoid the histogram from disappearing you can; create it on the heap (by using new). This will leave the histogram; object intact, but the pointer in the named script scope will be; ""gone"". Since histograms (and",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md:7619,simpl,simple,7619,documentation/users-guide/Cling.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md,1,['simpl'],['simple']
Usability,"a protocol). .. admonition:: Rationale. There are a fair number of existing methods with ``init``-like selectors; which nonetheless don't follow the ``init`` conventions. Typically these; are either accidental naming collisions or helper methods called during; initialization. Because of the peculiar retain/release behavior of; ``init`` methods, it's very important not to treat these methods as; ``init`` methods if they aren't meant to be. It was felt that implicitly; defining these methods out of the family based on the exact relationship; between the return type and the declaring class would be much too subtle; and fragile. Therefore we identify a small number of legitimate-seeming; return types and call everything else an error. This serves the secondary; purpose of encouraging programmers not to accidentally give methods names; in the ``init`` family. Note that a method with an ``init``-family selector which returns a; non-Objective-C type (e.g. ``void``) is perfectly well-formed; it simply; isn't in the ``init`` family. A program is ill-formed if a method's declarations, implementations, and; overrides do not all have the same method family. .. _arc.family.attribute:. Explicit method family control; ------------------------------. A method may be annotated with the ``objc_method_family`` attribute to; precisely control which method family it belongs to. If a method in an; ``@implementation`` does not have this attribute, but there is a method; declared in the corresponding ``@interface`` that does, then the attribute is; copied to the declaration in the ``@implementation``. The attribute is; available outside of ARC, and may be tested for with the preprocessor query; ``__has_attribute(objc_method_family)``. The attribute is spelled; ``__attribute__((objc_method_family(`` *family* ``)))``. If *family* is; ``none``, the method has no family, even if it would otherwise be considered to; have one based on its selector and type. Otherwise, *family* must be one of; ``a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:69858,simpl,simply,69858,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['simpl'],['simply']
Usability,"a reference to the underlying type (same; example: Instruction&) instead of a pointer to the underlying object. This; makes it much easier to write nested loops that iterator over things, changing; this:. for (Function::iterator BI = Func->begin(); BI != Func->end(); ++BI); for (BasicBlock::iterator II = (*BI)->begin(); II != (*BI)->end(); ++II); (*II)->dump();. into:. for (Function::iterator BI = Func->begin(); BI != Func->end(); ++BI); for (BasicBlock::iterator II = BI->begin(); II != BI->end(); ++II); II->dump();. which is much more natural and what users expect. * Simplification of #include's: Before, it was necessary for a .cpp file to; include every .h file that it used. Now things are batched a little bit more; to make it easier to use. Specifically, the include graph now includes these; edges:; Module.h -> Function.h, GlobalVariable.h; Function.h -> BasicBlock.h, Argument.h; BasicBlock.h -> Instruction.h. Which means that #including Function.h is usually sufficient for getting the; lower level #includes. * Printing out a Value* has now changed: Printing a Value* will soon print out; the address of the value instead of the contents of the Value. To print out; the contents, you must convert it to a reference with (for example); 'cout << *I' instead of 'cout << I;'. This conversion is not yet complete,; but will be eventually. In the mean time, both forms print out the contents. * References are used much more throughout the code base. In general, if a; pointer is known to never be null, it is passed in as a reference instead of a; pointer. For example, the instruction visitor class uses references instead; of pointers, and that Pass subclasses now all receive references to Values; instead of pointers, because they may never be null. * The Function class now has helper functions for accessing the Arguments list.; Instead of having to go through getArgumentList for simple things like; iterator over the arguments, now the a*() methods can be used to access them. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2002-06-25-MegaPatchInfo.txt:3218,simpl,simple,3218,interpreter/llvm-project/llvm/docs/HistoricalNotes/2002-06-25-MegaPatchInfo.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2002-06-25-MegaPatchInfo.txt,1,['simpl'],['simple']
Usability,"a.org/wiki/MIT_License); - Free from copy-left licenses, like GPL, because you should innovate without; restrictions.; - Forked from [Mongoose](https://code.google.com/p/mongoose/) in 2013, before; it changed the licence from MIT to commercial + GPL. A lot of enhancements; have been added since that time, see; [RELEASE_NOTES.md](https://github.com/civetweb/civetweb/blob/master/RELEASE_NOTES.md).; - Works on Windows, Mac, Linux, UNIX, iPhone, Android, Buildroot, and many; other platforms.; - Scripting and database support (CGI, SQLite database, Lua Server Pages,; Server side Lua scripts, Server side JavaScript).; This provides a ready to go, powerful web development platform in a one; single-click executable with **no dependencies**.0; - Support for CGI, SSI, HTTP digest (MD5) authorization, WebSocket,; WebDAV.; - HTTPS (SSL/TLS) support using [OpenSSL](https://www.openssl.org/).; - Optional support for authentication using client side X.509 certificates.; - Resumed download, URL rewrite, file blacklist, IP-based ACL.; - May run as Windows service.; - Download speed limit based on client subnet or URI pattern.; - Simple and clean embedding API.; - The source is in single file to make things easy.; - Embedding examples included.; - HTTP client capable of sending arbitrary HTTP/HTTPS requests.; - Websocket client functionality available (WS/WSS). ### Optionally included software. [![Lua](https://raw.githubusercontent.com/civetweb/civetweb/master/resources/lua-logo.jpg ""Lua Logo"")](http://lua.org). [![Sqlite3](https://raw.githubusercontent.com/civetweb/civetweb/master/resources/sqlite3-logo.jpg ""Sqlite3 Logo"")](http://sqlite.org). [![LuaFileSystem](https://raw.githubusercontent.com/civetweb/civetweb/master/resources/luafilesystem-logo.jpg ""LuaFileSystem Logo"")](http://keplerproject.github.io/luafilesystem/). [![LuaSQLite3](https://raw.githubusercontent.com/civetweb/civetweb/master/resources/luasqlite-logo.jpg ""LuaSQLite3 Logo"")](http://lua.sqlite.org/index.cgi/index). [",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/README.md:6325,Resume,Resumed,6325,net/http/civetweb/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/README.md,1,['Resume'],['Resumed']
Usability,"able through the ``getType()`` method. In addition, all LLVM; values can be named. The ""name"" of the ``Value`` is a symbolic string printed; in the LLVM code:. .. code-block:: llvm. %foo = add i32 1, 2. .. _nameWarning:. The name of this instruction is ""foo"". **NOTE** that the name of any value may; be missing (an empty string), so names should **ONLY** be used for debugging; (making the source code easier to read, debugging printouts), they should not be; used to keep track of values or map between them. For this purpose, use a; ``std::map`` of pointers to the ``Value`` itself instead. One important aspect of LLVM is that there is no distinction between an SSA; variable and the operation that produces it. Because of this, any reference to; the value produced by an instruction (or the value available as an incoming; argument, for example) is represented as a direct pointer to the instance of the; class that represents this value. Although this may take some getting used to,; it simplifies the representation and makes it easier to manipulate. .. _m_Value:. Important Public Members of the ``Value`` class; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. * | ``Value::use_iterator`` - Typedef for iterator over the use-list; | ``Value::const_use_iterator`` - Typedef for const_iterator over the; use-list; | ``unsigned use_size()`` - Returns the number of users of the value.; | ``bool use_empty()`` - Returns true if there are no users.; | ``use_iterator use_begin()`` - Get an iterator to the start of the; use-list.; | ``use_iterator use_end()`` - Get an iterator to the end of the use-list.; | ``User *use_back()`` - Returns the last element in the list. These methods are the interface to access the def-use information in LLVM.; As with all other iterators in LLVM, the naming conventions follow the; conventions defined by the STL_. * ``Type *getType() const``; This method returns the Type of the Value. * | ``bool hasName() const``; | ``std::string getName() const``; | ``void",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:143064,simpl,simplifies,143064,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['simpl'],['simplifies']
Usability,"above,; except that the bisection script does not need to include the; `git submodule update` step. The same example, finding which commit introduces a regression where clang-3.9; crashes but not clang-3.8 passes, will look like::. git bisect start releases/3.9.x releases/3.8.x; git bisect run ./bisect_script.sh. With the `bisect_script.sh` script being::. #!/bin/sh; cd $BUILD_DIR. ninja clang || exit 125 # an exit code of 125 asks ""git bisect""; # to ""skip"" the current commit. ./bin/clang some_crash_test.cpp. Also, since the monorepo handles commits update across multiple projects, you're; less like to encounter a build failure where a commit change an API in LLVM and; another later one ""fixes"" the build in clang. Moving Local Branches to the Monorepo; =====================================. Suppose you have been developing against the existing LLVM git; mirrors. You have one or more git branches that you want to migrate; to the ""final monorepo"". The simplest way to migrate such branches is with the; ``migrate-downstream-fork.py`` tool at; https://github.com/jyknight/llvm-git-migration. Basic migration; ---------------. Basic instructions for ``migrate-downstream-fork.py`` are in the; Python script and are expanded on below to a more general recipe::. # Make a repository which will become your final local mirror of the; # monorepo.; mkdir my-monorepo; git -C my-monorepo init. # Add a remote to the monorepo.; git -C my-monorepo remote add upstream/monorepo https://github.com/llvm/llvm-project.git. # Add remotes for each git mirror you use, from upstream as well as; # your local mirror. All projects are listed here but you need only; # import those for which you have local branches.; my_projects=( clang; clang-tools-extra; compiler-rt; debuginfo-tests; libcxx; libcxxabi; libunwind; lld; lldb; llvm; openmp; polly ); for p in ${my_projects[@]}; do; git -C my-monorepo remote add upstream/split/${p} https://github.com/llvm-mirror/${p}.git; git -C my-monorepo remote add loc",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst:20266,simpl,simplest,20266,interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,1,['simpl'],['simplest']
Usability,"absolutely; required; for example for certain code that cannot tolerate any instrumentation; and resulting side-effects. This attribute overrides ``no_sanitize(""memory"")``. Ignorelist; ----------. MemorySanitizer supports ``src`` and ``fun`` entity types in; :doc:`SanitizerSpecialCaseList`, that can be used to relax MemorySanitizer; checks for certain source files and functions. All ""Use of uninitialized value""; warnings will be suppressed and all values loaded from memory will be; considered fully initialized. Report symbolization; ====================. MemorySanitizer uses an external symbolizer to print files and line numbers in; reports. Make sure that ``llvm-symbolizer`` binary is in ``PATH``,; or set environment variable ``MSAN_SYMBOLIZER_PATH`` to point to it. .. _msan-origins:. Origin Tracking; ===============. MemorySanitizer can track origins of uninitialized values, similar to; Valgrind's --track-origins option. This feature is enabled by; ``-fsanitize-memory-track-origins=2`` (or simply; ``-fsanitize-memory-track-origins``) Clang option. With the code from; the example above,. .. code-block:: console. % cat umr2.cc; #include <stdio.h>. int main(int argc, char** argv) {; int* a = new int[10];; a[5] = 0;; volatile int b = a[argc];; if (b); printf(""xx\n"");; return 0;; }. % clang -fsanitize=memory -fsanitize-memory-track-origins=2 -fno-omit-frame-pointer -g -O2 umr2.cc; % ./a.out; WARNING: MemorySanitizer: use-of-uninitialized-value; #0 0x7f7893912f0b in main umr2.cc:7; #1 0x7f789249b76c in __libc_start_main libc-start.c:226. Uninitialized value was stored to memory at; #0 0x7f78938b5c25 in __msan_chain_origin msan.cc:484; #1 0x7f7893912ecd in main umr2.cc:6. Uninitialized value was created by a heap allocation; #0 0x7f7893901cbd in operator new[](unsigned long) msan_new_delete.cc:44; #1 0x7f7893912e06 in main umr2.cc:4. By default, MemorySanitizer collects both allocation points and all; intermediate stores the uninitialized value went through. Origin; track",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MemorySanitizer.rst:3995,simpl,simply,3995,interpreter/llvm-project/clang/docs/MemorySanitizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MemorySanitizer.rst,1,['simpl'],['simply']
Usability,"ace; that allows users to input these options without ever invoking the; action. Selection Requirements; ^^^^^^^^^^^^^^^^^^^^^^. The refactoring rule requirements that require some form of source selection; are listed below:. - ``SourceRangeSelectionRequirement`` evaluates to a source range when the; action is invoked with some sort of selection. This requirement should be; satisfied when a refactoring is initiated in an editor, even when the user; has not selected anything (the range will contain the cursor's location in; that case). .. FIXME: Future selection requirements. .. FIXME: Maybe mention custom selection requirements?. Other Requirements; ^^^^^^^^^^^^^^^^^^. There are several other requirements types that can be used when creating; a refactoring rule:. - The ``RefactoringOptionsRequirement`` requirement is an abstract class that; should be subclassed by requirements working with options. The more; concrete ``OptionRequirement`` requirement is a simple implementation of the; aforementioned class that returns the value of the specified option when; it's evaluated. The next section talks more about refactoring options and; how they can be used when creating a rule. Refactoring Options; -------------------. Refactoring options are values that affect a refactoring operation and are; specified either using command-line options or another client-specific; mechanism. Options should be created using a class that derives either from; the ``OptionalRequiredOption`` or ``RequiredRefactoringOption``. The following; example shows how one can created a required string option that corresponds to; the ``-new-name`` command-line option in clang-refactor:. .. code-block:: c++. class NewNameOption : public RequiredRefactoringOption<std::string> {; public:; StringRef getName() const override { return ""new-name""; }; StringRef getDescription() const override {; return ""The new name to change the symbol to"";; }; };. The option that's shown in the example above can then be used t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst:9541,simpl,simple,9541,interpreter/llvm-project/clang/docs/RefactoringEngine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst,1,['simpl'],['simple']
Usability,"ack(i); ...; >>> for i in v:; ... print(i, end=' '); 1 2 3 4 5 6 7 8 9; >>>; >>> list(v); [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]; >>>; ```. The parameters to the template instantiation can either be an actual; type or value (as is used here, ""int""), or a string representation of; the parameters (e.g. ""'double'""), or a mixture of both (e.g. ""'TCanvas,; 0'"" or ""'double', 0"" ). The ""std::vector\<int\>"" class is one of the; classes builtin by default into the Cling extension dlls. You will get a; non-functional class (instances of which can still be passed around to; C++) if the corresponding dictionary doesn't exist. #### Access to ROOT Globals. Most globals and global functions can be imported directly from the; ROOT.py module, but some common ones (most notably **`gMinuit`**,; although that variable now exists at startup from release 5.08 onward); do not exist yet at program startup, as they exist in modules that are; loaded later (e.g. through the auto-loading mechanism). An example; session should make this clear:. ``` {.cpp}; >>> from ROOT import *; >>> gROOT # directly available; <ROOT.TROOT object at 0x399c30>; >>> gMinuit # library not yet loaded: not available; Traceback (most recent call last):; File ""<stdin>"", line 1, in ?; NameError: name 'gMinuit' is not defined; >>> TMinuit # use of TMinuit class forces auto-loading; <class '__main__.TMinuit'>; >>> gMinuit # now gMinuit is available; <__main__.TMinuit object at 0x1458c70>; >>> not not gMinuit # but it is the null pointer, until set; False; >>> g = TMinuit(); >>> not not gMinuit; True; ```. It is also possible to create globals interactively, either by executing; a Cling macro, or by a call to `gROOT.ProcessLine()`. These globals are; made available in the same way: either use them directly after creation; in 'from ROOT import \*' more, or get them from the ROOT namespace after; an 'import ROOT'. As of 5.08, the behaviour of ROOT globals is the same as python globals,; which is sometimes counterintuitive: since the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:13181,clear,clear,13181,documentation/users-guide/PythonRuby.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md,1,['clear'],['clear']
Usability,"ackSafetyAnalysis; SupportLibrary; TableGen/index; TableGenFundamentals; Vectorizers; WritingAnLLVMPass; WritingAnLLVMNewPMPass; WritingAnLLVMBackend; yaml2obj. Clang; -----. :doc:`HowToBuildOnARM`; Notes on building and testing LLVM/Clang on ARM. :doc:`HowToBuildWithPGO`; Notes on building LLVM/Clang with PGO. :doc:`HowToCrossCompileLLVM`; Notes on cross-building and testing LLVM/Clang. `How to build the C, C++, ObjC, and ObjC++ front end`__; Instructions for building the clang front-end from source. .. __: https://clang.llvm.org/get_started.html. :doc:`CoverageMappingFormat`; This describes the format and encoding used for LLVM’s code coverage mapping. :doc:`CFIVerify`; A description of the verification tool for Control Flow Integrity. LLVM Builds and Distributions; -----------------------------. :doc:`BuildingADistribution`; A best-practices guide for using LLVM's CMake build system to package and; distribute LLVM-based tools. :doc:`CMake`; An addendum to the main Getting Started guide for those using the `CMake; build system <http://www.cmake.org>`_. :doc:`Docker`; A reference for using Dockerfiles provided with LLVM. :doc:`Support Library <SupportLibrary>`; This document describes the LLVM Support Library (``lib/Support``) and; how to keep LLVM source code portable. :doc:`AdvancedBuilds`; This document describes more advanced build configurations. Optimizations; -------------. :doc:`WritingAnLLVMPass`; Information on how to write LLVM transformations and analyses. :doc:`WritingAnLLVMNewPMPass`; Information on how to write LLVM transformations under the new pass; manager. :doc:`Passes`; A list of optimizations and analyses implemented in LLVM. :doc:`StackSafetyAnalysis`; This document describes the design of the stack safety analysis of local; variables. :doc:`MergeFunctions`; Describes functions merging optimization. :doc:`AliasAnalysis`; Information on how to write a new alias analysis implementation or how to; use existing analyses. :doc:`MemorySSA`; Informat",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/UserGuides.rst:2223,guid,guide,2223,interpreter/llvm-project/llvm/docs/UserGuides.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/UserGuides.rst,1,['guid'],['guide']
Usability,"act with LLVM IR. Design of MemorySSA; ===================. ``MemorySSA`` is an analysis that can be built for any arbitrary function. When; it's built, it does a pass over the function's IR in order to build up its; mapping of ``MemoryAccess``\ es. You can then query ``MemorySSA`` for things; like the dominance relation between ``MemoryAccess``\ es, and get the; ``MemoryAccess`` for any given ``Instruction`` . When ``MemorySSA`` is done building, it also hands you a ``MemorySSAWalker``; that you can use (see below). The walker; ----------. A structure that helps ``MemorySSA`` do its job is the ``MemorySSAWalker``, or; the walker, for short. The goal of the walker is to provide answers to clobber; queries beyond what's represented directly by ``MemoryAccess``\ es. For example,; given:. .. code-block:: llvm. define void @foo() {; %a = alloca i8; %b = alloca i8. ; 1 = MemoryDef(liveOnEntry); store i8 0, ptr %a; ; 2 = MemoryDef(1); store i8 0, ptr %b; }. The store to ``%a`` is clearly not a clobber for the store to ``%b``. It would; be the walker's goal to figure this out, and return ``liveOnEntry`` when queried; for the clobber of ``MemoryAccess`` ``2``. By default, ``MemorySSA`` provides a walker that can optimize ``MemoryDef``\ s; and ``MemoryUse``\ s by consulting whatever alias analysis stack you happen to; be using. Walkers were built to be flexible, though, so it's entirely reasonable; (and expected) to create more specialized walkers (e.g. one that specifically; queries ``GlobalsAA``, one that always stops at ``MemoryPhi`` nodes, etc). Default walker APIs; ^^^^^^^^^^^^^^^^^^^. There are two main APIs used to retrieve the clobbering access using the walker:. - ``MemoryAccess *getClobberingMemoryAccess(MemoryAccess *MA);`` return the; clobbering memory access for ``MA``, caching all intermediate results; computed along the way as part of each access queried. - ``MemoryAccess *getClobberingMemoryAccess(MemoryAccess *MA, const MemoryLocation &Loc);``; returns the a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MemorySSA.rst:9204,clear,clearly,9204,interpreter/llvm-project/llvm/docs/MemorySSA.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MemorySSA.rst,1,['clear'],['clearly']
Usability,"activated thanks to the options `PFC`; (Palette Fill Color), `PLC` (Palette Line Color) and `AMC` (Palette Marker Color).; When one of these options is given to `TH1::Draw` the histogram get its color; from the current color palette defined by `gStyle->SetPalette(…)`. The color; is determined according to the number of objects having palette coloring in; the current pad.; - The line width and line style can be change on 2d histograms painted with; option `ARR`.; - When the angle of a TGraphPolar was not in radian, the error bars were misplaced.; The problem was reported [here](https://sft.its.cern.ch/jira/browse/ROOT-8476).; - In `TASimage::DrawLineInternal` the case of a line with 0 pixel along X and 0; pixel along Y was not treated properly. An horizontal line was drawn instead.; - In `TGraphPainter::PaintGrapHist`: Decouple the `P` option (histogram drawn with; a simple polymarker) from the `L` option (Histogram drawn as a simple polyline). This; improved (in some cases some extra markers were drawn) and simplified the code.; - Candle plot improvements:; * Rearragement of TCandle-code - split into calculate and paint; * Implementation for a ""raw-data candle"" inside TCandle - to be used from TTreeViewer in the future; * Implementation of 1D histograms along each candle (left, right and violin) - to be used for violin-charts; * Implementation of a zero indicator line for TCandle - to be used for violin-charts; * Reimplementation if THistPainter draw option VIOLIN; * Implementations of presets and individual options for VIOLIN-charts; * Implementation of VIOLIN-charts in THStack - can be combined with CANDLE; * Update of the docs (THistPainter and THStack); * New tutorials; - In various places in TGraph the underlying histogram was deleted when the graph; range should be recomputed. This has the side effect that some graph parameters; (like the axis titles) were also deleted. This now fixed. It was reported; [here](https://sft.its.cern.ch/jira/browse/ROOT-8092).; - ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v610/index.md:10191,simpl,simplified,10191,README/ReleaseNotes/v610/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v610/index.md,1,['simpl'],['simplified']
Usability,"acuum"",0,0,0);; root[] TGeoMedium *med = new TGeoMedium(""Vacuum"",1,mat);; ~~~. We can finally make our volume having a box shape. Note that the world; volume does not need to be a box - it can be any other shape. Generally,; boxes and tubes are the most recommendable shapes for this purpose due; to their fast navigation algorithms. ~~~{.cpp}; root[] TGeoVolume *top=gGeoManager->MakeBox(""Top"",med,10.,10.,10.);; ~~~. The default units are in centimeters. Now we want to make this volume; our world. We have to do this operation **before** closing the geometry. ~~~{.cpp}; root[] gGeoManager->SetTopVolume(top);; ~~~. This should be enough, but it is not since always after defining some; geometry hierarchy, TGeo needs to build some optimization; structures and perform some checks. Note the messages posted after the; statement is executed. We will describe the corresponding operations; later. ~~~{.cpp}; root[] gGeoManager->CloseGeometry();; ~~~. Now we are really done with geometry building stage, but we would like; to see our simple world:. ~~~{.cpp}; root[] top->SetLineColor(kMagenta);; root[] gGeoManager->SetTopVisible(); // the TOP is invisible; root[] top->Draw();; ~~~. \anchor GP00b; ### Example 2: A Geometrical Hierarchy Look and Feel. Before going further, let us get a look and feel of interacting with the; modeller. For this, we will use one of the examples illustrating the; geometry package. To get an idea on the geometry structure created in; this example, just look at rootgeom.C. You will; notice that this is a bit more complex that just creating the ""world""; since several other volumes are created and put together in a hierarchy.; The purpose here is just to learn how to interact with a geometry that; is already built, but just few hints on the building steps in this; example might be useful. The geometry here represents the word %ROOT that; is replicated in some symmetric manner. You might for instance ask some; questions after having a first look:. **Q:** ""OK",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:6844,simpl,simple,6844,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['simpl'],['simple']
Usability,"ad as an enumeration. For example, say some configuration option; started as an enumeration. Then it got more complex so it is now a; mapping. But it is necessary to support the old configuration files.; In that case, add a function ``enumInput`` like for; ``ScalarEnumerationTraits::enumeration``. Examples:. .. code-block:: c++. struct FooBarEnum {; int Foo;; int Bar;; bool operator==(const FooBarEnum &R) const {; return Foo == R.Foo && Bar == R.Bar;; }; };. template <> struct MappingTraits<FooBarEnum> {; static void enumInput(IO &io, FooBarEnum &Val) {; io.enumCase(Val, ""OnlyFoo"", FooBarEnum({1, 0}));; io.enumCase(Val, ""OnlyBar"", FooBarEnum({0, 1}));; }; static void mapping(IO &io, FooBarEnum &Val) {; io.mapOptional(""Foo"", Val.Foo);; io.mapOptional(""Bar"", Val.Bar);; }; };. No Normalization; ----------------. The ``mapping()`` method is responsible, if needed, for normalizing and; denormalizing. In a simple case where the native data structure requires no; normalization, the mapping method just uses mapOptional() or mapRequired() to; bind the struct's fields to YAML key names. For example:. .. code-block:: c++. using llvm::yaml::MappingTraits;; using llvm::yaml::IO;. template <>; struct MappingTraits<Person> {; static void mapping(IO &io, Person &info) {; io.mapRequired(""name"", info.name);; io.mapOptional(""hat-size"", info.hatSize);; }; };. Normalization; ----------------. When [de]normalization is required, the mapping() method needs a way to access; normalized values as fields. To help with this, there is; a template MappingNormalization<> which you can then use to automatically; do the normalization and denormalization. The template is used to create; a local variable in your mapping() method which contains the normalized keys. Suppose you have native data type; Polar which specifies a position in polar coordinates (distance, angle):. .. code-block:: c++. struct Polar {; float distance;; float angle;; };. but you've decided the normalized YAML for should be in x,y ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/YamlIO.rst:16633,simpl,simple,16633,interpreter/llvm-project/llvm/docs/YamlIO.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/YamlIO.rst,1,['simpl'],['simple']
Usability,"ad. ### The TGraph::Fit Method. The signature for fitting a TGraph is exactly the same as for the **`TH1`**. Only some options apply only for fitting histograms,; these are the options ""`L`"", ""`WL`"" and ""`I`"".; These options apply instead only for `TGraph::Fit`, the rest of options (appart from ""`L`"", ""`WL`"" and ""`I`"" are the same). * `TGraph` specific *options*. 	- ""`EX0`"" When fitting a `TGraphErrors` or a `TgraphAsymErrors` the errors on the coordinates are not used in the fit. 	- ""`ROB`"" in case of linear fitting use the Robust fitting. Compute the LTS regression coefficients (robust (resistant) regression),; using the default fraction of good points.; 	- ""`ROB=0.x`"" as above, but compute the LTS regression coefficients, using 0.x as a fraction of good points. ## The `TF1` function class. Here we will show how to create the **`TF1`** class that is used for fitting histograms and graphs. ### Fit with a Predefined Function. To fit a histogram with a predefined function, simply pass the name of; the function in the first parameter of `TH1::Fit`. For example,; this line fits histogram object `hist` with a Gaussian. ``` {.cpp}; root[] hist.Fit(""gaus"");; ```. The initial parameter values (and eventual limits) for pre-defined functions are set; automatically. For overriding the default limits values use the fit option `B`. The list of pre-defined functions that can be used with the `Fit` method is the following:. - ""`gaus`"" Gaussian function with 3 parameters:; `f(x) = p0*exp(-0.5*((x-p1)/p2)^2)`. - ""`expo`""An Exponential with 2 parameters: `f(x) = exp(p0+p1*x)`. - ""`pol`*`N`*"" A polynomial of degree *N*, where N is a number between 0 and 9:; `f(x) = p0 + p1*x + p2*x2 +...`. - ""`chebyshev`*`N`*"" A Chebyshev polynomial of degree *N*, where N is a number between 0 and 9:; `f(x) = p0 + p1*x + p2*(2*x2-1) +...`. - ""`landau`"" Landau function with mean and sigma. This function has; been adapted from the `CERNLIB` routine `G110 denlan` (see `TMath::Landau`). - ""`gausn`"" Normal",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:4437,simpl,simply,4437,documentation/users-guide/FittingHistograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md,1,['simpl'],['simply']
Usability,"adata i32 %c, ...); %d = trunc i32 %c to i16; ret i16 %d; }. Now, here's what happens after the unnecessary truncation instruction ``%d`` is; replaced with a simplified instruction:. .. code-block:: llvm. define i16 @foo(i16 %a) {; call void @llvm.dbg.value(metadata i32 undef, ...); %simplified = and i16 %a, 15; ret i16 %simplified; }. Note that after deleting ``%d``, all uses of its operand ``%c`` become; trivially dead. The debug use which used to point to ``%c`` is now ``undef``,; and debug info is needlessly lost. To solve this problem, do:. .. code-block:: cpp. llvm::replaceAllDbgUsesWith(%c, theSimplifiedAndInstruction, ...). This results in better debug info because the debug use of ``%c`` is preserved:. .. code-block:: llvm. define i16 @foo(i16 %a) {; %simplified = and i16 %a, 15; call void @llvm.dbg.value(metadata i16 %simplified, ...); ret i16 %simplified; }. You may have noticed that ``%simplified`` is narrower than ``%c``: this is not; a problem, because ``llvm::replaceAllDbgUsesWith`` takes care of inserting the; necessary conversion operations into the DIExpressions of updated debug uses. Deleting a MIR-level MachineInstr; ---------------------------------. TODO. Rules for updating ``DIAssignID`` Attachments; =============================================. ``DIAssignID`` metadata attachments are used by Assignment Tracking, which is; currently an experimental debug mode. See :doc:`AssignmentTracking` for how to update them and for more info on; Assignment Tracking. How to automatically convert tests into debug info tests; ========================================================. .. _IRDebugify:. Mutation testing for IR-level transformations; ---------------------------------------------. An IR test case for a transformation can, in many cases, be automatically; mutated to test debug info handling within that transformation. This is a; simple way to test for proper debug info handling. The ``debugify`` utility pass; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``d",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToUpdateDebugInfo.rst:8561,simpl,simplified,8561,interpreter/llvm-project/llvm/docs/HowToUpdateDebugInfo.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToUpdateDebugInfo.rst,1,['simpl'],['simplified']
Usability,"add an explicit prefix for Clang to look in for a GCC toolchain with; the ``--gcc-toolchain=/opt/my/gcc/prefix`` flag, passing it to both compile and; link commands when using your just-built-Clang to bootstrap. .. _Getting Started with LLVM:. Getting Started with LLVM; =========================. The remainder of this guide is meant to get you up and running with LLVM and to; give you some basic information about the LLVM environment. The later sections of this guide describe the `general layout`_ of the LLVM; source tree, a `simple example`_ using the LLVM tool chain, and `links`_ to find; more information about LLVM or to get help via e-mail. Terminology and Notation; ------------------------. Throughout this manual, the following names are used to denote paths specific to; the local system and working environment. *These are not environment variables; you need to set but just strings used in the rest of this document below*. In; any of the examples below, simply replace each of these names with the; appropriate pathname on your local system. All these paths are absolute:. ``SRC_ROOT``. This is the top level directory of the LLVM source tree. ``OBJ_ROOT``. This is the top level directory of the LLVM object tree (i.e. the tree where; object files and compiled programs will be placed. It can be the same as; SRC_ROOT). Unpacking the LLVM Archives; ---------------------------. If you have the LLVM distribution, you will need to unpack it before you can; begin to compile it. LLVM is distributed as a number of different; subprojects. Each one has its own download which is a TAR archive that is; compressed with the gzip program. The files are as follows, with *x.y* marking the version number:. ``llvm-x.y.tar.gz``. Source release for the LLVM libraries and tools. ``cfe-x.y.tar.gz``. Source release for the Clang frontend. .. _checkout:. Checkout LLVM from Git; ----------------------. You can also checkout the source code for LLVM from Git. .. note::. Passing ``--config core",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst:20871,simpl,simply,20871,interpreter/llvm-project/llvm/docs/GettingStarted.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst,1,['simpl'],['simply']
Usability,"add i32 %w, %w ; undef; %z = add i32 %x, %x ; even number because all uses of %x observe; ; the same value; %x2 = freeze i32 %w; %cmp = icmp eq i32 %x, %x2 ; can be true or false. ; example with vectors; %v = <2 x i32> <i32 undef, i32 poison>; %a = extractelement <2 x i32> %v, i32 0 ; undef; %b = extractelement <2 x i32> %v, i32 1 ; poison; %add = add i32 %a, %a ; undef. %v.fr = freeze <2 x i32> %v ; element-wise freeze; %d = extractelement <2 x i32> %v.fr, i32 0 ; not undef; %add.f = add i32 %d, %d ; even number. ; branching on frozen value; %poison = add nsw i1 %k, undef ; poison; %c = freeze i1 %poison; br i1 %c, label %foo, label %bar ; non-deterministic branch to %foo or %bar. .. _i_call:. '``call``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = [tail | musttail | notail ] call [fast-math flags] [cconv] [ret attrs] [addrspace(<num>)]; <ty>|<fnty> <fnptrval>(<function args>) [fn attrs] [ operand bundles ]. Overview:; """""""""""""""""". The '``call``' instruction represents a simple function call. Arguments:; """""""""""""""""""". This instruction requires several arguments:. #. The optional ``tail`` and ``musttail`` markers indicate that the optimizers; should perform tail call optimization. The ``tail`` marker is a hint that; `can be ignored <CodeGenerator.html#tail-call-optimization>`_. The; ``musttail`` marker means that the call must be tail call optimized in order; for the program to be correct. This is true even in the presence of; attributes like ""disable-tail-calls"". The ``musttail`` marker provides these; guarantees:. #. The call will not cause unbounded stack growth if it is part of a; recursive cycle in the call graph.; #. Arguments with the :ref:`inalloca <attr_inalloca>` or; :ref:`preallocated <attr_preallocated>` attribute are forwarded in place.; #. If the musttail call appears in a function with the ``""thunk""`` attribute; and the caller and callee both have varargs, then any unprototyped; arguments in register or memory are forwarded to the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:472458,simpl,simple,472458,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['simpl'],['simple']
Usability,"add two lines to transfer the newly defined function to; the JIT and open a new module. In HandleExtern, we just need to add one line to; add the prototype to FunctionProtos. .. warning::; Duplication of symbols in separate modules is not allowed since LLVM-9. That means you can not redefine function in your Kaleidoscope as its shown below. Just skip this part. The reason is that the newer OrcV2 JIT APIs are trying to stay very close to the static and dynamic linker rules, including rejecting duplicate symbols. Requiring symbol names to be unique allows us to support concurrent compilation for symbols using the (unique) symbol names as keys for tracking. With these changes made, let's try our REPL again (I removed the dump of the; anonymous functions this time, you should get the idea by now :) :. ::. ready> def foo(x) x + 1;; ready> foo(2);; Evaluated to 3.000000. ready> def foo(x) x + 2;; ready> foo(2);; Evaluated to 4.000000. It works!. Even with this simple code, we get some surprisingly powerful capabilities -; check this out:. ::. ready> extern sin(x);; Read extern:; declare double @sin(double). ready> extern cos(x);; Read extern:; declare double @cos(double). ready> sin(1.0);; Read top-level expression:; define double @2() {; entry:; ret double 0x3FEAED548F090CEE; }. Evaluated to 0.841471. ready> def foo(x) sin(x)*sin(x) + cos(x)*cos(x);; Read function definition:; define double @foo(double %x) {; entry:; %calltmp = call double @sin(double %x); %multmp = fmul double %calltmp, %calltmp; %calltmp2 = call double @cos(double %x); %multmp4 = fmul double %calltmp2, %calltmp2; %addtmp = fadd double %multmp, %multmp4; ret double %addtmp; }. ready> foo(4.0);; Read top-level expression:; define double @3() {; entry:; %calltmp = call double @foo(double 4.000000e+00); ret double %calltmp; }. Evaluated to 1.000000. Whoa, how does the JIT know about sin and cos? The answer is surprisingly; simple: The KaleidoscopeJIT has a straightforward symbol resolution rule that; it use",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl04.rst:21695,simpl,simple,21695,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl04.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl04.rst,1,['simpl'],['simple']
Usability,"add_clang_library(clangAnalysisFlowSensitive; Arena.cpp; ControlFlowContext.cpp; DataflowAnalysisContext.cpp; DataflowEnvironment.cpp; Formula.cpp; HTMLLogger.cpp; Logger.cpp; RecordOps.cpp; SimplifyConstraints.cpp; Transfer.cpp; TypeErasedDataflowAnalysis.cpp; Value.cpp; WatchedLiteralsSolver.cpp; DebugSupport.cpp. DEPENDS; clangAnalysisFlowSensitiveResources; LINK_LIBS; clangAnalysis; clangAST; clangASTMatchers; clangBasic; clangLex; ). add_subdirectory(Models). add_custom_command(OUTPUT HTMLLogger.inc; COMMAND ""${Python3_EXECUTABLE}"" ${CLANG_SOURCE_DIR}/utils/bundle_resources.py; ${CMAKE_CURRENT_BINARY_DIR}/HTMLLogger.inc; HTMLLogger.html HTMLLogger.css HTMLLogger.js; WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}; COMMENT ""Bundling HTMLLogger resources""; DEPENDS ${CLANG_SOURCE_DIR}/utils/bundle_resources.py HTMLLogger.html HTMLLogger.css HTMLLogger.js; VERBATIM); add_custom_target(clangAnalysisFlowSensitiveResources DEPENDS HTMLLogger.inc); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/CMakeLists.txt:191,Simpl,SimplifyConstraints,191,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/CMakeLists.txt,1,['Simpl'],['SimplifyConstraints']
Usability,add_llvm_component_library(LLVMDebugInfoCodeView; AppendingTypeTableBuilder.cpp; CodeViewError.cpp; CodeViewRecordIO.cpp; ContinuationRecordBuilder.cpp; CVSymbolVisitor.cpp; CVTypeVisitor.cpp; DebugChecksumsSubsection.cpp; DebugCrossExSubsection.cpp; DebugCrossImpSubsection.cpp; DebugFrameDataSubsection.cpp; DebugInlineeLinesSubsection.cpp; DebugLinesSubsection.cpp; DebugStringTableSubsection.cpp; DebugSubsection.cpp; DebugSubsectionRecord.cpp; DebugSubsectionVisitor.cpp; DebugSymbolRVASubsection.cpp; DebugSymbolsSubsection.cpp; EnumTables.cpp; Formatters.cpp; GlobalTypeTableBuilder.cpp; LazyRandomTypeCollection.cpp; Line.cpp; MergingTypeTableBuilder.cpp; RecordName.cpp; RecordSerialization.cpp; SimpleTypeSerializer.cpp; StringsAndChecksums.cpp; SymbolDumper.cpp; SymbolRecordHelpers.cpp; SymbolRecordMapping.cpp; SymbolSerializer.cpp; TypeDumpVisitor.cpp; TypeIndex.cpp; TypeIndexDiscovery.cpp; TypeHashing.cpp; TypeRecordHelpers.cpp; TypeRecordMapping.cpp; TypeStreamMerger.cpp; TypeTableCollection.cpp. ADDITIONAL_HEADER_DIRS; ${LLVM_MAIN_INCLUDE_DIR}/llvm/DebugInfo/CodeView. LINK_COMPONENTS; Support; ); ,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/CodeView/CMakeLists.txt:705,Simpl,SimpleTypeSerializer,705,interpreter/llvm-project/llvm/lib/DebugInfo/CodeView/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/CodeView/CMakeLists.txt,1,['Simpl'],['SimpleTypeSerializer']
Usability,add_llvm_component_library(LLVMOrcShared; AllocationActions.cpp; ObjectFormats.cpp; OrcError.cpp; OrcRTBridge.cpp; SimpleRemoteEPCUtils.cpp; ADDITIONAL_HEADER_DIRS; ${LLVM_MAIN_INCLUDE_DIR}/llvm/ExecutionEngine/Orc. DEPENDS; intrinsics_gen. LINK_LIBS; ${LLVM_PTHREAD_LIB}. LINK_COMPONENTS; Support; ); ,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Shared/CMakeLists.txt:115,Simpl,SimpleRemoteEPCUtils,115,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Shared/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Shared/CMakeLists.txt,1,['Simpl'],['SimpleRemoteEPCUtils']
Usability,add_llvm_component_library(LLVMScalarOpts; ADCE.cpp; AlignmentFromAssumptions.cpp; AnnotationRemarks.cpp; BDCE.cpp; CallSiteSplitting.cpp; ConstantHoisting.cpp; ConstraintElimination.cpp; CorrelatedValuePropagation.cpp; DCE.cpp; DeadStoreElimination.cpp; DFAJumpThreading.cpp; DivRemPairs.cpp; EarlyCSE.cpp; FlattenCFGPass.cpp; Float2Int.cpp; GuardWidening.cpp; GVN.cpp; GVNHoist.cpp; GVNSink.cpp; IVUsersPrinter.cpp; InductiveRangeCheckElimination.cpp; IndVarSimplify.cpp; InferAddressSpaces.cpp; InferAlignment.cpp; InstSimplifyPass.cpp; JumpThreading.cpp; LICM.cpp; LoopAccessAnalysisPrinter.cpp; LoopBoundSplit.cpp; LoopSink.cpp; LoopDeletion.cpp; LoopDataPrefetch.cpp; LoopDistribute.cpp; LoopFuse.cpp; LoopIdiomRecognize.cpp; LoopInstSimplify.cpp; LoopInterchange.cpp; LoopFlatten.cpp; LoopLoadElimination.cpp; LoopPassManager.cpp; LoopPredication.cpp; LoopRerollPass.cpp; LoopRotation.cpp; LoopSimplifyCFG.cpp; LoopStrengthReduce.cpp; LoopUnrollPass.cpp; LoopUnrollAndJamPass.cpp; LoopVersioningLICM.cpp; LowerAtomicPass.cpp; LowerConstantIntrinsics.cpp; LowerExpectIntrinsic.cpp; LowerGuardIntrinsic.cpp; LowerMatrixIntrinsics.cpp; LowerWidenableCondition.cpp; MakeGuardsExplicit.cpp; MemCpyOptimizer.cpp; MergeICmps.cpp; MergedLoadStoreMotion.cpp; NaryReassociate.cpp; NewGVN.cpp; PartiallyInlineLibCalls.cpp; PlaceSafepoints.cpp; Reassociate.cpp; Reg2Mem.cpp; RewriteStatepointsForGC.cpp; SCCP.cpp; SROA.cpp; Scalar.cpp; Scalarizer.cpp; ScalarizeMaskedMemIntrin.cpp; SeparateConstOffsetFromGEP.cpp; SimpleLoopUnswitch.cpp; SimplifyCFGPass.cpp; Sink.cpp; SpeculativeExecution.cpp; StraightLineStrengthReduce.cpp; StructurizeCFG.cpp; TailRecursionElimination.cpp; TLSVariableHoist.cpp; WarnMissedTransforms.cpp. ADDITIONAL_HEADER_DIRS; ${LLVM_MAIN_INCLUDE_DIR}/llvm/Transforms; ${LLVM_MAIN_INCLUDE_DIR}/llvm/Transforms/Scalar. DEPENDS; intrinsics_gen. COMPONENT_NAME; Scalar. LINK_COMPONENTS; AggressiveInstCombine; Analysis; Core; InstCombine; Support; TransformUtils; ); ,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CMakeLists.txt:1509,Simpl,SimpleLoopUnswitch,1509,interpreter/llvm-project/llvm/lib/Transforms/Scalar/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CMakeLists.txt,2,['Simpl'],"['SimpleLoopUnswitch', 'SimplifyCFGPass']"
Usability,add_llvm_component_library(LLVMTransformUtils; AddDiscriminators.cpp; AMDGPUEmitPrintf.cpp; ASanStackFrameLayout.cpp; AssumeBundleBuilder.cpp; BasicBlockUtils.cpp; BreakCriticalEdges.cpp; BuildLibCalls.cpp; BypassSlowDivision.cpp; CallPromotionUtils.cpp; CallGraphUpdater.cpp; CanonicalizeAliases.cpp; CanonicalizeFreezeInLoops.cpp; CloneFunction.cpp; CloneModule.cpp; CodeExtractor.cpp; CodeLayout.cpp; CodeMoverUtils.cpp; CtorUtils.cpp; CountVisits.cpp; Debugify.cpp; DemoteRegToStack.cpp; DXILUpgrade.cpp; EntryExitInstrumenter.cpp; EscapeEnumerator.cpp; Evaluator.cpp; FixIrreducible.cpp; FlattenCFG.cpp; FunctionComparator.cpp; FunctionImportUtils.cpp; GlobalStatus.cpp; GuardUtils.cpp; HelloWorld.cpp; InlineFunction.cpp; InjectTLIMappings.cpp; InstructionNamer.cpp; IntegerDivision.cpp; LCSSA.cpp; LibCallsShrinkWrap.cpp; Local.cpp; LoopConstrainer.cpp; LoopPeel.cpp; LoopRotationUtils.cpp; LoopSimplify.cpp; LoopUnroll.cpp; LoopUnrollAndJam.cpp; LoopUnrollRuntime.cpp; LoopUtils.cpp; LoopVersioning.cpp; LowerAtomic.cpp; LowerGlobalDtors.cpp; LowerIFunc.cpp; LowerInvoke.cpp; LowerMemIntrinsics.cpp; LowerSwitch.cpp; MatrixUtils.cpp; MemoryOpRemark.cpp; MemoryTaggingSupport.cpp; Mem2Reg.cpp; MetaRenamer.cpp; MisExpect.cpp; ModuleUtils.cpp; MoveAutoInit.cpp; NameAnonGlobals.cpp; PredicateInfo.cpp; PromoteMemoryToRegister.cpp; RelLookupTableConverter.cpp; ScalarEvolutionExpander.cpp; SCCPSolver.cpp; StripGCRelocates.cpp; SSAUpdater.cpp; SSAUpdaterBulk.cpp; SampleProfileInference.cpp; SampleProfileLoaderBaseUtil.cpp; SanitizerStats.cpp; SimplifyCFG.cpp; SimplifyIndVar.cpp; SimplifyLibCalls.cpp; SizeOpts.cpp; SplitModule.cpp; StripNonLineTableDebugInfo.cpp; SymbolRewriter.cpp; UnifyFunctionExitNodes.cpp; UnifyLoopExits.cpp; Utils.cpp; ValueMapper.cpp; VNCoercion.cpp. ADDITIONAL_HEADER_DIRS; ${LLVM_MAIN_INCLUDE_DIR}/llvm/Transforms; ${LLVM_MAIN_INCLUDE_DIR}/llvm/Transforms/Utils. DEPENDS; intrinsics_gen. LINK_COMPONENTS; Analysis; Core; Support; TargetParser; ); ,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CMakeLists.txt:1550,Simpl,SimplifyCFG,1550,interpreter/llvm-project/llvm/lib/Transforms/Utils/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CMakeLists.txt,3,['Simpl'],"['SimplifyCFG', 'SimplifyIndVar', 'SimplifyLibCalls']"
Usability,"address of outgoing stack arguments. An ``inalloca`` argument must; be a pointer to stack memory produced by an ``alloca`` instruction.; The alloca, or argument allocation, must also be tagged with the; inalloca keyword. Only the last argument may have the ``inalloca``; attribute, and that argument is guaranteed to be passed in memory. An argument allocation may be used by a call at most once because; the call may deallocate it. The ``inalloca`` attribute cannot be; used in conjunction with other attributes that affect argument; storage, like ``inreg``, ``nest``, ``sret``, or ``byval``. The; ``inalloca`` attribute also disables LLVM's implicit lowering of; large aggregate return values, which means that frontend authors; must lower them with ``sret`` pointers. When the call site is reached, the argument allocation must have; been the most recent stack allocation that is still live, or the; behavior is undefined. It is possible to allocate additional stack; space after an argument allocation and before its call site, but it; must be cleared off with :ref:`llvm.stackrestore; <int_stackrestore>`. The inalloca attribute requires a type argument, which must be the; same as the pointee type of the argument. See :doc:`InAlloca` for more information on how to use this; attribute. ``sret(<ty>)``; This indicates that the pointer parameter specifies the address of a; structure that is the return value of the function in the source; program. This pointer must be guaranteed by the caller to be valid:; loads and stores to the structure may be assumed by the callee not; to trap and to be properly aligned. This is not a valid attribute; for return values. The sret type argument specifies the in memory type, which must be; the same as the pointee type of the argument. .. _attr_elementtype:. ``elementtype(<ty>)``. The ``elementtype`` argument attribute can be used to specify a pointer; element type in a way that is compatible with `opaque pointers; <OpaquePointers.html>`__. The ``elem",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:55639,clear,cleared,55639,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['clear'],['cleared']
Usability,"ady know how to compile the code in question for the host architecture,; and that you know how to choose additional include and library paths. However, this document is *not* a ""how to"" and won't help you setting your; build system or Makefiles, nor choosing the right CMake options, etc.; Also, it does not cover all the possible options, nor does it contain; specific examples for specific architectures. For a concrete example, the; `instructions for cross-compiling LLVM itself; <https://llvm.org/docs/HowToCrossCompileLLVM.html>`_ may be of interest. After reading this document, you should be familiar with the main issues; related to cross-compilation, and what main compiler options Clang provides; for performing cross-compilation. Cross compilation issues; ========================. In GCC world, every host/target combination has its own set of binaries,; headers, libraries, etc. So, it's usually simple to download a package; with all files in, unzip to a directory and point the build system to; that compiler, that will know about its location and find all it needs to; when compiling your code. On the other hand, Clang/LLVM is natively a cross-compiler, meaning that; one set of programs can compile to all targets by setting the ``-target``; option. That makes it a lot easier for programmers wishing to compile to; different platforms and architectures, and for compiler developers that; only have to maintain one build system, and for OS distributions, that; need only one set of main packages. But, as is true to any cross-compiler, and given the complexity of; different architectures, OS's and options, it's not always easy finding; the headers, libraries or binutils to generate target specific code.; So you'll need special options to help Clang understand what target; you're compiling to, where your tools are, etc. Another problem is that compilers come with standard libraries only (like; ``compiler-rt``, ``libcxx``, ``libgcc``, ``libm``, etc), so you'll have to; find an",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CrossCompilation.rst:1251,simpl,simple,1251,interpreter/llvm-project/clang/docs/CrossCompilation.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CrossCompilation.rst,1,['simpl'],['simple']
Usability,"afe points; the collector could move the objects and invalidate the; derived pointer. This is bad enough in the first place, but safe points can; crop up unpredictably. Consider:. %array = load { i32, [0 x %obj] }** %array_addr; %nth_el = getelementptr { i32, [0 x %obj] }* %array, i32 0, i32 %n; %old = load %obj** %nth_el; %z = div i64 %x, %y; store %obj* %new, %obj** %nth_el. If the i64 division is lowered to a libcall, then a safe point will (must); appear for the call site. If a collection occurs, %array and %nth_el no longer; point into the correct object. The fix for this is to copy address calculations so that dependent pointers; are never live across safe point boundaries. But the loads cannot be copied; like this if there was an intervening store, so may be hard to get right. Only a concurrent mutator can trigger a collection at the libcall safe point.; So single-threaded programs do not have this requirement, even with a copying; collector. Still, LLVM optimizations would probably undo a front-end's careful; work. //===---------------------------------------------------------------------===//. The ocaml frametable structure supports liveness information. It would be good; to support it. //===---------------------------------------------------------------------===//. The FIXME in ComputeCommonTailLength in BranchFolding.cpp needs to be; revisited. The check is there to work around a misuse of directives in inline; assembly. //===---------------------------------------------------------------------===//. It would be good to detect collector/target compatibility instead of silently; doing the wrong thing. //===---------------------------------------------------------------------===//. It would be really nice to be able to write patterns in .td files for copies,; which would eliminate a bunch of explicit predicates on them (e.g. no side; effects). Once this is in place, it would be even better to have tblgen; synthesize the various copy insertion/inspection meth",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/README.txt:3802,undo,undo,3802,interpreter/llvm-project/llvm/lib/CodeGen/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/README.txt,1,['undo'],['undo']
Usability,"age collection run, the checker sees if the marked symbol is; being collected and issues the 'SYMBOL DEAD' warning if it does.; This way you know where exactly, up to the line of code, the symbol dies. It is unlikely that you call this function after the symbol is already dead,; because the very reference to it as the function argument prevents it from; dying. However, if the argument is not a symbol but a concrete value,; no warning would be issued. Example usage::. do {; int x = generate_some_integer();; clang_analyzer_warnOnDeadSymbol(x);; } while(0); // expected-warning{{SYMBOL DEAD}}. - ``void clang_analyzer_explain(a single argument of any type);``. This function explains the value of its argument in a human-readable manner; in the warning message. You can make as many overrides of its prototype; in the test code as necessary to explain various integral, pointer,; or even record-type values. To simplify usage in C code (where overloading; the function declaration is not allowed), you may append an arbitrary suffix; to the function name, without affecting functionality. Example usage::. void clang_analyzer_explain(int);; void clang_analyzer_explain(void *);. // Useful in C code; void clang_analyzer_explain_int(int);. void foo(int param, void *ptr) {; clang_analyzer_explain(param); // expected-warning{{argument 'param'}}; clang_analyzer_explain_int(param); // expected-warning{{argument 'param'}}; if (!ptr); clang_analyzer_explain(ptr); // expected-warning{{memory address '0'}}; }. - ``void clang_analyzer_dump( /* a single argument of any type */);``. Similar to clang_analyzer_explain, but produces a raw dump of the value,; same as SVal::dump(). Example usage::. void clang_analyzer_dump(int);; void foo(int x) {; clang_analyzer_dump(x); // expected-warning{{reg_$0<x>}}; }. - ``size_t clang_analyzer_getExtent(void *);``. This function returns the value that represents the extent of a memory region; pointed to by the argument. This value is often difficult to obtain ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst:6701,simpl,simplify,6701,interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst,1,['simpl'],['simplify']
Usability,age/second-tool.h; openmp/tools/multiplex/tests/print/first-tool.h; openmp/tools/multiplex/tests/print/second-tool.h; polly/include/polly/Canonicalization.h; polly/include/polly/CodePreparation.h; polly/include/polly/DeadCodeElimination.h; polly/include/polly/DeLICM.h; polly/include/polly/DependenceInfo.h; polly/include/polly/FlattenAlgo.h; polly/include/polly/FlattenSchedule.h; polly/include/polly/ForwardOpTree.h; polly/include/polly/JSONExporter.h; polly/include/polly/LinkAllPasses.h; polly/include/polly/ManualOptimizer.h; polly/include/polly/MatmulOptimizer.h; polly/include/polly/Options.h; polly/include/polly/PolyhedralInfo.h; polly/include/polly/PruneUnprofitable.h; polly/include/polly/RegisterPasses.h; polly/include/polly/ScheduleOptimizer.h; polly/include/polly/ScheduleTreeTransform.h; polly/include/polly/ScopBuilder.h; polly/include/polly/ScopDetection.h; polly/include/polly/ScopDetectionDiagnostic.h; polly/include/polly/ScopInfo.h; polly/include/polly/ScopPass.h; polly/include/polly/Simplify.h; polly/include/polly/ZoneAlgo.h; polly/include/polly/CodeGen/BlockGenerators.h; polly/include/polly/CodeGen/CodegenCleanup.h; polly/include/polly/CodeGen/CodeGeneration.h; polly/include/polly/CodeGen/IRBuilder.h; polly/include/polly/CodeGen/IslAst.h; polly/include/polly/CodeGen/IslExprBuilder.h; polly/include/polly/CodeGen/IslNodeBuilder.h; polly/include/polly/CodeGen/LoopGenerators.h; polly/include/polly/CodeGen/LoopGeneratorsGOMP.h; polly/include/polly/CodeGen/LoopGeneratorsKMP.h; polly/include/polly/CodeGen/PerfMonitor.h; polly/include/polly/CodeGen/PPCGCodeGeneration.h; polly/include/polly/CodeGen/RuntimeDebugBuilder.h; polly/include/polly/CodeGen/Utils.h; polly/include/polly/Support/DumpFunctionPass.h; polly/include/polly/Support/DumpModulePass.h; polly/include/polly/Support/GICHelper.h; polly/include/polly/Support/ISLOperators.h; polly/include/polly/Support/ISLOStream.h; polly/include/polly/Support/ISLTools.h; polly/include/polly/Support/LinkGPURuntime.h; polly/,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt:412481,Simpl,Simplify,412481,interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,1,['Simpl'],['Simplify']
Usability,"ains>` laid out elsewhere in this document. .. _arc.misc.special_methods.dealloc:. ``dealloc``; ^^^^^^^^^^^. A program is ill-formed if it contains a message send or ``@selector``; expression for the selector ``dealloc``. .. admonition:: Rationale. There are no legitimate reasons to call ``dealloc`` directly. A class may provide a method definition for an instance method named; ``dealloc``. This method will be called after the final ``release`` of the; object but before it is deallocated or any of its instance variables are; destroyed. The superclass's implementation of ``dealloc`` will be called; automatically when the method returns. .. admonition:: Rationale. Even though ARC destroys instance variables automatically, there are still; legitimate reasons to write a ``dealloc`` method, such as freeing; non-retainable resources. Failing to call ``[super dealloc]`` in such a; method is nearly always a bug. Sometimes, the object is simply trying to; prevent itself from being destroyed, but ``dealloc`` is really far too late; for the object to be raising such objections. Somewhat more legitimately, an; object may have been pool-allocated and should not be deallocated with; ``free``; for now, this can only be supported with a ``dealloc``; implementation outside of ARC. Such an implementation must be very careful; to do all the other work that ``NSObject``'s ``dealloc`` would, which is; outside the scope of this document to describe. The instance variables for an ARC-compiled class will be destroyed at some; point after control enters the ``dealloc`` method for the root class of the; class. The ordering of the destruction of instance variables is unspecified,; both within a single class and between subclasses and superclasses. .. admonition:: Rationale. The traditional, non-ARC pattern for destroying instance variables is to; destroy them immediately before calling ``[super dealloc]``. Unfortunately,; message sends from the superclass are quite capable of reaching methods",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:88213,simpl,simply,88213,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['simpl'],['simply']
Usability,"airly simple and there is little code reuse opportunity anyway. .. _implementation-details:. Implementation Details; ======================. The current implementation of DDG differs slightly from the dependence; graph described in [1]_ in the following ways:. 1. The graph nodes in the paper represent three main program components, namely *assignment statements*, *for loop headers* and *while loop headers*. In this implementation, DDG nodes naturally represent LLVM IR instructions. An assignment statement in this implementation typically involves a node representing the ``store`` instruction along with a number of individual nodes computing the right-hand-side of the assignment that connect to the ``store`` node via a def-use edge. The loop header instructions are not represented as special nodes in this implementation because they have limited uses and can be easily identified, for example, through ``LoopAnalysis``.; 2. The paper describes five types of dependency edges between nodes namely *loop dependency*, *flow-*, *anti-*, *output-*, and *input-* dependencies. In this implementation *memory* edges represent the *flow-*, *anti-*, *output-*, and *input-* dependencies. However, *loop dependencies* are not made explicit, because they mainly represent association between a loop structure and the program elements inside the loop and this association is fairly obvious in LLVM IR itself.; 3. The paper describes two types of pi-blocks; *recurrences* whose bodies are SCCs and *IN* nodes whose bodies are not part of any SCC. In this implementation, pi-blocks are only created for *recurrences*. *IN* nodes remain as simple DDG nodes in the graph. References; ----------; .. [1] ""D. J. Kuck, R. H. Kuhn, D. A. Padua, B. Leasure, and M. Wolfe (1981). DEPENDENCE GRAPHS AND COMPILER OPTIMIZATIONS.""; .. [2] ""J. FERRANTE (IBM), K. J. OTTENSTEIN (Michigan Technological University) and JOE D. WARREN (Rice University), 1987. The Program Dependence Graph and Its Use in Optimization.""; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DependenceGraphs/index.rst:6346,simpl,simple,6346,interpreter/llvm-project/llvm/docs/DependenceGraphs/index.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DependenceGraphs/index.rst,1,['simpl'],['simple']
Usability,"aive mathematical formulas for complex; multiplication and enables application of Smith's algorithm for complex; division. See SMITH, R. L. Algorithm 116: Complex division. Commun.; ACM 5, 8 (1962). The default is ``-fno-cx-fortran-rules``. .. _floating-point-environment:. Accessing the floating point environment; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; Many targets allow floating point operations to be configured to control things; such as how inexact results should be rounded and how exceptional conditions; should be handled. This configuration is called the floating point environment.; C and C++ restrict access to the floating point environment by default, and the; compiler is allowed to assume that all operations are performed in the default; environment. When code is compiled in this default mode, operations that depend; on the environment (such as floating-point arithmetic and `FLT_ROUNDS`) may have; undefined behavior if the dynamic environment is not the default environment; for; example, `FLT_ROUNDS` may or may not simply return its default value for the target; instead of reading the dynamic environment, and floating-point operations may be; optimized as if the dynamic environment were the default. Similarly, it is undefined; behavior to change the floating point environment in this default mode, for example; by calling the `fesetround` function.; C provides two pragmas to allow code to dynamically modify the floating point environment:. - ``#pragma STDC FENV_ACCESS ON`` allows dynamic changes to the entire floating; point environment. - ``#pragma STDC FENV_ROUND FE_DYNAMIC`` allows dynamic changes to just the floating; point rounding mode. This may be more optimizable than ``FENV_ACCESS ON`` because; the compiler can still ignore the possibility of floating-point exceptions by default. Both of these can be used either at the start of a block scope, in which case; they cover all code in that scope (unless they're turned off in a child scope),; or at the ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:69727,simpl,simply,69727,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['simpl'],['simply']
Usability,"ake sense to rename individually - it is expected that; this list will change following experimentation:. * TableGen; * llvm/tools; * clang-tools-extra; * clang; * ARM backend; * AArch64 backend; * AMDGPU backend; * ARC backend; * AVR backend; * BPF backend; * Hexagon backend; * Lanai backend; * MIPS backend; * NVPTX backend; * PowerPC backend; * RISC-V backend; * Sparc backend; * SystemZ backend; * WebAssembly backend; * X86 backend; * XCore backend; * libLTO; * Debug Information; * Remainder of llvm; * compiler-rt; * libunwind; * openmp; * parallel-libs; * polly; * lldb. #. Remove the old variable name rule from the policy page. #. Repeat many of the steps in the sequence, using a script to expand acronyms. References; ==========. .. [LLDB] LLDB Coding Conventions https://llvm.org/svn/llvm-project/lldb/branches/release_39/www/lldb-coding-conventions.html; .. [Google] Google C++ Style Guide https://google.github.io/styleguide/cppguide.html#Variable_Names; .. [WebKit] WebKit Code Style Guidelines https://webkit.org/code-style-guidelines/#names; .. [Qt] Qt Coding Style https://wiki.qt.io/Qt_Coding_Style#Declaring_variables; .. [Rust] Rust naming conventions https://doc.rust-lang.org/1.0.0/style/style/naming/README.html; .. [Swift] Swift API Design Guidelines https://swift.org/documentation/api-design-guidelines/#general-conventions; .. [Python] Style Guide for Python Code https://www.python.org/dev/peps/pep-0008/#function-and-variable-names; .. [Mozilla] Mozilla Coding style: Prefixes https://firefox-source-docs.mozilla.org/tools/lint/coding-style/coding_style_cpp.html#prefixes; .. [SVE] LLVM with support for SVE https://github.com/ARM-software/LLVM-SVE; .. [AminiInconsistent] Mehdi Amini, http://lists.llvm.org/pipermail/llvm-dev/2019-February/130329.html; .. [ArsenaultAgree] Matt Arsenault, http://lists.llvm.org/pipermail/llvm-dev/2019-February/129934.html; .. [BeylsDistinguish] Kristof Beyls, http://lists.llvm.org/pipermail/llvm-dev/2019-February/130292.html; .. [B",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst:13561,Guid,Guidelines,13561,interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst,1,['Guid'],['Guidelines']
Usability,"al, i32 %sel, 1; resume { ptr, i32 } %lpad.val29. The `CoroSpit` pass replaces `coro.end` with ``True`` in the resume functions,; thus leading to immediate unwind to the caller, whereas in start function it; is replaced with ``False``, thus allowing to proceed to the rest of the cleanup; code that is only needed during initial invocation of the coroutine. For Windows Exception handling model, a frontend should attach a funclet bundle; referring to an enclosing cleanuppad as follows:. .. code-block:: llvm. ehcleanup:; %tok = cleanuppad within none []; %unused = call i1 @llvm.coro.end(ptr null, i1 true, token none) [ ""funclet""(token %tok) ]; cleanupret from %tok unwind label %RestOfTheCleanup. The `CoroSplit` pass, if the funclet bundle is present, will insert; ``cleanupret from %tok unwind to caller`` before; the `coro.end`_ intrinsic and will remove the rest of the block. In the unwind path (when the argument is `true`), `coro.end` will mark the coroutine; as done, making it undefined behavior to resume the coroutine again and causing ; `llvm.coro.done` to return `true`. This is not necessary in the normal path because; the coroutine will already be marked as done by the final suspend. The following table summarizes the handling of `coro.end`_ intrinsic. +--------------------------+------------------------+---------------------------------+; | | In Start Function | In Resume/Destroy Functions |; +--------------------------+------------------------+---------------------------------+; |unwind=false | nothing |``ret void`` |; +------------+-------------+------------------------+---------------------------------+; | | WinEH | mark coroutine as done || ``cleanupret unwind to caller``|; | | | || mark coroutine done |; |unwind=true +-------------+------------------------+---------------------------------+; | | Landingpad | mark coroutine as done | mark coroutine done |; +------------+-------------+------------------------+---------------------------------+. .. _coro.end.re",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:46170,resume,resume,46170,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"al:. Chapter 1 Introduction; ======================. **Warning: This tutorial is currently being updated to account for ORC API; changes. Only Chapters 1 and 2 are up-to-date.**. **Example code from Chapters 3 to 5 will compile and run, but has not been; updated**. Welcome to Chapter 1 of the ""Building an ORC-based JIT in LLVM"" tutorial. This; tutorial runs through the implementation of a JIT compiler using LLVM's; On-Request-Compilation (ORC) APIs. It begins with a simplified version of the; KaleidoscopeJIT class used in the; `Implementing a language with LLVM <LangImpl01.html>`_ tutorials and then; introduces new features like concurrent compilation, optimization, lazy; compilation and remote execution. The goal of this tutorial is to introduce you to LLVM's ORC JIT APIs, show how; these APIs interact with other parts of LLVM, and to teach you how to recombine; them to build a custom JIT that is suited to your use-case. The structure of the tutorial is:. - Chapter #1: Investigate the simple KaleidoscopeJIT class. This will; introduce some of the basic concepts of the ORC JIT APIs, including the; idea of an ORC *Layer*. - `Chapter #2 <BuildingAJIT2.html>`_: Extend the basic KaleidoscopeJIT by adding; a new layer that will optimize IR and generated code. - `Chapter #3 <BuildingAJIT3.html>`_: Further extend the JIT by adding a; Compile-On-Demand layer to lazily compile IR. - `Chapter #4 <BuildingAJIT4.html>`_: Improve the laziness of our JIT by; replacing the Compile-On-Demand layer with a custom layer that uses the ORC; Compile Callbacks API directly to defer IR-generation until functions are; called. - `Chapter #5 <BuildingAJIT5.html>`_: Add process isolation by JITing code into; a remote process with reduced privileges using the JIT Remote APIs. To provide input for our JIT we will use a lightly modified version of the; Kaleidoscope REPL from `Chapter 7 <LangImpl07.html>`_ of the ""Implementing a; language in LLVM tutorial"". Finally, a word on API generations: ORC ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT1.rst:1185,simpl,simple,1185,interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT1.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT1.rst,1,['simpl'],['simple']
Usability,"alf by refactoring the code reading and writing the TBasket data;; A single transient buffer holding the compressed data is now managed by TTree (and could be made thread local); rather than having one per TBranch. Updated TBranchElement::Unroll to no longer split a base class; that can not be split (i.e. respect the information returned; by TStreamerElement::CannotSplit (and thus TClass::CanSplit). This disabling is currently _not_ done automatically for backward compatibility reasons and because; ; Without TClass::SetCanSplit there was no way to; force the splitting (short of setting the split level lower); Some classes still requires a custom streamer solely to; read older data files (for example for file written before; the advent of StreamerInfo) and are such not necessary to; be used when writting (and schema evolution rules can not; yet be used in this case). Allowed removing branches when cloning a TNtuple. Added an option value (""cachedbranches"") to the Print() function of TTreeCache to be able to print the list of cached branches. Made the ownership of the TBranch by fBranch clearer (and thus allow the 'reuse' of TTree object without memory leak). Introduced GetLeaf(branchname,leafname) used in TTreeFormula to avoid ambiguity in the syntax introduced by too many slashes. Improved performance of TTree::GetEntry. With this changes the 'overhead'; compare to protobuf goes from 48% to 24%. (This does not include the; cost of the file opening which can be comparatively large for small; files. For the example used in the comparison the cost TFile::Open is 8% of the cost; of 100000 calls to TTree::GetEntry). Prevented the use of non-existent memory when reading in an object that is part of an STL collection and which used; to contains an embedded object (and this data member has been removed). Now properly recognize a TClonesArray data member even if the requested type was a typedef (to TClonesArray) that is in a namespace (for example edm::Event::ContaierType). ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/doc/v532/index.html:3436,clear,clearer,3436,tree/doc/v532/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/doc/v532/index.html,1,['clear'],['clearer']
Usability,"align 16; %1 = getelementptr [8 x i64]* %input, i64 0, i64 2; store i64 1, i64* %1, align 16; %2 = getelementptr [8 x i64]* %input, i64 0, i64 4; store i64 1, i64* %2, align 16; %3 = getelementptr [8 x i64]* %input, i64 0, i64 6; store i64 1, i64* %3, align 16. Which gets codegen'd into:. 	pxor	%xmm0, %xmm0; 	movaps	%xmm0, -16(%rbp); 	movaps	%xmm0, -32(%rbp); 	movaps	%xmm0, -48(%rbp); 	movaps	%xmm0, -64(%rbp); 	movq	$1, -64(%rbp); 	movq	$1, -48(%rbp); 	movq	$1, -32(%rbp); 	movq	$1, -16(%rbp). It would be better to have 4 movq's of 0 instead of the movaps's. //===---------------------------------------------------------------------===//. http://llvm.org/PR717:. The following code should compile into ""ret int undef"". Instead, LLVM; produces ""ret int 0"":. int f() {; int x = 4;; int y;; if (x == 3) y = 0;; return y;; }. //===---------------------------------------------------------------------===//. The loop unroller should partially unroll loops (instead of peeling them); when code growth isn't too bad and when an unroll count allows simplification; of some code within the loop. One trivial example is:. #include <stdio.h>; int main() {; int nRet = 17;; int nLoop;; for ( nLoop = 0; nLoop < 1000; nLoop++ ) {; if ( nLoop & 1 ); nRet += 2;; else; nRet -= 1;; }; return nRet;; }. Unrolling by 2 would eliminate the '&1' in both copies, leading to a net; reduction in code size. The resultant code would then also be suitable for; exit value computation. //===---------------------------------------------------------------------===//. We miss a bunch of rotate opportunities on various targets, including ppc, x86,; etc. On X86, we miss a bunch of 'rotate by variable' cases because the rotate; matching code in dag combine doesn't look through truncates aggressively ; enough. Here are some testcases reduces from GCC PR17886:. unsigned long long f5(unsigned long long x, unsigned long long y) {; return (x << 8) | ((y >> 48) & 0xffull);; }; unsigned long long f6(unsigned long long x, u",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt:16022,simpl,simplification,16022,interpreter/llvm-project/llvm/lib/Target/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt,1,['simpl'],['simplification']
Usability,"alizer matches foo_(1). Matcher<CXXCtorInitializer>forFieldMatcher<FieldDecl> InnerMatcher; Matches the field declaration of a constructor initializer. Given; struct Foo {; Foo() : foo_(1) { }; int foo_;; };; cxxRecordDecl(has(cxxConstructorDecl(hasAnyConstructorInitializer(; forField(hasName(""foo_"")))))); matches Foo; with forField matching foo_. Matcher<CXXCtorInitializer>hasTypeLocMatcher<TypeLoc> Inner; Matches if the type location of a node matches the inner matcher. Examples:; int x;; declaratorDecl(hasTypeLoc(loc(asString(""int"")))); matches int x. auto x = int(3);; cxxTemporaryObjectExpr(hasTypeLoc(loc(asString(""int"")))); matches int(3). struct Foo { Foo(int, int); };; auto x = Foo(1, 2);; cxxFunctionalCastExpr(hasTypeLoc(loc(asString(""struct Foo"")))); matches Foo(1, 2). Usable as: Matcher<BlockDecl>, Matcher<CXXBaseSpecifier>,; Matcher<CXXCtorInitializer>, Matcher<CXXFunctionalCastExpr>,; Matcher<CXXNewExpr>, Matcher<CXXTemporaryObjectExpr>,; Matcher<CXXUnresolvedConstructExpr>,; Matcher<ClassTemplateSpecializationDecl>, Matcher<CompoundLiteralExpr>,; Matcher<DeclaratorDecl>, Matcher<ExplicitCastExpr>,; Matcher<ObjCPropertyDecl>, Matcher<TemplateArgumentLoc>,; Matcher<TypedefNameDecl>. Matcher<CXXCtorInitializer>withInitializerMatcher<Expr> InnerMatcher; Matches the initializer expression of a constructor initializer. Given; struct Foo {; Foo() : foo_(1) { }; int foo_;; };; cxxRecordDecl(has(cxxConstructorDecl(hasAnyConstructorInitializer(; withInitializer(integerLiteral(equals(1))))))); matches Foo; with withInitializer matching (1). Matcher<CXXDependentScopeMemberExpr>hasObjectExpressionMatcher<Expr> InnerMatcher; Matches a member expression where the object expression is matched by a; given matcher. Implicit object expressions are included; that is, it matches; use of implicit `this`. Given; struct X {; int m;; int f(X x) { x.m; return m; }; };; memberExpr(hasObjectExpression(hasType(cxxRecordDecl(hasName(""X""))))); matches `x.m`, but not `m`; however,; me",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:151927,Usab,Usable,151927,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['Usab'],['Usable']
Usability,"all analysis paths.; There are more debug checkers available. To see all available debug checkers:. $ clang -cc1 -analyzer-checker-help | grep ""debug"". Debug Prints and Tricks; To view ""half-baked"" ExplodedGraph while debugging, jump to a frame; that has clang::ento::ExprEngine object and execute:. (gdb) p ViewGraph(0). To see the ProgramState while debugging use the following command. (gdb) p State->dump(). To see clang::Expr while debugging use the following command. If you; pass in a SourceManager object, it will also dump the corresponding line in the; source code. (gdb) p E->dump(). To dump AST of a method that the current ExplodedNode belongs; to:. (gdb) p C.getPredecessor()->getCodeDecl().getBody()->dump(). Making Your Checker Better. User facing documentation is important for adoption! Make sure the checker list is updated; at the homepage of the analyzer. Also ensure the description is clear to; non-analyzer-developers in Checkers.td.; Warning and note messages should be clear and easy to understand, even if a bit long. Messages should start with a capital letter (unlike Clang warnings!) and should not; end with ..; Articles are usually omitted, eg. Dereference of a null pointer ->; Dereference of null pointer.; Introduce BugReporterVisitors to emit additional notes that explain the warning; to the user better. There are some existing visitors that might be useful for your check,; e.g. trackNullOrUndefValue. For example, SimpleStreamChecker should highlight; the event of opening the file when reporting a file descriptor leak. If the check tracks anything in the program state, it needs to implement the; checkDeadSymbolscallback to clean the state up.; The check should conservatively assume that the program is correct when a tracked symbol; is passed to a function that is unknown to the analyzer.; checkPointerEscape callback could help you handle that case.; Use safe and convenient APIs!. Always use CheckerContext::generateErrorNode and; CheckerContext::genera",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/checker_dev_manual.html:23153,clear,clear,23153,interpreter/llvm-project/clang/www/analyzer/checker_dev_manual.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/checker_dev_manual.html,1,['clear'],['clear']
Usability,"all projects. .. _build_single_project:. Building a single sub-project; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Even though there is a single source tree, you are not required to build; all sub-projects together. It is trivial to configure builds for a single; sub-project. For example::. mkdir build && cd build; # Configure only LLVM (default); cmake path/to/monorepo; # Configure LLVM and lld; cmake path/to/monorepo -DLLVM_ENABLE_PROJECTS=lld; # Configure LLVM and clang; cmake path/to/monorepo -DLLVM_ENABLE_PROJECTS=clang. .. _git-svn-mirror:. Outstanding Questions; ---------------------. Read-only sub-project mirrors; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. With the Monorepo, it is undecided whether the existing single-subproject; mirrors (e.g. https://git.llvm.org/git/compiler-rt.git) will continue to; be maintained. Read/write SVN bridge; ^^^^^^^^^^^^^^^^^^^^^. GitHub supports a read/write SVN bridge for its repositories. However,; there have been issues with this bridge working correctly in the past,; so it's not clear if this is something that will be supported going forward. Monorepo Drawbacks; ------------------. * Using the monolithic repository may add overhead for those contributing to a; standalone sub-project, particularly on runtimes like libcxx and compiler-rt; that don't rely on LLVM; currently, a fresh clone of libcxx is only 15MB (vs.; 1GB for the monorepo), and the commit rate of LLVM may cause more frequent; `git push` collisions when upstreaming. Affected contributors may be able to; use the SVN bridge or the single-subproject Git mirrors. However, it's; undecided if these projects will continue to be maintained.; * Using the monolithic repository may add overhead for those *integrating* a; standalone sub-project, even if they aren't contributing to it, due to the; same disk space concern as the point above. The availability of the; sub-project Git mirrors would addresses this.; * Preservation of the existing read/write SVN-based workflows relies on the; GitHub SV",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst:10960,clear,clear,10960,interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,1,['clear'],['clear']
Usability,"alloc). One example of this is in; SingleSource/Benchmarks/Misc/dt.c. //===---------------------------------------------------------------------===//. Interesting missed case because of control flow flattening (should be 2 loads):; http://gcc.gnu.org/bugzilla/show_bug.cgi?id=26629; With: llvm-gcc t2.c -S -o - -O0 -emit-llvm | llvm-as | ; opt -mem2reg -gvn -instcombine | llvm-dis; we miss it because we need 1) CRIT EDGE 2) MULTIPLE DIFFERENT; VALS PRODUCED BY ONE BLOCK OVER DIFFERENT PATHS. //===---------------------------------------------------------------------===//. http://gcc.gnu.org/bugzilla/show_bug.cgi?id=19633; We could eliminate the branch condition here, loading from null is undefined:. struct S { int w, x, y, z; };; struct T { int r; struct S s; };; void bar (struct S, int);; void foo (int a, struct T b); {; struct S *c = 0;; if (a); c = &b.s;; bar (*c, a);; }. //===---------------------------------------------------------------------===//. simplifylibcalls should do several optimizations for strspn/strcspn:. strcspn(x, ""a"") -> inlined loop for up to 3 letters (similarly for strspn):. size_t __strcspn_c3 (__const char *__s, int __reject1, int __reject2,; int __reject3) {; register size_t __result = 0;; while (__s[__result] != '\0' && __s[__result] != __reject1 &&; __s[__result] != __reject2 && __s[__result] != __reject3); ++__result;; return __result;; }. This should turn into a switch on the character. See PR3253 for some notes on; codegen. 456.hmmer apparently uses strcspn and strspn a lot. 471.omnetpp uses strspn. //===---------------------------------------------------------------------===//. simplifylibcalls should turn these snprintf idioms into memcpy (GCC PR47917). char buf1[6], buf2[6], buf3[4], buf4[4];; int i;. int foo (void) {; int ret = snprintf (buf1, sizeof buf1, ""abcde"");; ret += snprintf (buf2, sizeof buf2, ""abcdef"") * 16;; ret += snprintf (buf3, sizeof buf3, ""%s"", i++ < 6 ? ""abc"" : ""def"") * 256;; ret += snprintf (buf4, sizeof buf4, ""%s"",",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt:36779,simpl,simplifylibcalls,36779,interpreter/llvm-project/llvm/lib/Target/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt,1,['simpl'],['simplifylibcalls']
Usability,"alloc``, ``calloc``,; ``alloca``, ``memccpy``, ``realloc``, ``bcopy``. Please note that there are no built-in filter functions. One can configure their own taint sources, sinks, and propagation rules by; providing a configuration file via checker option; ``alpha.security.taint.TaintPropagation:Config``. The configuration file is in; `YAML <http://llvm.org/docs/YamlIO.html#introduction-to-yaml>`_ format. The; taint-related options defined in the config file extend but do not override the; built-in sources, rules, sinks. The format of the external taint configuration; file is not stable, and could change without any notice even in a non-backward; compatible way. For a more detailed description of configuration options, please see the; :doc:`user-docs/TaintAnalysisConfiguration`. For an example see; :ref:`clangsa-taint-configuration-example`. **Configuration**. * `Config` Specifies the name of the YAML configuration file. The user can; define their own taint sources and sinks. **Related Guidelines**. * `CWE Data Neutralization Issues; <https://cwe.mitre.org/data/definitions/137.html>`_; * `SEI Cert STR02-C. Sanitize data passed to complex subsystems; <https://wiki.sei.cmu.edu/confluence/display/c/STR02-C.+Sanitize+data+passed+to+complex+subsystems>`_; * `SEI Cert ENV33-C. Do not call system(); <https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=87152177>`_; * `ENV03-C. Sanitize the environment when invoking external programs; <https://wiki.sei.cmu.edu/confluence/display/c/ENV03-C.+Sanitize+the+environment+when+invoking+external+programs>`_. **Limitations**. * The taintedness property is not propagated through function calls which are; unknown (or too complex) to the analyzer, unless there is a specific; propagation rule built-in to the checker or given in the YAML configuration; file. This causes potential true positive findings to be lost. alpha.unix; ^^^^^^^^^^. .. _alpha-unix-BlockInCriticalSection:. alpha.unix.BlockInCriticalSection (C); """"""""""""""""""""""""""",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:73561,Guid,Guidelines,73561,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['Guid'],['Guidelines']
Usability,"ally in the main file. .. productionlist::; IncludeDirective: ""include"" `TokString`. Portions of the main file and included files can be conditionalized using; preprocessor directives. .. productionlist::; PreprocessorDirective: ""#define"" | ""#ifdef"" | ""#ifndef"". Types; =====. The TableGen language is statically typed, using a simple but complete type; system. Types are used to check for errors, to perform implicit conversions,; and to help interface designers constrain the allowed input. Every value is; required to have an associated type. TableGen supports a mixture of low-level types (e.g., ``bit``) and; high-level types (e.g., ``dag``). This flexibility allows you to describe a; wide range of records conveniently and compactly. .. productionlist::; Type: ""bit"" | ""int"" | ""string"" | ""dag""; :| ""bits"" ""<"" `TokInteger` "">""; :| ""list"" ""<"" `Type` "">""; :| `ClassID`; ClassID: `TokIdentifier`. ``bit``; A ``bit`` is a boolean value that can be 0 or 1. ``int``; The ``int`` type represents a simple 64-bit integer value, such as 5 or; -42. ``string``; The ``string`` type represents an ordered sequence of characters of arbitrary; length. ``bits<``\ *n*\ ``>``; The ``bits`` type is a fixed-sized integer of arbitrary length *n* that; is treated as separate bits. These bits can be accessed individually.; A field of this type is useful for representing an instruction operation; code, register number, or address mode/register/displacement. The bits of; the field can be set individually or as subfields. For example, in an; instruction address, the addressing mode, base register number, and; displacement can be set separately. ``list<``\ *type*\ ``>``; This type represents a list whose elements are of the *type* specified in; angle brackets. The element type is arbitrary; it can even be another; list type. List elements are indexed from 0. ``dag``; This type represents a nestable directed acyclic graph (DAG) of nodes.; Each node has an *operator* and zero or more *arguments* (or *opera",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst:10897,simpl,simple,10897,interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,1,['simpl'],['simple']
Usability,"ally supports a fully fine grained mapping mechanism that allows; you to map almost any diagnostic to the output level that you want. The only; diagnostics that cannot be mapped are ``NOTE``\ s, which always follow the; severity of the previously emitted diagnostic and ``ERROR``\ s, which can only; be mapped to ``Fatal`` (it is not possible to turn an error into a warning, for; example). Diagnostic mappings are used in many ways. For example, if the user specifies; ``-pedantic``, ``EXTENSION`` maps to ``Warning``, if they specify; ``-pedantic-errors``, it turns into ``Error``. This is used to implement; options like ``-Wunused_macros``, ``-Wundef`` etc. Mapping to ``Fatal`` should only be used for diagnostics that are considered so; severe that error recovery won't be able to recover sensibly from them (thus; spewing a ton of bogus errors). One example of this class of error are failure; to ``#include`` a file. The Format String; ^^^^^^^^^^^^^^^^^. The format string for the diagnostic is very simple, but it has some power. It; takes the form of a string in English with markers that indicate where and how; arguments to the diagnostic are inserted and formatted. For example, here are; some simple format strings:. .. code-block:: c++. ""binary integer literals are an extension""; ""format string contains '\\0' within the string body""; ""more '%%' conversions than data arguments""; ""invalid operands to binary expression (%0 and %1)""; ""overloaded '%0' must be a %select{unary|binary|unary or binary}2 operator""; "" (has %1 parameter%s1)"". These examples show some important points of format strings. You can use any; plain ASCII character in the diagnostic string except ""``%``"" without a; problem, but these are C strings, so you have to use and be aware of all the C; escape sequences (as in the second example). If you want to produce a ""``%``""; in the output, use the ""``%%``"" escape sequence, like the third diagnostic.; Finally, Clang uses the ""``%...[digit]``"" sequences to specif",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:6269,simpl,simple,6269,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['simpl'],['simple']
Usability,"also change for each sub-pad. ## Changes in 5.0.2; 1. Fix - read branch entries as arrays; 2. Fix - command submission to THttpServer; 3. Fix - let refill statbox also for empty histogram; 4. Fix - problem with online TTree::Draw and ROOT6. ## Changes in 5.0.1; 1. Support older ROOT files, created before 2010; 2. Support TBranchObject - appears in old files; 3. Correctly set TBasket buffer position for the entry; 4. Fix - problem with empty STL containers; 5. Fix - empty baskets at the end of branch store; 6. Fix - problem with zooming in THStack. ## Changes in 5.0.0; 1. Reading TTree data; - all kinds of branches, including split STL containers; - branches with several elementary leaves; - branches from different ROOT files; - JSROOT.TSelector class to access TTree data; - simple access to branch data with ""dump"" draw option; 2. TTree::Draw support; - simple 1D/2D/3D histograms; - simple cut conditions; - configurable histogram like ""px:py>>hist(50,-5,5,50,-5,5)""; - strings support; - iterate over arrays indexes, let use another branch as index values; - support ""Entry$"" and ""Entries$"" variables in expressions; - bits histogram like ""event.fTracks.fBits>>bits(16)""; - special handling of TBits; - arbitrary math function from JavaScript Math class, some TMath:: function from ROOT; - if branch is object, one could use methods ""TMath::Abs(lep1_p4.X()+lep1_p4.Y())""; - interactive player to configure and execute draw expression; 3. Full support of Float16_t and Double32_t types in I/O; 4. Drawing of RooPlot objects, I/O support for RooFit classes; 5. Many improvements in object inspector; - support of large lists; only first part is shown; - support of large arrays; values group in decades; - allow to call draw function for sub-elements in inspector; 6. Canvas or selected sub-pad can be enlarged when double-clicked outside frame (#116); Complete drawing will be expanded to the visible space.; Not available for flex, tabs and collapsible layouts.; 7. Support reading of lo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/changes.md:46947,simpl,simple,46947,js/changes.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/changes.md,2,['simpl'],['simple']
Usability,"alue like ``7``; to an entity of type ``bits<4>``. .. productionlist::; Value: `SimpleValue` `ValueSuffix`*; :| `Value` ""#"" [`Value`]; ValueSuffix: ""{"" `RangeList` ""}""; :| ""["" `SliceElements` ""]""; :| ""."" `TokIdentifier`; RangeList: `RangePiece` ("","" `RangePiece`)*; RangePiece: `TokInteger`; :| `TokInteger` ""..."" `TokInteger`; :| `TokInteger` ""-"" `TokInteger`; :| `TokInteger` `TokInteger`; SliceElements: (`SliceElement` "","")* `SliceElement` "",""?; SliceElement: `Value`; :| `Value` ""..."" `Value`; :| `Value` ""-"" `Value`; :| `Value` `TokInteger`. .. warning::; The peculiar last form of :token:`RangePiece` and :token:`SliceElement` is; due to the fact that the ""``-``"" is included in the :token:`TokInteger`,; hence ``1-5`` gets lexed as two consecutive tokens, with values ``1`` and; ``-5``, instead of ""1"", ""-"", and ""5"".; The use of hyphen as the range punctuation is deprecated. Simple values; -------------. The :token:`SimpleValue` has a number of forms. .. productionlist::; SimpleValue: `TokInteger` | `TokString`+ | `TokCode`. A value can be an integer literal, a string literal, or a code literal.; Multiple adjacent string literals are concatenated as in C/C++; the simple; value is the concatenation of the strings. Code literals become strings and; are then indistinguishable from them. .. productionlist::; SimpleValue2: ""true"" | ""false"". The ``true`` and ``false`` literals are essentially syntactic sugar for the; integer values 1 and 0. They improve the readability of TableGen files when; boolean values are used in field initializations, bit sequences, ``if``; statements, etc. When parsed, these literals are converted to integers. .. note::. Although ``true`` and ``false`` are literal names for 1 and 0, we; recommend as a stylistic rule that you use them for boolean; values only. .. productionlist::; SimpleValue3: ""?"". A question mark represents an uninitialized value. .. productionlist::; SimpleValue4: ""{"" [`ValueList`] ""}""; ValueList: `ValueListNE`; ValueListNE: `Value`",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst:14195,Simpl,SimpleValue,14195,interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,1,['Simpl'],['SimpleValue']
Usability,"alue() << ""\n"";. Note that ``enumerate`` has ``zip_equal`` semantics and provides elements; through a 'reference wrapper' proxy, which makes them modifiable when accessed; through structured bindings or the ``value()`` member function. When two or more; ranges are passed, ``enumerate`` requires them to have equal lengths (checked; with an ``assert``). .. _debugging:. Debugging; =========. A handful of `GDB pretty printers; <https://sourceware.org/gdb/onlinedocs/gdb/Pretty-Printing.html>`__ are; provided for some of the core LLVM libraries. To use them, execute the; following (or add it to your ``~/.gdbinit``)::. source /path/to/llvm/src/utils/gdb-scripts/prettyprinters.py. It also might be handy to enable the `print pretty; <http://ftp.gnu.org/old-gnu/Manuals/gdb/html_node/gdb_57.html>`__ option to; avoid data structures being printed as a big block of text. .. _common:. Helpful Hints for Common Operations; ===================================. This section describes how to perform some very simple transformations of LLVM; code. This is meant to give examples of common idioms used, showing the; practical side of LLVM transformations. Because this is a ""how-to"" section, you should also read about the main classes; that you will be working with. The :ref:`Core LLVM Class Hierarchy Reference; <coreclasses>` contains details and descriptions of the main classes that you; should know about. .. _inspection:. Basic Inspection and Traversal Routines; ---------------------------------------. The LLVM compiler infrastructure have many different data structures that may be; traversed. Following the example of the C++ standard template library, the; techniques used to traverse these various data structures are all basically the; same. For an enumerable sequence of values, the ``XXXbegin()`` function (or; method) returns an iterator to the start of the sequence, the ``XXXend()``; function returns an iterator pointing to one past the last valid element of the; sequence, and there ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:103638,simpl,simple,103638,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['simpl'],['simple']
Usability,"alyzer. Obtaining the Static Analyzer; This page describes how to download and install the analyzer. Once; the analyzer is installed, follow the instructions on using scan-build to; get started analyzing your code.; Packaged Builds (Mac OS X); Semi-regular pre-built binaries of the analyzer are available on Mac; OS X. These are built to run on OS X 10.7 and later.; Builds are released frequently. Often the differences between build; numbers being a few bug fixes or minor feature improvements. When using; the analyzer, we recommend that you check back here occasionally for new; builds, especially if the build you are using is more than a couple; weeks old.; The latest build is:; . Packaged builds for other platforms may eventually be provided, but; we need volunteers who are willing to help provide such regular builds.; If you wish to help contribute regular builds of the analyzer on other; platforms, please email the Clang; Developers' mailing list.; Using Packaged Builds; To use a package build, simply unpack it anywhere. If the build; archive has the name checker-XXX.tar.bz2 then the; archive will expand to a directory called checker-XXX.; You do not need to place this directory or the contents of this; directory in any special place. Uninstalling the analyzer is as simple; as deleting this directory.; Most of the files in the checker-XXX directory will; be supporting files for the analyzer that you can simply ignore. Most; users will only care about two files, which are located at the top of; the checker-XXX directory:. scan-build: scan-build is the high-level command line utility for running the analyzer; scan-view: scan-view a companion command line; utility to scan-build, scan-view is used to view; analysis results generated by scan-build. There is an option; that one can pass to scan-build to cause scan-view to; run as soon as it the analysis of a build completes. Running scan-build; For specific details on using scan-build, please see; scan-build's documentat",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/installation.html:1037,simpl,simply,1037,interpreter/llvm-project/clang/www/analyzer/installation.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/installation.html,1,['simpl'],['simply']
Usability,"ameter(1,1);; f1->Draw();; ```. in Python becomes:. ``` {.python}; import ROOT; f1 = ROOT.TF1(""f2"",""[0]*sin([1]*x)/x"",0.,10.); f1.SetParameter(0,1);; f1.SetParameter(1,1);; f1.Draw();; ```. A slightly more advanced example hands over data defined in the macro to the ROOT; class `TGraphErrors`. Note that a Python array can be used to pass data between; Python and ROOT. The first line in the Python script allows it to be executed; directly from the operating system, without the need to start the script from; python or the highly recommended powerful interactive shell ipython. The last line; in the python script is there to allow you to have a look at the graphical output; in the ROOT canvas before it disappears upon termination of the script. Here is the C++ version:. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/TGraphFit.C; ```. In Python it looks like this:. ``` {.python}; @ROOT_INCLUDE_FILE macros/TGraphFit.py; ```. Comparing the C++ and Python versions in these two examples, it now should be; clear how easy it is to convert any ROOT Macro in C++ to a Python version. As another example, let us revisit macro3 from Chapter 4. A straight-forward; Python version relying on the ROOT class `TMath`:. ``` {.python}; @ROOT_INCLUDE_FILE macros/macro3.py; ```. ### More Python- less C++ ###. You may have noticed already that there are some Python modules providing; functionality similar to ROOT classes, which fit more seamlessly into your; Python code. A more “pythonic” version of the above macro3 would use a replacement of the; ROOT class TMath for the provisioning of data to TGraphPolar. With the math; package, the part of the code becomes. ``` {.cpp}; import math; from array import array; from ROOT import TCanvas , TGraphPolar; ...; ipt=range(0,npoints); r=array('d',map(lambda x: x*(rmax-rmin)/(npoints-1.)+rmin,ipt)); theta=array('d',map(math.sin,r)); e=array('d',npoints*[0.]); ... ```. #### Customised Binning ####; This example combines comfortable handling of arrays in Python to",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/root_in_python.md:1859,clear,clear,1859,documentation/primer/root_in_python.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/root_in_python.md,1,['clear'],['clear']
Usability,"ample is a set of; values defining the inputs and the corresponding output that the; network should ideally provide. In ROOT this is a **`TTree`** entry.; The first thing to be decided is the network layout. This layout is; described in a string where the layers are separated by semicolons.; The input/output layers are defined by giving the expression for each; neuron, separated by comas. Hidden layers are just described by the; number of neurons. In addition, input and output layer formulas can be preceded by '@'; (e.g. ""@out"") if one wants to normalize the corresponding value. Also,; if the string ends with '`!`', output neurons are set up for; classification, i.e. with a sigmoid (1 neuron) or softmax (more; neurons) activation function. Many questions on the good usage of neural network, including rules of; dumb to determine the best network topology are addressed at; <ftp://ftp.sas.com/pub/neural/FAQ.html>. ``` {.cpp}; // a simple network: 2 inputs, 10 hidden and 1 normalized; // output neuron; TMultiLayerPerceptron network(""r,z:10:@Br"",tree);; ```. Expressions are evaluated as for `TTree::Draw()`. Input and outputs; are taken from the **`TTree`** associated with the network. This; **`TTree`** can be given as argument of the constructor or defined; later with `TMultiLayerPerceptron::SetData()`. Events can also be; weighted. The weight expression can be given in the constructor or set; later with the method `SetWeight()` of the class; **`TMultiLayerPerceptron`**. Two datasets must be defined before; learning the network: a training dataset that is used when minimizing; the error, and a test dataset that will avoid bias. Those two datasets; can be built aside and then given to the network, or can be built from; a standard expression. By default, half of the events are put in both; datasets. ``` {.cpp}; // a more complex 4:8:1 network; // the ptsumf branch is used as weigh;; // default event lists are explicit; TMultiLayerPerceptron network(""m,pt,acol,acopl:8:type""",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:75082,simpl,simple,75082,documentation/users-guide/FittingHistograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md,1,['simpl'],['simple']
Usability,"ample, guarantees that there will be no critical; edges in the CFG when your pass has been run. Some analyses chain to other analyses to do their job. For example, an; `AliasAnalysis <AliasAnalysis>` implementation is required to :ref:`chain; <aliasanalysis-chaining>` to other alias analysis passes. In cases where; analyses chain, the ``addRequiredTransitive`` method should be used instead of; the ``addRequired`` method. This informs the ``PassManager`` that the; transitively required pass should be alive as long as the requiring pass is. The ``AnalysisUsage::addPreserved<>`` method; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. One of the jobs of the ``PassManager`` is to optimize how and when analyses are; run. In particular, it attempts to avoid recomputing data unless it needs to.; For this reason, passes are allowed to declare that they preserve (i.e., they; don't invalidate) an existing analysis if it's available. For example, a; simple constant folding pass would not modify the CFG, so it can't possibly; affect the results of dominator analysis. By default, all passes are assumed; to invalidate all others. The ``AnalysisUsage`` class provides several methods which are useful in; certain circumstances that are related to ``addPreserved``. In particular, the; ``setPreservesAll`` method can be called to indicate that the pass does not; modify the LLVM program at all (which is true for analyses), and the; ``setPreservesCFG`` method can be used by transformations that change; instructions in the program but do not modify the CFG or terminator; instructions. ``addPreserved`` is particularly useful for transformations like; ``BreakCriticalEdges``. This pass knows how to update a small set of loop and; dominator related analyses if they exist, so it can preserve them, despite the; fact that it hacks on the CFG. Example implementations of ``getAnalysisUsage``; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. .. code-block:: c++. // This example modifies the program, bu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst:31533,simpl,simple,31533,interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,1,['simpl'],['simple']
Usability,"ample: BOOST_PP_STRINGIZE. .. END_FORMAT_STYLE_OPTIONS. Adding additional style options; ===============================. Each additional style option adds costs to the clang-format project. Some of; these costs affect the clang-format development itself, as we need to make; sure that any given combination of options work and that new features don't; break any of the existing options in any way. There are also costs for end users; as options become less discoverable and people have to think about and make a; decision on options they don't really care about. The goal of the clang-format project is more on the side of supporting a; limited set of styles really well as opposed to supporting every single style; used by a codebase somewhere in the wild. Of course, we do want to support all; major projects and thus have established the following bar for adding style; options. Each new style option must .. * be used in a project of significant size (have dozens of contributors); * have a publicly accessible style guide; * have a person willing to contribute and maintain patches. Examples; ========. A style similar to the `Linux Kernel style; <https://www.kernel.org/doc/html/latest/process/coding-style.html>`_:. .. code-block:: yaml. BasedOnStyle: LLVM; IndentWidth: 8; UseTab: Always; BreakBeforeBraces: Linux; AllowShortIfStatementsOnASingleLine: false; IndentCaseLabels: false. The result is (imagine that tabs are used for indentation here):. .. code-block:: c++. void test(); {; switch (x) {; case 0:; case 1:; do_something();; break;; case 2:; do_something_else();; break;; default:; break;; }; if (condition); do_something_completely_different();. if (x == y) {; q();; } else if (x > y) {; w();; } else {; r();; }; }. A style similar to the default Visual Studio formatting style:. .. code-block:: yaml. UseTab: Never; IndentWidth: 4; BreakBeforeBraces: Allman; AllowShortIfStatementsOnASingleLine: false; IndentCaseLabels: false; ColumnLimit: 0. The result is:. .. code-block:: c+",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:134664,guid,guide,134664,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['guid'],['guide']
Usability,"ampling, Fourier transforms, etc. �The following concrete implementation; of the TestStatSampler interface are currently available. ToyMCSamplerUses a Toy Monte Carlo approach to build the; sampling distribution. �The pdf's generate method to generate is used to; generate toy data, and then the test statistic is evaluated at the; requested parameter point. ; DebuggingSampler Simply returns a uniform distribution; between 0,1. �Useful for debugging. NeymanConstruction and FeldmanCousins; A flexible framework for the Neyman Construction was added in this; release. The NeymanConstruction is a concrete implementation of the; IntervalCalculator interface, but it needs several; additional components�to be specified before use. The design; factorizes the choice of the parameter points to be tested,�the choice of; the test statistic, and the generation of sampling distribution into; separate parts (described above). �Finally, the NeymanConstruction class; is simply in charge of using these parts (strategies) and constructing; the confidence belt and confidence intervals. �The ConfidenceBelt class; is still under development, but the current version works fine for; producing ConfidenceIntervals. �We are also working to make this class; work with parallelization approaches, which is not yet complete.; The FeldmanCousins class is a separate concrete implementation of the; IntervalCalculator interface. �It uses the NeymanConstruction internally,; and�enforces�specific choices of the test statistic and ordering; principle to realize the Unified intervals described by Feldman and; Cousins in their paper�Phys.Rev.D57:3873-3889,1998. In an extension to the technique discussed in Feldman and Cousins paper,; the FeldmanCousins class also performs a ""profile construction"" if their are nuisance parameters.; In this case, the parameters of interest are scanned in a regular grid. For each point in the grid; the calculator finds the best fit value of the nuisance parameters (given the dat",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html:28183,simpl,simply,28183,roofit/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html,1,['simpl'],['simply']
Usability,"an add a ``-mno-evex512`` in the command line with AVX512 options if; they want to run the binary on both legacy AVX512 and new AVX10/256 capable; processors. The option has the same constraints as ``-mavx10.N``, i.e.,; cannot call to 512-bit X86 specific intrinsics and pass or return 512-bit vector; types in function call. Users should avoid using AVX512 features in function target attributes when; developing code for AVX10. If they have to do so, they need to add an explicit; ``evex512`` or ``no-evex512`` together with AVX512 features for 512-bit or; non-512-bit functions respectively to avoid unexpected code generation. Both; command line option and target attribute of EVEX512 feature can only be used; with AVX512. They don't affect vector size of AVX10. User should not mix the use AVX10 and AVX512 options together at any time,; because the option combinations are conflicting sometimes. For example, a; combination of ``-mavx512f -mavx10.1-256`` doesn't show a clear intention to; compiler, since instructions in AVX512F and AVX10.1/256 intersect but do not; overlap. In this case, compiler will emit warning for it, but the behavior; is determined. It will generate the same code as option ``-mavx10.1-512``.; A similar case is ``-mavx512f -mavx10.2-256``, which equals to; ``-mavx10.1-512 -mavx10.2-256``, because ``avx10.2-256`` implies ``avx10.1-256``; and ``-mavx512f -mavx10.1-256`` equals to ``-mavx10.1-512``. There are some new macros introduced with AVX10 support. ``-mavx10.1-256`` will; enable ``__AVX10_1__`` and ``__EVEX256__``, while ``-mavx10.1-512`` enables; ``__AVX10_1__``, ``__EVEX256__``, ``__EVEX512__`` and ``__AVX10_1_512__``.; Besides, both ``-mavx10.1-256`` and ``-mavx10.1-512`` will enable all AVX512; feature specific macros. A AVX512 feature will enable both ``__EVEX256__``,; ``__EVEX512__`` and its own macro. So ``__EVEX512__`` can be used to guard code; that can run on both legacy AVX512 and AVX10/512 capable processors but cannot; run on AVX10/256,",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:160199,clear,clear,160199,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['clear'],['clear']
Usability,"an be added or customized by overriding InstrInfo's hook; ``createMIROperandComment()``. Debug-Info constructs; ---------------------. Most of the debugging information in a MIR file is to be found in the metadata; of the embedded module. Within a machine function, that metadata is referred to; by various constructs to describe source locations and variable locations. Source locations; ^^^^^^^^^^^^^^^^. Every MIR instruction may optionally have a trailing reference to a; ``DILocation`` metadata node, after all operands and symbols, but before; memory operands:. .. code-block:: text. $rbp = MOV64rr $rdi, debug-location !12. The source location attachment is synonymous with the ``!dbg`` metadata; attachment in LLVM-IR. The absence of a source location attachment will be; represented by an empty ``DebugLoc`` object in the machine instruction. Fixed variable locations; ^^^^^^^^^^^^^^^^^^^^^^^^. There are several ways of specifying variable locations. The simplest is; describing a variable that is permanently located on the stack. In the stack; or fixedStack attribute of the machine function, the variable, scope, and; any qualifying location modifier are provided:. .. code-block:: text. - { id: 0, name: offset.addr, offset: -24, size: 8, alignment: 8, stack-id: default,; 4 debug-info-variable: '!1', debug-info-expression: '!DIExpression()',; debug-info-location: '!2' }. Where:. - ``debug-info-variable`` identifies a DILocalVariable metadata node,. - ``debug-info-expression`` adds qualifiers to the variable location,. - ``debug-info-location`` identifies a DILocation metadata node. These metadata attributes correspond to the operands of a ``llvm.dbg.declare``; IR intrinsic, see the :ref:`source level debugging<format_common_intrinsics>`; documentation. Varying variable locations; ^^^^^^^^^^^^^^^^^^^^^^^^^^. Variables that are not always on the stack or change location are specified; with the ``DBG_VALUE`` meta machine instruction. It is synonymous with the; ``llvm.dbg.valu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MIRLangRef.rst:24602,simpl,simplest,24602,interpreter/llvm-project/llvm/docs/MIRLangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MIRLangRef.rst,1,['simpl'],['simplest']
Usability,"an be nested).; * The ``Lexer`` keeps track of an :ref:`MultipleIncludeOpt; <MultipleIncludeOpt>` object, which is used to detect whether the buffer uses; the standard ""``#ifndef XX`` / ``#define XX``"" idiom to prevent multiple; inclusion. If a buffer does, subsequent includes can be ignored if the; ""``XX``"" macro is defined. .. _TokenLexer:. The ``TokenLexer`` class; ------------------------. The ``TokenLexer`` class is a token provider that returns tokens from a list of; tokens that came from somewhere else. It typically used for two things: 1); returning tokens from a macro definition as it is being expanded 2) returning; tokens from an arbitrary buffer of tokens. The later use is used by; ``_Pragma`` and will most likely be used to handle unbounded look-ahead for the; C++ parser. .. _MultipleIncludeOpt:. The ``MultipleIncludeOpt`` class; --------------------------------. The ``MultipleIncludeOpt`` class implements a really simple little state; machine that is used to detect the standard ""``#ifndef XX`` / ``#define XX``""; idiom that people typically use to prevent multiple inclusion of headers. If a; buffer uses this idiom and is subsequently ``#include``'d, the preprocessor can; simply check to see whether the guarding condition is defined or not. If so,; the preprocessor can completely ignore the include of the header. .. _Parser:. The Parser Library; ==================. This library contains a recursive-descent parser that polls tokens from the; preprocessor and notifies a client of the parsing progress. Historically, the parser used to talk to an abstract ``Action`` interface that; had virtual methods for parse events, for example ``ActOnBinOp()``. When Clang; grew C++ support, the parser stopped supporting general ``Action`` clients --; it now always talks to the :ref:`Sema library <Sema>`. However, the Parser; still accesses AST objects only through opaque types like ``ExprResult`` and; ``StmtResult``. Only :ref:`Sema <Sema>` looks at the AST node contents o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:56369,simpl,simple,56369,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['simpl'],['simple']
Usability,"an exact; field label and data type match.). If, however, all methods fail and there is only one C++ exception (the other; exceptions originating from argument conversion, never succeeding to call; into C++), this C++ exception will be preferentially reported and will have; the original C++ type. `Return values`; ---------------. Most return types are readily amenable to automatic memory management: builtin; returns, by-value returns, (const-)reference returns to internal data, smart; pointers, etc.; The important exception is pointer returns.; ; A function that returns a pointer to an object over which Python should claim; ownership, should have its ``__creates__`` flag set through its; :doc:`pythonization <pythonizations>`.; Well-written APIs will have clear clues in their naming convention about the; ownership rules.; For example, functions called ``New...``, ``Clone...``, etc. can be expected; to return freshly allocated objects.; A basic name-matching in the pythonization then makes it simple to mark all; these functions as creators. The return values are :ref:`auto-casted <sec-auto-casting-label>`. `\*args and \*\*kwds`; ---------------------. C++ default arguments work as expected.; Keywords, however, are a Python language feature that does not exist in C++.; Many C++ function declarations do have formal arguments, but these are not; part of the C++ interface (the argument names are repeated in the definition,; making the names in the declaration irrelevant: they do not even need to be; provided).; Thus, although ``cppyy`` will map keyword argument names to formal argument; names from the C++ declaration, use of this feature is not recommended unless; you have a guarantee that the names in C++ the interface are maintained.; Example:. .. code-block:: python. >>> from cppyy.gbl import Concrete; >>> c = Concrete() # uses default argument; >>> c.m_int; 42; >>> c = Concrete(13) # uses provided argument; >>> c.m_int; 13; >>> args = (27,); >>> c = Concrete(*args) # a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/functions.rst:13006,simpl,simple,13006,bindings/pyroot/cppyy/cppyy/doc/source/functions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/functions.rst,1,['simpl'],['simple']
Usability,"an now just use; `getSCEV() <https://llvm.org/doxygen/classllvm_1_1ScalarEvolution.html#a30bd18ac905eacf3601bc6a553a9ff49>`_.; and which of these two llvm::Instructions you pass to it disambiguates; the context / scope / relative loop. .. rubric:: Footnotes. .. [#lcssa-construction] To insert these loop-closing PHI nodes, one has to; (re-)compute dominance frontiers (if the loop has multiple exits). .. [#point-of-use-phis] Considering the point of use of a PHI entry value; to be in the respective predecessor is a convention across the whole LLVM.; The reason is mostly practical; for example it preserves the dominance; property of SSA. It is also just an overapproximation of the actual; number of uses; the incoming block could branch to another block in which; case the value is not actually used but there are no side-effects (it might; increase its live range which is not relevant in LCSSA though).; Furthermore, we can gain some intuition if we consider liveness:; A PHI is *usually* inserted in the current block because the value can't; be used from this point and onwards (i.e. the current block is a dominance; frontier). It doesn't make sense to consider that the value is used in; the current block (because of the PHI) since the value stops being live; before the PHI. In some sense the PHI definition just ""replaces"" the original; value definition and doesn't actually use it. It should be stressed that; this analogy is only used as an example and does not pose any strict; requirements. For example, the value might dominate the current block; but we can still insert a PHI (as we do with LCSSA PHI nodes) *and*; use the original value afterwards (in which case the two live ranges overlap,; although in LCSSA (the whole point is that) we never do that). .. [#def-use-chain] A property of SSA is that there exists a def-use chain; for each definition, which is a list of all the uses of this definition.; LLVM implements this property by keeping a list of all the uses of a Valu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LoopTerminology.rst:17382,intuit,intuition,17382,interpreter/llvm-project/llvm/docs/LoopTerminology.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LoopTerminology.rst,1,['intuit'],['intuition']
Usability,"an; which supports APT package manager, you can install all the required packages by:; ```sh; sudo apt-get update; sudo apt-get install git g++ debhelper devscripts gnupg python; ```; You are not required to do this manually since CPT can do this for you automatically. ###### Setting up:; Make sure GnuPG is properly set up with your correct fingerprint. These; credentials are needed to sign the Debian package and create Debian changelogs.; On a build machine (Electric Commander), make sure the fingerprint is of the; user who is supposed to sign the official uploads. You might also want to; configure GnuPG to not ask for the passphrase while signing the Debian package. The [Ubuntu Packaging Guide] contains a quick guide on creating a GPG key on an; Ubuntu system. To test if you have successfully set up your GnuPG key, use the following command:; ```sh; gpg --fingerprint; ```; Again, all these checks are performed by default when you launch CPT with ```-c``` option.; [Ubuntu Packaging Guide]:http://packaging.ubuntu.com/html/getting-set-up.html#create-your-gpg-key. #### Windows; CPT is meant to be executed on cmd.exe prompt. Make sure you have set the; environment properly before continuing.; Below is a list of required packages for Windows (Win32-x86):. [MSYS Git] for Windows. [Python] for Windows. Microsoft Visual Studio 11 (2012), with Microsoft Visual C++ 2012. [MSYS Git]:http://msysgit.github.io/; [Python]:https://www.python.org/. ###### Setting Up:; Unlike other UNIX-like platforms, Windows requires you to follow some rules.; Do not ignore this section unless you want CPT to fail mid-way with wierd; errors. You should require these instructions only once. * While installing the packages make sure the executable is in a path that; doesn't contain spaces. For example, you should install Python in a path like. ```sh; C:\Python27; ```; rather than. ```sh; C:\Program Files (x86)\Python 2.7; ```; * Path to all the required executables should be present in the Windows; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/tools/packaging/README.md:3472,Guid,Guide,3472,interpreter/cling/tools/packaging/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/tools/packaging/README.md,1,['Guid'],['Guide']
Usability,"analyzed; in tandem by the static analyzer.; Upon completion of the build, results are then presented to the user within a; web browser.; Will it work with any build system?; scan-build has little or no knowledge about how you build your code.; It works by overriding the CC and CXX environment variables to; (hopefully) change your build to use a ""fake"" compiler instead of the; one that would normally build your project. This fake compiler executes either; clang or gcc (depending on the platform) to compile your; code and then executes the static analyzer to analyze your code.; This ""poor man's interposition"" works amazingly well in many cases; and falls down in others. Please consult the information on this page on making; the best use of scan-build, which includes getting it to work when the; aforementioned hack fails to work. Viewing static analyzer results in a web browser. Contents. Getting Started. Basic Usage; For Windows Users; Other Options; Output of scan-build. Recommended Usage Guidelines. Always Analyze a Project in its ""Debug"" Configuration; Use Verbose Output when Debugging scan-build; Run './configure' through scan-build. Analyzing iPhone Projects. Getting Started; The scan-build command can be used to analyze an entire project by; essentially interposing on a project's build process. This means that to run the; analyzer using scan-build, you will use scan-build to analyze; the source files compiled by gcc/clang during a project build.; This means that any files that are not compiled will also not be analyzed.; Basic Usage; Basic usage of scan-build is designed to be simple: just place the; word ""scan-build"" in front of your build command:. $ scan-build make; $ scan-build xcodebuild. In the first case scan-build analyzes the code of a project built; with make and in the second case scan-build analyzes a project; built using xcodebuild.; Here is the general format for invoking scan-build:. $ scan-build [scan-build options] <command> [command options]. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/scan-build.html:1387,Guid,Guidelines,1387,interpreter/llvm-project/clang/www/analyzer/scan-build.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/scan-build.html,1,['Guid'],['Guidelines']
Usability,"and calculator classes.; Offsetting is a feature of calculation in a fitting context; it enhances numerical precision by subtracting the initial likelihood value from the value that the minimizer sees, thus setting it to zero for the minimizer.; Since this does not impact the derivative terms, it does not affect the fitting result, except for added numerical precision. ## Calculators; `RooFit::TestStatistics` provides two abstract base classes for likelihood calculation: `LikelihoodWrapper` and `LikelihoodGradientWrapper`.; These are used by the `RooAbsMinimizerFcn` implementation `MinuitFcnGrad` which expects them to, respectively, provide likelihood and likelihood gradient values for use by `Minuit2` in fitting the pdf to the dataset. The `Wrapper`s can be implemented for different kinds of algorithms, or with different kinds of optimization ""back-ends"" in mind.; One implementation of each is ready for use in `RooFit` currently:. 1. `LikelihoodSerial` is more or less simply a rewrite of the existing serial calculation of a `RooNLLVar`.; 2. `LikelihoodGradientJob` calculates the partial derivatives or the gradient in parallel on multiple CPUs/cores, based on `RooFit::MultiProcess`, which is a fork-based multi-processing task execution framework with dynamic load balancing. Other possible implementations could use the GPU or external tools like TensorFlow. The coupling of all these classes to `RooMinimizer` is made via the `MinuitFcnGrad` class, which owns the `Wrappers` that calculate the likelihood components. Note: a second `LikelihoodWrapper` class called `LikelihoodJob` is also available.; This class emulates the existing `NumCPU(>1)` functionality of the `RooAbsTestStatistic` tree, which is implemented based on `RooRealMPFE`.; This class is not yet thoroughly tested and should not be considered production ready. ### Usage example: `MultiProcess` enabled parallel gradient calculator. The main selling point of using `RooFit::TestStatistics` from a performance poi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/test_statistics.md:7123,simpl,simply,7123,roofit/doc/developers/test_statistics.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/test_statistics.md,1,['simpl'],['simply']
Usability,"and non-core components. :doc:`SphinxQuickstartTemplate`; A template + tutorial for writing new Sphinx documentation. It is meant; to be read in source form. :doc:`HowToSubmitABug`; Instructions for properly submitting information about any bugs you run into; in the LLVM system. :doc:`BugLifeCycle`; Describes how bugs are reported, triaged and closed. :doc:`CodingStandards`; Details the LLVM coding standards and provides useful information on writing; efficient C++ code. :doc:`GitHub`; Describes how to use the llvm-project repository and code reviews on GitHub. :doc:`GitBisecting`; Describes how to use ``git bisect`` on LLVM's repository. :doc:`GitRepositoryPolicy`; Collection of policies around the git repositories. .. _development-process:. Development Process; -------------------. Information about LLVM's development process. .. toctree::; :hidden:. Projects; HowToReleaseLLVM; Packaging; ReleaseProcess; HowToAddABuilder; ReleaseNotes. :doc:`Projects`; How-to guide and templates for new projects that *use* the LLVM; infrastructure. The templates (directory organization, Makefiles, and test; tree) allow the project code to be located outside (or inside) the ``llvm/``; tree, while using LLVM header files and libraries. :doc:`HowToReleaseLLVM`; This is a guide to preparing LLVM releases. Most developers can ignore it. :doc:`ReleaseProcess`; This is a guide to validate a new release, during the release process. Most developers can ignore it. :doc:`HowToAddABuilder`; Instructions for adding new builder to LLVM buildbot master. :doc:`Packaging`; Advice on packaging LLVM into a distribution. :doc:`Release notes for the current release <ReleaseNotes>`; This describes new features, known bugs, and other limitations. .. _lists-forums:. Forums & Mailing Lists; ----------------------. If you can't find what you need in these docs, try consulting the; Discourse forums. There are also commit mailing lists for all commits to the LLVM Project.; The :doc:`CodeOfConduct` applies to",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingInvolved.rst:1601,guid,guide,1601,interpreter/llvm-project/llvm/docs/GettingInvolved.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingInvolved.rst,1,['guid'],['guide']
Usability,"and one test sample has; been rewritten completely. The new code is more performant and; has a clearer structure. This fixes several bugs which have been; reported by the TMVA users. On Minimization: . Variables, targets and spectators are now checked if they are; constant. (The execution of TMVA is stopped for variables and; targets, a warning is given for spectators.). On Regression:; ; The analysis type is no longer defined by calling a dedicated; TestAllMethods-member-function of the Factory, but with the; option ""AnalysisType"" in the Factory. The default value is; ""Auto"" where TMVA tries to determine the most suitable analysis; type from the targets and classes the user has defined. Other; values are ""regression"", ""classification"" and ""multiclass"" for; the forthcoming multiclass classification.; Missing regression evaluation plots for training sample were; added. On Cut method:. Removed obsolete option ""FVerySmart"" from Cuts method. On MLP method:; ; Display of convergence information in the progress bar for MLP during training. Creation of animated gifs for MLP convergence monitoring (please; contact authors if you want to do this). On Datasets: . Checks are performed if events are unvoluntarily cut by using a; non-filled array entry (e.g. ""arr[4]"" is used, when the array; has not always at least 5 entries). A warning is given in that; case.; Bug fixes. Spectators and Targets could not be used with by-hand assignment of events.; Corrected types (training/testing) for assigning single events.; Changed message from FATAL to WARNING when the user requests more events for ; training or testing than available.; Fixed bug which caused TMVA to crash if the number of input variables exceeded ; the allowed maximum for generating scatter plots.; Prevent TMVA from crashing when running with an empty TTree or TChain.; A variable expression like ""Alt$(arr[3],0)"" can now be used; to give a default value for a variable if for some events the; array don't contain enough eleme",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/doc/v526/index.html:2490,progress bar,progress bar,2490,tmva/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/doc/v526/index.html,1,['progress bar'],['progress bar']
Usability,"and parameter; attributes, an assume operand bundle my also encode a ``separate_storage``; operand bundle. This has the form:. .. code-block:: llvm. separate_storage(<val1>, <val2>)``. This indicates that no pointer :ref:`based <pointeraliasing>` on one of its; arguments can alias any pointer based on the other. Even if the assumed property can be encoded as a boolean value, like; ``nonnull``, using operand bundles to express the property can still have; benefits:. * Attributes that can be expressed via operand bundles are directly the; property that the optimizer uses and cares about. Encoding attributes as; operand bundles removes the need for an instruction sequence that represents; the property (e.g., `icmp ne ptr %p, null` for `nonnull`) and for the; optimizer to deduce the property from that instruction sequence.; * Expressing the property using operand bundles makes it easy to identify the; use of the value as a use in an :ref:`llvm.assume <int_assume>`. This then; simplifies and improves heuristics, e.g., for use ""use-sensitive""; optimizations. .. _ob_preallocated:. Preallocated Operand Bundles; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Preallocated operand bundles are characterized by the ``""preallocated""``; operand bundle tag. These operand bundles allow separation of the allocation; of the call argument memory from the call site. This is necessary to pass; non-trivially copyable objects by value in a way that is compatible with MSVC; on some targets. There can be at most one ``""preallocated""`` operand bundle; attached to a call site and it must have exactly one bundle operand, which is; a token generated by ``@llvm.call.preallocated.setup``. A call with this; operand bundle should not adjust the stack before entering the function, as; that will have been done by one of the ``@llvm.call.preallocated.*`` intrinsics. .. code-block:: llvm. %foo = type { i64, i32 }. ... %t = call token @llvm.call.preallocated.setup(i32 1); %a = call ptr @llvm.call.preallocated.arg(token %",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:126355,simpl,simplifies,126355,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['simpl'],['simplifies']
Usability,"and they fall into hierarchies. In addition, the ROOT has; fully cross-platform GUI classes and provides all standard components; for an application environment with common ‘look and feel'. The; object-oriented, event-driven programming model supports the modern; signals/slots communication mechanism. It handles user interface actions; and allows total independence of interacting objects and classes. This; mechanism uses the ROOT dictionary information and the Cling the C++; Interpreter to connect signals to slots methods. Therefore, all necessary elements for an object-oriented editor design; are in place. The editor complexity can be reduced by splitting it into; discrete units of so-called *`object`* *`editors`*. Any object editor; provides an object specific GUI. The main purpose of the ROOT graphics; editor is the organization of the object editors' appearance and the; task sequence between them. ### Object Editors. Every object editor follows a simple naming convention: to have as a; name the object class name concatenated with ‘*`Editor`*' (e.g. for; **`TGraph`** objects the object editor is **`TGraphEditor`**). Thanks to; the signals/slots communication mechanism and to the method; `DistancetoPrimitive()` that computes a ‘‘distance'' to an object from; the mouse position, it was possible to implement a signal method of the; canvas that says which is the selected object and to which pad it; belongs. Having this information the graphics editor loads the; corresponding object editor and the user interface is ready for use.; This way after a click on ‘axis'—the axis editor is active; a click on a; ‘pad' activates the pad editor, etc. The algorithm in use is simple and is based on the object-oriented; relationship and communication. When the user activates the editor,; according to the selected object **`<obj>`** in the canvas it looks for; a class name **`<obj>Editor`**. For that reason, the correct naming is; very important. If a class with this name is found, ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:102212,simpl,simple,102212,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,2,['simpl'],['simple']
Usability,"and: register, immediate, basic block, external; symbol, global address, constant pool index, or jump table index. For an; instruction with a memory address operand, the ``printMemOperand`` method; should be implemented to generate the proper output. Similarly,; ``printCCOperand`` should be used to print a conditional operand. ``doFinalization`` should be overridden in ``XXXAsmPrinter``, and it should be; called to shut down the assembly printer. During ``doFinalization``, global; variables and constants are printed to output. Subtarget Support; =================. Subtarget support is used to inform the code generation process of instruction; set variations for a given chip set. For example, the LLVM SPARC; implementation provided covers three major versions of the SPARC microprocessor; architecture: Version 8 (V8, which is a 32-bit architecture), Version 9 (V9, a; 64-bit architecture), and the UltraSPARC architecture. V8 has 16; double-precision floating-point registers that are also usable as either 32; single-precision or 8 quad-precision registers. V8 is also purely big-endian.; V9 has 32 double-precision floating-point registers that are also usable as 16; quad-precision registers, but cannot be used as single-precision registers.; The UltraSPARC architecture combines V9 with UltraSPARC Visual Instruction Set; extensions. If subtarget support is needed, you should implement a target-specific; ``XXXSubtarget`` class for your architecture. This class should process the; command-line options ``-mcpu=`` and ``-mattr=``. TableGen uses definitions in the ``Target.td`` and ``Sparc.td`` files to; generate code in ``SparcGenSubtarget.inc``. In ``Target.td``, shown below, the; ``SubtargetFeature`` interface is defined. The first 4 string parameters of; the ``SubtargetFeature`` interface are a feature name, a XXXSubtarget field set; by the feature, the value of the XXXSubtarget field, and a description of the; feature. (The fifth parameter is a list of features whose pres",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst:71689,usab,usable,71689,interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst,1,['usab'],['usable']
Usability,"and; `LLDB development <https://lldb.llvm.org/resources/build.html>`_. 11. Install psutil and obtain LLVM source code:. .. code-block:: bat. pip install psutil; git clone https://github.com/llvm/llvm-project.git llvm. Instead of ``git clone`` you may download a compressed source distribution; from the `releases page <https://github.com/llvm/llvm-project/releases>`_.; Select the last link: ``Source code (zip)`` and unpack the downloaded file using; Windows Explorer built-in zip support or any other unzip tool. 12. Finally, configure LLVM using CMake:. .. code-block:: bat. cmake -S llvm\llvm -B build -DLLVM_ENABLE_PROJECTS=clang -DLLVM_TARGETS_TO_BUILD=X86 -Thost=x64; exit. ``LLVM_ENABLE_PROJECTS`` specifies any additional LLVM projects you want to; build while ``LLVM_TARGETS_TO_BUILD`` selects the compiler targets. If; ``LLVM_TARGETS_TO_BUILD`` is omitted by default all targets are built; slowing compilation and using more disk space.; See the :doc:`LLVM CMake guide <CMake>` for detailed information about; how to configure the LLVM build. The ``cmake`` command line tool is bundled with Visual Studio but its GUI is; not. You may install `CMake <http://www.cmake.org/>`_ to use its GUI to change; CMake variables or modify the above command line. * Once CMake is installed then the simplest way is to just start the; CMake GUI, select the directory where you have LLVM extracted to, and; the default options should all be fine. One option you may really; want to change, regardless of anything else, might be the; ``CMAKE_INSTALL_PREFIX`` setting to select a directory to INSTALL to; once compiling is complete, although installation is not mandatory for; using LLVM. Another important option is ``LLVM_TARGETS_TO_BUILD``,; which controls the LLVM target architectures that are included on the; build.; * CMake generates project files for all build types. To select a specific; build type, use the Configuration manager from the VS IDE or the; ``/property:Configuration`` command line ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStartedVS.rst:5381,guid,guide,5381,interpreter/llvm-project/llvm/docs/GettingStartedVS.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStartedVS.rst,1,['guid'],['guide']
Usability,"andled before submission but understand that it isn't; possible to test all of this for every submission. Our build bots and nightly; testing infrastructure normally finds these problems. A good rule of thumb is; to check the nightly testers for regressions the day after your change. Build; bots will directly email you if a group of commits that included yours caused a; failure. You are expected to check the build bot messages to see if they are; your fault and, if so, fix the breakage. Commits that violate these quality standards (e.g. are very broken) may be; reverted. This is necessary when the change blocks other developers from making; progress. The developer is welcome to re-commit the change after the problem has; been fixed. .. _commit messages:. Commit messages; ---------------. Although we don't enforce the format of commit messages, we prefer that; you follow these guidelines to help review, search in logs, email formatting; and so on. These guidelines are very similar to rules used by other open source; projects. Most importantly, the contents of the message should be carefully written to; convey the rationale of the change (without delving too much in detail). It; also should avoid being vague or overly specific. For example, ""bits were not; set right"" will leave the reviewer wondering about which bits, and why they; weren't right, while ""Correctly set overflow bits in TargetInfo"" conveys almost; all there is to the change. Below are some guidelines about the format of the message itself:. * Separate the commit message into title and body separated by a blank line. * If you're not the original author, ensure the 'Author' property of the commit is; set to the original author and the 'Committer' property is set to yourself.; You can use a command similar to; ``git commit --amend --author=""John Doe <jdoe@llvm.org>""`` to correct the; author property if it is incorrect. See `Attribution of Changes`_ for more; information including the method we used for attr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst:15010,guid,guidelines,15010,interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,1,['guid'],['guidelines']
Usability,"andlers; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Error recovery attempts may themselves fail. For that reason, ``handleErrors``; actually recognises three different forms of handler signature:. .. code-block:: c++. // Error must be handled, no new errors produced:; void(UserDefinedError &E);. // Error must be handled, new errors can be produced:; Error(UserDefinedError &E);. // Original error can be inspected, then re-wrapped and returned (or a new; // error can be produced):; Error(std::unique_ptr<UserDefinedError> E);. Any error returned from a handler will be returned from the ``handleErrors``; function so that it can be handled itself, or propagated up the stack. .. _err_exitonerr:. Using ExitOnError to simplify tool code; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Library code should never call ``exit`` for a recoverable error, however in tool; code (especially command line tools) this can be a reasonable approach. Calling; ``exit`` upon encountering an error dramatically simplifies control flow as the; error no longer needs to be propagated up the stack. This allows code to be; written in straight-line style, as long as each fallible call is wrapped in a; check and call to exit. The ``ExitOnError`` class supports this pattern by; providing call operators that inspect ``Error`` values, stripping the error away; in the success case and logging to ``stderr`` then exiting in the failure case. To use this class, declare a global ``ExitOnError`` variable in your program:. .. code-block:: c++. ExitOnError ExitOnErr;. Calls to fallible functions can then be wrapped with a call to ``ExitOnErr``,; turning them into non-failing calls:. .. code-block:: c++. Error mayFail();; Expected<int> mayFail2();. void foo() {; ExitOnErr(mayFail());; int X = ExitOnErr(mayFail2());; }. On failure, the error's log message will be written to ``stderr``, optionally; preceded by a string ""banner"" that can be set by calling the setBanner method. A; mapping can also be supplied from ``Error`` val",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:30618,simpl,simplifies,30618,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['simpl'],['simplifies']
Usability,"ang++ -g -fsanitize-coverage=trace-pc-guard trace-pc-guard-example.cc -c; clang++ trace-pc-guard-cb.cc trace-pc-guard-example.o -fsanitize=address; ASAN_OPTIONS=strip_path_prefix=`pwd`/ ./a.out. .. code-block:: console. INIT: 0x71bcd0 0x71bce0; guard: 0x71bcd4 2 PC 0x4ecd5b in main trace-pc-guard-example.cc:2; guard: 0x71bcd8 3 PC 0x4ecd9e in main trace-pc-guard-example.cc:3:7. .. code-block:: console. ASAN_OPTIONS=strip_path_prefix=`pwd`/ ./a.out with-foo. .. code-block:: console. INIT: 0x71bcd0 0x71bce0; guard: 0x71bcd4 2 PC 0x4ecd5b in main trace-pc-guard-example.cc:3; guard: 0x71bcdc 4 PC 0x4ecdc7 in main trace-pc-guard-example.cc:4:17; guard: 0x71bcd0 1 PC 0x4ecd20 in foo() trace-pc-guard-example.cc:2:14. Inline 8bit-counters; ====================. **Experimental, may change or disappear in future**. With ``-fsanitize-coverage=inline-8bit-counters`` the compiler will insert; inline counter increments on every edge.; This is similar to ``-fsanitize-coverage=trace-pc-guard`` but instead of a; callback the instrumentation simply increments a counter. Users need to implement a single function to capture the counters at startup. .. code-block:: c++. extern ""C""; void __sanitizer_cov_8bit_counters_init(char *start, char *end) {; // [start,end) is the array of 8-bit counters created for the current DSO.; // Capture this array in order to read/modify the counters.; }. Inline bool-flag; ================. **Experimental, may change or disappear in future**. With ``-fsanitize-coverage=inline-bool-flag`` the compiler will insert; setting an inline boolean to true on every edge.; This is similar to ``-fsanitize-coverage=inline-8bit-counter`` but instead of; an increment of a counter, it just sets a boolean to true. Users need to implement a single function to capture the flags at startup. .. code-block:: c++. extern ""C""; void __sanitizer_cov_bool_flag_init(bool *start, bool *end) {; // [start,end) is the array of boolean flags created for the current DSO.; // Capture this arr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerCoverage.rst:4485,simpl,simply,4485,interpreter/llvm-project/clang/docs/SanitizerCoverage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerCoverage.rst,1,['simpl'],['simply']
Usability,ang-tidy/readability/RedundantControlFlowCheck.cpp; clang-tools-extra/clang-tidy/readability/RedundantControlFlowCheck.h; clang-tools-extra/clang-tidy/readability/RedundantDeclarationCheck.cpp; clang-tools-extra/clang-tidy/readability/RedundantDeclarationCheck.h; clang-tools-extra/clang-tidy/readability/RedundantMemberInitCheck.cpp; clang-tools-extra/clang-tidy/readability/RedundantMemberInitCheck.h; clang-tools-extra/clang-tidy/readability/RedundantPreprocessorCheck.cpp; clang-tools-extra/clang-tidy/readability/RedundantPreprocessorCheck.h; clang-tools-extra/clang-tidy/readability/RedundantSmartptrGetCheck.cpp; clang-tools-extra/clang-tidy/readability/RedundantSmartptrGetCheck.h; clang-tools-extra/clang-tidy/readability/RedundantStringCStrCheck.h; clang-tools-extra/clang-tidy/readability/RedundantStringInitCheck.cpp; clang-tools-extra/clang-tidy/readability/RedundantStringInitCheck.h; clang-tools-extra/clang-tidy/readability/SimplifyBooleanExprCheck.cpp; clang-tools-extra/clang-tidy/readability/SimplifyBooleanExprCheck.h; clang-tools-extra/clang-tidy/readability/SimplifyBooleanExprMatchers.h; clang-tools-extra/clang-tidy/readability/SimplifySubscriptExprCheck.cpp; clang-tools-extra/clang-tidy/readability/StaticAccessedThroughInstanceCheck.cpp; clang-tools-extra/clang-tidy/readability/StaticAccessedThroughInstanceCheck.h; clang-tools-extra/clang-tidy/readability/StaticDefinitionInAnonymousNamespaceCheck.cpp; clang-tools-extra/clang-tidy/readability/StaticDefinitionInAnonymousNamespaceCheck.h; clang-tools-extra/clang-tidy/readability/StringCompareCheck.cpp; clang-tools-extra/clang-tidy/readability/StringCompareCheck.h; clang-tools-extra/clang-tidy/readability/SuspiciousCallArgumentCheck.cpp; clang-tools-extra/clang-tidy/readability/SuspiciousCallArgumentCheck.h; clang-tools-extra/clang-tidy/readability/UniqueptrDeleteReleaseCheck.cpp; clang-tools-extra/clang-tidy/readability/UniqueptrDeleteReleaseCheck.h; clang-tools-extra/clang-tidy/readability/UppercaseLiteralSuffix,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt:70797,Simpl,SimplifyBooleanExprCheck,70797,interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,1,['Simpl'],['SimplifyBooleanExprCheck']
Usability,ang-tidy/readability/RedundantControlFlowCheck.h; clang-tools-extra/clang-tidy/readability/RedundantDeclarationCheck.cpp; clang-tools-extra/clang-tidy/readability/RedundantDeclarationCheck.h; clang-tools-extra/clang-tidy/readability/RedundantMemberInitCheck.cpp; clang-tools-extra/clang-tidy/readability/RedundantMemberInitCheck.h; clang-tools-extra/clang-tidy/readability/RedundantPreprocessorCheck.cpp; clang-tools-extra/clang-tidy/readability/RedundantPreprocessorCheck.h; clang-tools-extra/clang-tidy/readability/RedundantSmartptrGetCheck.cpp; clang-tools-extra/clang-tidy/readability/RedundantSmartptrGetCheck.h; clang-tools-extra/clang-tidy/readability/RedundantStringCStrCheck.h; clang-tools-extra/clang-tidy/readability/RedundantStringInitCheck.cpp; clang-tools-extra/clang-tidy/readability/RedundantStringInitCheck.h; clang-tools-extra/clang-tidy/readability/SimplifyBooleanExprCheck.cpp; clang-tools-extra/clang-tidy/readability/SimplifyBooleanExprCheck.h; clang-tools-extra/clang-tidy/readability/SimplifyBooleanExprMatchers.h; clang-tools-extra/clang-tidy/readability/SimplifySubscriptExprCheck.cpp; clang-tools-extra/clang-tidy/readability/StaticAccessedThroughInstanceCheck.cpp; clang-tools-extra/clang-tidy/readability/StaticAccessedThroughInstanceCheck.h; clang-tools-extra/clang-tidy/readability/StaticDefinitionInAnonymousNamespaceCheck.cpp; clang-tools-extra/clang-tidy/readability/StaticDefinitionInAnonymousNamespaceCheck.h; clang-tools-extra/clang-tidy/readability/StringCompareCheck.cpp; clang-tools-extra/clang-tidy/readability/StringCompareCheck.h; clang-tools-extra/clang-tidy/readability/SuspiciousCallArgumentCheck.cpp; clang-tools-extra/clang-tidy/readability/SuspiciousCallArgumentCheck.h; clang-tools-extra/clang-tidy/readability/UniqueptrDeleteReleaseCheck.cpp; clang-tools-extra/clang-tidy/readability/UniqueptrDeleteReleaseCheck.h; clang-tools-extra/clang-tidy/readability/UppercaseLiteralSuffixCheck.cpp; clang-tools-extra/clang-tidy/readability/UppercaseLiteralSuf,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt:70866,Simpl,SimplifyBooleanExprMatchers,70866,interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,1,['Simpl'],['SimplifyBooleanExprMatchers']
Usability,"ansion pass, you can; specify the machine copy propagation pass in the ``-stop-after`` option, as it; runs just before the pass that we are trying to test:. ``llc -stop-after=machine-cp bug-trigger.ll -o test.mir``. If the same pass is run multiple times, a run index can be included; after the name with a comma. ``llc -stop-after=dead-mi-elimination,1 bug-trigger.ll -o test.mir``. After generating the input MIR file, you'll have to add a run line that uses; the ``-run-pass`` option to it. In order to test the post register allocation; pseudo instruction expansion pass on X86-64, a run line like the one shown; below can be used:. ``# RUN: llc -o - %s -mtriple=x86_64-- -run-pass=postrapseudos | FileCheck %s``. The MIR files are target dependent, so they have to be placed in the target; specific test directories (``lib/CodeGen/TARGETNAME``). They also need to; specify a target triple or a target architecture either in the run line or in; the embedded LLVM IR module. Simplifying MIR files; ^^^^^^^^^^^^^^^^^^^^^. The MIR code coming out of ``-stop-after``/``-stop-before`` is very verbose;; Tests are more accessible and future proof when simplified:. - Use the ``-simplify-mir`` option with llc. - Machine function attributes often have default values or the test works just; as well with default values. Typical candidates for this are: `alignment:`,; `exposesReturnsTwice`, `legalized`, `regBankSelected`, `selected`.; The whole `frameInfo` section is often unnecessary if there is no special; frame usage in the function. `tracksRegLiveness` on the other hand is often; necessary for some passes that care about block livein lists. - The (global) `liveins:` list is typically only interesting for early; instruction selection passes and can be removed when testing later passes.; The per-block `liveins:` on the other hand are necessary if; `tracksRegLiveness` is true. - Branch probability data in block `successors:` lists can be dropped if the; test doesn't depend on it. Example:; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MIRLangRef.rst:2964,Simpl,Simplifying,2964,interpreter/llvm-project/llvm/docs/MIRLangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MIRLangRef.rst,1,['Simpl'],['Simplifying']
Usability,"anteed to succeed when the; /// callback executes. Pass in NULL to remove any callback.; typedef void (*dfsan_write_callback_t)(int fd, const void *buf, size_t count);; void dfsan_set_write_callback(dfsan_write_callback_t labeled_write_callback);. /// Callbacks to be invoked on calls to `memcmp` or `strncmp`.; void dfsan_weak_hook_memcmp(void *caller_pc, const void *s1, const void *s2,; size_t n, dfsan_label s1_label,; dfsan_label s2_label, dfsan_label n_label);; void dfsan_weak_hook_strncmp(void *caller_pc, const char *s1, const char *s2,; size_t n, dfsan_label s1_label,; dfsan_label s2_label, dfsan_label n_label);. Taint label representation; --------------------------. We use an 8-bit unsigned integer for the representation of a; label. The label identifier 0 is special, and means that the data item; is unlabelled. This is optimizing for low CPU and code size overhead; of the instrumentation. When a label union operation is requested at a; join point (any arithmetic or logical operation with two or more; operands, such as addition), we can simply OR the two labels in O(1). Users are responsible for managing the 8 integer labels (i.e., keeping; track of what labels they have used so far, picking one that is yet; unused, etc). Origin tracking trace representation; ------------------------------------. An origin tracking trace is a list of chains. Each chain has a stack trace; where the DFSan runtime records a label propagation, and a pointer to its; previous chain. The very first chain does not point to any chain. Every four 4-bytes aligned application bytes share a 4-byte origin trace ID. A; 4-byte origin trace ID contains a 4-bit depth and a 28-bit hash ID of a chain. A chain ID is calculated as a hash from a chain structure. A chain structure; contains a stack ID and the previous chain ID. The chain head has a zero; previous chain ID. A stack ID is a hash from a stack trace. The 4-bit depth; limits the maximal length of a path. The environment variable ``origin_",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst:5926,simpl,simply,5926,interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst,1,['simpl'],['simply']
Usability,"antiated. However, in the case of; ``bar.cpp`` we use the constructor with number ``(2)``, which does not; explicitly initialize the ``a`` member, so the default ``InitListExpr`` is; needed and thus instantiated. When we merge the AST of ``foo.cpp`` and; ``bar.cpp`` we must create an AST node for the class template instantiation of; ``X<char>`` which has all the required nodes. Therefore, when we find an; existing ``ClassTemplateSpecializationDecl`` then we merge the fields of the; ``ClassTemplateSpecializationDecl`` in the ""from"" context in a way that the; ``InitListExpr`` is copied if not existent yet. The same merge mechanism should; be done in the cases of instantiated default arguments and exception; specifications of functions. .. _visibility:. Visibility of Declarations; ^^^^^^^^^^^^^^^^^^^^^^^^^^. During import of a global variable with external visibility, the lookup will; find variables (with the same name) but with static visibility (linkage).; Clearly, we cannot put them into the same redeclaration chain. The same is true; the in case of functions. Also, we have to take care of other kinds of; declarations like enums, classes, etc. if they are in anonymous namespaces.; Therefore, we filter the lookup results and consider only those which have the; same visibility as the declaration we currently import. We consider two declarations in two anonymous namespaces to have the same; visibility only if they are imported from the same AST context. Strategies to Handle Conflicting Names; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. During the import we lookup existing declarations with the same name. We filter; the lookup results based on their :ref:`visibility <visibility>`. If any of the; found declarations are not structurally equivalent then we bumped to a name; conflict error (ODR violation in C++). In this case, we return with an; ``Error`` and we set up the ``Error`` object for the declaration. However, some; clients of the ``ASTImporter`` may require a differen",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:110153,Clear,Clearly,110153,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['Clear'],['Clearly']
Usability,"anual.html#Statistic>`_ to your pass, which will; tally counts of things you care about. Following this, you can set up a test and a report that collects these; and formats them for easy viewing. This consists of two files, a; ""``test-suite/TEST.XXX.Makefile``"" fragment (where XXX is the name of; your test) and a ""``test-suite/TEST.XXX.report``"" file that indicates; how to format the output into a table. There are many example reports of; various levels of sophistication included with the test suite, and the; framework is very general. If you are interested in testing an optimization pass, check out the; ""libcalls"" test as an example. It can be run like this:. .. code-block:: bash. % cd llvm/projects/test-suite/MultiSource/Benchmarks # or some other level; % make TEST=libcalls report. This will do a bunch of stuff, then eventually print a table like this:. ::. Name | total | #exit |; ...; FreeBench/analyzer/analyzer | 51 | 6 |; FreeBench/fourinarow/fourinarow | 1 | 1 |; FreeBench/neural/neural | 19 | 9 |; FreeBench/pifft/pifft | 5 | 3 |; MallocBench/cfrac/cfrac | 1 | * |; MallocBench/espresso/espresso | 52 | 12 |; MallocBench/gs/gs | 4 | * |; Prolangs-C/TimberWolfMC/timberwolfmc | 302 | * |; Prolangs-C/agrep/agrep | 33 | 12 |; Prolangs-C/allroots/allroots | * | * |; Prolangs-C/assembler/assembler | 47 | * |; Prolangs-C/bison/mybison | 74 | * |; ... This basically is grepping the -stats output and displaying it in a; table. You can also use the ""TEST=libcalls report.html"" target to get; the table in HTML form, similarly for report.csv and report.tex. The source for this is in ``test-suite/TEST.libcalls.*``. The format is; pretty simple: the Makefile indicates how to run the test (in this case,; ""``opt -simplify-libcalls -stats``""), and the report contains one line; for each column of the output. The first value is the header for the; column and the second is the regex to grep the output of the command; for. There are lots of example reports that can do fancy stuff.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestSuiteMakefileGuide.rst:7232,simpl,simple,7232,interpreter/llvm-project/llvm/docs/TestSuiteMakefileGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestSuiteMakefileGuide.rst,2,['simpl'],"['simple', 'simplify-libcalls']"
Usability,"anup]. In this case, the coroutine frame would include a suspend index that will; indicate at which suspend point the coroutine needs to resume. .. code-block:: llvm. %f.frame = type { ptr, ptr, i32, i32 }. The resume function will use an index to jump to an appropriate basic block and will look; as follows:. .. code-block:: llvm. define internal fastcc void @f.Resume(ptr %FramePtr) {; entry.Resume:; %index.addr = getelementptr inbounds %f.Frame, ptr %FramePtr, i64 0, i32 2; %index = load i8, ptr %index.addr, align 1; %switch = icmp eq i8 %index, 0; %n.addr = getelementptr inbounds %f.Frame, ptr %FramePtr, i64 0, i32 3; %n = load i32, ptr %n.addr, align 4. br i1 %switch, label %loop.resume, label %loop. loop.resume:; %sub = sub nsw i32 0, %n; call void @print(i32 %sub); br label %suspend; loop:; %inc = add nsw i32 %n, 1; store i32 %inc, ptr %n.addr, align 4; tail call void @print(i32 %inc); br label %suspend. suspend:; %storemerge = phi i8 [ 0, %loop ], [ 1, %loop.resume ]; store i8 %storemerge, ptr %index.addr, align 1; ret void; }. If different cleanup code needs to get executed for different suspend points,; a similar switch will be in the `f.destroy` function. .. note ::. Using suspend index in a coroutine state and having a switch in `f.resume` and; `f.destroy` is one of the possible implementation strategies. We explored; another option where a distinct `f.resume1`, `f.resume2`, etc. are created for; every suspend point, and instead of storing an index, the resume and destroy; function pointers are updated at every suspend. Early testing showed that the; current approach is easier on the optimizer than the latter so it is a; lowering strategy implemented at the moment. Distinct Save and Suspend; -------------------------. In the previous example, setting a resume index (or some other state change that; needs to happen to prepare a coroutine for resumption) happens at the same time as; a suspension of a coroutine. However, in certain cases, it is necessary to co",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:19764,resume,resume,19764,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"any case, if the; composition/decomposition of the class is explicitly coded, the user should include; the byte count, class information, and version number of the class before the data on; disk as shown in \ref dobject. The special method used for streaming a TClonesArray is described in the TClonesArray; section below. More information on the StreamerInfo record and its use is found in the; [Input/Output chapter of the Root Manual](https://root.cern/manual/storing_root_objects/). NOTE: Some of the classes used internally in ROOTIO (e.g. TObject, TRef, TRefArray); have explicitly coded (de)compositions, and do not use the information in the; StreamerInfo record to do the (de)composition. In this case, the StreamerInfo for; the class may still be present in the StreamerInfo record, but may not match what is; actually written to disk for those objects. \anchor ptpo; ## Pointers to persistent objects. These were introduced in release 3.02, so there is not yet a description in the current; Root Users Guide, which is for a version release 3.1. Here we discuss only the information; on disk. A ROOT file contains zero or more TProcessID records. Each such record contains a globally; unique ID defining a given ROOT job that wrote a referenced object (see \ref tprocessid).; Each referenced object contains a ""pidf"" field referencing the corresponding TProcessID; record and an ""fUniqueID"" field uniquely identifying the referenced object among those; written by that process (see \ref tobject). Similarly, every persistent reference to that; object (a TRef Object, see \ref tref) also contains ""pidf"" and ""fUniqueID"" fields with the; same value, thereby uniquely determining the referenced object (which need not even be in the; same file). In the case of an array of references (a TRefArray object, see \ref trefarray),; there is one ""pidf"" value for the entire array, and a separate ""fUniqueID"" value for each; reference. For further information, see the above URL. ## Some useful contai",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/doc/TFile/README.md:10838,Guid,Guide,10838,io/doc/TFile/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/doc/TFile/README.md,1,['Guid'],['Guide']
Usability,"any cases it makes sense to build a special fuzzing-friendly build; with certain fuzzing-unfriendly features disabled. We propose to use a common build macro; for all such cases for consistency: ``FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION``. .. code-block:: c++. void MyInitPRNG() {; #ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION; // In fuzzing mode the behavior of the code should be deterministic.; srand(0);; #else; srand(time(0));; #endif; }. AFL compatibility; -----------------; LibFuzzer can be used together with AFL_ on the same test corpus.; Both fuzzers expect the test corpus to reside in a directory, one file per input.; You can run both fuzzers on the same corpus, one after another:. .. code-block:: console. ./afl-fuzz -i testcase_dir -o findings_dir /path/to/program @@; ./llvm-fuzz testcase_dir findings_dir # Will write new tests to testcase_dir. Periodically restart both fuzzers so that they can use each other's findings.; Currently, there is no simple way to run both fuzzing engines in parallel while sharing the same corpus dir. You may also use AFL on your target function ``LLVMFuzzerTestOneInput``:; see an example `here <https://github.com/llvm/llvm-project/tree/main/compiler-rt/lib/fuzzer/afl>`__. How good is my fuzzer?; ----------------------. Once you implement your target function ``LLVMFuzzerTestOneInput`` and fuzz it to death,; you will want to know whether the function or the corpus can be improved further.; One easy to use metric is, of course, code coverage. We recommend to use; `Clang Coverage <https://clang.llvm.org/docs/SourceBasedCodeCoverage.html>`_,; to visualize and study your code coverage; (`example <https://github.com/google/fuzzer-test-suite/blob/master/tutorial/libFuzzerTutorial.md#visualizing-coverage>`_). User-supplied mutators; ----------------------. LibFuzzer allows to use custom (user-supplied) mutators, see; `Structure-Aware Fuzzing <https://github.com/google/fuzzing/blob/master/docs/structure-aware-fuzzing.md>`_; for more de",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst:22757,simpl,simple,22757,interpreter/llvm-project/llvm/docs/LibFuzzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst,1,['simpl'],['simple']
Usability,"any times the same objects, are created; and deleted. The only supported way to add objects to a; **`TClonesArray`** is via the `new` with placement method. The different; `Add()` methods of **`TObjArray`** and its base classes are not; supported. ### The Idea Behind TClonesArray. To reduce the very large number of new and delete calls in large loops; like this (O(100000) x O(10000) times new/delete):. ``` {.cpp}; TObjArray a(10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000); for (int i = 0; i < ev->Ntracks; i++) { // O(10000); a[i] = new TTrack(x,y,z,...);; ...; }; ...; a.Delete();; }; ```. You better use a **`TClonesArray`** which reduces the number of; new/delete calls to only O(10000):. ``` {.cpp}; TClonesArray a(""TTrack"", 10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000); for (int i = 0; i < ev->Ntracks; i++) { // O(10000); TTrack *track = (Track*)a.ConstructedAt(i);; track->Set(x,y,z,...);; ...; }; ...; a.Clear(); // Or Clear(""C"") if the track objects must be returned (via Track::Clear) to a default state.; }; ```. Considering that a pair of new/delete calls on average cost about 70 ms,; O(109) new/deletes will save about 19 hours. For the other collections,; see the class reference guide on the web and the test program; `$ROOTSYS/test/tcollex.cxx.`. ## Template Containers and STL. Some people dislike polymorphic containers because they are not truly; ""type safe"". In the end, the compiler leaves it the user to ensure that; the types are correct. This only leaves the other alternative: creating; a new class each time a new (container organization) / (contained; object) combination is needed. To say the least this could be very; tedious. Most people faced with this choice would, for each type of; container:. Define the class leaving a dummy name for the contained object type.; When a particular container was needed, copy the code and then do a; global search and replace for the contained class. C++ has a built in; template scheme that eff",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md:17589,Clear,Clear,17589,documentation/users-guide/CollectionClasses.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md,3,['Clear'],['Clear']
Usability,"ap<[...], double>>' for 1st argument;. -fno-elide-type: template diff without elision. t.cc:4:5: note: candidate function not viable: no known conversion from 'vector<map<int, float>>' to 'vector<map<int, double>>' for 1st argument;. -fdiagnostics-show-template-tree: template tree printing with elision. t.cc:4:5: note: candidate function not viable: no known conversion for 1st argument;; vector<; map<; [...],; [float != double]>>. -fdiagnostics-show-template-tree -fno-elide-type: template tree printing with no elision. t.cc:4:5: note: candidate function not viable: no known conversion for 1st argument;; vector<; map<; int,; [float != double]>>. Automatic Macro Expansion; Many errors happen in macros that are sometimes deeply nested. With; traditional compilers, you need to dig deep into the definition of the macro to; understand how you got into trouble. The following simple example shows how; Clang helps you out by automatically printing instantiation information and; nested range information for diagnostics as they are instantiated through macros; and also shows how some of the other pieces work in a bigger example. $ clang -fsyntax-only t.c; t.c:80:3: error: invalid operands to binary expression ('typeof(P)' (aka 'struct mystruct') and 'typeof(F)' (aka 'float')); X = MYMAX(P, F);; ^~~~~~~~~~~; t.c:76:94: note: expanded from:; #define MYMAX(A,B) __extension__ ({ __typeof__(A) __a = (A); __typeof__(B) __b = (B); __a < __b ? __b : __a; }); ~~~ ^ ~~~. Here's another real world warning that occurs in the ""window"" Unix package (which; implements the ""wwopen"" class of APIs):. $ clang -fsyntax-only t.c; t.c:22:2: warning: type specifier missing, defaults to 'int'; ILPAD();; ^; t.c:17:17: note: expanded from:; #define ILPAD() PAD((NROW - tt.tt_row) * 10) /* 1 ms per char */; ^; t.c:14:2: note: expanded from:; register i; \; ^. In practice, we've found that Clang's treatment of macros is actually more useful in multiply nested; macros than in simple ones.; Quality of Implem",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html:8873,simpl,simple,8873,interpreter/llvm-project/clang/www/diagnostics.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html,1,['simpl'],['simple']
Usability,"applied; earlier in the pipeline. Async Lowering; --------------. In async-continuation lowering, signaled by the use of `llvm.coro.id.async`,; handling of control-flow must be handled explicitly by the frontend. In this lowering, a coroutine is assumed to take the current `async context` as; one of its arguments (the argument position is determined by; `llvm.coro.id.async`). It is used to marshal arguments and return values of the; coroutine. Therefore an async coroutine returns `void`. .. code-block:: llvm. define swiftcc void @async_coroutine(ptr %async.ctxt, ptr, ptr) {; }. Values live across a suspend point need to be stored in the coroutine frame to; be available in the continuation function. This frame is stored as a tail to the; `async context`. Every suspend point takes an `context projection function` argument which; describes how-to obtain the continuations `async context` and every suspend; point has an associated `resume function` denoted by the; `llvm.coro.async.resume` intrinsic. The coroutine is resumed by calling this; `resume function` passing the `async context` as the one of its arguments; argument. The `resume function` can restore its (the caller's) `async context`; by applying a `context projection function` that is provided by the frontend as; a parameter to the `llvm.coro.suspend.async` intrinsic. .. code-block:: c. // For example:; struct async_context {; struct async_context *caller_context;; ...; }. char *context_projection_function(struct async_context *callee_ctxt) {; return callee_ctxt->caller_context;; }. .. code-block:: llvm. %resume_func_ptr = call ptr @llvm.coro.async.resume(); call {ptr, ptr, ptr} (ptr, ptr, ...) @llvm.coro.suspend.async(; ptr %resume_func_ptr,; ptr %context_projection_function. The frontend should provide a `async function pointer` struct associated with; each async coroutine by `llvm.coro.id.async`'s argument. The initial size and; alignment of the `async context` must be provided as arguments to the; `llvm.coro",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:8605,resume,resume,8605,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"apsed time is less than a second. ### Examples of Using the Generators. The method `Rndm()` is used for generating a pseudo-random number; distributed between 0 and 1 as shown in the following example:. ``` {.cpp}; // use default seed; // (same random numbers will be generated each time); TRandom3 r; // generate a number in interval ]0,1] (0 is excluded); r.Rndm();; double x[100];; r.RndmArray(100,x); // generate an array of random numbers in ]0,1]; TRandom3 rdm(111); // construct with a user-defined seed; // use 0: a unique seed will be automatically generated using TUUID; TRandom1 r1(0);; TRandom2 r2(0);; TRandom3 r3(0);; // seed generated using machine clock (different every second); TRandom r0(0);; ```. ### Random Number Distributions. The **`TRandom`** base class provides functions, which can be used by; all the other derived classes for generating random variates according; to predefined distributions. In the simplest cases, like in the case of; the exponential distribution, the non-uniform random number is obtained; by applying appropriate transformations. In the more complicated cases,; random variates are obtained using acceptance-rejection methods, which; require several random numbers. ``` {.cpp}; TRandom3 r;; // generate a gaussian distributed number with:; // mu=0, sigma=1 (default values); double x1 = r.Gaus();; double x2 = r.Gaus(10,3); // use mu = 10, sigma = 3;; ```. The following table shows the various distributions that can be; generated using methods of the **`TRandom`** classes. More information; is available in the reference documentation for **`TRandom`**. In; addition, random numbers distributed according to a user defined; function, in a limited interval, or to a user defined histogram, can be; generated in a very efficient way using **`TF1::`**GetRandom() or; **`TH1::`**GetRandom(). +-------------------------------------------+--------------------------------+; | Distributions | Description |; +-------------------------------------------+-",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:15109,simpl,simplest,15109,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['simpl'],['simplest']
Usability,"apture, you don't; subclass a parser. This means that you don't have to write **any**; boilerplate code. #. Globally accessible: Libraries can specify command line arguments that are; automatically enabled in any tool that links to the library. This is; possible because the application doesn't have to keep a list of arguments to; pass to the parser. This also makes supporting `dynamically loaded options`_; trivial. #. Cleaner: CommandLine supports enum and other types directly, meaning that; there is less error and more security built into the library. You don't have; to worry about whether your integral command line argument accidentally got; assigned a value that is not valid for your enum type. #. Powerful: The CommandLine library supports many different types of arguments,; from simple `boolean flags`_ to `scalars arguments`_ (`strings`_,; `integers`_, `enums`_, `doubles`_), to `lists of arguments`_. This is; possible because CommandLine is... #. Extensible: It is very simple to add a new argument type to CommandLine.; Simply specify the parser that you want to use with the command line option; when you declare it. `Custom parsers`_ are no problem. #. Labor Saving: The CommandLine library cuts down on the amount of grunt work; that you, the user, have to do. For example, it automatically provides a; ``-help`` option that shows the available command line options for your tool.; Additionally, it does most of the basic correctness checking for you. #. Capable: The CommandLine library can handle lots of different forms of; options often found in real programs. For example, `positional`_ arguments,; ``ls`` style `grouping`_ options (to allow processing '``ls -lad``'; naturally), ``ld`` style `prefix`_ options (to parse '``-lmalloc; -L/usr/lib``'), and interpreter style options. This document will hopefully let you jump in and start using CommandLine in your; utility quickly and painlessly. Additionally it should be a simple reference; manual to figure out how stuff wo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst:2618,simpl,simple,2618,interpreter/llvm-project/llvm/docs/CommandLine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst,1,['simpl'],['simple']
Usability,"arameters after the lambda, indent the block two spaces from the indent of the; ``[]``:. .. code-block:: c++. dyn_switch(V->stripPointerCasts(),; [] (PHINode *PN) {; // process phis...; },; [] (SelectInst *SI) {; // process selects...; },; [] (LoadInst *LI) {; // process loads...; },; [] (AllocaInst *AI) {; // process allocas...; });. Braced Initializer Lists; """""""""""""""""""""""""""""""""""""""""""""""". Starting from C++11, there are significantly more uses of braced lists to; perform initialization. For example, they can be used to construct aggregate; temporaries in expressions. They now have a natural way of ending up nested; within each other and within function calls in order to build up aggregates; (such as option structs) from local variables. The historically common formatting of braced initialization of aggregate; variables does not mix cleanly with deep nesting, general expression contexts,; function arguments, and lambdas. We suggest new code use a simple rule for; formatting braced initialization lists: act as-if the braces were parentheses; in a function call. The formatting rules exactly match those already well; understood for formatting nested function calls. Examples:. .. code-block:: c++. foo({a, b, c}, {1, 2, 3});. llvm::Constant *Mask[] = {; llvm::ConstantInt::get(llvm::Type::getInt32Ty(getLLVMContext()), 0),; llvm::ConstantInt::get(llvm::Type::getInt32Ty(getLLVMContext()), 1),; llvm::ConstantInt::get(llvm::Type::getInt32Ty(getLLVMContext()), 2)};. This formatting scheme also makes it particularly easy to get predictable,; consistent, and automatic formatting with tools like `Clang Format`_. .. _Clang Format: https://clang.llvm.org/docs/ClangFormat.html. Language and Compiler Issues; ----------------------------. Treat Compiler Warnings Like Errors; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Compiler warnings are often useful and help improve the code. Those that are; not useful, can be often suppressed with a small code change. For example, an; assignment in the ``if``",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst:20688,simpl,simple,20688,interpreter/llvm-project/llvm/docs/CodingStandards.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst,1,['simpl'],['simple']
Usability,"arate sub ranges of the same histogram. To use a Gaussian, or; any other ROOT built in function, on a sub range you need to define a; new **`TF1`**. Each is 'derived' from the canned function `gaus`. ![Fitting a histogram with several Gaussian; functions](pictures/03000062.png). First, four **`TF1`** objects are created - one for each sub-range:. ``` {.cpp}; g1 = new TF1(""m1"",""gaus"",85,95);; g2 = new TF1(""m2"",""gaus"",98,108);; g3 = new TF1(""m3"",""gaus"",110,121);; // The total is the sum of the three, each has 3 parameters; total = new TF1(""mstotal"",""gaus(0)+gaus(3)+gaus(6)"",85,125);; ```. Next, we fill a histogram with bins defined in the array x. ``` {.cpp}; // Create a histogram and set it's contents; h = new TH1F(""g1"",""Example of several fits in subranges"",; np,85,134);; h->SetMaximum(7);; for (int i=0; i<np; i++) {; h->SetBinContent(i+1,x[i]);; }; // Define the parameter array for the total function; Double_t par[9];; ```. When fitting simple functions, such as a Gaussian, the initial values; of the parameters are automatically computed by ROOT. In the more; complicated case of the sum of 3 Gaussian functions, the initial; values of parameters must be set. In this particular case, the initial; values are taken from the result of the individual fits. The use of; the ""+"" sign is explained below:. ``` {.cpp}; // Fit each function and add it to the list of functions; h->Fit(g1,""R"");; h->Fit(g2,""R+"");; h->Fit(g3,""R+"");. // Get the parameters from the fit; g1->GetParameters(&par[0]);; g2->GetParameters(&par[3]);; g3->GetParameters(&par[6]);. // Use the parameters on the sum; total->SetParameters(par);; h->Fit(total,""R+"");; ```. ### Adding Functions to the List. The example `$ROOTSYS/tutorials/fit/multifit.C` also illustrates how; to fit several functions on the same histogram. By default a Fit; command deletes the previously fitted function in the histogram; object. You can specify the option ""+"" in the second parameter to add; the newly fitted function to the existing l",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:13459,simpl,simple,13459,documentation/users-guide/FittingHistograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md,1,['simpl'],['simple']
Usability,"aration or a block. Given; class X { void f(int x) {} };; cxxMethodDecl(hasParameter(0, hasType(varDecl()))); matches f(int x) {}; with hasParameter(...); matching int x. For ObjectiveC, given; @interface I - (void) f:(int) y; @end. the matcher objcMethodDecl(hasParameter(0, hasName(""y""))); matches the declaration of method f with hasParameter; matching y. Matcher<BlockDecl>hasTypeLocMatcher<TypeLoc> Inner; Matches if the type location of a node matches the inner matcher. Examples:; int x;; declaratorDecl(hasTypeLoc(loc(asString(""int"")))); matches int x. auto x = int(3);; cxxTemporaryObjectExpr(hasTypeLoc(loc(asString(""int"")))); matches int(3). struct Foo { Foo(int, int); };; auto x = Foo(1, 2);; cxxFunctionalCastExpr(hasTypeLoc(loc(asString(""struct Foo"")))); matches Foo(1, 2). Usable as: Matcher<BlockDecl>, Matcher<CXXBaseSpecifier>,; Matcher<CXXCtorInitializer>, Matcher<CXXFunctionalCastExpr>,; Matcher<CXXNewExpr>, Matcher<CXXTemporaryObjectExpr>,; Matcher<CXXUnresolvedConstructExpr>,; Matcher<ClassTemplateSpecializationDecl>, Matcher<CompoundLiteralExpr>,; Matcher<DeclaratorDecl>, Matcher<ExplicitCastExpr>,; Matcher<ObjCPropertyDecl>, Matcher<TemplateArgumentLoc>,; Matcher<TypedefNameDecl>. Matcher<BlockPointerType>pointeeMatcher<Type>; Narrows PointerType (and similar) matchers to those where the; pointee matches a given matcher. Given; int *a;; int const *b;; float const *f;; pointerType(pointee(isConstQualified(), isInteger())); matches ""int const *b"". Usable as: Matcher<BlockPointerType>, Matcher<MemberPointerType>,; Matcher<PointerType>, Matcher<ReferenceType>. Matcher<CXXBaseSpecifier>hasTypeLocMatcher<TypeLoc> Inner; Matches if the type location of a node matches the inner matcher. Examples:; int x;; declaratorDecl(hasTypeLoc(loc(asString(""int"")))); matches int x. auto x = int(3);; cxxTemporaryObjectExpr(hasTypeLoc(loc(asString(""int"")))); matches int(3). struct Foo { Foo(int, int); };; auto x = Foo(1, 2);; cxxFunctionalCastExpr(hasTypeLoc(loc(asString(""str",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:143794,Usab,Usable,143794,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['Usab'],['Usable']
Usability,"are taken from the **`TTree`** associated with the network. This; **`TTree`** can be given as argument of the constructor or defined; later with `TMultiLayerPerceptron::SetData()`. Events can also be; weighted. The weight expression can be given in the constructor or set; later with the method `SetWeight()` of the class; **`TMultiLayerPerceptron`**. Two datasets must be defined before; learning the network: a training dataset that is used when minimizing; the error, and a test dataset that will avoid bias. Those two datasets; can be built aside and then given to the network, or can be built from; a standard expression. By default, half of the events are put in both; datasets. ``` {.cpp}; // a more complex 4:8:1 network; // the ptsumf branch is used as weigh;; // default event lists are explicit; TMultiLayerPerceptron network(""m,pt,acol,acopl:8:type"",""pt"",tree,; ""Entry$%2"",""Entry$/2"");; ```. The method `TMultiLayerPerceptron::SetLearningMethod()` defines the; learning method. Learning methods are:. ```; TMultiLayerPerceptron::kStochastic,; TMultiLayerPerceptron::kBatch,; TMultiLayerPerceptron::kSteepestDescent,; TMultiLayerPerceptron::kRibierePolak,; TMultiLayerPerceptron::kFletcherReeves,; TMultiLayerPerceptron::kBFGS // default; ```. The training can start with; `TMultiLayerPerceptron::Train(Int_t nepoch,Option_t* options).` The; first argument is the number of epochs while option is a string that; can contain ""`text`"" (simple text output), ""`graph`"" (evaluating; graphical training curves), ""`update` `=` `X`"" (step for the; text/graph output update) or ""`+`"" (will skip the randomization and; start from the previous values). All combinations are available. ``` {.cpp}; network.Train(1000,""text,graph,update=10""); // full output every; // 10 epochs; network.Train(100,""text,+""); // 100 more epochs; //starts with existing weights; ```. The weights can be saved to a file (`DumpWeights`) and then reloaded; (`LoadWeights`) to a new compatible network. The output can also be;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:76269,Learn,Learning,76269,documentation/users-guide/FittingHistograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md,1,['Learn'],['Learning']
Usability,"are useful for measurement or checking alignments,; as the sizes and angles between objects are preserved. You can select the active camera from the viewer's Camera menu on the; top menu bar. There are three perspective camera choices:. - Perspective (Floor XOZ) Default. - Perspective (Floor YOZ). - Perspective (Floor XOY). In each case the perspective camera is constrained to keep the chosen; floor plane, defined by a pair of world axes, appearing level at all; times - i.e. there is no banking of the ‘horizon' that you experience; when a plane rolls. There are also three orthographic camera choices:. - Orthographic (XOY). - Orthographic (XOZ). - Orthographic (ZOY). Orthographic projections are generally constrained to look down one of; the global axes of the world, with the other two axes lying; horizontal/vertical on the viewer window. Therefore, XOY has the X-axis; horizontal, the Y-axis vertical. You can always confirm the orientation; and constraints of the camera in the world by enabling axis drawing in; the ""Guides"" tab - see sections ""Guides"" and ""Clipping"" below. For; orthographic camera a ruler-depicting current scene units is also; available. You can also pick the current camera by obtaining a handle to the GL; Viewer object behind the interface:. ``` {.cpp}; TGLViewer * v = (TGLViewer *)gPad->GetViewer3D();; ```. calling the method `TGLViewer::SetCurrentCamera` with one of the; **`TGLViewer::ECameraType` types:**. ``` {.cpp}; v->SetCurrentCamera(TGLViewer::kCameraPerspXOZ);; ```. See also `$ROOTSYS/tutorials/gl/glViewerExercise.C`. #### Adjusting Cameras. The interactions with the camera are summarized above. In each case the; interaction is listed, along with description and user actions required; to achieve it. For all cameras you can reset the original default view,; framing the entire scene, by double clicking any mouse button. ![GL Viewer camera interactions](pictures/020000DB.jpg). For the Zoom interaction you can use the following modifiers; combin",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:109772,Guid,Guides,109772,documentation/users-guide/Graphics.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md,2,['Guid'],['Guides']
Usability,"ared with the 'diff' method.; (`#66744 <https://github.com/llvm/llvm-project/issues/66744>`_). - Fix crash caused by a spaceship operator returning a comparision category by; reference. Fixes:; (`#64162 <https://github.com/llvm/llvm-project/issues/64162>`_); - Fix a crash when calling a consteval function in an expression used as; the size of an array.; (`#65520 <https://github.com/llvm/llvm-project/issues/65520>`_). - Clang no longer tries to capture non-odr-used variables that appear; in the enclosing expression of a lambda expression with a noexcept specifier.; (`#67492 <https://github.com/llvm/llvm-project/issues/67492>`_). - Fix crash when fold expression was used in the initialization of default; argument. Fixes:; (`#67395 <https://github.com/llvm/llvm-project/issues/67395>`_). - Fixed a bug causing destructors of constant-evaluated structured bindings; initialized by array elements to be called in the wrong evaluation context. - Fix crash where ill-formed code was being treated as a deduction guide and; we now produce a diagnostic. Fixes:; (`#65522 <https://github.com/llvm/llvm-project/issues/65522>`_). - Fixed a bug where clang incorrectly considered implicitly generated deduction; guides from a non-templated constructor and a templated constructor as ambiguous,; rather than prefer the non-templated constructor as specified in; [standard.group]p3. - Fixed a crash caused by incorrect handling of dependence on variable templates; with non-type template parameters of reference type. Fixes:; (`#65153 <https://github.com/llvm/llvm-project/issues/65153>`_). - Clang now properly compares constraints on an out of line class template; declaration definition. Fixes:; (`#61763 <https://github.com/llvm/llvm-project/issues/61763>`_). - Fix a bug where implicit deduction guides are not correctly generated for nested template; classes. Fixes:; (`#46200 <https://github.com/llvm/llvm-project/issues/46200>`_); (`#57812 <https://github.com/llvm/llvm-project/issues/57812>`_). - ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:51228,guid,guide,51228,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst,1,['guid'],['guide']
Usability,"argument is; assumed to be ``this``, and the analysis will not check the body of the; function. This pattern is intended for use by classes which hide locking; details behind an abstract interface. For example:. .. code-block:: c++. template <class T>; class CAPABILITY(""mutex"") Container {; private:; Mutex mu;; T* data;. public:; // Hide mu from public interface.; void Lock() ACQUIRE() { mu.Lock(); }; void Unlock() RELEASE() { mu.Unlock(); }. T& getElem(int i) { return data[i]; }; };. void test() {; Container<int> c;; c.Lock();; int i = c.getElem(0);; c.Unlock();; }. EXCLUDES(...); -------------. *Previously*: ``LOCKS_EXCLUDED``. ``EXCLUDES`` is an attribute on functions or methods, which declares that; the caller must *not* hold the given capabilities. This annotation is; used to prevent deadlock. Many mutex implementations are not re-entrant, so; deadlock can occur if the function acquires the mutex a second time. .. code-block:: c++. Mutex mu;; int a GUARDED_BY(mu);. void clear() EXCLUDES(mu) {; mu.Lock();; a = 0;; mu.Unlock();; }. void reset() {; mu.Lock();; clear(); // Warning! Caller cannot hold 'mu'.; mu.Unlock();; }. Unlike ``REQUIRES``, ``EXCLUDES`` is optional. The analysis will not issue a; warning if the attribute is missing, which can lead to false negatives in some; cases. This issue is discussed further in :ref:`negative`. NO_THREAD_SAFETY_ANALYSIS; -------------------------. ``NO_THREAD_SAFETY_ANALYSIS`` is an attribute on functions or methods, which; turns off thread safety checking for that method. It provides an escape hatch; for functions which are either (1) deliberately thread-unsafe, or (2) are; thread-safe, but too complicated for the analysis to understand. Reasons for; (2) will be described in the :ref:`limitations`, below. .. code-block:: c++. class Counter {; Mutex mu;; int a GUARDED_BY(mu);. void unsafeIncrement() NO_THREAD_SAFETY_ANALYSIS { a++; }; };. Unlike the other attributes, NO_THREAD_SAFETY_ANALYSIS is not part of the; interface o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:10493,clear,clear,10493,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,1,['clear'],['clear']
Usability,"aries loaded by the same application if the original source; files have the same name.; This loose limitation is imposed by the registration mechanism ROOT; has in place to keep track of dynamically loaded libraries. In the following example, we walk through the steps necessary to; generate a dictionary, I/O, and inspect member functions. Let's start; with a **`TEvent`** class, which contains a collection of **`TTracks`**. The `TEvent.h` header is:. ``` {.cpp}; #ifndef __TEvent__; #define __TEvent__; #include ""TObject.h""; #include ""TCollection.h"". class TTrack;. class TEvent : public TObject {; private:; Int_t fId; // event sequential id; Float_t fTotalMom; // total momentum; TCollection *fTracks; // collection of tracks; public:; TEvent() { fId = 0; fTotalMom = 0; fTracks = nullptr; }; TEvent(Int_t id);; ~TEvent();; void AddTrack(TTrack *t);; Int_t GetId() const { return fId; }; Int_t GetNoTracks() const;; void Print(Option_t *opt="""");; Float_t TotalMomentum();. ClassDef(TEvent,1); //Simple event class; };. #endif; ```. The things to notice in these header files are:. - The usage of the `ClassDef` macro. - The default constructors of the **`TEvent`** and **`TTrack`**; classes. - Comments to describe the data members and the comment after the; `ClassDef` macro to describe the class. These classes are intended for you to create an event object with a; certain id, and then add tracks to it. The track objects have a pointer; to their event. This shows that the I/O system correctly handles; circular references. The `TTrack.h` header is:. ``` {.cpp}; #ifndef __TTrack__; #define __TTrack__; #include ""TObject.h"". class TEvent;. class TTrack : public TObject {; private:; Int_t fId; //track sequential id; TEvent *fEvent; //event to which track belongs; Float_t fPx; //x part of track momentum; Float_t fPy; //y part of track momentum; Float_t fPz; //z part of track momentum; public:; TTrack() { fId = 0; fEvent = nullptr; fPx = fPy = fPz = 0; }; TTrack(Int_t id, TEvent *ev, Flo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md:14941,Simpl,Simple,14941,documentation/users-guide/AddingaClass.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md,1,['Simpl'],['Simple']
Usability,"arlo (MC) fractions to data histogram; (a la HMCMLL, R. Barlow and C. Beeston, Comp. Phys. Comm. 77 (1993); 219-228). It takes into account both data and Monte Carlo statistical; uncertainties through a likelihood fit using Poisson statistics.; However, the template (MC) predictions are also varied within; statistics, leading to additional contributions to the overall; likelihood. This leads to many more fit parameters (one per bin per; template), but the minimization with respect to these additional; parameters is done analytically rather than introducing them as formal; fit parameters. Some special care needs to be taken in the case of bins; with zero content. **`TMultiDimFit`** implements multi-dimensional function; parametrization for multi-dimensional data by fitting them to; multi-dimensional data using polynomial or Chebyshev or Legendre; polynomial. **`TSpectrum`** contains advanced spectra processing functions for; 1- and 2-dimensional background estimation, smoothing, deconvolution,; peak search and fitting, and orthogonal transformations. **`RooFit`** is a complete toolkit for fitting and data analysis; modeling (see the RooFit User Guide at; ftp://root.cern.ch/root/doc/RooFit\_Users\_Manual\_2.07-29.pdf). **`TSplot`** to disentangle signal from background via an extended; maximum likelihood fit and with a tool to access the quality and; validity of the fit producing distributions for the control variables.; (see M. Pivk and F.R. Le Diberder, Nucl. Inst. Meth.A 555, 356-369,; 2005). ### Multi-variate Analysis Classes. **`TMultiLayerPerceptron`** is a Neural Network class (see for more; details the chapter ""Neural Networks""). **`TPrincipal`** provides the Principal Component Analysis. **`TRobustEstimator`** is a robust method for minimum covariance; determinant estimator (MCD). **`TMVA`** is a package for multivariate data analysis (see; <https://github.com/root-project/root/blob/master/documentation/tmva/UsersGuide/TMVAUsersGuide.pdf> the User's Guide).; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:119207,Guid,Guide,119207,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,2,['Guid'],['Guide']
Usability,"arser<int> specialization** uses the C ``strtol`` function to parse the; string input. As such, it will accept a decimal number (with an optional '+'; or '-' prefix) which must start with a non-zero digit. It accepts octal; numbers, which are identified with a '``0``' prefix digit, and hexadecimal; numbers with a prefix of '``0x``' or '``0X``'. .. _doubles:; .. _float:; .. _double:. * The **parser<double>** and **parser<float> specializations** use the standard; C ``strtod`` function to convert floating point strings into floating point; values. As such, a broad range of string formats is supported, including; exponential notation (ex: ``1.7e15``) and properly supports locales. .. _Extension Guide:; .. _extending the library:. Extension Guide; ===============. Although the CommandLine library has a lot of functionality built into it; already (as discussed previously), one of its true strengths lie in its; extensibility. This section discusses how the CommandLine library works under; the covers and illustrates how to do some simple, common, extensions. .. _Custom parsers:; .. _custom parser:; .. _Writing a Custom Parser:. Writing a custom parser; -----------------------. One of the simplest and most common extensions is the use of a custom parser.; As `discussed previously`_, parsers are the portion of the CommandLine library; that turns string input from the user into a particular parsed data type,; validating the input in the process. There are two ways to use a new parser:. #. Specialize the `cl::parser`_ template for your custom data type. This approach has the advantage that users of your custom data type will; automatically use your custom parser whenever they define an option with a; value type of your data type. The disadvantage of this approach is that it; doesn't work if your fundamental data type is something that is already; supported. #. Write an independent class, using it explicitly from options that need it. This approach works well in situations wher",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst:61698,simpl,simple,61698,interpreter/llvm-project/llvm/docs/CommandLine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst,1,['simpl'],['simple']
Usability,"art of the RNTupleUtils library,; which depends on the RNTuple library. The RNTuple classes are organized in layers:; the storage layer, the primitives layer, the logical layer and the event iteration layer.; Most classes in the storage layer and the primitives layer are in the `ROOT::Internal` namespace (non-public interfaces),; with the notable exception of the descriptor classes (`RNTupleDescriptor`, `RFieldDescriptor`, etc.).; Most classes in the upper layers provide public interfaces. | Layer | Description | Example of classes |; |------------|---------------------------------------------------------------------|-------------------------------------------------------------|; | Storage | Read and write pages (physical: file, object store; virtual: e.g. buffered) | RPage{Source,Sink}, RNTupleDescriptor, RClusterPool |; | Primitives | Storage-backed columns of simple types | RColumn, RColumnElement, RPage |; | Logical | Mapping of C++ types onto columns | RField, RNTupleModel, REntry |; | Iteration | Reading and writing events / properties | RNTuple{Reader,Writer}, RNTupleView, RNTupleDS (RDataFrame) |; | Tooling | Higher-level, RNTuple related utility classes | RNTupleMerger, RNTupleImporter, RNTupleInspector |. The RNTuple classes are, unless explicitly stated otherwise, conditionally thread safe. The read and write APIs provide templated, compile-time type-safe APIs,; APIs where the type at hand is passed as string and which are runtime type-safe,; and type-unsafe APIs using void pointers. On I/O errors and invalid input, RNTuple classes throw an `RException`. Walkthrough: Reading Data; -------------------------. ```c++; auto file = std::make_unique<TFile>(""data.root"");; auto ntuple = std::unique_ptr<RNTuple>(file->Get<RNTuple>(""ntpl""));. // Option 1: entire row; // The reader creates a page source; the page source creates a model from the on-disk information; auto reader = RNTupleReader::Open(ntuple);; // Populate the objects that are used in the model's defau",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/Architecture.md:1584,simpl,simple,1584,tree/ntuple/v7/doc/Architecture.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/Architecture.md,1,['simpl'],['simple']
Usability,"aryOp()); BinopPrecedence[P.getOperatorName()] = P.getBinaryPrecedence();. // Create a new basic block to start insertion into.; BasicBlock *BB = BasicBlock::Create(*TheContext, ""entry"", TheFunction);; ... Basically, before codegening a function, if it is a user-defined; operator, we register it in the precedence table. This allows the binary; operator parsing logic we already have in place to handle it. Since we; are working on a fully-general operator precedence parser, this is all; we need to do to ""extend the grammar"". Now we have useful user-defined binary operators. This builds a lot on; the previous framework we built for other operators. Adding unary; operators is a bit more challenging, because we don't have any framework; for it yet - let's see what it takes. User-defined Unary Operators; ============================. Since we don't currently support unary operators in the Kaleidoscope; language, we'll need to add everything to support them. Above, we added; simple support for the 'unary' keyword to the lexer. In addition to; that, we need an AST node:. .. code-block:: c++. /// UnaryExprAST - Expression class for a unary operator.; class UnaryExprAST : public ExprAST {; char Opcode;; std::unique_ptr<ExprAST> Operand;. public:; UnaryExprAST(char Opcode, std::unique_ptr<ExprAST> Operand); : Opcode(Opcode), Operand(std::move(Operand)) {}. Value *codegen() override;; };. This AST node is very simple and obvious by now. It directly mirrors the; binary operator AST node, except that it only has one child. With this,; we need to add the parsing logic. Parsing a unary operator is pretty; simple: we'll add a new function to do it:. .. code-block:: c++. /// unary; /// ::= primary; /// ::= '!' unary; static std::unique_ptr<ExprAST> ParseUnary() {; // If the current token is not an operator, it must be a primary expr.; if (!isascii(CurTok) || CurTok == '(' || CurTok == ','); return ParsePrimary();. // If this is a unary operator, read it.; int Opc = CurTok;; getNextTo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl06.rst:10525,simpl,simple,10525,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl06.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl06.rst,1,['simpl'],['simple']
Usability,"as a pointer to such a Boolean node. Since the shape; components may also be composites, they will also contain binary Boolean; nodes branching out other two shapes in the hierarchy. Any such branch; ends-up when the final leaves are no longer composite shapes, but basic; primitives. The figure shows the composite shapes structure. ![The composite shapes structure](pictures/080001CA.png). Suppose that A, B, C and D represent basic shapes, we will illustrate; how the internal representation of few combinations look like. We do; this only for understanding how to create them in a proper way, since; the user interface for this purpose is in fact very simple. We will; ignore for the time being the positioning of components. The definition; of a composite shape takes an expression where the identifiers are shape; names. The expression is parsed and decomposed in 2 sub-expressions and; the top-level Boolean operator. 1. Union: `A+B+C`. Just to illustrate the Boolean expression parsing and the composite; shape structure, let's take a simple example. We will describe the union; of A, B and C. Both union operators are at the same level. Since:. `A+B+C = (A+B)+C = A+(B+C)`. The first` (+)` is taken as separator, hence the expression split in:; `A` and `(B+C)`. A Boolean node of type **`TGeoUnion`**`(""A"",""B+C"")` is; created. This tries to replace the 2 expressions by actual pointers to; corresponding shapes. The first expression (A) contains no operators; therefore is interpreted as representing a shape. The shape named ""A"" is; searched into the list of shapes handled by the manager class and stored; as the ""left"" shape in the Boolean union node. Since the second; expression is not yet fully decomposed, the ""right"" shape in the; combination is created as a new composite shape. This will split at its; turn B+C into B and C and create a **`TGeoUnion`**`(""B"",""C"")`. The B and; C identifiers will be looked for and replaced by the pointers to the; actual shapes into the new node. Fin",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:44788,simpl,simple,44788,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['simpl'],['simple']
Usability,"as a single dataset (syntax:; ""dataset1|dataset2|..."");  - 'keep; separated':; the datasets are processed one after the other; the user is notified in; the selector of the change of dataset so they have the opportunity to; separate the results. A new packetizer, TPacketizerMulti, has been; developed for this case: it basically contains a list of standard; packetizers (one for each dataset) and loops over them (syntax:; ""dataset1,dataset2,..."" or dataset1 dataset2 ..."").; In; both cases, entry-list can be applied using the syntax; ""dataset<<entrylist"", e.g.; ""dataset1<<el1|dataset2<<el2|"".; The datasets to be processed can also be specified on one or multiple lines in a text file.; Add; support for automatic download of a package when available on the; master but not locally. The downloaded packages are store under <sandbox>/packages/downloaded; and automatically checked for updates against the master repository. If; a local version of the same package is created (using the; UploadPackage) the entry in downloaded is; cleared, so that the behaviour is unchanged.; Add; the possibility to remap the server for the files in a dataset. This; allows, for example, to reuse the dataset information for the same; files stored in a different cluster.; Add a local cache for; TDataSetManagerFile. This is mainly used to improve the speed of; TDataSetManager::ShowDataSets, which is run very often by users and may; be very slow if the number of dataset is large. The cache is also used; to cache frequently received dataset objects.Add the possibility to audit the activity on the nodes via syslog. .; New packetizer TPacketizerFile generating packets which contain a single; file path to be used in processing single files. Used, for example, in; tasks generating files. The files are specified into a TMap - named; 'PROOF_FilesToProcess' - containing the list of files to be generated; per host (the key is the host name, the value the TList of TObjString; (or TFileInfo) with the files names ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v528/index.html:1252,clear,cleared,1252,proof/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v528/index.html,1,['clear'],['cleared']
Usability,"as queries between each pair of pointers in the; function. This is inspired and adapted from code by: Naveen Neelakantam, Francesco; Spadini, and Wojciech Stryjewski. ``basic-aa``: Basic Alias Analysis (stateless AA impl); ------------------------------------------------------. A basic alias analysis pass that implements identities (two different globals; cannot alias, etc), but does no stateful analysis. ``basiccg``: Basic CallGraph Construction; -----------------------------------------. Yet to be written. .. _passes-da:. ``da``: Dependence Analysis; ---------------------------. Dependence analysis framework, which is used to detect dependences in memory; accesses. ``domfrontier``: Dominance Frontier Construction; ------------------------------------------------. This pass is a simple dominator construction algorithm for finding forward; dominator frontiers. ``domtree``: Dominator Tree Construction; ----------------------------------------. This pass is a simple dominator construction algorithm for finding forward; dominators. ``dot-callgraph``: Print Call Graph to ""dot"" file; -------------------------------------------------. This pass, only available in ``opt``, prints the call graph into a ``.dot``; graph. This graph can then be processed with the ""dot"" tool to convert it to; postscript or some other suitable format. ``dot-cfg``: Print CFG of function to ""dot"" file; ------------------------------------------------. This pass, only available in ``opt``, prints the control flow graph into a; ``.dot`` graph. This graph can then be processed with the :program:`dot` tool; to convert it to postscript or some other suitable format.; Additionally the ``-cfg-func-name=<substring>`` option can be used to filter the; functions that are printed. All functions that contain the specified substring; will be printed. ``dot-cfg-only``: Print CFG of function to ""dot"" file (with no function bodies); -------------------------------------------------------------------------------. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst:2402,simpl,simple,2402,interpreter/llvm-project/llvm/docs/Passes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst,1,['simpl'],['simple']
Usability,"as: Matcher<AddrLabelExpr>, Matcher<CallExpr>,; Matcher<CXXConstructExpr>, Matcher<CXXNewExpr>, Matcher<DeclRefExpr>,; Matcher<EnumType>, Matcher<InjectedClassNameType>, Matcher<LabelStmt>,; Matcher<MemberExpr>, Matcher<QualType>, Matcher<RecordType>,; Matcher<TagType>, Matcher<TemplateSpecializationType>,; Matcher<TemplateTypeParmType>, Matcher<TypedefType>,; Matcher<UnresolvedUsingType>. Matcher<UsingShadowDecl>hasTargetDeclMatcher<NamedDecl> InnerMatcher; Matches a using shadow declaration where the target declaration is; matched by the given matcher. Given; namespace X { int a; void b(); }; using X::a;; using X::b;; usingDecl(hasAnyUsingShadowDecl(hasTargetDecl(functionDecl()))); matches using X::b but not using X::a ; Matcher<UsingType>hasUnderlyingTypeMatcher<Type>; Matches DecltypeType or UsingType nodes to find the underlying type. Given; decltype(1) a = 1;; decltype(2.0) b = 2.0;; decltypeType(hasUnderlyingType(isInteger())); matches the type of ""a"". Usable as: Matcher<DecltypeType>, Matcher<UsingType>. Matcher<UsingType>throughUsingDeclMatcher<UsingShadowDecl> Inner; Matches if a node refers to a declaration through a specific; using shadow declaration. Examples:; namespace a { int f(); }; using a::f;; int x = f();; declRefExpr(throughUsingDecl(anything())); matches f. namespace a { class X{}; }; using a::X;; X x;; typeLoc(loc(usingType(throughUsingDecl(anything())))); matches X. Usable as: Matcher<DeclRefExpr>, Matcher<UsingType>. Matcher<ValueDecl>hasTypeMatcher<Decl> InnerMatcher; Overloaded to match the declaration of the expression's or value; declaration's type. In case of a value declaration (for example a variable declaration),; this resolves one layer of indirection. For example, in the value; declaration ""X x;"", cxxRecordDecl(hasName(""X"")) matches the declaration of; X, while varDecl(hasType(cxxRecordDecl(hasName(""X"")))) matches the; declaration of x. Example matches x (matcher = expr(hasType(cxxRecordDecl(hasName(""X""))))); and z (matcher = varDe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:251486,Usab,Usable,251486,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['Usab'],['Usable']
Usability,"ased frequently. Often the differences between build; numbers being a few bug fixes or minor feature improvements. When using; the analyzer, we recommend that you check back here occasionally for new; builds, especially if the build you are using is more than a couple; weeks old.; The latest build is:; . Packaged builds for other platforms may eventually be provided, but; we need volunteers who are willing to help provide such regular builds.; If you wish to help contribute regular builds of the analyzer on other; platforms, please email the Clang; Developers' mailing list.; Using Packaged Builds; To use a package build, simply unpack it anywhere. If the build; archive has the name checker-XXX.tar.bz2 then the; archive will expand to a directory called checker-XXX.; You do not need to place this directory or the contents of this; directory in any special place. Uninstalling the analyzer is as simple; as deleting this directory.; Most of the files in the checker-XXX directory will; be supporting files for the analyzer that you can simply ignore. Most; users will only care about two files, which are located at the top of; the checker-XXX directory:. scan-build: scan-build is the high-level command line utility for running the analyzer; scan-view: scan-view a companion command line; utility to scan-build, scan-view is used to view; analysis results generated by scan-build. There is an option; that one can pass to scan-build to cause scan-view to; run as soon as it the analysis of a build completes. Running scan-build; For specific details on using scan-build, please see; scan-build's documentation.; To run scan-build, either add the; checker-XXX directory to your path or specify a complete; path for scan-build when running it. It is also possible to use; a symbolic link to scan-build, such one located in a directory; in your path. When scan-build runs it will automatically; determine where to find its accompanying files.; Other Platforms (Building the Analyzer from Sour",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/installation.html:1454,simpl,simply,1454,interpreter/llvm-project/clang/www/analyzer/installation.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/installation.html,1,['simpl'],['simply']
Usability,"asopt`_; modifier) whenever it is specified. Because aliases do not hold state, the only; thing the program has to query is the ``Quiet`` variable now. Another nice; feature of aliases is that they automatically hide themselves from the ``-help``; output (although, again, they are still visible in the ``-help-hidden output``). Now the application code can simply use:. .. code-block:: c++. ...; if (!Quiet) printInformationalMessage(...);; ... ... which is much nicer! The ""`cl::alias`_"" can be used to specify an; alternative name for any variable type, and has many uses. .. _unnamed alternatives using the generic parser:. Selecting an alternative from a set of possibilities; ----------------------------------------------------. So far we have seen how the CommandLine library handles builtin types like; ``std::string``, ``bool`` and ``int``, but how does it handle things it doesn't; know about, like enums or '``int*``'s?. The answer is that it uses a table-driven generic parser (unless you specify; your own parser, as described in the `Extension Guide`_). This parser maps; literal strings to whatever type is required, and requires you to tell it what; this mapping should be. Let's say that we would like to add four optimization levels to our optimizer,; using the standard flags ""``-g``"", ""``-O0``"", ""``-O1``"", and ""``-O2``"". We; could easily implement this with boolean options like above, but there are; several problems with this strategy:. #. A user could specify more than one of the options at a time, for example,; ""``compiler -O3 -O2``"". The CommandLine library would not be able to catch; this erroneous input for us. #. We would have to test 4 different variables to see which ones are set. #. This doesn't map to the numeric levels that we want... so we cannot easily; see if some level >= ""``-O1``"" is enabled. To cope with these problems, we can use an enum value, and have the CommandLine; library fill it in with the appropriate level directly, which is used like this",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst:13674,Guid,Guide,13674,interpreter/llvm-project/llvm/docs/CommandLine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst,1,['Guid'],['Guide']
Usability,"at is executing; the focused thread of execution for languages that are implemented using a SIMD; or SIMT execution model. The ``DW_ASPACE_AMDGPU_private_wave`` address space allows location expressions; to specify the unswizzled private address space corresponding to the wavefront; that is executing the focused thread of execution. The wavefront view of private; memory is the per wavefront unswizzled backing memory layout defined in; :ref:`amdgpu-address-spaces`, such that address 0 corresponds to the first; location for the backing memory of the wavefront (namely the address is not; offset by ``wavefront-scratch-base``). The following formula can be used to; convert from a ``DW_ASPACE_AMDGPU_private_lane`` address to a; ``DW_ASPACE_AMDGPU_private_wave`` address:. ::. private-address-wavefront =; ((private-address-lane / 4) * wavefront-size * 4) +; (wavefront-lane-id * 4) + (private-address-lane % 4). If the ``DW_ASPACE_AMDGPU_private_lane`` address is dword aligned, and the start; of the dwords for each lane starting with lane 0 is required, then this; simplifies to:. ::. private-address-wavefront =; private-address-lane * wavefront-size. A compiler can use the ``DW_ASPACE_AMDGPU_private_wave`` address space to read a; complete spilled vector register back into a complete vector register in the; CFI. The frame pointer can be a private lane address which is dword aligned,; which can be shifted to multiply by the wavefront size, and then used to form a; private wavefront address that gives a location for a contiguous set of dwords,; one per lane, where the vector register dwords are spilled. The compiler knows; the wavefront size since it generates the code. Note that the type of the; address may have to be converted as the size of a; ``DW_ASPACE_AMDGPU_private_lane`` address may be smaller than the size of a; ``DW_ASPACE_AMDGPU_private_wave`` address. .. _amdgpu-dwarf-lane-identifier:. Lane identifier; ---------------. DWARF lane identifies specify a target architec",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:96878,simpl,simplifies,96878,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['simpl'],['simplifies']
Usability,"at least add CivetWeb version and operating system.; Please see also the guidelines for [Contributions](https://github.com/civetweb/civetweb/blob/master/docs/Contribution.md) and the [Security Policy](https://github.com/civetweb/civetweb/blob/master/SECURITY.md). Note: We do not take any liability or warranty for any linked contents. Visit these pages and try the community support suggestions at your own risk.; Any link provided in this project (including source and documentation) is provided in the hope that this information will be helpful.; However, we cannot accept any responsibility for any content on an external page. Contributions; -------------. Contributions are welcome provided all contributions carry the MIT license. DO NOT APPLY fixes copied from Mongoose to this project to prevent GPL tainting.; Since 2013, CivetWeb and Mongoose are developed independently.; By now the code base differs, so patches cannot be safely transferred in either direction. Some guidelines can be found in [docs/Contribution.md](https://github.com/civetweb/civetweb/blob/master/docs/Contribution.md). Authors; -------. CivetWeb has been forked from the last MIT version of Mongoose in 2013.; Since then, CivetWeb has seen many improvements from various authors; (Copyright (c) 2013-2021 the CivetWeb developers, MIT license). A list of authors can be found in [CREDITS.md](https://github.com/civetweb/civetweb/blob/master/CREDITS.md). CivetWeb is based on the Mongoose project. The original author of Mongoose was; Sergey Lyubka (Copyright (c) 2004-2013 Sergey Lyubka, MIT license).; However, on August 16, 2013, the [license of Mongoose has been changed](https://groups.google.com/forum/#!topic/mongoose-users/aafbOnHonkI); after writing and distributing the original code this project is based on.; The license change and CivetWeb used to be mentioned on the Mongoose; [Wikipedia](https://en.wikipedia.org/wiki/Mongoose_(web_server)); page as well, but it's getting deleted (and added again) there",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/README.md:9773,guid,guidelines,9773,net/http/civetweb/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/README.md,1,['guid'],['guidelines']
Usability,"at makes it easier to refer to the; coroutine frame. .. _coro.id:. 'llvm.coro.id' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; ::. declare token @llvm.coro.id(i32 <align>, ptr <promise>, ptr <coroaddr>,; ptr <fnaddrs>). Overview:; """""""""""""""""". The '``llvm.coro.id``' intrinsic returns a token identifying a; switched-resume coroutine. Arguments:; """""""""""""""""""". The first argument provides information on the alignment of the memory returned; by the allocation function and given to `coro.begin` by the first argument. If; this argument is 0, the memory is assumed to be aligned to 2 * sizeof(ptr).; This argument only accepts constants. The second argument, if not `null`, designates a particular alloca instruction; to be a `coroutine promise`_. The third argument is `null` coming out of the frontend. The CoroEarly pass sets; this argument to point to the function this coro.id belongs to. The fourth argument is `null` before coroutine is split, and later is replaced; to point to a private global constant array containing function pointers to; outlined resume and destroy parts of the coroutine. Semantics:; """""""""""""""""""". The purpose of this intrinsic is to tie together `coro.id`, `coro.alloc` and; `coro.begin` belonging to the same coroutine to prevent optimization passes from; duplicating any of these instructions unless entire body of the coroutine is; duplicated. A frontend should emit exactly one `coro.id` intrinsic per coroutine. A frontend should emit function attribute `presplitcoroutine` for the coroutine. .. _coro.id.async:. 'llvm.coro.id.async' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; ::. declare token @llvm.coro.id.async(i32 <context size>, i32 <align>,; ptr <context arg>,; ptr <async function pointer>). Overview:; """""""""""""""""". The '``llvm.coro.id.async``' intrinsic returns a token identifying an async coroutine. Arguments:; """""""""""""""""""". The first argument provides the initial size of the `async context` as required; from the frontend. Lowering will add to",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:37827,resume,resume,37827,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"at the argument means; without requiring it to use a specific presentation (consider this MVC for; Clang :). It is really easy to add format specifiers to the Clang diagnostics system, but; they should be discussed before they are added. If you are creating a lot of; repetitive diagnostics and/or have an idea for a useful formatter, please bring; it up on the cfe-dev mailing list. Here are the different diagnostic argument formats currently supported by; Clang:. **""s"" format**. Example:; ``""requires %0 parameter%s0""``; Class:; Integers; Description:; This is a simple formatter for integers that is useful when producing English; diagnostics. When the integer is 1, it prints as nothing. When the integer; is not 1, it prints as ""``s``"". This allows some simple grammatical forms to; be to be handled correctly, and eliminates the need to use gross things like; ``""requires %1 parameter(s)""``. Note, this only handles adding a simple; ""``s``"" character, it will not handle situations where pluralization is more; complicated such as turning ``fancy`` into ``fancies`` or ``mouse`` into; ``mice``. You can use the ""plural"" format specifier to handle such situations. **""select"" format**. Example:; ``""must be a %select{unary|binary|unary or binary}0 operator""``; Class:; Integers; Description:; This format specifier is used to merge multiple related diagnostics together; into one common one, without requiring the difference to be specified as an; English string argument. Instead of specifying the string, the diagnostic; gets an integer argument and the format string selects the numbered option.; In this case, the ""``%0``"" value must be an integer in the range [0..2]. If; it is 0, it prints ""unary"", if it is 1 it prints ""binary"" if it is 2, it; prints ""unary or binary"". This allows other language translations to; substitute reasonable words (or entire phrases) based on the semantics of the; diagnostic instead of having to do things textually. The selected string; does undergo formatt",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:10798,simpl,simple,10798,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['simpl'],['simple']
Usability,"at the function type must match the signature of the callee and the; types of the 'call parameters' arguments. The '#call args' operand is the number of arguments to the actual; call. It must exactly match the number of arguments passed in the; 'call parameters' variable length section. The 'flags' operand is used to specify extra information about the; statepoint. This is currently only used to mark certain statepoints; as GC transitions. This operand is a 64-bit integer with the following; layout, where bit 0 is the least significant bit:. +-------+---------------------------------------------------+; | Bit # | Usage |; +=======+===================================================+; | 0 | Set if the statepoint is a GC transition, cleared |; | | otherwise. |; +-------+---------------------------------------------------+; | 1-63 | Reserved for future use; must be cleared. |; +-------+---------------------------------------------------+. The 'call parameters' arguments are simply the arguments which need to; be passed to the call target. They will be lowered according to the; specified calling convention and otherwise handled like a normal call; instruction. The number of arguments must exactly match what is; specified in '# call args'. The types must match the signature of; 'target'. The 'call parameter' attributes must be followed by two 'i64 0' constants.; These were originally the length prefixes for 'gc transition parameter' and; 'deopt parameter' arguments, but the role of these parameter sets have been; entirely replaced with the corresponding operand bundles. In a future; revision, these now redundant arguments will be removed. Semantics:; """""""""""""""""""". A statepoint is assumed to read and write all memory. As a result,; memory operations can not be reordered past a statepoint. It is; illegal to mark a statepoint as being either 'readonly' or 'readnone'. Note that legal IR can not perform any memory operation on a 'gc; pointer' argument of the statepoint in a loc",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:502545,simpl,simply,502545,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['simpl'],['simply']
Usability,"at you use this technique for building SSA form,; unless there is an extremely good reason not to. Using this technique; is:. - Proven and well tested: clang uses this technique; for local mutable variables. As such, the most common clients of LLVM; are using this to handle a bulk of their variables. You can be sure; that bugs are found fast and fixed early.; - Extremely Fast: mem2reg has a number of special cases that make it; fast in common cases as well as fully general. For example, it has; fast-paths for variables that are only used in a single block,; variables that only have one assignment point, good heuristics to; avoid insertion of unneeded phi nodes, etc.; - Needed for debug info generation: `Debug information in; LLVM <../../SourceLevelDebugging.html>`_ relies on having the address of; the variable exposed so that debug info can be attached to it. This; technique dovetails very naturally with this style of debug info. If nothing else, this makes it much easier to get your front-end up and; running, and is very simple to implement. Let's extend Kaleidoscope with; mutable variables now!. Mutable Variables in Kaleidoscope; =================================. Now that we know the sort of problem we want to tackle, let's see what; this looks like in the context of our little Kaleidoscope language.; We're going to add two features:. #. The ability to mutate variables with the '=' operator.; #. The ability to define new variables. While the first item is really what this is about, we only have; variables for incoming arguments as well as for induction variables, and; redefining those only goes so far :). Also, the ability to define new; variables is a useful thing regardless of whether you will be mutating; them. Here's a motivating example that shows how we could use these:. ::. # Define ':' for sequencing: as a low-precedence operator that ignores operands; # and just returns the RHS.; def binary : 1 (x y) y;. # Recursive fib, we could do this before.; def fib(",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst:10120,simpl,simple,10120,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,1,['simpl'],['simple']
Usability,"at; :ref:`DenseMap <dss_densemap>` has. .. _dss_sparseset:. llvm/ADT/SparseSet.h; ^^^^^^^^^^^^^^^^^^^^. SparseSet holds a small number of objects identified by unsigned keys of; moderate size. It uses a lot of memory, but provides operations that are almost; as fast as a vector. Typical keys are physical registers, virtual registers, or; numbered basic blocks. SparseSet is useful for algorithms that need very fast clear/find/insert/erase; and fast iteration over small sets. It is not intended for building composite; data structures. .. _dss_sparsemultiset:. llvm/ADT/SparseMultiSet.h; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. SparseMultiSet adds multiset behavior to SparseSet, while retaining SparseSet's; desirable attributes. Like SparseSet, it typically uses a lot of memory, but; provides operations that are almost as fast as a vector. Typical keys are; physical registers, virtual registers, or numbered basic blocks. SparseMultiSet is useful for algorithms that need very fast; clear/find/insert/erase of the entire collection, and iteration over sets of; elements sharing a key. It is often a more efficient choice than using composite; data structures (e.g. vector-of-vectors, map-of-vectors). It is not intended for; building composite data structures. .. _dss_FoldingSet:. llvm/ADT/FoldingSet.h; ^^^^^^^^^^^^^^^^^^^^^. FoldingSet is an aggregate class that is really good at uniquing; expensive-to-create or polymorphic objects. It is a combination of a chained; hash table with intrusive links (uniqued objects are required to inherit from; FoldingSetNode) that uses :ref:`SmallVector <dss_smallvector>` as part of its ID; process. Consider a case where you want to implement a ""getOrCreateFoo"" method for a; complex object (for example, a node in the code generator). The client has a; description of **what** it wants to generate (it knows the opcode and all the; operands), but we don't want to 'new' a node, then try inserting it into a set; only to find out it already exists, at which po",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:81393,clear,clear,81393,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['clear'],['clear']
Usability,"at; =========. LibFormat is a library that implements automatic source code formatting based; on Clang. This documents describes the LibFormat interface and design as well; as some basic style discussions. If you just want to use `clang-format` as a tool or integrated into an editor,; checkout :doc:`ClangFormat`. Design; ------. FIXME: Write up design. Interface; ---------. The core routine of LibFormat is ``reformat()``:. .. code-block:: c++. tooling::Replacements reformat(const FormatStyle &Style, Lexer &Lex,; SourceManager &SourceMgr,; std::vector<CharSourceRange> Ranges);. This reads a token stream out of the lexer ``Lex`` and reformats all the code; ranges in ``Ranges``. The ``FormatStyle`` controls basic decisions made during; formatting. A list of options can be found under :ref:`style-options`. The style options are described in :doc:`ClangFormatStyleOptions`. .. _style-options:. Style Options; -------------. The style options describe specific formatting options that can be used in; order to make `ClangFormat` comply with different style guides. Currently,; several style guides are hard-coded:. .. code-block:: c++. /// Returns a format style complying with the LLVM coding standards:; /// https://llvm.org/docs/CodingStandards.html.; FormatStyle getLLVMStyle();. /// Returns a format style complying with Google's C++ style guide:; /// http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml.; FormatStyle getGoogleStyle();. /// Returns a format style complying with Chromium's style guide:; /// https://chromium.googlesource.com/chromium/src/+/refs/heads/main/styleguide/styleguide.md; FormatStyle getChromiumStyle();. /// Returns a format style complying with the GNU coding standards:; /// https://www.gnu.org/prep/standards/standards.html; FormatStyle getGNUStyle();. /// Returns a format style complying with Mozilla's style guide; /// https://firefox-source-docs.mozilla.org/code-quality/coding-style/index.html; FormatStyle getMozillaStyle();. /// Returns a f",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibFormat.rst:1081,guid,guides,1081,interpreter/llvm-project/clang/docs/LibFormat.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibFormat.rst,1,['guid'],['guides']
Usability,"ata and then; it is used to evaluate the likelihood. ; ; This class implements the HypoTestCalculatorGeneric interface and can be used as an alternative Hypothesis test; calculator in the HypoTestInverter class. It can then plugged in the HypoTestInverter for computing asymptotic CLs and CLs+b; limits. In this way the limits will be computed by just performing a fit for each test parameter value and without; generating any toys. . The class can be used via the StandardHypothesisTest.C tutorial passing a value of 2 for the; calculator type. . RooStats Utils. Add a utility function (from G. Petrucciani), RooStats::MakeNuisancePdf, which given a model configuration (or the global pdf and the; observables), factorizes from the model pdf the constraint probability density functions for the nuisance parameters; and builds a global nuisance pdf. This function can then be used in the HybridCalculator or in the BayesianCalculator; with the option ""TOYMC"".; . HypotestInverter and HypoTestInverterResult. Several improvements and bug fixes in merging results and in computing the observed and expected limits.; Provide support now for using the AsympoticCalculator. MCMCCalculator. Add now possibility to store in the chain only the parameter of interested via the method MCMCCalculator::SetChainParameters. This saves memory in case of models with a; large number of nuisance parameters. . Test Statistics classes. Make a more robust evaluation of the ProfileLikelihoodTestStat. Use RooMinimizer and give possibility to use; different minimizer, via ProfileLikelihoodTestStat::SetMinimizer. The print level of minimization can also be; controlled via ProfileLikelihoodTestStat::SetPrintLevel. Activate also the RooFit cache optimizations when; evaluating the NLL ; The same optimizations are applied also to the RatioOfProfilesLikelihood test statistic; Fix a bug in reusing the NLL object in the SimpleLikelihoodCalculator. This makes now the evaluation of this test; statistics much faster. . ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v532/index.html:9416,Simpl,SimpleLikelihoodCalculator,9416,roofit/doc/v532/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v532/index.html,1,['Simpl'],['SimpleLikelihoodCalculator']
Usability,"ata types"");; tree->Branch(""floatVal"", &floatVal, ""floatVal/f""); // Float16_t value with default settings; tree->Branch(""floatArray"", floatArray, ""floatArray[7]/f[0,100]""); // Float16_t array with range from 0 to 100; tree->Branch(""doubleVal"", &doubleVal, ""doubleVal/d[0,1000,20]""); // Double32_t value with range from 0 to 1000 and 20 bits; tree->Branch(""doubleArray"", doubleArray, ""doubleArray[5]/d[0,0,18]""); // Double32_t array without range and 18 bits; ~~~. ### Bulk I/O; - The new `TBulkBranchRead` class (inside the `ROOT::Experimental::Internal` namespace) provides; a mechanism for reading, in a single library call, many events' worth of simple data (primitive types,; arrays of primitives, split structures) stored in a `TTree`. This allows for extremely fast delivery; of event data to the process. This is meant as an internal interface that allows the ROOT team to; implement faster high-level interface.; - The `TTreeReaderFast ` class (inside the `ROOT::Experimental::Internal` namespace) provides a simple; mechanism for reading ntuples with the bulk IO interface. ## Histogram Libraries. ### TH1; - Add a search range to the `TH1::FindFirstBinAbove(..)` and `TH1::FindLastBinAvove(..)` functions. ### TH2Poly; - Add implementation of `SetBinError` and fix a bug in `GetBinError` in case of weighted events. ### TF1; - The implementation of `TF1::GetX` has been improved. In case of the presence of multiple roots, the function will return the root with the lower x value. In case of no-roots a NaN will be returned instead of returning a random incorrect value. ### TKDE; - Add support for I/O. ## Math Libraries; - Add `TComplex` value printer for printing the value of object at the root prompt and in python; - Add to the documentation of `TLorentzVector` a link to `ROOT::Math::LorentzVector`, which is a superior tool.; - Add new implementation of `TStatistic::Merge` able to deal silently with empty TStatistic objects. This implementation is useful when filling TStatistics w",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v618/index.md:11381,simpl,simple,11381,README/ReleaseNotes/v618/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v618/index.md,1,['simpl'],['simple']
Usability,"atcher. Example 1: matches ""a string""; (matcher = castExpr(hasSourceExpression(cxxConstructExpr()))); class URL { URL(string); };; URL url = ""a string"";. Example 2: matches 'b' (matcher =; opaqueValueExpr(hasSourceExpression(implicitCastExpr(declRefExpr()))); int a = b ?: 1;. Matcher<OverloadExpr>hasAnyDeclarationMatcher<Decl> InnerMatcher; Matches an OverloadExpr if any of the declarations in the set of; overloads matches the given matcher. Given; template <typename T> void foo(T);; template <typename T> void bar(T);; template <typename T> void baz(T t) {; foo(t);; bar(t);; }; unresolvedLookupExpr(hasAnyDeclaration(; functionTemplateDecl(hasName(""foo"")))); matches foo in foo(t); but not bar in bar(t);. Matcher<ParenType>innerTypeMatcher<Type>; Matches ParenType nodes where the inner type is a specific type. Given; int (*ptr_to_array)[4];; int (*ptr_to_func)(int);. varDecl(hasType(pointsTo(parenType(innerType(functionType()))))) matches; ptr_to_func but not ptr_to_array. Usable as: Matcher<ParenType>. Matcher<PointerTypeLoc>hasPointeeLocMatcher<TypeLoc> PointeeMatcher; Matches pointer `TypeLoc`s that have a pointee `TypeLoc` matching; `PointeeMatcher`. Given; int* x;; pointerTypeLoc(hasPointeeLoc(loc(asString(""int"")))); matches `int*`. Matcher<PointerType>pointeeMatcher<Type>; Narrows PointerType (and similar) matchers to those where the; pointee matches a given matcher. Given; int *a;; int const *b;; float const *f;; pointerType(pointee(isConstQualified(), isInteger())); matches ""int const *b"". Usable as: Matcher<BlockPointerType>, Matcher<MemberPointerType>,; Matcher<PointerType>, Matcher<ReferenceType>. Matcher<QualType>hasCanonicalTypeMatcher<QualType> InnerMatcher; Matches QualTypes whose canonical type matches InnerMatcher. Given:; typedef int &int_ref;; int a;; int_ref b = a;. varDecl(hasType(qualType(referenceType()))))) will not match the; declaration of b but varDecl(hasType(qualType(hasCanonicalType(referenceType())))))) does. Matcher<QualType>hasDeclarati",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:225405,Usab,Usable,225405,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['Usab'],['Usable']
Usability,"ated to finer grained read and write locks in a few hotspots that occur during file opening/closing or task initialization in RDataFrame. This can lead to O(100x) improvements for some typical RDataFrame scenarios with 256 threads due to massively reduced lock contention. ## TTree Libraries. - `TTree` now supports the inclusion of leaves of types `long` and `unsigned long` (and therefore also `std::size_t` on most systems) also for branches in ""leaflist mode"". The corresponding leaflist letters are 'G' and 'g'.; - when looping over a `TTree` with a friend with a larger number of entries, `TTreeReader` now ends the event loop when the entries in the _main_ `TTree` are exhausted, consistently with other interfaces. See [#6518](https://github.com/root-project/root/issues/6518) for more details.; - `TTreeProcessorMT::SetMaxTasksPerFilePerWorker` is now deprecated in favor of the more flexible and newly introduced `TTreeProcessorMT::SetTasksPerWorkerHint`. See the relevant entries in our reference guide for more information.; - The name of the sub-branches of a split collection no longer have 2 consecutive dots if the top level branche name has a trailing dot. The name of the collection's index leaf also no longer include the dot. For example for ""t."" the names where ""t._"" and ""t..fValue"" and are now ""t_"" and ""t.fValue"". . ## RDataFrame. ### New features. - Introduce `ROOT::RDF::RunGraphs`, which allows to compute the results of multiple `RDataFrame`s (or better, multiple independent computation graphs) concurrently while sharing the same thread pool. The computation may be more efficient than running the `RDataFrame`s sequentially if an analysis consists of several computation graphs that individually do not fully utilize the available resources. See e.g. [this tutorial](https://root.cern/doc/master/df104__HiggsToTwoPhotons_8py.html) for an example usage.; - `RDataFrame` now supports reading friend `TTree`s with a `TTreeIndex`, aka ""indexed friends"". More details at [RO",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v624/index.md:5356,guid,guide,5356,README/ReleaseNotes/v624/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v624/index.md,1,['guid'],['guide']
Usability,"ath::MinimizerOptions` class. If the requested minimizer is not available in ROOT, the default one is used. The default minimizer type and algorithm can be specified by using the; static function `ROOT::Math::MinimizerOptions::SetDefaultMinimizer(""minimizerName"")`. ### Minimizer Libraries and Algorithms. The list of available minimizer libraries currently available in ROOT, with their corresponding available algorithms is the following one.; Some minimizers (e.g. *Minuit*) contain several algorithms that the user can; choose. Others are based on a single algorithm (e.g. *Fumili*). - **`Minuit`** (library *libMinuit*). Old version of Minuit, based on the `TMinuit` class. The list of possible algorithms are:; - *`Migrad`* (default one); 	 - *`Simplex`*; - *`Minimize`* (it is a combination of Migrad and Simplex); - *`MigradImproved`*; 	 - *`Scan`*; 	 - *`Seek`*. - **`Minuit2`** (library *libMinuit2*). New C++ version of Minuit. The list of possible algorithm is :; - *`Migrad`* (default); - *`Simplex`*; 	 - *`Minimize`*; 	 - *`Scan`*; 	 - *`Fumili`* . This is the same algorithm of `TFumili`, but implemented in the Minuit2 library. - **`Fumili`**. Implement a dedicated minimization algorithm for least-square and likelihood fits. It has requirements on the type of method function to be used.; No specific algorithm exists. - **`GSLMultiMin`** (library *libMathMore*). Minimizer based on the Multidimensional Minimization routines of the Gnu Scientific Library (GSL). The list of available algorithms is; 	- *`BFGS2`* (default) : second version of the vector Broyden-Fletcher-Goldfarb-Shanno (BFGS) algorithm;; 	- *`BFGS`* : old version of the vector Broyden-Fletcher-Goldfarb-Shanno (BFGS) algorithm;; 	- *`ConjugateFR`* : Fletcher-Reeves conjugate gradient algorithm;; 	- *`ConjugatePR`* : Polak-Ribiere conjugate gradient algorithm;; 	- *`SteepestDescent`*: steepest descent algorithm;. - **`GSLMultiFit`** (library *libMathMore*). Minimizer based on the Non-Linear Least-Square routi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:41400,Simpl,Simplex,41400,documentation/users-guide/FittingHistograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md,1,['Simpl'],['Simplex']
Usability,"athText interface](https://root.cern.ch/doc/master/classTMathText.html); is invoked. It provides the plain TeX syntax and allow to access character's; set like Russian and Japanese. ## Interpretation and Compilation. As you observed, up to now we heavily exploited the capabilities of ROOT; for interpreting our code, more than compiling and then executing. This; is sufficient for a wide range of applications, but you might have; already asked yourself ""how can this code be compiled ?"". There are two; answers. ### Compile a Macro with ACLiC. ACLiC will create for you a compiled dynamic library for your macro,; without any effort from your side, except the insertion of the; appropriate header files in lines *5--11*. In this example, they are; already included. To generate an object library from the macro code, from inside the; interpreter type (please note the ""+""):. ``` {.cpp}; root [1] .L macro1.C+; ```. Once this operation is accomplished, the macro symbols will be available; in memory and you will be able to execute it simply by calling from; inside the interpreter:. ``` {.cpp}; root [2] macro1(); ```. ### Compile a Macro with the Compiler. A plethora of excellent compilers are available, both free and; commercial. We will refer to the `GCC` compiler in the following. In; this case, you have to include the appropriate headers in the code and; then exploit the *root-config* tool for the automatic settings of all; the compiler flags. *root-config* is a script that comes with ROOT; it; prints all flags and libraries needed to compile code and link it with; the ROOT libraries. In order to make the code executable stand-alone, an; entry point for the operating system is needed, in C++ this is the; procedure `int main();`. The easiest way to turn a ROOT macro code into; a stand-alone application is to add the following ""dressing code"" at the; end of the macro file. This defines the procedure main, the only purpose; of which is to call your macro:. ``` {.cpp}; int main() ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/your_first_ROOT_macro.md:9811,simpl,simply,9811,documentation/primer/your_first_ROOT_macro.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/your_first_ROOT_macro.md,1,['simpl'],['simply']
Usability,"atic"" storage; class specifier (""static"" keyword) written in the source. Given:; static void f() {}; static int i = 0;; extern int j;; int k;; functionDecl(isStaticStorageClass()); matches the function declaration f.; varDecl(isStaticStorageClass()); matches the variable declaration i. Matcher<VarDecl>isTemplateInstantiation; Matches template instantiations of function, class, or static; member variable template instantiations. Given; template <typename T> class X {}; class A {}; X<A> x;; or; template <typename T> class X {}; class A {}; template class X<A>;; or; template <typename T> class X {}; class A {}; extern template class X<A>;; cxxRecordDecl(hasName(""::X""), isTemplateInstantiation()); matches the template instantiation of X<A>. But given; template <typename T> class X {}; class A {};; template <> class X<A> {}; X<A> x;; cxxRecordDecl(hasName(""::X""), isTemplateInstantiation()); does not match, as X<A> is an explicit template specialization. Usable as: Matcher<FunctionDecl>, Matcher<VarDecl>, Matcher<CXXRecordDecl>. AST Traversal Matchers. Traversal matchers specify the relationship to other nodes that are; reachable from the current node.; Note that there are special traversal matchers (has, hasDescendant, forEach and; forEachDescendant) which work on all nodes and allow users to write more generic; match expressions. Return typeNameParameters. Matcher<*>binaryOperationMatcher<*>...Matcher<*>; Matches nodes which can be used with binary operators. The code; var1 != var2;; might be represented in the clang AST as a binaryOperator, a; cxxOperatorCallExpr or a cxxRewrittenBinaryOperator, depending on. * whether the types of var1 and var2 are fundamental (binaryOperator) or at; least one is a class type (cxxOperatorCallExpr); * whether the code appears in a template declaration, if at least one of the; vars is a dependent-type (binaryOperator); * whether the code relies on a rewritten binary operator, such as a; spaceship operator or an inverted equality operato",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:129526,Usab,Usable,129526,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['Usab'],['Usable']
Usability,"atically when objects are; added. At creation time one specifies the default array size (default =; 16) and lower bound (default = 0). Resizing involves a re-allocation and; a copy of the old array to the new. This can be costly if done too; often. If possible, set initial size close to expected final size. Index; validity is always checked (if you are 100% sure and maximum performance; is needed you can use `UnCheckedAt()` instead of `At()` or; `operator[]`). If the stored objects are sort able the array can be; sorted using `Sort()`. Once sorted, efficient searching is possible via; the `BinarySearch()` method. The figure shows the internal data; structure of a **`TObjArray`**:. ![The internal data structure of a TObjArray](pictures/020001A7.jpg). Iterating can be done using a **`TIter`** iterator or via a simple for; loop:. ``` {.cpp}; for (int i = 0; i <= fArr.GetLast(); i++); if ((track = (TTrack*)fArr[i])) // or fArr.At(i); track->Draw();; ```. Main features of **`TObjArray`** are simple, well-known array semantics.; **Overhead per element**: none, except possible over sizing of `fCont`. ## TClonesArray An Array of Identical Objects. A **`TClonesArray`** is an array of identical (clone) objects. The; memory for the objects stored in the array is allocated only once in the; lifetime of the clones array. All objects must be of the same class. For; the rest this class has the same properties as a **`TObjArray`**. ![The internal data structure of a TClonesArray](pictures/020001A8.jpg). The figure above shows the internal data structure of a; **`TClonesArray`**. The class is specially designed for repetitive data; analysis tasks, where in a loop many times the same objects, are created; and deleted. The only supported way to add objects to a; **`TClonesArray`** is via the `new` with placement method. The different; `Add()` methods of **`TObjArray`** and its base classes are not; supported. ### The Idea Behind TClonesArray. To reduce the very large number of new and ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md:15966,simpl,simple,15966,documentation/users-guide/CollectionClasses.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md,1,['simpl'],['simple']
Usability,"ating the; memory for the `async context` but can use the `async function pointer` struct; to obtain the required size. .. code-block:: c. struct async_function_pointer {; uint32_t relative_function_pointer_to_async_impl;; uint32_t context_size;; }. Lowering will split an async coroutine into a ramp function and one resume; function per suspend point. How control-flow is passed between caller, suspension point, and back to; resume function is left up to the frontend. The suspend point takes a function and its arguments. The function is intended; to model the transfer to the callee function. It will be tail called by; lowering and therefore must have the same signature and calling convention as; the async coroutine. .. code-block:: llvm. call {ptr, ptr, ptr} (ptr, ptr, ...) @llvm.coro.suspend.async(; ptr %resume_func_ptr,; ptr %context_projection_function,; ptr %suspend_function,; ptr %arg1, ptr %arg2, i8 %arg3). Coroutines by Example; =====================. The examples below are all of switched-resume coroutines. Coroutine Representation; ------------------------. Let's look at an example of an LLVM coroutine with the behavior sketched; by the following pseudo-code. .. code-block:: c++. void *f(int n) {; for(;;) {; print(n++);; <suspend> // returns a coroutine handle on first suspend; }; }. This coroutine calls some function `print` with value `n` as an argument and; suspends execution. Every time this coroutine resumes, it calls `print` again with an argument one bigger than the last time. This coroutine never completes by itself and must be destroyed explicitly. If we use this coroutine with; a `main` shown in the previous section. It will call `print` with values 4, 5; and 6 after which the coroutine will be destroyed. The LLVM IR for this coroutine looks like this:. .. code-block:: llvm. define ptr @f(i32 %n) presplitcoroutine {; entry:; %id = call token @llvm.coro.id(i32 0, ptr null, ptr null, ptr null); %size = call i32 @llvm.coro.size.i32(); %alloc = call pt",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:10760,resume,resume,10760,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"ation code:. .. code-block:: llvm. cleanup:; %mem = call ptr @llvm.coro.free(token %id, ptr %hdl); %need.dyn.free = icmp ne ptr %mem, null; br i1 %need.dyn.free, label %dyn.free, label %if.end; dyn.free:; call void @CustomFree(ptr %mem); br label %if.end; if.end:; ... With allocations and deallocations represented as described as above, after; coroutine heap allocation elision optimization, the resulting main will be:. .. code-block:: llvm. define i32 @main() {; entry:; call void @print(i32 4); call void @print(i32 5); call void @print(i32 6); ret i32 0; }. Multiple Suspend Points; -----------------------. Let's consider the coroutine that has more than one suspend point:. .. code-block:: c++. void *f(int n) {; for(;;) {; print(n++);; <suspend>; print(-n);; <suspend>; }; }. Matching LLVM code would look like (with the rest of the code remaining the same; as the code in the previous section):. .. code-block:: llvm. loop:; %n.addr = phi i32 [ %n, %entry ], [ %inc, %loop.resume ]; call void @print(i32 %n.addr) #4; %2 = call i8 @llvm.coro.suspend(token none, i1 false); switch i8 %2, label %suspend [i8 0, label %loop.resume; i8 1, label %cleanup]; loop.resume:; %inc = add nsw i32 %n.addr, 1; %sub = xor i32 %n.addr, -1; call void @print(i32 %sub); %3 = call i8 @llvm.coro.suspend(token none, i1 false); switch i8 %3, label %suspend [i8 0, label %loop; i8 1, label %cleanup]. In this case, the coroutine frame would include a suspend index that will; indicate at which suspend point the coroutine needs to resume. .. code-block:: llvm. %f.frame = type { ptr, ptr, i32, i32 }. The resume function will use an index to jump to an appropriate basic block and will look; as follows:. .. code-block:: llvm. define internal fastcc void @f.Resume(ptr %FramePtr) {; entry.Resume:; %index.addr = getelementptr inbounds %f.Frame, ptr %FramePtr, i64 0, i32 2; %index = load i8, ptr %index.addr, align 1; %switch = icmp eq i8 %index, 0; %n.addr = getelementptr inbounds %f.Frame, ptr %FramePtr, i64 ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:18386,resume,resume,18386,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"ation with additional labels to define where control; flow goes after the call. The output values of a '``callbr``' instruction are available only to; the '``fallthrough``' block, not to any '``indirect``' blocks(s). The only use of this today is to implement the ""goto"" feature of gcc inline; assembly where additional labels can be provided as locations for the inline; assembly to jump to. Example:; """""""""""""""". .. code-block:: llvm. ; ""asm goto"" without output constraints.; callbr void asm """", ""r,!i""(i32 %x); to label %fallthrough [label %indirect]. ; ""asm goto"" with output constraints.; <result> = callbr i32 asm """", ""=r,r,!i""(i32 %x); to label %fallthrough [label %indirect]. .. _i_resume:. '``resume``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. resume <type> <value>. Overview:; """""""""""""""""". The '``resume``' instruction is a terminator instruction that has no; successors. Arguments:; """""""""""""""""""". The '``resume``' instruction requires one argument, which must have the; same type as the result of any '``landingpad``' instruction in the same; function. Semantics:; """""""""""""""""""". The '``resume``' instruction resumes propagation of an existing; (in-flight) exception whose unwinding was interrupted with a; :ref:`landingpad <i_landingpad>` instruction. Example:; """""""""""""""". .. code-block:: llvm. resume { ptr, i32 } %exn. .. _i_catchswitch:. '``catchswitch``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <resultval> = catchswitch within <parent> [ label <handler1>, label <handler2>, ... ] unwind to caller; <resultval> = catchswitch within <parent> [ label <handler1>, label <handler2>, ... ] unwind label <default>. Overview:; """""""""""""""""". The '``catchswitch``' instruction is used by `LLVM's exception handling system; <ExceptionHandling.html#overview>`_ to describe the set of possible catch handlers; that may be executed by the :ref:`EH personality routine <personalityfn>`. Arguments:; """""""""""""""""""". The ``parent`` argument is the token of the funclet t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:369937,resume,resume,369937,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['resume'],['resume']
Usability,"ations are required to be instantiated separately (this; includes default arguments and exception specifications), and such; instantiations update the existing declaration. These cases tend to be fragile; mutable AST state should be avoided where; possible. As a consequence of this design principle, we typically do not provide setters; for AST state. (Some are provided for short-term modifications intended to be; used immediately after an AST node is created and before it's ""published"" as; part of the complete AST, or where language semantics require after-the-fact; updates.). Faithfulness; ^^^^^^^^^^^^. The AST intends to provide a representation of the program that is faithful to; the original source. We intend for it to be possible to write refactoring tools; using only information stored in, or easily reconstructible from, the Clang AST.; This means that the AST representation should either not desugar source-level; constructs to simpler forms, or -- where made necessary by language semantics; or a clear engineering tradeoff -- should desugar minimally and wrap the result; in a construct representing the original source form. For example, ``CXXForRangeStmt`` directly represents the syntactic form of a; range-based for statement, but also holds a semantic representation of the; range declaration and iterator declarations. It does not contain a; fully-desugared ``ForStmt``, however. Some AST nodes (for example, ``ParenExpr``) represent only syntax, and others; (for example, ``ImplicitCastExpr``) represent only semantics, but most nodes; will represent a combination of syntax and associated semantics. Inheritance; is typically used when representing different (but related) syntaxes for nodes; with the same or similar semantics. .. _Type:. The ``Type`` class and its subclasses; -------------------------------------. The ``Type`` class (and its subclasses) are an important part of the AST.; Types are accessed through the ``ASTContext`` class, which implicitly creates",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:60232,simpl,simpler,60232,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,2,"['clear', 'simpl']","['clear', 'simpler']"
Usability,"ations. The; curve resulting from each scan can be plotted on the output terminal; using MnPlot [api:plot] in order to show the approximate behaviour of; the function. ### ScanMinimizer ###. Although the $\mbox{SCAN}$ method is not intended for minimization; it can be used as a minimizer in its most primitive form. ## MnSimplex and SimplexMinimizer ##. [api:simplex]. $\mbox{SIMPLEX}$ is a function minimization method using the simplex; method of Nelder and Mead. MnSimplex provides minimization of the; function by the method of $\mbox{SIMPLEX}$ and the functionality for; parameters interaction. It also retains the result from the last; minimization in case the user may want to do subsequent minimization; steps with parameter interactions in between the minimization requests.; The minimization is done by the SimplexMinimizer. Minimization of the; function can be done by directly using the SimplexMinimizer if no; parameters interaction is required. As $\mbox{SIMPLEX}$ is a; stepping method it does not produce a covariance matrix. ### MnSimplex(const FCNBase&, const std::vector$<$double$>$&,\; const std::vector$<$double$>$&, unsigned int) ###. Constructor for the minimal required interface: $\mbox{FCN}$ and; starting values for parameters and uncertainties. Optional the strategy; level in MnStrategy can be specified. ### MnSimplex(const FCNBase&, const MnUserParameters&,\; unsigned int) ###. Constructor for high level parameters interface. Optional the strategy; level in MnStrategy can be specified. ### MnSimplex(const FCNBase&, const MnUserParameterState&,\; const MnStrategy&) ###. Constructor from a full state (parameters + covariance) as starting; input plus the desired strategy. ### operator() ###. MnSimplex::operator()(unsigned int maxfcn, double tolerance) causes; minimization of the $\mbox{FCN}$ and returns the result in form of a; FunctionMinimum. Minimization terminates either when the function has; been called (approximately) $\mbox{maxfcn}$ times, or when the;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:49016,SIMPL,SIMPLEX,49016,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['SIMPL'],['SIMPLEX']
Usability,ations; Unknown. 2047; CD4; Coordinating “throws anything” specifications; Unknown. 2048; open; C-style casts that cast away constness vs static_cast; Not resolved. 2049; drafting; List initializer in non-type template default argument; Clang 18. 2050; NAD; Consolidate specification of linkage; Unknown. 2051; CD5; Simplifying alias rules; Unknown. 2052; CD4; Template argument deduction vs overloaded operators; Unknown. 2053; C++20; auto in non-generic lambdas; Unknown. 2054; DR; Missing description of class SFINAE; Unknown. 2055; drafting; Explicitly-specified non-deduced parameter packs; Not resolved. 2056; drafting; Member function calls in partially-initialized class objects; Not resolved. 2057; drafting; Template template arguments with default arguments; Not resolved. 2058; CD6; More errors from internal-linkage namespaces; Unknown. 2059; CD5; Linkage and deduced return types; Unknown. 2060; NAD; Deduced return type for explicit specialization; Unknown. 2061; CD4; Inline namespace after simplifications; Yes. 2062; CD6; Class template redeclaration requirements; Unknown. 2063; CD4; Type/nontype hiding in class scope; Unknown. 2064; CD4; Conflicting specifications for dependent decltype-specifiers; Unknown. 2065; CD6; Current instantiation of a partial specialization; Unknown. 2066; CD4; Does type-dependent imply value-dependent?; Unknown. 2067; open; Generated variadic templates requiring empty pack; Not resolved. 2068; CD4; When can/must a defaulted virtual destructor be defined?; Unknown. 2069; CD4; Do destructors have names?; Unknown. 2070; CD6; using-declaration with dependent nested-name-specifier; Unknown. 2071; CD4; typedef with no declarator; Unknown. 2072; C++23; Default argument instantiation for member functions of templates; Unknown. 2073; drafting; Allocating memory for exception objects; Not resolved. 2074; drafting; Type-dependence of local class of function template; Not resolved. 2075; CD4; Passing short initializer lists to array reference para,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:140101,simpl,simplifications,140101,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['simpl'],['simplifications']
Usability,"atrixDColumn m1(m,1); m1(2) = 3; // the same as m(2,1)=3;; ~~~. Note, constructing of, say, TMatrixDDiag does *not* involve any; copying of any elements of the source matrix. #### 5. It's possible (and encouraged) to use ""nested"" functions; For example, creating of a Hilbert matrix can be done as follows:. ~~~ {.cpp}; void foo(const TMatrixD &m); {; TMatrixD m1(TMatrixD::kZero,m);; struct MakeHilbert : public TElementPosActionD {; void Operation(Double_t &element); { element = 1./(fI+fJ-1); }; };; m1.Apply(MakeHilbert());; }; ~~~. of course, using a special method THilbertMatrixD() is; still more optimal, but not by a whole lot. And that's right,; class MakeHilbert is declared *within* a function and local to; that function. It means one can define another MakeHilbert class; (within another function or outside of any function, that is, in; the global scope), and it still will be OK. Note, this currently; is not yet supported by the interpreter CINT. Another example is applying of a simple function to each matrix element:. ~~~ {.cpp}; void foo(TMatrixD &m,TMatrixD &m1); {; typedef double (*dfunc_t)(double);; class ApplyFunction : public TElementActionD {; dfunc_t fFunc;; void Operation(Double_t &element); { element=fFunc(element); }; public:; ApplyFunction(dfunc_t func):fFunc(func) {}; };; ApplyFunction x(TMath::Sin);; m.Apply(x);; }; ~~~. Validation code `$ROOTSYS/test/vmatrix.cxx` and `vvector.cxx` contain; a few more examples of that kind. #### 6. Lazy matrices:. instead of returning an object return a ""recipe""; how to make it. The full matrix would be rolled out only when; and where it's needed:. ~~~ {.cpp}; TMatrixD haar = THaarMatrixD(5);; ~~~. THaarMatrixD() is a *class*, not a simple function. However; similar this looks to a returning of an object (see note #1; above), it's dramatically different. THaarMatrixD() constructs a; TMatrixDLazy, an object of just a few bytes long. A special; ""TMatrixD(const TMatrixDLazy &recipe)"" constructor follows the; recipe an",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/matrix/doc/index.md:17900,simpl,simple,17900,math/matrix/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/matrix/doc/index.md,1,['simpl'],['simple']
Usability,"ave been able to create our wire with a single line:. ~~~{.cpp}; TGeoVolume *wire_co = gGeoManager->MakeTube(""WIRE_CO"",ptrCOPPER,0,0.01,1); //(*); ~~~. (*) The same applies for all primitive shapes, for which there can; be found corresponding `MakeSHAPE()` methods. Their usage is much more; convenient unless a shape has to be shared between more volumes. Let us make now an aluminum wire having the same shape, supposing that; we have created the copper wire with the line above:. ~~~{.cpp}; TGeoVolume *wire_al = new TGeoVolume(""WIRE_AL"",wire_co>GetShape(),; ptrAL);; ~~~. We would like now to position our wire in the middle of a gas chamber.; We need first to define the gas chamber:. ~~~{.cpp}; TGeoVolume *chamber = gGeoManager->MakeTube(""CHAMBER"",ptrGAS,; 0,1,1);; ~~~. Now we can put the wire inside:. ~~~{.cpp}; chamber->AddNode(wire_co,1);; ~~~. If we inspect now the chamber volume in a browser, we will notice that; it has one daughter. Of course, the gas has some container also, but let; us keeps it like that for the sake of simplicity. Since we did not; supply the third argument, the wire will be positioned with an identity; transformation inside the chamber. \anchor GP01bf; #### Overlapping Volumes. Positioning volumes that does not overlap their neighbors nor extrude; their container is sometimes quite strong constraint. Having a limited; set of geometric shapes might force sometimes overlaps. Since; overlapping is contradictory to containment, a point belonging to an; overlapping region will naturally belong to all overlapping partners.; The answer provided by the modeller to ""Where am I?"" is no longer; deterministic if there is no priority assigned. There are two ways out provided by the modeller in such cases and we; will illustrate them by examples. - Suppose we have 2 crossing tubes that we have to describe. Such a; structure cannot be decomposed in a containment schema. This is a; typical example of simple structure that can be handled by using; composite sh",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:35342,simpl,simplicity,35342,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['simpl'],['simplicity']
Usability,"ave; it evaluate its conditional, then return the 'then' or 'else' value; based on how the condition was resolved. This is very similar to the C; ""?:"" expression. The semantics of the if/then/else expression is that it evaluates the; condition to a boolean equality value: 0.0 is considered to be false and; everything else is considered to be true. If the condition is true, the; first subexpression is evaluated and returned, if the condition is; false, the second subexpression is evaluated and returned. Since; Kaleidoscope allows side-effects, this behavior is important to nail; down. Now that we know what we ""want"", let's break this down into its; constituent pieces. Lexer Extensions for If/Then/Else; ---------------------------------. The lexer extensions are straightforward. First we add new enum values; for the relevant tokens:. .. code-block:: c++. // control; tok_if = -6,; tok_then = -7,; tok_else = -8,. Once we have that, we recognize the new keywords in the lexer. This is; pretty simple stuff:. .. code-block:: c++. ...; if (IdentifierStr == ""def""); return tok_def;; if (IdentifierStr == ""extern""); return tok_extern;; if (IdentifierStr == ""if""); return tok_if;; if (IdentifierStr == ""then""); return tok_then;; if (IdentifierStr == ""else""); return tok_else;; return tok_identifier;. AST Extensions for If/Then/Else; -------------------------------. To represent the new expression we add a new AST node for it:. .. code-block:: c++. /// IfExprAST - Expression class for if/then/else.; class IfExprAST : public ExprAST {; std::unique_ptr<ExprAST> Cond, Then, Else;. public:; IfExprAST(std::unique_ptr<ExprAST> Cond, std::unique_ptr<ExprAST> Then,; std::unique_ptr<ExprAST> Else); : Cond(std::move(Cond)), Then(std::move(Then)), Else(std::move(Else)) {}. Value *codegen() override;; };. The AST node just has pointers to the various subexpressions. Parser Extensions for If/Then/Else; ----------------------------------. Now that we have the relevant tokens coming from the lexer a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst:2616,simpl,simple,2616,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst,1,['simpl'],['simple']
Usability,"aversed using the; ``CFGBlock::*iterator`` interface. A ``CFG`` object owns the instances of ``CFGBlock`` within the control-flow; graph it represents. Each ``CFGBlock`` within a CFG is also uniquely numbered; (accessible via ``CFGBlock::getBlockID()``). Currently the number is based on; the ordering the blocks were created, but no assumptions should be made on how; ``CFGBlocks`` are numbered other than their numbers are unique and that they; are numbered from 0..N-1 (where N is the number of basic blocks in the CFG). Entry and Exit Blocks; ^^^^^^^^^^^^^^^^^^^^^. Each instance of ``CFG`` contains two special blocks: an *entry* block; (accessible via ``CFG::getEntry()``), which has no incoming edges, and an; *exit* block (accessible via ``CFG::getExit()``), which has no outgoing edges.; Neither block contains any statements, and they serve the role of providing a; clear entrance and exit for a body of code such as a function body. The; presence of these empty blocks greatly simplifies the implementation of many; analyses built on top of CFGs. .. _ConditionalControlFlow:. Conditional Control-Flow; ^^^^^^^^^^^^^^^^^^^^^^^^. Conditional control-flow (such as those induced by if-statements and loops) is; represented as edges between ``CFGBlocks``. Because different C language; constructs can induce control-flow, each ``CFGBlock`` also records an extra; ``Stmt*`` that represents the *terminator* of the block. A terminator is; simply the statement that caused the control-flow, and is used to identify the; nature of the conditional control-flow between blocks. For example, in the; case of an if-statement, the terminator refers to the ``IfStmt`` object in the; AST that represented the given branch. To illustrate, consider the following code example:. .. code-block:: c++. int foo(int x) {; x = x + 1;; if (x > 2); x++;; else {; x += 2;; x *= 2;; }. return x;; }. After invoking the parser+semantic analyzer on this code fragment, the AST of; the body of ``foo`` is referenced by ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:113934,simpl,simplifies,113934,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['simpl'],['simplifies']
Usability,"aw();; ```. Of course, this version shows the same results as the initial one. Try; playing with the parameters and plot the function again. The class `TF1`; has a large number of very useful methods, including integration and; differentiation. To make full use of this and other ROOT classes, visit; the documentation on the Internet under; <https://root.cern/doc/master/>. Formulae in ROOT; are evaluated using the class `TFormula`, so also look up the relevant; class documentation for examples, implemented functions and syntax. You should definitely download this guide to your own system to have it; at you disposal whenever you need it. To extend a little bit on the above example, consider a more complex; function you would like to define. You can also do this using standard; `C` or `C++` code. Consider the example below, which calculates and displays the; interference pattern produced by light falling on a multiple slit.; Please do not type in the example below at the ROOT command line, there; is a much simpler way: Make sure you have the file `slits.C` on disk,; and type `root slits.C` in the shell. This will start root and make it; read the ""macro"" `slits.C`, i.e. all the lines in the file will be; executed one after the other. ``` {.cpp .numberLines}; @ROOT_INCLUDE_FILE macros/slits.C; ```; [f21]: figures/TF1_DoubleSlit.png ""f21""; <a name=""f21""></a>. ![Output of slits.C with parameters 0.2 and 2.\label{f21}][f21]. The example first asks for user input, namely the ratio of slit width; over slit distance, and the number of slits. After entering this; information, you should see the graphical output as is shown in Figure [2.1](#f21). This is a more complicated example than the ones we have seen before, so; spend some time analysing it carefully, you should have understood it; before continuing. Let us go through it in detail:. Lines *7-18* define the necessary functions in `C++` code, split into; three separate functions, as suggested by the problem considered. The; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md:5338,simpl,simpler,5338,documentation/primer/ROOT_as_calculator.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md,1,['simpl'],['simpler']
Usability,"awtText`, `TTF::SetTextSize` was called with a rounded; value (to pixel). This cause some misplacements of character in TLatex; formulae. ### TPDF and TPostScript. - Parenthesis can be used in PDF and PS file names.; - In PDF files, italic greek characters were not correct for non null; text angle. ### TImageDump; - Fix a `TBox` clipping issue. ### TSVG; - Some markers did not show in Google-Chrome. ### New class TTeXDump: Graphics interface to TeX. This class allow to generate `PGF/TikZ` vector graphics output; which can be included in TeX and LaTeX documents. `PGF` is a TeX macro package for generating graphics. It is platform; and format-independent and works together with the most important TeX; backend drivers, including pdftex and dvips. It comes with a; user-friedly syntax layer called `TikZ`. To generate a such file it is enough to do:. ```; gStyle->SetPaperSize(10.,10.);; hpx->Draw();; gPad->Print(""hpx.tex"");; ```. Then, the generated file (<tt>hpx.tex</tt>) can be included in a; LaTeX document (`simple.tex`) in the following way:. ```; \documentclass{article}; \usepackage{tikz}; \usetikzlibrary{patterns}; \title{A simple LaTeX example}; \date{July 2013}; \begin{document}; \maketitle; The following image as been generated using the TTeXDump class:; \par; \input{hpx.tex}; \end{document}; ```. Note the two directive needed at the top of the LaTeX file:. ```; \usepackage{tikz}; \usetikzlibrary{patterns}; ```. Then including the picture in the document is done with the; `\input` directive. The command `pdflatex simple.tex` will generate the corresponding pdf; file `simple.pdf`. ### X11 fonts. - A coverity fix in `Rotated.cxx` had a side effect on rotated text; drawn with X11 fonts. ### TCanvas and TPad. - `TPad::SaveAs` produces named macros in .C files.; - Change the way the string input is done in the Pad toolbar for text; and Pave Label. It doesn't use anymore the `TGX11` function `RequestString`.; Now the text appears directly as it will show and it is poss",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/doc/v600/index.md:1209,simpl,simple,1209,graf2d/doc/v600/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/doc/v600/index.md,1,['simpl'],['simple']
Usability,"ay after a click on ‘axis'—the axis editor is active; a click on a; ‘pad' activates the pad editor, etc. The algorithm in use is simple and is based on the object-oriented; relationship and communication. When the user activates the editor,; according to the selected object **`<obj>`** in the canvas it looks for; a class name **`<obj>Editor`**. For that reason, the correct naming is; very important. If a class with this name is found, the editor verifies; that this class derives from the base editor class **`TGedFrame`**. If; all checks are satisfied, the editor makes an instance of the object; editor. Then, it scans all object base classes searching the; corresponding object editors. When it finds one, it makes an instance of; the base class editor too. Once the object editor is in place, it sets the user interface elements; according to the object's status. After that, it is ready to interact; with the object following the user actions. The graphics editor gives an intuitive way to edit objects in a canvas; with immediate feedback. Complexity of some object editors is reduced by; hiding GUI elements and revealing them only on users' requests. An object in the canvas is selected by clicking on it with the left; mouse button. Its name is displayed on the top of the editor frame in; red color. If the editor frame needs more space than the canvas window,; a vertical scroll bar appears for easy navigation. ![Histogram, pad and axis editors](pictures/03000222.png). ### Editor Design Elements. The next rules describe the path to follow when creating your own object; editor that will be recognized and loaded by the graphics editor in; ROOT, i.e. it will be included as a part of it. (a) Derive the code of your object editor from the base editor class; **`TGedFrame`**. (b) Keep the correct naming convention: the name of the object editor; should be the object class name concatenated with the word `‘Editor'`. (c) Provide a default constructor. (d) Use the signals/slots commun",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:103790,intuit,intuitive,103790,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,2,"['feedback', 'intuit']","['feedback', 'intuitive']"
Usability,"ay after a click on ‘axis'—the axis editor is active; a click on a; ‘pad' activates the pad editor, etc. The algorithm in use is simple and is based on the object-oriented; relationship and communication. When the user activates the editor,; according to the selected object **`<obj>`** in the canvas it looks for; a class name **`<obj>Editor`**. For that reason, the correct naming is; very important. If a class with this name is found, the editor verifies; that this class derives from the base editor class **`TGedFrame`**. If; all checks are satisfied, the editor makes an instance of the object; editor. Then, it scans all object base classes searching the; corresponding object editors. When it finds one, it makes an instance of; the base class editor too. Once the object editor is in place, it sets the user interface elements; according to the object's status. After that, it is ready to interact; with the object following the user actions. The graphics editor gives an intuitive way to edit objects in a canvas; with immediate feedback. Complexity of some object editors is reduced by; hiding GUI elements and revealing them only on users' requests. An object in the canvas is selected by clicking on it with the left; mouse button. Its name is displayed on the top of the editor frame in; red color. If the editor frame needs more space than the canvas window,; a vertical scroll bar appears for easy navigation. \image html ged.png width=800px. **Histogram, pad and axis editors**. ### Editor Design Elements. The next rules describe the path to follow when creating your own object; editor that will be recognized and loaded by the graphics editor in; ROOT, i.e. it will be included as a part of it. (a) Derive the code of your object editor from the base editor class; **`TGedFrame`**. (b) Keep the correct naming convention: the name of the object editor; should be the object class name concatenated with the word `‘Editor'`. (c) Provide a default constructor. (d) Use the signals/s",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/ged/doc/index.md:2820,intuit,intuitive,2820,gui/ged/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/ged/doc/index.md,2,"['feedback', 'intuit']","['feedback', 'intuitive']"
Usability,"ayer concept by using a new layer,; IRTransformLayer, to add IR optimization support to KaleidoscopeJIT. Optimizing Modules using the IRTransformLayer; =============================================. In `Chapter 4 <LangImpl04.html>`_ of the ""Implementing a language with LLVM""; tutorial series the llvm *FunctionPassManager* is introduced as a means for; optimizing LLVM IR. Interested readers may read that chapter for details, but; in short: to optimize a Module we create an llvm::FunctionPassManager; instance, configure it with a set of optimizations, then run the PassManager on; a Module to mutate it into a (hopefully) more optimized but semantically; equivalent form. In the original tutorial series the FunctionPassManager was; created outside the KaleidoscopeJIT and modules were optimized before being; added to it. In this Chapter we will make optimization a phase of our JIT; instead. For now this will provide us a motivation to learn more about ORC; layers, but in the long term making optimization part of our JIT will yield an; important benefit: When we begin lazily compiling code (i.e. deferring; compilation of each function until the first time it's run) having; optimization managed by our JIT will allow us to optimize lazily too, rather; than having to do all our optimization up-front. To add optimization support to our JIT we will take the KaleidoscopeJIT from; Chapter 1 and compose an ORC *IRTransformLayer* on top. We will look at how the; IRTransformLayer works in more detail below, but the interface is simple: the; constructor for this layer takes a reference to the execution session and the; layer below (as all layers do) plus an *IR optimization function* that it will; apply to each Module that is added via addModule:. .. code-block:: c++. class KaleidoscopeJIT {; private:; ExecutionSession ES;; RTDyldObjectLinkingLayer ObjectLayer;; IRCompileLayer CompileLayer;; IRTransformLayer TransformLayer;. DataLayout DL;; MangleAndInterner Mangle;; ThreadSafeContex",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT2.rst:2111,learn,learn,2111,interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT2.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT2.rst,1,['learn'],['learn']
Usability,"ays follow the; severity of the previously emitted diagnostic and ``ERROR``\ s, which can only; be mapped to ``Fatal`` (it is not possible to turn an error into a warning, for; example). Diagnostic mappings are used in many ways. For example, if the user specifies; ``-pedantic``, ``EXTENSION`` maps to ``Warning``, if they specify; ``-pedantic-errors``, it turns into ``Error``. This is used to implement; options like ``-Wunused_macros``, ``-Wundef`` etc. Mapping to ``Fatal`` should only be used for diagnostics that are considered so; severe that error recovery won't be able to recover sensibly from them (thus; spewing a ton of bogus errors). One example of this class of error are failure; to ``#include`` a file. The Format String; ^^^^^^^^^^^^^^^^^. The format string for the diagnostic is very simple, but it has some power. It; takes the form of a string in English with markers that indicate where and how; arguments to the diagnostic are inserted and formatted. For example, here are; some simple format strings:. .. code-block:: c++. ""binary integer literals are an extension""; ""format string contains '\\0' within the string body""; ""more '%%' conversions than data arguments""; ""invalid operands to binary expression (%0 and %1)""; ""overloaded '%0' must be a %select{unary|binary|unary or binary}2 operator""; "" (has %1 parameter%s1)"". These examples show some important points of format strings. You can use any; plain ASCII character in the diagnostic string except ""``%``"" without a; problem, but these are C strings, so you have to use and be aware of all the C; escape sequences (as in the second example). If you want to produce a ""``%``""; in the output, use the ""``%%``"" escape sequence, like the third diagnostic.; Finally, Clang uses the ""``%...[digit]``"" sequences to specify where and how; arguments to the diagnostic are formatted. Arguments to the diagnostic are numbered according to how they are specified by; the C++ code that :ref:`produces them <internals-producing-diag",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:6468,simpl,simple,6468,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['simpl'],['simple']
Usability,"ays is of variable length, and in particular; that the second array is jagged. **Example:** Suppose a hypothetical PDB file with a 4KiB block size, and 4; streams of lengths {1000 bytes, 8000 bytes, 16000 bytes, 9000 bytes}. Stream 0: ceil(1000 / 4096) = 1 block. Stream 1: ceil(8000 / 4096) = 2 blocks. Stream 2: ceil(16000 / 4096) = 4 blocks. Stream 3: ceil(9000 / 4096) = 3 blocks. In total, 10 blocks are used. Let's see what the stream directory might look; like:. .. code-block:: c++. struct StreamDirectory {; ulittle32_t NumStreams = 4;; ulittle32_t StreamSizes[] = {1000, 8000, 16000, 9000};; ulittle32_t StreamBlocks[][] = {; {4},; {5, 6},; {11, 9, 7, 8},; {10, 15, 12}; };; };. In total, this occupies ``15 * 4 = 60`` bytes, so; ``SuperBlock->NumDirectoryBytes`` would equal ``60``, and; ``SuperBlock->BlockMapAddr`` would be an array of one ``ulittle32_t``, since; ``60 <= SuperBlock->BlockSize``. Note also that the streams are discontiguous, and that part of stream 3 is in the; middle of part of stream 2. You cannot assume anything about the layout of the; blocks!. Alignment and Block Boundaries; ==============================; As may be clear by now, it is possible for a single field (whether it be a high; level record, a long string field, or even a single ``uint16``) to begin and; end in separate blocks. For example, if the block size is 4096 bytes, and a; ``uint16`` field begins at the last byte of the current block, then it would; need to end on the first byte of the next block. Since blocks are not; necessarily contiguously laid out in the file, this means that both the consumer; and the producer of an MSF file must be prepared to split data apart; accordingly. In the aforementioned example, the high byte of the ``uint16``; would be written to the last byte of block N, and the low byte would be written; to the first byte of block N+1, which could be tens of thousands of bytes later; (or even earlier!) in the file, depending on what the stream directory says.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PDB/MsfFile.rst:6874,clear,clear,6874,interpreter/llvm-project/llvm/docs/PDB/MsfFile.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PDB/MsfFile.rst,1,['clear'],['clear']
Usability,"b browser.; Dedicated for the case when ROOT should be running as server application, providing different RWebWindow instances for connection. ## Montecarlo Libraries. ## PROOF Libraries. ## Language Bindings. ## JavaScript ROOT. ## Jupyter lab. - Let use created notebooks with viewers like https://nbviewer.jupyter.org/; - Fix problem with using of local JSROOT version. ## Tutorials. - The tutorial games.C was not working properly. - Improve tutorial ErrorIntegral.C. - Schrödinger's Hydrogen Atom example. - Tutorial demonstrating how the changing of the range can zoom into the histogram. - Tutorial demonstrating how a Histogram can be read from a ROOT File. - histMax.C: a tutorial demoing how the hist->GetMaximumBin() can be used. ## Class Reference Guide. - Images for ROOT7 tutorials can be generated, in json format, using the directive using; `\macro_image (json)` in the macro header. - Clarify THStack drawing options. - Add missing documentation to TH1 functions. - Restructure the math reference guide. - Make the web gui documentation visible in the reference guide. - Make clear THtml is legacy code. Add deprecated flag on PROOF and TGeoTrack. - Improve many classes documentation: TContext, TTreePlayer, THistPainter, TGraph, TSelector,; integrator, GUI, TH1, TH2, TH3, TColor classes ... - Make the TFile layout doc visible in Reference Guide. - Update the external links of the reference guide main page. - Reformat TMVA mathcore Unuran Roostats documentation . ## Build, Configuration and Testing Infrastructure. - For users building from source the `latest-stable` branch and passing `-Droottest=ON` to the CMake command line, the corresponding revision of roottest pointed to by `latest-stable` will be downloaded as required. ## PyROOT. - The `ROOT` Python module is now properly serializable so that it is automatically available in the Python environment if a function or ROOT object needs to be serialized. See issue [#6764](https://github.com/root-project/root/issues/",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md:38913,guid,guide,38913,README/ReleaseNotes/v626/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md,1,['guid'],['guide']
Usability,"ba type declarations are done lazily, with the ``numba_ext`` module only; initially registering hooks on proxy base classes, to keep overheads in; Numba's type-resolution to a minimum.; On use in a JITed trace, each C++ type or function call is refined to the; actual, concrete types and type-specific overloads, with templates; instantiated as-needed.; Where possible, lowering is kept generic to reduce the number of callbacks; in Numba's compilation chain. Examples; --------. The following, non-exhaustive, set of examples gives an idea of the; current level of support.; More examples can be found in the `test suite`_. C++ free (global) functions can be called and overloads will be selected, or; a template will be instantiated, based on the provided types.; Exact type matches are fully supported, there is some support for typedefs; add implicit conversions for builtin types, there is no support for; conversions of custom types or default arguments. - **Basic usage**: To use ``cppyy`` in Numba JITed code, simply import; ``cppyy.numba_ext``, after which further use is transparent and the same; as when otherwise using ``cppyy`` in Python.; Example:. .. code-block:: python. >>> import numba; >>> import cppyy; >>> import cppyy.numba_ext # enables numba to work with cppyy; >>> import math; >>> @numba.jit(nopython=True); ... def cpp_sqrt(x):; ... return cppyy.gbl.sqrt(x) # direct use, no extra setup required; >>> print(""Sqrt of 4: "", cpp_sqrt(4.0)); Sqrt of 4: 2.0; >>> print(""Sqrt of Pi: "", cpp_sqrt(math.pi)); Sqrt of Pi: 1.7724538509055159. - **Overload selection**: C++ overloads provide different implementations; for different argument types (not to be confused with Numba overloads,; which provide different implementations for the same argument types).; Unfortunately, mapping of Python types to C++ types is often not exact,; so a ""best match"" is chosen, similarly to what ``cppyy`` normally does.; However, the latter, being dynamic, is more flexible.; For example, best-match",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/numba.rst:3578,simpl,simply,3578,bindings/pyroot/cppyy/cppyy/doc/source/numba.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/numba.rst,1,['simpl'],['simply']
Usability,"back control. To enforce these semantics, stackmap and patchpoint intrinsics are; considered to potentially read and write all memory. This may limit; optimization more than some clients desire. This limitation may be; avoided by marking the call site as ""readonly"". In the future we may; also allow meta-data to be added to the intrinsic call to express; aliasing, thereby allowing optimizations to hoist certain loads above; stack maps. Direct Stack Map Entries; ^^^^^^^^^^^^^^^^^^^^^^^^. As shown in :ref:`stackmap-section`, a Direct stack map location; records the address of frame index. This address is itself the value; that the runtime requested. This differs from Indirect locations,; which refer to a stack locations from which the requested values must; be loaded. Direct locations can communicate the address if an alloca,; while Indirect locations handle register spills. For example:. .. code-block:: none. entry:; %a = alloca i64...; llvm.experimental.stackmap(i64 <ID>, i32 <shadowBytes>, ptr %a). The runtime can determine this alloca's relative location on the; stack immediately after compilation, or at any time thereafter. This; differs from Register and Indirect locations, because the runtime can; only read the values in those locations when execution reaches the; instruction address of the stack map. This functionality requires LLVM to treat entry-block allocas; specially when they are directly consumed by an intrinsics. (This is; the same requirement imposed by the llvm.gcroot intrinsic.) LLVM; transformations must not substitute the alloca with any intervening; value. This can be verified by the runtime simply by checking that the; stack map's location is a Direct location type. Supported Architectures; =======================. Support for StackMap generation and the related intrinsics requires; some code for each backend. Today, only a subset of LLVM's backends; are supported. The currently supported architectures are X86_64,; PowerPC, AArch64 and SystemZ.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/StackMaps.rst:20374,simpl,simply,20374,interpreter/llvm-project/llvm/docs/StackMaps.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/StackMaps.rst,1,['simpl'],['simply']
Usability,"basic block to start insertion into.; BasicBlock *BB = BasicBlock::Create(*TheContext, ""entry"", TheFunction);; Builder->SetInsertPoint(BB);. // Record the function arguments in the NamedValues map.; NamedValues.clear();; for (auto &Arg : TheFunction->args()); NamedValues[std::string(Arg.getName())] = &Arg;. Now we get to the point where the ``Builder`` is set up. The first line; creates a new `basic block <http://en.wikipedia.org/wiki/Basic_block>`_; (named ""entry""), which is inserted into ``TheFunction``. The second line; then tells the builder that new instructions should be inserted into the; end of the new basic block. Basic blocks in LLVM are an important part; of functions that define the `Control Flow; Graph <http://en.wikipedia.org/wiki/Control_flow_graph>`_. Since we; don't have any control flow, our functions will only contain one block; at this point. We'll fix this in `Chapter 5 <LangImpl05.html>`_ :). Next we add the function arguments to the NamedValues map (after first clearing; it out) so that they're accessible to ``VariableExprAST`` nodes. .. code-block:: c++. if (Value *RetVal = Body->codegen()) {; // Finish off the function.; Builder->CreateRet(RetVal);. // Validate the generated code, checking for consistency.; verifyFunction(*TheFunction);. return TheFunction;; }. Once the insertion point has been set up and the NamedValues map populated,; we call the ``codegen()`` method for the root expression of the function. If no; error happens, this emits code to compute the expression into the entry block; and returns the value that was computed. Assuming no error, we then create an; LLVM `ret instruction <../../LangRef.html#ret-instruction>`_, which completes the function.; Once the function is built, we call ``verifyFunction``, which is; provided by LLVM. This function does a variety of consistency checks on; the generated code, to determine if our compiler is doing everything; right. Using this is important: it can catch a lot of bugs. Once the; funct",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst:15329,clear,clearing,15329,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst,1,['clear'],['clearing']
Usability,"be coroutine promise>; <SUSPEND> // injected suspend point, so that the coroutine starts suspended; for (int i = 0; i < n; ++i) {; current_value = i; <SUSPEND>; // corresponds to ""yield i""; }; <SUSPEND final=true> // injected final suspend point; }. and python iterator `__next__` would look like:. .. code-block:: c++. int __next__(void* hdl) {; coro.resume(hdl);; if (coro.done(hdl)) throw StopIteration();; return *(int*)coro.promise(hdl, 4, false);; }. Intrinsics; ==========. Coroutine Manipulation Intrinsics; ---------------------------------. Intrinsics described in this section are used to manipulate an existing; coroutine. They can be used in any function which happen to have a pointer; to a `coroutine frame`_ or a pointer to a `coroutine promise`_. .. _coro.destroy:. 'llvm.coro.destroy' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.coro.destroy(ptr <handle>). Overview:; """""""""""""""""". The '``llvm.coro.destroy``' intrinsic destroys a suspended; switched-resume coroutine. Arguments:; """""""""""""""""""". The argument is a coroutine handle to a suspended coroutine. Semantics:; """""""""""""""""""". When possible, the `coro.destroy` intrinsic is replaced with a direct call to; the coroutine destroy function. Otherwise it is replaced with an indirect call; based on the function pointer for the destroy function stored in the coroutine; frame. Destroying a coroutine that is not suspended leads to undefined behavior. .. _coro.resume:. 'llvm.coro.resume' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ::. declare void @llvm.coro.resume(ptr <handle>). Overview:; """""""""""""""""". The '``llvm.coro.resume``' intrinsic resumes a suspended switched-resume coroutine. Arguments:; """""""""""""""""""". The argument is a handle to a suspended coroutine. Semantics:; """""""""""""""""""". When possible, the `coro.resume` intrinsic is replaced with a direct call to the; coroutine resume function. Otherwise it is replaced with an indirect call based; on the function pointer for",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:27259,resume,resume,27259,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"be running as server application, providing different RWebWindow instances for connection. ## Montecarlo Libraries. ## PROOF Libraries. ## Language Bindings. ## JavaScript ROOT. ## Jupyter lab. - Let use created notebooks with viewers like https://nbviewer.jupyter.org/; - Fix problem with using of local JSROOT version. ## Tutorials. - The tutorial games.C was not working properly. - Improve tutorial ErrorIntegral.C. - Schrödinger's Hydrogen Atom example. - Tutorial demonstrating how the changing of the range can zoom into the histogram. - Tutorial demonstrating how a Histogram can be read from a ROOT File. - histMax.C: a tutorial demoing how the hist->GetMaximumBin() can be used. ## Class Reference Guide. - Images for ROOT7 tutorials can be generated, in json format, using the directive using; `\macro_image (json)` in the macro header. - Clarify THStack drawing options. - Add missing documentation to TH1 functions. - Restructure the math reference guide. - Make the web gui documentation visible in the reference guide. - Make clear THtml is legacy code. Add deprecated flag on PROOF and TGeoTrack. - Improve many classes documentation: TContext, TTreePlayer, THistPainter, TGraph, TSelector,; integrator, GUI, TH1, TH2, TH3, TColor classes ... - Make the TFile layout doc visible in Reference Guide. - Update the external links of the reference guide main page. - Reformat TMVA mathcore Unuran Roostats documentation . ## Build, Configuration and Testing Infrastructure. - For users building from source the `latest-stable` branch and passing `-Droottest=ON` to the CMake command line, the corresponding revision of roottest pointed to by `latest-stable` will be downloaded as required. ## PyROOT. - The `ROOT` Python module is now properly serializable so that it is automatically available in the Python environment if a function or ROOT object needs to be serialized. See issue [#6764](https://github.com/root-project/root/issues/6764) for a concrete usecase.; - Improve overload res",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md:38978,guid,guide,38978,README/ReleaseNotes/v626/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md,1,['guid'],['guide']
Usability,"bed below:. :Methods:. Identified by 'Selector' and 'MethodKind'; the MethodKind is either; ""Instance"" or ""Class"". ::. Classes:; - Name: UIViewController; Methods:; - Selector: ""presentViewController:animated:""; MethodKind: Instance; …. :Properties:. Identified by 'Name' and 'PropertyKind'; the PropertyKind is also either; ""Instance"" or ""Class"". ::. Classes:; - Name: UIView; Properties:; - Name: subviews; PropertyKind: Instance; …. Each declaration supports the following annotations (if relevant to that; declaration kind), all of which are optional:. :SwiftName:. Equivalent to ``NS_SWIFT_NAME``. For a method, must include the full Swift name; with all arguments. Use ""_"" to omit an argument label. ::. - Selector: ""presentViewController:animated:""; MethodKind: Instance; SwiftName: ""present(_:animated:)"". - Class: NSBundle; SwiftName: Bundle. :Availability, AvailabilityMsg:. A value of ""nonswift"" is equivalent to ``NS_SWIFT_UNAVAILABLE``. A value of; ""available"" can be used in the ""SwiftVersions"" section to undo the effect of; ""nonswift"". ::. - Selector: ""dealloc""; MethodKind: Instance; Availability: nonswift; AvailabilityMsg: ""prefer 'deinit'"". :SwiftPrivate:. Equivalent to NS_REFINED_FOR_SWIFT. ::. - Name: CGColorEqualToColor; SwiftPrivate: true. :Nullability:. Used for properties and globals. There are four options, identified by their; initials:. - ``Nonnull`` or ``N`` (corresponding to ``_Nonnull``); - ``Optional`` or ``O`` (corresponding to ``_Nullable``); - ``Unspecified`` or ``U`` (corresponding to ``_Null_unspecified``); - ``Scalar`` or ``S`` (deprecated). Note that 'Nullability' is overridden by 'Type', even in a ""SwiftVersions""; section. .. note::. 'Nullability' can also be used to describe the argument types of methods; and functions, but this usage is deprecated in favor of 'Parameters' (see; below). ::. - Name: dataSource; Nullability: O. :NullabilityOfRet:. Used for methods and functions. Describes the nullability of the return type. Note that 'Nullabili",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/APINotes.rst:4991,undo,undo,4991,interpreter/llvm-project/clang/docs/APINotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/APINotes.rst,1,['undo'],['undo']
Usability,"bel %if.end; dyn.free:; call void @CustomFree(ptr %mem); br label %if.end; if.end:; ... With allocations and deallocations represented as described as above, after; coroutine heap allocation elision optimization, the resulting main will be:. .. code-block:: llvm. define i32 @main() {; entry:; call void @print(i32 4); call void @print(i32 5); call void @print(i32 6); ret i32 0; }. Multiple Suspend Points; -----------------------. Let's consider the coroutine that has more than one suspend point:. .. code-block:: c++. void *f(int n) {; for(;;) {; print(n++);; <suspend>; print(-n);; <suspend>; }; }. Matching LLVM code would look like (with the rest of the code remaining the same; as the code in the previous section):. .. code-block:: llvm. loop:; %n.addr = phi i32 [ %n, %entry ], [ %inc, %loop.resume ]; call void @print(i32 %n.addr) #4; %2 = call i8 @llvm.coro.suspend(token none, i1 false); switch i8 %2, label %suspend [i8 0, label %loop.resume; i8 1, label %cleanup]; loop.resume:; %inc = add nsw i32 %n.addr, 1; %sub = xor i32 %n.addr, -1; call void @print(i32 %sub); %3 = call i8 @llvm.coro.suspend(token none, i1 false); switch i8 %3, label %suspend [i8 0, label %loop; i8 1, label %cleanup]. In this case, the coroutine frame would include a suspend index that will; indicate at which suspend point the coroutine needs to resume. .. code-block:: llvm. %f.frame = type { ptr, ptr, i32, i32 }. The resume function will use an index to jump to an appropriate basic block and will look; as follows:. .. code-block:: llvm. define internal fastcc void @f.Resume(ptr %FramePtr) {; entry.Resume:; %index.addr = getelementptr inbounds %f.Frame, ptr %FramePtr, i64 0, i32 2; %index = load i8, ptr %index.addr, align 1; %switch = icmp eq i8 %index, 0; %n.addr = getelementptr inbounds %f.Frame, ptr %FramePtr, i64 0, i32 3; %n = load i32, ptr %n.addr, align 4. br i1 %switch, label %loop.resume, label %loop. loop.resume:; %sub = sub nsw i32 0, %n; call void @print(i32 %sub); br label %suspend; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:18569,resume,resume,18569,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"ber of iterations in the review process. For example, when; suggesting a change, if you want the author to make a similar set of changes at; other places in the code, please explain the requested set of changes so that; the author can make all of the changes at once. If a patch will require; multiple steps prior to approval (e.g., splitting, refactoring, posting data; from specific performance tests), please explain as many of these up front as; possible. This allows the patch author and reviewers to make the most efficient; use of their time. LGTM - How a Patch Is Accepted; ------------------------------. A patch is approved to be committed when a reviewer accepts it, and this is; almost always associated with a message containing the text ""LGTM"" (which; stands for Looks Good To Me). Only approval from a single reviewer is required. When providing an unqualified LGTM (approval to commit), it is the; responsibility of the reviewer to have reviewed all of the discussion and; feedback from all reviewers ensuring that all feedback has been addressed and; that all other reviewers will almost surely be satisfied with the patch being; approved. If unsure, the reviewer should provide a qualified approval, (e.g.,; ""LGTM, but please wait for @someone, @someone_else""). You may also do this if; you are fairly certain that a particular community member will wish to review,; even if that person hasn't done so yet. Note that, if a reviewer has requested a particular community member to review,; and after a week that community member has yet to respond, feel free to ping; the patch (which literally means submitting a comment on the patch with the; word, ""Ping.""), or alternatively, ask the original reviewer for further; suggestions. If it is likely that others will want to review a recently-posted patch,; especially if there might be objections, but no one else has done so yet, it is; also polite to provide a qualified approval (e.g., ""LGTM, but please wait for a; couple of days in ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeReview.rst:6841,feedback,feedback,6841,interpreter/llvm-project/llvm/docs/CodeReview.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeReview.rst,2,['feedback'],['feedback']
Usability,"ber. Given; struct B {};; struct D : B {; int I;; D(int i) : I(i) {}; };; struct E : B {; E() : B() {}; };; cxxConstructorDecl(hasAnyConstructorInitializer(isBaseInitializer())); will match E(), but not match D(int). Matcher<CXXCtorInitializer>isMemberInitializer; Matches a constructor initializer if it is initializing a member, as; opposed to a base. Given; struct B {};; struct D : B {; int I;; D(int i) : I(i) {}; };; struct E : B {; E() : B() {}; };; cxxConstructorDecl(hasAnyConstructorInitializer(isMemberInitializer())); will match D(int), but not match E(). Matcher<CXXCtorInitializer>isWritten; Matches a constructor initializer if it is explicitly written in; code (as opposed to implicitly added by the compiler). Given; struct Foo {; Foo() { }; Foo(int) : foo_(""A"") { }; string foo_;; };; cxxConstructorDecl(hasAnyConstructorInitializer(isWritten())); will match Foo(int), but not Foo(). Matcher<CXXDeductionGuideDecl>isExplicit; Matches constructor, conversion function, and deduction guide declarations; that have an explicit specifier if this explicit specifier is resolved to; true. Given; template<bool b>; struct S {; S(int); // #1; explicit S(double); // #2; operator int(); // #3; explicit operator bool(); // #4; explicit(false) S(bool) // # 7; explicit(true) S(char) // # 8; explicit(b) S(S) // # 9; };; S(int) -> S<true> // #5; explicit S(double) -> S<false> // #6; cxxConstructorDecl(isExplicit()) will match #2 and #8, but not #1, #7 or #9.; cxxConversionDecl(isExplicit()) will match #4, but not #3.; cxxDeductionGuideDecl(isExplicit()) will match #6, but not #5. Matcher<CXXDependentScopeMemberExpr>hasMemberNamestd::string N; Matches template-dependent, but known, member names. In template declarations, dependent members are not resolved and so can; not be matched to particular named declarations. This matcher allows to match on the known name of members. Given; template <typename T>; struct S {; void mem();; };; template <typename T>; void x() {; S<T> s;; s.mem();",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:63950,guid,guide,63950,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['guid'],['guide']
Usability,"bers, which are identified with a '``0``' prefix digit, and hexadecimal; numbers with a prefix of '``0x``' or '``0X``'. .. _doubles:; .. _float:; .. _double:. * The **parser<double>** and **parser<float> specializations** use the standard; C ``strtod`` function to convert floating point strings into floating point; values. As such, a broad range of string formats is supported, including; exponential notation (ex: ``1.7e15``) and properly supports locales. .. _Extension Guide:; .. _extending the library:. Extension Guide; ===============. Although the CommandLine library has a lot of functionality built into it; already (as discussed previously), one of its true strengths lie in its; extensibility. This section discusses how the CommandLine library works under; the covers and illustrates how to do some simple, common, extensions. .. _Custom parsers:; .. _custom parser:; .. _Writing a Custom Parser:. Writing a custom parser; -----------------------. One of the simplest and most common extensions is the use of a custom parser.; As `discussed previously`_, parsers are the portion of the CommandLine library; that turns string input from the user into a particular parsed data type,; validating the input in the process. There are two ways to use a new parser:. #. Specialize the `cl::parser`_ template for your custom data type. This approach has the advantage that users of your custom data type will; automatically use your custom parser whenever they define an option with a; value type of your data type. The disadvantage of this approach is that it; doesn't work if your fundamental data type is something that is already; supported. #. Write an independent class, using it explicitly from options that need it. This approach works well in situations where you would line to parse an; option using special syntax for a not-very-special data-type. The drawback; of this approach is that users of your parser have to be aware that they are; using your parser instead of the builtin on",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst:61858,simpl,simplest,61858,interpreter/llvm-project/llvm/docs/CommandLine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst,1,['simpl'],['simplest']
Usability,"bers. * Move from MathMore to MathCore the class `ROOT::Math::Random`. Make it a new interface class for random number generation. Add interfaces for standard; ROOT random engines, GSL random engines and random engines provided by the C++ standard library (`std::random`).; * Add a new randomengine, `MIXMAX` based on matrix-recursive random number generator from Kostas and George Savvidy. See this [paper](http://dx.doi.org/10.1016/j.cpc.2015.06.003). ## R Interface. Apply several improvements in the interface to R, allowing to use R functions within ROOT.; See more at the [ROOT-R User Guide](http://oproject.org/tiki-index.php?page=ROOT%20R%20Users%20Guide). . ## TMVA. Add new TMVA plug-in based on R and Python (using Scikit-Learn) ; * See the [RMVA Web page](http://oproject.org/tiki-index.php?page=RMVA) for a detailed description of the new TMVA method based on R; * See the [PyMVA Web page](http://oproject.org/tiki-index.php?page=PyMVA) for detailed description of the machine learning methods added in TMVA and based on the Python Scikit-Learn package. ## RooFit Libraries; . ## 2D Graphics Libraries. ### THistPainter. Improve the algorithm to compute the lower limit of an axis in log scale when its; real lower limit is 0. The problem was reported in ROOT-7414. Using the `COL` option with histograms having some negative bins; the empty bins; (containing 0) are drawn. In some cases one wants to not draw empty bins; (containing 0) of histograms having a negative minimum. The option `1`, used with; the option `COL`, allows to do that. Implement the Log option for `CANDLE` plots as requested; [here](https://root.cern.ch/phpBB3/viewtopic.php?f=3&t=20225&p=87006#p87006). ### TTeXDump. From Dmitry Kalinkin (via github): Fix file corruption in `TTeXDump::DrawPolyMarker`; The current implementation of `TTeXDump` uses `TVirtualPS::PrintFast` based methods; to output TeX markup with automatic line-wraps. Yet these methods are optimized for; PostScript format where there are a lot",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v606/index.md:14383,learn,learning,14383,README/ReleaseNotes/v606/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v606/index.md,2,"['Learn', 'learn']","['Learn', 'learning']"
Usability,"big; chunk of the file. Because of this, we have a simple guideline: make anonymous namespaces as small; as possible, and only use them for class declarations. For example:. .. code-block:: c++. namespace {; class StringSort {; ...; public:; StringSort(...); bool operator<(const char *RHS) const;; };; } // namespace. static void runHelper() {; ...; }. bool StringSort::operator<(const char *RHS) const {; ...; }. Avoid putting declarations other than classes into anonymous namespaces:. .. code-block:: c++. namespace {. // ... many declarations ... void runHelper() {; ...; }. // ... many declarations ... } // namespace. When you are looking at ""``runHelper``"" in the middle of a large C++ file,; you have no immediate way to tell if this function is local to the file. In; contrast, when the function is marked static, you don't need to cross-reference; faraway places in the file to tell that the function is local. Don't Use Braces on Simple Single-Statement Bodies of if/else/loop Statements; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. When writing the body of an ``if``, ``else``, or for/while loop statement, we; prefer to omit the braces to avoid unnecessary line noise. However, braces; should be used in cases where the omission of braces harm the readability and; maintainability of the code. We consider that readability is harmed when omitting the brace in the presence; of a single statement that is accompanied by a comment (assuming the comment; can't be hoisted above the ``if`` or loop statement, see below). Similarly, braces should be used when a single-statement body is complex enough; that it becomes difficult to see where the block containing the following; statement began. An ``if``/``else`` chain or a loop is considered a single; statement for this rule, and this rule applies recursively. This list is not exhaustive. For example, readability is also harmed if an; ``if``/``else`` chain does not use braced bodies for either all or",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst:61473,Simpl,Simple,61473,interpreter/llvm-project/llvm/docs/CodingStandards.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst,1,['Simpl'],['Simple']
Usability,"bility R, ThreadSafeModule TSM) override;. private:; IRLayer &BaseLayer;; TransformFunction Transform;; };. // From IRTransformLayer.cpp:. IRTransformLayer::IRTransformLayer(ExecutionSession &ES,; IRLayer &BaseLayer,; TransformFunction Transform); : IRLayer(ES), BaseLayer(BaseLayer), Transform(std::move(Transform)) {}. void IRTransformLayer::emit(MaterializationResponsibility R,; ThreadSafeModule TSM) {; assert(TSM.getModule() && ""Module must not be null"");. if (auto TransformedTSM = Transform(std::move(TSM), R)); BaseLayer.emit(std::move(R), std::move(*TransformedTSM));; else {; R.failMaterialization();; getExecutionSession().reportError(TransformedTSM.takeError());; }; }. This is the whole definition of IRTransformLayer, from; ``llvm/include/llvm/ExecutionEngine/Orc/IRTransformLayer.h`` and; ``llvm/lib/ExecutionEngine/Orc/IRTransformLayer.cpp``. This class is concerned; with two very simple jobs: (1) Running every IR Module that is emitted via this; layer through the transform function object, and (2) implementing the ORC; ``IRLayer`` interface (which itself conforms to the general ORC Layer concept,; more on that below). Most of the class is straightforward: a typedef for the; transform function, a constructor to initialize the members, a setter for the; transform function value, and a default no-op transform. The most important; method is ``emit`` as this is half of our IRLayer interface. The emit method; applies our transform to each module that it is called on and, if the transform; succeeds, passes the transformed module to the base layer. If the transform; fails, our emit function calls; ``MaterializationResponsibility::failMaterialization`` (this JIT clients who; may be waiting on other threads know that the code they were waiting for has; failed to compile) and logs the error with the execution session before bailing; out. The other half of the IRLayer interface we inherit unmodified from the IRLayer; class:. .. code-block:: c++. Error IRLayer::add(JITDyli",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT2.rst:7948,simpl,simple,7948,interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT2.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT2.rst,1,['simpl'],['simple']
Usability,"bindings are generated/built/packaged using 3 environments:. - One compatible with the header files being bound. This is used to; generate the generic C++ binding code (and some ancillary files) using; a modified C++ compiler. The needed options must be compatible with the; normal build environment of the header files.; - One to compile the generated, generic C++ binding code using a standard; C++ compiler. The resulting library code is ""universal"" in that it is; compatible with both Python2 and Python3.; - One to package the library and ancillary files into standard Python2/3; wheel format. The packaging is done using native Python tooling. +----------------------+---------------------------------------------------------------------------------------------+; |Arguments and options | Description |; +======================+=============================================================================================+; |pkg | The name of the package to generate. This can be either |; | | of the form ""simplename"" (e.g. ""Akonadi""), or of the |; | | form ""namespace.simplename"" (e.g. ""KF5.Akonadi""). |; +----------------------+---------------------------------------------------------------------------------------------+; |pkg_version | The version of the package. |; +----------------------+---------------------------------------------------------------------------------------------+; |author | The name of the library author. |; +----------------------+---------------------------------------------------------------------------------------------+; |author_email | The email address of the library author. |; +----------------------+---------------------------------------------------------------------------------------------+; |URL url | The home page for the library. Default is |; | | ""https://pypi.python.org/pypi/<pkg>"". |; +----------------------+---------------------------------------------------------------------------------------------+; |LICENSE license | The license, defa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/cmake_interface.rst:5806,simpl,simplename,5806,bindings/pyroot/cppyy/cppyy/doc/source/cmake_interface.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/cmake_interface.rst,1,['simpl'],['simplename']
Usability,"bing how to move from debug info using; intrinsics such as dbg.value to using the non-instruction DPValue object. :doc:`InstrProfileFormat`; This document explains two binary formats of instrumentation-based profiles. Code Generation; ---------------. :doc:`WritingAnLLVMBackend`; Information on how to write LLVM backends for machine targets. :doc:`CodeGenerator`; The design and implementation of the LLVM code generator. Useful if you are; working on retargetting LLVM to a new architecture, designing a new codegen; pass, or enhancing existing components. :doc:`TableGen <TableGen/index>`; Describes the TableGen tool, which is used heavily by the LLVM code; generator. ==========; GlobalISel; ==========. :doc:`MIRPatterns <GlobalISel/MIRPatterns>`; Describes the design of MIR Patterns and how to use them. ===; JIT; ===. :doc:`MCJITDesignAndImplementation`; Describes the inner workings of MCJIT execution engine. :doc:`ORCv2`; Describes the design and implementation of the ORC APIs, including some; usage examples, and a guide for users transitioning from ORCv1 to ORCv2. :doc:`JITLink`; Describes the design and APIs for the JITLink library, ORC's new JIT; linker. :doc:`DebuggingJITedCode`; How to debug JITed code with GDB. Additional Topics; -----------------. :doc:`CommandLine`; Provides information on using the command line parsing library. :doc:`ExtendingLLVM`; Look here to see how to add instructions and intrinsics to LLVM. :doc:`AddingConstrainedIntrinsics`; Gives the steps necessary when adding a new constrained math intrinsic; to LLVM. :doc:`HowToBuildWindowsItaniumPrograms`; Notes on assembling a Windows Itanium environment. :doc:`HowToCrossCompileBuiltinsOnArm`; Notes on cross-building and testing the compiler-rt builtins for Arm. :doc:`BigEndianNEON`; LLVM's support for generating NEON instructions on big endian ARM targets is; somewhat nonintuitive. This document explains the implementation and rationale. :doc:`AArch64SME`; LLVM's support for AArch64 SME ACLE an",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/UserGuides.rst:5437,guid,guide,5437,interpreter/llvm-project/llvm/docs/UserGuides.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/UserGuides.rst,1,['guid'],['guide']
Usability,"bject {; private:; Float_t fPx; //X component of the momentum; Float_t fPy; //Y component of the momentum; Float_t fPz; //Z component of the momentum; Float_t fRandom; //A random track quantity; Float_t fMass2; //The mass square of this particle; Float_t fBx; //X intercept at the vertex; Float_t fBy; //Y intercept at the vertex; Float_t fMeanCharge; //Mean charge deposition of all hits; Float_t fXfirst; //X coordinate of the first point; Float_t fXlast; //X coordinate of the last point; Float_t fYfirst; //Y coordinate of the first point; Float_t fYlast; //Y coordinate of the last point; Float_t fZfirst; //Z coordinate of the first point; Float_t fZlast; //Z coordinate of the last point; Float_t fCharge; //Charge of this track; Float_t fVertex[3]; //Track vertex position; Int_t fNpoint; //Number of points for this track; Short_t fValid; //Validity criterion. // method definitions ...; ClassDef(Track,1) //A track segment; };; ```. ### Writing the Tree. We create a simple tree with two branches both holding `Event` objects.; One is split and the other is not. We also create a pointer to an; `Event` object (`event`). ``` {.cpp}; void tree4w() {; // check to see if the event class is in the dictionary; // if it is not load the definition in libEvent.so; if (!TClassTable::GetDict(""Event"")) {; gSystem->Load(""$ROOTSYS/test/libEvent.so"");; }; // create a Tree file tree4.root; TFile f(""tree4.root"",""RECREATE"");; // create a ROOT Tree; TTree t4(""t4"",""A Tree with Events"");; // create a pointer to an Event object; Event *event = new Event();; // create two branches, split one; t4.Branch(""event_branch"", ""Event"", &event,16000,2);; t4.Branch(""event_not_split"", ""Event"", &event,16000,0);. // a local variable for the event type; char etype[20];. // fill the tree; for (Int_t ev = 0; ev <100; ev++) {; Float_t sigmat, sigmas;; gRandom->Rannor(sigmat,sigmas);; Int_t ntrack = Int_t(600 + 600 *sigmat/120.);; Float_t random = gRandom->Rndm(1);; sprintf(etype,""type%d"",ev%5);; event->SetType(et",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:62083,simpl,simple,62083,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['simpl'],['simple']
Usability,"bject. To use an attribute group, an; object references the attribute group's ID (e.g. ``#37``). An object may refer; to more than one attribute group. In that situation, the attributes from the; different groups are merged. Here is an example of attribute groups for a function that should always be; inlined, has a stack alignment of 4, and which shouldn't use SSE instructions:. .. code-block:: llvm. ; Target-independent attributes:; attributes #0 = { alwaysinline alignstack=4 }. ; Target-dependent attributes:; attributes #1 = { ""no-sse"" }. ; Function @f has attributes: alwaysinline, alignstack=4, and ""no-sse"".; define void @f() #0 #1 { ... }. .. _fnattrs:. Function Attributes; -------------------. Function attributes are set to communicate additional information about; a function. Function attributes are considered to be part of the; function, not of the function type, so functions with different function; attributes can have the same function type. Function attributes are simple keywords that follow the type specified.; If multiple attributes are needed, they are space separated. For; example:. .. code-block:: llvm. define void @f() noinline { ... }; define void @f() alwaysinline { ... }; define void @f() alwaysinline optsize { ... }; define void @f() optsize { ... }. ``alignstack(<n>)``; This attribute indicates that, when emitting the prologue and; epilogue, the backend should forcibly align the stack pointer.; Specify the desired alignment, which must be a power of two, in; parentheses.; ``""alloc-family""=""FAMILY""``; This indicates which ""family"" an allocator function is part of. To avoid; collisions, the family name should match the mangled name of the primary; allocator function, that is ""malloc"" for malloc/calloc/realloc/free,; ""_Znwm"" for ``::operator::new`` and ``::operator::delete``, and; ""_ZnwmSt11align_val_t"" for aligned ``::operator::new`` and; ``::operator::delete``. Matching malloc/realloc/free calls within a family; can be optimized, but mismatched o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:77142,simpl,simple,77142,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['simpl'],['simple']
Usability,"ble and easily accommodate new uses; as we grow the clang and LLVM infrastructure. As one example, the driver; can easily support the introduction of tools which have an integrated; assembler; something we hope to add to LLVM in the future. Similarly, most of the driver functionality is kept in a library which; can be used to build other tools which want to implement or accept a gcc; like interface. Low Overhead; ------------. The driver should have as little overhead as possible. In practice, we; found that the gcc driver by itself incurred a small but meaningful; overhead when compiling many small files. The driver doesn't do much; work compared to a compilation, but we have tried to keep it as; efficient as possible by following a few simple principles:. - Avoid memory allocation and string copying when possible.; - Don't parse arguments more than once.; - Provide a few simple interfaces for efficiently searching arguments. Simple; ------. Finally, the driver was designed to be ""as simple as possible"", given; the other goals. Notably, trying to be completely compatible with the; gcc driver adds a significant amount of complexity. However, the design; of the driver attempts to mitigate this complexity by dividing the; process into a number of independent stages instead of a single; monolithic task. Internal Design and Implementation; ==================================. .. contents::; :local:; :depth: 1. Internals Introduction; ----------------------. In order to satisfy the stated goals, the driver was designed to; completely subsume the functionality of the gcc executable; that is, the; driver should not need to delegate to gcc to perform subtasks. On; Darwin, this implies that the Clang driver also subsumes the gcc; driver-driver, which is used to implement support for building universal; images (binaries and object files). This also implies that the driver; should be able to call the language specific compilers (e.g. cc1); directly, which means that it must hav",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst:2226,simpl,simple,2226,interpreter/llvm-project/clang/docs/DriverInternals.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst,1,['simpl'],['simple']
Usability,"ble()`` - Removes a global variable from the list and deletes it.; | ``global_begin()``, ``global_end()``, ``global_size()``, ``global_empty()``. These are forwarding methods that make it easy to access the contents of a; ``Module`` object's GlobalVariable_ list. ----------------. * ``SymbolTable *getSymbolTable()``. Return a reference to the SymbolTable_ for this ``Module``. ----------------. * ``Function *getFunction(StringRef Name) const``. Look up the specified function in the ``Module`` SymbolTable_. If it does not; exist, return ``null``. * ``FunctionCallee getOrInsertFunction(const std::string &Name,; const FunctionType *T)``. Look up the specified function in the ``Module`` SymbolTable_. If; it does not exist, add an external declaration for the function and; return it. Note that the function signature already present may not; match the requested signature. Thus, in order to enable the common; usage of passing the result directly to EmitCall, the return type is; a struct of ``{FunctionType *T, Constant *FunctionPtr}``, rather; than simply the ``Function*`` with potentially an unexpected; signature. * ``std::string getTypeName(const Type *Ty)``. If there is at least one entry in the SymbolTable_ for the specified Type_,; return it. Otherwise return the empty string. * ``bool addTypeName(const std::string &Name, const Type *Ty)``. Insert an entry in the SymbolTable_ mapping ``Name`` to ``Ty``. If there is; already an entry for this name, true is returned and the SymbolTable_ is not; modified. .. _Value:. The ``Value`` class; -------------------. ``#include ""llvm/IR/Value.h""``. header source: `Value.h <https://llvm.org/doxygen/Value_8h_source.html>`_. doxygen info: `Value Class <https://llvm.org/doxygen/classllvm_1_1Value.html>`_. The ``Value`` class is the most important class in the LLVM Source base. It; represents a typed value that may be used (among other things) as an operand to; an instruction. There are many different types of ``Value``\ s, such as; Con",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:140312,simpl,simply,140312,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['simpl'],['simply']
Usability,"blic statements about a resolution and will; only publish :ref:`transparency reports<Transparency Reports>`. If a public; statement is necessary and requested by the committee, it will be given by the; LLVM Foundation Board of Directors. Report Acknowledgement; ======================. When a report is received, the committee will reply to the reporter to confirm; receipt within 24 hours of the incident being reported. . This acknowledgement will contain:. * Acknowledgement of the incident report; * Next steps of the committee for responding to the incident; * Reminder of confidentiality policy regarding the report and parties involved. All incident reports should be assessed if they require immediate response and; acted on accordingly. .. _Incident Response Assessment:. Incident Response Assessment; ============================. The committee will assess the incident and determine an appropriate response.; The assessment will be documented and retained in records. Here are some; guidelines for the process:. * Review report documentation to determine the content and context of the; incident. * Request additional information if needed from the reporter. * Determine if it occurred within the scope of the CoC.; * Determine if it violated the CoC and specifically which part.; * Consult documentation of past incidents for patterns of behavior (if; available and applicable).; * Follow up with the reportee to get their view or any other additional; information.; * Determine appropriate resolutions to the incident when all information has; been gathered.; * Notify the reporter of the resolution and request feedback. This may or may; not be used to reevaluate the resolution. The committee will aim to have a resolution agreed upon within two weeks of; receipt of the incident report. In the event that a resolution cannot be; determined within that time, the CoC committee will respond to the reporter(s); with an updated and projected timeline for resolution. . .. _Following Up W",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ResponseGuide.rst:5040,guid,guidelines,5040,interpreter/llvm-project/llvm/docs/ResponseGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ResponseGuide.rst,1,['guid'],['guidelines']
Usability,"block:: console. $ make check-all. Setup Clang Tooling Using CMake on Windows; ==========================================. For Windows developers, the Visual Studio project generators in CMake do; not support `CMAKE_EXPORT_COMPILE_COMMANDS; <https://cmake.org/cmake/help/latest/variable/CMAKE_EXPORT_COMPILE_COMMANDS.html>`_.; However, the Ninja generator does support this variable and can be used; on Windows to generate a suitable ``compile_commands.json`` that invokes; the MSVC compiler. First, you will need to install `Ninja`_. Once installed, the Ninja; executable will need to be in your search path for CMake to locate it. Next, assuming you already have Visual Studio installed on your machine, you; need to have the appropriate environment variables configured so that CMake; will locate the MSVC compiler for the Ninja generator. The `documentation; <https://docs.microsoft.com/en-us/cpp/build/building-on-the-command-line?view=msvc-170#path_and_environment>`_; describes the necessary environment variable settings, but the simplest thing; is to use a `developer command-prompt window; <https://docs.microsoft.com/en-us/cpp/build/building-on-the-command-line?view=msvc-170#developer_command_prompt_shortcuts>`_; or call a `developer command file; <https://docs.microsoft.com/en-us/cpp/build/building-on-the-command-line?view=msvc-170#developer_command_file_locations>`_; to set the environment variables appropriately. Now you can run CMake with the Ninja generator to export a compilation; database:. .. code-block:: console. C:\> mkdir build-ninja; C:\> cd build-ninja; C:\build-ninja> cmake -G Ninja -DCMAKE_EXPORT_COMPILE_COMMANDS=ON path/to/llvm/sources. It is best to keep your Visual Studio IDE build folder separate from the; Ninja build folder. This prevents the two build systems from negatively; interacting with each other. Once the ``compile_commands.json`` file has been created by Ninja, you can; use that compilation database with Clang Tooling. One caveat is that becaus",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst:2990,simpl,simplest,2990,interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst,1,['simpl'],['simplest']
Usability,"body of an ``if``, ``else``, or for/while loop statement, we; prefer to omit the braces to avoid unnecessary line noise. However, braces; should be used in cases where the omission of braces harm the readability and; maintainability of the code. We consider that readability is harmed when omitting the brace in the presence; of a single statement that is accompanied by a comment (assuming the comment; can't be hoisted above the ``if`` or loop statement, see below). Similarly, braces should be used when a single-statement body is complex enough; that it becomes difficult to see where the block containing the following; statement began. An ``if``/``else`` chain or a loop is considered a single; statement for this rule, and this rule applies recursively. This list is not exhaustive. For example, readability is also harmed if an; ``if``/``else`` chain does not use braced bodies for either all or none of its; members, or has complex conditionals, deep nesting, etc. The examples below; intend to provide some guidelines. Maintainability is harmed if the body of an ``if`` ends with a (directly or; indirectly) nested ``if`` statement with no ``else``. Braces on the outer ``if``; would help to avoid running into a ""dangling else"" situation. .. code-block:: c++. // Omit the braces since the body is simple and clearly associated with the; // `if`.; if (isa<FunctionDecl>(D)); handleFunctionDecl(D);; else if (isa<VarDecl>(D)); handleVarDecl(D);. // Here we document the condition itself and not the body.; if (isa<VarDecl>(D)) {; // It is necessary that we explain the situation with this surprisingly long; // comment, so it would be unclear without the braces whether the following; // statement is in the scope of the `if`.; // Because the condition is documented, we can't really hoist this; // comment that applies to the body above the `if`.; handleOtherDecl(D);; }. // Use braces on the outer `if` to avoid a potential dangling `else`; // situation.; if (isa<VarDecl>(D)) {; if (should",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst:62645,guid,guidelines,62645,interpreter/llvm-project/llvm/docs/CodingStandards.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst,1,['guid'],['guidelines']
Usability,"body of code that uses acronyms; extensively to the detriment of its readability. Further, it is natural and; generally encouraged that new code be written in the style of the surrounding; code. Therefore it is likely that much newly written code will also use; acronyms despite what the coding standard says, much as it is today. As well as changing the case of variable names, they could also be expanded to; their non-acronym form e.g. ``Triple T`` → ``Triple triple``. There is support for expanding many acronyms [CarruthAcronym]_ [PicusAcronym]_; but there is a preference that expanding acronyms be deferred; [ParzyszekAcronym]_ [CarruthAcronym]_. The consensus within the community seems to be that at least some acronyms are; valuable [ParzyszekAcronym]_ [LattnerAcronym]_. The most commonly cited acronym; is ``TLI`` however that is used to refer to both ``TargetLowering`` and; ``TargetLibraryInfo`` [GreeneDistinguish]_. The following is a list of acronyms considered sufficiently useful that the; benefit of using them outweighs the cost of learning them. Acronyms that are; either not on the list or are used to refer to a different type should be; expanded. ============================ =============; Class name Variable name; ============================ =============; DeterministicFiniteAutomaton dfa; DominatorTree dt; LoopInfo li; MachineFunction mf; MachineInstr mi; MachineRegisterInfo mri; ScalarEvolution se; TargetInstrInfo tii; TargetLibraryInfo tli; TargetRegisterInfo tri; ============================ =============. In some cases renaming acronyms to the full type name will result in overly; verbose code. Unlike most classes, a variable's scope is limited and therefore; some of its purpose can implied from that scope, meaning that fewer words are; necessary to give it a clear name. For example, in an optimization pass the reader; can assume that a variable's purpose relates to optimization and therefore an; ``OptimizationRemarkEmitter`` variable could be given t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst:5844,learn,learning,5844,interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst,1,['learn'],['learning']
Usability,"bot-worker description::. Windows 7 x64; Core i7 (2.66GHz), 16GB of RAM. g++.exe (TDM-1 mingw32) 4.4.0; GNU Binutils 2.19.1; cmake version 2.8.4; Microsoft(R) 32-bit C/C++ Optimizing Compiler Version 16.00.40219.01 for 80x86. See `here <http://docs.buildbot.net/current/manual/installation/worker.html>`_; for which files to edit. #. Send a patch which adds your build worker and your builder to; `zorg <https://github.com/llvm/llvm-zorg>`_. Use the typical LLVM; `workflow <https://llvm.org/docs/Contributing.html#how-to-submit-a-patch>`_. * workers are added to ``buildbot/osuosl/master/config/workers.py``; * builders are added to ``buildbot/osuosl/master/config/builders.py``. Please make sure your builder name and its builddir are unique through the; file. All new builders should default to using the ""'collapseRequests': False""; configuration. This causes the builder to build each commit individually; and not merge build requests. To maximize quality of feedback to developers,; we *strongly prefer* builders to be configured not to collapse requests.; This flag should be removed only after all reasonable efforts have been; exhausted to improve build times such that the builder can keep up with; commit flow. It is possible to allow email addresses to unconditionally receive; notifications on build failure; for this you'll need to add an; ``InformativeMailNotifier`` to ``buildbot/osuosl/master/config/status.py``.; This is particularly useful for the staging buildmaster which is silent; otherwise. #. Send the buildbot-worker access name and the access password directly to; `Galina Kistanova <mailto:gkistanova@gmail.com>`_, and wait until she; lets you know that your changes are applied and buildmaster is; reconfigured. #. Make sure you can start the buildbot-worker and successfully connect; to the silent buildmaster. Then set up your buildbot-worker to start; automatically at the start up time. See the buildbot documentation; for help. You may want to restart your computer t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToAddABuilder.rst:5709,feedback,feedback,5709,interpreter/llvm-project/llvm/docs/HowToAddABuilder.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToAddABuilder.rst,1,['feedback'],['feedback']
Usability,"bstituted into; Not resolved. 2771; open; Transformation for unqualified-ids in address operator; Not resolved. 2772; DR; Missing Annex C entry for linkage effects of linkage-specification; Unknown. 2773; open; Naming anonymous union members as class members; Not resolved. 2774; open; Value-dependence of requires-expressions; Not resolved. 2775; tentatively ready; Unclear argument type for copy of exception object; Unknown. 2776; open; Substitution failure and implementation limits; Not resolved. 2777; open; Type of id-expression denoting a template parameter object; Not resolved. 2778; open; Trivial destructor does not imply constant destruction; Not resolved. 2779; open; Restrictions on the ordinary literal encoding; Not resolved. 2780; DR; reinterpret_cast to reference to function types; Unknown. 2781; open; Unclear recursion in the one-definition rule; Not resolved. 2782; open; Treatment of closure types in the one-definition rule; Not resolved. 2783; DR; Handling of deduction guides in global-module-fragment; Unknown. 2784; open; Unclear definition of member-designator for offsetof; Not resolved. 2785; DR; Type-dependence of requires-expression; Unknown. 2786; open; Comparing pointers to complete objects; Not resolved. 2787; open; Kind of explicit object copy/move assignment function; Not resolved. 2788; open; Correspondence and redeclarations; Not resolved. 2789; DR; Overload resolution with implicit and explicit object member functions; Clang 18. 2790; open; Aggregate initialization and user-defined conversion sequence; Not resolved. 2791; DR; Unclear phrasing about ""returning to the caller""; Unknown. 2792; DR; Clean up specification of noexcept operator; Unknown. 2793; DR; Block-scope declaration conflicting with parameter name; Unknown. 2794; open; Uniqueness of lambdas in alias templates; Not resolved. 2795; DR; Overlapping empty subobjects with different cv-qualification; Unknown. 2796; DR; Function pointer conversions for relational operators; Unknown. 27",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:192950,guid,guides,192950,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['guid'],['guides']
Usability,"buf_t *sbuf, sized_t nelems) {; // Materialize RHS values:; int *tmp_ptr = (int *)malloc(sizeof(int) * nelems);; int tmp_count = nelems;; // Inserted check:; // - checks to ensure that `lower <= tmp_ptr <= upper`; // - if (upper(tmp_ptr) - tmp_ptr < tmp_count) trap();; sbuf->buf = tmp_ptr;; sbuf->count = tmp_count;; }. Whether the compiler can optimize such run-time checks depends on how the upper; bound of the pointer is derived. If the source pointer has ``__sized_by``,; ``__counted_by``, or a variant of such, the compiler assumes that the upper; bound calculation doesn't overflow, e.g., ``ptr + size`` (where the type of; ``ptr`` is ``void *__sized_by(size)``), because when the ``__sized_by`` pointer; is initialized, ``-fbounds-safety`` inserts run-time checks to ensure that ``ptr; + size`` doesn't overflow and that ``size >= 0``. Assuming the upper bound calculation doesn't overflow, the compiler can simplify; the trap condition ``upper(tmp_ptr) - tmp_ptr < tmp_count`` to ``size <; tmp_count`` so if both ``size`` and ``tmp_count`` values are known at compile; time such that ``0 <= tmp_count <= size``, the optimizer can remove the check. ``ptr + size`` may still overflow if the ``__sized_by`` pointer is created from; code that doesn't enable ``-fbounds-safety``, which is undefined behavior. In the previous code example with the transformed ``alloc_buf()``, the upper; bound of ``tmp_ptr`` is derived from ``void *__sized_by_or_null(size)``, which; is the return type of ``malloc()``. Hence, the pointer arithmetic doesn't; overflow or ``tmp_ptr`` is null. Therefore, if ``nelems`` was given as a; compile-time constant, the compiler could remove the checks. Cast rules; ----------. ``-fbounds-safety`` does not enforce overall type safety and bounds invariants; can still be violated by incorrect casts in some cases. That said,; ``-fbounds-safety`` prevents type conversions that change bounds attributes in a; way to violate the bounds invariant of the destination's pointer ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:38134,simpl,simplify,38134,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['simpl'],['simplify']
Usability,"build and; test LLVM have been ported to a plethora of platforms. What API do I use to store a value to one of the virtual registers in LLVM IR's SSA representation?; ---------------------------------------------------------------------------------------------------. In short: you can't. It's actually kind of a silly question once you grok; what's going on. Basically, in code like:. .. code-block:: llvm. %result = add i32 %foo, %bar. , ``%result`` is just a name given to the ``Value`` of the ``add``; instruction. In other words, ``%result`` *is* the add instruction. The; ""assignment"" doesn't explicitly ""store"" anything to any ""virtual register"";; the ""``=``"" is more like the mathematical sense of equality. Longer explanation: In order to generate a textual representation of the; IR, some kind of name has to be given to each instruction so that other; instructions can textually reference it. However, the isomorphic in-memory; representation that you manipulate from C++ has no such restriction since; instructions can simply keep pointers to any other ``Value``'s that they; reference. In fact, the names of dummy numbered temporaries like ``%1`` are; not explicitly represented in the in-memory representation at all (see; ``Value::getName()``). Source Languages; ================. What source languages are supported?; ------------------------------------. LLVM currently has full support for C and C++ source languages through; `Clang <https://clang.llvm.org/>`_. Many other language frontends have; been written using LLVM, and an incomplete list is available at; `projects with LLVM <https://llvm.org/ProjectsWithLLVM/>`_. I'd like to write a self-hosting LLVM compiler. How should I interface with the LLVM middle-end optimizers and back-end code generators?; ----------------------------------------------------------------------------------------------------------------------------------------; Your compiler front-end will communicate with LLVM by creating a module in the; LLVM",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/FAQ.rst:2437,simpl,simply,2437,interpreter/llvm-project/llvm/docs/FAQ.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/FAQ.rst,1,['simpl'],['simply']
Usability,"bvector``. Prior to the existence of the Legalize passes, we required that every target; `selector`_ supported and handled every operator and type even if they are not; natively supported. The introduction of the Legalize phases allows all of the; canonicalization patterns to be shared across targets, and makes it very easy to; optimize the canonicalized code because it is still in the form of a DAG. .. _optimizations:; .. _Optimize SelectionDAG:; .. _selector:. SelectionDAG Optimization Phase: the DAG Combiner; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The SelectionDAG optimization phase is run multiple times for code generation,; immediately after the DAG is built and once after each legalization. The first; run of the pass allows the initial code to be cleaned up (e.g. performing; optimizations that depend on knowing that the operators have restricted type; inputs). Subsequent runs of the pass clean up the messy code generated by the; Legalize passes, which allows Legalize to be very simple (it can focus on making; code legal instead of focusing on generating *good* and legal code). One important class of optimizations performed is optimizing inserted sign and; zero extension instructions. We currently use ad-hoc techniques, but could move; to more rigorous techniques in the future. Here are some good papers on the; subject:. ""`Widening integer arithmetic <http://www.eecs.harvard.edu/~nr/pubs/widen-abstract.html>`_"" :raw-html:`<br>`; Kevin Redwine and Norman Ramsey :raw-html:`<br>`; International Conference on Compiler Construction (CC) 2004. ""`Effective sign extension elimination <http://portal.acm.org/citation.cfm?doid=512529.512552>`_"" :raw-html:`<br>`; Motohiro Kawahito, Hideaki Komatsu, and Toshio Nakatani :raw-html:`<br>`; Proceedings of the ACM SIGPLAN 2002 Conference on Programming Language Design; and Implementation. .. _Select instructions from DAG:. SelectionDAG Select Phase; ^^^^^^^^^^^^^^^^^^^^^^^^^. The Select phase is the bulk of the target",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:45670,simpl,simple,45670,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,1,['simpl'],['simple']
Usability,"bvious data dependency (e.g., when comparing strings, ignore the fact; that the output of the comparison might be implicit data-dependent on the; content of the strings). This applies only to functions with ``custom`` category; in ABI list. Its default value is true.; * ``origin_history_size`` -- The limit of origin chain length. Non-positive values; mean unlimited. Its default value is 16.; * ``origin_history_per_stack_limit`` -- The limit of origin node's references count.; Non-positive values mean unlimited. Its default value is 20000.; * ``store_context_size`` -- The depth limit of origin tracking stack traces. Its; default value is 20.; * ``zero_in_malloc`` -- Whether to zero shadow space of new allocated memory. Its; default value is true.; * ``zero_in_free`` --- Whether to zero shadow space of deallocated memory. Its; default value is true. Example; =======. DataFlowSanitizer supports up to 8 labels, to achieve low CPU and code; size overhead. Base labels are simply 8-bit unsigned integers that are; powers of 2 (i.e. 1, 2, 4, 8, ..., 128), and union labels are created; by ORing base labels. The following program demonstrates label propagation by checking that; the correct labels are propagated. .. code-block:: c++. #include <sanitizer/dfsan_interface.h>; #include <assert.h>. int main(void) {; int i = 100;; int j = 200;; int k = 300;; dfsan_label i_label = 1;; dfsan_label j_label = 2;; dfsan_label k_label = 4;; dfsan_set_label(i_label, &i, sizeof(i));; dfsan_set_label(j_label, &j, sizeof(j));; dfsan_set_label(k_label, &k, sizeof(k));. dfsan_label ij_label = dfsan_get_label(i + j);. assert(ij_label & i_label); // ij_label has i_label; assert(ij_label & j_label); // ij_label has j_label; assert(!(ij_label & k_label)); // ij_label doesn't have k_label; assert(ij_label == 3); // Verifies all of the above. // Or, equivalently:; assert(dfsan_has_label(ij_label, i_label));; assert(dfsan_has_label(ij_label, j_label));; assert(!dfsan_has_label(ij_label, k_label));. dfsa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst:10767,simpl,simply,10767,interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst,1,['simpl'],['simply']
Usability,"by -loop-reduce and -indvars. //===---------------------------------------------------------------------===//. u32 to float conversion improvement:. float uint32_2_float( unsigned u ) {; float fl = (int) (u & 0xffff);; float fh = (int) (u >> 16);; fh *= 0x1.0p16f;; return fh + fl;; }. 00000000 subl $0x04,%esp; 00000003 movl 0x08(%esp,1),%eax; 00000007 movl %eax,%ecx; 00000009 shrl $0x10,%ecx; 0000000c cvtsi2ss %ecx,%xmm0; 00000010 andl $0x0000ffff,%eax; 00000015 cvtsi2ss %eax,%xmm1; 00000019 mulss 0x00000078,%xmm0; 00000021 addss %xmm1,%xmm0; 00000025 movss %xmm0,(%esp,1); 0000002a flds (%esp,1); 0000002d addl $0x04,%esp; 00000030 ret. //===---------------------------------------------------------------------===//. When using fastcc abi, align stack slot of argument of type double on 8 byte; boundary to improve performance. //===---------------------------------------------------------------------===//. GCC's ix86_expand_int_movcc function (in i386.c) has a ton of interesting; simplifications for integer ""x cmp y ? a : b"". //===---------------------------------------------------------------------===//. Consider the expansion of:. define i32 @test3(i32 %X) {; %tmp1 = urem i32 %X, 255; ret i32 %tmp1; }. Currently it compiles to:. ...; movl $2155905153, %ecx; movl 8(%esp), %esi; movl %esi, %eax; mull %ecx; ... This could be ""reassociated"" into:. movl $2155905153, %eax; movl 8(%esp), %ecx; mull %ecx. to avoid the copy. In fact, the existing two-address stuff would do this; except that mul isn't a commutative 2-addr instruction. I guess this has; to be done at isel time based on the #uses to mul?. //===---------------------------------------------------------------------===//. Make sure the instruction which starts a loop does not cross a cacheline; boundary. This requires knowning the exact length of each machine instruction.; That is somewhat complicated, but doable. Example 256.bzip2:. In the new trace, the hot loop has an instruction which crosses a cacheline; boundar",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/README.txt:9750,simpl,simplifications,9750,interpreter/llvm-project/llvm/lib/Target/X86/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/README.txt,1,['simpl'],['simplifications']
Usability,"by joining; one of the `issue-subscribers-* <https://github.com/orgs/llvm/teams?query=issue-subscribers>`_; teams.; You may also subscribe to the `llvm-bugs; <http://lists.llvm.org/mailman/listinfo/llvm-bugs>`_ email list to keep track; of bugs and enhancements occurring in the entire project. We really appreciate people; who are proactive at catching incoming bugs in their components and dealing with them; promptly. Please be aware that all public LLVM mailing lists and discourse forums are public and archived, and; that notices of confidentiality or non-disclosure cannot be respected. .. _patch:; .. _one-off patches:. Making and Submitting a Patch; -----------------------------. When making a patch for review, the goal is to make it as easy for the reviewer; to read it as possible. As such, we recommend that you:. #. Make your patch against git main, not a branch, and not an old version; of LLVM. This makes it easy to apply the patch. For information on how to; clone from git, please see the :ref:`Getting Started Guide; <checkout>`. #. Similarly, patches should be submitted soon after they are generated. Old; patches may not apply correctly if the underlying code changes between the; time the patch was created and the time it is applied. #. Once you have created your patch, create a; :ref:`GitHub Pull Request <github-reviews>` for; it (or commit it directly if applicable). When submitting patches, please do not add confidentiality or non-disclosure; notices to the patches themselves. These notices conflict with the LLVM; licensing terms and may result in your contribution being excluded. .. _code review:. Code Reviews; ------------. LLVM has a code-review policy. Code review is one way to increase the quality of; software. Please see :doc:`CodeReview` for more information on LLVM's code-review; process. .. _breaking:. Making Potentially Breaking Changes; -----------------------------------. Please help notify users and vendors of potential disruptions when upgradi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst:4131,Guid,Guide,4131,interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,1,['Guid'],['Guide']
Usability,"by passing -configuration; Debug to xcodebuild.; Analyze your project using the Simulator as your base SDK. It is; possible to analyze your code when targeting the device, but this is much; easier to do when using Xcode's Build and Analyze feature.; Check that your code signing SDK is set to the simulator SDK as well, and make sure this option is set to Don't Code Sign. Note that you can most of this without actually modifying your project. For; example, if your application targets iPhoneOS 2.2, you could run; scan-build in the following manner from the command line:. $ scan-build xcodebuild -configuration Debug -sdk iphonesimulator2.2. Alternatively, if your application targets iPhoneOS 3.0:. $ scan-build xcodebuild -configuration Debug -sdk iphonesimulator3.0. Gotcha: using the right compiler; Recall that scan-build analyzes your project by using a compiler to; compile the project and clang to analyze your project. The script uses; simple heuristics to determine which compiler should be used (it defaults to; clang on Darwin and gcc on other platforms). When analyzing; iPhone projects, scan-build may pick the wrong compiler than the one; Xcode would use to build your project. For example, this could be because; multiple versions of a compiler may be installed on your system, especially if; you are developing for the iPhone.; When compiling your application to run on the simulator, it is important that scan-build; finds the correct version of gcc/clang. Otherwise, you may see strange build; errors that only happen when you run scan-build. scan-build provides the --use-cc and --use-c++; options to hardwire which compiler scan-build should use for building your code.; Note that although you are chiefly interested in analyzing your project, keep in; mind that running the analyzer is intimately tied to the build, and not being; able to compile your code means it won't get fully analyzed (if at all).; If you aren't certain which compiler Xcode uses to build your project,",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/scan-build.html:9892,simpl,simple,9892,interpreter/llvm-project/clang/www/analyzer/scan-build.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/scan-build.html,1,['simpl'],['simple']
Usability,"by passing; ``-ftrigraphs``. Non-comprehensive list of changes in this release; -------------------------------------------------. * Clang now has a ``__builtin_vectorelements()`` function that determines the number of elements in a vector.; For fixed-sized vectors, e.g., defined via ``__attribute__((vector_size(N)))`` or ARM NEON's vector types; (e.g., ``uint16x8_t``), this returns the constant number of elements at compile-time.; For scalable vectors, e.g., SVE or RISC-V V, the number of elements is not known at compile-time and is; determined at runtime.; * The ``__datasizeof`` keyword has been added. It is similar to ``sizeof``; except that it returns the size of a type ignoring tail padding.; * ``__builtin_classify_type()`` now classifies ``_BitInt`` values as the return value ``18``; and vector types as return value ``19``, to match GCC 14's behavior.; * The default value of `_MSC_VER` was raised from 1920 to 1933.; * Since MSVC 19.33 added undocumented attribute ``[[msvc::constexpr]]``, this release adds the attribute as well. * Added ``#pragma clang fp reciprocal``. * The version of Unicode used by Clang (primarily to parse identifiers) has been updated to 15.1. * Clang now defines macro ``__LLVM_INSTR_PROFILE_GENERATE`` when compiling with; PGO instrumentation profile generation, and ``__LLVM_INSTR_PROFILE_USE`` when; compiling with PGO profile use. New Compiler Flags; ------------------. * ``-fverify-intermediate-code`` and its complement ``-fno-verify-intermediate-code``.; Enables or disables verification of the generated LLVM IR.; Users can pass this to turn on extra verification to catch certain types of; compiler bugs at the cost of extra compile time.; Since enabling the verifier adds a non-trivial cost of a few percent impact on; build times, it's disabled by default, unless your LLVM distribution itself is; compiled with runtime checks enabled.; * ``-fkeep-system-includes`` modifies the behavior of the ``-E`` option,; preserving ``#include`` directiv",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:14839,undo,undocumented,14839,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst,1,['undo'],['undocumented']
Usability,"by; essentially interposing on a project's build process. This means that to run the; analyzer using scan-build, you will use scan-build to analyze; the source files compiled by gcc/clang during a project build.; This means that any files that are not compiled will also not be analyzed.; Basic Usage; Basic usage of scan-build is designed to be simple: just place the; word ""scan-build"" in front of your build command:. $ scan-build make; $ scan-build xcodebuild. In the first case scan-build analyzes the code of a project built; with make and in the second case scan-build analyzes a project; built using xcodebuild.; Here is the general format for invoking scan-build:. $ scan-build [scan-build options] <command> [command options]. Operationally, scan-build literally runs <command> with all of the; subsequent options passed to it. For example, one can pass -j4 to; make get a parallel build over 4 cores:. $ scan-build make -j4. In almost all cases, scan-build makes no effort to interpret the; options after the build command; it simply passes them through. In general,; scan-build should support parallel builds, but not distributed; builds.; It is also possible to use scan-build to analyze specific; files:. $ scan-build gcc -c t1.c t2.c. This example causes the files t1.c and t2.c to be analyzed. For Windows Users; Windows users must have Perl installed to use scan-build.; scan-build.bat script allows you to launch scan-build in the same; way as it described in the Basic Usage section above. To invoke scan-build from; an arbitrary location, add the path to the folder containing scan-build.bat to; your PATH environment variable.; If you have unexpected compilation/make problems when running scan-build; with MinGW/MSYS the following information may be helpful:. If getting unexpected ""fatal error: no input files"" while; building with MSYS make from the Windows cmd, try one of these solutions:. Use MinGW mingw32-make instead of MSYS make and; exclude the path to MSYS from PATH ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/scan-build.html:2684,simpl,simply,2684,interpreter/llvm-project/clang/www/analyzer/scan-build.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/scan-build.html,1,['simpl'],['simply']
Usability,"c blocks in the CFG). Entry and Exit Blocks; ^^^^^^^^^^^^^^^^^^^^^. Each instance of ``CFG`` contains two special blocks: an *entry* block; (accessible via ``CFG::getEntry()``), which has no incoming edges, and an; *exit* block (accessible via ``CFG::getExit()``), which has no outgoing edges.; Neither block contains any statements, and they serve the role of providing a; clear entrance and exit for a body of code such as a function body. The; presence of these empty blocks greatly simplifies the implementation of many; analyses built on top of CFGs. .. _ConditionalControlFlow:. Conditional Control-Flow; ^^^^^^^^^^^^^^^^^^^^^^^^. Conditional control-flow (such as those induced by if-statements and loops) is; represented as edges between ``CFGBlocks``. Because different C language; constructs can induce control-flow, each ``CFGBlock`` also records an extra; ``Stmt*`` that represents the *terminator* of the block. A terminator is; simply the statement that caused the control-flow, and is used to identify the; nature of the conditional control-flow between blocks. For example, in the; case of an if-statement, the terminator refers to the ``IfStmt`` object in the; AST that represented the given branch. To illustrate, consider the following code example:. .. code-block:: c++. int foo(int x) {; x = x + 1;; if (x > 2); x++;; else {; x += 2;; x *= 2;; }. return x;; }. After invoking the parser+semantic analyzer on this code fragment, the AST of; the body of ``foo`` is referenced by a single ``Stmt*``. We can then construct; an instance of ``CFG`` representing the control-flow graph of this function; body by single call to a static class method:. .. code-block:: c++. Stmt *FooBody = ...; std::unique_ptr<CFG> FooCFG = CFG::buildCFG(FooBody);. Along with providing an interface to iterate over its ``CFGBlocks``, the; ``CFG`` class also provides methods that are useful for debugging and; visualizing CFGs. For example, the method ``CFG::dump()`` dumps a; pretty-printed version of ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:114390,simpl,simply,114390,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['simpl'],['simply']
Usability,"c destroys a suspended; switched-resume coroutine. Arguments:; """""""""""""""""""". The argument is a coroutine handle to a suspended coroutine. Semantics:; """""""""""""""""""". When possible, the `coro.destroy` intrinsic is replaced with a direct call to; the coroutine destroy function. Otherwise it is replaced with an indirect call; based on the function pointer for the destroy function stored in the coroutine; frame. Destroying a coroutine that is not suspended leads to undefined behavior. .. _coro.resume:. 'llvm.coro.resume' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ::. declare void @llvm.coro.resume(ptr <handle>). Overview:; """""""""""""""""". The '``llvm.coro.resume``' intrinsic resumes a suspended switched-resume coroutine. Arguments:; """""""""""""""""""". The argument is a handle to a suspended coroutine. Semantics:; """""""""""""""""""". When possible, the `coro.resume` intrinsic is replaced with a direct call to the; coroutine resume function. Otherwise it is replaced with an indirect call based; on the function pointer for the resume function stored in the coroutine frame.; Resuming a coroutine that is not suspended leads to undefined behavior. .. _coro.done:. 'llvm.coro.done' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ::. declare i1 @llvm.coro.done(ptr <handle>). Overview:; """""""""""""""""". The '``llvm.coro.done``' intrinsic checks whether a suspended; switched-resume coroutine is at the final suspend point or not. Arguments:; """""""""""""""""""". The argument is a handle to a suspended coroutine. Semantics:; """""""""""""""""""". Using this intrinsic on a coroutine that does not have a `final suspend`_ point; or on a coroutine that is not suspended leads to undefined behavior. .. _coro.promise:. 'llvm.coro.promise' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ::. declare ptr @llvm.coro.promise(ptr <ptr>, i32 <alignment>, i1 <from>). Overview:; """""""""""""""""". The '``llvm.coro.promise``' intrinsic obtains a pointer to a; `coroutine promise`_ given a switched-resume coroutine handle and vice versa. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:28247,resume,resume,28247,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"c, with Cocoa, the pattern selector did not work anymore and the fit panel range did not work. - Fix in Cocoa. XSGui crashed on Mac M1. ## WebGUI Libraries. - provide `--web=server` mode, which only printout window URLs instead of starting real web browser.; Dedicated for the case when ROOT should be running as server application, providing different RWebWindow instances for connection. ## Montecarlo Libraries. ## PROOF Libraries. ## Language Bindings. ## JavaScript ROOT. ## Jupyter lab. - Let use created notebooks with viewers like https://nbviewer.jupyter.org/; - Fix problem with using of local JSROOT version. ## Tutorials. - The tutorial games.C was not working properly. - Improve tutorial ErrorIntegral.C. - Schrödinger's Hydrogen Atom example. - Tutorial demonstrating how the changing of the range can zoom into the histogram. - Tutorial demonstrating how a Histogram can be read from a ROOT File. - histMax.C: a tutorial demoing how the hist->GetMaximumBin() can be used. ## Class Reference Guide. - Images for ROOT7 tutorials can be generated, in json format, using the directive using; `\macro_image (json)` in the macro header. - Clarify THStack drawing options. - Add missing documentation to TH1 functions. - Restructure the math reference guide. - Make the web gui documentation visible in the reference guide. - Make clear THtml is legacy code. Add deprecated flag on PROOF and TGeoTrack. - Improve many classes documentation: TContext, TTreePlayer, THistPainter, TGraph, TSelector,; integrator, GUI, TH1, TH2, TH3, TColor classes ... - Make the TFile layout doc visible in Reference Guide. - Update the external links of the reference guide main page. - Reformat TMVA mathcore Unuran Roostats documentation . ## Build, Configuration and Testing Infrastructure. - For users building from source the `latest-stable` branch and passing `-Droottest=ON` to the CMake command line, the corresponding revision of roottest pointed to by `latest-stable` will be downloaded as required.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md:38659,Guid,Guide,38659,README/ReleaseNotes/v626/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md,1,['Guid'],['Guide']
Usability,c/LaInnerProduct.cxx; src/LaInverse.cxx; src/LaOuterProduct.cxx; src/LaSumOfElements.cxx; src/LaVtMVSimilarity.cxx; src/MPIProcess.cxx; src/MinimumBuilder.cxx; src/Minuit2Minimizer.cxx; src/MnApplication.cxx; src/MnContours.cxx; src/MnCovarianceSqueeze.cxx; src/MnEigen.cxx; src/MnFcn.cxx; src/MnFumiliMinimize.cxx; src/MnFunctionCross.cxx; src/MnGlobalCorrelationCoeff.cxx; src/MnHesse.cxx; src/MnLineSearch.cxx; src/MnMachinePrecision.cxx; src/MnMinos.cxx; src/MnParabolaFactory.cxx; src/MnParameterScan.cxx; src/MnPlot.cxx; src/MnPosDef.cxx; src/MnPrint.cxx; src/MnPrintImpl.cxx; src/MnScan.cxx; src/MnSeedGenerator.cxx; src/MnStrategy.cxx; src/MnTiny.cxx; src/MnTraceObject.cxx; src/MnUserFcn.cxx; src/MnUserParameterState.cxx; src/MnUserParameters.cxx; src/MnUserTransformation.cxx; src/ModularFunctionMinimizer.cxx; src/NegativeG2LineSearch.cxx; src/Numerical2PGradientCalculator.cxx; src/NumericalDerivator.cxx; src/ParametricFunction.cxx; src/ScanBuilder.cxx; src/SimplexBuilder.cxx; src/SimplexParameters.cxx; src/SimplexSeedGenerator.cxx; src/SinParameterTransformation.cxx; src/SqrtLowParameterTransformation.cxx; src/SqrtUpParameterTransformation.cxx; src/TMinuit2TraceObject.cxx; src/VariableMetricBuilder.cxx; src/VariableMetricEDMEstimator.cxx; src/mnbins.cxx; src/mndasum.cxx; src/mndaxpy.cxx; src/mnddot.cxx; src/mndscal.cxx; src/mndspmv.cxx; src/mndspr.cxx; src/mnlsame.cxx; src/mnteigen.cxx; src/mntplot.cxx; src/mnvert.cxx; src/mnxerbla.cxx; DICTIONARY_OPTIONS; -writeEmptyRootPCM; DEPENDENCIES; MathCore; Hist; ); endif(). if(minuit2_omp); find_package(OpenMP REQUIRED); find_package(Threads REQUIRED). if(NOT TARGET OpenMP::OpenMP_CXX); add_library(OpenMP::OpenMP_CXX IMPORTED INTERFACE); set_property(TARGET OpenMP::OpenMP_CXX PROPERTY INTERFACE_COMPILE_DEFINITIONS -D_GLIBCXX_PARALLEL); set_property(TARGET OpenMP::OpenMP_CXX PROPERTY INTERFACE_COMPILE_OPTIONS ${OpenMP_CXX_FLAGS}); set_property(TARGET OpenMP::OpenMP_CXX PROPERTY INTERFACE_LINK_LIBRARIES ${OpenMP_CXX_LIBRARIE,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/CMakeLists.txt:4949,Simpl,SimplexParameters,4949,math/minuit2/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/CMakeLists.txt,1,['Simpl'],['SimplexParameters']
Usability,"called; with constants like in the ""``sin(1.0)``"" above. In the future we'll see how tweaking this symbol resolution rule can be used to; enable all sorts of useful features, from security (restricting the set of; symbols available to JIT'd code), to dynamic code generation based on symbol; names, and even lazy compilation. One immediate benefit of the symbol resolution rule is that we can now extend; the language by writing arbitrary C++ code to implement operations. For example,; if we add:. .. code-block:: c++. #ifdef _WIN32; #define DLLEXPORT __declspec(dllexport); #else; #define DLLEXPORT; #endif. /// putchard - putchar that takes a double and returns 0.; extern ""C"" DLLEXPORT double putchard(double X) {; fputc((char)X, stderr);; return 0;; }. Note, that for Windows we need to actually export the functions because; the dynamic symbol loader will use ``GetProcAddress`` to find the symbols. Now we can produce simple output to the console by using things like:; ""``extern putchard(x); putchard(120);``"", which prints a lowercase 'x'; on the console (120 is the ASCII code for 'x'). Similar code could be; used to implement file I/O, console input, and many other capabilities; in Kaleidoscope. This completes the JIT and optimizer chapter of the Kaleidoscope; tutorial. At this point, we can compile a non-Turing-complete; programming language, optimize and JIT compile it in a user-driven way.; Next up we'll look into `extending the language with control flow; constructs <LangImpl05.html>`_, tackling some interesting LLVM IR issues; along the way. Full Code Listing; =================. Here is the complete code listing for our running example, enhanced with; the LLVM JIT and optimizer. To build this example, use:. .. code-block:: bash. # Compile; clang++ -g toy.cpp `llvm-config --cxxflags --ldflags --system-libs --libs core orcjit native` -O3 -o toy; # Run; ./toy. If you are compiling this on Linux, make sure to add the ""-rdynamic""; option as well. This makes sure that the e",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl04.rst:24315,simpl,simple,24315,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl04.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl04.rst,1,['simpl'],['simple']
Usability,"can modify the; entities described in an earlier precompiled header. For example, later; precompiled headers can add entries into the various name-lookup tables for; the translation unit or namespaces, or add new categories to an Objective-C; class. Each of these updates is captured in an ""update record"" that is; stored in the chained precompiled header file and will be loaded along with; the original entity. .. _pchinternals-modules:. Modules; -------. Modules generalize the chained precompiled header model yet further, from a; linear chain of precompiled headers to an arbitrary directed acyclic graph; (DAG) of AST files. All of the same techniques used to make chained; precompiled headers work --- ID number, name lookup, update records --- are; shared with modules. However, the DAG nature of modules introduce a number of; additional complications to the model:. Numbering of IDs; The simple, linear numbering scheme used in chained precompiled headers falls; apart with the module DAG, because different modules may end up with; different numbering schemes for entities they imported from common shared; modules. To account for this, each module file provides information about; which modules it depends on and which ID numbers it assigned to the entities; in those modules, as well as which ID numbers it took for its own new; entities. The AST reader then maps these ""local"" ID numbers into a ""global""; ID number space for the current translation unit, providing a 1-1 mapping; between entities (in whatever AST file they inhabit) and global ID numbers.; If that translation unit is then serialized into an AST file, this mapping; will be stored for use when the AST file is imported. Declaration merging; It is possible for a given entity (from the language's perspective) to be; declared multiple times in different places. For example, two different; headers can have the declaration of ``printf`` or could forward-declare; ``struct stat``. If each of those headers is included in a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst:27554,simpl,simple,27554,interpreter/llvm-project/clang/docs/PCHInternals.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst,1,['simpl'],['simple']
Usability,"can only be specified for unique-suspend; returned-continuation coroutines where it must be a token value produced by; '``llvm.coro.end.results``' intrinsic. Only none token is allowed for coro.end calls in unwind sections. Semantics:; """"""""""""""""""""; The purpose of this intrinsic is to allow frontends to mark the cleanup and; other code that is only relevant during the initial invocation of the coroutine; and should not be present in resume and destroy parts. In returned-continuation lowering, ``llvm.coro.end`` fully destroys the; coroutine frame. If the second argument is `false`, it also returns from; the coroutine with a null continuation pointer, and the next instruction; will be unreachable. If the second argument is `true`, it falls through; so that the following logic can resume unwinding. In a yield-once; coroutine, reaching a non-unwind ``llvm.coro.end`` without having first; reached a ``llvm.coro.suspend.retcon`` has undefined behavior. The remainder of this section describes the behavior under switched-resume; lowering. This intrinsic is lowered when a coroutine is split into; the start, resume and destroy parts. In the start part, it is a no-op,; in resume and destroy parts, it is replaced with `ret void` instruction and; the rest of the block containing `coro.end` instruction is discarded.; In landing pads it is replaced with an appropriate instruction to unwind to; caller. The handling of coro.end differs depending on whether the target is; using landingpad or WinEH exception model. For landingpad based exception model, it is expected that frontend uses the; `coro.end`_ intrinsic as follows:. .. code-block:: llvm. ehcleanup:; %InResumePart = call i1 @llvm.coro.end(ptr null, i1 true, token none); br i1 %InResumePart, label %eh.resume, label %cleanup.cont. cleanup.cont:; ; rest of the cleanup. eh.resume:; %exn = load ptr, ptr %exn.slot, align 8; %sel = load i32, ptr %ehselector.slot, align 4; %lpad.val = insertvalue { ptr, i32 } undef, ptr %exn, 0; %lpad.va",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:44146,resume,resume,44146,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"case, you should install ```openssl-devel```, re-compile Python and ```configure```; will automatically link against the required libraries and produce a binary with SSL; support. #### Ubuntu/Debian; On Debian, Ubuntu, Linux Mint, CrunchBang, or any other distro based on Debian; which supports APT package manager, you can install all the required packages by:; ```sh; sudo apt-get update; sudo apt-get install git g++ debhelper devscripts gnupg python; ```; You are not required to do this manually since CPT can do this for you automatically. ###### Setting up:; Make sure GnuPG is properly set up with your correct fingerprint. These; credentials are needed to sign the Debian package and create Debian changelogs.; On a build machine (Electric Commander), make sure the fingerprint is of the; user who is supposed to sign the official uploads. You might also want to; configure GnuPG to not ask for the passphrase while signing the Debian package. The [Ubuntu Packaging Guide] contains a quick guide on creating a GPG key on an; Ubuntu system. To test if you have successfully set up your GnuPG key, use the following command:; ```sh; gpg --fingerprint; ```; Again, all these checks are performed by default when you launch CPT with ```-c``` option.; [Ubuntu Packaging Guide]:http://packaging.ubuntu.com/html/getting-set-up.html#create-your-gpg-key. #### Windows; CPT is meant to be executed on cmd.exe prompt. Make sure you have set the; environment properly before continuing.; Below is a list of required packages for Windows (Win32-x86):. [MSYS Git] for Windows. [Python] for Windows. Microsoft Visual Studio 11 (2012), with Microsoft Visual C++ 2012. [MSYS Git]:http://msysgit.github.io/; [Python]:https://www.python.org/. ###### Setting Up:; Unlike other UNIX-like platforms, Windows requires you to follow some rules.; Do not ignore this section unless you want CPT to fail mid-way with wierd; errors. You should require these instructions only once. * While installing the packages make ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/tools/packaging/README.md:3173,Guid,Guide,3173,interpreter/cling/tools/packaging/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/tools/packaging/README.md,2,"['Guid', 'guid']","['Guide', 'guide']"
Usability,"cause they can all be seen together. Each option acts as a switch and; can be either ""on"" or ""off"". It is never changed in contents. Checkboxes; differ from radio buttons in that they permit selection of more than one; alternative. Each box can be switched on or off independently. These; buttons can be used alone or grouped in sets. It is good practice to; provide default settings for check boxes whenever it is possible. ![](pictures/03000213.png). This can be done by:. ``` {.cpp}; SetState(EButtonState state); ```. The parameter state can be one of `kButtonUp`, `kButtonDown`,; `kButtonEngaged`, `kButtonDisabled`. Check boxes can be used to affect other controls. The contents of a list; can, for example, be filtered by setting a check box. In any case, use a; check box only when both states of a choice are clearly opposite and; unambiguous. If opposite states are not clear, it is better to use two; radio buttons. Choice description, i.e. check box label, must be clear, meaningful,; fully spelled out, and displayed in mixed-type text. Whenever the use of; a given button is inappropriate, for whatever reason, that button should; be disabled:. ``` {.cpp}; button->SetState(kButtonDisabled);; ```. Never make a button appear and disappear. In general, option buttons should not offer more than eight choices. If; the number of choices exceeds this maximum, it is better to use a; multiple selection list box. The method `IsToggleButton()` gives the information whether a radio; button or a check button is selected. An option button can be set or; unset via its method `PSetState(EButtonState state).`. The method `HandleKey(event)` is called when the defined hotkey is hit; for any button. It sets the selected option button or clicks the; selected text button and invokes its defined action. ### Text Entries. A **`TGTextEntry`** is a one-line text input widget. It contains text; that is entered or modified through the keyboard. This text may be; displayed in different way accordin",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:63297,clear,clear,63297,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,1,['clear'],['clear']
Usability,"causing destructors of constant-evaluated structured bindings; initialized by array elements to be called in the wrong evaluation context. - Fix crash where ill-formed code was being treated as a deduction guide and; we now produce a diagnostic. Fixes:; (`#65522 <https://github.com/llvm/llvm-project/issues/65522>`_). - Fixed a bug where clang incorrectly considered implicitly generated deduction; guides from a non-templated constructor and a templated constructor as ambiguous,; rather than prefer the non-templated constructor as specified in; [standard.group]p3. - Fixed a crash caused by incorrect handling of dependence on variable templates; with non-type template parameters of reference type. Fixes:; (`#65153 <https://github.com/llvm/llvm-project/issues/65153>`_). - Clang now properly compares constraints on an out of line class template; declaration definition. Fixes:; (`#61763 <https://github.com/llvm/llvm-project/issues/61763>`_). - Fix a bug where implicit deduction guides are not correctly generated for nested template; classes. Fixes:; (`#46200 <https://github.com/llvm/llvm-project/issues/46200>`_); (`#57812 <https://github.com/llvm/llvm-project/issues/57812>`_). - Diagnose use of a variable-length array in a coroutine. The design of; coroutines is such that it is not possible to support VLA use. Fixes:; (`#65858 <https://github.com/llvm/llvm-project/issues/65858>`_). - Fix bug where we were overriding zero-initialization of class members when; default initializing a base class in a constant expression context. Fixes:; (`#69890 <https://github.com/llvm/llvm-project/issues/69890>`_). - Fix crash when template class static member imported to other translation unit.; Fixes:; (`#68769 <https://github.com/llvm/llvm-project/issues/68769>`_). - Clang now rejects incomplete types for ``__builtin_dump_struct``. Fixes:; (`#63506 <https://github.com/llvm/llvm-project/issues/63506>`_). - Fixed a crash for C++98/03 while checking an ill-formed ``_Static_assert`` expressi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:52009,guid,guides,52009,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst,1,['guid'],['guides']
Usability,"ccess.; The essence of that method is: ""release early, release often and; listen to your customers"". This is precisely how ROOT is being; developed. Over the last five years, many of our ""customers"" became; co-developers. Here we would like to thank our main co-developers and; contributors:. **Masaharu Goto** wrote the C++ interpreter CINT that was an; essential part of ROOT before ROOT 6. Despite being 8 time zones ahead; of us, we have the feeling he has been sitting in the room next door; since 1995. **Andrei** and **Mihaela Gheata** (Alice collaboration) are co-authors; of the ROOT geometry classes and Virtual Monte-Carlo. They have been; working with the ROOT team since 2000. **Olivier Couet**, who after a successful development and maintenance; of PAW, has joined the ROOT team in 2000 and has been working on the; graphics sub-system. **Ilka Antcheva** has been working on the Graphical User Interface; classes. She is also responsible for this latest edition of the Users; Guide with a better style, improved index and several new chapters; (since 2002). **Bertrand Bellenot** has been developing and maintaining the Win32GDK; version of ROOT. Bertrand has also many other contributions like the; nice RootShower example (since 2001). **Valeriy Onoutchin** has been working on several ROOT packages, in; particular the graphics sub-system for Windows and the GUI Builder; (since 2000). **Gerri Ganis** has been working on the authentication procedures to; be used by the root daemons and the PROOF system (since 2002). **Maarten Ballintijn** (MIT) is one of the main developers of the; PROOF sub-system (since 1995). **Valeri Fine** (now at BNL) ported ROOT to Windows and contributed; largely to the 3-D graphics. He is currently working on the Qt layer; of ROOT (since 1995). **Victor Perevoztchikov** (BNL) worked on key elements of the I/O; system, in particular the improved support for STL collections; (1997-2001). **Nenad Buncic** developed the HTML documentation generation",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Preface.md:2540,Guid,Guide,2540,documentation/users-guide/Preface.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Preface.md,1,['Guid'],['Guide']
Usability,"ce Code Transformation takes the source code (that needs to be; differentiated) as the input and generates an output code that represents the; derivative of the input. This output code can be used instead of the input; code for more efficient compilation. For more technical details, please see the following paper:. > [Automatic Differentiation of Binned Likelihoods with RooFit and Clad](https://arxiv.org/abs/2304.02650). ## Overview on RooFit implementation details to access source code transformation AD. In RooFit jargon, what is meant by a ""RooFit class"" is a class inheriting from; RooAbsArg that represents a mathematical function, a PDF, or any other; transformation of inputs that are also represented by RooAbsArg objects.; Almost all final classes deriving from RooAbsArg have RooAbsReal as an; intermediate base class, which is the base class for all RooAbsArg that; represent real-valued nodes in the computation graph.; As such RooFit objects are so prevalent in practice, the names RooAbsArg and; RooAbsReal are used interchangeably in this guide. Users take these classes to build a computational graph that represents the; PDF (also called ""model"") that they want to use for fitting the data.; The user then passes his final PDF and a RooAbsData object to the; RooAbsPdf::fitTo() method, which implicitly creates a negative-log likelihood; (NLL) that RooFit minimizes for parameter estimation.; The NLL object, internally created by RooAbsPdf::createNLL(), is a RooAbsArg; itself.; In technical terms, it's another larger computation graph that encompasses the; computation graph representing the PDF. To enable source code transformation AD for RooFit NLLs with Clad, RooFit has a; routine that can traverse a computation graph made of RooAbsArg objects and; transform it to much simpler C++ code that mathematically represents the same; computation, but without any overhead that is hard to digest by the AD tool. On a high level, this *code generation* is implemented as follow",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md:3468,guid,guide,3468,roofit/doc/developers/roofit_ad.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md,1,['guid'],['guide']
Usability,"ce and the; stability of the C++ API that it wraps. In practice, this means that things; like ""create debug info"" or ""create this type of instruction"" are likely to be; less stable than ""take this IR file and JIT it for my current machine"". * Release stability: We won't break the C API on the release branch with patches; that go on that branch, with the exception that we will fix an unintentional; C API break that will keep the release consistent with both the previous and; next release. * Testing: Patches to the C API are expected to come with tests just like any; other patch. * Including new things into the API: If an LLVM subcomponent has a C API already; included, then expanding that C API is acceptable. Adding C API for; subcomponents that don't currently have one needs to be discussed on the; `LLVM Discourse forums`_ for design and maintainability feedback prior to implementation. * Documentation: Any changes to the C API are required to be documented in the; release notes so that it's clear to external users who do not follow the; project how the C API is changing and evolving. .. _toolchain:. Updating Toolchain Requirements; -------------------------------. We intend to require newer toolchains as time goes by. This means LLVM's; codebase can use newer versions of C++ as they get standardized. Requiring newer; toolchains to build LLVM can be painful for those building LLVM; therefore, it; will only be done through the following process:. * It is a general goal to support LLVM and GCC versions from the last 3 years; at a minimum. This time-based guideline is not strict: we may support much; older compilers, or decide to support fewer versions. * An RFC is sent to the `LLVM Discourse forums`_. - Detail upsides of the version increase (e.g. which newer C++ language or; library features LLVM should use; avoid miscompiles in particular compiler; versions, etc).; - Detail downsides on important platforms (e.g. Ubuntu LTS status). * Once the RFC reaches consensus, ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst:33802,clear,clear,33802,interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,1,['clear'],['clear']
Usability,"ced that ``%simplified`` is narrower than ``%c``: this is not; a problem, because ``llvm::replaceAllDbgUsesWith`` takes care of inserting the; necessary conversion operations into the DIExpressions of updated debug uses. Deleting a MIR-level MachineInstr; ---------------------------------. TODO. Rules for updating ``DIAssignID`` Attachments; =============================================. ``DIAssignID`` metadata attachments are used by Assignment Tracking, which is; currently an experimental debug mode. See :doc:`AssignmentTracking` for how to update them and for more info on; Assignment Tracking. How to automatically convert tests into debug info tests; ========================================================. .. _IRDebugify:. Mutation testing for IR-level transformations; ---------------------------------------------. An IR test case for a transformation can, in many cases, be automatically; mutated to test debug info handling within that transformation. This is a; simple way to test for proper debug info handling. The ``debugify`` utility pass; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``debugify`` testing utility is just a pair of passes: ``debugify`` and; ``check-debugify``. The first applies synthetic debug information to every instruction of the; module, and the second checks that this DI is still available after an; optimization has occurred, reporting any errors/warnings while doing so. The instructions are assigned sequentially increasing line locations, and are; immediately used by debug value intrinsics everywhere possible. For example, here is a module before:. .. code-block:: llvm. define void @f(i32* %x) {; entry:; %x.addr = alloca i32*, align 8; store i32* %x, i32** %x.addr, align 8; %0 = load i32*, i32** %x.addr, align 8; store i32 10, i32* %0, align 4; ret void; }. and after running ``opt -debugify``:. .. code-block:: llvm. define void @f(i32* %x) !dbg !6 {; entry:; %x.addr = alloca i32*, align 8, !dbg !12; call void @llvm.dbg.value(metadata i32** %x.addr,",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToUpdateDebugInfo.rst:9530,simpl,simple,9530,interpreter/llvm-project/llvm/docs/HowToUpdateDebugInfo.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToUpdateDebugInfo.rst,1,['simpl'],['simple']
Usability,"cement of a volume with respect to its container; reference frame. This frame will be called 'master' and the frame of the; positioned volume - 'local'. If `T` is a transformation used for; positioning volume daughters, then: `MASTER = T * LOCAL`. Therefore `T `is used to perform a local to master conversion, while; `T-1` for a master to local conversion. The second use case is the; computation of the global transformation of a given object in the; geometry. Since the geometry is built as 'volumes-inside-volumes', the; global transformation represents the pile-up of all local; transformations in the corresponding branch. Once a given object in the; hierarchy becomes the current one, the conversion from master to local; coordinates or the other way around can be done from the manager class. A general homogenous transformation is defined as a 4x4 matrix embedding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous; matrix, composition being performed as simple matrix multiplication. Rotation:. \f[; \left|\begin{array}{cccc}; r_{11} & r_{12} & r_{13} & 0 \\; r_{21} & r_{22} & r_{23} & 0 \\; r_{31} & r_{32} & r_{33} & 0 \\; 0 & 0 & 0 & 1; \end{array}; \right|; \f]. Translation:. \f[; \left|\begin{array}{cccc}; 1 & 0 & 0 & 0 \\; 0 & 1 & 0 & 0 \\; 0 & 0 & 1 & 0 \\; t_x & t_y & t_z & 1; \end{array}; \right|; \f]. Scale:. \f[; \left|\begin{array}{cccc}; s_x & 0 & 0 & 0 \\; 0 & s_y & 0 & 0 \\; 0 & 0 & s_z & 0 \\; 0 & 0 & 0 & 1; \end{array}; \right|; \f]. Inverse rotation:. \f[; \left|\begin{array}{cccc}; r_{11} & r_{21} & r_{31} & 0 \\; r_{12} & r_{22} & r_{32} & 0 \\; r_{13} & r_{23} & r_{33} & 0 \\; 0 & 0 & 0 & 1; \end{array}; \right|; \f]. Inverse translation:. \f[; \left|\begin{array}{cccc}; 1 & 0 & 0 & 0 \\; 0 & 1 & 0 & 0 \\; 0 & 0 & 1 & 0 \\; -t_x & -t_y & -t_z & 1; \end{array}; \right|; \f]. Inverse scale:. \f[; \left|\begin{array}{cccc}; \frac{1}{s_x} & 0 & 0 & 0 \\; 0 & \frac",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:52756,simpl,simple,52756,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['simpl'],['simple']
Usability,"cement of a volume with respect to its container; reference frame. This frame will be called 'master' and the frame of the; positioned volume - 'local'. If `T` is a transformation used for; positioning volume daughters, then: `MASTER = T * LOCAL`. Therefore `T `is used to perform a local to master conversion, while; `T-1` for a master to local conversion. The second use case is the; computation of the global transformation of a given object in the; geometry. Since the geometry is built as 'volumes-inside-volumes', the; global transformation represents the pile-up of all local; transformations in the corresponding branch. Once a given object in the; hierarchy becomes the current one, the conversion from master to local; coordinates or the other way around can be done from the manager class. A general homogenous transformation is defined as a 4x4 matrix embedding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous; matrix, composition being performed as simple matrix multiplication. Rotation:; $\left|\begin{array}{cccc}; r_{11} & r_{12} & r_{13} & 0 \\; r_{21} & r_{22} & r_{23} & 0 \\; r_{31} & r_{32} & r_{33} & 0 \\; 0 & 0 & 0 & 1; \end{array}; \right|$; Translation:; $\left|\begin{array}{cccc}; 1 & 0 & 0 & 0 \\; 0 & 1 & 0 & 0 \\; 0 & 0 & 1 & 0 \\; t_x & t_y & t_z & 1; \end{array}; \right|$; Scale:; $\left|\begin{array}{cccc}; s_x & 0 & 0 & 0 \\; 0 & s_y & 0 & 0 \\; 0 & 0 & s_z & 0 \\; 0 & 0 & 0 & 1; \end{array}; \right|$. Inverse rotation:; $\left|\begin{array}{cccc}; r_{11} & r_{21} & r_{31} & 0 \\; r_{12} & r_{22} & r_{32} & 0 \\; r_{13} & r_{23} & r_{33} & 0 \\; 0 & 0 & 0 & 1; \end{array}; \right|$; Inverse translation:; $\left|\begin{array}{cccc}; 1 & 0 & 0 & 0 \\; 0 & 1 & 0 & 0 \\; 0 & 0 & 1 & 0 \\; -t_x & -t_y & -t_z & 1; \end{array}; \right|$; Inverse scale:; $\left|\begin{array}{cccc}; \frac{1}{s_x} & 0 & 0 & 0 \\; 0 & \frac{1}{s_y} & 0 & 0 \\; 0 & 0 & \frac{1}{s_z} &",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:92429,simpl,simple,92429,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['simpl'],['simple']
Usability,"cern.ch/t/25889; - Ignore not-supported options in TMultiGraph https://root-forum.cern.ch/t/25888; - Correctly use fGridColor from TStyle; - Prevent error when TPaveText includes TLine or TBox in list of lines; - Bin errors calculations in TProfile; - Correctly handle new TF1 parameter coding convention (jsroot#132); - Check if pad name can be used as element id (jsroot#133); - Adjust title position for vertical axis with fTitleOffset==0. ## Tutorials. - xml/xmlreadfile.C shows how to read and parse any xml file, supported by TXMLEngine class.; - fit/fitNormSum.C shows building of vectorized function and fitting with TF1.; - multicore/mt303_AsyncSimple.C explains uses of `Async()` and `TFuture`.; - multicore/mt304_fillHistos.C shows the new auto-binning mechanism.; - graphs/timeSeriesFromCSV_TDF.C illustrates a time axis on a TGraph with text-data read by `TDataFrame`.; - dataframe/tdf013_InspectAnalysis.C shows how to display incremental snapshots of `TDataFrame` analysis results in a `TBrowser`; - dataframe/tdf014_CSVDataSource.C shows reading text-data (comma separated) using a `TDataFrame`; - dataframe/tdf012_DefinesAndFiltersAsStrings.C shows how to use jitted defines and filters by calculating pi; from checking how many randomly generated points in the unit square fall inside a unit circle; - most `TDataFrame` tutorials are now provided both in C++ and python. ## Command line tools; - `rootls` has been extended.; - option `-l` displays the year; - option `-t` displays all details of 'THnSparse'; - `rootcp` bug fixes ([ROOT-8528](https://sft.its.cern.ch/jira/browse/ROOT-8528)); - Now copies only the latest version of each object instead of copying all; versions in wrong order. ## Class Reference Guide; - The list of libraries needed by each class is displayed as a diagram. ## Build, Configuration and Testing Infrastructure. This is the last release with the configure/make-based build system. It will; be removed; please migrate to the CMake-based build system.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v612/index.md:31864,Guid,Guide,31864,README/ReleaseNotes/v612/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v612/index.md,1,['Guid'],['Guide']
Usability,"ch if only part of the statement is expanded from that macro or; if different parts of the statement are expanded from different; appearances of the macro. Matcher<TypeLoc>isExpansionInFileMatchingStringRef RegExp, Regex::RegexFlags Flags = NoFlags; Matches AST nodes that were expanded within files whose name is; partially matching a given regex. Example matches Y but not X; (matcher = cxxRecordDecl(isExpansionInFileMatching(""AST.*"")); #include ""ASTMatcher.h""; class X {};; ASTMatcher.h:; class Y {};. Usable as: Matcher<Decl>, Matcher<Stmt>, Matcher<TypeLoc>. If the matcher is used in clang-query, RegexFlags parameter; should be passed as a quoted string. e.g: ""NoFlags"".; Flags can be combined with '|' example ""IgnoreCase | BasicRegex"". Matcher<TypeLoc>isExpansionInMainFile; Matches AST nodes that were expanded within the main-file. Example matches X but not Y; (matcher = cxxRecordDecl(isExpansionInMainFile()); #include <Y.h>; class X {};; Y.h:; class Y {};. Usable as: Matcher<Decl>, Matcher<Stmt>, Matcher<TypeLoc>. Matcher<TypeLoc>isExpansionInSystemHeader; Matches AST nodes that were expanded within system-header-files. Example matches Y but not X; (matcher = cxxRecordDecl(isExpansionInSystemHeader()); #include <SystemHeader.h>; class X {};; SystemHeader.h:; class Y {};. Usable as: Matcher<Decl>, Matcher<Stmt>, Matcher<TypeLoc>. Matcher<Type>booleanType; Matches type bool. Given; struct S { bool func(); };; functionDecl(returns(booleanType())); matches ""bool func();"". Matcher<Type>equalsBoundNodestd::string ID; Matches if a node equals a previously bound node. Matches a node if it equals the node previously bound to ID. Given; class X { int a; int b; };; cxxRecordDecl(; has(fieldDecl(hasName(""a""), hasType(type().bind(""t"")))),; has(fieldDecl(hasName(""b""), hasType(type(equalsBoundNode(""t"")))))); matches the class X, as a and b have the same type. Note that when multiple matches are involved via forEach* matchers,; equalsBoundNodes acts as a filter.; For example:; comp",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:120790,Usab,Usable,120790,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['Usab'],['Usable']
Usability,"ched to, since these will be destroyed together. ![Editors for shapes, materials, media, matrices](pictures/020001F0.jpg); ![Editors for shapes, materials, media, matrices](pictures/020001F1.jpg); ![Editors for shapes, materials, media, matrices](pictures/020001F2.jpg); ![Editors for shapes, materials, media, matrices](pictures/020001F3.jpg); ![Editors for shapes, materials, media, matrices](pictures/030001F4.png). For most editors, the functionalities Apply and Undo are provided. For shapes, changing any of the shape parameters will activate the; ""*Apply*"" button only if the check button ""*Delayed draw*"" is checked,; otherwise the changes are immediately applied. Once the apply button is; pressed, the changes are applied to the edited shape and drawn. The; ""*Undo*"" button becomes active after the first modification has been; applied. It allows restoring the initial parameters of the shape. NOTE: In this version the ""*Undo*"" does not allow restoring an; intermediate state of the parameters that was applied - it will always; restore the parameters at the moment the shape was edited. All material properties changes are undoable. The mixture editor; currently allows adding elements one by one in the mixture composition.; This can be done either by element weight fraction or by number of; atoms. Once an element was added using one method the other method is not; selectable anymore. Summing component fractions up to 1 in the final; mixture is the user responsibility. Adding materials as components of a; mixture is not supported in this version. The elements that were added to the mixture appear in the bottom of the; mixture editor. The operations performed on mixture are not undoable. ### Creation of New Objects. As described above, all geometry object creators are accessible within; the geometry manager editor frame. Generally, if the new object that; needs to be created does not depend on other objects, it will be built; with a set of default parameters. This is the cas",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:170984,Undo,Undo,170984,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['Undo'],['Undo']
Usability,"cheme:. ``<base>-<arch>.opt.<format>``. Note that this is incompatible with passing the; :option:`-foptimization-record-file` option. .. option:: -foptimization-record-file. Control the file to which optimization reports are written. This implies; :ref:`-fsave-optimization-record <opt_fsave-optimization-record>`. On Darwin platforms, this is incompatible with passing multiple; ``-arch <arch>`` options. .. option:: -foptimization-record-passes. Only include passes which match a specified regular expression. When optimization reports are being output (see; :ref:`-fsave-optimization-record <opt_fsave-optimization-record>`), this; option controls the passes that will be included in the final report. If this option is not used, all the passes are included in the optimization; record. .. _opt_fdiagnostics-show-hotness:. .. option:: -f[no-]diagnostics-show-hotness. Enable profile hotness information in diagnostic line. This option controls whether Clang prints the profile hotness associated; with diagnostics in the presence of profile-guided optimization information.; This is currently supported with optimization remarks (see; :ref:`Options to Emit Optimization Reports <rpass>`). The hotness information; allows users to focus on the hot optimization remarks that are likely to be; more relevant for run-time performance. For example, in this output, the block containing the callsite of `foo` was; executed 3000 times according to the profile data:. ::. s.c:7:10: remark: foo inlined into bar (hotness: 3000) [-Rpass-analysis=inline]; sum += foo(x, x - 2);; ^. This option is implied when; :ref:`-fsave-optimization-record <opt_fsave-optimization-record>` is used.; Otherwise, it defaults to off. .. option:: -fdiagnostics-hotness-threshold. Prevent optimization remarks from being output if they do not have at least; this hotness value. This option, which defaults to zero, controls the minimum hotness an; optimization remark would need in order to be output by Clang. This is; current",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:13985,guid,guided,13985,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['guid'],['guided']
Usability,"cher<Decl>classTemplateSpecializationDeclMatcher<ClassTemplateSpecializationDecl>...; Matches C++ class template specializations. Given; template<typename T> class A {};; template<> class A<double> {};; A<int> a;; classTemplateSpecializationDecl(); matches the specializations A<int> and A<double>. Matcher<Decl>conceptDeclMatcher<ConceptDecl>...; Matches concept declarations. Example matches integral; template<typename T>; concept integral = std::is_integral_v<T>;. Matcher<Decl>cxxConstructorDeclMatcher<CXXConstructorDecl>...; Matches C++ constructor declarations. Example matches Foo::Foo() and Foo::Foo(int); class Foo {; public:; Foo();; Foo(int);; int DoSomething();; };. Matcher<Decl>cxxConversionDeclMatcher<CXXConversionDecl>...; Matches conversion operator declarations. Example matches the operator.; class X { operator int() const; };. Matcher<Decl>cxxDeductionGuideDeclMatcher<CXXDeductionGuideDecl>...; Matches user-defined and implicitly generated deduction guide. Example matches the deduction guide.; template<typename T>; class X { X(int) };; X(int) -> X<int>;. Matcher<Decl>cxxDestructorDeclMatcher<CXXDestructorDecl>...; Matches explicit C++ destructor declarations. Example matches Foo::~Foo(); class Foo {; public:; virtual ~Foo();; };. Matcher<Decl>cxxMethodDeclMatcher<CXXMethodDecl>...; Matches method declarations. Example matches y; class X { void y(); };. Matcher<Decl>cxxRecordDeclMatcher<CXXRecordDecl>...; Matches C++ class declarations. Example matches X, Z; class X;; template<class T> class Z {};. Matcher<Decl>declMatcher<Decl>...; Matches declarations. Examples matches X, C, and the friend declaration inside C;; void X();; class C {; friend X;; };. Matcher<Decl>declaratorDeclMatcher<DeclaratorDecl>...; Matches declarator declarations (field, variable, function; and non-type template parameter declarations). Given; class X { int y; };; declaratorDecl(); matches int y. Matcher<Decl>decompositionDeclMatcher<DecompositionDecl>...; Matches decomposition-decla",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:11615,guid,guide,11615,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['guid'],['guide']
Usability,"cility environment; --------------------------------------------------. The Virtual Analysis Facility client is a wrapper around commands sent; to the remote host by means of PROOF on Demand's `pod-remote`. The VAF; client takes care of setting up passwordless SSH from your client node; to the VAF master. ### Getting the credentials. > You can skip this paragraph if the remote server wasn't configured for; > HTTPS+SSH authentication. In our example we will assume that the remote server's name is; `cloud-gw-213.to.infn.it`: substitute it with your remote endpoint. First, check that you have your Grid certificate and private key; installed both in your browser and in the home directory of your; client. Point your browser to `https://cloud-gw-213.to.infn.it/auth/`: you'll; probably be asked for a certificate to choose for authentication. Pick; one and you'll be presented with the following web page:. ![Web authentication with sshcertauth](img/sshcertauth-web.png). The webpage clearly explains you what to do next. ### Customizing user's configuration. Before entering the VAF environment, you should customize the user's; configuration. How to do so depends on your experiment, but usually you; should essentially specify the version of the experiment's software you; need. For instance, in the CMS use case, only one file is needed:; `~/.vaf/common.before`, which contains something like:. ``` {.bash}; # Version of CMSSW (as reported by ""scram list""); export VafCmsswVersion='CMSSW_5_3_9_sherpa2beta2'; ```. ### Entering the VAF environment. Open a terminal on your client machine (can be either your local; computer or a remote user interface) and type:. vaf-enter <username>@cloud-gw-213.to.infn.it. You'll substitute `<username>` with the username that either your system; administrator or the web authentication (if you used it) provided you. You'll be presented with a neat shell which looks like the following:. Entering VAF environment: dberzano@cloud-gw-213.to.infn.it; Remember",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/UsingVirtualAnalysisFacility.md:9124,clear,clearly,9124,proof/doc/confman/UsingVirtualAnalysisFacility.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/UsingVirtualAnalysisFacility.md,1,['clear'],['clearly']
Usability,"cipate in the project using GitHub. Branches; ========. It is possible to create branches that starts with `users/<username>/`, however this is; intended to be able to support ""stacked"" pull-request. Do not create any branches in the; llvm/llvm-project repository otherwise, please use a fork (see below). User branches that; aren't associated with a pull-request **will be deleted**. Pull Requests; =============; The LLVM project is using GitHub Pull Requests for Code Reviews. This document; describes the typical workflow of creating a Pull Request and getting it reviewed; and accepted. This is meant as an overview of the GitHub workflow, for complete; documentation refer to `GitHub's documentation <https://docs.github.com/pull-requests>`_. GitHub Tools; ------------; You can interact with GitHub in several ways: via git command line tools,; the web browser, `GitHub Desktop <https://desktop.github.com/>`_, or the; `GitHub CLI <https://cli.github.com>`_. This guide will cover the git command line; tools and the GitHub CLI. The GitHub CLI (`gh`) will be most like the `arc` workflow and; recommended. Creating Pull Requests; ----------------------; Keep in mind that when creating a pull request, it should generally only contain one; self-contained commit initially.; This makes it easier for reviewers to understand the introduced changes and; provide feedback. It also helps maintain a clear and organized commit history; for the project. If you have multiple changes you want to introduce, it's; recommended to create separate pull requests for each change. Create a local branch per commit you want to submit and then push that branch; to your `fork <https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/working-with-forks>`_; of the llvm-project and; `create a pull request from the fork <https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/creating-a-pull-request-from-a-fork>`_.; As GitH",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GitHub.rst:1474,guid,guide,1474,interpreter/llvm-project/llvm/docs/GitHub.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GitHub.rst,1,['guid'],['guide']
Usability,"ck.C.`. ``` {.cpp}; {; THStack hs(""hs"",""test stacked histograms"");; TH1F *h1 = new TH1F(""h1"",""test hstack"",100,-4,4);; h1->FillRandom(""gaus"",20000);; h1->SetFillColor(kRed);; hs.Add(h1);; TH1F *h2 = new TH1F(""h2"",""test hstack"",100,-4,4);; h2->FillRandom(""gaus"",15000);; h2->SetFillColor(kBlue);; hs.Add(h2);; TH1F *h3 = new TH1F(""h3"",""test hstack"",100,-4,4);; h3->FillRandom(""gaus"",10000);; h3->SetFillColor(kGreen);; hs.Add(h3);; TCanvas c1(""c1"",""stacked hists"",10,10,700,900);; c1.Divide (1,2);; c1.cd(1);; hs.Draw();; c1.cd(2);; hs->Draw(""nostack"");; }; ```. ## TH2Poly. `TH2Poly` is a 2D Histogram class allowing to define polygonal bins of; arbitrary shape. Each bin in the `TH2Poly` histogram is a `TH2PolyBin` object.; `TH2PolyBin` is a very simple class containing the vertices and; contents of the polygonal bin as well as several related functions. Bins are defined using one of the `AddBin()` methods. The bin; definition should be done before filling. The following very simple macro shows how to build and fill a; `TH2Poly`:. ``` {.cpp}; {; TH2Poly *h2p = new TH2Poly();; Double_t x1[] = {0, 5, 5};; Double_t y1[] = {0, 0, 5};; Double_t x2[] = {0, -1, -1, 0};; Double_t y2[] = {0, 0, -1, -1};; Double_t x3[] = {4, 3, 0, 1, 2.4};; Double_t y3[] = {4, 3.7, 1, 4.7, 3.5};; h2p->AddBin(3, x1, y1);; h2p->AddBin(3, x2, y2);; h2p->AddBin(3, x3, y3);; h2p->Fill( 3, 1, 3); // fill bin 1; h2p->Fill(-0.5, -0.5, 7); // fill bin 2; h2p->Fill(-0.7, -0.5, 1); // fill bin 2; h2p->Fill( 1, 3, 5); // fill bin 3; }; ```. More examples can bin found in `$ROOTSYS/tutorials/hist/th2poly*.C`. ![A TH2Poly histogram example](pictures/th2poly1.png). ## Profile Histograms. Profile histograms are in many cases an elegant replacement of; two-dimensional histograms. The relationship of two quantities X and Y; can be visualized by a two-dimensional histogram or a scatter-plot;; its representation is not particularly satisfactory, except for sparse; data. If Y is an unknown [but single-valued] function of ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:60652,simpl,simple,60652,documentation/users-guide/Histograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md,1,['simpl'],['simple']
Usability,"ckstartTemplate.md`. You; should copy it, open the new file in your text editor, write your docs, and; then send the new document to llvm-commits for review. Focus on *content*. It is easy to fix the Markdown syntax; later if necessary, although Markdown tries to imitate common; plain-text conventions so it should be quite natural. A basic knowledge of; Markdown syntax is useful when writing the document, so the last; ~half of this document (starting with [Example Section](#example-section)) gives examples; which should cover 99% of use cases. Let me say that again: focus on *content*. But if you really need to verify; Sphinx's output, see `docs/README.txt` for information. Once you have finished with the content, please send the `.md` file to; llvm-commits for review. ## Guidelines. Try to answer the following questions in your first section:. 1. Why would I want to read this document?. 2. What should I know to be able to follow along with this document?. 3. What will I have learned by the end of this document?. Common names for the first section are `Introduction`, `Overview`, or; `Background`. If possible, make your document a ""how to"". Give it a name `HowTo*.md`; like the other ""how to"" documents. This format is usually the easiest; for another person to understand and also the most useful. You generally should not be writing documentation other than a ""how to""; unless there is already a ""how to"" about your topic. The reason for this; is that without a ""how to"" document to read first, it is difficult for a; person to understand a more advanced document. Focus on content (yes, I had to say it again). The rest of this document shows example Markdown markup constructs; that are meant to be read by you in your text editor after you have copied; this file into a new file for the documentation you are about to write. ## Example Section. Your text can be *emphasized*, **bold**, or `monospace`. Use blank lines to separate paragraphs. Headings (like `Example Section` just",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MarkdownQuickstartTemplate.md:1445,learn,learned,1445,interpreter/llvm-project/llvm/docs/MarkdownQuickstartTemplate.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MarkdownQuickstartTemplate.md,1,['learn'],['learned']
Usability,"class is the parent of the **`TCanvas`**; class. In ROOT, most objects derive from a base class **`TObject`**.; This class has a virtual method `Draw()` such as all objects are; supposed to be able to be ""drawn"". If several canvases are defined,; there is only one active at a time. One draws an object in the active; canvas by using the statement:. ``` {.cpp}; object.Draw(); ```. This instructs the object ""`object`"" to draw itself. If no canvas is; opened, a default one (named ""`c1`"") is created. In the next example,; the first statement defines a function and the second one draws it. A; default canvas is created since there was no opened one. You should; see the picture as shown in the next figure. ``` {.cpp}; root[] TF1 f1(""func1"",""sin(x)/x"",0,10); root[] f1.Draw(); <TCanvas::MakeDefCanvas>: created default TCanvas with name c1; ```. ![A canvas with drawing](pictures/0300000A.png). The following components comprise the canvas window:. - Menu bar - contains main menus for global operations with files,; print, clear canvas, inspect, etc. - Tool bar - has buttons for global and drawing operations; such as; arrow, ellipse, latex, pad, etc. - Canvas - an area to draw objects. - Status bar - displays descriptive messages about the selected; object. - Editor frame - responds dynamically and presents the user; interface according to the selected object in the canvas. ### Main Menus and Toolbar. At the top of the canvas window are File, Edit, View, Options,; Inspect, Classes and Help menus. #### File Menu. - *New Canvas*: creates a new canvas window in the current ROOT; session. - *Open...*: popup a dialog to open a file. - *Close Canvas*: close the canvas window. - *Save*: save the drawing of the current canvas in a format; selectable from the submenu. The current canvas name is used as a; file name for various formats such as PostScript, GIF, JPEG, C; macro file, root file. - *Save As...*: popup a dialog for saving the current canvas drawing; in a new filename. - *Print*: ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:7069,clear,clear,7069,documentation/users-guide/GettingStarted.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md,1,['clear'],['clear']
Usability,"class templates; Unknown. 1006; C++11; std::nullptr_t as a non-type template parameter; Unknown. 1007; NAD; Protected access and pointers to members; Unknown. 1008; NAD; Querying the alignment of an object; Unknown. 1009; C++11; Missing cases in the declarator-id of a function template declaration; Unknown. 1010; CD2; Address of object with dynamic storage duration in constant expression; Unknown. 1011; C++11; Standard conversions that cannot be inverted; Unknown. 1012; C++11; Undeprecating static; Unknown. 1013; CD3; Uninitialized std::nullptr_t objects; Unknown. 1014; NAD; Overload resolution between const T& and T&&; Unknown. 1015; C++11; Template arguments and argument-dependent lookup; Unknown. 1016; C++11; Overloadable declarations, function templates, and references; Unknown. 1017; C++11; Member access transformation in unevaluated operands; Unknown. 1018; C++11; Ambiguity between simple-declaration and attribute-declaration; Unknown. 1019; dup; Dependent simple-template-ids in base-specifiers and mem-initializers; Unknown. 1020; C++11; Implicitly-defined copy constructors and explicit base class constructors; Unknown. 1021; CD4; Definitions of namespace members; Unknown. 1022; C++11; Can an enumeration variable have values outside the values of the enumeration?; Unknown. 1023; dup; thread_local objects as non-type template arguments; Unknown. 1024; CD3; Limits on multicharacter literals; Unknown. 1025; C++11; Use of a reference as a non-type template argument; Unknown. 1026; NAD; Cv-qualified non-class rvalues; Unknown. 1027; review; Type consistency and reallocation of scalar types; Not resolved. 1028; CD6; Dependent names in non-defining declarations; Unknown. 1029; C++11; Type of a destructor call; Unknown. 1030; C++11; Evaluation order in initializer-lists used in aggregate initialization; Unknown. 1031; C++11; Optional elements in attributes; Unknown. 1032; C++11; Empty pack expansions; Unknown. 1033; C++11; Restrictions on alignment attributes; Unknown.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:67210,simpl,simple-template-ids,67210,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['simpl'],['simple-template-ids']
Usability,"cleanuppad``. New instructions are also used to mark the points where control is transferred; out of a catch/cleanup handler (which will correspond to exits from the; generated funclet). A catch handler which reaches its end by normal execution; executes a ``catchret`` instruction, which is a terminator indicating where in; the function control is returned to. A cleanup handler which reaches its end; by normal execution executes a ``cleanupret`` instruction, which is a terminator; indicating where the active exception will unwind to next. Each of these new EH pad instructions has a way to identify which action should; be considered after this action. The ``catchswitch`` instruction is a terminator; and has an unwind destination operand analogous to the unwind destination of an; invoke. The ``cleanuppad`` instruction is not; a terminator, so the unwind destination is stored on the ``cleanupret``; instruction instead. Successfully executing a catch handler should resume; normal control flow, so neither ``catchpad`` nor ``catchret`` instructions can; unwind. All of these ""unwind edges"" may refer to a basic block that contains an; EH pad instruction, or they may unwind to the caller. Unwinding to the caller; has roughly the same semantics as the ``resume`` instruction in the landingpad; model. When inlining through an invoke, instructions that unwind to the caller; are hooked up to unwind to the unwind destination of the call site. Putting things together, here is a hypothetical lowering of some C++ that uses; all of the new IR instructions:. .. code-block:: c. struct Cleanup {; Cleanup();; ~Cleanup();; int m;; };; void may_throw();; int f() noexcept {; try {; Cleanup obj;; may_throw();; } catch (int e) {; may_throw();; return e;; }; return 0;; }. .. code-block:: text. define i32 @f() nounwind personality ptr @__CxxFrameHandler3 {; entry:; %obj = alloca %struct.Cleanup, align 4; %e = alloca i32, align 4; %call = invoke ptr @""??0Cleanup@@QEAA@XZ""(ptr nonnull %obj); to la",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ExceptionHandling.rst:27083,resume,resume,27083,interpreter/llvm-project/llvm/docs/ExceptionHandling.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ExceptionHandling.rst,1,['resume'],['resume']
Usability,"codes can be found at; :doc:`GenericOpcode`. The ``MachineIRBuilder`` class wraps the ``MachineInstrBuilder`` and provides; a convenient way to create these generic instructions. .. _gmir-gvregs:. Generic Virtual Registers; -------------------------. .. note::. This section expands on :ref:`mir-registers` from the MIR Language; Reference. Generic virtual registers are like virtual registers but they are not assigned a; Register Class constraint. Instead, generic virtual registers have less strict; constraints starting with a :ref:`gmir-llt` and then further constrained to a; :ref:`gmir-regbank`. Eventually they will be constrained to a register class; at which point they become normal virtual registers. Generic virtual registers can be used with all the virtual register API's; provided by ``MachineRegisterInfo``. In particular, the def-use chain API's can; be used without needing to distinguish them from non-generic virtual registers. For simplicity, most generic instructions only accept virtual registers (both; generic and non-generic). There are some exceptions to this but in general:. * instead of immediates, they use a generic virtual register defined by an; instruction that materializes the immediate value (see; :ref:`irtranslator-constants`). Typically this is a G_CONSTANT or a; G_FCONSTANT. One example of an exception to this rule is G_SEXT_INREG where; having an immediate is mandatory.; * instead of physical register, they use a generic virtual register that is; either defined by a ``COPY`` from the physical register or used by a ``COPY``; that defines the physical register. .. admonition:: Historical Note. We started with an alternative representation, where MRI tracks a size for; each generic virtual register, and instructions have lists of types.; That had two flaws: the type and size are redundant, and there was no generic; way of getting a given operand's type (as there was no 1:1 mapping between; instruction types and operands).; We considered putting t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GlobalISel/GMIR.rst:2087,simpl,simplicity,2087,interpreter/llvm-project/llvm/docs/GlobalISel/GMIR.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GlobalISel/GMIR.rst,1,['simpl'],['simplicity']
Usability,"color component, hsv smooth; // algorithm, hsv modulo color component, it does not apply for simple; // display modes algorithm group [15]; float l_h_weight; // weight between shading according to fictive light source and; // according to channels counts, applies only for; // PICTURE2_MODE_GROUP_LIGHT_HEIGHT modes group; int xlight; // x position of fictive light source, applies only for rainbowed display; // modes with shading according to light; int ylight; // y position of fictive light source, applies only for rainbowed display; // modes with shading according to light; int zlight; // z position of fictive light source, applies only for rainbowed display; // modes with shading according to light; int shadow; // determines whether shadow will be drawn (no shadow, shadow),; // for rainbowed display modes with shading according to light; int shading; // determines whether the picture will shaded, smoothed (no shading,; // shading), for rainbowed display modes only; int bezier; // determines Bezier interpolation (applies only for simple display; // modes group for grid, x_lines, y_lines display modes); int border_color; // color of background of the picture; int full_border; // decides whether background is painted; int raster_en_dis; // decides whether the rasters are shown; int raster_long; // decides whether the rasters are drawn as long lines; int raster_color; // color of the rasters; char *raster_description_x; // x axis description; char *raster_description_y; // y axis description; char *raster_description_z; // z axis description; int pen_color; // color of spectrum; int pen_dash; // style of pen; int pen_width; // width of line; int chanmark_en_dis; // decides whether the channel marks are shown; int chanmark_style; // style of channel marks; int chanmark_width; // width of channel marks; int chanmark_height; // height of channel marks; int chanmark_color; // color of channel marks; int chanline_en_dis; // decides whether the channel lines (grid) are shown.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:79327,simpl,simple,79327,documentation/spectrum/Spectrum.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md,1,['simpl'],['simple']
Usability,com/civetweb/civetweb/issues/812)). Trouble tickets should be filed on GitHub; [https://github.com/civetweb/civetweb/issues](https://github.com/civetweb/civetweb/issues). New releases are announced at Google Groups; [https://groups.google.com/d/forum/civetweb](https://groups.google.com/d/forum/civetweb). Formerly some support question and discussion threads have been at [Google groups](https://groups.google.com/d/forum/civetweb).; Recent questions and discussions use [GitHub issues](https://github.com/civetweb/civetweb/issues). Source releases can be found on GitHub; [https://github.com/civetweb/civetweb/releases](https://github.com/civetweb/civetweb/releases). A very brief overview can be found on GitHub Pages; [http://civetweb.github.io/civetweb/](http://civetweb.github.io/civetweb/). Getting The Source; ------------------; Download the source code by running the following code in your command prompt:. $ git clone https://github.com/civetweb/civetweb.git; or simply grab a copy of the source code as a ZIP or TGZ file. Quick start documentation; --------------------------. - [docs/Installing.md](https://github.com/civetweb/civetweb/blob/master/docs/Installing.md) - Install Guide (for end users using pre-built binaries); - [docs/UserManual.md](https://github.com/civetweb/civetweb/blob/master/docs/UserManual.md) - End User Guide; - [docs/Building.md](https://github.com/civetweb/civetweb/blob/master/docs/Building.md) - Building the Server (quick start guide); - [docs/Embedding.md](https://github.com/civetweb/civetweb/blob/master/docs/Embedding.md) - Embedding (how to add HTTP support to an existing application); - [docs/OpenSSL.md](https://github.com/civetweb/civetweb/blob/master/docs/OpenSSL.md) - Adding HTTPS (SSL/TLS) support using OpenSSL.; - [API documentation](https://github.com/civetweb/civetweb/tree/master/docs/api) - Additional documentation on the civetweb application programming interface ([civetweb.h](https://github.com/civetweb/civetweb/blob/master/include/,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/README.md:3808,simpl,simply,3808,net/http/civetweb/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/README.md,1,['simpl'],['simply']
Usability,"com/llvm/llvm-project/issues/47355>`_; - Fixed a bug where Template Instantiation failed to handle Lambda Expressions; with certain types of Attributes.; (`#76521 <https://github.com/llvm/llvm-project/issues/76521>`_). Miscellaneous Bug Fixes; ^^^^^^^^^^^^^^^^^^^^^^^. Miscellaneous Clang Crashes Fixed; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; - Fixed a crash when parsing top-level ObjC blocks that aren't properly; terminated. Clang should now also recover better when an @end is missing; between blocks.; `Issue 64065 <https://github.com/llvm/llvm-project/issues/64065>`_; - Fixed a crash when check array access on zero-length element.; `Issue 64564 <https://github.com/llvm/llvm-project/issues/64564>`_; - Fixed a crash when an ObjC ivar has an invalid type. See; (`#68001 <https://github.com/llvm/llvm-project/pull/68001>`_); - Fixed a crash in C when redefined struct is another nested redefinition.; `Issue 41302 <https://github.com/llvm/llvm-project/issues/41302>`_; - Fixed a crash when ``-ast-dump=json`` was used for code using class; template deduction guides.; - Fixed a crash when a lambda marked as ``static`` referenced a captured; variable in an expression.; `Issue 74608 <https://github.com/llvm/llvm-project/issues/74608>`_; - Fixed a crash with modules and a ``constexpr`` destructor.; `Issue 68702 <https://github.com/llvm/llvm-project/issues/68702>`_. OpenACC Specific Changes; ------------------------; - OpenACC Implementation effort is beginning with semantic analysis and parsing; of OpenACC pragmas. The ``-fopenacc`` flag was added to enable these new,; albeit incomplete changes. The ``_OPENACC`` macro is currently defined to; ``1``, as support is too incomplete to update to a standards-required value.; - Added ``-fexperimental-openacc-macro-override``, a command line option to; permit overriding the ``_OPENACC`` macro to be any digit-only value specified; by the user, which permits testing the compiler against existing OpenACC; workloads in order to evaluate implemen",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:58164,guid,guides,58164,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst,1,['guid'],['guides']
Usability,"completion of a send of ``release`` that is not; preceded by a send of ``retain`` to the same object. The behavior of ``autorelease`` must be equivalent to sending ``release`` when; one of the autorelease pools currently in scope is popped. It may not throw an; exception. When the semantics call for performing one of these operations on a retainable; object pointer, if that pointer is ``null`` then the effect is a no-op. All of the semantics described in this document are subject to additional; :ref:`optimization rules <arc.optimization>` which permit the removal or; optimization of operations based on local knowledge of data flow. The; semantics describe the high-level behaviors that the compiler implements, not; an exact sequence of operations that a program will be compiled into. .. _arc.objects.operands:. Retainable object pointers as operands and arguments; ----------------------------------------------------. In general, ARC does not perform retain or release operations when simply using; a retainable object pointer as an operand within an expression. This includes:. * loading a retainable pointer from an object with non-weak :ref:`ownership; <arc.ownership>`,; * passing a retainable pointer as an argument to a function or method, and; * receiving a retainable pointer as the result of a function or method call. .. admonition:: Rationale. While this might seem uncontroversial, it is actually unsafe when multiple; expressions are evaluated in ""parallel"", as with binary operators and calls,; because (for example) one expression might load from an object while another; writes to it. However, C and C++ already call this undefined behavior; because the evaluations are unsequenced, and ARC simply exploits that here to; avoid needing to retain arguments across a large number of calls. The remainder of this section describes exceptions to these rules, how those; exceptions are detected, and what those exceptions imply semantically. .. _arc.objects.operands.consumed:. Co",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:15556,simpl,simply,15556,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['simpl'],['simply']
Usability,"consistency; ^^^^^^^^^^^^^^^^^^^^^^^. The C++ language defines that same declarations in different translation units should have; the same definition, as known as ODR (One Definition Rule). Prior to modules, the translation; units don't dependent on each other and the compiler itself can't perform a strong; ODR violation check. With the introduction of modules, now the compiler have; the chance to perform ODR violations with language semantics across translation units. However, in the practice, we found the existing ODR checking mechanism is not stable; enough. Many people suffers from the false positive ODR violation diagnostics, AKA,; the compiler are complaining two identical declarations have different definitions; incorrectly. Also the true positive ODR violations are rarely reported.; Also we learned that MSVC don't perform ODR check for declarations in the global module; fragment. So in order to get better user experience, save the time checking ODR and keep consistent; behavior with MSVC, we disabled the ODR check for the declarations in the global module; fragment by default. Users who want more strict check can still use the; ``-Xclang -fno-skip-odr-check-in-gmf`` flag to get the ODR check enabled. It is also; encouraged to report issues if users find false positive ODR violations or false negative ODR; violations with the flag enabled. ABI Impacts; -----------. The declarations in a module unit which are not in the global module fragment have new linkage names. For example,. .. code-block:: c++. export module M;; namespace NS {; export int foo();; }. The linkage name of ``NS::foo()`` would be ``_ZN2NSW1M3fooEv``.; This couldn't be demangled by previous versions of the debugger or demangler.; As of LLVM 15.x, users can utilize ``llvm-cxxfilt`` to demangle this:. .. code-block:: console. $ llvm-cxxfilt _ZN2NSW1M3fooEv. The result would be ``NS::foo@M()``, which reads as ``NS::foo()`` in module ``M``. The ABI implies that we can't declare something in a modul",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:17866,user experience,user experience,17866,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,1,['user experience'],['user experience']
Usability,"constraint in the constraint list must have the same number of alternative; sets. With this syntax, the same alternative in *all* of the items in the; constraint list will be chosen together. Putting those together, you might have a two operand constraint string like; ``""rm|r,ri|rm""``. This indicates that if operand 0 is ``r`` or ``m``, then; operand 1 may be one of ``r`` or ``i``. If operand 0 is ``r``, then operand 1; may be one of ``r`` or ``m``. But, operand 0 and 1 cannot both be of type m. However, the use of either of the alternatives features is *NOT* recommended, as; LLVM is not able to make an intelligent choice about which one to use. (At the; point it currently needs to choose, not enough information is available to do so; in a smart way.) Thus, it simply tries to make a choice that's most likely to; compile, not one that will be optimal performance. (e.g., given ""``rm``"", it'll; always choose to use memory, not registers). And, if given multiple registers,; or multiple register classes, it will simply choose the first one. (In fact, it; doesn't currently even ensure explicitly specified physical registers are; unique, so specifying multiple physical registers as alternatives, like; ``{r11}{r12},{r11}{r12}``, will assign r11 to both operands, not at all what was; intended.). Supported Constraint Code List; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""". The constraint codes are, in general, expected to behave the same way they do in; GCC. LLVM's support is often implemented on an 'as-needed' basis, to support C; inline asm code which was supported by GCC. A mismatch in behavior between LLVM; and GCC likely indicates a bug in LLVM. Some constraint codes are typically supported by all targets:. - ``r``: A register in the target's general purpose register class.; - ``m``: A memory address operand. It is target-specific what addressing modes; are supported, typical examples are register, or register + register offset,; or register + immediate offset (of some target-specific",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:220095,simpl,simply,220095,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['simpl'],['simply']
Usability,"cope of this document: it is worth to mention; that I/O can be performed out of the box for the almost complete set; of ROOT classes. We can explore this functionality with histograms and two simple macros. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/write_to_file.C; ```. Not bad, eh ? Especially for a language that does not foresees; persistency natively like C++. The *RECREATE* option forces ROOT to; create a new file even if a file with the same name exists on disk. Now, you may use the Cling command line to access information in the file; and draw the previously written histogram:. ``` {.cpp}; > root my_rootfile.root; root [0]; Attaching file my_rootfile.root as _file0...; root [1] _file0->ls(); TFile** my_rootfile.root; TFile* my_rootfile.root; KEY: TH1F	my_histogram;1 My Title; root [2] my_histogram->Draw(); ```; \newpage; Alternatively, you can use a simple macro to carry out the job:. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/read_from_file.C; ```. ## N-tuples in ROOT ##. ### Storing simple N-tuples ###. Up to now we have seen how to manipulate input read from ASCII files.; ROOT offers the possibility to do much better than that, with its own; n-tuple classes. Among the many advantages provided by these classes one; could cite. - Optimised disk I/O. - Possibility to store many n-tuple rows. - Write the n-tuples in ROOT files. - Interactive inspection with `TBrowser`. - Store not only numbers, but also *objects* in the columns. In this section we will discuss briefly the `TNtuple` class, which is a; simplified version of the `TTree` class. A ROOT `TNtuple` object can; store rows of float entries. Let's tackle the problem according to the; usual strategy commenting a minimal example. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/write_ntuple_to_file.C; ```. This data written to this example n-tuple represents, in the statistical; sense, three independent variables (Potential or Voltage, Pressure and; Temperature), and one variable (Current) which depends on the others; according",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md:1514,simpl,simple,1514,documentation/primer/filio.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md,1,['simpl'],['simple']
Usability,"cppyy-backend; =============. C/C++ wrapper around Cling, the LLVM-based interactive C++ interpreter, for; use by cppyy, providing stable C and C++ Reflection APIs. The compilation of cppyy-backend is very fast, but it will pull in; cppyy-cling, which takes a long time to install if there is no matching wheel; for your platform, forcing a build from source. By default, all cores will be; used, but it is also recommended to add the verbose flag to see progress:. $ python -m pip install --verbose cppyy-backend. For further details, see cppyy's installation instructions:; https://cppyy.readthedocs.io/en/latest/installation.html. Cling documentation is here:; https://root.cern.ch/cling. ----. Find the cppyy documentation here:; http://cppyy.readthedocs.io. Change log:; https://cppyy.readthedocs.io/en/latest/changelog.html. Bug reports/feedback:; https://bitbucket.org/wlav/cppyy/issues?status=new&status=open; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy-backend/clingwrapper/README.rst:843,feedback,feedback,843,bindings/pyroot/cppyy/cppyy-backend/clingwrapper/README.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy-backend/clingwrapper/README.rst,1,['feedback'],['feedback']
Usability,"cppyy-cling; ===========. A repackaging of Cling, the LLVM-based interactive C++ interpreter, as a; library for use as the backend to cppyy. This version of Cling is patched for; improved performance and better use with Python. Wheels are available for the major platforms, but if you have to build from; source, building of LLVM will take a long time. By default, all cores will be; used, but it is also recommended to add the verbose flag to see progress:. $ python -m pip install --verbose cppyy-cling. For further details, see cppyy's installation instructions:; https://cppyy.readthedocs.io/en/latest/installation.html. Cling documentation is here:; https://root.cern.ch/cling. ----. Full cppyy documentation is here:; http://cppyy.readthedocs.io/. Change log:; https://cppyy.readthedocs.io/en/latest/changelog.html. Bug reports/feedback:; https://bitbucket.org/wlav/cppyy/issues?status=new&status=open; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy-backend/cling/README.rst:834,feedback,feedback,834,bindings/pyroot/cppyy/cppyy-backend/cling/README.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy-backend/cling/README.rst,1,['feedback'],['feedback']
Usability,"cppyy.bind_object(s, 'MyStruct'); >>> print(sobj); <cppyy.gbl.MyStruct object at 0x7ff25e28eb20>; >>> print(sobj.fInt); 42; >>>. Instead of the type name as a string, ``bind_object`` can also take the; actual class (here: ``cppyy.gbl.MyStruct``). * **Typed nullptr**: A Python side proxy can pass through a pointer to; pointer function argument, but if the C++ side allocates memory and; stores it in the pointer, the result is a memory leak.; In that case, use ``bind_object`` to bind ``cppyy.nullptr`` instead, to; get a typed nullptr to pass to the function.; Example (continuing from the example above):. .. code-block:: python. >>> cppyy.cppdef(""""""; ... void create_mystruct(MyStruct** ptr) { *ptr = new MyStruct{42}; }; ... """"""); ...; >>> s = cppyy.bind_object(cppyy.nullptr, 'MyStruct'); >>> print(s); <cppyy.gbl.MyStruct object at 0x0>; >>> cppyy.gbl.create_mystruct(s); >>> print(s); <cppyy.gbl.MyStruct object at 0x7fc7d85b91c0>; >>> print(s.fInt); 42; >>>. * **C-style cast**: This is the simplest option for builtin types.; The syntax is ""template-style"", example:. .. code-block:: python. >>> cppyy.cppdef(""""""; ... void* get_data(int sz) {; ... int* iptr = (int*)malloc(sizeof(int)*sz);; ... for (int i=0; i<sz; ++i) iptr[i] = i;; ... return iptr;; ... }""""""); ...; >>> NDATA = 4; >>> d = cppyy.gbl.get_data(NDATA); >>> print(d); <cppyy.LowLevelView object at 0x1068cba30>; >>> d = cppyy.ll.cast['int*'](d); >>> d.reshape((NDATA,)); >>> print(list(d)); [0, 1, 2, 3]; >>>. * **C++-style casts**: Similar to the C-style cast, there are; ``ll.static_cast`` and ``ll.reinterpret_cast``.; There should never be a reason for a ``dynamic_cast``, since that only; applies to objects, for which auto-casting will work.; The syntax is ""template-style"", just like for the C-style cast above. .. _npcasts:. `NumPy casts`; -------------. The ``cppyy.LowLevelView`` type returned for pointers to basic types,; including for ``void*``, is a simple and light-weight view on memory, given a; pointer, type,",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/lowlevel.rst:3660,simpl,simplest,3660,bindings/pyroot/cppyy/cppyy/doc/source/lowlevel.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/lowlevel.rst,1,['simpl'],['simplest']
Usability,"cribing vectorization; candidates. It serves for both optimizing candidates including estimating their; cost reliably, and for performing their final translation into IR. This; facilitates dealing with multiple vectorization candidates. High-level Design; =================. Vectorization Workflow; ----------------------; VPlan-based vectorization involves three major steps, taking a ""scenario-based; approach"" to vectorization planning:. 1. Legal Step: check if a loop can be legally vectorized; encode constraints and; artifacts if so.; 2. Plan Step:. a. Build initial VPlans following the constraints and decisions taken by; Legal Step 1, and compute their cost.; b. Apply optimizations to the VPlans, possibly forking additional VPlans.; Prune sub-optimal VPlans having relatively high cost.; 3. Execute Step: materialize the best VPlan. Note that this is the only step; that modifies the IR. Design Guidelines; -----------------; In what follows, the term ""input IR"" refers to code that is fed into the; vectorizer whereas the term ""output IR"" refers to code that is generated by the; vectorizer. The output IR contains code that has been vectorized or ""widened""; according to a loop Vectorization Factor (VF), and/or loop unroll-and-jammed; according to an Unroll Factor (UF).; The design of VPlan follows several high-level guidelines:. 1. Analysis-like: building and manipulating VPlans must not modify the input IR.; In particular, if the best option is not to vectorize at all, the; vectorization process terminates before reaching Step 3, and compilation; should proceed as if VPlans had not been built. 2. Align Cost & Execute: each VPlan must support both estimating the cost and; generating the output IR code, such that the cost estimation evaluates the; to-be-generated code reliably. 3. Support vectorizing additional constructs:. a. Outer-loop vectorization. In particular, VPlan must be able to model the; control-flow of the output IR which may include multiple basic-blocks and;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/VectorizationPlan.rst:1465,Guid,Guidelines,1465,interpreter/llvm-project/llvm/docs/VectorizationPlan.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/VectorizationPlan.rst,1,['Guid'],['Guidelines']
Usability,"ct the false alarm; rate? Currently, the analyzer only reasons about one procedure at a time (no; inter-procedural analysis). Also, it uses a simple range tracking based; solver to model symbolic execution.; Consult the GitHub Issues; to get some ideas for new checkers and consider starting with improving/fixing; bugs in the existing checkers. Once an idea for a checker has been chosen, there are two key decisions that; need to be made:; ; Which events the checker should be tracking. This is discussed in more; detail in the section Events, Callbacks, and; Checker Class Structure.; What checker-specific data needs to be stored as part of the program; state (if any). This should be minimized as much as possible. More detail about; implementing custom program state is given in section Custom Program States.; ; Checker Registration; All checker implementation files are located in; clang/lib/StaticAnalyzer/Checkers folder. The steps below describe; how the checker SimpleStreamChecker, which checks for misuses of; stream APIs, was registered with the analyzer.; Similar steps should be followed for a new checker. A new checker implementation file, SimpleStreamChecker.cpp, was; created in the directory lib/StaticAnalyzer/Checkers.; The following registration code was added to the implementation file:. void ento::registerSimpleStreamChecker(CheckerManager &mgr) {; mgr.registerChecker<SimpleStreamChecker>();; }. A package was selected for the checker and the checker was defined in the; table of checkers at include/clang/StaticAnalyzer/Checkers/Checkers.td.; Since all checkers should first be developed as ""alpha"", and the SimpleStreamChecker; performs UNIX API checks, the correct package is ""alpha.unix"", and the following; was added to the corresponding UnixAlpha section of Checkers.td:. let ParentPackage = UnixAlpha in {; ...; def SimpleStreamChecker : Checker<""SimpleStream"">,; HelpText<""Check for misuses of stream APIs"">,; DescFile<""SimpleStreamChecker.cpp"">;; ...; } // end """,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/checker_dev_manual.html:8718,Simpl,SimpleStreamChecker,8718,interpreter/llvm-project/clang/www/analyzer/checker_dev_manual.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/checker_dev_manual.html,1,['Simpl'],['SimpleStreamChecker']
Usability,"ct::Paint()`**. #### Physical IDs. TVirtualViewer3D provides for two methods of object addition:. ``` {.cpp}; virtual Int_t AddObject(const TBuffer3D &buffer,; Bool_t * addChildren = 0); virtual Int_t AddObject(UInt_t physicalID,; const TBuffer3D & buffer,; Bool_t *addChildren = 0); ```. If you use the first (simple) case a viewer using logical/physical pairs; will generate sequential IDs for each physical object internally. Scene; rebuilds will require destruction and recreation of all physical; objects. For the second you can specify an identifier from the client; side, which must be unique and stable - i.e. the IDs of a published; object is consistent, regardless of changes in termination of contained; child geometry branches. In this case the viewer can safely cache the; physical objects across scene rebuilds, discarding those no longer of; interest. #### Child Objects. In many geometries there is a rigid containment hierarchy, and so if the; viewer is not interested in a certain object due to limits/size then it; will also not be interest in any of the contained branch of siblings.; Both `TBuffer3D::AddObject()` methods have an `addChildren` return; parameter. The viewer will complete this (if passed) indicating if; children of the object just sent are worth sending. #### Recycling TBuffer3D. Once add `TBuffer3D::AddObject()` has been called, the contents are; copied to the viewer's internal data structures. You are free to destroy; this **`TBuffer3D`**, or recycle it for the next object if suitable. #### Examples. For an example of a simple geometry, working in master reference frame; examine the code under `$ROOTSYS/g3d`. For a more complex example, which; works in both master and local frames, and uses logical`/`physical; division of shape geometry and placement, examine the code under; `$ROOTSYS/geom` - in particular **`TGeoShape`** hierarchy, and the; painter object **`TGeoPainter`** (under geopainter) where the; negotiation with the viewer is performed.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:139086,simpl,simple,139086,documentation/users-guide/Graphics.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md,1,['simpl'],['simple']
Usability,"ction and any load of the; pointer. The ``-gvn``, ``-memcpyopt``, and ``-dse`` passes; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. These passes use AliasAnalysis information to reason about loads and stores. .. _the clients:. Clients for debugging and evaluation of implementations; -------------------------------------------------------. These passes are useful for evaluating the various alias analysis; implementations. You can use them with commands like:. .. code-block:: bash. % opt -ds-aa -aa-eval foo.bc -disable-output -stats. The ``-print-alias-sets`` pass; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``-print-alias-sets`` pass is exposed as part of the ``opt`` tool to print; out the Alias Sets formed by the `AliasSetTracker`_ class. This is useful if; you're using the ``AliasSetTracker`` class. To use it, use something like:. .. code-block:: bash. % opt -ds-aa -print-alias-sets -disable-output. The ``-aa-eval`` pass; ^^^^^^^^^^^^^^^^^^^^^. The ``-aa-eval`` pass simply iterates through all pairs of pointers in a; function and asks an alias analysis whether or not the pointers alias. This; gives an indication of the precision of the alias analysis. Statistics are; printed indicating the percent of no/may/must aliases found (a more precise; algorithm will have a lower number of may aliases). Memory Dependence Analysis; ==========================. .. note::. We are currently in the process of migrating things from; ``MemoryDependenceAnalysis`` to :doc:`MemorySSA`. Please try to use; that instead. If you're just looking to be a client of alias analysis information, consider; using the Memory Dependence Analysis interface instead. MemDep is a lazy,; caching layer on top of alias analysis that is able to answer the question of; what preceding memory operations a given instruction depends on, either at an; intra- or inter-block level. Because of its laziness and caching policy, using; MemDep can be a significant performance win over accessing alias analysis; directly.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:29603,simpl,simply,29603,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,1,['simpl'],['simply']
Usability,"ction given in the beginning. We can now; use all methods of the `TF1` class to control the behaviour of our; function -- nice, isn't it ?. If you like, you can easily extend the example to also plot the; interference pattern of a single slit, using function `double single`,; or of a grid with narrow slits, function `double nslit0`, in `TF1`; instances. Here, we used a macro, some sort of lightweight program, that the; interpreter distributed with ROOT, Cling, is able to execute. This is a; rather extraordinary situation, since `C++` is not natively an interpreted; language! There is much more to say: chapter is indeed dedicated to; macros. ## Controlling ROOT ##. One more remark at this point: as every command you type into ROOT is; usually interpreted by Cling, an ""escape character"" is needed to pass; commands to ROOT directly. This character is the dot at the beginning of; a line:. ``` {.cpp}; root [1] .<command>; ```. This is a selection of the most common commands. - **quit root**, simply type `.q` or `.quit` or `.exit`. - obtain the full **list of commands**, use `.?` or `.help`. - **access the shell** of the operating system, type `.!<OS_command>`;; try, e.g. `.!ls` or `.!pwd`. - **execute a macro**, enter `.x <file_name>`; in the above example,; you might have used `.x slits.C` at the ROOT prompt. - **load a macro**, type `.L <file_name>`; in the above example, you; might instead have used the command `.L slits.C` followed by the; function call `slits();`. Note that after loading a macro all; functions and procedures defined therein are available at the ROOT; prompt. - **compile a macro**, type `.L <file_name>+`; ROOT is able to manage; for you the `C++` compiler behind the scenes and to produce machine; code starting from your macro. One could decide to compile a macro; in order to obtain better performance or to get nearer to the; production environment. ## Plotting Measurements ##. To display measurements in ROOT, including errors, there exists a; powerfu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md:7897,simpl,simply,7897,documentation/primer/ROOT_as_calculator.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md,1,['simpl'],['simply']
Usability,"ction is currently implemented in the `ELF_x86_64.cpp`; file, and tied to the x86-64 relocation parsing code. The bulk of the code is; generic and should be split into an ELFLinkGraphBuilder base class along the; same lines as the existing generic MachOLinkGraphBuilder. * Implement support for arm32. * Implement support for other new architectures. JITLink Availability and Feature Status; ---------------------------------------. The following table describes the status of the JITlink backends for various; format / architecture combinations (as of July 2023). Support levels:. * None: No backend. JITLink will return an ""architecture not supported"" error.; Represented by empty cells in the table below.; * Skeleton: A backend exists, but does not support commonly used relocations.; Even simple programs are likely to trigger an ""unsupported relocation"" error.; Backends in this state may be easy to improve by implementing new relocations.; Consider getting involved!; * Basic: The backend supports simple programs, isn't ready for general use yet.; * Usable: The backend is useable for general use for at least one code and; relocation model.; * Good: The backend supports almost all relocations. Advanced features like; native thread local storage may not be available yet.; * Complete: The backend supports all relocations and object format features. .. list-table:: Availability and Status; :widths: 10 30 30 30; :header-rows: 1; :stub-columns: 1. * - Architecture; - ELF; - COFF; - MachO; * - arm32; - Skeleton; -; -; * - arm64; - Usable; -; - Good; * - LoongArch; - Good; -; -; * - PowerPC 64; - Usable; -; -; * - RISC-V; - Good; -; -; * - x86-32; - Basic; -; -; * - x86-64; - Good; - Usable; - Good. .. [1] See ``llvm/examples/OrcV2Examples/LLJITWithObjectLinkingLayerPlugin`` for; a full worked example. .. [2] If not for *hidden* scoped symbols we could eliminate the; ``JITLinkDylib*`` argument to ``JITLinkMemoryManager::allocate`` and; treat every object as a separate simulated dyl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst:45881,simpl,simple,45881,interpreter/llvm-project/llvm/docs/JITLink.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst,1,['simpl'],['simple']
Usability,"ction:. .. code-block:: llvm. define i16 @foo(i16 %a) {; %b = sext i16 %a to i32; %c = and i32 %b, 15; call void @llvm.dbg.value(metadata i32 %c, ...); %d = trunc i32 %c to i16; ret i16 %d; }. Now, here's what happens after the unnecessary truncation instruction ``%d`` is; replaced with a simplified instruction:. .. code-block:: llvm. define i16 @foo(i16 %a) {; call void @llvm.dbg.value(metadata i32 undef, ...); %simplified = and i16 %a, 15; ret i16 %simplified; }. Note that after deleting ``%d``, all uses of its operand ``%c`` become; trivially dead. The debug use which used to point to ``%c`` is now ``undef``,; and debug info is needlessly lost. To solve this problem, do:. .. code-block:: cpp. llvm::replaceAllDbgUsesWith(%c, theSimplifiedAndInstruction, ...). This results in better debug info because the debug use of ``%c`` is preserved:. .. code-block:: llvm. define i16 @foo(i16 %a) {; %simplified = and i16 %a, 15; call void @llvm.dbg.value(metadata i16 %simplified, ...); ret i16 %simplified; }. You may have noticed that ``%simplified`` is narrower than ``%c``: this is not; a problem, because ``llvm::replaceAllDbgUsesWith`` takes care of inserting the; necessary conversion operations into the DIExpressions of updated debug uses. Deleting a MIR-level MachineInstr; ---------------------------------. TODO. Rules for updating ``DIAssignID`` Attachments; =============================================. ``DIAssignID`` metadata attachments are used by Assignment Tracking, which is; currently an experimental debug mode. See :doc:`AssignmentTracking` for how to update them and for more info on; Assignment Tracking. How to automatically convert tests into debug info tests; ========================================================. .. _IRDebugify:. Mutation testing for IR-level transformations; ---------------------------------------------. An IR test case for a transformation can, in many cases, be automatically; mutated to test debug info handling within that transformation.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToUpdateDebugInfo.rst:8517,simpl,simplified,8517,interpreter/llvm-project/llvm/docs/HowToUpdateDebugInfo.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToUpdateDebugInfo.rst,1,['simpl'],['simplified']
Usability,"ctionality of both; of these features.; Improved printing of contents -- Many operator p.d.f. and function components now show; a more intuitive natural representation of their contents (these changes are mostly in the; respective p.d.f.s, but are most relevant in the context of a workspace). New object factory interface to workspace to facilitate script driven model definition; A object factory has been added to RooFit to simplify the process of creating p.d.f.; and function expressions consisting of multiple objects. The factory has two goals:; the first is to provide a back-end for higher level factories and tools to process; the creation of objects. The second is to provide a simple end-user language to; populate a RooWorkspace with function and p.d.f. objects. For the latter purpose the object creation language is executed through the factory() method; of a workspace object. RooWorkspace w(""w"") ;; RooAbsArg* arg = w.factory(""expression_goes_here"") ;. Basic Syntax; The rules at its simplest level are as follows. Expressions with square brackets create variables (discrete and continuous). ""m[-10,10]"" - Creates a RooRealVar named 'm' with range [-10,10]; ""m[5,-10,10]"" - Idem, but with initial value 5; ""m[5]"" - Creates a constant RooRealVar with name 'm' and value 5. ""tagCat[Lep,Kao,NT1,NT2]"" -- Creates a RooCategory with name tagCat and labeled states Lep,Kao,NT1,NT2; ""b0flav[B0=1,B0bar=-1]"" -- Creates a RooCategory with name b0flav and states B0 and B0bar with explicit index assignments. Expressions with parentheses create RooAbsArg function objects of any type. ""RooGaussian::g(x,m,s)"" -- Create a RooGaussian named g with variables x,m,s; This expression maps 1-1 to a createArg() call. ""Gaussian::g(x,m,s)"" -- Idem. The 'Roo' prefix on any class may be omitted. ""Gaussian(x,m,s)"" -- Create a RooGaussian with an automatically assigned name with variables x,m,s. Expressions with curly brackets creates RooArgSets or RooArgLists ""{x,y,z}"". Compound expressions; The rea",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html:18768,simpl,simplest,18768,roofit/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html,1,['simpl'],['simplest']
Usability,"ctions for the three indices through ""P"" in the assignment statement. The; function argument ``P`` will be the second operand of each of these GEP; instructions. The third operand indexes through that pointer. The fourth; operand will be the field offset into the ``struct munger_struct`` type, for; either the ``f1`` or ``f2`` field. So, in LLVM assembly the ``munge`` function; looks like:. .. code-block:: llvm. define void @munge(ptr %P) {; entry:; %tmp = getelementptr %struct.munger_struct, ptr %P, i32 1, i32 0; %tmp1 = load i32, ptr %tmp; %tmp2 = getelementptr %struct.munger_struct, ptr %P, i32 2, i32 1; %tmp3 = load i32, ptr %tmp2; %tmp4 = add i32 %tmp3, %tmp1; %tmp5 = getelementptr %struct.munger_struct, ptr %P, i32 0, i32 0; store i32 %tmp4, ptr %tmp5; ret void; }. In each case the second operand is the pointer through which the GEP instruction; starts. The same is true whether the second operand is an argument, allocated; memory, or a global variable. To make this clear, let's consider a more obtuse example:. .. code-block:: text. @MyVar = external global i32; ...; %idx1 = getelementptr i32, ptr @MyVar, i64 0; %idx2 = getelementptr i32, ptr @MyVar, i64 1; %idx3 = getelementptr i32, ptr @MyVar, i64 2. These GEP instructions are simply making address computations from the base; address of ``MyVar``. They compute, as follows (using C syntax):. .. code-block:: c++. idx1 = (char*) &MyVar + 0; idx2 = (char*) &MyVar + 4; idx3 = (char*) &MyVar + 8. Since the type ``i32`` is known to be four bytes long, the indices 0, 1 and 2; translate into memory offsets of 0, 4, and 8, respectively. No memory is; accessed to make these computations because the address of ``@MyVar`` is passed; directly to the GEP instructions. The obtuse part of this example is in the cases of ``%idx2`` and ``%idx3``. They; result in the computation of addresses that point to memory past the end of the; ``@MyVar`` global, which is only one ``i32`` long, not three ``i32``\s long.; While this is legal i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GetElementPtr.rst:3706,clear,clear,3706,interpreter/llvm-project/llvm/docs/GetElementPtr.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GetElementPtr.rst,1,['clear'],['clear']
Usability,"ctions named ``.text``. .. code-block:: gas. 	.section	.text,""ax"",@progbits,unique,1; nop. 	.section	.text,""ax"",@progbits,unique,2; nop. The unique number is not present in the resulting object at all. It is just used; in the assembler to differentiate the sections. The 'o' flag is mapped to SHF_LINK_ORDER. If it is present, a symbol; must be given that identifies the section to be placed is the; .sh_link. .. code-block:: gas. .section .foo,""a"",@progbits; .Ltmp:; .section .bar,""ao"",@progbits,.Ltmp. which is equivalent to just. .. code-block:: gas. .section .foo,""a"",@progbits; .section .bar,""ao"",@progbits,.foo. ``.linker-options`` Section (linker options); ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. In order to support passing linker options from the frontend to the linker, a; special section of type ``SHT_LLVM_LINKER_OPTIONS`` (usually named; ``.linker-options`` though the name is not significant as it is identified by; the type). The contents of this section is a simple pair-wise encoding of; directives for consideration by the linker. The strings are encoded as standard; null-terminated UTF-8 strings. They are emitted inline to avoid having the; linker traverse the object file for retrieving the value. The linker is; permitted to not honour the option and instead provide a warning/error to the; user that the requested option was not honoured. The section has type ``SHT_LLVM_LINKER_OPTIONS`` and has the ``SHF_EXCLUDE``; flag to ensure that the section is treated as opaque by linkers which do not; support the feature and will not be emitted into the final linked binary. This would be equivalent to the follow raw assembly:. .. code-block:: gas. .section "".linker-options"",""e"",@llvm_linker_options; .asciz ""option 1""; .asciz ""value 1""; .asciz ""option 2""; .asciz ""value 2"". The following directives are specified:. - lib. The parameter identifies a library to be linked against. The library will; be looked up in the default and any specified library search paths; (specifi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Extensions.rst:6272,simpl,simple,6272,interpreter/llvm-project/llvm/docs/Extensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Extensions.rst,1,['simpl'],['simple']
Usability,"ctions that are registered as global constructors in; ``llvm.global_ctors`` and which contain a call to ``__cxa_atexit`` to register; their destructor functions. ``loweratomic``: Lower atomic intrinsics to non-atomic form; -----------------------------------------------------------. This pass lowers atomic intrinsics to non-atomic form for use in a known; non-preemptible environment. The pass does not verify that the environment is non-preemptible (in general; this would require knowledge of the entire call graph of the program including; any libraries which may not be available in bitcode form); it simply lowers; every atomic intrinsic. ``lowerinvoke``: Lower invokes to calls, for unwindless code generators; -----------------------------------------------------------------------. This transformation is designed for use by code generators which do not yet; support stack unwinding. This pass converts ``invoke`` instructions to; ``call`` instructions, so that any exception-handling ``landingpad`` blocks; become dead code (which can be removed by running the ``-simplifycfg`` pass; afterwards). ``lowerswitch``: Lower ``SwitchInst``\ s to branches; ----------------------------------------------------. Rewrites switch instructions with a sequence of branches, which allows targets; to get away with not implementing the switch instruction until it is; convenient. .. _passes-mem2reg:. ``mem2reg``: Promote Memory to Register; ---------------------------------------. This file promotes memory references to be register references. It promotes; alloca instructions which only have loads and stores as uses. An ``alloca`` is; transformed by using dominator frontiers to place phi nodes, then traversing; the function in depth-first order to rewrite loads and stores as appropriate.; This is just the standard SSA construction algorithm to construct ""pruned"" SSA; form. ``memcpyopt``: MemCpy Optimization; ----------------------------------. This pass performs various transformations rela",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst:30065,simpl,simplifycfg,30065,interpreter/llvm-project/llvm/docs/Passes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst,1,['simpl'],['simplifycfg']
Usability,"ctlyDerived : virtual Base {}; // matches Base; class IndirectlyDerived : DirectlyDerived, Base {}; // matches Base. Usable as: Matcher<CXXMethodDecl>, Matcher<CXXBaseSpecifier>. Matcher<CXXBoolLiteralExpr>equalsbool Value. Matcher<CXXBoolLiteralExpr>equalsconst ValueT Value; Matches literals that are equal to the given value of type ValueT. Given; f('false, 3.14, 42);; characterLiteral(equals(0)); matches 'cxxBoolLiteral(equals(false)) and cxxBoolLiteral(equals(0)); match false; floatLiteral(equals(3.14)) and floatLiteral(equals(314e-2)); match 3.14; integerLiteral(equals(42)); matches 42. Note that you cannot directly match a negative numeric literal because the; minus sign is not part of the literal: It is a unary operator whose operand; is the positive numeric literal. Instead, you must use a unaryOperator(); matcher to match the minus sign:. unaryOperator(hasOperatorName(""-""),; hasUnaryOperand(integerLiteral(equals(13)))). Usable as: Matcher<CharacterLiteral>, Matcher<CXXBoolLiteralExpr>,; Matcher<FloatingLiteral>, Matcher<IntegerLiteral>. Matcher<CXXBoolLiteralExpr>equalsdouble Value. Matcher<CXXBoolLiteralExpr>equalsunsigned Value. Matcher<CXXCatchStmt>isCatchAll; Matches a C++ catch statement that has a catch-all handler. Given; try {; // ...; } catch (int) {; // ...; } catch (...) {; // ...; }; cxxCatchStmt(isCatchAll()) matches catch(...) but not catch(int). Matcher<CXXConstructExpr>argumentCountAtLeastunsigned N; Checks that a call expression or a constructor call expression has at least; the specified number of arguments (including absent default arguments). Example matches f(0, 0) and g(0, 0, 0); (matcher = callExpr(argumentCountAtLeast(2))); void f(int x, int y);; void g(int x, int y, int z);; f(0, 0);; g(0, 0, 0);. Matcher<CXXConstructExpr>argumentCountIsunsigned N; Checks that a call expression or a constructor call expression has; a specific number of arguments (including absent default arguments). Example matches f(0, 0) (matcher = callExpr(argument",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:58771,Usab,Usable,58771,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['Usab'],['Usable']
Usability,"cts that come from, e.g., a library adopting the feature and providing; benefits to its users.; A specific need to reside within the Clang tree: There are some extensions; that would be better expressed as a separate tool, and should remain as; separate tools even if they end up being hosted as part of the LLVM umbrella; project.; A specification: The specification must be sufficient to understand the; design of the feature as well as interpret the meaning of specific examples.; The specification should be detailed enough that another compiler vendor; could implement the feature.; Representation within the appropriate governing organization: For; extensions to a language governed by a standards committee (C, C++, OpenCL),; the extension itself must have an active proposal and proponent within that; committee and have a reasonable chance of acceptance. Clang should drive the; standard, not diverge from it. This criterion does not apply to all; extensions, since some extensions fall outside of the realm of the standards; bodies.; A long-term support plan: increasingly large or complex extensions to; Clang need matching commitments to supporting them over time, including; improving their implementation and specification as Clang evolves. The; capacity of the contributor to make that commitment is as important as the; commitment itself.; A high-quality implementation: The implementation must fit well into; Clang's architecture, follow LLVM's coding conventions, and meet Clang's; quality standards, including diagnostics and complete AST; representations. This is particularly important for language extensions,; because users will learn how those extensions work through the behavior of the; compiler.; A test suite: Extensive testing is crucial to ensure that the language; extension is not broken by ongoing maintenance in Clang. The test suite; should be complete enough that another compiler vendor could conceivably; validate their implementation of the feature against it. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_involved.html:4373,learn,learn,4373,interpreter/llvm-project/clang/www/get_involved.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_involved.html,1,['learn'],['learn']
Usability,"cts, it also leads to dramatically cleaner source code. #. No subclasses required: To use CommandLine, you instantiate variables that; correspond to the arguments that you would like to capture, you don't; subclass a parser. This means that you don't have to write **any**; boilerplate code. #. Globally accessible: Libraries can specify command line arguments that are; automatically enabled in any tool that links to the library. This is; possible because the application doesn't have to keep a list of arguments to; pass to the parser. This also makes supporting `dynamically loaded options`_; trivial. #. Cleaner: CommandLine supports enum and other types directly, meaning that; there is less error and more security built into the library. You don't have; to worry about whether your integral command line argument accidentally got; assigned a value that is not valid for your enum type. #. Powerful: The CommandLine library supports many different types of arguments,; from simple `boolean flags`_ to `scalars arguments`_ (`strings`_,; `integers`_, `enums`_, `doubles`_), to `lists of arguments`_. This is; possible because CommandLine is... #. Extensible: It is very simple to add a new argument type to CommandLine.; Simply specify the parser that you want to use with the command line option; when you declare it. `Custom parsers`_ are no problem. #. Labor Saving: The CommandLine library cuts down on the amount of grunt work; that you, the user, have to do. For example, it automatically provides a; ``-help`` option that shows the available command line options for your tool.; Additionally, it does most of the basic correctness checking for you. #. Capable: The CommandLine library can handle lots of different forms of; options often found in real programs. For example, `positional`_ arguments,; ``ls`` style `grouping`_ options (to allow processing '``ls -lad``'; naturally), ``ld`` style `prefix`_ options (to parse '``-lmalloc; -L/usr/lib``'), and interpreter style options. This ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst:2424,simpl,simple,2424,interpreter/llvm-project/llvm/docs/CommandLine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst,1,['simpl'],['simple']
Usability,"d %0() [""kcfi""(i32 1234)]. Clang emits KCFI operand bundles and the necessary metadata with; ``-fsanitize=kcfi``. .. _convergencectrl:. Convergence Control Operand Bundles; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. A ""convergencectrl"" operand bundle is only valid on a ``convergent`` operation.; When present, the operand bundle must contain exactly one value of token type.; See the :doc:`ConvergentOperations` document for details. .. _moduleasm:. Module-Level Inline Assembly; ----------------------------. Modules may contain ""module-level inline asm"" blocks, which corresponds; to the GCC ""file scope inline asm"" blocks. These blocks are internally; concatenated by LLVM and treated as a single unit, but may be separated; in the ``.ll`` file if desired. The syntax is very simple:. .. code-block:: llvm. module asm ""inline asm code goes here""; module asm ""more can go here"". The strings can contain any character by escaping non-printable; characters. The escape sequence used is simply ""\\xx"" where ""xx"" is the; two digit hex code for the number. Note that the assembly string *must* be parseable by LLVM's integrated assembler; (unless it is disabled), even when emitting a ``.s`` file. .. _langref_datalayout:. Data Layout; -----------. A module may specify a target specific data layout string that specifies; how data is to be laid out in memory. The syntax for the data layout is; simply:. .. code-block:: llvm. target datalayout = ""layout specification"". The *layout specification* consists of a list of specifications; separated by the minus sign character ('-'). Each specification starts; with a letter and may include other information after the letter to; define some aspect of the data layout. The specifications accepted are; as follows:. ``E``; Specifies that the target lays out data in big-endian form. That is,; the bits with the most significance have the lowest address; location.; ``e``; Specifies that the target lays out data in little-endian form. That; is, the bits with the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:130685,simpl,simply,130685,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['simpl'],['simply']
Usability,"d '::' and any; of the STL container names was inadvertently omitted (in case of classes; that are part of the TTree but had only a base and no member or in some; cases where it had only object data members.; Prevent storing a 2nd time an object non derived from TObject in the case; where the object is both the top level object of branch and has; some of it sub-object containing a pointer back to the object. (This was; actually activated in v5.18).; ; void TBranch::DeleteBaskets(Option_t* option); new function which loops on all branch baskets. If the file where branch buffers reside is writable, free the disk space associated to the baskets of the branch, then call Reset(). If the option contains ""all"", delete also the baskets for the subbranches. The branch is reset.; NOTE that this function must be used with extreme care. Deleting branch baskets; fragments the file and may introduce inefficiencies when adding new entries; in the Tree or later on when reading the Tree. Protect TTree::GetCurrentFile in case the current directory is gROOT.; This case may happen when a TChain calls TChain::Process and no files have been; connected to the chain yet, but a TFile has been opened meanwhile.; Remove the calls to MapObject introduce in revision 21384 when; are unnecessary hence restoring lost performance in case where; the TTree contains many simple type (double, int, etc.); In TBranchElement::Streamer when writing, call ForceWriteInfo; not only for the TStreamerInfo directly concerning this branch; but also (in the case of the top level branch of a split TClonesArray; or a split STL container) call ForceWriteInfo for the class of; the value. This omission meant that slow CloneTree was (fataly) missing in; some cases the copy of the TStreamerInfo for class that are part; part of the TTree but had only a base and no member or in; some cases where it had only object data members.; Fix the return value of the lookup in TChainIndex; when the value searched for does not exist. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/doc/v520/index.html:9220,simpl,simple,9220,tree/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/doc/v520/index.html,1,['simpl'],['simple']
Usability,"d 'hide' any item from the user (but keep access with normal http requests). With such properties one could specify which item is drawn when web page is loaded, or configure monitoring. See tutorials/http/httpcontrol.C macro for more details. ##### Method Calls; Implement exe.json requests to be able to execute any method of registered objects. This request is used to provide remote TTree::Draw() functionality. ##### Misc; Correctly set 'Cache-Control' headers when replying to http requests.; Better support of STL containers when converting objects into json with TBufferJSON class. ## JavaScript ROOT. - Several files can now be loaded simultaneously; - Use d3.time.scale to display time scales; - Implemented drag and drop to superimpose histograms or graphs; - Allow selection of drawing option via context menu; - Better support of touch devices; - Provide simple layout, making it default; - Allow to open ROOT files in online session (via url parameter); - One could monitor simultaneously objects from server and root files; - Implement 'autocol' draw option - when superimposing histograms,; their line colors will be automatically assigned; - Implement 'nostat' draw option - disabled stat drawing; - Using '_same_' identifier in item name, one can easily draw or superimpose; similar items from different files. Could be used in URL like:; `...&files=[file1.root,file2.root]&items=[file1.root/hpx, file2.root/_same_]`; `...&files=[file1.root,file2.root]&item=file1.root/hpx+file2.root/_same_`; Main limitation - file names should have similar length.; - When 'autozoom' specified in draw options, histogram zoomed into; non-empty content. Same command available via context menu.; - Item of 'Text' kind can be created. It is displayed as; lain text in the browser. If property 'mathjax' specified,; MathJax.js library will be loaded and used for rendering.; See tutorials/http/httpcontrol.C macro for example.; - When using foreignObject, provide workaround for absolute positioning; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v604/index.md:10636,simpl,simple,10636,README/ReleaseNotes/v604/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v604/index.md,1,['simpl'],['simple']
Usability,"d **`TVectorF`**.; Copy constructors exist to transform these into their double precision; equivalent, thereby allowing easy access to decomposition and eigenvalue; classes, only available in double precision. The choice was made not to provide the less frequently used complex; matrix classes. If necessary, users can always reformulate the; calculation in 2 parts, a real one and an imaginary part. Although, a; linear equation involving complex numbers will take about a factor of 8; more computations, the alternative of introducing a set of complex; classes in this non-template library would create a major maintenance; challenge. Another choice was to fill in both the upper-right corner and the; bottom-left corner of a symmetric matrix. Although most algorithms use; only the upper-right corner, implementation of the different matrix; views was more straightforward this way. When stored only the; upper-right part is written to file. For a detailed description of the interface, the user should look at the; root reference guide at: <http://root.cern.ch/root/Reference.html>. ## Overview of Matrix Classes. The figure below shows an overview of the classes available in the; linear algebra library,` libMatrix.so`. At the center is the base class; **`TMatrixDBase`** from which three different matrix classes,; **`TMatrixD`**, **`TMatrixDSym`** and **`TMatrixDFSparse`** derive. The; user can define customized matrix operations through the classes; **`TElementActionD`** and **`TElementsPosActionD`**. ![Overview of matrix classes](pictures/0300012D.png). Reference to different views of the matrix can be created through the; classes on the right-hand side, see ""Matrix Views"". These references; provide a natural connection to vectors. Matrix decompositions (used in equation solving and matrix inversion); are available through the classes on the left-hand side (see ""Matrix; Decompositions""). They inherit from the **`TDecompBase`** class. The; Eigen Analysis is performed through the ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md:1392,guid,guide,1392,documentation/users-guide/LinearAlgebra.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md,1,['guid'],['guide']
Usability,"d Clang, you will need to give *it* access to modern C++; standard library in order to use it as your new host in part of a bootstrap.; There are two easy ways to do this, either build (and install) libc++ along; with Clang and then use it with the ``-stdlib=libc++`` compile and link flag,; or install Clang into the same prefix (``$HOME/toolchains`` above) as GCC.; Clang will look within its own prefix for libstdc++ and use it if found. You; can also add an explicit prefix for Clang to look in for a GCC toolchain with; the ``--gcc-toolchain=/opt/my/gcc/prefix`` flag, passing it to both compile and; link commands when using your just-built-Clang to bootstrap. .. _Getting Started with LLVM:. Getting Started with LLVM; =========================. The remainder of this guide is meant to get you up and running with LLVM and to; give you some basic information about the LLVM environment. The later sections of this guide describe the `general layout`_ of the LLVM; source tree, a `simple example`_ using the LLVM tool chain, and `links`_ to find; more information about LLVM or to get help via e-mail. Terminology and Notation; ------------------------. Throughout this manual, the following names are used to denote paths specific to; the local system and working environment. *These are not environment variables; you need to set but just strings used in the rest of this document below*. In; any of the examples below, simply replace each of these names with the; appropriate pathname on your local system. All these paths are absolute:. ``SRC_ROOT``. This is the top level directory of the LLVM source tree. ``OBJ_ROOT``. This is the top level directory of the LLVM object tree (i.e. the tree where; object files and compiled programs will be placed. It can be the same as; SRC_ROOT). Unpacking the LLVM Archives; ---------------------------. If you have the LLVM distribution, you will need to unpack it before you can; begin to compile it. LLVM is distributed as a number of different; su",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst:20364,guid,guide,20364,interpreter/llvm-project/llvm/docs/GettingStarted.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst,2,"['guid', 'simpl']","['guide', 'simple']"
Usability,"d Fortran version,; with almost equivalent numerical accuracy and computational performances.; Furthermore, it contains new functionality, like the possibility to set single side parameter limits or; the FUMILI algorithm, which is an optimized method for least square and log likelihood minimizations.; The package has been originally developed by M. Winkler and F. James.; More information on the new C++ version can be found on the; MINUIT Web Site. Minuit2, originally developed in the SEAL project, is now distributed within %ROOT.; The API has been then changed in this new version to follow the %ROOT coding convention (function names starting with capital letters) and the classes have been moved inside the namespace ROOT::Minuit2.; In addition, the %ROOT distribution contains classes needed to integrate Minuit2 in the %ROOT framework. A new class has been introduced, ROOT::Minuit2::Minuit2Minimizer, which implements the interface; ROOT::Math::Minimizer. Within %ROOT, it can be instantiates also using the %ROOT plug-in manager. This class provides a convenient entry point for using Minuit2. An example of using this interface is; the %ROOT tutorial tutorials/fit/NumericalMinimization.C or; the Minuit2 test program testMinimize.cxx. A standalone version of Minuit2 (independent of %ROOT) can be downloaded from here. It does not contain the %ROOT interface and it is therefore totally independent of external packages and can be simply build using the configure script and then make. Example tests are provided in the directory test/MnSim and test/MnTutorial and they can be built with the make check command. The Minuit2 User Guide provides all the information needed for using directly (without add-on packages like %ROOT) Minuit2. References. F. James, Fortran MINUIT Reference Manual (html);; F. James and M. Winkler, C++ MINUIT User's Guide (html and; pdf);; F. James, Minuit Tutorial on Function Minimization (pdf);; F. James, The Interpretation of Errors in Minuit (pdf);. */; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/doc/Minuit2.html:1712,simpl,simply,1712,math/minuit2/doc/Minuit2.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/doc/Minuit2.html,3,"['Guid', 'simpl']","['Guide', 'simply']"
Usability,"d a ``result'' or data model class called; SamplingDistribution, which holds the sampling distribution of an; arbitrary real valued test statistic. �The class also can return the; inverse of the cumulative distribution function (with or without; interpolation). �; We introduced an interface for any tool that can produce a; SamplingDistribution, called TestStatSampler. �The interface is; essentially GetSamplingDistribution(parameterPoint) which returns a; SamplingDistribution based on a given probability density function. �We; foresee a few versions of this tool based on toy Monte Carlo, importance; sampling, Fourier transforms, etc. �The following concrete implementation; of the TestStatSampler interface are currently available. ToyMCSamplerUses a Toy Monte Carlo approach to build the; sampling distribution. �The pdf's generate method to generate is used to; generate toy data, and then the test statistic is evaluated at the; requested parameter point. ; DebuggingSampler Simply returns a uniform distribution; between 0,1. �Useful for debugging. NeymanConstruction and FeldmanCousins; A flexible framework for the Neyman Construction was added in this; release. The NeymanConstruction is a concrete implementation of the; IntervalCalculator interface, but it needs several; additional components�to be specified before use. The design; factorizes the choice of the parameter points to be tested,�the choice of; the test statistic, and the generation of sampling distribution into; separate parts (described above). �Finally, the NeymanConstruction class; is simply in charge of using these parts (strategies) and constructing; the confidence belt and confidence intervals. �The ConfidenceBelt class; is still under development, but the current version works fine for; producing ConfidenceIntervals. �We are also working to make this class; work with parallelization approaches, which is not yet complete.; The FeldmanCousins class is a separate concrete implementation of the; IntervalCa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html:27596,Simpl,Simply,27596,roofit/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html,1,['Simpl'],['Simply']
Usability,"d axis on their own. This may be useful for example in the case; one wants to draw two axis for the same plot, one on the left and one on; the right. For historical reasons, there are two classes representing axis.; **`TAxis`** \* `axis` is the axis object, which will be returned when; calling the `TH1::GetAxis()` method. ``` {.cpp}; TAxis *axis = histo->GetXaxis(); ```. Of course, you may do the same for `Y` and `Z`-axis. The graphical; representation of an axis is done with the **`TGaxis`** class. The; histogram classes and **`TGraph`** generate instances of this class.; This is internal and the user should not have to see it. ### Axis Title. The axis title is set, as with all named objects, by. ``` {.cpp}; axis->SetTitle(""Whatever title you want"");; ```. When the axis is embedded into a histogram or a graph, one has to first; extract the axis object:. ``` {.cpp}; h->GetXaxis()->SetTitle(""Whatever title you want""); ```. ### Axis Options and Characteristics. The axis options are most simply set with the styles. The available; style options controlling specific axis options are the following:. ``` {.cpp}; TAxis *axis = histo->GetXaxis();; axis->SetAxisColor(Color_t color = 1);; axis->SetLabelColor(Color_t color = 1);; axis->SetLabelFont(Style_t font = 62);; axis->SetLabelOffset(Float_t offset = 0.005);; axis->SetLabelSize(Float_t size = 0.04);; axis->SetNdivisions(Int_t n = 510, Bool_t optim = kTRUE);; axis->SetNoExponent(Bool_t noExponent = kTRUE);; axis->SetTickLength(Float_t length = 0.03);; axis->SetTitleOffset(Float_t offset = 1);; axis->SetTitleSize(Float_t size = 0.02);; ```. The getters corresponding to the described setters are also available.; The general options, not specific to axis, as for instance; `SetTitleTextColor()` are valid and do have an effect on axis; characteristics. ### Setting the Number of Divisions. Use `TAxis::SetNdivisions(ndiv,optim)` to set the number of divisions; for an axis. The `ndiv` and `optim` are as follows:. - `ndiv = N1 + 10",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:50574,simpl,simply,50574,documentation/users-guide/Graphics.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md,1,['simpl'],['simply']
Usability,"d be treated as ``__null_terminated``.; The same applies to other annotations.; In system headers, the default pointer attribute for ABI-visible pointers is set; to ``__unsafe_indexable`` by default. The ``__ptrcheck_abi_assume_*ATTR*()`` macros are defined as pragmas in the; toolchain header (See `Portability with toolchains that do not support the; extension`_ for more details about the toolchain header):. .. code-block:: C. #define __ptrcheck_abi_assume_single() \; _Pragma(""clang abi_ptr_attr set(single)""). #define __ptrcheck_abi_assume_indexable() \; _Pragma(""clang abi_ptr_attr set(indexable)""). #define __ptrcheck_abi_assume_bidi_indexable() \; _Pragma(""clang abi_ptr_attr set(bidi_indexable)""). #define __ptrcheck_abi_assume_unsafe_indexable() \; _Pragma(""clang abi_ptr_attr set(unsafe_indexable)""). ABI implications of default bounds annotations; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Although simply modifying types of a local variable doesn't normally impact the; ABI, taking the address of such a modified type could create a pointer type that; has an ABI mismatch. Looking at the following example, ``int *local`` is; implicitly ``int *__bidi_indexable`` and thus the type of ``&local`` is a; pointer to ``int *__bidi_indexable``. On the other hand, in ``void foo(int; **)``, the parameter type is a pointer to ``int *__single`` (i.e., ``void; foo(int *__single *__single)``) (or a pointer to ``int *__unsafe_indexable`` if; it's from a system header). The compiler reports an error for casts between; pointers whose elements have incompatible pointer attributes. This way,; ``-fbounds-safety`` prevents pointers that are implicitly ``__bidi_indexable``; from silently escaping thereby breaking the ABI. .. code-block:: c. void foo(int **);. void bar(void) {; int *local = 0;; // error: passing 'int *__bidi_indexable*__bidi_indexable' to parameter of; // incompatible nested pointer type 'int *__single*__single'; foo(&local);; }. A local variable may still be exposed to",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:23469,simpl,simply,23469,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['simpl'],['simply']
Usability,"d loop containing S2 will be vectorized. Loop Distribution is currently not enabled by default in the optimizer because; it can hurt performance in some cases. For example, instruction-level; parallelism could be reduced by sequentializing the execution of the; statements S1 and S2 above. If Loop Distribution is turned on globally with; ``-mllvm -enable-loop-distribution``, specifying ``distribute(disable)`` can; be used the disable it on a per-loop basis. Additional Information; ----------------------. For convenience multiple loop hints can be specified on a single line. .. code-block:: c++. #pragma clang loop vectorize_width(4) interleave_count(8); for(...) {; ...; }. If an optimization cannot be applied any hints that apply to it will be ignored.; For example, the hint ``vectorize_width(4)`` is ignored if the loop is not; proven safe to vectorize. To identify and diagnose optimization issues use; `-Rpass`, `-Rpass-missed`, and `-Rpass-analysis` command line options. See the; user guide for details. Extensions to specify floating-point flags; ====================================================. The ``#pragma clang fp`` pragma allows floating-point options to be specified; for a section of the source code. This pragma can only appear at file scope or; at the start of a compound statement (excluding comments). When using within a; compound statement, the pragma is active within the scope of the compound; statement. Currently, the following settings can be controlled with this pragma:. ``#pragma clang fp reassociate`` allows control over the reassociation; of floating point expressions. When enabled, this pragma allows the expression; ``x + (y + z)`` to be reassociated as ``(x + y) + z``.; Reassociation can also occur across multiple statements.; This pragma can be used to disable reassociation when it is otherwise; enabled for the translation unit with the ``-fassociative-math`` flag.; The pragma can take two values: ``on`` and ``off``. .. code-block:: c++. float f",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:169529,guid,guide,169529,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['guid'],['guide']
Usability,"d many; different ways of classifying them: flow-sensitive vs. flow-insensitive,; context-sensitive vs. context-insensitive, field-sensitive; vs. field-insensitive, unification-based vs. subset-based, etc. Traditionally,; alias analyses respond to a query with a `Must, May, or No`_ alias response,; indicating that two pointers always point to the same object, might point to the; same object, or are known to never point to the same object. The LLVM `AliasAnalysis; <https://llvm.org/doxygen/classllvm_1_1AliasAnalysis.html>`__ class is the; primary interface used by clients and implementations of alias analyses in the; LLVM system. This class is the common interface between clients of alias; analysis information and the implementations providing it, and is designed to; support a wide range of implementations and clients (but currently all clients; are assumed to be flow-insensitive). In addition to simple alias analysis; information, this class exposes Mod/Ref information from those implementations; which can provide it, allowing for powerful analyses and transformations to work; well together. This document contains information necessary to successfully implement this; interface, use it, and to test both sides. It also explains some of the finer; points about what exactly results mean. ``AliasAnalysis`` Class Overview; ================================. The `AliasAnalysis <https://llvm.org/doxygen/classllvm_1_1AliasAnalysis.html>`__; class defines the interface that the various alias analysis implementations; should support. This class exports two important enums: ``AliasResult`` and; ``ModRefResult`` which represent the result of an alias query or a mod/ref; query, respectively. The ``AliasAnalysis`` interface exposes information about memory, represented in; several different ways. In particular, memory objects are represented as a; starting address and size, and function calls are represented as the actual; ``call`` or ``invoke`` instructions that performs the call. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:1291,simpl,simple,1291,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,1,['simpl'],['simple']
Usability,"d object are:. - **directory:** The working directory of the compilation. All paths; specified in the **command** or **file** fields must be either; absolute or relative to this directory.; - **file:** The main translation unit source processed by this; compilation step. This is used by tools as the key into the; compilation database. There can be multiple command objects for the; same file, for example if the same source file is compiled with; different configurations.; - **arguments:** The compile command argv as list of strings.; This should run the compilation step for the translation unit ``file``.; ``arguments[0]`` should be the executable name, such as ``clang++``.; Arguments should not be escaped, but ready to pass to ``execvp()``.; - **command:** The compile command as a single shell-escaped string.; Arguments may be shell quoted and escaped following platform conventions,; with '``""``' and '``\``' being the only special characters. Shell expansion; is not supported. Either **arguments** or **command** is required. **arguments** is preferred,; as shell (un)escaping is a possible source of errors.; - **output:** The name of the output created by this compilation step.; This field is optional. It can be used to distinguish different processing; modes of the same input file. Build System Integration; ========================. The convention is to name the file compile\_commands.json and put it at; the top of the build directory. Clang tools are pointed to the top of; the build directory to detect the file and use the compilation database; to parse C++ code in the source tree. Alternatives; ============; For simple projects, Clang tools also recognize a ``compile_flags.txt`` file.; This should contain one argument per line. The same flags will be used to; compile any file. Example:. ::. -xc++; -I; libwidget/include/. Here ``-I libwidget/include`` is two arguments, and so becomes two lines.; Paths are relative to the directory containing ``compile_flags.txt``.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/JSONCompilationDatabase.rst:4728,simpl,simple,4728,interpreter/llvm-project/clang/docs/JSONCompilationDatabase.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/JSONCompilationDatabase.rst,1,['simpl'],['simple']
Usability,"d of 4 elements.; This can be used to simplify a variety of shuffle operations, where the; elements are fixed zeros. //===---------------------------------------------------------------------===//. This code generates ugly code, probably due to costs being off or something:. define void @test(float* %P, <4 x float>* %P2 ) {; %xFloat0.688 = load float* %P; %tmp = load <4 x float>* %P2; %inFloat3.713 = insertelement <4 x float> %tmp, float 0.0, i32 3; store <4 x float> %inFloat3.713, <4 x float>* %P2; ret void; }. Generates:. _test:; 	movl	8(%esp), %eax; 	movaps	(%eax), %xmm0; 	pxor	%xmm1, %xmm1; 	movaps	%xmm0, %xmm2; 	shufps	$50, %xmm1, %xmm2; 	shufps	$132, %xmm2, %xmm0; 	movaps	%xmm0, (%eax); 	ret. Would it be better to generate:. _test:; movl 8(%esp), %ecx; movaps (%ecx), %xmm0; 	xor %eax, %eax; pinsrw $6, %eax, %xmm0; pinsrw $7, %eax, %xmm0; movaps %xmm0, (%ecx); ret. ?. //===---------------------------------------------------------------------===//. Some useful information in the Apple Altivec / SSE Migration Guide:. http://developer.apple.com/documentation/Performance/Conceptual/; Accelerate_sse_migration/index.html. e.g. SSE select using and, andnot, or. Various SSE compare translations. //===---------------------------------------------------------------------===//. Add hooks to commute some CMPP operations. //===---------------------------------------------------------------------===//. Apply the same transformation that merged four float into a single 128-bit load; to loads from constant pool. //===---------------------------------------------------------------------===//. Floating point max / min are commutable when -enable-unsafe-fp-path is; specified. We should turn int_x86_sse_max_ss and X86ISD::FMIN etc. into other; nodes which are selected to max / min instructions that are marked commutable. //===---------------------------------------------------------------------===//. We should materialize vector constants like ""all ones"" and ""signbit"" with ; code l",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/README-SSE.txt:8990,Guid,Guide,8990,interpreter/llvm-project/llvm/lib/Target/X86/README-SSE.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/README-SSE.txt,1,['Guid'],['Guide']
Usability,"d or older Ubuntus:. # service autofs restart. - Prepare a `/etc/cvmfs/default.local` file (create it if it does not; exists) with the following configuration bits:. ``` {.bash}; CVMFS_HTTP_PROXY=http://your-proxy-server.domain.ch:3128,DIRECT; CVMFS_REPOSITORIES=your-experiment.cern.ch,sft.cern.ch; CVMFS_QUOTA_LIMIT=50000; ```. You need to properly specify your closest HTTP caching proxy:; separate many of them via commas. The last fallback value, `DIRECT`,; tells cvmfs to connect directly without using any proxy at all. Among the list of repositories (comma-separated), always specify; `sft.cern.ch` and the one containing the software to your experiment; (e.g., `cms.cern.ch`). The quota limit is, in Megabytes, the amount of local disk space to; use as cache. - Check the configuration and repositories with:. # cvmfs_config chksetup; OK; # cvmfs_config probe; Probing /cvmfs/cms.cern.ch... OK; Probing /cvmfs/sft.cern.ch... OK. > You might need special configurations for some custom software; > repositories! Special cases are not covered in this guide. ### Firewall configuration. [PROOF on Demand](http://pod.gsi.de/) is very flexible in handling; various cases of network topologies. The best solution would be to allow; all TCP communications between the cluster machines. No other incoming communication is required from the outside. Configuration steps for the head node only; ------------------------------------------. ### Setup HTTPS+SSH (sshcertauth) authentication. > Latest recommended sshcertauth version is 0.8.5.; >; > [Download](https://github.com/dberzano/sshcertauth/archive/v0.8.5.zip); > and [read the; > instructions](http://newton.ph.unito.it/~berzano/w/doku.php?id=proof:sshcertauth). If you want your users to connect to the PROOF cluster using their Grid; user certificate and private key you might be interested in installing; sshcertauth. Please refer to the [installation; guide](http://newton.ph.unito.it/~berzano/w/doku.php?id=proof:sshcertauth); for further i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/ConfigProofPoD.md:3662,guid,guide,3662,proof/doc/confman/ConfigProofPoD.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/ConfigProofPoD.md,1,['guid'],['guide']
Usability,"d possible local settings; (daemon, dataset manager).; Add possibility to control the automatic re-loading of; the <proof.conf> file via the keyword; 'reload:1'/'reload:0'; in the xpd.resource directive.; Move the validation of <proof.conf> at the; moment of use; this allows to specify a file path and to dynamically; create/modify/destroy the file; used by PoD.; Improve displaying speed of large log files. Fixes. Fix two severe; bugs in the way TTreeCache; was used in PROOF: one bug was de facto disactivating the cache; the; other was causing a std::bad_alloc exception to be thrown on workers; when opening a remote file after a local one.    ; Fix several problems in TChain::Draw including. drawing into an existing histogram, i.e.; chain->Draw(""var>>myhist"");. treatment of histogram merging in case of small; statistics, i.e. when; the autobinning is not or only partially active;. usage of existing canvases when different histogram; names are specified;. Fix a problem causing a duplication of the final feedback; object. Fix problem with determining the subdir name in; TFileMerger::MergeRecursive on Windows; Make sure that the default sandbox is under $HOME/.proof; Fix a problem with dataset validation in multi-level; master setups; Fix a problem with ordinal numbers in multi-master setups; Fix a problem with defining the internal paths for; executables when configuring with '--prefix'; Fix backward-incompatibility issue giving the error; message  ""unknown action code: 5112""; Fix a few problems with file retrieval from the cache; Fix a problem with iteration of a std::list occasionally; causing seg-violations in TXSocket; Fix a few problems preventing correct usage of entry; lists in PROOF; Fix a problem with the permissions of the credentials; files created under <sandbox>/.creds; Fix a potential problem while determining the log paths; in log retrieval. Do not use vnsprintf in the XrdProofd plug-in, potential; source of deadlocks.; Fix a problem overwriting the local",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v524/index.html:9247,feedback,feedback,9247,proof/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v524/index.html,1,['feedback'],['feedback']
Usability,"d pythonization with the `__getattr__` syntax still works, but emits a deprecation warning and will be removed from ROOT 6.34. ### Removal of Python 2 support. ROOT does no longer support Python 2. The minimum Python version necessary to use ROOT in a Python application is 3.8.; As a consequence, any reference to Python 2 in ROOT code was removed and certain configuration options are no longer; usable, e.g. * `root-config --python2-version`; * cmake -Dpyroot-python2. The cmake build system now looks for the standard `Python3` package and previously custom Python-related cmake variables; are now just the ones automatically produced by cmake (see https://cmake.org/cmake/help/latest/module/FindPython.html). ### More usage of the public cppyy API. Many implementation details of the ROOT pythonizations were moved from C++ functions to pure Python bindings using the; public cppyy API. This helps in the integration with the tool but also improves code efficiency and memory usage. ## Class Reference Guide. - Define missing doxygen groups.; - Fix a few typos in the `THStack` documentation.; - Small fixes in the `THistPainter` documentation.; - Improve the `TColor` documentation: use modern C++ in the examples.; - Make sure the python examples do not generate wrong namespaces in the documentation.; - The dataframe tutorials json spec files were not displayed properly. Moreover there was; no direct correspondence between the code source and the json file. Those files do not; have any doc in them. With a direct link to the GitHub source file the dependency between source; code and json is now more obvious.; - Document how to remove shadow of `TPave`, as it was not evident (only explanations were hidden here and there in the forum).; - Improve the `SetFillColorAlpha` documentation.; - Simplify some graphics examples: arrow.C, crown.C, diamond.C and ellipse.C.; - Fix a typo in the documentation of `TGraph::SetHighlight` in `TGraph.cxx`.; - Change the marker style in the tutorial ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md:23291,Guid,Guide,23291,README/ReleaseNotes/v632/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md,1,['Guid'],['Guide']
Usability,"d set of training variables in that zone. The division; into categories in presence of distinct sub-populations reduces; the correlations between the training variables, improves the; modelling, and hence increases the classification and regression; performance. Presently, the Category method works for; classification only, but regression will follow soon. Please; contact us if urgently needed. An example scripts and data files illustrating how the new; Category method is configured and used. Please check the macros; test/TMVAClassificationCategory.C and; test/TMVAClassificationCategoryApplication.C or the; corresponding executables.; Regression functionality for gradient boosted trees using a Huber loss function. Comments. On Input Data: . New TMVA event vector building. The code for splitting the input; data into training and test samples for all classes and the; mixing of those samples to one training and one test sample has; been rewritten completely. The new code is more performant and; has a clearer structure. This fixes several bugs which have been; reported by the TMVA users. On Minimization: . Variables, targets and spectators are now checked if they are; constant. (The execution of TMVA is stopped for variables and; targets, a warning is given for spectators.). On Regression:; ; The analysis type is no longer defined by calling a dedicated; TestAllMethods-member-function of the Factory, but with the; option ""AnalysisType"" in the Factory. The default value is; ""Auto"" where TMVA tries to determine the most suitable analysis; type from the targets and classes the user has defined. Other; values are ""regression"", ""classification"" and ""multiclass"" for; the forthcoming multiclass classification.; Missing regression evaluation plots for training sample were; added. On Cut method:. Removed obsolete option ""FVerySmart"" from Cuts method. On MLP method:; ; Display of convergence information in the progress bar for MLP during training. Creation of animated gifs for ML",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/doc/v526/index.html:1573,clear,clearer,1573,tmva/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/doc/v526/index.html,1,['clear'],['clearer']
Usability,"d that this; limitation cannot be eliminated with the usage of any parallel analysis; toolkit. ### Optimisation Regarding N-tuples ###. ROOT automatically applies compression algorithms on n-tuples to reduce; the memory consumption. A value that is in most cases the same will; consume only small space on your disk (but it has to be decompressed on; reading). Nevertheless, you should think about the design of your; n-tuples and your analyses as soon as the processing time exceeds some; minutes. - Try to keep your n-tuples simple and use appropriate variable types.; If your measurement has only a limited precision, it is needless to; store it with double precision. - Experimental conditions that do not change with every single; measurement should be stored in a separate tree. Although the; compression can handle redundant values, the processing time; increase with every variable that has to be filled. - The function `SetCacheSize(long)` specifies the size of the cache; for reading a `TTree` object from a file. The default value is 30MB.; A manual increase may help in certain situations. Please note that; the caching mechanism can cover only one `TTree` object per `TFile`; object. - You can select the branches to be covered by the caching algorithm; with `AddBranchToCache` and deactivate unneeded branches with; `SetBranchStatus`. This mechanism can result in a significant; speed-up for simple operations on trees with many branches. - You can measure the performance easily with `TTreePerfStats`. The; ROOT documentation on this class also includes an introductory; example. For example, `TTreePerfStats` can show you that it is; beneficial to store meta data and payload data separately, i.e.; write the meta data tree in a bulk to a file at the end of your job; instead of writing both trees interleaved. [^6]: The usage of `fOutput` is not really needed for this simple example, but it allows re-usage of the exact code in parallel processing with `PROOF` (see next section).; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md:14543,simpl,simple,14543,documentation/primer/filio.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md,2,['simpl'],['simple']
Usability,"d the operands to the; operation. The various operation node types are described at the top of the; ``include/llvm/CodeGen/ISDOpcodes.h`` file. Although most operations define a single value, each node in the graph may; define multiple values. For example, a combined div/rem operation will define; both the dividend and the remainder. Many other situations require multiple; values as well. Each node also has some number of operands, which are edges to; the node defining the used value. Because nodes may define multiple values,; edges are represented by instances of the ``SDValue`` class, which is a; ``<SDNode, unsigned>`` pair, indicating the node and result value being used,; respectively. Each value produced by an ``SDNode`` has an associated ``MVT``; (Machine Value Type) indicating what the type of the value is. SelectionDAGs contain two different kinds of values: those that represent data; flow and those that represent control flow dependencies. Data values are simple; edges with an integer or floating point value type. Control edges are; represented as ""chain"" edges which are of type ``MVT::Other``. These edges; provide an ordering between nodes that have side effects (such as loads, stores,; calls, returns, etc). All nodes that have side effects should take a token; chain as input and produce a new one as output. By convention, token chain; inputs are always operand #0, and chain results are always the last value; produced by an operation. However, after instruction selection, the; machine nodes have their chain after the instruction's operands, and; may be followed by glue nodes. A SelectionDAG has designated ""Entry"" and ""Root"" nodes. The Entry node is; always a marker node with an Opcode of ``ISD::EntryToken``. The Root node is; the final side-effecting node in the token chain. For example, in a single basic; block function it would be the return node. One important concept for SelectionDAGs is the notion of a ""legal"" vs.; ""illegal"" DAG. A legal DAG for a tar",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:35385,simpl,simple,35385,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,1,['simpl'],['simple']
Usability,"d to; generate a Data Layout and the optimization phases will operate; accordingly and introduce target specificity into the IR with respect to; these default specifications. .. _langref_triple:. Target Triple; -------------. A module may specify a target triple string that describes the target; host. The syntax for the target triple is simply:. .. code-block:: llvm. target triple = ""x86_64-apple-macosx10.7.0"". The *target triple* string consists of a series of identifiers delimited; by the minus sign character ('-'). The canonical forms are:. ::. ARCHITECTURE-VENDOR-OPERATING_SYSTEM; ARCHITECTURE-VENDOR-OPERATING_SYSTEM-ENVIRONMENT. This information is passed along to the backend so that it generates; code for the proper architecture. It's possible to override this on the; command line with the ``-mtriple`` command line option. .. _objectlifetime:. Object Lifetime; ----------------------. A memory object, or simply object, is a region of a memory space that is; reserved by a memory allocation such as :ref:`alloca <i_alloca>`, heap; allocation calls, and global variable definitions.; Once it is allocated, the bytes stored in the region can only be read or written; through a pointer that is :ref:`based on <pointeraliasing>` the allocation; value.; If a pointer that is not based on the object tries to read or write to the; object, it is undefined behavior. A lifetime of a memory object is a property that decides its accessibility.; Unless stated otherwise, a memory object is alive since its allocation, and; dead after its deallocation.; It is undefined behavior to access a memory object that isn't alive, but; operations that don't dereference it such as; :ref:`getelementptr <i_getelementptr>`, :ref:`ptrtoint <i_ptrtoint>` and; :ref:`icmp <i_icmp>` return a valid result.; This explains code motion of these instructions across operations that; impact the object's lifetime.; A stack object's lifetime can be explicitly specified using; :ref:`llvm.lifetime.start <int_lifest",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:140159,simpl,simply,140159,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['simpl'],['simply']
Usability,"d to; top of stack, and the new space is available immediately below the linkage and; parameter areas. The cost of shifting the linkage and parameter areas is minor; since only the link value needs to be copied. The link value can be easily; fetched by adding the original frame size to the base pointer. Note that; allocations in the dynamic space need to observe 16 byte alignment. The *locals area* is where the llvm compiler reserves space for local variables. The *saved registers area* is where the llvm compiler spills callee saved; registers on entry to the callee. Prolog/Epilog; ^^^^^^^^^^^^^. The llvm prolog and epilog are the same as described in the PowerPC ABI, with; the following exceptions. Callee saved registers are spilled after the frame is; created. This allows the llvm epilog/prolog support to be common with other; targets. The base pointer callee saved register r31 is saved in the TOC slot of; linkage area. This simplifies allocation of space for the base pointer and; makes it convenient to locate programmatically and during debugging. Dynamic Allocation; ^^^^^^^^^^^^^^^^^^. .. note::. TODO - More to come. The NVPTX backend; -----------------. The NVPTX code generator under lib/Target/NVPTX is an open-source version of; the NVIDIA NVPTX code generator for LLVM. It is contributed by NVIDIA and is; a port of the code generator used in the CUDA compiler (nvcc). It targets the; PTX 3.0/3.1 ISA and can target any compute capability greater than or equal to; 2.0 (Fermi). This target is of production quality and should be completely compatible with; the official NVIDIA toolchain. Code Generator Options:. :raw-html:`<table border=""1"" cellspacing=""0"">`; :raw-html:`<tr>`; :raw-html:`<th>Option</th>`; :raw-html:`<th>Description</th>`; :raw-html:`</tr>`; :raw-html:`<tr>`; :raw-html:`<td>sm_20</td>`; :raw-html:`<td align=""left"">Set shader model/compute capability to 2.0</td>`; :raw-html:`</tr>`; :raw-html:`<tr>`; :raw-html:`<td>sm_21</td>`; :raw-html:`<td align=""le",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:100794,simpl,simplifies,100794,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,1,['simpl'],['simplifies']
Usability,"d upon. Short titles; also look better in `git log`. * When the changes are restricted to a specific part of the code (e.g. a; back-end or optimization pass), it is customary to add a tag to the; beginning of the line in square brackets. For example, ""[SCEV] ...""; or ""[OpenMP] ..."". This helps email filters and searches for post-commit; reviews. * The body, if it exists, should be separated from the title by an empty line. * The body should be concise, but explanatory, including a complete; reasoning. Unless it is required to understand the change, examples,; code snippets and gory details should be left to bug comments, web; review or the mailing list. * Text formatting and spelling should follow the same rules as documentation; and in-code comments, ex. capitalization, full stop, etc. * If the commit is a bug fix on top of another recently committed patch, or a; revert or reapply of a patch, include the git commit hash of the prior; related commit. This could be as simple as ""Revert commit NNNN because it; caused PR#"". * If the patch has been reviewed, add a link to its review page, as shown; `here <https://www.llvm.org/docs/Phabricator.html#committing-a-change>`__.; If the patch fixes a bug in GitHub Issues, we encourage adding a reference to; the issue being closed, as described; `here <https://llvm.org/docs/BugLifeCycle.html#resolving-closing-bugs>`__. * It is also acceptable to add other metadata to the commit message to automate; processes, including for downstream consumers. This metadata can include; links to resources that are not available to the entire community. However,; such links and/or metadata should not be used in place of making the commit; message self-explanatory. Note that such non-public links should not be; included in the submitted code. For minor violations of these recommendations, the community normally favors; reminding the contributor of this policy over reverting. Minor corrections and; omissions can be handled by sending a reply to t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst:17404,simpl,simple,17404,interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,1,['simpl'],['simple']
Usability,"d users of the project. For more information about; the Apache 2.0 License, please see the `Apache License FAQ; <http://www.apache.org/foundation/license-faq.html>`_, maintained by the; Apache Project. .. _patent license:. Patents; -------. Section 3 of the Apache 2.0 license is a patent grant under which; contributors of code to the project contribute the rights to use any of; their patents that would otherwise be infringed by that code contribution; (protecting uses of that code). Further, the patent grant is revoked; from anyone who files a patent lawsuit about code in LLVM - this protects the; community by providing a ""patent commons"" for the code base and reducing the; odds of patent lawsuits in general. The license specifically scopes which patents are included with code; contributions. To help explain this, the `Apache License FAQ; <http://www.apache.org/foundation/license-faq.html>`_ explains this scope using; some questions and answers, which we reproduce here for your convenience (for; reference, the ""ASF"" is the Apache Software Foundation, the guidance still; holds though)::. Q1: If I own a patent and contribute to a Work, and, at the time my; contribution is included in that Work, none of my patent's claims are subject; to Apache's Grant of Patent License, is there a way any of those claims would; later become subject to the Grant of Patent License solely due to subsequent; contributions by other parties who are not licensees of that patent. A1: No. Q2: If at any time after my contribution, I am able to license other patent; claims that would have been subject to Apache's Grant of Patent License if; they were licensable by me at the time of my contribution, do those other; claims become subject to the Grant of Patent License?. A2: Yes. Q3: If I own or control a licensable patent and contribute code to a specific; Apache product, which of my patent claims are subject to Apache's Grant of; Patent License?. A3: The only patent claims that are licensed to th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst:59147,guid,guidance,59147,interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,1,['guid'],['guidance']
Usability,"d(""lhs"")),; hasRHS(expr().bind(""rhs"")); ); matches each use of ""!="" in:; struct S{; bool operator!=(const S&) const;; };. void foo(); {; 1 != 2;; S() != S();; }. template<typename T>; void templ(); {; 1 != 2;; T() != S();; }; struct HasOpEq; {; bool operator==(const HasOpEq &) const;; };. void inverse(); {; HasOpEq s1;; HasOpEq s2;; if (s1 != s2); return;; }. struct HasSpaceship; {; bool operator<=>(const HasOpEq &) const;; };. void use_spaceship(); {; HasSpaceship s1;; HasSpaceship s2;; if (s1 != s2); return;; }. Matcher<*>eachOfMatcher<*>, ..., Matcher<*>; Matches if any of the given matchers matches. Unlike anyOf, eachOf will generate a match result for each; matching submatcher. For example, in:; class A { int a; int b; };; The matcher:; cxxRecordDecl(eachOf(has(fieldDecl(hasName(""a"")).bind(""v"")),; has(fieldDecl(hasName(""b"")).bind(""v"")))); will generate two results binding ""v"", the first of which binds; the field declaration of a, the second the field declaration of; b. Usable as: Any Matcher. Matcher<*>findAllMatcher<*> Matcher; Matches if the node or any descendant matches. Generates results for each match. For example, in:; class A { class B {}; class C {}; };; The matcher:; cxxRecordDecl(hasName(""::A""),; findAll(cxxRecordDecl(isDefinition()).bind(""m""))); will generate results for A, B and C. Usable as: Any Matcher. Matcher<*>forEachDescendantMatcher<*>; Matches AST nodes that have descendant AST nodes that match the; provided matcher. Example matches X, A, A::X, B, B::C, B::C::X; (matcher = cxxRecordDecl(forEachDescendant(cxxRecordDecl(hasName(""X""))))); class X {};; class A { class X {}; }; // Matches A, because A::X is a class of name; // X inside A.; class B { class C { class X {}; }; };. DescendantT must be an AST base type. As opposed to 'hasDescendant', 'forEachDescendant' will cause a match for; each result that matches instead of only on the first one. Note: Recursively combined ForEachDescendant can cause many matches:; cxxRecordDecl(forEachDescendan",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:131739,Usab,Usable,131739,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['Usab'],['Usable']
Usability,"d(std::coroutine_handle<PromiseType> handle) noexcept {; handle.promise().count++;; }; };. static task coro_task(int v) {; int a = v;; co_await await_counter{};; a++;; std::cout << a << ""\n"";; a++;; std::cout << a << ""\n"";; a++;; std::cout << a << ""\n"";; co_await await_counter{};; a++;; std::cout << a << ""\n"";; a++;; std::cout << a << ""\n"";; }. int main() {; task t = coro_task(43);; t.resume();; t.resume();; t.resume();; return 0;; }. In debug mode (`O0` + `g`), the printing result would be:. .. parsed-literal::. {__resume_fn = 0x4019e0 <coro_task(int)>, __destroy_fn = 0x402000 <coro_task(int)>, __promise = {count = 1}, v = 43, a = 45, __coro_index = 1 '\001', struct_std__suspend_always_0 = {__int_8 = 0 '\000'},; class_await_counter_1 = {__int_8 = 0 '\000'}, class_await_counter_2 = {__int_8 = 0 '\000'}, struct_std__suspend_always_3 = {__int_8 = 0 '\000'}}. In the above, the values of `v` and `a` are clearly expressed, as are the; temporary values for `await_counter` (`class_await_counter_1` and; `class_await_counter_2`) and `std::suspend_always` (; `struct_std__suspend_always_0` and `struct_std__suspend_always_3`). The index; of the current suspension point of the coroutine is emitted as `__coro_index`.; In the above example, the `__coro_index` value of `1` means the coroutine; stopped at the second suspend point (Note that `__coro_index` is zero indexed); which is the first `co_await await_counter{};` in `coro_task`. Note that the; first initial suspend point is the compiler generated; `co_await promise_type::initial_suspend()`. However, when optimizations are enabled, the printed result changes drastically:. .. parsed-literal::. {__resume_fn = 0x401280 <coro_task(int)>, __destroy_fn = 0x401390 <coro_task(int)>, __promise = {count = 1}, __int_32_0 = 43, __coro_index = 1 '\001'}. Unused values are optimized out, as well as the name of the local variable `a`.; The only information remained is the value of a 32 bit integer. In this simple; case, it seems to be pretty ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst:7659,clear,clearly,7659,interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst,1,['clear'],['clearly']
Usability,"d.; - `TTree::Branch()` now complains for wrong leaf list strings, e.g. ""value/F[4]"" (which should really be spelled as ""value[4]/F"").; - Allow reading of older version of TTreePerfStats (ROOT-8520); - In `TTree::OptimizeBaskets()` do not call GetBasket(0) to avoid disc reads; - It is now possible to define the precision of the default histogram created; by `TTree::Draw`. Three new parameters are available in `$ROOTSYS/etcsystem.rootrc`; ```{.cpp}; Hist.Precision.1D: float; Hist.Precision.2D: float; Hist.Precision.3D: float; ```; the default values are `float`. They can be set to `double`.; - Fix ROOT-8742: TTree::SetBranchAddress could not be invoked safely even when dealing with the same tree obtained from the same file opened in different threads.; - TTree::Branch() now complains if a ""name[size]/F"" branch specification is passed wrongly (e.g. as ""name/F[size]""). ### TDataFrame; - Creation of the TDataFrame class. The TDataFrame allows to interact with data; stored in columnar format in a functional and intuitive way in order to perform; data analysis. Parallelism is accessible simply by activating implicit; multi-threading with the ROOT::EnableImplicitMT() function.; In a nutshell, the functionality provided is:; - Create and fill histograms with one single method invocation; - Express filtering of entries with strings, lambdas or functions; - Easy creation of efficiencies of cut-flows; - Possibility to run on ranges of entries; - Creating columns not present in the original dataset; - Chain multiple actions to be executed on the same event loop; - Creation of events on-the-fly (e.g. via Pythia or user-define generator functors), with no need for an input TTree; - Snapshot on a rootfile the dataset after cuts and after augmentation with columns created by the user; - Run analyses expressed as chains of actions in parallel in a transparent way for the user; See [the online documentation](https://root.cern.ch/doc/master/classROOT_1_1Experimental_1_1TDF_1_1TDataFram",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v610/index.md:6234,intuit,intuitive,6234,README/ReleaseNotes/v610/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v610/index.md,1,['intuit'],['intuitive']
Usability,"dAddressTakenIatEntryTable: {type: int}; GuardAddressTakenIatEntryCount: {type: int}; GuardLongJumpTargetTable: {type: int}; GuardLongJumpTargetCount: {type: int}; DynamicValueRelocTable: {type: int}; CHPEMetadataPointer: {type: int}; GuardRFFailureRoutine: {type: int}; GuardRFFailureRoutineFunctionPointer: {type: int}; DynamicValueRelocTableOffset: {type: int}; DynamicValueRelocTableSection: {type: int}; GuardRFVerifyStackPointerFunctionPointer: {type: int}; HotPatchTableOffset: {type: int}; EnclaveConfigurationPointer: {type: int}; VolatileMetadataPointer: {type: int}; GuardEHContinuationTable: {type: int}; GuardEHContinuationCount: {type: int}; GuardXFGCheckFunctionPointer: {type: int}; GuardXFGDispatchFunctionPointer: {type: int}; GuardXFGTableDispatchFunctionPointer: {type: int}; CastGuardOsDeterminedFailureMode: {type: int}. symbols:; - Name: .text; Value: 0; SectionNumber: 1; SimpleType: IMAGE_SYM_TYPE_NULL # (0); ComplexType: IMAGE_SYM_DTYPE_NULL # (0); StorageClass: IMAGE_SYM_CLASS_STATIC # (3); NumberOfAuxSymbols: 1; AuxiliaryData:; ""\x24\x00\x00\x00\x03\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00"" # |$.................|. - Name: _main; Value: 0; SectionNumber: 1; SimpleType: IMAGE_SYM_TYPE_NULL # (0); ComplexType: IMAGE_SYM_DTYPE_NULL # (0); StorageClass: IMAGE_SYM_CLASS_EXTERNAL # (2). Here's a simplified Kwalify_ schema with an extension to allow alternate types. .. _Kwalify: http://www.kuwata-lab.com/kwalify/ruby/users-guide.html. .. code-block:: yaml. type: map; mapping:; header:; type: map; mapping:; Machine: [ {type: str, enum:; [ IMAGE_FILE_MACHINE_UNKNOWN; , IMAGE_FILE_MACHINE_AM33; , IMAGE_FILE_MACHINE_AMD64; , IMAGE_FILE_MACHINE_ARM; , IMAGE_FILE_MACHINE_ARMNT; , IMAGE_FILE_MACHINE_ARM64; , IMAGE_FILE_MACHINE_EBC; , IMAGE_FILE_MACHINE_I386; , IMAGE_FILE_MACHINE_IA64; , IMAGE_FILE_MACHINE_M32R; , IMAGE_FILE_MACHINE_MIPS16; , IMAGE_FILE_MACHINE_MIPSFPU; , IMAGE_FILE_MACHINE_MIPSFPU16; , IMAGE_FILE_MACHINE_POWERPC; , IMAGE_FILE_MACHINE_POWER",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/yaml2obj.rst:2610,Simpl,SimpleType,2610,interpreter/llvm-project/llvm/docs/yaml2obj.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/yaml2obj.rst,1,['Simpl'],['SimpleType']
Usability,"dLock; (C); Simple lock -> unlock checker; applies to:; pthread_mutex_lock; pthread_rwlock_rdlock; pthread_rwlock_wrlock; lck_mtx_lock; lck_rw_lock_exclusive; lck_rw_lock_shared; pthread_mutex_trylock; pthread_rwlock_tryrdlock; pthread_rwlock_tryrwlock; lck_mtx_try_lock; lck_rw_try_lock_exclusive; lck_rw_try_lock_shared; pthread_mutex_unlock; pthread_rwlock_unlock; lck_mtx_unlock; lck_rw_done. pthread_mutex_t mtx;. void test() {; pthread_mutex_lock(&mtx);; pthread_mutex_lock(&mtx);; // warn: this lock has already been acquired; }. lck_mtx_t lck1, lck2;. void test() {; lck_mtx_lock(&lck1);; lck_mtx_lock(&lck2);; lck_mtx_unlock(&lck1);; // warn: this was not the most recently acquired lock; }. lck_mtx_t lck1, lck2;. void test() {; if (lck_mtx_try_lock(&lck1) == 0); return;. lck_mtx_lock(&lck2);; lck_mtx_unlock(&lck1);; // warn: this was not the most recently acquired lock; }. alpha.unix.SimpleStream; (C); Check for misuses of stream APIs:; fopen; fclose(demo checker, the subject of the demo; (Slides; ,Video); by Anna Zaks and Jordan Rose presented at the ; 2012 LLVM Developers' Meeting). void test() {; FILE *F = fopen(""myfile.txt"", ""w"");; } // warn: opened file is never closed. void test() {; FILE *F = fopen(""myfile.txt"", ""w"");. if (F); fclose(F);. fclose(F); // warn: closing a previously closed file stream; }. alpha.unix.Stream; (C); Check stream handling functions:fopen; tmpfile; fclose; fread; fwrite; fseek; ftell; rewind; fgetpos; fsetpos; clearerr; feof; ferror; fileno. void test() {; FILE *p = fopen(""foo"", ""r"");; } // warn: opened file is never closed. void test() {; FILE *p = fopen(""foo"", ""r"");; fseek(p, 1, SEEK_SET); // warn: stream pointer might be NULL; fclose(p);; }. void test() {; FILE *p = fopen(""foo"", ""r"");. if (p); fseek(p, 1, 3);; // warn: third arg should be SEEK_SET, SEEK_END, or SEEK_CUR. fclose(p);; }. void test() {; FILE *p = fopen(""foo"", ""r"");; fclose(p);; fclose(p); // warn: already closed; }. void test() {; FILE *p = tmpfile();; ftell(p); // wa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:13879,Simpl,SimpleStream,13879,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,1,['Simpl'],['SimpleStream']
Usability,"dOrErr = Importer.Import(From);; if (!ImportedOrErr) {; llvm::Error Err = ImportedOrErr.takeError();; consumeError(std::move(Err));. // ... but the node had been created.; auto *ToYDef = getFirstDecl<CXXRecordDecl>(; cxxRecordDecl(hasName(""Y""), isDefinition()), ToUnit);; ToYDef->dump();; // An error is set for ""ToYDef"" in the shared state.; Optional<ASTImportError> OptErr =; ImporterState->getImportDeclErrorIfAny(ToYDef);; assert(OptErr);. return 1;; }. If we take a look at the AST, then we can see that the Decl with the definition is created, but the field is missing. .. code-block:: bash. |-CXXRecordDecl 0xf66678 <line:9:7, col:13> col:13 class Y; `-CXXRecordDecl 0xf66730 prev 0xf66678 <:10:7, col:13> col:13 class Y definition; |-DefinitionData pass_in_registers empty aggregate standard_layout trivially_copyable pod trivial literal has_constexpr_non_copy_move_ctor can_const_default_init; | |-DefaultConstructor exists trivial constexpr needs_implicit defaulted_is_constexpr; | |-CopyConstructor simple trivial has_const_param needs_implicit implicit_has_const_param; | |-MoveConstructor exists simple trivial needs_implicit; | |-CopyAssignment trivial has_const_param needs_implicit implicit_has_const_param; | |-MoveAssignment exists simple trivial needs_implicit; | `-Destructor simple irrelevant trivial needs_implicit; `-CXXRecordDecl 0xf66828 <col:7, col:13> col:13 implicit class Y. We do not remove the erroneous nodes because by the time when we recognize the error it is too late to remove the node, there may be additional references to that already in the AST.; This is aligned with the overall `design principle of the Clang AST <InternalsManual.html#immutability>`_: Clang AST nodes (types, declarations, statements, expressions, and so on) are generally designed to be **immutable once created**.; Thus, clients of the ASTImporter library should always check if there is any associated error for the node which they inspect in the destination context.; We recommend skipp",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst:19363,simpl,simple,19363,interpreter/llvm-project/clang/docs/LibASTImporter.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst,4,['simpl'],['simple']
Usability,"d];; mem [label="" New Memory \n Allocation? "", shape=""diamond""];; withaloc [label="" SetValueWithAlloc() "", shape=""box""];; noaloc [label="" SetValueNoAlloc() "", shape=""box""];; right [label="" 1. RValue Structure \n (a temporary value)"", shape=""box""];; left2 [label="" 2. LValue Structure \n (a variable with \n an address)"", shape=""box""];; left3 [label="" 3. Built-In Type \n (int, float, etc.)"", shape=""box""];; output [label="" move to 'Assign' step "", shape=""box""];. synth -> mem;; mem -> withaloc [label=""Yes""];; mem -> noaloc [label=""No""];; withaloc -> right;; noaloc -> left2;; noaloc -> left3;; right -> output;; left2 -> output;; left3 -> output;; }; output -> assign; }. Where is the captured result stored?; ------------------------------------. ``LastValue`` holds the last result of the value printing. It is a class member; because it can be accessed even after subsequent inputs. **Note:** If no value printing happens, then it is in an invalid state. Improving Efficiency and User Experience; ----------------------------------------. The Value object is essentially used to create a mapping between an expression; 'type' and the allocated 'memory'. Built-in types (bool, char, int,; float, double, etc.) are copyable. Their memory allocation size is known; and the Value object can introduce a small-buffer optimization.; In case of objects, the ``Value`` class provides reference-counted memory; management. The implementation maps the type as written and the Clang Type to be able to use; the preprocessor to synthesize the relevant cast operations. For example,; ``X(char, Char_S)``, where ``char`` is the type from the language's type system; and ``Char_S`` is the Clang builtin type which represents it. This mapping helps; to import execution results from the interpreter in a compiled program and vice; versa. The ``Value.h`` header file can be included at runtime and this is why it; has a very low token count and was developed with strict constraints in mind. This also enables the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst:8719,User Experience,User Experience,8719,interpreter/llvm-project/clang/docs/ClangRepl.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst,1,['User Experience'],['User Experience']
Usability,"d_size_t`` is defined before that header is included, and also vend ``wchar_t`` only when the macro ``__need_wchar_t`` is defined. Such headers are often included many times in a single translation unit, and will have no include guards. There is no sane way to map this header to a submodule. One can either eliminate the header (e.g., by splitting it into separate headers, one per actual API) or simply ``exclude`` it in the module map. To detect and help address some of these problems, the ``clang-tools-extra`` repository contains a ``modularize`` tool that parses a set of given headers and attempts to detect these problems and produce a report. See the tool's in-source documentation for information on how to check your system or library headers. Future Directions; =================; Modules support is under active development, and there are many opportunities remaining to improve it. Here are a few ideas:. **Detect unused module imports**; Unlike with ``#include`` directives, it should be fairly simple to track whether a directly-imported module has ever been used. By doing so, Clang can emit ``unused import`` or ``unused #include`` diagnostics, including Fix-Its to remove the useless imports/includes. **Fix-Its for missing imports**; It's fairly common for one to make use of some API while writing code, only to get a compiler error about ""unknown type"" or ""no function named"" because the corresponding header has not been included. Clang can detect such cases and auto-import the required module, but should provide a Fix-It to add the import. **Improve modularize**; The modularize tool is both extremely important (for deployment) and extremely crude. It needs better UI, better detection of problems (especially for C++), and perhaps an assistant mode to help write module maps for you. Where To Learn More About Modules; =================================; The Clang source code provides additional information about modules:. ``clang/lib/Headers/module.modulemap``; Module ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:56266,simpl,simple,56266,interpreter/llvm-project/clang/docs/Modules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst,1,['simpl'],['simple']
Usability,"dar:. LLVM community calendar; -----------------------. We aim to maintain a public calendar view of all events happening in the LLVM; community such as :ref:`online-sync-ups` and :ref:`office-hours`. The calendar; can be found at; https://calendar.google.com/calendar/u/0/embed?src=calendar@llvm.org and can; also be seen inline below:. .. raw:: html. <iframe src=""https://calendar.google.com/calendar/embed?height=600&wkst=1&bgcolor=%23ffffff&ctz=UTC&showCalendars=0&showDate=1&showNav=1&src=Y2FsZW5kYXJAbGx2bS5vcmc&color=%23039BE5"" style=""border:solid 1px #777"" width=""800"" height=""600"" frameborder=""0"" scrolling=""no""></iframe>. .. _llvm-community-calendar-host-guidance:. Guidance on what to put into LLVM community calendar invites; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. To add your event, create a calendar event for it and invite calendar@llvm.org; on it. Your event should then show up on the community calendar. Please put the following pieces of information in your calendar invite:. * Write a single paragraph describing what the event is about. Include things; such as who the event is for and what sort of topics are discussed.; * State explicitly that the :doc:`CodeOfConduct` applies to this event.; * Make it clear who:. * the organizer is. * the person to contact is in case of any code-of-conduct issues. Typically,; this would be the organizer. * If you have meeting minutes for your event, add a pointer to where those live.; A good place for meeting minutes could be as a post on LLVM Discourse. An example invite looks as follows. .. code-block:: none. This event is a meetup for all developers of LLDB. Meeting agendas are posted; on discourse before the event. Attendees are required to adhere to the LLVM Code of Conduct; (https://llvm.org/docs/CodeOfConduct.html). For any Code of Conduct reports,; please contact the organizers, and also email conduct@llvm.org. Agenda/Meeting Minutes: Link to minutes. Organizer(s): First Surname (name@email.com). ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingInvolved.rst:20164,clear,clear,20164,interpreter/llvm-project/llvm/docs/GettingInvolved.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingInvolved.rst,1,['clear'],['clear']
Usability,"date, and commit it. This can be done by running; the following:. ::. git pull --rebase https://github.com/llvm/llvm-project.git main; git show # Ensure the patch looks correct.; ninja check-$whatever # Rerun the appropriate tests if needed.; git push https://github.com/llvm/llvm-project.git HEAD:main. Abandoning a change; -------------------. If you decide you should not commit the patch, you should explicitly abandon; the review so that reviewers don't think it is still open. In the web UI,; scroll to the bottom of the page where normally you would enter an overall; comment. In the drop-down Action list, which defaults to ""Comment,"" you should; select ""Abandon Revision"" and then enter a comment explaining why. Click the; Submit button to finish closing the review. Status; ------. Please let us know whether you like it and what could be improved! We're still; working on setting up a bug tracker, but you can email klimek-at-google-dot-com; and chandlerc-at-gmail-dot-com and CC the llvm-dev mailing list with questions; until then. We also could use help implementing improvements. This sadly is; really painful and hard because the Phabricator codebase is in PHP and not as; testable as you might like. However, we've put exactly what we're deploying up; on an `llvm-reviews GitHub project`_ where folks can hack on it and post pull; requests. We're looking into what the right long-term hosting for this is, but; note that it is a derivative of an existing open source project, and so not; trivially a good fit for an official LLVM project. .. _LLVM's Phabricator: https://reviews.llvm.org; .. _`https://reviews.llvm.org`: https://reviews.llvm.org; .. _Code Repository Browser: https://reviews.llvm.org/diffusion/; .. _Arcanist Quick Start: https://secure.phabricator.com/book/phabricator/article/arcanist_quick_start/; .. _Arcanist User Guide: https://secure.phabricator.com/book/phabricator/article/arcanist/; .. _llvm-reviews GitHub project: https://github.com/r4nt/llvm-reviews/; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst:17618,Guid,Guide,17618,interpreter/llvm-project/llvm/docs/Phabricator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst,1,['Guid'],['Guide']
Usability,"dd `Nonzero` helper: return the indices of the elements which are not zero; - Add `Reverse` helepr: return copy of reversed RVec.; - Add `Sort` helper: return copy of vector with elements sorted in ascending order (also according to a user defined predicate); - Add `Take` helper which can:; - return elements of a RVec at given indices.; - return first elements or last elements of an RVec.; - Add `Where` helper which can:; - return the elements of v1 if the condition c is true and v2 if the condition c is false.; - return the elements of v1 if the condition c is true and sets the value v2 if the condition c is false.; - return the elements of v2 if the condition c is false and sets the value v1 if the condition c is true.; - return a vector with the value v2 if the condition c is false and sets the value v1 if the condition c is true. ## RooFit Libraries; - Add value printer for RooAbsArg and daughters.; - Add a Python version for the majority of the Tutorials. ## TMVA Library. ### Deep Learning. This release contains several fixes and improvement for the `MethodDL`. The `MethodDL` is also now the recommended class to use for Deep Learning in TMVA and is replacing the previous existing; `MethodDNN`, which is still available, but it has a limited functionality and it supports only dense layer. The new features of `MethodDL` are:. - Support training and evaluation of Convolutional layer on GPU; - Several ML optimizers are now included and they can be used in addition to SGD. These are ADAM (the new default), ADAGRAD,; RMSPROP, ADADELTA. A new option, *Optimizer* has been added in the option string used to define the training strategy options.; - Add support for regression in MethodDL; - Use single precision (float) types as the fundamental type for the neural network architecture. Double precision could be enabled, but it will require recompiling TMVA. ; - Support inference (network evaluation) in batch mode in addition to single event. Batch mode evaluation is now the ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v616/index.md:13100,Learn,Learning,13100,README/ReleaseNotes/v616/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v616/index.md,1,['Learn'],['Learning']
Usability,"dd or change the project's .clang-tidy to reflect the agreed rules.; (This is in a separate commit to enable the merging process described in; `Minimising cost of downstream merges`_).; Also update the project list on the policy page.; 2. Apply ``clang-tidy`` to the project's files, with only the; ``readability-identifier-naming`` rules enabled. ``clang-tidy`` will also; reformat the affected lines according to the rules in ``.clang-format``.; It is anticipated that this will be a good dog-fooding opportunity for; clang-tidy, and bugs should be fixed in the process, likely including:. * `readability-identifier-naming incorrectly fixes lambda capture; <https://bugs.llvm.org/show_bug.cgi?id=41119>`_.; * `readability-identifier-naming incorrectly fixes variables which; become keywords <https://bugs.llvm.org/show_bug.cgi?id=41120>`_.; * `readability-identifier-naming misses fixing member variables in; destructor <https://bugs.llvm.org/show_bug.cgi?id=41122>`_. #. Gather feedback and refine the process as appropriate. #. Apply the process to the following projects, with a suitable delay between; each (at least 4 weeks after the first change, at least 2 weeks subsequently); to allow gathering further feedback.; This list should exclude projects that must adhere to an externally defined; standard e.g. libcxx.; The list is roughly in chronological order of renaming.; Some items may not make sense to rename individually - it is expected that; this list will change following experimentation:. * TableGen; * llvm/tools; * clang-tools-extra; * clang; * ARM backend; * AArch64 backend; * AMDGPU backend; * ARC backend; * AVR backend; * BPF backend; * Hexagon backend; * Lanai backend; * MIPS backend; * NVPTX backend; * PowerPC backend; * RISC-V backend; * Sparc backend; * SystemZ backend; * WebAssembly backend; * X86 backend; * XCore backend; * libLTO; * Debug Information; * Remainder of llvm; * compiler-rt; * libunwind; * openmp; * parallel-libs; * polly; * lldb. #. Remove the old v",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst:12139,feedback,feedback,12139,interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst,1,['feedback'],['feedback']
Usability,"de Motion. **LSDA**; Language Specific Data Area. C++ ""zero cost"" unwinding is built on top a; generic unwinding mechanism. As the unwinder walks each frame, it calls; a ""personality"" function to do language specific analysis. Each function's; FDE points to an optional LSDA which is passed to the personality function.; For C++, the LSDA contain info about the type and location of catch; statements in that function. **Load-VN**; Load Value Numbering. **LTO**; Link-Time Optimization. M; -. **MC**; Machine Code. N; -; .. _nfc:. **NFC**; ""No functional change"". Used in a commit message to indicate that a patch; is a pure refactoring/cleanup.; Usually used in the first line, so it is visible without opening the; actual commit email. O; -; .. _object pointer:; .. _object pointers:. **Object Pointer**; A pointer to an object such that the garbage collector is able to trace; references contained within the object. This term is used in opposition to; `derived pointer`_. P; -. **PGO**; Profile-Guided Optimization. **PR**; Problem report. A bug filed on `the LLVM Bug Tracking System; <https://bugs.llvm.org/enter_bug.cgi>`_. **PRE**; Partial Redundancy Elimination. R; -. **RAUW**. Replace All Uses With. The functions ``User::replaceUsesOfWith()``,; ``Value::replaceAllUsesWith()``, and; ``Constant::replaceUsesOfWithOnConstant()`` implement the replacement of one; Value with another by iterating over its def/use chain and fixing up all of; the pointers to point to the new value. See; also `def/use chains <ProgrammersManual.html#iterating-over-def-use-use-def-chains>`_. **Reassociation**; Rearranging associative expressions to promote better redundancy elimination; and other optimization. For example, changing ``(A+B-A)`` into ``(B+A-A)``,; permitting it to be optimized into ``(B+0)`` then ``(B)``. **RFC**; Request for Comment. An email sent to a project mailing list in order to; solicit feedback on a proposed change. .. _roots:; .. _stack roots:. **Root**; In garbage collection, ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Lexicon.rst:6181,Guid,Guided,6181,interpreter/llvm-project/llvm/docs/Lexicon.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Lexicon.rst,1,['Guid'],['Guided']
Usability,"de for ""a+b"", and; then continue parsing:. .. code-block:: c++. ... if body omitted ...; }. // Merge LHS/RHS.; LHS = std::make_unique<BinaryExprAST>(BinOp, std::move(LHS),; std::move(RHS));; } // loop around to the top of the while loop.; }. In our example above, this will turn ""a+b+"" into ""(a+b)"" and execute the; next iteration of the loop, with ""+"" as the current token. The code; above will eat, remember, and parse ""(c+d)"" as the primary expression,; which makes the current pair equal to [+, (c+d)]. It will then evaluate; the 'if' conditional above with ""\*"" as the binop to the right of the; primary. In this case, the precedence of ""\*"" is higher than the; precedence of ""+"" so the if condition will be entered. The critical question left here is ""how can the if condition parse the; right hand side in full""? In particular, to build the AST correctly for; our example, it needs to get all of ""(c+d)\*e\*f"" as the RHS expression; variable. The code to do this is surprisingly simple (code from the; above two blocks duplicated for context):. .. code-block:: c++. // If BinOp binds less tightly with RHS than the operator after RHS, let; // the pending operator take RHS as its LHS.; int NextPrec = GetTokPrecedence();; if (TokPrec < NextPrec) {; RHS = ParseBinOpRHS(TokPrec+1, std::move(RHS));; if (!RHS); return nullptr;; }; // Merge LHS/RHS.; LHS = std::make_unique<BinaryExprAST>(BinOp, std::move(LHS),; std::move(RHS));; } // loop around to the top of the while loop.; }. At this point, we know that the binary operator to the RHS of our; primary has higher precedence than the binop we are currently parsing.; As such, we know that any sequence of pairs whose operators are all; higher precedence than ""+"" should be parsed together and returned as; ""RHS"". To do this, we recursively invoke the ``ParseBinOpRHS`` function; specifying ""TokPrec+1"" as the minimum precedence required for it to; continue. In our example above, this will cause it to return the AST; node for ""(c+d)\*e\*f"" a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst:18899,simpl,simple,18899,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst,1,['simpl'],['simple']
Usability,"de set can; be a subset of another loop with a different loop header. The loop; hierarchy in a function forms a forest: Each top-level loop is the; root of the tree of the loops nested inside it. .. image:: ./loop-nested.svg; :width: 350 px. * It is not possible that two loops share only a few of their nodes.; Two loops are either disjoint or one is nested inside the other. In; the example below the left and right subsets both violate the; maximality condition. Only the merge of both sets is considered a loop. .. image:: ./loop-nonmaximal.svg; :width: 250 px. * It is also possible that two logical loops share a header, but are; considered a single loop by LLVM:. .. code-block:: C. for (int i = 0; i < 128; ++i); for (int j = 0; j < 128; ++j); body(i,j);. which might be represented in LLVM-IR as follows. Note that there is; only a single header and hence just a single loop. .. image:: ./loop-merge.svg; :width: 400 px. The :ref:`LoopSimplify <loop-terminology-loop-simplify>` pass will; detect the loop and ensure separate headers for the outer and inner loop. .. image:: ./loop-separate.svg; :width: 400 px. * A cycle in the CFG does not imply there is a loop. The example below; shows such a CFG, where there is no header node that dominates all; other nodes in the cycle. This is called **irreducible control-flow**. .. image:: ./loop-irreducible.svg; :width: 150 px. The term reducible results from the ability to collapse the CFG into a; single node by successively replacing one of three base structures with; a single node: A sequential execution of basic blocks, acyclic conditional; branches (or switches), and a basic block looping on itself.; `Wikipedia <https://en.wikipedia.org/wiki/Control-flow_graph#Reducibility>`_; has a more formal definition, which basically says that every cycle has; a dominating header. * Irreducible control-flow can occur at any level of the loop nesting.; That is, a loop that itself does not contain any loops can still have; cyclic control flow ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LoopTerminology.rst:4215,simpl,simplify,4215,interpreter/llvm-project/llvm/docs/LoopTerminology.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LoopTerminology.rst,1,['simpl'],['simplify']
Usability,"de unsupported context menu entries, status line update. ## Changes in 3.4; 1. Support usage of minimized versions of .js and .css files.; Minimized scripts used by default on web servers.; 2. Implement JSROOT.extend instead of jQuery.extend, reduce; usage of jquery.js in core JSROOT classes; 3. Implement main graphics without jquery at all,; such mode used in `nobrowser` mode.; 4. Provide optional latex drawing with MathJax SVG.; TMathText always drawn with MathJax,; other classes require `mathjax` option in URL; 5. Improve drawing of different text classes, correctly handle; their alignment and scaling, special handling for IE; 6. Fix error with time axes - time offset was not correctly interpreted. ## Changes in 3.3; 1. Use d3.time.scale for display of time scales; 2. Within JSRootCore.js script URL one could specify JSROOT; functionality to be loaded: '2d', '3d', 'io', 'load', 'onload'.; Old method with JSROOT.AssertPrerequisites will also work.; 3. With THttpServer JSROOT now provides simple control functionality.; One could publish commands and execute them from the browser; 4. One could open several ROOT files simultaneously; 5. Add 'simple' layout - drawing uses full space on the right side; 6. Allow to open ROOT files in online session (via url parameter); 7. One could monitor simultaneously objects from server and root files; 8. Implement 'autocol' draw option - when superimposing histograms,; their line colors will be automatically assigned; 9. Implement 'nostat' draw option - disabled stat drawing; 10. Using '_same_' identifier in item name, one can easily draw or superimpose; similar items from different files. Could be used in URL like:; `...&files=[file1.root,file2.root]&items=[file1.root/hpx, file2.root/_same_]`; `...&files=[file1.root,file2.root]&item=file1.root/hpx+file2.root/_same_`; Main limitation - file names should have similar length.; 11. When 'autozoom' specified in draw options, histogram zoomed into; non-empty content. Same command availab",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/changes.md:67215,simpl,simple,67215,js/changes.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/changes.md,1,['simpl'],['simple']
Usability,"de-block:: bash. Kaleidoscope-Ch9 < fib.ks | & clang -x ir -. which gives an a.out/a.exe in the current working directory. Compile Unit; ============. The top level container for a section of code in DWARF is a compile unit.; This contains the type and function data for an individual translation unit; (read: one file of source code). So the first thing we need to do is; construct one for our fib.ks file. DWARF Emission Setup; ====================. Similar to the ``IRBuilder`` class we have a; `DIBuilder <https://llvm.org/doxygen/classllvm_1_1DIBuilder.html>`_ class; that helps in constructing debug metadata for an LLVM IR file. It; corresponds 1:1 similarly to ``IRBuilder`` and LLVM IR, but with nicer names.; Using it does require that you be more familiar with DWARF terminology than; you needed to be with ``IRBuilder`` and ``Instruction`` names, but if you; read through the general documentation on the; `Metadata Format <https://llvm.org/docs/SourceLevelDebugging.html>`_ it; should be a little more clear. We'll be using this class to construct all; of our IR level descriptions. Construction for it takes a module so we; need to construct it shortly after we construct our module. We've left it; as a global static variable to make it a bit easier to use. Next we're going to create a small container to cache some of our frequent; data. The first will be our compile unit, but we'll also write a bit of; code for our one type since we won't have to worry about multiple typed; expressions:. .. code-block:: c++. static std::unique_ptr<DIBuilder> DBuilder;. struct DebugInfo {; DICompileUnit *TheCU;; DIType *DblTy;. DIType *getDoubleTy();; } KSDbgInfo;. DIType *DebugInfo::getDoubleTy() {; if (DblTy); return DblTy;. DblTy = DBuilder->createBasicType(""double"", 64, dwarf::DW_ATE_float);; return DblTy;; }. And then later on in ``main`` when we're constructing our module:. .. code-block:: c++. DBuilder = std::make_unique<DIBuilder>(*TheModule);. KSDbgInfo.TheCU = DBuilder->createC",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl09.rst:6434,clear,clear,6434,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl09.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl09.rst,1,['clear'],['clear']
Usability,"de-block:: llvm. %f.frame = type { ptr, ptr, i32 }. After resume and destroy parts are outlined, function `f` will contain only the; code responsible for creation and initialization of the coroutine frame and; execution of the coroutine until a suspend point is reached:. .. code-block:: llvm. define ptr @f(i32 %n) {; entry:; %id = call token @llvm.coro.id(i32 0, ptr null, ptr null, ptr null); %alloc = call noalias ptr @malloc(i32 24); %frame = call noalias ptr @llvm.coro.begin(token %id, ptr %alloc); %1 = getelementptr %f.frame, ptr %frame, i32 0, i32 0; store ptr @f.resume, ptr %1; %2 = getelementptr %f.frame, ptr %frame, i32 0, i32 1; store ptr @f.destroy, ptr %2. %inc = add nsw i32 %n, 1; %inc.spill.addr = getelementptr inbounds %f.Frame, ptr %FramePtr, i32 0, i32 2; store i32 %inc, ptr %inc.spill.addr; call void @print(i32 %n). ret ptr %frame; }. Outlined resume part of the coroutine will reside in function `f.resume`:. .. code-block:: llvm. define internal fastcc void @f.resume(ptr %frame.ptr.resume) {; entry:; %inc.spill.addr = getelementptr %f.frame, ptr %frame.ptr.resume, i64 0, i32 2; %inc.spill = load i32, ptr %inc.spill.addr, align 4; %inc = add i32 %inc.spill, 1; store i32 %inc, ptr %inc.spill.addr, align 4; tail call void @print(i32 %inc); ret void; }. Whereas function `f.destroy` will contain the cleanup code for the coroutine:. .. code-block:: llvm. define internal fastcc void @f.destroy(ptr %frame.ptr.destroy) {; entry:; tail call void @free(ptr %frame.ptr.destroy); ret void; }. Avoiding Heap Allocations; -------------------------. A particular coroutine usage pattern, which is illustrated by the `main`; function in the overview section, where a coroutine is created, manipulated and; destroyed by the same calling function, is common for coroutines implementing; RAII idiom and is suitable for allocation elision optimization which avoid; dynamic allocation by storing the coroutine frame as a static `alloca` in its; caller. In the entry block, we will c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:15612,resume,resume,15612,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"de](https://root.cern.ch/doc/master/classRooCategory.html). ### Type-safe proxies for RooFit objects; RooFit's proxy classes have been modernised. The class `RooTemplateProxy` allows for access to other RooFit objects; similarly to a smart pointer. In older versions of RooFit, the objects held by *e.g.* `RooRealProxy` had to be; accessed like this:; RooAbsArg* absArg = realProxy.absArg();; RooAbsPdf* pdf = dynamic_cast<RooAbsPdf*>(absArg);; assert(pdf); // This *should* work, but the proxy doesn't have a way to check; pdf->fitTo(...);; That is, a `RooRealProxy` stores a pointer to a RooAbsArg, and this pointer has to be cast. There was no type; safety, *i.e.*, any object deriving from RooAbsArg could be stored in that proxy, and the user had to take care; of ensuring that types are correct.; Now, if one uses; RooTemplateProxy<RooAbsPdf> pdfProxy;; instead of; RooRealProxy realProxy;; in RooFit classes, the above code can be simplified to; pdfProxy->fitTo(...);. Check the [doxygen reference guide](https://root.cern.ch/doc/master/classRooTemplateProxy.html) for `RooTemplateProxy` for; more information on how to modernise old code. ### HistFactory. #### Switch default statistical MC errors to Poisson; When defining HistFactory samples with statistical errors from C++, e.g.; Sample background1( ""background1"", ""background1"", InputFile );; background1.ActivateStatError();; statistical MC errors now have Poisson instead of Gaussian constraints. This better reflects the uncertainty of the MC simulations.; This can be reverted as follows:; // C++:; Channel chan(""channel1"");; chan.SetStatErrorConfig( 0.05, ""Gauss"" );; // Within <Channel ... > XML:; <StatErrorConfig RelErrorThreshold=""0.05"" ConstraintType=""Gauss"" />. #### Less verbose HistFactory; HistFactory was very verbose, writing to the terminal with lots of `cout`. Now, many HistFactory messages are going; into RooFit's message stream number 2. The verbosity can therefore be adjusted using; RooMsgService::instance().getS",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v622/index.md:5014,guid,guide,5014,README/ReleaseNotes/v622/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v622/index.md,1,['guid'],['guide']
Usability,"dencies(TMVA VDT); endif(). if(tmva-cpu); target_include_directories(TMVA PRIVATE ${TBB_INCLUDE_DIRS}); target_link_libraries(TMVA PRIVATE ${TBB_LIBRARIES}); set_target_properties(TMVA PROPERTIES COMPILE_FLAGS ""${TBB_CXXFLAGS}""). if(BLAS_FOUND); target_link_libraries(TMVA PRIVATE ${BLAS_LINKER_FLAGS} ${BLAS_LIBRARIES}); elseif(GSL_FOUND); target_compile_definitions(TMVA PRIVATE -DDNN_USE_CBLAS); target_include_directories(TMVA SYSTEM PRIVATE ${GSL_INCLUDE_DIR}); target_link_libraries(TMVA PRIVATE ${GSL_CBLAS_LIBRARY}); if(builtin_gsl); add_dependencies(TMVA GSL); endif(); else(); message(FATAL_ERROR ""tmva-cpu enabled but neither BLAS nor GSL BLAS were found""); endif(); endif(). if(tmva-gpu); target_sources(TMVA PRIVATE; src/DNN/Architectures/Cuda.cu; src/DNN/Architectures/Cuda/CudaBuffers.cxx; src/DNN/Architectures/Cuda/CudaMatrix.cu; src/DNN/Architectures/Cuda/CudaTensor.cu ); target_link_libraries(TMVA PRIVATE CUDA::cuda_driver CUDA::cublas); if(tmva-cudnn); message(STATUS ""Using Cuda+cuDNN for TMVA Deep Learning on GPU""); target_sources(TMVA PRIVATE; src/DNN/Architectures/Cudnn/TensorDataLoader.cxx; src/DNN/Architectures/Cudnn.cu); target_link_libraries(TMVA PRIVATE ROOT::cuDNN); else(); message(STATUS ""cuDNN not found or disabled - use only Cuda+Cublas for TMVA Deep Learning on GPU""); endif(); endif(tmva-gpu). if(dataframe); ROOT_STANDARD_LIBRARY_PACKAGE(TMVAUtils; NO_INSTALL_HEADERS; HEADERS; TMVA/RTensorUtils.hxx; TMVA/RStandardScaler.hxx; TMVA/RReader.hxx; TMVA/RInferenceUtils.hxx; TMVA/RBDT.hxx; TMVA/RSofieReader.hxx; TMVA/RBatchGenerator.hxx; TMVA/RBatchLoader.hxx; TMVA/RChunkLoader.hxx. SOURCES. src/RBDT.cxx. DEPENDENCIES; TMVA ROOTDataFrame ROOTVecOps; ${TMVA_EXTRA_DEPENDENCIES}. LINKDEF LinkDefUtils.h; DICTIONARY_OPTIONS; -writeEmptyRootPCM. ${EXTRA_DICT_OPTS}; ); endif(). ROOT_ADD_TEST_SUBDIRECTORY(test); ROOT_ADD_TEST_SUBDIRECTORY(test/crossvalidation); ROOT_ADD_TEST_SUBDIRECTORY(test/DNN); ROOT_ADD_TEST_SUBDIRECTORY(test/Method); ROOT_ADD_TEST_SUBDIRE",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/CMakeLists.txt:10571,Learn,Learning,10571,tmva/tmva/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/CMakeLists.txt,1,['Learn'],['Learning']
Usability,"der {; ulittle32_t Version;; ulittle32_t Signature;; ulittle32_t Age;; Guid UniqueId;; };. - **Version** - A Value from the following enum:. .. code-block:: c++. enum class PdbStreamVersion : uint32_t {; VC2 = 19941610,; VC4 = 19950623,; VC41 = 19950814,; VC50 = 19960307,; VC98 = 19970604,; VC70Dep = 19990604,; VC70 = 20000404,; VC80 = 20030901,; VC110 = 20091201,; VC140 = 20140508,; };. While the meaning of this field appears to be obvious, in practice we have; never observed a value other than ``VC70``, even with modern versions of; the toolchain, and it is unclear why the other values exist. It is assumed; that certain aspects of the PDB stream's layout, and perhaps even that of; the other streams, will change if the value is something other than ``VC70``. - **Signature** - A 32-bit time-stamp generated with a call to ``time()`` at; the time the PDB file is written. Note that due to the inherent uniqueness; problems of using a timestamp with 1-second granularity, this field does not; really serve its intended purpose, and as such is typically ignored in favor; of the ``Guid`` field, described below. - **Age** - The number of times the PDB file has been written. This can be used; along with ``Guid`` to match the PDB to its corresponding executable. - **Guid** - A 128-bit identifier guaranteed to be unique across space and time.; In general, this can be thought of as the result of calling the Win32 API; `UuidCreate <https://msdn.microsoft.com/en-us/library/windows/desktop/aa379205(v=vs.85).aspx>`__,; although LLVM cannot rely on that, as it must work on non-Windows platforms. .. _pdb_named_stream_map:. Named Stream Map; ================. Following the header is a serialized hash table whose key type is a string, and; whose value type is an integer. The existence of a mapping ``X -> Y`` means; that the stream with the name ``X`` has stream index ``Y`` in the underlying MSF; file. Note that not all streams are named (for example, the; :doc:`TPI Stream <TpiStream>` ha",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PDB/PdbStream.rst:1403,Guid,Guid,1403,interpreter/llvm-project/llvm/docs/PDB/PdbStream.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PDB/PdbStream.rst,1,['Guid'],['Guid']
Usability,"des in x dimension of grid; int nodesy; // number of nodes in y dimension of grid; int count_reg; // width between contours, applies only for contours display mode; int alfa; // angles of display,alfa+beta must be less or equal to 90, alpha- angle; // between base line of Canvas and left lower edge of picture picture; // base plane; int beta; // angle between base line of Canvas and right lower edge of picture base plane; int view_angle; // rotation angle of the view, it can be 0, 90, 180, 270 degrees; int levels; // # of color levels for rainbowed display modes, it does not apply for; // simple display modes algorithm group; float rainbow1_step; // determines the first component step for neighboring color; // levels, applies only for rainbowed display modes, it does not apply; // for simple display modes algorithm group; float rainbow2_step; // determines the second component step for neighboring; // color levels, applies only for rainbowed display modes, it does not; // apply for simple display modes algorithm group; float rainbow3_step; // determines the third component step for neighboring; // color levels, applies only for rainbowed display modes, it does not; // apply for simple display modes algorithm group; int color_alg; // applies only for rainbowed display modes (rgb smooth algorithm,; // rgb modulo color component, cmy smooth algorithm, cmy modulo; // color component, cie smooth algorithm, cie modulo color component,; // yiq smooth algorithm, yiq modulo color component, hsv smooth; // algorithm, hsv modulo color component, it does not apply for simple; // display modes algorithm group [15]; float l_h_weight; // weight between shading according to fictive light source and; // according to channels counts, applies only for; // PICTURE2_MODE_GROUP_LIGHT_HEIGHT modes group; int xlight; // x position of fictive light source, applies only for rainbowed display; // modes with shading according to light; int ylight; // y position of fictive light source, applies ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:77788,simpl,simple,77788,documentation/spectrum/Spectrum.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md,1,['simpl'],['simple']
Usability,"deserialization of older readers. ## Locators and Envelope Links. A locator is a generalized way to specify a certain byte range on the storage medium.; For disk-based storage, the locator is just byte offset and byte size.; For other storage systems, the locator contains enough information to retrieve the referenced block,; e.g. in object stores, the locator can specify a certain object ID.; The locator has the following format. ```; 0 1 2 3; 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+; | Size |T|; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+; | |; + Offset +; | |; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+; ```. _Size_: If `T` is zero, the number of bytes to read, i.e. the compressed size of the referenced block.; Otherwise, the 16 least-significant bits, i.e. bits 0:15, specify the size of the locator itself (see below). _T(ype)_: Zero for a simple on-disk or in-file locator, 1 otherwise.; Can be interpreted as the sign bit of the size, i.e. negative sizes indicate non-standard locators.; In this case, the locator should be interpreted like a frame, i.e. size indicates the _size of the locator itself_. _Offset_:; For on-disk / in-file locators, the 64bit byte offset of the referenced byte range counted from the start of the file. For non-standard locators, i.e. `T` == 1, the locator format is as follows. ```; 0 1 2 3; 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+; | Size | Reserved | Type |T|; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+; | LOCATOR PAYLOAD |; | ... |; ```. In this case, the last 8 bits of the size should be interpreted as a locator type.; To determine the locator type, the absolute value of the 8bit integer should be taken.; The type can take one of the following values. | Type | Meaning | Payload format |; |------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/BinaryFormatSpecification.md:10042,simpl,simple,10042,tree/ntuple/v7/doc/BinaryFormatSpecification.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/BinaryFormatSpecification.md,1,['simpl'],['simple']
Usability,"detection for a sampled allocation is; transient. To keep memory overhead fixed while still detecting bugs, deallocated; slots are randomly reused to guard future allocations. Usage; =====. GWP-ASan already ships by default in the; `Scudo Hardened Allocator <https://llvm.org/docs/ScudoHardenedAllocator.html>`_,; so building with ``-fsanitize=scudo`` is the quickest and easiest way to try out; GWP-ASan. Options; -------. GWP-ASan's configuration is managed by the supporting allocator. We provide a; generic configuration management library that is used by Scudo. It allows; several aspects of GWP-ASan to be configured through the following methods:. - When the GWP-ASan library is compiled, by setting; ``-DGWP_ASAN_DEFAULT_OPTIONS`` to the options string you want set by default.; If you're building GWP-ASan as part of a compiler-rt/LLVM build, add it during; cmake configure time (e.g. ``cmake ... -DGWP_ASAN_DEFAULT_OPTIONS=""...""``). If; you're building GWP-ASan outside of compiler-rt, simply ensure that you; specify ``-DGWP_ASAN_DEFAULT_OPTIONS=""...""`` when building; ``optional/options_parser.cpp``). - By defining a ``__gwp_asan_default_options`` function in one's program that; returns the options string to be parsed. Said function must have the following; prototype: ``extern ""C"" const char* __gwp_asan_default_options(void)``, with a; default visibility. This will override the compile time define;. - Depending on allocator support (Scudo has support for this mechanism): Through; an environment variable, containing the options string to be parsed. In Scudo,; this is through `SCUDO_OPTIONS=GWP_ASAN_${OPTION_NAME}=${VALUE}` (e.g.; `SCUDO_OPTIONS=GWP_ASAN_SampleRate=100`). Options defined this way will; override any definition made through ``__gwp_asan_default_options``. The options string follows a syntax similar to ASan, where distinct options; can be assigned in the same string, separated by colons. For example, using the environment variable:. .. code:: console. GWP_ASAN",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GwpAsan.rst:5587,simpl,simply,5587,interpreter/llvm-project/llvm/docs/GwpAsan.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GwpAsan.rst,1,['simpl'],['simply']
Usability,"dex = load i8, ptr %index.addr, align 1; %switch = icmp eq i8 %index, 0; %n.addr = getelementptr inbounds %f.Frame, ptr %FramePtr, i64 0, i32 3; %n = load i32, ptr %n.addr, align 4. br i1 %switch, label %loop.resume, label %loop. loop.resume:; %sub = sub nsw i32 0, %n; call void @print(i32 %sub); br label %suspend; loop:; %inc = add nsw i32 %n, 1; store i32 %inc, ptr %n.addr, align 4; tail call void @print(i32 %inc); br label %suspend. suspend:; %storemerge = phi i8 [ 0, %loop ], [ 1, %loop.resume ]; store i8 %storemerge, ptr %index.addr, align 1; ret void; }. If different cleanup code needs to get executed for different suspend points,; a similar switch will be in the `f.destroy` function. .. note ::. Using suspend index in a coroutine state and having a switch in `f.resume` and; `f.destroy` is one of the possible implementation strategies. We explored; another option where a distinct `f.resume1`, `f.resume2`, etc. are created for; every suspend point, and instead of storing an index, the resume and destroy; function pointers are updated at every suspend. Early testing showed that the; current approach is easier on the optimizer than the latter so it is a; lowering strategy implemented at the moment. Distinct Save and Suspend; -------------------------. In the previous example, setting a resume index (or some other state change that; needs to happen to prepare a coroutine for resumption) happens at the same time as; a suspension of a coroutine. However, in certain cases, it is necessary to control; when coroutine is prepared for resumption and when it is suspended. In the following example, a coroutine represents some activity that is driven; by completions of asynchronous operations `async_op1` and `async_op2` which get; a coroutine handle as a parameter and resume the coroutine once async; operation is finished. .. code-block:: text. void g() {; for (;;); if (cond()) {; async_op1(<coroutine-handle>); // will resume once async_op1 completes; <suspend>; do_one();; }",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:20273,resume,resume,20273,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"diately preceding; the `coro.suspend` intrinsic. The second argument indicates whether this suspension point is `final`_.; The second argument only accepts constants. If more than one suspend point is; designated as final, the resume and destroy branches should lead to the same; basic blocks. Example (normal suspend point):; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". .. code-block:: llvm. %0 = call i8 @llvm.coro.suspend(token none, i1 false); switch i8 %0, label %suspend [i8 0, label %resume; i8 1, label %cleanup]. Example (final suspend point):; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""". .. code-block:: llvm. while.end:; %s.final = call i8 @llvm.coro.suspend(token none, i1 true); switch i8 %s.final, label %suspend [i8 0, label %trap; i8 1, label %cleanup]; trap:; call void @llvm.trap(); unreachable. Semantics:; """""""""""""""""""". If a coroutine that was suspended at the suspend point marked by this intrinsic; is resumed via `coro.resume`_ the control will transfer to the basic block; of the 0-case. If it is resumed via `coro.destroy`_, it will proceed to the; basic block indicated by the 1-case. To suspend, coroutine proceed to the; default label. If suspend intrinsic is marked as final, it can consider the `true` branch; unreachable and can perform optimizations that can take advantage of that fact. .. _coro.save:. 'llvm.coro.save' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; ::. declare token @llvm.coro.save(ptr <handle>). Overview:; """""""""""""""""". The '``llvm.coro.save``' marks the point where a coroutine need to update its; state to prepare for resumption to be considered suspended (and thus eligible; for resumption). It is illegal to merge two '``llvm.coro.save``' calls unless their; '``llvm.coro.suspend``' users are also merged. So '``llvm.coro.save``' is currently; tagged with the `no_merge` function attribute. Arguments:; """""""""""""""""""". The first argument points to a coroutine handle of the enclosing coroutine. Semantics:; """""""""""""""""""". Whatever coroutine state changes are required to e",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:51344,resume,resumed,51344,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resumed']
Usability,"ding in ``\`` are concatenated until a RUN line that doesn't end in; ``\`` is found. This concatenated set of RUN lines then constitutes one; execution. :program:`lit` will substitute variables and arrange for the pipeline; to be executed. If any process in the pipeline fails, the entire line (and; test case) fails too. Below is an example of legal RUN lines in a ``.ll`` file:. .. code-block:: llvm. ; RUN: llvm-as < %s | llvm-dis > %t1; ; RUN: llvm-dis < %s.bc-13 > %t2; ; RUN: diff %t1 %t2. As with a Unix shell, the RUN lines permit pipelines and I/O; redirection to be used. There are some quoting rules that you must pay attention to when writing; your RUN lines. In general nothing needs to be quoted. :program:`lit` won't; strip off any quote characters so they will get passed to the invoked program.; To avoid this use curly braces to tell :program:`lit` that it should treat; everything enclosed as one value. In general, you should strive to keep your RUN lines as simple as possible,; using them only to run tools that generate textual output you can then examine.; The recommended way to examine output to figure out if the test passes is using; the :doc:`FileCheck tool <CommandGuide/FileCheck>`. *[The usage of grep in RUN; lines is deprecated - please do not send or commit patches that use it.]*. Put related tests into a single file rather than having a separate file per; test. Check if there are files already covering your feature and consider; adding your code there instead of creating a new file. Generating assertions in regression tests; -----------------------------------------. Some regression test cases are very large and complex to write/update by hand.; In that case to reduce the human work we can use the scripts available in; llvm/utils/ to generate the assertions. For example to generate assertions in an :program:`llc`-based test, after; adding one or more RUN lines use:. .. code-block:: bash. % llvm/utils/update_llc_test_checks.py --llc-binary build/bin/ll",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst:10603,simpl,simple,10603,interpreter/llvm-project/llvm/docs/TestingGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst,1,['simpl'],['simple']
Usability,"dir LINKDEF LinkDef.h)` *if* the header is usually included as; `#include ""Header1.h""`, or to `ROOT_GENERATE_DICTIONARY(Dict subdir/Header1.h LINKDEF LinkDef.h)` *if* the header is usually; included as `#include ""subdir/Header1.h""`. I.e. the general rule is: pass to `ROOT_GENERATE_DICTIONARY` (or; `ROOT_STANDARD_LIBRARY_PACKAGE`) the spelling as `#include`ed. As an important side-effect, `ROOT_GENERATE_DICTIONARY` and thus `ROOT_STANDARD_LIBRARY_PACKAGE` now *require* the header to; be found at configuration time. We have seen too many cases where the header location was mis-stated, and as a consequence,; CMake did not generate the proper dependencies. If the header should not be taken into account for dependencies and / or if; the header will not be found (e.g. the standard library's `vector`) please pass the header through the `NODEPHEADERS` option; to `ROOT_GENERATE_DICTIONARY` or `ROOT_STANDARD_LIBRARY_PACKAGE`. We believe that this simplification / regularization of behavior, and the additional checks are worth the possible changes; on the user side. ## PyROOT. If the fix or new feature is a pythonization related to a C++ class, the change is added to the respective section above. ### Current PyROOT. - Fix compatibility with Python3.7 (ROOT-9922, ROOT-9871, ROOT-9809); - Fix lookup for templated methods (ROOT-9789); - Fix lookup for templated free functions (ROOT-9836). ### Experimental PyROOT. - All pythonisations from current PyROOT already migrated (`TTree` and subclasses, `TDirectory` and subclasses,; `TCollection` and subclasses, `TObject`, `TClass`, `TString`, `TObjString`, `TIter`, `TStyle`, `TH1`, `TFX`, `TMinuit`, `TVector3`,; `TVectorT`, `TArray`, `TCollection`, `TSeqCollection`, `TClonesArray`, `TComplex`, `TGraph`, `RooDataHist`) - ROOT-9510; - Cppyy updated to cppyy 1.4.7, cppyy-backend 1.8.1 (clingwrapper), CPyCppyy 1.7.1; * Includes fixed template support, fixed overload resolution, Windows fixes and other; - Merged Cppyy's patch to support using",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v618/index.md:25782,simpl,simplification,25782,README/ReleaseNotes/v618/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v618/index.md,1,['simpl'],['simplification']
Usability,"dium) . Floating-point support.; Currently, the analyzer treats all floating-point values as unknown.; This project would involve adding a new SVal kind; for constant floats, generalizing the constraint manager to handle floats,; and auditing existing code to make sure it doesn't; make incorrect assumptions (most notably, that X == X; is always true, since it does not hold for NaN).; (Difficulty: Medium). Improved loop execution modeling.; The analyzer simply unrolls each loop N times before; dropping the path, for a fixed constant N.; However, that results in lost coverage in cases where the loop always; executes more than N times.; A Google Summer Of Code; project; was completed to make the loop bound parameterizable,; but the widening; problem still remains open. (Difficulty: Hard). Basic function summarization support; The analyzer performs inter-procedural analysis using; either inlining or ""conservative evaluation"" (invalidating all data; passed to the function).; Often, a very simple summary; (e.g. ""this function is pure"") would be; enough to be a large improvement over conservative evaluation.; Such summaries could be obtained either syntactically,; or using a dataflow framework.; (Difficulty: Hard). Implement a dataflow flamework.; The analyzer core; implements a symbolic execution; engine, which performs checks; (use-after-free, uninitialized value read, etc.); over a single program path.; However, many useful properties; (dead code, check-after-use, etc.) require; reasoning over all possible in a program.; Such reasoning requires a; dataflow analysis framework.; Clang already implements; a few dataflow analyses (most notably, liveness),; but they implemented in an ad-hoc fashion.; A proper framework would enable us writing many more useful checkers.; (Difficulty: Hard) . Track type information through casts more precisely.; The DynamicTypePropagation; checker is in charge of inferring a region's; dynamic type based on what operations the code is performing",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/open_projects.html:7506,simpl,simple,7506,interpreter/llvm-project/clang/www/analyzer/open_projects.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/open_projects.html,1,['simpl'],['simple']
Usability,"dominator tree alongside any transformations, but other analysis results may be invalid.; PreservedAnalyses PA;; PA.preserve<DominatorAnalysis>();; return PA;. // We haven't made any control flow changes, any analyses that only care about the control flow are still valid.; PreservedAnalyses PA;; PA.preserveSet<CFGAnalyses>();; return PA;. The pass manager will call the analysis manager's ``invalidate()`` method; with the pass's returned ``PreservedAnalyses``. This can be also done; manually within the pass:. .. code-block:: c++. FooModulePass::run(Module& M, ModuleAnalysisManager& AM) {; auto &FAM = AM.getResult<FunctionAnalysisManagerModuleProxy>(M).getManager();. // Invalidate all analysis results for function F1.; FAM.invalidate(F1, PreservedAnalyses::none());. // Invalidate all analysis results across the entire module.; AM.invalidate(M, PreservedAnalyses::none());. // Clear the entry in the analysis manager for function F2 if we've completely removed it from the module.; FAM.clear(F2);. ...; }. One thing to note when accessing inner level IR analyses is cached results for; deleted IR. If a function is deleted in a module pass, its address is still used; as the key for cached analyses. Take care in the pass to either clear the; results for that function or not use inner analyses at all. ``AM.invalidate(M, PreservedAnalyses::none());`` will invalidate the inner; analysis manager proxy which will clear all cached analyses, conservatively; assuming that there are invalid addresses used as keys for cached analyses.; However, if you'd like to be more selective about which analyses are; cached/invalidated, you can mark the analysis manager proxy as preserved,; essentially saying that all deleted entries have been taken care of manually.; This should only be done with measurable compile time gains as it can be tricky; to make sure all the right analyses are invalidated. Implementing Analysis Invalidation; ==================================. By default, an analysis is in",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NewPassManager.rst:14001,clear,clear,14001,interpreter/llvm-project/llvm/docs/NewPassManager.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NewPassManager.rst,1,['clear'],['clear']
Usability,"don't currently merge them together. For; example, it is useful to merge memcpy(a,b,strlen(b)) -> strcpy. This can only; be done safely if ""b"" isn't modified between the strlen and memcpy of course. //===---------------------------------------------------------------------===//. We compile this program: (from GCC PR11680); http://gcc.gnu.org/bugzilla/attachment.cgi?id=4487. Into code that runs the same speed in fast/slow modes, but both modes run 2x; slower than when compile with GCC (either 4.0 or 4.2):. $ llvm-g++ perf.cpp -O3 -fno-exceptions; $ time ./a.out fast; 1.821u 0.003s 0:01.82 100.0%	0+0k 0+0io 0pf+0w. $ g++ perf.cpp -O3 -fno-exceptions; $ time ./a.out fast; 0.821u 0.001s 0:00.82 100.0%	0+0k 0+0io 0pf+0w. It looks like we are making the same inlining decisions, so this may be raw; codegen badness or something else (haven't investigated). //===---------------------------------------------------------------------===//. Divisibility by constant can be simplified (according to GCC PR12849) from; being a mulhi to being a mul lo (cheaper). Testcase:. void bar(unsigned n) {; if (n % 3 == 0); true();; }. This is equivalent to the following, where 2863311531 is the multiplicative; inverse of 3, and 1431655766 is ((2^32)-1)/3+1:; void bar(unsigned n) {; if (n * 2863311531U < 1431655766U); true();; }. The same transformation can work with an even modulo with the addition of a; rotate: rotate the result of the multiply to the right by the number of bits; which need to be zero for the condition to be true, and shrink the compare RHS; by the same amount. Unless the target supports rotates, though, that; transformation probably isn't worthwhile. The transformation can also easily be made to work with non-zero equality; comparisons: just transform, for example, ""n % 3 == 1"" to ""(n-1) % 3 == 0"". //===---------------------------------------------------------------------===//. Better mod/ref analysis for scanf would allow us to eliminate the vtable and a; bunch of other stuf",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt:19527,simpl,simplified,19527,interpreter/llvm-project/llvm/lib/Target/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt,1,['simpl'],['simplified']
Usability,"drag it to the; desired position. ``` {.cpp}; fSlider = new TGTripleHSlider(parent,100,kDoubleScaleBoth,kSLD_ID,; kHorizontalFrame);; parent->AddFrame(fSlider,new TGLayoutHints(kLHintsExpandX,5,5,5,5));; fSlider->SetConstrained(kTRUE);; fSlider->SetRange(rmin, rmax);; fSlider->SetPosition(pmin, pmax);; fSlider ->SetPointerPosition(pvalue);; ```. ### Progress Bars. A progress bar is a widget that shows that an operation is in progress; and how much time is left. It is a long rectangular bar, initially; empty, that fills with a color as a process is being performed. The; filled-in area indicates the percentage of the process that has been; completed. You should use this widget for waits exceeding `one minute`.; For a very time consuming operation it is better to break the operation; into subtasks and provide a progress bar for each of them. ![](pictures/0200021E.jpg). A progress bar may be oriented horizontally or vertically. The; horizontally oriented progress bar fills with a color from left to; right; the vertically oriented - from bottom to top. A percent complete; message provides an indication of the completed part of the process. It; is a good practice to include some descriptive text of the process to; keep users informed and entertained while they are waiting for process; completion. The picture below shows the progress bars you can create using the; classes **`TGProgressBar`**, **`TGHProgressBar`**, and; **`TGHProgressBar`**. ``` {.cpp}; // vertical frame with three horizontal progressive bars; TGVerticalFrame *vframe = new TGVerticalFrame(fMain, 10, 10);; fHProg1 = new TGHProgressBar(vframe,TGProgressBar::kStandard,300);; fHProg1->ShowPosition();; fHProg1->SetBarColor(""yellow"");; fHProg2 = new TGHProgressBar(vframe,TGProgressBar::kFancy,300);; fHProg2->SetBarColor(""lightblue"");; fHProg2->ShowPosition(kTRUE,kFALSE,""%.0f events"");; fHProg3 = new TGHProgressBar(vframe,TGProgressBar::kStandard,300);; fHProg3->SetFillType(TGProgressBar::kBlockFill);. vframe->Add",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:88351,progress bar,progress bar,88351,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,1,['progress bar'],['progress bar']
Usability,"dress space to be user accessible may need to adjust the exact sequence used; above. Additionally, the low addresses will need to be marked unreadable by the; OS to fully harden the load. ###### RIP-relative addressing is even easier to break. There is a common addressing mode idiom that is substantially harder to check:; addressing relative to the instruction pointer. We cannot change the value of; the instruction pointer register and so we have the harder problem of forcing; `%base + scale * %index + offset` to be an invalid address, by *only* changing; `%index`. The only advantage we have is that the attacker also cannot modify; `%base`. If we use the fast instruction sequence above, but only apply it to; the index, we will always access `%rip + (scale * -1) + offset`. If the; attacker can find a load which with this address happens to point to secret; data, then they can reach it. However, the loader and base libraries can also; simply refuse to map the heap, data segments, or stack within 2gb of any of the; text in the program, much like it can reserve the low 2gb of address space. ###### The flag registers again make everything hard. Unfortunately, the technique of using `orq`-instructions has a serious flaw on; x86. The very thing that makes it easy to accumulate state, the flag registers; containing predicates, causes serious problems here because they may be alive; and used by the loading instruction or subsequent instructions. On x86, the; `orq` instruction **sets** the flags and will override anything already there.; This makes inserting them into the instruction stream very hazardous.; Unfortunately, unlike when hardening the loaded value, we have no fallback here; and so we must have a fully general approach available. The first thing we must do when generating these sequences is try to analyze; the surrounding code to prove that the flags are not in fact alive or being; used. Typically, it has been set by some other instruction which just happens; to s",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md:31010,simpl,simply,31010,interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,1,['simpl'],['simply']
Usability,"ds the precedence for each binary operator that is; /// defined.; static std::map<char, int> BinopPrecedence;. /// GetTokPrecedence - Get the precedence of the pending binary operator token.; static int GetTokPrecedence() {; if (!isascii(CurTok)); return -1;. // Make sure it's a declared binop.; int TokPrec = BinopPrecedence[CurTok];; if (TokPrec <= 0) return -1;; return TokPrec;; }. int main() {; // Install standard binary operators.; // 1 is lowest precedence.; BinopPrecedence['<'] = 10;; BinopPrecedence['+'] = 20;; BinopPrecedence['-'] = 20;; BinopPrecedence['*'] = 40; // highest.; ...; }. For the basic form of Kaleidoscope, we will only support 4 binary; operators (this can obviously be extended by you, our brave and intrepid; reader). The ``GetTokPrecedence`` function returns the precedence for; the current token, or -1 if the token is not a binary operator. Having a; map makes it easy to add new operators and makes it clear that the; algorithm doesn't depend on the specific operators involved, but it; would be easy enough to eliminate the map and do the comparisons in the; ``GetTokPrecedence`` function. (Or just use a fixed-size array). With the helper above defined, we can now start parsing binary; expressions. The basic idea of operator precedence parsing is to break; down an expression with potentially ambiguous binary operators into; pieces. Consider, for example, the expression ""a+b+(c+d)\*e\*f+g"".; Operator precedence parsing considers this as a stream of primary; expressions separated by binary operators. As such, it will first parse; the leading primary expression ""a"", then it will see the pairs [+, b]; [+, (c+d)] [\*, e] [\*, f] and [+, g]. Note that because parentheses are; primary expressions, the binary expression parser doesn't need to worry; about nested subexpressions like (c+d) at all. To start, an expression is a primary expression potentially followed by; a sequence of [binop,primaryexpr] pairs:. .. code-block:: c++. /// expression; /// ::= pr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst:13747,clear,clear,13747,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst,1,['clear'],['clear']
Usability,"duce type of Float_t branches when jitting.; - Do not rely on branches' titles for runtime type inference.; - Do not loose an entry when using Range and multiple actions. #### Other changes; - Throw an exception if the type of a branch cannot be deduced. ## Histogram Libraries; - Per object statsoverflow flag has been added. This change is required to prevent non reproducible behaviours in a multithreaded environments. For example, if several threads change the; `TH1::fgStatOverflows` flag and fill histograms, the behaviour will be undefined.; - A fix has been added in resetting the statistics of histograms with label. The bug was causing the histogram entries to be set as zero and this was making failing the merging of those; histogram (see ROOT-9336). . ## Math Libraries. ## RooFit Libraries. - A fix has been added in the component selection, which is used for plotting simultaneous models. See [PR #2033](https://github.com/root-project/root/pull/2033). ## TMVA Library. #### New Deep Learning Module. - TMVA contains a new set of Deep Learning classes ( `MethodDL` ), with support, in addition to dense layer, also convolutional and recurrent layer. . #### Other New TMVA Features. - Support for Parallelization of BDT using Multi-Threads; - Several improvements in Cross Validation including support for Multi-Process cross-validation running. . ## 2D Graphics Libraries; - `TMultiGraph::GetHistogram` now works even if the multigraph is not drawn. Make sure; it never returns a null pointer.; - X11 line `width = 0` doesn't work on OpenSuSE Thumbleweed for non solid lines. Now fixed.; - TCanvas::SetWindowsSize has been changed to get the same window size in interactive mode…and batch mode.; - Change the `TGraph` default fill color to white to avoid black box in legend; when `gPad->BuildLegend()` is called.; - Auto-coloring for TF1 (drawing options PFC, PLC and PMC) is implemented.; - Auto-coloring for TH1::DrawCopy (drawing options PFC, PLC and PMC) is implemented.; - Improv",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v614/index.md:11536,Learn,Learning,11536,README/ReleaseNotes/v614/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v614/index.md,1,['Learn'],['Learning']
Usability,"duction guide declarations; that have an explicit specifier if this explicit specifier is resolved to; true. Given; template<bool b>; struct S {; S(int); // #1; explicit S(double); // #2; operator int(); // #3; explicit operator bool(); // #4; explicit(false) S(bool) // # 7; explicit(true) S(char) // # 8; explicit(b) S(S) // # 9; };; S(int) -> S<true> // #5; explicit S(double) -> S<false> // #6; cxxConstructorDecl(isExplicit()) will match #2 and #8, but not #1, #7 or #9.; cxxConversionDecl(isExplicit()) will match #4, but not #3.; cxxDeductionGuideDecl(isExplicit()) will match #6, but not #5. Matcher<CXXConstructorDecl>isInheritingConstructor. Matcher<CXXConstructorDecl>isMoveConstructor; Matches constructor declarations that are move constructors. Given; struct S {; S(); // #1; S(const S &); // #2; S(S &&); // #3; };; cxxConstructorDecl(isMoveConstructor()) will match #3, but not #1 or #2. Matcher<CXXConversionDecl>isExplicit; Matches constructor, conversion function, and deduction guide declarations; that have an explicit specifier if this explicit specifier is resolved to; true. Given; template<bool b>; struct S {; S(int); // #1; explicit S(double); // #2; operator int(); // #3; explicit operator bool(); // #4; explicit(false) S(bool) // # 7; explicit(true) S(char) // # 8; explicit(b) S(S) // # 9; };; S(int) -> S<true> // #5; explicit S(double) -> S<false> // #6; cxxConstructorDecl(isExplicit()) will match #2 and #8, but not #1, #7 or #9.; cxxConversionDecl(isExplicit()) will match #4, but not #3.; cxxDeductionGuideDecl(isExplicit()) will match #6, but not #5. Matcher<CXXCtorInitializer>isBaseInitializer; Matches a constructor initializer if it is initializing a base, as; opposed to a member. Given; struct B {};; struct D : B {; int I;; D(int i) : I(i) {}; };; struct E : B {; E() : B() {}; };; cxxConstructorDecl(hasAnyConstructorInitializer(isBaseInitializer())); will match E(), but not match D(int). Matcher<CXXCtorInitializer>isMemberInitializer; Matches a constr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:62228,guid,guide,62228,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['guid'],['guide']
Usability,"e **curl** program since only curl correctly implements such authentication method. The command will look like:. ```bash; [shell] curl --user ""accout:password"" http://localhost:8080/Objects/subfolder/obj/root.json --digest -o root.json; ```. ### Objects data access in JSON format. Request `root.json` implemented with [TBufferJSON](https://root.cern/doc/master/classTBufferJSON.html) class. TBufferJSON generates such object representation, which could be directly used in [JSROOT](https://root.cern/js/) for drawing. `root.json` request returns either complete object or just object member like:. ```bash; [shell] wget http://localhost:8080/Objects/subfolder/obj/fTitle/root.json; ```. The result will be: `""title""`. For the `root.json` request one could specify the 'compact' parameter, which allow to reduce the number of spaces and new lines without data lost. This parameter can have values from '0' (no compression) till '3' (no spaces and new lines at all).; In addition, one can use simple compression algorithm for big arrays. If compact='10', zero values in the begin and at the end; of the array will be excluded. If compact='20', similar values or large zero gaps in-between will be compressed. Such array; compression support in JSROOT from version 4.8.2. Usage of `root.json` request is about as efficient as binary `root.bin` request. Comparison of different request methods with TH2 histogram from hsimple.C shown in the table:. | Request | Size |; | :---------------------- | :--------- |; | root.bin | 7672 bytes |; | root.bin.gz | 1582 bytes |; | root.json | 8570 bytes |; | root.json?compact=3 | 6004 bytes |; | root.json?compact=23 | 5216 bytes |; | root.json.gz?compact=23 | 1855 bytes |. One should remember that JSON representation always includes names of the data fields which are not present in the binary representation. Even then the size difference is negligible. `root.json` used in JSROOT to request objects from THttpServer. ### Generating images out of objects. For ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/HttpServer/HttpServer.md:17218,simpl,simple,17218,documentation/HttpServer/HttpServer.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/HttpServer/HttpServer.md,1,['simpl'],['simple']
Usability,"e *G* was used we; also have alias to *F*. 4. Set *F* linkage to private. Make it strong :-). No global aliases, replaceDirectCallers; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; If global aliases are not supported. We call ``replaceDirectCallers``. Just; go through all calls of *G* and replace it with calls of *F*. If you look into; the method you will see that it scans all uses of *G* too, and if use is callee; (if user is call instruction and *G* is used as what to be called), we replace; it with use of *F*. If “F” could not be overridden, fix it!; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". We call ``writeThunkOrAlias(Function *F, Function *G)``. Here we try to replace; *G* with alias to *F* first. The next conditions are essential:. * target should support global aliases,; * the address itself of *G* should be not significant, not named and not; referenced anywhere,; * function should come with external, local or weak linkage. Otherwise we write thunk: some wrapper that has *G's* interface and calls *F*,; so *G* could be replaced with this wrapper. *writeAlias*. As follows from *llvm* reference:. “Aliases act as *second name* for the aliasee value”. So we just want to create; a second name for *F* and use it instead of *G*:. 1. create global alias itself (*GA*),. 2. adjust alignment of *F* so it must be maximum of current and *G's* alignment;. 3. replace uses of *G*:. 3.1. first mark all callers of *G* as to-be-analyzed-again, using; ``removeUsers`` method (see chapter above),. 3.2. call ``G->replaceAllUsesWith(GA)``. 4. Get rid of *G*. *writeThunk*. As it written in method comments:. “Replace G with a simple tail call to bitcast(F). Also replace direct uses of G; with bitcast(F). Deletes G.”. In general it does the same as usual when we want to replace callee, except the; first point:. 1. We generate tail call wrapper around *F*, but with interface that allows use; it instead of *G*. 2. “As-usual”: ``removeUsers`` and ``replaceAllUsesWith`` then. 3. Get rid of *G*. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MergeFunctions.rst:30967,simpl,simple,30967,interpreter/llvm-project/llvm/docs/MergeFunctions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MergeFunctions.rst,1,['simpl'],['simple']
Usability,"e / disable the drawing with ‘*Show'*; checkbox. Enter X/Y/Z position in the edit boxes to set position.; Initial position is at the center of the scene. Set the guides using `TGLViewer::SetGuideState` e.g. to enable edge; axes, and enable a reference marker at world position 50, 60, 100:. ``` {.cpp}; Double_t refPos[3] = {50.0,60.0,100.0};; v->SetGuideState(TGLUtil::kAxesEdge, kTRUE, refPos);; ```. #### Selecting Scene Shapes. You can select a single shape from your scene by pressing ‘Shift' key,; pointing and left clicking anywhere on the shape in the viewer.; Selection is currently shown by drawing the shape-bounding box (not; depth clipped) in white (polygon or wire frame render styles) or red; (outline render style). Manipulators supported by the shape are drawn in; red, green and blue while the non-supported ones are drawn in grey. To; deselect a shape, either select another, or shift/click anywhere on the; background (empty space) in the viewer. You cannot select Manipulators; or Guides (Axes / Reference Marker). #### Editing Shapes. When a shape is selected, the viewer's control pane shows the user; interface that allows you to review and adjust the color and geometry; properties of the shape. Note: At present modifications to the shapes are local to the viewer -; they are not propagated back to external objects/client that published; to the viewer. The changes are preserved only until the viewer is; closed. In some cases, this will never be feasible as there is not a; one-to-one correspondence between a shape in the viewer and a single; external object in which the modification could be stored. #### Colors / Style. Viewer Controls Pane ‘Style' tab. A full description of OpenGL materials, colors and lighting is beyond; the scope of this document. You should refer to the OpenGL programming; manual (Red Book) for a full discussion. In most cases adjustment of the; Diffuse color material + Opacity/Shine properties is sufficient to; achieve desired results. A sha",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:119047,Guid,Guides,119047,documentation/users-guide/Graphics.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md,1,['Guid'],['Guides']
Usability,"e Canal, FNAL,\; Jolly Chen, CERN/EP-SFT,\; Olivier Couet, CERN/EP-SFT,\; Marta Czurylo, CERN/EP-SFT,\; Monica Dessole, CERN/EP-SFT,\; Mattias Ellert, Uppsala University,\; Gerri Ganis, CERN/EP-SFT,\; Florine de Geus, CERN/University of Twente,\; Andrei Gheata, CERN/EP-SFT,\; Bernhard Manfred Gruber,\; Enrico Guiraud,; Jonas Hahnfeld, CERN/Goethe University Frankfurt,\; Fernando Hueso Gonzalez, University of Valencia\; Attila Krasznahorkay, CERN/EP-ADP-OS,\; Wim Lavrijsen, LBL,\; Dennis Klein, GSI,\; Christoph Langenbruch, Heidelberg University/LHCb,\; Sergey Linev, GSI,\; Javier Lopez-Gomez,\; Pere Mato, CERN/EP-SFT,\; Alaettin Serhan Mete, Argonne,\; Thomas Madlener, DESY,\; Lorenzo Moneta, CERN/EP-SFT,\; Alja Mrak Tadel, UCSD/CMS,\; Axel Naumann, CERN/EP-SFT,\; Dante Niewenhuis, VU Amsterdam\; Luis Antonio Obis Aparicio, University of Zaragoza,; Ianna Osborne, Princeton University,\; Vincenzo Eduardo Padulano, CERN/EP-SFT,\; Danilo Piparo, CERN/EP-SFT,\; Fons Rademakers, CERN/IT,\; Jonas Rembser, CERN/EP-SFT,\; Andrea Rizzi, University of Pisa,\; Andre Sailer, CERN/EP-SFT,\; Garima Singh, ETH,\; Juraj Smiesko, CERN/RCS-PRJ-FC,; Pavlo Svirin, National Technical University of Ukraine,\; Maciej Szymanski, Argonne,\; Christian Tacke, Darmstadt University,\; Matevz Tadel, UCSD/CMS,\; Alvaro Tolosa Delgado, CERN/RCS-PRJ-FC,\; Devajith Valaparambil Sreeramaswamy, CERN/EP-SFT,\; Peter Van Gemmeren, Argonne,\; Vassil Vassilev, Princeton/CMS,\; Wouter Verkerke, NIKHEF/ATLAS,; Stefan Wunsch. ## Deprecation and Removal. ## Core Libraries. ## I/O Libraries. ## TTree Libraries. ## Histogram Libraries. ## Math Libraries. ## RooFit Libraries. ## Graphics Backends. ## 2D Graphics Libraries. ## 3D Graphics Libraries. ## Geometry Libraries. ## Database Libraries. ## Networking Libraries. ## GUI Libraries. ## Montecarlo Libraries. ## PROOF Libraries. ## Language Bindings. ## JavaScript ROOT. ## Tutorials. ## Class Reference Guide. ## Build, Configuration and Testing Infrastructure. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/empty.md:2458,Guid,Guide,2458,README/ReleaseNotes/empty.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/empty.md,1,['Guid'],['Guide']
Usability,"e `RooFitLegacy/RooCatTypeLegacy.h`.; - The `RooAbsString` that was only an alias for `RooStringVar` got removed.; - The `RooDataWeightedAverage` is now deprecated and will be removed in 6.32. It was only supposed to be an implementation detail of RooFits plotting that is now not necessary anymore.; - The `RooSpan` class was removed and its place in the implementation details of RooFit is now taken by `std::span`.; - The `RooAbsArg::isCloneOf()` and `RooAbsArg::getCloningAncestors()` member functions were removed because they didn't work (always returned `false` and an empty list respectively); - `ROOT::Math::KelvinFunctions` had an incompatible license and needed to be removed without deprecation.; - The use of `ROOT_GIT_BRANCH` and `ROOT_GIT_COMMIT` have been deprecated in favor of parsing `etc/gitinfo.txt`. This later file is now generated as part of the build of ROOT; `RGitCommit.h` (defining `ROOT_GIT_BRANCH` and `ROOT_GIT_COMMIT`) is not updated anymore. This simplifies ROOT's build and release procedure. ## Core Libraries. - Increase thread-safety in parts of core libraries (TCling, TClingMethodInfo, TClingTypeInfo, TFunction) to allow for parallel workflows using RDataFrame in multiple C++ `std::thread`s. ## I/O Libraries. - Improve parsing of input argument to `TChain::Add`. Now it supports the case of globbing files while also using the `?#` token to specify the tree name. ## RDataFrame; - instead of returning nothing, `ROOT::RDF::RunGraphs` now returns the number of separate computation graphs that have been run. - Introduce [`ProgressBar`](https://root.cern/doc/master/classROOT_1_1RDataFrame.html#progressbar) feature that can be added to any RDataFrame program. - The `RDatasetSpec` class and its users now employ the concept of 'sample' rather than the original naming 'group' for groups of files with associated metadata. - `df106_HiggsToFourLeptons` tutorials (both python and C++) now showcase the `ProgressBar`. They now use `FromSpec` to define multiple ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v630/index.md:4417,simpl,simplifies,4417,README/ReleaseNotes/v630/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v630/index.md,1,['simpl'],['simplifies']
Usability,"e a token value produced by; '``llvm.coro.end.results``' intrinsic. Only none token is allowed for coro.end calls in unwind sections. Semantics:; """"""""""""""""""""; The purpose of this intrinsic is to allow frontends to mark the cleanup and; other code that is only relevant during the initial invocation of the coroutine; and should not be present in resume and destroy parts. In returned-continuation lowering, ``llvm.coro.end`` fully destroys the; coroutine frame. If the second argument is `false`, it also returns from; the coroutine with a null continuation pointer, and the next instruction; will be unreachable. If the second argument is `true`, it falls through; so that the following logic can resume unwinding. In a yield-once; coroutine, reaching a non-unwind ``llvm.coro.end`` without having first; reached a ``llvm.coro.suspend.retcon`` has undefined behavior. The remainder of this section describes the behavior under switched-resume; lowering. This intrinsic is lowered when a coroutine is split into; the start, resume and destroy parts. In the start part, it is a no-op,; in resume and destroy parts, it is replaced with `ret void` instruction and; the rest of the block containing `coro.end` instruction is discarded.; In landing pads it is replaced with an appropriate instruction to unwind to; caller. The handling of coro.end differs depending on whether the target is; using landingpad or WinEH exception model. For landingpad based exception model, it is expected that frontend uses the; `coro.end`_ intrinsic as follows:. .. code-block:: llvm. ehcleanup:; %InResumePart = call i1 @llvm.coro.end(ptr null, i1 true, token none); br i1 %InResumePart, label %eh.resume, label %cleanup.cont. cleanup.cont:; ; rest of the cleanup. eh.resume:; %exn = load ptr, ptr %exn.slot, align 8; %sel = load i32, ptr %ehselector.slot, align 4; %lpad.val = insertvalue { ptr, i32 } undef, ptr %exn, 0; %lpad.val29 = insertvalue { ptr, i32 } %lpad.val, i32 %sel, 1; resume { ptr, i32 } %lpad.val29. The",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:44233,resume,resume,44233,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"e a virtual method one is involved; (instead of having C++ hide it for you behind ""syntactic sugar""). > And the old array syntax:; > type [ int, int, ...]; > is just much more familiar and clear to people than anything new you; > introduce, no matter how logical it is. . Erm... excuse me but how is this the ""old array syntax""? If you are; arguing for consistency with C, you should be asking for 'type int []',; which is significantly different than the above (beside the above; introduces a new operator and duplicates information; needlessly). Basically what I am suggesting is exactly the above without; the fluff. So instead of:. type [ int, int, ...]. you use:. type [ int ]. > Introducing a new syntax that may; > make function pointers easier but makes arrays much more difficult seems; > very risky to me. This is not about function pointers. This is about consistency in the; type system, and consistency with the rest of the language. The point; above does not make arrays any more difficult to use, and makes the; structure of types much more obvious than the ""c way"". > > In my opinion, it is critically important to have clear and concise type; > > specifications, because types are going to be all over the programs.; > ; > I absolutely agree. But the question is, what is more clear and concise?; > The syntax programmers are used to out of years of experience or a new; > syntax that they have never seen that has a more logical structure. I think; > the answer is the former. Sometimes, you have to give up a better idea; > because you can't overcome sociological barriers to it. Qwerty keyboards; > and Windows are two classic examples of bad technology that are difficult to; > root out. Very true, but you seem to be advocating a completely different Type; system than C has, in addition to it not offering the advantages of clear; structure that the system I recommended does... so you seem to not have a; problem with changing this, just with what I change it to. :). -Chris. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-06-TypeNotationDebateResp4.txt:3521,clear,clear,3521,interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-06-TypeNotationDebateResp4.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-06-TypeNotationDebateResp4.txt,3,['clear'],['clear']
Usability,"e above, the analyzer has detected that the body of; the loop is never entered for the case where length <= 0. In this; particular example, you may know that the loop will always be entered because; the input parameter length will be greater than zero in all calls to this; function. You can teach the analyzer facts about your code as well as document; it by using assertions. By adding assert(length > 0) in the beginning; of the function, you tell the analyzer that your code is never expecting a zero; or a negative value, so it won't need to test the correctness of those paths. int foo(int length) {; int x = 0;; assert(length > 0);; for (int i = 0; i < length; i++); x += 1;; return length/x;; }. Q: How can I suppress a specific analyzer warning?; When you encounter an analyzer bug/false positive, check if it's one of the; issues discussed above or if the analyzer; annotations can; resolve the issue by helping the static analyzer understand the code better.; Second, please report it to help us improve; user experience.; Sometimes there's really no ""good"" way to eliminate the issue. In such cases; you can ""silence"" it directly by annotating the problematic line of code with; the help of Clang attribute 'suppress':. int foo() {; int *x = nullptr;; ...; [[clang::suppress]] {; // all warnings in this scope are suppressed; int y = *x;; }. // null pointer dereference warning suppressed on the next line; [[clang::suppress]]; return *x; }. int bar(bool coin_flip) {; // suppress all memory leak warnings about this allocation; [[clang::suppress]]; int *result = (int *)malloc(sizeof(int));. if (coin_flip); return 0; // including this leak path. return *result; // as well as this leak path; }. You can also consider using __clang_analyzer__ macro; described below.; Q: How can I selectively exclude code the analyzer examines?; When the static analyzer is using clang to parse source files, it implicitly; defines the preprocessor macro __clang_analyzer__. One can use this; macro to se",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/faq.html:8352,user experience,user experience,8352,interpreter/llvm-project/clang/www/analyzer/faq.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/faq.html,1,['user experience'],['user experience']
Usability,"e and Building; --------------------------. Finally, if you're using your platform compiler, run:. .. code-block:: bash. $ cmake -G Ninja <source-dir> -DCMAKE_BUILD_TYPE=<type> <options above>. If you're using Clang as the cross-compiler, run:. .. code-block:: bash. $ CC='clang' CXX='clang++' cmake -G Ninja <source-dir> -DCMAKE_BUILD_TYPE=<type> <options above>. If you have ``clang``/``clang++`` on the path, it should just work, and special; Ninja files will be created in the build directory. I strongly suggest; you to run ``cmake`` on a separate build directory, *not* inside the; source tree. To build, simply type:. .. code-block:: bash. $ ninja. It should automatically find out how many cores you have, what are; the rules that needs building and will build the whole thing. You can't run ``ninja check-all`` on this tree because the created; binaries are targeted to ARM, not x86_64. Installing and Using; --------------------. After the LLVM/Clang has built successfully, you should install it; via:. .. code-block:: bash. $ ninja install. which will create a sysroot on the install-dir. You can then tar; that directory into a binary with the full triple name (for easy; identification), like:. .. code-block:: bash. $ ln -sf <install-dir> arm-linux-gnueabihf-clang; $ tar zchf arm-linux-gnueabihf-clang.tar.gz arm-linux-gnueabihf-clang. If you copy that tarball to your target board, you'll be able to use; it for running the test-suite, for example. Follow the guidelines at; https://llvm.org/docs/lnt/quickstart.html, unpack the tarball in the; test directory, and use options:. .. code-block:: bash. $ ./sandbox/bin/python sandbox/bin/lnt runtest nt \; --sandbox sandbox \; --test-suite `pwd`/test-suite \; --cc `pwd`/arm-linux-gnueabihf-clang/bin/clang \; --cxx `pwd`/arm-linux-gnueabihf-clang/bin/clang++. Remember to add the ``-jN`` options to ``lnt`` to the number of CPUs; on your board. Also, the path to your clang has to be absolute, so; you'll need the `pwd` trick above.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToCrossCompileLLVM.rst:7599,guid,guidelines,7599,interpreter/llvm-project/llvm/docs/HowToCrossCompileLLVM.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToCrossCompileLLVM.rst,1,['guid'],['guidelines']
Usability,"e any continuous; function. 2- Trained with `output=1` for the signal and 0 for the background,; the approximated function of inputs `X` is the probability of signal,; knowing `X`. ### Learning Methods. The aim of all learning methods is to minimize the total error on a; set of weighted examples. The error is defined as the sum in quadrate,; divided by two, of the error on each individual output neuron. In all; methods implemented in this library, one needs to compute the first; derivative of that error with respect to the weights. Exploiting the; well-known properties of the derivative, one can express this; derivative as the product of the local partial derivative by the; weighted sum of the outputs derivatives (for a neuron) or as the; product of the input value with the local partial derivative of the; output neuron (for a synapse). This computation is called; ""back-propagation of the errors"". Six learning methods are; implemented. #### Stochastic Minimization. This is the most trivial learning method. The Robbins-Monro stochastic; approximation is applied to multilayer perceptrons. The weights are; updated after each example according to the formula:. $$; w_{ij}(t+1) = w_{ij}(t) + \Delta w_{ij}(t); $$. with:. $$; \Delta w_{ij}(t) = - \eta \left(; \frac{\partial e_p}{\partial w_{ij}} + \delta \right) +; \epsilon \Delta w_{ij}(t-1); $$. The parameters for this method are `Eta`, `EtaDecay`, `Delta` and; `Epsilon`. #### Steepest Descent With Fixed Step Size (Batch Learning). It is the same as the stochastic minimization, but the weights are; updated after considering all the examples, with the total derivative; `dEdw`. The parameters for this method are `Eta`, `EtaDecay`, `Delta`; and `Epsilon`. #### Steepest Descent Algorithm. Weights are set to the minimum along the line defined by the gradient.; The only parameter for this method is `Tau`. Lower `Tau` = higher; precision = slower search. A value `Tau=3` seems reasonable. #### Conjugate Gradients With the Polak-R",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:72204,learn,learning,72204,documentation/users-guide/FittingHistograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md,1,['learn'],['learning']
Usability,"e been solved. Step #3: Write Access Move; --------------------------. 9. Collect developers' GitHub account information, and add them to the project.; 10. Switch the SVN repository to read-only and allow pushes to the GitHub repository.; 11. Update the documentation.; 12. Mirror Git to SVN. Step #4 : Post Move; -------------------. 13. Archive the SVN repository.; 14. Update links on the LLVM website pointing to viewvc/klaus/phab etc. to; point to GitHub instead. GitHub Repository Description; =============================. Monorepo; ----------------. The LLVM git repository hosted at https://github.com/llvm/llvm-project contains all; sub-projects in a single source tree. It is often referred to as a monorepo and; mimics an export of the current SVN repository, with each sub-project having its; own top-level directory. Not all sub-projects are used for building toolchains.; For example, www/ and test-suite/ are not part of the monorepo. Putting all sub-projects in a single checkout makes cross-project refactoring; naturally simple:. * New sub-projects can be trivially split out for better reuse and/or layering; (e.g., to allow libSupport and/or LIT to be used by runtimes without adding a; dependency on LLVM).; * Changing an API in LLVM and upgrading the sub-projects will always be done in; a single commit, designing away a common source of temporary build breakage.; * Moving code across sub-project (during refactoring for instance) in a single; commit enables accurate `git blame` when tracking code change history.; * Tooling based on `git grep` works natively across sub-projects, allowing to; easier find refactoring opportunities across projects (for example reusing a; datastructure initially in LLDB by moving it into libSupport).; * Having all the sources present encourages maintaining the other sub-projects; when changing API. Finally, the monorepo maintains the property of the existing SVN repository that; the sub-projects move synchronously, and a single revisi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst:8910,simpl,simple,8910,interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,1,['simpl'],['simple']
Usability,"e call will; be preceded by a runtime type check, which validates that the call target is; prefixed with a :ref:`type identifier<md_kcfi_type>` that matches the operand; bundle attribute. For example:. .. code-block:: llvm. call void %0() [""kcfi""(i32 1234)]. Clang emits KCFI operand bundles and the necessary metadata with; ``-fsanitize=kcfi``. .. _convergencectrl:. Convergence Control Operand Bundles; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. A ""convergencectrl"" operand bundle is only valid on a ``convergent`` operation.; When present, the operand bundle must contain exactly one value of token type.; See the :doc:`ConvergentOperations` document for details. .. _moduleasm:. Module-Level Inline Assembly; ----------------------------. Modules may contain ""module-level inline asm"" blocks, which corresponds; to the GCC ""file scope inline asm"" blocks. These blocks are internally; concatenated by LLVM and treated as a single unit, but may be separated; in the ``.ll`` file if desired. The syntax is very simple:. .. code-block:: llvm. module asm ""inline asm code goes here""; module asm ""more can go here"". The strings can contain any character by escaping non-printable; characters. The escape sequence used is simply ""\\xx"" where ""xx"" is the; two digit hex code for the number. Note that the assembly string *must* be parseable by LLVM's integrated assembler; (unless it is disabled), even when emitting a ``.s`` file. .. _langref_datalayout:. Data Layout; -----------. A module may specify a target specific data layout string that specifies; how data is to be laid out in memory. The syntax for the data layout is; simply:. .. code-block:: llvm. target datalayout = ""layout specification"". The *layout specification* consists of a list of specifications; separated by the minus sign character ('-'). Each specification starts; with a letter and may include other information after the letter to; define some aspect of the data layout. The specifications accepted are; as follows:. ``E``; Specifi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:130478,simpl,simple,130478,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['simpl'],['simple']
Usability,"e came to the same; > conclusion I do: that you have to go with familiar syntax over logical; > syntax because familiarity is such a strong force:; > ""However, familiarity is a strong force. To compare, in English, we; live; > more or less happily with the absurd rules for ""to be"" (am, are, is, been,; > was, were, ...) and all attempts to simplify are treated with contempt or; > (preferably) humor. It be a curious world and it always beed."". Although you have to remember that his situation was considerably; different than ours. He was in a position where he was designing a high; level language that had to be COMPATIBLE with C. Our language is such; that a new person would have to learn the new, different, syntax; anyways. Making them learn about the type system does not seem like much; of a stretch from learning the opcodes and how SSA form works, and how; everything ties together... > > Basically, my argument for this type construction system is that it is; > > VERY simple to use and understand (although it IS different than C, it is; > > very simple and straightforward, which C is NOT). In fact, I would assert; > > that most programmers TODAY do not understand pointers to member; > > functions, and have to look up an example when they have to write them. > Again, I don't disagree with this at all. But to some extent this; > particular problem is inherently difficult. Your syntax for the above; > example may be easier for you to read because this is the way you have been; > thinking about it. Honestly, I don't find it much easier than the C syntax.; > In either case, I would have to look up an example to write pointers to; > member functions. I would argue that because the lexical structure of the language is self; consistent, any person who spent a significant amount of time programming; in LLVM directly would understand how to do it without looking it up in a; manual. The reason this does not work for C is because you rarely have to; declare these pointers, and th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-06-TypeNotationDebateResp4.txt:1039,simpl,simple,1039,interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-06-TypeNotationDebateResp4.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-06-TypeNotationDebateResp4.txt,2,['simpl'],['simple']
Usability,"e diagnostic is expected to occur a minimum number of times, this can; be specified by appending a ``+`` to the number. For example:. .. code-block:: c++. void f(); // expected-note 0+ {{previous declaration is here}}; void g(); // expected-note 1+ {{previous declaration is here}}. In the first example, the diagnostic becomes optional, i.e. it will be; swallowed if it occurs, but will not generate an error if it does not occur. In; the second example, the diagnostic must occur at least once. As a short-hand,; ""one or more"" can be specified simply by ``+``. For example:. .. code-block:: c++. void g(); // expected-note + {{previous declaration is here}}. A range can also be specified by ``<n>-<m>``. For example:. .. code-block:: c++. void f(); // expected-note 0-1 {{previous declaration is here}}. In this example, the diagnostic may appear only once, if at all. .. _DiagnosticMatching:. Matching Modes; ~~~~~~~~~~~~~~. The default matching mode is simple string, which looks for the expected text; that appears between the first `{{` and `}}` pair of the comment. The string is; interpreted just as-is, with one exception: the sequence `\n` is converted to a; single newline character. This mode matches the emitted diagnostic when the; text appears as a substring at any position of the emitted message. To enable matching against desired strings that contain `}}` or `{{`, the; string-mode parser accepts opening delimiters of more than two curly braces,; like `{{{`. It then looks for a closing delimiter of equal ""width"" (i.e `}}}`).; For example:. .. code-block:: c++. // expected-note {{{evaluates to '{{2, 3, 4}} == {0, 3, 4}'}}}. The intent is to allow the delimeter to be wider than the longest `{` or `}`; brace sequence in the content, so that if your expected text contains `{{{`; (three braces) it may be delimited with `{{{{` (four braces), and so on. Regex matching mode may be selected by appending ``-re`` to the diagnostic type; and including regexes wrapped in double curl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:160881,simpl,simple,160881,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['simpl'],['simple']
Usability,"e equivalent of:. .. code-block:: c++. static task coro_task(int v) {; store v to __int_32_0 in the frame; co_await await_counter{};; a = load __int_32_0; std::cout << a+1 << ""\n"";; std::cout << a+2 << ""\n"";; std::cout << a+3 << ""\n"";; co_await await_counter{};; a = load __int_32_0; std::cout << a+4 << ""\n"";; std::cout << a+5 << ""\n"";; }. It should now be obvious why the value of `__int_32_0` remains unchanged; throughout the function. It is important to recognize that `__int_32_0`; does not directly correspond to `a`, but is instead a variable generated; to assist the compiler in code generation. The variables in an optimized; coroutine frame should not be thought of as directly representing the; variables in the C++ source. Get the suspended points; ========================. An important requirement for debugging coroutines is to understand suspended; points, which are where the coroutine is currently suspended and awaiting. For simple cases like the above, inspecting the value of the `__coro_index`; variable in the coroutine frame works well. However, it is not quite so simple in really complex situations. In these; cases, it is necessary to use the coroutine libraries to insert the; line-number. For example:. .. code-block:: c++. // For all the promise_type we want:; class promise_type {; ...; + unsigned line_number = 0xffffffff;; };. #include <source_location>. // For all the awaiter types we need:; class awaiter {; ...; template <typename Promise>; void await_suspend(std::coroutine_handle<Promise> handle,; std::source_location sl = std::source_location::current()) {; ...; handle.promise().line_number = sl.line();; }; };. In this case, we use `std::source_location` to store the line number of the; await inside the `promise_type`. Since we can locate the coroutine function; from the address of the coroutine, we can identify suspended points this way; as well. The downside here is that this comes at the price of additional runtime cost.; This is consistent with th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst:10660,simpl,simple,10660,interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst,1,['simpl'],['simple']
Usability,"e final executable file when the program is linked. 2. It is also used by *llvm-cov* - the mapping information is extracted from an; object file and is used to associate the execution counts (the values of the; profile instrumentation counters), and the source ranges in a file.; After that, the tool is able to generate various code coverage reports; for the program. The coverage mapping format aims to be a ""universal format"" that would be; suitable for usage by any frontend, and not just by Clang. It also aims to; provide the frontend the possibility of generating the minimal coverage mapping; data in order to reduce the size of the IR and object files - for example,; instead of emitting mapping information for each statement in a function, the; frontend is allowed to group the statements with the same execution count into; regions of code, and emit the mapping information only for those regions. Advanced Concepts; =================. The remainder of this guide is meant to give you insight into the way the; coverage mapping format works. The coverage mapping format operates on a per-function level as the; profile instrumentation counters are associated with a specific function.; For each function that requires code coverage, the frontend has to create; coverage mapping data that can map between the source code ranges and; the profile instrumentation counters for that function. Mapping Region; --------------. The function's coverage mapping data contains an array of mapping regions.; A mapping region stores the `source code range`_ that is covered by this region,; the `file id <coverage file id_>`_, the `coverage mapping counter`_ and; the region's kind.; There are several kinds of mapping regions:. * Code regions associate portions of source code and `coverage mapping; counters`_. They make up the majority of the mapping regions. They are used; by the code coverage tool to compute the execution counts for lines,; highlight the regions of code that were never execute",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CoverageMappingFormat.rst:2885,guid,guide,2885,interpreter/llvm-project/llvm/docs/CoverageMappingFormat.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CoverageMappingFormat.rst,1,['guid'],['guide']
Usability,"e final side-effecting node in the token chain. For example, in a single basic; block function it would be the return node. One important concept for SelectionDAGs is the notion of a ""legal"" vs.; ""illegal"" DAG. A legal DAG for a target is one that only uses supported; operations and supported types. On a 32-bit PowerPC, for example, a DAG with a; value of type i1, i8, i16, or i64 would be illegal, as would a DAG that uses a; SREM or UREM operation. The `legalize types`_ and `legalize operations`_ phases; are responsible for turning an illegal DAG into a legal DAG. .. _SelectionDAG-Process:. SelectionDAG Instruction Selection Process; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. SelectionDAG-based instruction selection consists of the following steps:. #. `Build initial DAG`_ --- This stage performs a simple translation from the; input LLVM code to an illegal SelectionDAG. #. `Optimize SelectionDAG`_ --- This stage performs simple optimizations on the; SelectionDAG to simplify it, and recognize meta instructions (like rotates; and ``div``/``rem`` pairs) for targets that support these meta operations.; This makes the resultant code more efficient and the `select instructions; from DAG`_ phase (below) simpler. #. `Legalize SelectionDAG Types`_ --- This stage transforms SelectionDAG nodes; to eliminate any types that are unsupported on the target. #. `Optimize SelectionDAG`_ --- The SelectionDAG optimizer is run to clean up; redundancies exposed by type legalization. #. `Legalize SelectionDAG Ops`_ --- This stage transforms SelectionDAG nodes to; eliminate any operations that are unsupported on the target. #. `Optimize SelectionDAG`_ --- The SelectionDAG optimizer is run to eliminate; inefficiencies introduced by operation legalization. #. `Select instructions from DAG`_ --- Finally, the target instruction selector; matches the DAG operations to target instructions. This process translates; the target-independent input DAG into another DAG of target instructions. #. `Sele",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:37110,simpl,simple,37110,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,2,['simpl'],"['simple', 'simplify']"
Usability,"e first argument is a token returned by a call to '``llvm.coro.id``'; identifying the coroutine. Semantics:; """""""""""""""""""". A frontend should emit at most one `coro.alloc` intrinsic per coroutine.; The intrinsic is used to suppress dynamic allocation of the coroutine frame; when possible. Example:; """""""""""""""". .. code-block:: llvm. entry:; %id = call token @llvm.coro.id(i32 0, ptr null, ptr null, ptr null); %dyn.alloc.required = call i1 @llvm.coro.alloc(token %id); br i1 %dyn.alloc.required, label %coro.alloc, label %coro.begin. coro.alloc:; %frame.size = call i32 @llvm.coro.size(); %alloc = call ptr @MyAlloc(i32 %frame.size); br label %coro.begin. coro.begin:; %phi = phi ptr [ null, %entry ], [ %alloc, %coro.alloc ]; %frame = call ptr @llvm.coro.begin(token %id, ptr %phi). .. _coro.noop:. 'llvm.coro.noop' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; ::. declare ptr @llvm.coro.noop(). Overview:; """""""""""""""""". The '``llvm.coro.noop``' intrinsic returns an address of the coroutine frame of; a coroutine that does nothing when resumed or destroyed. Arguments:; """""""""""""""""""". None. Semantics:; """""""""""""""""""". This intrinsic is lowered to refer to a private constant coroutine frame. The; resume and destroy handlers for this frame are empty functions that do nothing.; Note that in different translation units llvm.coro.noop may return different pointers. .. _coro.frame:. 'llvm.coro.frame' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; ::. declare ptr @llvm.coro.frame(). Overview:; """""""""""""""""". The '``llvm.coro.frame``' intrinsic returns an address of the coroutine frame of; the enclosing coroutine. Arguments:; """""""""""""""""""". None. Semantics:; """""""""""""""""""". This intrinsic is lowered to refer to the `coro.begin`_ instruction. This is; a frontend convenience intrinsic that makes it easier to refer to the; coroutine frame. .. _coro.id:. 'llvm.coro.id' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; ::. declare token @llvm.coro.id(i32 <align>, ptr <promise>, ptr <coroaddr>,; ptr <f",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:36021,resume,resumed,36021,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resumed']
Usability,"e function is split into three functions, representing three; different ways that control can enter the coroutine:. 1. the ramp function that is initially invoked, which takes arbitrary; arguments and returns a pointer to the coroutine object;. 2. a coroutine resume function that is invoked when the coroutine is resumed,; which takes a pointer to the coroutine object and returns `void`;. 3. a coroutine destroy function that is invoked when the coroutine is; destroyed, which takes a pointer to the coroutine object and returns; `void`. Because the resume and destroy functions are shared across all suspend; points, suspend points must store the index of the active suspend in; the coroutine object, and the resume/destroy functions must switch over; that index to get back to the correct point. Hence the name of this; lowering. Pointers to the resume and destroy functions are stored in the coroutine; object at known offsets which are fixed for all coroutines. A completed; coroutine is represented with a null resume function. There is a somewhat complex protocol of intrinsics for allocating and; deallocating the coroutine object. It is complex in order to allow the; allocation to be elided due to inlining. This protocol is discussed; in further detail below. The frontend may generate code to call the coroutine function directly;; this will become a call to the ramp function and will return a pointer; to the coroutine object. The frontend should always resume or destroy; the coroutine using the corresponding intrinsics. Returned-Continuation Lowering; ------------------------------. In returned-continuation lowering, signaled by the use of; `llvm.coro.id.retcon` or `llvm.coro.id.retcon.once`, some aspects of; the ABI must be handled more explicitly by the frontend. In this lowering, every suspend point takes a list of ""yielded values""; which are returned back to the caller along with a function pointer,; called the continuation function. The coroutine is resumed by simply; c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:4749,resume,resume,4749,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"e function the; loop is in, and that includes some function analyses the loop analyses depend; on. This discounts future concurrency over separate loops in a function, but; that's a tradeoff due to how tightly a loop and its function are coupled. To; make sure the function analyses that loop passes use are valid, they are; manually updated in the loop passes to ensure that invalidation is not; necessary. There is a set of common function analyses that loop passes and; analyses have access to which is passed into loop passes as a; ``LoopStandardAnalysisResults`` parameter. Other mutable function analyses are; not accessible from loop passes. As with any caching mechanism, we need some way to tell analysis managers; when results are no longer valid. Much of the analysis manager complexity; comes from trying to invalidate as few analysis results as possible to keep; compile times as low as possible. There are two ways to deal with potentially invalid analysis results. One is; to simply force clear the results. This should generally only be used when; the IR that the result is keyed on becomes invalid. For example, a function; is deleted, or a CGSCC has become invalid due to call graph changes. The typical way to invalidate analysis results is for a pass to declare what; types of analyses it preserves and what types it does not. When transforming; IR, a pass either has the option to update analyses alongside the IR; transformation, or tell the analysis manager that analyses are no longer; valid and should be invalidated. If a pass wants to keep some specific; analysis up to date, such as when updating it would be faster than; invalidating and recalculating it, the analysis itself may have methods to; update it for specific transformations, or there may be helper updaters like; ``DomTreeUpdater`` for a ``DominatorTree``. Otherwise to mark some analysis; as no longer valid, the pass can return a ``PreservedAnalyses`` with the; proper analyses invalidated. .. code-block:: c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NewPassManager.rst:11745,simpl,simply,11745,interpreter/llvm-project/llvm/docs/NewPassManager.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NewPassManager.rst,2,"['clear', 'simpl']","['clear', 'simply']"
Usability,"e functionally related controls. ![](pictures/02000207.jpg). It is a composite frame with a border and a title. The title explains; the purpose of the group and should be a noun or noun phrase. Here is an; example taken from `guitest.C`:. ``` {.cpp}; groupFrame = new TGGroupFrame(tf,""Options"",kVerticalFrame);; groupFrame->SetTitlePos(TGGroupFrame::kLeft);; ```. The second line sets the title position on the left. You can change it; to be centered or right aligned if you use **`TGGroupFrame::kCenter`** or; `TGGroupFrame::kRight` as a parameter. ![](pictures/02000208.jpg). Be conservative in the use of borders because of the potential for; clutter. Do not place them around single entry fields, single combo; boxes, list boxes and groups of command buttons. The design of these; widgets provides them with a border. The picture above provides kind of; borders to avoid. ## Layout Management. The layout process is an integral part of any GUI. When you create a; simple message window, laying out its few buttons and text widgets is; quite simple. However, this process becomes increasingly difficult if; you have to implement large GUI's with many widgets that should behave; properly when the GUI is resized or uses a different font type or size.; Layout management is the process of determining the size and position of; every widget in a container. A layout manager is an object that performs layout management for the; widgets within a container. You already know that when adding a; component (child widget) to a container (parent widget) you can provide; alignment hints (or rely on the default ones). These hints are used by; the layout manager to correctly position the widgets in the container.; The **`TGLayoutManager`** is an abstract class providing the basic; layout functionality. ![The layout classes hierarchy](pictures/02000209.jpg). The base ""container"" class is **`TGCmpositeFrame`**. You can easily; change the layout manager using the; `SetLayoutManager(TGLayoutManager *l)",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:33674,simpl,simple,33674,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,2,['simpl'],['simple']
Usability,"e have to define so many volumes to make an R?"". **A:** Well, in real life some objects have much more complex shapes; that an ""R"". The modeller cannot just know all of them; the idea; is to make a complex object by using elementary building blocks that; have known shapes (called ""primitive shapes""). Gluing these; together in the appropriate way is the user responsibility. **Q:** ""I am getting the global picture but not making much out of it... There; are also a lot of calls to TGeoVolume::AddNode() that I do not understand."". **A:** A volume is positioned inside another one by using this; method. The relative geometrical transformation as well as a copy number; must be specified. When positioned, a volume becomes a ""node"" of; its container and a new object of the class TGeoNode is; automatically created. This method is therefore the key element for the; creation of a hierarchical link between two volumes. As it will be; described further on in this document, there are few other methods; performing similar actions, but let us keep things simple for the time; being. In addition, notice that there are some visualization-related; calls in the example followed by a final TGeoVolume::Draw() call for; the top volume. These are explained in details in the section; ""Visualization Settings and Attributes"". At this point, you will; probably like to see how this geometry looks like. You just need to run; the example and you will get the following picture that you can rotate; using the mouse; or you can zoom / move it around (see what the Help; menu of the GL window displays). ~~~{.cpp}; % root rootgeom.C; ~~~. \image html geometry001.png width=600px. Now let us browse the hierarchy that was just created. Start a browser; and double-click on the item simple1 representing the; `gGeoManager` object. Note that right click opens the context menu; of the manager class where several global methods are available. ~~~{.cpp}; root[] new TBrowser;; ~~~. \image html geometry002.jpg width=",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:10725,simpl,simple,10725,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['simpl'],['simple']
Usability,"e image, such as the triple and architecture. All of these structures are combined to form a single binary blob, the order; does not matter because of the use of absolute offsets. This makes it easier to; extend in the future. As mentioned previously, multiple offloading images are; bundled together by simply concatenating them in this format. Because we have; the magic bytes and size of each image, we can extract them as-needed. Usage; =====. This tool can be used with the following arguments. Generally information is; passed as a key-value pair to the ``image=`` argument. The ``file`` and; ``triple``, arguments are considered mandatory to make a valid image.; The ``arch`` argument is suggested. .. code-block:: console. OVERVIEW: A utility for bundling several object files into a single binary.; The output binary can then be embedded into the host section table; to create a fatbinary containing offloading code. USAGE: clang-offload-packager [options]. OPTIONS:. Generic Options:. --help - Display available options (--help-hidden for more); --help-list - Display list of available options (--help-list-hidden for more); --version - Display the version of this program. clang-offload-packager options:. --image=<<key>=<value>,...> - List of key and value arguments. Required; keywords are 'file' and 'triple'.; -o <file> - Write output to <file>. Example; =======. This tool simply takes many input files from the ``image`` option and creates a; single output file with all the images combined. .. code-block:: console. clang-offload-packager -o out.bin --image=file=input.o,triple=nvptx64,arch=sm_70. The inverse operation can be performed instead by passing the packaged binary as; input. In this mode the matching images will either be placed in the output; specified by the ``file`` option. If no ``file`` argument is provided a name; will be generated for each matching image. .. code-block:: console. clang-offload-packager in.bin --image=file=output.o,triple=nvptx64,arch=sm_70; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangOffloadPackager.rst:8510,simpl,simply,8510,interpreter/llvm-project/clang/docs/ClangOffloadPackager.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangOffloadPackager.rst,1,['simpl'],['simply']
Usability,"e instruction after *inst; if (it != inst->getParent()->end()) errs() << *it << ""\n"";; }. .. _iterate_complex:. Finding call sites: a slightly more complex example; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Say that you're writing a FunctionPass and would like to count all the locations; in the entire module (that is, across every ``Function``) where a certain; function (i.e., some ``Function *``) is already in scope. As you'll learn; later, you may want to use an ``InstVisitor`` to accomplish this in a much more; straight-forward manner, but this example will allow us to explore how you'd do; it if you didn't have ``InstVisitor`` around. In pseudo-code, this is what we; want to do:. .. code-block:: none. initialize callCounter to zero; for each Function f in the Module; for each BasicBlock b in f; for each Instruction i in b; if (i a Call and calls the given function); increment callCounter. And the actual code is (remember, because we're writing a ``FunctionPass``, our; ``FunctionPass``-derived class simply has to override the ``runOnFunction``; method):. .. code-block:: c++. Function* targetFunc = ...;. class OurFunctionPass : public FunctionPass {; public:; OurFunctionPass(): callCounter(0) { }. virtual runOnFunction(Function& F) {; for (BasicBlock &B : F) {; for (Instruction &I: B) {; if (auto *CB = dyn_cast<CallBase>(&I)) {; // We know we've encountered some kind of call instruction (call,; // invoke, or callbr), so we need to determine if it's a call to; // the function pointed to by m_func or not.; if (CB->getCalledFunction() == targetFunc); ++callCounter;; }; }; }; }. private:; unsigned callCounter;; };. .. _iterate_chains:. Iterating over def-use & use-def chains; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Frequently, we might have an instance of the ``Value`` class (`doxygen; <https://llvm.org/doxygen/classllvm_1_1Value.html>`__) and we want to determine; which ``User``\ s use the ``Value``. The list of all ``User``\ s of a particular; ``Value`` ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:110223,simpl,simply,110223,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['simpl'],['simply']
Usability,"e it into a (hopefully) more optimized but semantically; equivalent form. In the original tutorial series the FunctionPassManager was; created outside the KaleidoscopeJIT and modules were optimized before being; added to it. In this Chapter we will make optimization a phase of our JIT; instead. For now this will provide us a motivation to learn more about ORC; layers, but in the long term making optimization part of our JIT will yield an; important benefit: When we begin lazily compiling code (i.e. deferring; compilation of each function until the first time it's run) having; optimization managed by our JIT will allow us to optimize lazily too, rather; than having to do all our optimization up-front. To add optimization support to our JIT we will take the KaleidoscopeJIT from; Chapter 1 and compose an ORC *IRTransformLayer* on top. We will look at how the; IRTransformLayer works in more detail below, but the interface is simple: the; constructor for this layer takes a reference to the execution session and the; layer below (as all layers do) plus an *IR optimization function* that it will; apply to each Module that is added via addModule:. .. code-block:: c++. class KaleidoscopeJIT {; private:; ExecutionSession ES;; RTDyldObjectLinkingLayer ObjectLayer;; IRCompileLayer CompileLayer;; IRTransformLayer TransformLayer;. DataLayout DL;; MangleAndInterner Mangle;; ThreadSafeContext Ctx;. public:. KaleidoscopeJIT(JITTargetMachineBuilder JTMB, DataLayout DL); : ObjectLayer(ES,; []() { return std::make_unique<SectionMemoryManager>(); }),; CompileLayer(ES, ObjectLayer, ConcurrentIRCompiler(std::move(JTMB))),; TransformLayer(ES, CompileLayer, optimizeModule),; DL(std::move(DL)), Mangle(ES, this->DL),; Ctx(std::make_unique<LLVMContext>()) {; ES.getMainJITDylib().addGenerator(; cantFail(DynamicLibrarySearchGenerator::GetForCurrentProcess(DL.getGlobalPrefix())));; }. Our extended KaleidoscopeJIT class starts out the same as it did in Chapter 1,; but after the CompileLayer we int",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT2.rst:2705,simpl,simple,2705,interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT2.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT2.rst,1,['simpl'],['simple']
Usability,"e left with the original AST. .. code-block:: bash. ERROR: NameConflict; TranslationUnitDecl 0xe54a48 <<invalid sloc>> <invalid sloc>; |-ClassTemplateDecl 0xe91020 <to.cc:3:7, line:4:17> col:14 X; | |-TemplateTypeParmDecl 0xe90ed0 <line:3:17, col:26> col:26 typename depth 0 index 0 T; | |-CXXRecordDecl 0xe90f90 <line:4:7, col:17> col:14 struct X definition; | | |-DefinitionData empty aggregate standard_layout trivially_copyable pod trivial literal has_constexpr_non_copy_move_ctor can_const_default_init; | | | |-DefaultConstructor exists trivial constexpr needs_implicit defaulted_is_constexpr; | | | |-CopyConstructor simple trivial has_const_param needs_implicit implicit_has_const_param; | | | |-MoveConstructor exists simple trivial needs_implicit; | | | |-CopyAssignment trivial has_const_param needs_implicit implicit_has_const_param; | | | |-MoveAssignment exists simple trivial needs_implicit; | | | `-Destructor simple irrelevant trivial needs_implicit; | | `-CXXRecordDecl 0xe91270 <col:7, col:14> col:14 implicit struct X; | `-ClassTemplateSpecialization 0xe91340 'X'; `-ClassTemplateSpecializationDecl 0xe91340 <line:6:7, line:7:30> col:14 struct X definition; |-DefinitionData pass_in_registers aggregate standard_layout trivially_copyable pod trivial literal; | |-DefaultConstructor exists trivial needs_implicit; | |-CopyConstructor simple trivial has_const_param needs_implicit implicit_has_const_param; | |-MoveConstructor exists simple trivial needs_implicit; | |-CopyAssignment trivial has_const_param needs_implicit implicit_has_const_param; | |-MoveAssignment exists simple trivial needs_implicit; | `-Destructor simple irrelevant trivial needs_implicit; |-TemplateArgument type 'int'; |-CXXRecordDecl 0xe91558 <col:7, col:14> col:14 implicit struct X; `-FieldDecl 0xe91600 <col:23, col:27> col:27 i 'int'. Error propagation; """""""""""""""""""""""""""""""""". If there is a dependent node we have to import before we could import a given node then the import error associated to the depend",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst:14015,simpl,simple,14015,interpreter/llvm-project/clang/docs/LibASTImporter.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst,8,['simpl'],['simple']
Usability,"e mechanism that; allows one file to include the content of another file (see `Include; Files`_). This allows large files to be broken up into smaller ones, and; also provides a simple library mechanism where multiple source files can; include the same library file. TableGen supports a simple preprocessor that can be used to conditionalize; portions of ``.td`` files. See `Preprocessing Facilities`_ for more; information. Lexical Analysis; ================. The lexical and syntax notation used here is intended to imitate; `Python's`_ notation. In particular, for lexical definitions, the productions; operate at the character level and there is no implied whitespace between; elements. The syntax definitions operate at the token level, so there is; implied whitespace between tokens. .. _`Python's`: http://docs.python.org/py3k/reference/introduction.html#notation. TableGen supports BCPL-style comments (``// ...``) and nestable C-style; comments (``/* ... */``).; TableGen also provides simple `Preprocessing Facilities`_. Formfeed characters may be used freely in files to produce page breaks when; the file is printed for review. The following are the basic punctuation tokens::. - + [ ] { } ( ) < > : ; . ... = ? #. Literals; --------. Numeric literals take one of the following forms:. .. productionlist::; TokInteger: `DecimalInteger` | `HexInteger` | `BinInteger`; DecimalInteger: [""+"" | ""-""] (""0""...""9"")+; HexInteger: ""0x"" (""0""...""9"" | ""a""...""f"" | ""A""...""F"")+; BinInteger: ""0b"" (""0"" | ""1"")+. Observe that the :token:`DecimalInteger` token includes the optional ``+``; or ``-`` sign, unlike most languages where the sign would be treated as a; unary operator. TableGen has two kinds of string literals:. .. productionlist::; TokString: '""' (non-'""' characters and escapes) '""'; TokCode: ""[{"" (shortest text not containing ""}]"") ""}]"". A :token:`TokCode` is nothing more than a multi-line string literal; delimited by ``[{`` and ``}]``. It can break across lines and the; line breaks are ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst:6972,simpl,simple,6972,interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,1,['simpl'],['simple']
Usability,"e must not impose an undue; burden on maintaining other components (core or peripheral). Warnings; --------. There are multiple types of issues that might trigger a request for deprecation,; including (but not limited to):. * Changes in a component consistently break other areas of the project.; * Components go broken for long periods of time (weeks or more).; * Clearly superior alternatives are in use and maintenance is painful.; * Builds and tests are harder / take longer, increasing the cost of; maintenance, overtaking the perceived benefits. If the maintenance cost is higher than it is acceptable by the majority of; developers, it means that either the sub-community is too small (and the extra; cost should be paid locally), or not active enough (and the problems won't be; fixed any time soon). In either case, removal of such problematic component is; justified. Steps for removal; -----------------. However clear the needs for removal are, we should take an incremental approach; to deprecating code, especially when there's still a sub-community that cares; about it. In that sense, code will never be removed outright without a series; of steps are taken. A minimum set of steps should be:; #. A proposal for removal / deactivation should be made to the Discourse forums ; (under the appropriate category), with a clear; statement of the maintenance costs imposed and the alternatives, if; applicable.; #. There must be enough consensus on the list that removal is warranted, and no; pending proposals to fix the situation from a sub-community.; #. An announcement for removal must be made on the same lists, with ample time; for downstream users to take action on their local infrastructure. The time; will depend on what is being removed. #. If a script or documents are to be removed, they can always be pulled; from previous revision, and can be removed within days.; #. if a whole target is removed, we need to first announce publicly, and; potentially mark as deprecated in o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportPolicy.rst:9132,clear,clear,9132,interpreter/llvm-project/llvm/docs/SupportPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportPolicy.rst,1,['clear'],['clear']
Usability,"e of Minuit, we have *Migrad, Simplex* or *Minimize*. The minimizer and its corresponding algorithm, when available,; can be set by using the function `FitConfig::SetMinimizer(""minimizerName"")` or by using directly the `ROOT:Math::MinimizerOptions` class. If the requested minimizer is not available in ROOT, the default one is used. The default minimizer type and algorithm can be specified by using the; static function `ROOT::Math::MinimizerOptions::SetDefaultMinimizer(""minimizerName"")`. ### Minimizer Libraries and Algorithms. The list of available minimizer libraries currently available in ROOT, with their corresponding available algorithms is the following one.; Some minimizers (e.g. *Minuit*) contain several algorithms that the user can; choose. Others are based on a single algorithm (e.g. *Fumili*). - **`Minuit`** (library *libMinuit*). Old version of Minuit, based on the `TMinuit` class. The list of possible algorithms are:; - *`Migrad`* (default one); 	 - *`Simplex`*; - *`Minimize`* (it is a combination of Migrad and Simplex); - *`MigradImproved`*; 	 - *`Scan`*; 	 - *`Seek`*. - **`Minuit2`** (library *libMinuit2*). New C++ version of Minuit. The list of possible algorithm is :; - *`Migrad`* (default); - *`Simplex`*; 	 - *`Minimize`*; 	 - *`Scan`*; 	 - *`Fumili`* . This is the same algorithm of `TFumili`, but implemented in the Minuit2 library. - **`Fumili`**. Implement a dedicated minimization algorithm for least-square and likelihood fits. It has requirements on the type of method function to be used.; No specific algorithm exists. - **`GSLMultiMin`** (library *libMathMore*). Minimizer based on the Multidimensional Minimization routines of the Gnu Scientific Library (GSL). The list of available algorithms is; 	- *`BFGS2`* (default) : second version of the vector Broyden-Fletcher-Goldfarb-Shanno (BFGS) algorithm;; 	- *`BFGS`* : old version of the vector Broyden-Fletcher-Goldfarb-Shanno (BFGS) algorithm;; 	- *`ConjugateFR`* : Fletcher-Reeves conjugate gradient al",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:41147,Simpl,Simplex,41147,documentation/users-guide/FittingHistograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md,2,['Simpl'],['Simplex']
Usability,"e of inclusion, it's advisable that new components; are not added too close to a release branch. The time will depend on the size; and complexity of the component, so adding release and testing managers on the; RFC and review is strongly advisable. Deprecation Policy; ==================. The LLVM code base has a number of files that aren't being actively maintained.; But not all of those files are obstructing the development of the project and; so it remains in the repository with the assumption that it could still be; useful for downstream users. For code to remain in the repository, its presence must not impose an undue; burden on maintaining other components (core or peripheral). Warnings; --------. There are multiple types of issues that might trigger a request for deprecation,; including (but not limited to):. * Changes in a component consistently break other areas of the project.; * Components go broken for long periods of time (weeks or more).; * Clearly superior alternatives are in use and maintenance is painful.; * Builds and tests are harder / take longer, increasing the cost of; maintenance, overtaking the perceived benefits. If the maintenance cost is higher than it is acceptable by the majority of; developers, it means that either the sub-community is too small (and the extra; cost should be paid locally), or not active enough (and the problems won't be; fixed any time soon). In either case, removal of such problematic component is; justified. Steps for removal; -----------------. However clear the needs for removal are, we should take an incremental approach; to deprecating code, especially when there's still a sub-community that cares; about it. In that sense, code will never be removed outright without a series; of steps are taken. A minimum set of steps should be:; #. A proposal for removal / deactivation should be made to the Discourse forums ; (under the appropriate category), with a clear; statement of the maintenance costs imposed and the altern",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportPolicy.rst:8573,Clear,Clearly,8573,interpreter/llvm-project/llvm/docs/SupportPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportPolicy.rst,1,['Clear'],['Clearly']
Usability,"e of the edges/blocks may still be left; uninstrumented (pruned) if such instrumentation is considered redundant.; Use ``no-prune`` (e.g. ``-fsanitize-coverage=bb,no-prune,trace-pc-guard``); to disable pruning. This could be useful for better coverage visualization. Edge coverage; -------------. Consider this code:. .. code-block:: c++. void foo(int *a) {; if (a); *a = 0;; }. It contains 3 basic blocks, let's name them A, B, C:. .. code-block:: none. A; |\; | \; | B; | /; |/; C. If blocks A, B, and C are all covered we know for certain that the edges A=>B; and B=>C were executed, but we still don't know if the edge A=>C was executed.; Such edges of control flow graph are called; `critical <https://en.wikipedia.org/wiki/Control_flow_graph#Special_edges>`_.; The edge-level coverage simply splits all critical edges by introducing new; dummy blocks and then instruments those blocks:. .. code-block:: none. A; |\; | \; D B; | /; |/; C. Tracing data flow; =================. Support for data-flow-guided fuzzing.; With ``-fsanitize-coverage=trace-cmp`` the compiler will insert extra instrumentation; around comparison instructions and switch statements.; Similarly, with ``-fsanitize-coverage=trace-div`` the compiler will instrument; integer division instructions (to capture the right argument of division); and with ``-fsanitize-coverage=trace-gep`` --; the `LLVM GEP instructions <https://llvm.org/docs/GetElementPtr.html>`_; (to capture array indices).; Similarly, with ``-fsanitize-coverage=trace-loads`` and ``-fsanitize-coverage=trace-stores``; the compiler will instrument loads and stores, respectively. Currently, these flags do not work by themselves - they require one; of ``-fsanitize-coverage={trace-pc,inline-8bit-counters,inline-bool}``; flags to work. Unless ``no-prune`` option is provided, some of the comparison instructions; will not be instrumented. .. code-block:: c++. // Called before a comparison instruction.; // Arg1 and Arg2 are arguments of the comparison.; voi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerCoverage.rst:8796,guid,guided,8796,interpreter/llvm-project/clang/docs/SanitizerCoverage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerCoverage.rst,1,['guid'],['guided']
Usability,"e optional) are used to specify what to; output for the ""``-help``"" option. In this case, we get a line that looks like; this:. ::. USAGE: compiler [options]. OPTIONS:; -h - Alias for -help; -help - display available options (-help-hidden for more); -o <filename> - Specify output filename. Because we specified that the command line option should parse using the; ``string`` data type, the variable declared is automatically usable as a real; string in all contexts that a normal C++ string object may be used. For; example:. .. code-block:: c++. ...; std::ofstream Output(OutputFilename.c_str());; if (Output.good()) ...; ... There are many different options that you can use to customize the command line; option handling library, but the above example shows the general interface to; these options. The options can be specified in any order, and are specified; with helper functions like `cl::desc(...)`_, so there are no positional; dependencies to remember. The available options are discussed in detail in the; `Reference Guide`_. Continuing the example, we would like to have our compiler take an input; filename as well as an output filename, but we do not want the input filename to; be specified with a hyphen (ie, not ``-filename.c``). To support this style of; argument, the CommandLine library allows for `positional`_ arguments to be; specified for the program. These positional arguments are filled with command; line parameters that are not in option form. We use this feature like this:. .. code-block:: c++. cl::opt<string> InputFilename(cl::Positional, cl::desc(""<input file>""), cl::init(""-""));. This declaration indicates that the first positional argument should be treated; as the input filename. Here we use the `cl::init`_ option to specify an initial; value for the command line option, which is used if the option is not specified; (if you do not specify a `cl::init`_ modifier for an option, then the default; constructor for the data type is used to initialize the value)",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst:6545,Guid,Guide,6545,interpreter/llvm-project/llvm/docs/CommandLine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst,1,['Guid'],['Guide']
Usability,"e original author who is responsible to revert; the patch promptly. Developers often disagree, and erring on the side of the; developer asking for more review prevents any lingering disagreement over; code in the tree. This does not indicate any fault from the patch author,; this is inherent to our post-commit review practices.; Reverting a patch ensures that design discussions can happen without blocking; other development; it's entirely possible the patch will end up being reapplied; essentially as-is once concerns have been resolved. Before being recommitted, the patch generally should undergo further review.; The community member who identified the problem is expected to engage; actively in the review. In cases where the problem is identified by a buildbot,; a community member with access to hardware similar to that on the buildbot is; expected to engage in the review. Please note: The bar for post-commit feedback is not higher than for pre-commit; feedback. Don't delay unnecessarily in providing feedback. However, if you see; something after code has been committed about which you would have commented; pre-commit (had you noticed it earlier), please feel free to provide that; feedback at any time. That having been said, if a substantial period of time has passed since the; original change was committed, it may be better to create a new patch to; address the issues than comment on the original commit. The original patch; author, for example, might no longer be an active contributor to the project. What Tools Are Used for Code Review?; ------------------------------------. Pre-commit code reviews are conducted on GitHub with Pull Requests. See; :ref:`GitHub <github-reviews>` documentation. When Is an RFC Required?; ------------------------. Some changes are too significant for just a code review. Changes that should; change the LLVM Language Reference (e.g., adding new target-independent; intrinsics), adding language extensions in Clang, and so on, require an RFC;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeReview.rst:3241,feedback,feedback,3241,interpreter/llvm-project/llvm/docs/CodeReview.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeReview.rst,1,['feedback'],['feedback']
Usability,"e ownership responsibility is split between a ""resource owner""; who provides the underlying machine resource, and a ""configuration owner"" who; maintains the build configuration. Generally, operational responsibility lies; with the ""config owner"". We do expect ""resource owners"" - who are generally; the contact listed in a workers attributes - to proxy requests to the relevant; ""config owner"" in a timely manner. Most issues with a buildbot should be addressed directly with a bot owner; via email. Please CC `Galina Kistanova <mailto:gkistanova@gmail.com>`_. Steps To Add Builder To LLVM Buildbot; =====================================; Volunteers can provide their build machines to work as build workers to; public LLVM Buildbot. Here are the steps you can follow to do so:. #. Check the existing build configurations to make sure the one you are; interested in is not covered yet or gets built on your computer much; faster than on the existing one. We prefer faster builds so developers; will get feedback sooner after changes get committed. #. The computer you will be registering with the LLVM buildbot; infrastructure should have all dependencies installed and be able to; build your configuration successfully. Please check what degree; of parallelism (-j param) would give the fastest build. You can build; multiple configurations on one computer. #. Install buildbot-worker (currently we are using buildbot version 2.8.4).; This specific version can be installed using ``pip``, with a command such; as ``pip3 install buildbot-worker==2.8.4``. #. Create a designated user account, your buildbot-worker will be running under,; and set appropriate permissions. #. Choose the buildbot-worker root directory (all builds will be placed under; it), buildbot-worker access name and password the build master will be using; to authenticate your buildbot-worker. #. Create a buildbot-worker in context of that buildbot-worker account. Point it; to the **lab.llvm.org** port **9994** (see `Buildbot d",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToAddABuilder.rst:2665,feedback,feedback,2665,interpreter/llvm-project/llvm/docs/HowToAddABuilder.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToAddABuilder.rst,1,['feedback'],['feedback']
Usability,"e possible to express; compatibility for such architecture versions in the multilib configuration. Not GNU spec files; ------------------. The GNU spec files standard is large and complex and there's little desire to; import that complexity to LLVM. It's also heavily oriented towards processing; command line argument strings which is hard to do correctly, hence the large; amount of logic dedicated to that task in the Clang driver. While compatibility; with GNU would bring benefits, the cost in this case is deemed too high. Avoid re-inventing feature detection in the configuration; ---------------------------------------------------------. A large amount of logic in the Clang driver is dedicated to inferring which; architectural features are available based on the given command line options.; It is neither desirable nor practical to repeat such logic in each multilib; configuration. Instead the configuration should be able to benefit from the; heavy lifting Clang already does to detect features. Low maintenance; ---------------. Multilib is a relatively small feature in the scheme of things so supporting it; should accordingly take little time. Where possible this should be achieved by; implementing it in terms of existing features in the LLVM codebase. Minimal additional API surface; ------------------------------. The greater the API surface, the greater the difficulty of keeping it stable.; Where possible the additional API surface should be kept small by defining it; in relation to existing APIs. An example of this is keeping a simple; relationship between flag names and command line options where possible.; Since the command line options are part of a stable API they are unlikely; to change, and therefore the flag names get the same stability. Low compile-time overhead; -------------------------. If the process of selecting multilib directories must be done on every; invocation of the Clang driver then it must have a negligible impact on; overall compile time.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst:13055,simpl,simple,13055,interpreter/llvm-project/clang/docs/Multilib.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst,1,['simpl'],['simple']
Usability,"e previous values). All combinations are available. ``` {.cpp}; network.Train(1000,""text,graph,update=10""); // full output every; // 10 epochs; network.Train(100,""text,+""); // 100 more epochs; //starts with existing weights; ```. The weights can be saved to a file (`DumpWeights`) and then reloaded; (`LoadWeights`) to a new compatible network. The output can also be; evaluated (`Evaluate`) for a given output neuron and an array of; double input parameters or the network can be exported (`Export`) as a; standalone code. Up to now, this is only as a C++ or PYTHON class, but; other languages could be implemented. ### Examples. An example of how to use **`TMultiLayerPerceptron`** is the macro; `mlpHiggs.C` in \$ROOTSYS/tutorials. Using some standard simulated; information that could have been obtained at `LEP`, a neural network; is build, which can make the difference between `WW` events and events; containing a Higgs boson. Starting with a **`TFile`** containing two; **`TTree`**s: one for the signal, the other for the background, a; simple script is used:. ``` {.cpp}; void mlpHiggs(Int_t ntrain=100) {; if (!gROOT->GetClass(""TMultiLayerPerceptron"")); gSystem->Load(""libMLP"");; // prepare inputs - the 2 trees are merged into one, and a; // ""type"" branch, equal to 1 for the signal and 0 for the; // background is added; TFile input(""mlpHiggs.root"");; TTree *signal = (TTree *)input.Get(""sig_filtered"");; TTree *background = (TTree *)input.Get(""bg_filtered"");; TTree *simu = new TTree(""MonteCarlo"",; ""Filtered Monte Carlo Events"");; ...; ```. Since the input is a **`TTree`** and we are starting from two; different **`TTree`**s (with different names), they are first merged; into one, and a ""`type`"" branch is added, that says whether there is; a signal or a background event. Those irrelevant details are skipped; here. ``` {.cpp}; ...; TMultiLayerPerceptron *mlp = new TMultiLayerPerceptron(; ""msumf,ptsumf, acolin, acopl:8:type"",""ptsumf"",simu,; ""Entry$%2"",""Entry$/2"");; mlp->Train(ntra",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:77957,simpl,simple,77957,documentation/users-guide/FittingHistograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md,1,['simpl'],['simple']
Usability,"e regardless of the output device. .. option:: -help. Print a summary of command line options. .. option:: -o <filename>. Specify the output filename. .. option:: -S. Write output in LLVM intermediate language (instead of bitcode). .. option:: -{passname}. :program:`opt` provides the ability to run any of LLVM's optimization or; analysis passes in any order. The :option:`-help` option lists all the passes; available. The order in which the options occur on the command line are the; order in which they are executed (within pass constraints). .. option:: -strip-debug. This option causes opt to strip debug information from the module before; applying other optimizations. It is essentially the same as `-strip`; but it ensures that stripping of debug information is done first. .. option:: -verify-each. This option causes opt to add a verify pass after every pass otherwise; specified on the command line (including `-verify`). This is useful; for cases where it is suspected that a pass is creating an invalid module but; it is not clear which pass is doing it. .. option:: -stats. Print statistics. .. option:: -time-passes. Record the amount of time needed for each pass and print it to standard; error. .. option:: -debug. If this is a debug build, this option will enable debug printouts from passes; which use the ``LLVM_DEBUG()`` macro. See the `LLVM Programmer's Manual; <../ProgrammersManual.html>`_, section ``#DEBUG`` for more information. .. option:: -load=<plugin>. Load the dynamic object ``plugin``. This object should register new; optimization or analysis passes. Once loaded, the object will add new command; line options to enable various optimizations or analyses. To see the new; complete list of optimizations, use the :option:`-help` and :option:`-load`; options together. For example:. .. code-block:: sh. opt -load=plugin.so -help. .. option:: -print-passes. Print all available passes and exit. EXIT STATUS; -----------. If :program:`opt` succeeds, it will exit with 0.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/opt.rst:2228,clear,clear,2228,interpreter/llvm-project/llvm/docs/CommandGuide/opt.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/opt.rst,1,['clear'],['clear']
Usability,"e split cases.; Improve the performance of TProcessUUID::AddUUID by reintroducing the THashList.; This significanly improve the performance of reading file with very large number of ; directories (A file with 100,000 directories was traversed in more than 8 minutes; and is now traversed in 15s) without noticeable affecting small files. TFolder. Several enhancement and clarification to TFolder::FindFullPathName. TStyle. Add the fill color attribute (SetLegendFillColor() and the font; attribute (SetLegendFont(). A new TStyle called ""Modern"" has been implemented. It can be set with:. gROOT->SetStyle(""Modern"");; ; It has very little decoration. It was made looking at the default styles; usually used by the experiments.; ; A new parameter Canvas.Style in etc/system.rootrc allows; to define the default style. If it is not specified, the Modern; style is used. To use the old default style one can set it to Classic or add. gROOT->SetStyle(""Classic"");; ; to your scripts. We seek feedback on improving the Modern style.; Please leave comments in the forum.; ; The following table shows the two plots hpx->Draw() and hpxpy->Draw(""colz""); in the ""Classic"" and ""Modern"" styles.; . Classic Style; Modern Style. An other example:; ; Classic style:. Modern style:. ACLiC. ACLiC now passes the macro __ACLIC__ to both the rootcint and compiler phases. TWinNTSystem. Fix 64-bit compatibility issues (__asm keyword is not allowed).; Try (as much as possible) to avoid the disturbing ""There is no disk in the drive. Please insert a disk into drive \Device\..."" popup message box when calling AccessPathName() on removable disk drives with no media installed. This should fix the problem reported on the forum.; Prevent short timers (e.g. 10ms) to keep looping in the DispatchOneEvent() infinite loop.; Better stdout/stderr redirection (it was impossible to restore stdout using freopen on Windows 7, leaving the console as a zombie...); Make sure the stdout/stderr redirection works also in the case there",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/doc/v530/index.html:2863,feedback,feedback,2863,core/doc/v530/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/doc/v530/index.html,1,['feedback'],['feedback']
Usability,"e statistics; gathered, use the '``-stats``' option:. .. code-block:: none. $ opt -stats -mypassname < program.bc > /dev/null; ... statistics output ... Note that in order to use the '``-stats``' option, LLVM must be; compiled with assertions enabled. When running ``opt`` on a C file from the SPEC benchmark suite, it gives a; report that looks like this:. .. code-block:: none. 7646 bitcodewriter - Number of normal instructions; 725 bitcodewriter - Number of oversized instructions; 129996 bitcodewriter - Number of bitcode bytes written; 2817 raise - Number of insts DCEd or constprop'd; 3213 raise - Number of cast-of-self removed; 5046 raise - Number of expression trees converted; 75 raise - Number of other getelementptr's formed; 138 raise - Number of load/store peepholes; 42 deadtypeelim - Number of unused typenames removed from symtab; 392 funcresolve - Number of varargs functions resolved; 27 globaldce - Number of global variables removed; 2 adce - Number of basic blocks removed; 134 cee - Number of branches revectored; 49 cee - Number of setcc instruction eliminated; 532 gcse - Number of loads removed; 2919 gcse - Number of instructions removed; 86 indvars - Number of canonical indvars added; 87 indvars - Number of aux indvars removed; 25 instcombine - Number of dead inst eliminate; 434 instcombine - Number of insts combined; 248 licm - Number of load insts hoisted; 1298 licm - Number of insts hoisted to a loop pre-header; 3 licm - Number of insts hoisted to multiple loop preds (bad, no loop pre-header); 75 mem2reg - Number of alloca's promoted; 1444 cfgsimplify - Number of blocks simplified. Obviously, with so many optimizations, having a unified framework for this stuff; is very nice. Making your pass fit well into the framework makes it more; maintainable and useful. .. _DebugCounters:. Adding debug counters to aid in debugging your code; ---------------------------------------------------. Sometimes, when writing new passes, or trying to track down bugs, it; i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:49465,simpl,simplified,49465,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['simpl'],['simplified']
Usability,"e systems is that a ; compiler may fall in anywhere in a ""continuum of compilation"" to do its ; job. On one side, scripting languages statically compile nothing and ; dynamically compile (or equivalently, interpret) everything. On the far ; other side, traditional static compilers process everything statically and ; nothing dynamically. These approaches have typically been seen as a ; tradeoff between performance and portability. On a deeper level, however, ; there are two reasons that optimal system performance may be obtained by a; system somewhere in between these two extremes: Dynamic application ; behavior and social constraints. From a technical perspective, pure static compilation cannot ever give ; optimal performance in all cases, because applications have varying dynamic; behavior that the static compiler cannot take into consideration. Even ; compilers that support profile guided optimization generate poor code in ; the real world, because using such optimization tunes that application ; to one particular usage pattern, whereas real programs (as opposed to ; benchmarks) often have several different usage patterns. On a social level, static compilation is a very shortsighted solution to ; the performance problem. Instruction set architectures (ISAs) continuously ; evolve, and each implementation of an ISA (a processor) must choose a set ; of tradeoffs that make sense in the market context that it is designed for. ; With every new processor introduced, the vendor faces two fundamental ; problems: First, there is a lag time between when a processor is introduced ; to when compilers generate quality code for the architecture. Secondly, ; even when compilers catch up to the new architecture there is often a large ; body of legacy code that was compiled for previous generations and will ; not or can not be upgraded. Thus a large percentage of code running on a ; processor may be compiled quite sub-optimally for the current ; characteristics of the dynamic execu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-04-16-DynamicCompilation.txt:1400,guid,guided,1400,interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-04-16-DynamicCompilation.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-04-16-DynamicCompilation.txt,1,['guid'],['guided']
Usability,"e that kills variable locations is called a ""kill; dbg.value"" or ""kill location"", and for legacy reasons the term ""undef; dbg.value"" may be used in existing code. The ``DbgVariableIntrinsic`` methods; ``isKillLocation`` and ``setKillLocation`` should be used where possible rather; than inspecting location operands directly to check or set whether a dbg.value; is a kill location. In general, if any dbg.value has its operand optimized out and cannot be; recovered, then a kill dbg.value is necessary to terminate earlier variable; locations. Additional kill dbg.values may be necessary when the debugger can; observe re-ordering of assignments. How variable location metadata is transformed during CodeGen; ============================================================. LLVM preserves debug information throughout mid-level and backend passes,; ultimately producing a mapping between source-level information and; instruction ranges. This; is relatively straightforwards for line number information, as mapping; instructions to line numbers is a simple association. For variable locations; however the story is more complex. As each ``llvm.dbg.value`` intrinsic; represents a source-level assignment of a value to a source variable, the; variable location intrinsics effectively embed a small imperative program; within the LLVM IR. By the end of CodeGen, this becomes a mapping from each; variable to their machine locations over ranges of instructions.; From IR to object emission, the major transformations which affect variable; location fidelity are:. 1. Instruction Selection; 2. Register allocation; 3. Block layout. each of which are discussed below. In addition, instruction scheduling can; significantly change the ordering of the program, and occurs in a number of; different passes. Some variable locations are not transformed during CodeGen. Stack locations; specified by ``llvm.dbg.declare`` are valid and unchanging for the entire; duration of the function, and are recorded in a simp",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:24225,simpl,simple,24225,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['simpl'],['simple']
Usability,"e to inlining creating nested exception; handling scopes. Restrictions; ------------. The unwinder delegates the decision of whether to stop in a call frame to that; call frame's language-specific personality function. Not all unwinders guarantee; that they will stop to perform cleanups. For example, the GNU C++ unwinder; doesn't do so unless the exception is actually caught somewhere further up the; stack. In order for inlining to behave correctly, landing pads must be prepared to; handle selector results that they did not originally advertise. Suppose that a; function catches exceptions of type ``A``, and it's inlined into a function that; catches exceptions of type ``B``. The inliner will update the ``landingpad``; instruction for the inlined landing pad to include the fact that ``B`` is also; caught. If that landing pad assumes that it will only be entered to catch an; ``A``, it's in for a rude awakening. Consequently, landing pads must test for; the selector results they understand and then resume exception propagation with; the `resume instruction <LangRef.html#i_resume>`_ if none of the conditions; match. Exception Handling Intrinsics; =============================. In addition to the ``landingpad`` and ``resume`` instructions, LLVM uses several; intrinsic functions (name prefixed with ``llvm.eh``) to provide exception; handling information at various points in generated code. .. _llvm.eh.typeid.for:. ``llvm.eh.typeid.for``; ----------------------. .. code-block:: llvm. i32 @llvm.eh.typeid.for(i8* %type_info). This intrinsic returns the type info index in the exception table of the current; function. This value can be used to compare against the result of; ``landingpad`` instruction. The single argument is a reference to a type info. Uses of this intrinsic are generated by the C++ front-end. .. _llvm.eh.exceptionpointer:. ``llvm.eh.exceptionpointer``; ----------------------------. .. code-block:: text. i8 addrspace(N)* @llvm.eh.padparam.pNi8(token %catchpad). ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ExceptionHandling.rst:14959,resume,resume,14959,interpreter/llvm-project/llvm/docs/ExceptionHandling.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ExceptionHandling.rst,2,['resume'],['resume']
Usability,"e to; another. For example, these rules allow you to assign a value like ``7``; to an entity of type ``bits<4>``. .. productionlist::; Value: `SimpleValue` `ValueSuffix`*; :| `Value` ""#"" [`Value`]; ValueSuffix: ""{"" `RangeList` ""}""; :| ""["" `SliceElements` ""]""; :| ""."" `TokIdentifier`; RangeList: `RangePiece` ("","" `RangePiece`)*; RangePiece: `TokInteger`; :| `TokInteger` ""..."" `TokInteger`; :| `TokInteger` ""-"" `TokInteger`; :| `TokInteger` `TokInteger`; SliceElements: (`SliceElement` "","")* `SliceElement` "",""?; SliceElement: `Value`; :| `Value` ""..."" `Value`; :| `Value` ""-"" `Value`; :| `Value` `TokInteger`. .. warning::; The peculiar last form of :token:`RangePiece` and :token:`SliceElement` is; due to the fact that the ""``-``"" is included in the :token:`TokInteger`,; hence ``1-5`` gets lexed as two consecutive tokens, with values ``1`` and; ``-5``, instead of ""1"", ""-"", and ""5"".; The use of hyphen as the range punctuation is deprecated. Simple values; -------------. The :token:`SimpleValue` has a number of forms. .. productionlist::; SimpleValue: `TokInteger` | `TokString`+ | `TokCode`. A value can be an integer literal, a string literal, or a code literal.; Multiple adjacent string literals are concatenated as in C/C++; the simple; value is the concatenation of the strings. Code literals become strings and; are then indistinguishable from them. .. productionlist::; SimpleValue2: ""true"" | ""false"". The ``true`` and ``false`` literals are essentially syntactic sugar for the; integer values 1 and 0. They improve the readability of TableGen files when; boolean values are used in field initializations, bit sequences, ``if``; statements, etc. When parsed, these literals are converted to integers. .. note::. Although ``true`` and ``false`` are literal names for 1 and 0, we; recommend as a stylistic rule that you use them for boolean; values only. .. productionlist::; SimpleValue3: ""?"". A question mark represents an uninitialized value. .. productionlist::; SimpleValue4: ""{"" [`",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst:14138,Simpl,SimpleValue,14138,interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,1,['Simpl'],['SimpleValue']
Usability,"e values:. * ``UT_Never`` (in configuration: ``Never``); Never use tab. * ``UT_ForIndentation`` (in configuration: ``ForIndentation``); Use tabs only for indentation. * ``UT_ForContinuationAndIndentation`` (in configuration: ``ForContinuationAndIndentation``); Fill all leading whitespace with tabs, and use spaces for alignment that; appears within a line (e.g. consecutive assignments and declarations). * ``UT_AlignWithSpaces`` (in configuration: ``AlignWithSpaces``); Use tabs for line continuation and indentation, and spaces for; alignment. * ``UT_Always`` (in configuration: ``Always``); Use tabs whenever we need to fill whitespace that spans at least from; one tab stop to the next one. .. _VerilogBreakBetweenInstancePorts:. **VerilogBreakBetweenInstancePorts** (``Boolean``) :versionbadge:`clang-format 17` :ref:`¶ <VerilogBreakBetweenInstancePorts>`; For Verilog, put each port on its own line in module instantiations. .. code-block:: c++. true:; ffnand ff1(.q(),; .qbar(out1),; .clear(in1),; .preset(in2));. false:; ffnand ff1(.q(), .qbar(out1), .clear(in1), .preset(in2));. .. _WhitespaceSensitiveMacros:. **WhitespaceSensitiveMacros** (``List of Strings``) :versionbadge:`clang-format 11` :ref:`¶ <WhitespaceSensitiveMacros>`; A vector of macros which are whitespace-sensitive and should not; be touched. These are expected to be macros of the form:. .. code-block:: c++. STRINGIZE(...). In the .clang-format configuration file, this can be configured like:. .. code-block:: yaml. WhitespaceSensitiveMacros: ['STRINGIZE', 'PP_STRINGIZE']. For example: BOOST_PP_STRINGIZE. .. END_FORMAT_STYLE_OPTIONS. Adding additional style options; ===============================. Each additional style option adds costs to the clang-format project. Some of; these costs affect the clang-format development itself, as we need to make; sure that any given combination of options work and that new features don't; break any of the existing options in any way. There are also costs for end users; as o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:133074,clear,clear,133074,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['clear'],['clear']
Usability,"e with an unreachable unwind destination to a call instruction. #. Use profile metadata to indicate statically known cold paths, even if; dynamic profiling information is not available. This can make a large; difference in code placement and thus the performance of tight loops. #. When generating code for loops, try to avoid terminating the header block of; the loop earlier than necessary. If the terminator of the loop header; block is a loop exiting conditional branch, the effectiveness of LICM will; be limited for loads not in the header. (This is due to the fact that LLVM; may not know such a load is safe to speculatively execute and thus can't; lift an otherwise loop invariant load unless it can prove the exiting; condition is not taken.) It can be profitable, in some cases, to emit such; instructions into the header even if they are not used along a rarely; executed path that exits the loop. This guidance specifically does not; apply if the condition which terminates the loop header is itself invariant,; or can be easily discharged by inspecting the loop index variables. #. In hot loops, consider duplicating instructions from small basic blocks; which end in highly predictable terminators into their successor blocks.; If a hot successor block contains instructions which can be vectorized; with the duplicated ones, this can provide a noticeable throughput; improvement. Note that this is not always profitable and does involve a; potentially large increase in code size. #. When checking a value against a constant, emit the check using a consistent; comparison type. The GVN pass *will* optimize redundant equalities even if; the type of comparison is inverted, but GVN only runs late in the pipeline.; As a result, you may miss the opportunity to run other important; optimizations. #. Avoid using arithmetic intrinsics unless you are *required* by your source; language specification to emit a particular code sequence. The optimizer; is quite good at reasoning about gene",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Frontend/PerformanceTips.rst:7863,guid,guidance,7863,interpreter/llvm-project/llvm/docs/Frontend/PerformanceTips.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Frontend/PerformanceTips.rst,1,['guid'],['guidance']
Usability,"e'll add are programmable unary operators; (right now, Kaleidoscope has no unary operators at all) as well as; binary operators. An example of this is:. ::. # Logical unary not.; def unary!(v); if v then; 0; else; 1;. # Define > with the same precedence as <.; def binary> 10 (LHS RHS); RHS < LHS;. # Binary ""logical or"", (note that it does not ""short circuit""); def binary| 5 (LHS RHS); if LHS then; 1; else if RHS then; 1; else; 0;. # Define = with slightly lower precedence than relationals.; def binary= 9 (LHS RHS); !(LHS < RHS | LHS > RHS);. Many languages aspire to being able to implement their standard runtime; library in the language itself. In Kaleidoscope, we can implement; significant parts of the language in the library!. We will break down implementation of these features into two parts:; implementing support for user-defined binary operators and adding unary; operators. User-defined Binary Operators; =============================. Adding support for user-defined binary operators is pretty simple with; our current framework. We'll first add support for the unary/binary; keywords:. .. code-block:: c++. enum Token {; ...; // operators; tok_binary = -11,; tok_unary = -12; };; ...; static int gettok() {; ...; if (IdentifierStr == ""for""); return tok_for;; if (IdentifierStr == ""in""); return tok_in;; if (IdentifierStr == ""binary""); return tok_binary;; if (IdentifierStr == ""unary""); return tok_unary;; return tok_identifier;. This just adds lexer support for the unary and binary keywords, like we; did in `previous chapters <LangImpl05.html#lexer-extensions-for-if-then-else>`_. One nice thing; about our current AST, is that we represent binary operators with full; generalisation by using their ASCII code as the opcode. For our extended; operators, we'll use this same representation, so we don't need any new; AST or parser support. On the other hand, we have to be able to represent the definitions of; these new operators, in the ""def binary\| 5"" part of the function; de",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl06.rst:3382,simpl,simple,3382,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl06.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl06.rst,1,['simpl'],['simple']
Usability,"e) in a MaterializationUnit,; which is then stored in the JITDylib. MaterializationUnits are responsible for; describing the definitions they provide, and for unwrapping the program; representation and passing it back to the layer when compilation is required; (this ownership shuffle makes writing thread-safe layers easier, since the; ownership of the program representation will be passed back on the stack,; rather than having to be fished out of a Layer member, which would require; synchronization). - *MaterializationResponsibility* - When a MaterializationUnit hands a program; representation back to the layer it comes with an associated; MaterializationResponsibility object. This object tracks the definitions; that must be materialized and provides a way to notify the JITDylib once they; are either successfully materialized or a failure occurs. Absolute Symbols, Aliases, and Reexports; ========================================. ORC makes it easy to define symbols with absolute addresses, or symbols that; are simply aliases of other symbols:. Absolute Symbols; ----------------. Absolute symbols are symbols that map directly to addresses without requiring; further materialization, for example: ""foo"" = 0x1234. One use case for; absolute symbols is allowing resolution of process symbols. E.g. .. code-block:: c++. JD.define(absoluteSymbols(SymbolMap({; { Mangle(""printf""),; { ExecutorAddr::fromPtr(&printf),; JITSymbolFlags::Callable } }; });. With this mapping established code added to the JIT can refer to printf; symbolically rather than requiring the address of printf to be ""baked in"".; This in turn allows cached versions of the JIT'd code (e.g. compiled objects); to be re-used across JIT sessions as the JIT'd code no longer changes, only the; absolute symbol definition does. For process and library symbols the DynamicLibrarySearchGenerator utility (See; :ref:`How to Add Process and Library Symbols to JITDylibs; <ProcessAndLibrarySymbols>`) can be used to automatically",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ORCv2.rst:13054,simpl,simply,13054,interpreter/llvm-project/llvm/docs/ORCv2.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ORCv2.rst,1,['simpl'],['simply']
Usability,"e). Divides `MOTHER` into `NDIV` divisions called `NAME` along axis `IAXIS`; starting at coordinate value `START` and having size `STEP`. The created; volumes will have tracking media `ID=NUMED` (if `NUMED=0` -\> same media; as `MOTHER`). The behavior of the division operation can be triggered using `OPTION`; (case insensitive):. - `N`divide all range in `NDIV` cells (same effect as `STEP<=0`); (GSDVN in G3); - `NX`divide range starting with `START` in `NDIV` cells (GSDVN2 in; G3); - `S`divide all range with given `STEP`; `NDIV` is computed and; divisions will be centered in full range (same effect as `NDIV<=0`); (GSDVS, GSDVT in G3); - `SX`same as `DVS`, but from `START` position (GSDVS2, GSDVT2 in G3). \anchor GP01bj; #### Volume Assemblies. In general, geometry contains structures of positioned volumes that have; to be grouped and handled together, for different possible reasons. One; of these is that the structure has to be replicated in several parts of; the geometry, or it may simply happen that they really represent a; single object, too complex to be described by a primitive shape. Usually handling structures like these can be easily done by positioning; all components in the same container volume, then positioning the; container itself. However, there are many practical cases when defining; such a container is not straightforward or even possible without; generating overlaps with the rest of the geometry. There are few ways; out of this:. - Defining the container for the structure as ""overlapping"" (see also; ""Overlapping Volumes""); - Representing the container as a composite shape - the Boolean union; of all components (see also ""Composite Shapes""); - Using an assembly volume - this will be described in the following. The first two approaches have the disadvantage of penalizing the; navigation performance with a factor increasing more than linear of the; number of components in the structure. The best solution is the third; one because it uses all volume-rel",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:48584,simpl,simply,48584,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['simpl'],['simply']
Usability,"e, in one script you can use ACLiC to compile and load another; script. ``` {.cpp}; gROOT->ProcessLine("".L MyScript.C+""); gROOT->ProcessLine("".L MyScript.C++""); ```. ### Setting the Include Path. You can get the include path by typing:. ``` {.cpp}; root[] .include; ```. You can append to the include path by typing:. ``` {.cpp}; root[] .include $HOME/mypackage/include; ```. In a script you can append to the include path:. ``` {.cpp}; gSystem->AddIncludePath("" -I$HOME/mypackage/include ""); ```. You can also overwrite the existing include path:. ``` {.cpp}; gSystem->SetIncludePath("" -I$HOME/mypackage/include ""); ```. The `$ROOTSYS/include` directory is automatically appended to the; include path, so you do not have to worry about including it. To add; library that should be used during linking of the shared library use; something like:. ``` {.cpp}; gSystem->AddLinkedLibs(""-L/my/path -lanylib"");; ```. This is especially useful for static libraries. For shared ones you; can also simply load them before trying to compile the script:. ``` {.cpp}; gSystem->Load(""mydir/mylib"");; ```. ACLiC uses the directive `fMakeSharedLibs` to create the shared; library. If loading the shared library fails, it tries to output a; list of missing symbols by creating an executable (on some platforms; like OSF, this does not HAVE to be an executable) containing the; script. It uses the directive `fMakeExe` to do so. For both; directives, before passing them to `TSystem::Exec()`, it expands the; variables `$SourceFiles`, `$SharedLib`, `$LibName`, `$IncludePath`,; `$LinkedLibs`, `$ExeName `and` $ObjectFiles`. See `SetMakeSharedLib()`; for more information on those variables. When the file being passed to; ACLiC is on a read only file system, ACLiC warns the user and creates; the library in a temporary directory:. ``` {.cpp}; root[] .L readonly/t.C++; Warning in <ACLiC>: /scratch/aclic/subs/./readonly is not writable!; Warning in <ACLiC>: Output will be written to /tmp; Info in <TUnixSystem::ACLiC",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md:17204,simpl,simply,17204,documentation/users-guide/Cling.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md,1,['simpl'],['simply']
Usability,"e, the gas has some container also, but let; us keeps it like that for the sake of simplicity. Since we did not; supply the third argument, the wire will be positioned with an identity; transformation inside the chamber. \anchor GP01bf; #### Overlapping Volumes. Positioning volumes that does not overlap their neighbors nor extrude; their container is sometimes quite strong constraint. Having a limited; set of geometric shapes might force sometimes overlaps. Since; overlapping is contradictory to containment, a point belonging to an; overlapping region will naturally belong to all overlapping partners.; The answer provided by the modeller to ""Where am I?"" is no longer; deterministic if there is no priority assigned. There are two ways out provided by the modeller in such cases and we; will illustrate them by examples. - Suppose we have 2 crossing tubes that we have to describe. Such a; structure cannot be decomposed in a containment schema. This is a; typical example of simple structure that can be handled by using; composite shapes. What we have to do is to define as shapes the; inner and outer parts of the tubes (tubes having; `Rmin=0`,` Rmax=`inner/outer radius), then to make a composite:; - `C = (Tub1out+Tub2out)-(Tub1in+Tub2in)`; - On the other hand, if we have an EM calorimeter having a honeycomb; structure, Boolean combinations do not help anymore. Here the; problem is that we usually have a very large number of cells that; are naturally belonging to the same container. This result in a very; flat and slow structure for that particular container, which we; would very much want to avoid by introducing additional levels in; depth. We can describe the basic cell as a hexahedron that we can; represent by using a polygon primitive shape. Instead of putting one; by one all cells in the same container, we can define rows of such; elements, fitting in box-shaped containers. Then we can put; row-beside-row inside the container, making life much easier for its; navigatio",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:36243,simpl,simple,36243,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['simpl'],['simple']
Usability,"e-manual/VLEPEM.pdf>`_. Other documents, collections, notes; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. * `PowerPC Compiler Writer's Guide <http://www.ibm.com/chips/techlib/techlib.nsf/techdocs/852569B20050FF7785256996007558C6>`_; * `Intro to PowerPC Architecture <http://www.ibm.com/developerworks/linux/library/l-powarch/>`_; * `Various IBM specifications and white papers <https://www.power.org/documentation/?document_company=105&document_category=all&publish_year=all&grid_order=DESC&grid_sort=title>`_; * `PowerPC ABI documents <http://penguinppc.org/dev/#library>`_; * `PowerPC64 alignment of long doubles (from GCC) <http://gcc.gnu.org/ml/gcc-patches/2003-09/msg00997.html>`_; * `Long branch stubs for powerpc64-linux (from binutils) <http://sources.redhat.com/ml/binutils/2002-04/msg00573.html>`_. AMDGPU; ------. Refer to :doc:`AMDGPUUsage` for additional documentation. RISC-V; ------; * `RISC-V User-Level ISA Specification <https://riscv.org/specifications/>`_. C-SKY; ------; * `C-SKY Architecture User Guide <https://github.com/c-sky/csky-doc/blob/master/CSKY%20Architecture%20user_guide.pdf>`_; * `C-SKY V2 ABI <https://github.com/c-sky/csky-doc/blob/master/C-SKY_V2_CPU_Applications_Binary_Interface_Standards_Manual.pdf>`_. LoongArch; ---------; * `LoongArch Reference Manual - Volume 1: Basic Architecture <https://loongson.github.io/LoongArch-Documentation/LoongArch-Vol1-EN.html>`_; * `LoongArch ELF ABI specification <https://loongson.github.io/LoongArch-Documentation/LoongArch-ELF-ABI-EN.html>`_. SPARC; -----. * `SPARC standards <http://sparc.org/standards>`_; * `SPARC V9 ABI <http://sparc.org/standards/64.psabi.1.35.ps.Z>`_; * `SPARC V8 ABI <http://sparc.org/standards/psABI3rd.pdf>`_. SystemZ; -------. * `z/Architecture Principles of Operation (registration required, free sign-up) <http://www-01.ibm.com/support/docview.wss?uid=isg2b9de5f05a9d57819852571c500428f9a>`_. VE; --. * `NEC SX-Aurora TSUBASA ISA Guide <https://www.hpc.nec/documents/guide/pdfs/Aurora_ISA_guide.pdf>`",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CompilerWriterInfo.rst:4708,Guid,Guide,4708,interpreter/llvm-project/llvm/docs/CompilerWriterInfo.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CompilerWriterInfo.rst,1,['Guid'],['Guide']
Usability,"e-types-functions-variables-and-enumerators-properly>`_; states:. Variable names should be nouns (as they represent state). The name should be; camel case, and start with an upper case letter (e.g. Leader or Boats). This rule is the same as that for type names. This is a problem because the; type name cannot be reused for a variable name [*]_. LLVM developers tend to; work around this by either prepending ``The`` to the type name::. Triple TheTriple;. ... or more commonly use an acronym, despite the coding standard stating ""Avoid; abbreviations unless they are well known""::. Triple T;. The proliferation of acronyms leads to hard-to-read code such as `this; <https://github.com/llvm/llvm-project/blob/0a8bc14ad7f3209fe702d18e250194cd90188596/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp#L7445>`_::. InnerLoopVectorizer LB(L, PSE, LI, DT, TLI, TTI, AC, ORE, VF.Width, IC,; &LVL, &CM);. Many other coding guidelines [LLDB]_ [Google]_ [WebKit]_ [Qt]_ [Rust]_ [Swift]_; [Python]_ require that variable names begin with a lower case letter in contrast; to class names which begin with a capital letter. This convention means that the; most readable variable name also requires the least thought::. Triple triple;. There is some agreement that the current rule is broken [LattnerAgree]_; [ArsenaultAgree]_ [RobinsonAgree]_ and that acronyms are an obstacle to reading; new code [MalyutinDistinguish]_ [CarruthAcronym]_ [PicusAcronym]_. There are; some opposing views [ParzyszekAcronym2]_ [RicciAcronyms]_. This work-in-progress proposal is to change the coding standard for variable; names to require that they start with a lower case letter. .. [*] In `some cases; <https://github.com/llvm/llvm-project/blob/8b72080d4d7b13072f371712eed333f987b7a18e/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp#L2727>`_; the type name *is* reused as a variable name, but this shadows the type name; and confuses many debuggers [DenisovCamelBack]_. Variable Names Coding Standard Options; =======================",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst:1710,guid,guidelines,1710,interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst,1,['guid'],['guidelines']
Usability,"e. If $\mbox{par}$ is not specified, all variable parameters are; scanned in sequence. The number of points $\mbox{npoints}$ in the; scan is 40 by default, and cannot exceed 100. The range of the scan is; by default 2 standard deviations on each side of the current best value,; but can be specified as from $\mbox{low}$ to $\mbox{high}$.; After each scan, if a new minimum is found, the best parameter values; are retained as start values for future scans or minimizations. The; curve resulting from each scan can be plotted on the output terminal; using MnPlot [api:plot] in order to show the approximate behaviour of; the function. ### ScanMinimizer ###. Although the $\mbox{SCAN}$ method is not intended for minimization; it can be used as a minimizer in its most primitive form. ## MnSimplex and SimplexMinimizer ##. [api:simplex]. $\mbox{SIMPLEX}$ is a function minimization method using the simplex; method of Nelder and Mead. MnSimplex provides minimization of the; function by the method of $\mbox{SIMPLEX}$ and the functionality for; parameters interaction. It also retains the result from the last; minimization in case the user may want to do subsequent minimization; steps with parameter interactions in between the minimization requests.; The minimization is done by the SimplexMinimizer. Minimization of the; function can be done by directly using the SimplexMinimizer if no; parameters interaction is required. As $\mbox{SIMPLEX}$ is a; stepping method it does not produce a covariance matrix. ### MnSimplex(const FCNBase&, const std::vector$<$double$>$&,\; const std::vector$<$double$>$&, unsigned int) ###. Constructor for the minimal required interface: $\mbox{FCN}$ and; starting values for parameters and uncertainties. Optional the strategy; level in MnStrategy can be specified. ### MnSimplex(const FCNBase&, const MnUserParameters&,\; unsigned int) ###. Constructor for high level parameters interface. Optional the strategy; level in MnStrategy can be specified. ### MnSimple",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:48586,SIMPL,SIMPLEX,48586,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['SIMPL'],['SIMPLEX']
Usability,"e:. .. code-block:: llvm. %Y = add i32 %X, 1; %Z = add i32 %Y, 1. into:. .. code-block:: llvm. %Z = add i32 %X, 2. This is a simple worklist driven algorithm. This pass guarantees that the following canonicalizations are performed on the; program:. #. If a binary operator has a constant operand, it is moved to the right-hand; side.; #. Bitwise operators with constant operands are always grouped so that shifts; are performed first, then ``or``\ s, then ``and``\ s, then ``xor``\ s.; #. Compare instructions are converted from ``<``, ``>``, ``≤``, or ``≥`` to; ``=`` or ``≠`` if possible.; #. All ``cmp`` instructions on boolean values are replaced with logical; operations.; #. ``add X, X`` is represented as ``mul X, 2`` ⇒ ``shl X, 1``; #. Multiplies with a constant power-of-two argument are transformed into; shifts.; #. … etc. This pass can also simplify calls to specific well-known function calls (e.g.; runtime library functions). For example, a call ``exit(3)`` that occurs within; the ``main()`` function can be transformed into simply ``return 3``. Whether or; not library calls are simplified is controlled by the; :ref:`-function-attrs <passes-function-attrs>` pass and LLVM's knowledge of; library calls on different targets. .. _passes-aggressive-instcombine:. ``aggressive-instcombine``: Combine expression patterns; --------------------------------------------------------. Combine expression patterns to form expressions with fewer, simple instructions. For example, this pass reduce width of expressions post-dominated by TruncInst; into smaller width when applicable. It differs from instcombine pass in that it can modify CFG and contains pattern; optimization that requires higher complexity than the O(1), thus, it should run fewer; times than instcombine pass. ``internalize``: Internalize Global Symbols; -------------------------------------------. This pass loops over all of the functions in the input module, looking for a; main function. If a main function is found, al",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst:20606,simpl,simply,20606,interpreter/llvm-project/llvm/docs/Passes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst,1,['simpl'],['simply']
Usability,"e:. <IfModule mod_headers.c>; <FilesMatch ""\.root"">; Header set Access-Control-Allow-Origin ""*""; Header set Access-Control-Allow-Headers ""range""; Header set Access-Control-Expose-Headers ""content-range,content-length,accept-ranges""; Header set Access-Control-Allow-Methods ""GET""; </FilesMatch>; </IfModule>. More details about configuring of CORS headers can be found [here](https://developer.mozilla.org/en/http_access_control). Alternative - enable CORS requests in the browser. It can be easily done with [CORS Everywhere plugin](https://addons.mozilla.org/de/firefox/addon/cors-everywhere/) for the Firefox browser or [Allow CORS plugin](https://chrome.google.com/webstore/detail/allow-control-allow-origi/nlfbmbojpeacfghkpbjhddihlkkiljbi?hl=en) for the Chrome browser. Next solution - install JSROOT on the server hosting ROOT files. In such configuration JSROOT does not issue CORS requests, therefore server and browsers can be used with their default settings. A simplified variant of such solution - copy only the top index.htm file from JSROOT package and specify the full path to `modules/gui.mjs` script like:. ```javascript; <script type=""module"">; import { openFile, draw } from 'https://root.cern/js/latest/modules/gui.mjs';; // ...; </script>; ```. In the main `<div>` element one can specify many custom parameters like one do it in URL string:. ```html; <div id=""simpleGUI"" path=""files/path"" files=""userfile1.root;subdir/usefile2.root"">; loading scripts ...; </div>; ```. ## Reading local ROOT files. JSROOT can read files from local file system using HTML5 FileReader functionality.; Main limitation here - user should interactively select files for reading.; There is button __""...""__ on the main JSROOT page, which starts file selection dialog.; If valid ROOT file is selected, JSROOT will be able to normally read content of such file. ## JSROOT with THttpServer. THttpServer provides http access to objects from running ROOT application.; JSROOT is used to implement the user in",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/JSROOT/JSROOT.md:28857,simpl,simplified,28857,documentation/JSROOT/JSROOT.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/JSROOT/JSROOT.md,1,['simpl'],['simplified']
Usability,"e; * Proves values to be constant, and replaces them with constants; * Proves conditional branches to be unconditional. Note that this pass has a habit of making definitions be dead. It is a good; idea to run a :ref:`DCE <passes-dce>` pass sometime after running this pass. .. _passes-simplifycfg:. ``simplifycfg``: Simplify the CFG; ---------------------------------. Performs dead code elimination and basic block merging. Specifically:. * Removes basic blocks with no predecessors.; * Merges a basic block into its predecessor if there is only one and the; predecessor only has one successor.; * Eliminates PHI nodes for basic blocks with a single predecessor.; * Eliminates a basic block that only contains an unconditional branch. ``sink``: Code sinking; ----------------------. This pass moves instructions into successor blocks, when possible, so that they; aren't executed on paths where their results aren't needed. .. _passes-simple-loop-unswitch:. ``simple-loop-unswitch``: Unswitch loops; ----------------------------------------. This pass transforms loops that contain branches on loop-invariant conditions; to have multiple loops. For example, it turns the left into the right code:. .. code-block:: c++. for (...) if (lic); A for (...); if (lic) A; B; C; B else; C for (...); A; C. This can increase the size of the code exponentially (doubling it every time a; loop is unswitched) so we only unswitch if the resultant code will be smaller; than a threshold. This pass expects :ref:`LICM <passes-licm>` to be run before it to hoist; invariant conditions out of the loop, to make the unswitching opportunity; obvious. ``strip``: Strip all symbols from a module; ------------------------------------------. Performs code stripping. This transformation can delete:. * names for virtual registers; * symbols for internal globals and functions; * debug information. Note that this transformation makes code much less readable, so it should only; be used in situations where the strip utili",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst:35393,simpl,simple-loop-unswitch,35393,interpreter/llvm-project/llvm/docs/Passes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst,1,['simpl'],['simple-loop-unswitch']
Usability,"e; developer asking for more review prevents any lingering disagreement over; code in the tree. This does not indicate any fault from the patch author,; this is inherent to our post-commit review practices.; Reverting a patch ensures that design discussions can happen without blocking; other development; it's entirely possible the patch will end up being reapplied; essentially as-is once concerns have been resolved. Before being recommitted, the patch generally should undergo further review.; The community member who identified the problem is expected to engage; actively in the review. In cases where the problem is identified by a buildbot,; a community member with access to hardware similar to that on the buildbot is; expected to engage in the review. Please note: The bar for post-commit feedback is not higher than for pre-commit; feedback. Don't delay unnecessarily in providing feedback. However, if you see; something after code has been committed about which you would have commented; pre-commit (had you noticed it earlier), please feel free to provide that; feedback at any time. That having been said, if a substantial period of time has passed since the; original change was committed, it may be better to create a new patch to; address the issues than comment on the original commit. The original patch; author, for example, might no longer be an active contributor to the project. What Tools Are Used for Code Review?; ------------------------------------. Pre-commit code reviews are conducted on GitHub with Pull Requests. See; :ref:`GitHub <github-reviews>` documentation. When Is an RFC Required?; ------------------------. Some changes are too significant for just a code review. Changes that should; change the LLVM Language Reference (e.g., adding new target-independent; intrinsics), adding language extensions in Clang, and so on, require an RFC; (Request for Comment) email on the project's ``*-dev`` mailing list first. For; changes that promise significant impact o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeReview.rst:3425,feedback,feedback,3425,interpreter/llvm-project/llvm/docs/CodeReview.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeReview.rst,1,['feedback'],['feedback']
Usability,"e; execution of at least one cycle header, or ``X`` itself is a cycle; header. In reducible cycles (natural loops), each execution of the header is; equivalent to the start of a new iteration of the cycle. But this; analogy breaks down in the presence of explicit constraints on the; converged-with relation, such as those described in :ref:`future; work<convergence-note-convergence>`. Instead, cycle headers should be; treated as implicit *points of convergence* in a maximal; converged-with relation. Consider a sequence of nested cycles ``C1``, ``C2``, ..., ``Ck`` such; that ``C1`` is the outermost cycle and ``Ck`` is the innermost cycle,; with headers ``H1``, ``H2``, ..., ``Hk`` respectively. When a thread; enters the cycle ``Ck``, any of the following is possible:. 1. The thread directly entered cycle ``Ck`` without having executed; any of the headers ``H1`` to ``Hk``. 2. The thread executed some or all of the nested headers one or more; times. The maximal converged-with relation captures the following intuition; about cycles:. 1. When two threads enter a top-level cycle ``C1``, they execute; converged dynamic instances of every node that is a :ref:`child; <cycle-parent-block>` of ``C1``. 2. When two threads enter a nested cycle ``Ck``, they execute; converged dynamic instances of every node that is a child of; ``Ck``, until either thread exits ``Ck``, if and only if they; executed converged dynamic instances of the last nested header that; either thread encountered. Note that when a thread exits a nested cycle ``Ck``, it must follow; a closed path outside ``Ck`` to reenter it. This requires executing; the header of some outer cycle, as described earlier. Consider two dynamic instances ``X1`` and ``X2`` produced by threads ``T1``; and ``T2`` for a node ``X`` that is a child of nested cycle ``Ck``.; Maximal convergence relates ``X1`` and ``X2`` as follows:. 1. If neither thread executed any header from ``H1`` to ``Hk``, then; ``X1`` and ``X2`` are converged. 2. Otherw",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergenceAndUniformity.rst:12401,intuit,intuition,12401,interpreter/llvm-project/llvm/docs/ConvergenceAndUniformity.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergenceAndUniformity.rst,1,['intuit'],['intuition']
Usability,"e; provided in the ``DependenceGraphBuilder`` class, while the ``DDGBuilder``; and ``PDGBuilder`` control some aspects of how the graph is constructed; by the way of overriding virtual methods defined in ``DependenceGraphBuilder``. Note also that the steps and the names used in this diagram are for; illustrative purposes and may be different from those in the actual; implementation. Design Trade-offs; -----------------. Advantages:; ^^^^^^^^^^^; - Builder allows graph construction code to be reused for DDG and PDG.; - Builder allows us to create DDG and PDG as separate graphs.; - DDG nodes and edges are completely disjoint from PDG nodes and edges allowing them to change easily and independently. Disadvantages:; ^^^^^^^^^^^^^^; - Builder may be perceived as over-engineering at first.; - There are some similarities between DDG nodes and edges compared to PDG nodes and edges, but there is little reuse of the class definitions. - This is tolerable given that the node and edge types are fairly simple and there is little code reuse opportunity anyway. .. _implementation-details:. Implementation Details; ======================. The current implementation of DDG differs slightly from the dependence; graph described in [1]_ in the following ways:. 1. The graph nodes in the paper represent three main program components, namely *assignment statements*, *for loop headers* and *while loop headers*. In this implementation, DDG nodes naturally represent LLVM IR instructions. An assignment statement in this implementation typically involves a node representing the ``store`` instruction along with a number of individual nodes computing the right-hand-side of the assignment that connect to the ``store`` node via a def-use edge. The loop header instructions are not represented as special nodes in this implementation because they have limited uses and can be easily identified, for example, through ``LoopAnalysis``.; 2. The paper describes five types of dependency edges between nodes n",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DependenceGraphs/index.rst:4716,simpl,simple,4716,interpreter/llvm-project/llvm/docs/DependenceGraphs/index.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DependenceGraphs/index.rst,1,['simpl'],['simple']
Usability,"e; regression tests to ensure everything is in working order. * CMake will generate build targets for each tool and library, and most; LLVM sub-projects generate their own ``check-<project>`` target. * Running a serial build will be **slow**. To improve speed, try running a; parallel build. That's done by default in Ninja; for ``make``, use the; option ``-j NN``, where ``NN`` is the number of parallel jobs, e.g. the; number of available CPUs. * A basic CMake and build/test invocation which only builds LLVM and no other; subprojects:. ``cmake -S llvm -B build -G Ninja -DCMAKE_BUILD_TYPE=Debug``. ``ninja -C build check-llvm``. This will setup an LLVM build with debugging info, then compile LLVM and; run LLVM tests. * For more detailed information on CMake options, see `CMake <CMake.html>`__. * If you get build or test failures, see `below`_. Consult the `Getting Started with LLVM`_ section for detailed information on; configuring and compiling LLVM. Go to `Directory Layout`_ to learn about the; layout of the source code tree. Stand-alone Builds; ------------------. Stand-alone builds allow you to build a sub-project against a pre-built; version of the clang or llvm libraries that is already present on your; system. You can use the source code from a standard checkout of the llvm-project; (as described above) to do stand-alone builds, but you may also build; from a :ref:`sparse checkout<workflow-multicheckout-nocommit>` or from the; tarballs available on the `releases <https://github.com/llvm/llvm-project/releases/>`_; page. For stand-alone builds, you must have an llvm install that is configured; properly to be consumable by stand-alone builds of the other projects.; This could be a distro provided LLVM install, or you can build it yourself,; like this:. .. code-block:: console. cmake -G Ninja -S path/to/llvm-project/llvm -B $builddir \; -DLLVM_INSTALL_UTILS=ON \; -DCMAKE_INSTALL_PREFIX=/path/to/llvm/install/prefix \; < other options >. ninja -C $builddir install. Onc",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst:5077,learn,learn,5077,interpreter/llvm-project/llvm/docs/GettingStarted.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst,1,['learn'],['learn']
Usability,"e; reviewer has experience with the area of LLVM and knows the design goals; well. The author of a change will often assign a specific reviewer (git; blame and git log can be useful to find one). As our change is fairly simple, we'll add the cfe-commits mailing list; as a subscriber; anyone who works on clang can likely pick up the; review. (For changes outside clang, llvm-commits is the usual list. See; `http://lists.llvm.org/ <http://lists.llvm.org/mailman/listinfo>`__ for; all the \*-commits mailing lists). Uploading a change for review; -----------------------------. LLVM code reviews happen through pull-request on GitHub, see; :ref:`GitHub <github-reviews>` documentation for how to open; a pull-request on GitHub. Review process; --------------. When you open a pull-request, some automation will add a comment and; notify different member of the projects depending on the component you; changed.; Within a few days, someone should start the review. They may add; themselves as a reviewer, or simply start leaving comments. You'll get; another email any time the review is updated. The details are in the; `https://llvm.org/docs/CodeReview/ <https://llvm.org/docs/CodeReview.html>`__. Comments; ~~~~~~~~. The reviewer can leave comments on the change, and you can reply. Some; comments are attached to specific lines, and appear interleaved with the; code. You can either reply to these, or address them and mark them as; ""done"". Note that in-line replies are **not** sent straight away! They; become ""draft"" comments and you must click ""Submit"" at the bottom of the; page. Updating your change; ~~~~~~~~~~~~~~~~~~~~. If you make changes in response to a reviewer's comments, simply update; your branch with more commits and push to your fork. It may be a good; idea to answer the comments from the reviewer explicitly. Accepting a revision; ~~~~~~~~~~~~~~~~~~~~. When the reviewer is happy with the change, they will **Accept** the; revision. They may leave some more minor comments th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MyFirstTypoFix.rst:10098,simpl,simply,10098,interpreter/llvm-project/llvm/docs/MyFirstTypoFix.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MyFirstTypoFix.rst,1,['simpl'],['simply']
Usability,"e; sure 'dot' and 'gv' are in your path. If you are running on macOS, download; and install the macOS `Graphviz program; <http://www.pixelglow.com/graphviz/>`_ and add; ``/Applications/Graphviz.app/Contents/MacOS/`` (or wherever you install it) to; your path. The programs need not be present when configuring, building or; running LLVM and can simply be installed when needed during an active debug; session. ``SelectionDAG`` has been extended to make it easier to locate *interesting*; nodes in large complex graphs. From gdb, if you ``call DAG.setGraphColor(node,; ""color"")``, then the next ``call DAG.viewGraph()`` would highlight the node in; the specified color (choices of colors can be found at `colors; <http://www.graphviz.org/doc/info/colors.html>`_.) More complex node attributes; can be provided with ``call DAG.setGraphAttrs(node, ""attributes"")`` (choices can; be found at `Graph attributes <http://www.graphviz.org/doc/info/attrs.html>`_.); If you want to restart and clear all the current graph attributes, then you can; ``call DAG.clearGraphAttrs()``. Note that graph visualization features are compiled out of Release builds to; reduce file size. This means that you need a Debug+Asserts or Release+Asserts; build to use these features. .. _datastructure:. Picking the Right Data Structure for a Task; ===========================================. LLVM has a plethora of data structures in the ``llvm/ADT/`` directory, and we; commonly use STL data structures. This section describes the trade-offs you; should consider when you pick one. The first step is a choose your own adventure: do you want a sequential; container, a set-like container, or a map-like container? The most important; thing when choosing a container is the algorithmic properties of how you plan to; access the container. Based on that, you should use:. * a :ref:`map-like <ds_map>` container if you need efficient look-up of a; value based on another value. Map-like containers also support efficient; queries f",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:54482,clear,clear,54482,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['clear'],['clear']
Usability,"e; used is when we want that a volume positioned inside a container to; match one ore more container limits. Suppose we want to position the; same box inside 2 different volumes and we want the Z size to match the; one of each container:. ~~~{.cpp}; TGeoVolume *container1 = gGeoManager->MakeBox(""C1"",imed,10,10,30);; TGeoVolume *container2 = gGeoManager->MakeBox(""C2"",imed,10,10,20);; TGeoVolume *pvol = gGeoManager->MakeBox(""PVOL"",jmed,3,3,-1);; container1->AddNode(pvol,1);; container2->AddNode(pvol,1);; ~~~. Note that the third parameter of `PVOL` is negative, which does not make; sense as half-length on Z. This is interpreted as: when positioned,; create a box replacing all invalid parameters with the corresponding; dimensions of the container. This is also internally handled by the; **`TGeoVolumeMulti`** class, which does not need to be instantiated by; users. \anchor GP01bi; #### Dividing Volumes. Volumes can be divided according a pattern. The simplest division can be; done along one axis that can be: `X,Y,Z,Phi,Rxy or Rxyz`. Let's take a; simple case: we would like to divide a box in N equal slices along X; coordinate, representing a new volume family. Supposing we already have; created the initial box, this can be done like:. ~~~{.cpp}; TGeoVolume *slicex = box->Divide(""SLICEX"",1,N);; ~~~. Here `SLICEX` is the name of the new family representing all slices and; 1 is the slicing axis. The meaning of the axis index is the following:; for all volumes having shapes like `box`, `trd1`, `trd2`, `trap`,; `gtra `or` para - `1, 2, 3 mean X, Y, Z; for `tube`, `tubs`, `cone`,; `cons - `1 means `Rxy`, 2 means `phi` and 3 means Z; for `pcon` and; `pgon` - 2 means `phi` and 3 means Z; for spheres 1 means `R `and 2; means `phi.`. In fact, the division operation has the same effect as positioning; volumes in a given order inside the divided container - the advantage; being that the navigation in such a structure is much faster. When a; volume is divided, a volume family corres",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:44231,simpl,simplest,44231,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['simpl'],['simplest']
Usability,"eMapper`` method:. .. code-block:: c++. int main(int argc, char *argv[]) {; ExitOnErr.setBanner(std::string(argv[0]) + "" error:"");; ExitOnErr.setExitCodeMapper(; [](const Error &Err) {; if (Err.isA<BadFileFormat>()); return 2;; return 1;; });. Use ``ExitOnError`` in your tool code where possible as it can greatly improve; readability. .. _err_cantfail:. Using cantFail to simplify safe callsites; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Some functions may only fail for a subset of their inputs, so calls using known; safe inputs can be assumed to succeed. The cantFail functions encapsulate this by wrapping an assertion that their; argument is a success value and, in the case of Expected<T>, unwrapping the; T value:. .. code-block:: c++. Error onlyFailsForSomeXValues(int X);; Expected<int> onlyFailsForSomeXValues2(int X);. void foo() {; cantFail(onlyFailsForSomeXValues(KnownSafeValue));; int Y = cantFail(onlyFailsForSomeXValues2(KnownSafeValue));; ...; }. Like the ExitOnError utility, cantFail simplifies control flow. Their treatment; of error cases is very different however: Where ExitOnError is guaranteed to; terminate the program on an error input, cantFail simply asserts that the result; is success. In debug builds this will result in an assertion failure if an error; is encountered. In release builds the behavior of cantFail for failure values is; undefined. As such, care must be taken in the use of cantFail: clients must be; certain that a cantFail wrapped call really can not fail with the given; arguments. Use of the cantFail functions should be rare in library code, but they are; likely to be of more use in tool and unit-test code where inputs and/or; mocked-up classes or functions may be known to be safe. Fallible constructors; """""""""""""""""""""""""""""""""""""""""". Some classes require resource acquisition or other complex initialization that; can fail during construction. Unfortunately constructors can't return errors,; and having clients test objects after they're constr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:32680,simpl,simplifies,32680,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['simpl'],['simplifies']
Usability,"eMatcher<Type>; Narrows PointerType (and similar) matchers to those where the; pointee matches a given matcher. Given; int *a;; int const *b;; float const *f;; pointerType(pointee(isConstQualified(), isInteger())); matches ""int const *b"". Usable as: Matcher<BlockPointerType>, Matcher<MemberPointerType>,; Matcher<PointerType>, Matcher<ReferenceType>. Matcher<CXXBaseSpecifier>hasTypeLocMatcher<TypeLoc> Inner; Matches if the type location of a node matches the inner matcher. Examples:; int x;; declaratorDecl(hasTypeLoc(loc(asString(""int"")))); matches int x. auto x = int(3);; cxxTemporaryObjectExpr(hasTypeLoc(loc(asString(""int"")))); matches int(3). struct Foo { Foo(int, int); };; auto x = Foo(1, 2);; cxxFunctionalCastExpr(hasTypeLoc(loc(asString(""struct Foo"")))); matches Foo(1, 2). Usable as: Matcher<BlockDecl>, Matcher<CXXBaseSpecifier>,; Matcher<CXXCtorInitializer>, Matcher<CXXFunctionalCastExpr>,; Matcher<CXXNewExpr>, Matcher<CXXTemporaryObjectExpr>,; Matcher<CXXUnresolvedConstructExpr>,; Matcher<ClassTemplateSpecializationDecl>, Matcher<CompoundLiteralExpr>,; Matcher<DeclaratorDecl>, Matcher<ExplicitCastExpr>,; Matcher<ObjCPropertyDecl>, Matcher<TemplateArgumentLoc>,; Matcher<TypedefNameDecl>. Matcher<CXXBaseSpecifier>hasTypeMatcher<Decl> InnerMatcher; Overloaded to match the declaration of the expression's or value; declaration's type. In case of a value declaration (for example a variable declaration),; this resolves one layer of indirection. For example, in the value; declaration ""X x;"", cxxRecordDecl(hasName(""X"")) matches the declaration of; X, while varDecl(hasType(cxxRecordDecl(hasName(""X"")))) matches the; declaration of x. Example matches x (matcher = expr(hasType(cxxRecordDecl(hasName(""X""))))); and z (matcher = varDecl(hasType(cxxRecordDecl(hasName(""X""))))); and friend class X (matcher = friendDecl(hasType(""X"")); and public virtual X (matcher = cxxBaseSpecifier(hasType(; cxxRecordDecl(hasName(""X"")))); class X {};; void y(X &x) { x; X z; }; class Y { friend c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:145038,Usab,Usable,145038,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['Usab'],['Usable']
Usability,"eVSlider(p,100,kDoubleScaleNo,dsliderID);; vDslider->SetRange(-10,10);; ```. ### Triple Slider. The new **`TGTripleHSlider`** and **`TGTripleVSlider`** classes inherit; from the double slider widgets and allow easy selection of a range and a; pointer value. The pointer position can be constrained into the selected; range or can be relative to it. ![](pictures/0300021D.png). To change the slider range value press the left mouse button near to the; left/right (top/bottom) edges of the slider. To change both values; simultaneously press the mouse button near to the slider center. To; change pointer value press the mouse on the pointer and drag it to the; desired position. ``` {.cpp}; fSlider = new TGTripleHSlider(parent,100,kDoubleScaleBoth,kSLD_ID,; kHorizontalFrame);; parent->AddFrame(fSlider,new TGLayoutHints(kLHintsExpandX,5,5,5,5));; fSlider->SetConstrained(kTRUE);; fSlider->SetRange(rmin, rmax);; fSlider->SetPosition(pmin, pmax);; fSlider ->SetPointerPosition(pvalue);; ```. ### Progress Bars. A progress bar is a widget that shows that an operation is in progress; and how much time is left. It is a long rectangular bar, initially; empty, that fills with a color as a process is being performed. The; filled-in area indicates the percentage of the process that has been; completed. You should use this widget for waits exceeding `one minute`.; For a very time consuming operation it is better to break the operation; into subtasks and provide a progress bar for each of them. ![](pictures/0200021E.jpg). A progress bar may be oriented horizontally or vertically. The; horizontally oriented progress bar fills with a color from left to; right; the vertically oriented - from bottom to top. A percent complete; message provides an indication of the completed part of the process. It; is a good practice to include some descriptive text of the process to; keep users informed and entertained while they are waiting for process; completion. The picture below shows the progress bars you",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:87738,Progress Bar,Progress Bars,87738,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,1,['Progress Bar'],['Progress Bars']
Usability,eView/DebugCrossExSubsection.h; llvm/include/llvm/DebugInfo/CodeView/DebugCrossImpSubsection.h; llvm/include/llvm/DebugInfo/CodeView/DebugInlineeLinesSubsection.h; llvm/include/llvm/DebugInfo/CodeView/DebugLinesSubsection.h; llvm/include/llvm/DebugInfo/CodeView/DebugStringTableSubsection.h; llvm/include/llvm/DebugInfo/CodeView/DebugSubsection.h; llvm/include/llvm/DebugInfo/CodeView/DebugSubsectionRecord.h; llvm/include/llvm/DebugInfo/CodeView/DebugSubsectionVisitor.h; llvm/include/llvm/DebugInfo/CodeView/DebugSymbolRVASubsection.h; llvm/include/llvm/DebugInfo/CodeView/EnumTables.h; llvm/include/llvm/DebugInfo/CodeView/Formatters.h; llvm/include/llvm/DebugInfo/CodeView/GlobalTypeTableBuilder.h; llvm/include/llvm/DebugInfo/CodeView/GUID.h; llvm/include/llvm/DebugInfo/CodeView/LazyRandomTypeCollection.h; llvm/include/llvm/DebugInfo/CodeView/Line.h; llvm/include/llvm/DebugInfo/CodeView/MergingTypeTableBuilder.h; llvm/include/llvm/DebugInfo/CodeView/RecordName.h; llvm/include/llvm/DebugInfo/CodeView/SimpleTypeSerializer.h; llvm/include/llvm/DebugInfo/CodeView/StringsAndChecksums.h; llvm/include/llvm/DebugInfo/CodeView/SymbolDumpDelegate.h; llvm/include/llvm/DebugInfo/CodeView/SymbolDumper.h; llvm/include/llvm/DebugInfo/CodeView/SymbolRecordHelpers.h; llvm/include/llvm/DebugInfo/CodeView/SymbolSerializer.h; llvm/include/llvm/DebugInfo/CodeView/SymbolVisitorCallbackPipeline.h; llvm/include/llvm/DebugInfo/CodeView/SymbolVisitorCallbacks.h; llvm/include/llvm/DebugInfo/CodeView/SymbolVisitorDelegate.h; llvm/include/llvm/DebugInfo/CodeView/TypeDeserializer.h; llvm/include/llvm/DebugInfo/CodeView/TypeDumpVisitor.h; llvm/include/llvm/DebugInfo/CodeView/TypeRecordHelpers.h; llvm/include/llvm/DebugInfo/CodeView/TypeStreamMerger.h; llvm/include/llvm/DebugInfo/CodeView/TypeVisitorCallbackPipeline.h; llvm/include/llvm/DebugInfo/CodeView/TypeVisitorCallbacks.h; llvm/include/llvm/DebugInfo/DWARF/DWARFCompileUnit.h; llvm/include/llvm/DebugInfo/DWARF/DWARFDebugInfoEntry.h; llvm/include/ll,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt:244337,Simpl,SimpleTypeSerializer,244337,interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,1,['Simpl'],['SimpleTypeSerializer']
Usability,"ead, one should use HybridCalculator's; ForcePriorNuisanceNull and ForcePriorNuisanceAlt. HybridCalculatorOriginal. Apply a fix for test statistic = 3 (profile likelihood); Apply a fix for using non-extended pdf. TestStatSampler and TestStatistics. Cleanup of the interfaces.; TestStatistics now have a method PValueIsRightTail to specify the sign conventions for the test statistic. This is used when making plots and calculating p-values.; make clear that TestStatistic::Evaluate should take data and values of the parameters that define the null.; Add method TestStatSampler::SetParametersForTestStat that ; allows for greater control of parameters used for generating toy data; and parameters used for evaluating the test statistic.; ProfileLikelihoodTestStatUsing the raw profile likelihood while reviewing the old algorithm used to provide robustness in situations with local minima.; New test statistic classes:; ; SimpleLikelihoodRatioTestStat : log L_1 / L_0; RatioOfProfiledLikelihoodsTestStat: log L(mu_1, hat(nu_1))/L(mu_0,hat(nu_0)); MaxLikelihoodEstimateTestStat: the MLE of a specified parameter. ToyMCSampler. New version of ToyMCSampler which can smear the nuisance; parameters according to their distributions for use with; HybridCalculator; Updated class structure: ToyMCSampler is a particular implementation of a TestStatSampler and runs with any TestStatistic. It returns the result in an instance of SamplingDistribution.; Supports Importance Sampling: Improves sampling the tails of a distribution by generating toys from a user supplied importance density and a reweighing procedure of the result.; Supports Adaptive Sampling: extends the run until a given number of toys is reached in the tail(s).; Parallelization using PROOF(-Lite) is supported. It is enabled by supplying a ProofConfig instance. BayesianCalculator. Improve the way the class performs the numerical integration to; find the interval and/or the posterior function.; In case of complex; numerical calculatio",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v528/index.html:7128,Simpl,SimpleLikelihoodRatioTestStat,7128,roofit/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v528/index.html,1,['Simpl'],['SimpleLikelihoodRatioTestStat']
Usability,"ean they are reordered to be on top of the others. To; interactively make an object ""active"", you can use the middle mouse; button. In case of canvases or pads, the border becomes highlighted when; it is active. #### With C++ Statements (Programmatically). Frequently we want to draw in different canvases or pads. By default,; the objects are drawn in the active canvas. To activate a canvas you can; use the `TPad::cd()` method. ``` {.cpp}; root[] c1->cd(); ```. ### Context Menus: the Right Mouse Button. The context menus are a way to interactively call certain methods of an; object. When designing a class, the programmer can add methods to the; context menu of the object by making minor changes to the header file. #### Using Context Menus. On a ROOT canvas, you can right-click on any object and see the context; menu for it. The script `hsimple.C` draws a histogram. The image below; shows the context menus for some of the objects on the canvas. Next; picture shows that drawing a simple histogram involves as many as seven; objects. When selecting a method from the context menu and that method; has options, the user will be asked for numerical values or strings to; fill in the option. For example, `TAxis::SetTitle` will prompt you for a; string to use for the axis title. ![Context menus of different objects in a canvas](pictures/030000A0.png). #### Structure of the Context Menus. The curious reader will have noticed that each entry in the context menu; corresponds to a method of the class. Look for example to the menu named; `TAxis::xaxis`. `xaxis` is the name of the object and **`TAxis`** the; name of its class. If we look at the list of **`TAxis`** methods, for; example in <https://root.cern/doc/master/classTAxis.html>, we see the; methods `SetTimeDisplay()` and` UnZoom()`, which appear also in the; context menu. There are several divisions in the context menu, separated by lines. The; top division is a list of the class methods; the second division is a; list of the ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:4649,simpl,simple,4649,documentation/users-guide/Graphics.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md,1,['simpl'],['simple']
Usability,"ear in the corresponding label and the button Edit will; start the object editor in a transient frame. Closing these transient; frames will not delete, but just hide existing opened editors for later; reuse. Their lifetime is determined by the canvas to which the manager; editor is attached to, since these will be destroyed together. \image html geometry021.png ""Editors for shapes, materials, media, matrices"" width=600px. For most editors, the functionalities Apply and Undo are provided. For shapes, changing any of the shape parameters will activate the; ""Apply"" button only if the check button ""Delayed draw"" is checked,; otherwise the changes are immediately applied. Once the apply button is; pressed, the changes are applied to the edited shape and drawn. The; ""Undo"" button becomes active after the first modification has been; applied. It allows restoring the initial parameters of the shape. NOTE: In this version the ""Undo"" does not allow restoring an; intermediate state of the parameters that was applied - it will always; restore the parameters at the moment the shape was edited. All material properties changes are undoable. The mixture editor; currently allows adding elements one by one in the mixture composition.; This can be done either by element weight fraction or by number of; atoms. Once an element was added using one method the other method is not; selectable anymore. Summing component fractions up to 1 in the final; mixture is the user responsibility. Adding materials as components of a; mixture is not supported in this version. The elements that were added to the mixture appear in the bottom of the; mixture editor. The operations performed on mixture are not undoable. \anchor GP08d; ### Creation of New Objects. As described above, all geometry object creators are accessible within; the geometry manager editor frame. Generally, if the new object that; needs to be created does not depend on other objects, it will be built; with a set of default parameters. T",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:130923,Undo,Undo,130923,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['Undo'],['Undo']
Usability,"earch=product%3Aclang+component%3A-New%2BBugs%2CAST%2CBasic%2CDriver%2CHeaders%2CLLVM%2BCodeGen%2Cparser%2Cpreprocessor%2CSemantic%2BAnalyzer>`_; for known existing bugs (FIXME: Is there a section for bug-reporting; guidelines somewhere?). Intentionally unsupported GCC extensions; ----------------------------------------. - clang does not support the gcc extension that allows variable-length; arrays in structures. This is for a few reasons: one, it is tricky to; implement, two, the extension is completely undocumented, and three,; the extension appears to be rarely used. Note that clang *does*; support flexible array members (arrays with a zero or unspecified; size at the end of a structure).; - GCC accepts many expression forms that are not valid integer constant; expressions in bit-field widths, enumerator constants, case labels,; and in array bounds at global scope. Clang also accepts additional; expression forms in these contexts, but constructs that GCC accepts due to; simplifications GCC performs while parsing, such as ``x - x`` (where ``x`` is a; variable) will likely never be accepted by Clang.; - clang does not support ``__builtin_apply`` and friends; this extension; is extremely obscure and difficult to implement reliably. .. _c_ms:. Microsoft extensions; --------------------. clang has support for many extensions from Microsoft Visual C++. To enable these; extensions, use the ``-fms-extensions`` command-line option. This is the default; for Windows targets. Clang does not implement every pragma or declspec provided; by MSVC, but the popular ones, such as ``__declspec(dllexport)`` and ``#pragma; comment(lib)`` are well supported. clang has a ``-fms-compatibility`` flag that makes clang accept enough; invalid C++ to be able to parse most Microsoft headers. For example, it; allows `unqualified lookup of dependent base class members; <https://clang.llvm.org/compatibility.html#dep_lookup_bases>`_, which is; a common compatibility issue with clang. This flag is",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:136215,simpl,simplifications,136215,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['simpl'],['simplifications']
Usability,"earned some parsing techniques, how to build and represent; an AST, how to build LLVM IR, and how to optimize the resultant code as; well as JIT compile it. While Kaleidoscope is interesting as a functional language, the fact; that it is functional makes it ""too easy"" to generate LLVM IR for it. In; particular, a functional language makes it very easy to build LLVM IR; directly in `SSA; form <http://en.wikipedia.org/wiki/Static_single_assignment_form>`_.; Since LLVM requires that the input code be in SSA form, this is a very; nice property and it is often unclear to newcomers how to generate code; for an imperative language with mutable variables. The short (and happy) summary of this chapter is that there is no need; for your front-end to build SSA form: LLVM provides highly tuned and; well tested support for this, though the way it works is a bit; unexpected for some. Why is this a hard problem?; ===========================. To understand why mutable variables cause complexities in SSA; construction, consider this extremely simple C example:. .. code-block:: c. int G, H;; int test(_Bool Condition) {; int X;; if (Condition); X = G;; else; X = H;; return X;; }. In this case, we have the variable ""X"", whose value depends on the path; executed in the program. Because there are two different possible values; for X before the return instruction, a PHI node is inserted to merge the; two values. The LLVM IR that we want for this example looks like this:. .. code-block:: llvm. @G = weak global i32 0 ; type of @G is i32*; @H = weak global i32 0 ; type of @H is i32*. define i32 @test(i1 %Condition) {; entry:; br i1 %Condition, label %cond_true, label %cond_false. cond_true:; %X.0 = load i32, i32* @G; br label %cond_next. cond_false:; %X.1 = load i32, i32* @H; br label %cond_next. cond_next:; %X.2 = phi i32 [ %X.1, %cond_false ], [ %X.0, %cond_true ]; ret i32 %X.2; }. In this example, the loads from the G and H global variables are; explicit in the LLVM IR, and they live in t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst:1561,simpl,simple,1561,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,1,['simpl'],['simple']
Usability,"easily remembered. With check boxes all; alternatives are visible: it is easy to access and compare choices; because they can all be seen together. Each option acts as a switch and; can be either ""on"" or ""off"". It is never changed in contents. Checkboxes; differ from radio buttons in that they permit selection of more than one; alternative. Each box can be switched on or off independently. These; buttons can be used alone or grouped in sets. It is good practice to; provide default settings for check boxes whenever it is possible. ![](pictures/03000213.png). This can be done by:. ``` {.cpp}; SetState(EButtonState state); ```. The parameter state can be one of `kButtonUp`, `kButtonDown`,; `kButtonEngaged`, `kButtonDisabled`. Check boxes can be used to affect other controls. The contents of a list; can, for example, be filtered by setting a check box. In any case, use a; check box only when both states of a choice are clearly opposite and; unambiguous. If opposite states are not clear, it is better to use two; radio buttons. Choice description, i.e. check box label, must be clear, meaningful,; fully spelled out, and displayed in mixed-type text. Whenever the use of; a given button is inappropriate, for whatever reason, that button should; be disabled:. ``` {.cpp}; button->SetState(kButtonDisabled);; ```. Never make a button appear and disappear. In general, option buttons should not offer more than eight choices. If; the number of choices exceeds this maximum, it is better to use a; multiple selection list box. The method `IsToggleButton()` gives the information whether a radio; button or a check button is selected. An option button can be set or; unset via its method `PSetState(EButtonState state).`. The method `HandleKey(event)` is called when the defined hotkey is hit; for any button. It sets the selected option button or clicks the; selected text button and invokes its defined action. ### Text Entries. A **`TGTextEntry`** is a one-line text input widget. It contain",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:63200,clear,clear,63200,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,1,['clear'],['clear']
Usability,"eated notebooks with viewers like https://nbviewer.jupyter.org/; - Fix problem with using of local JSROOT version. ## Tutorials. - The tutorial games.C was not working properly. - Improve tutorial ErrorIntegral.C. - Schrödinger's Hydrogen Atom example. - Tutorial demonstrating how the changing of the range can zoom into the histogram. - Tutorial demonstrating how a Histogram can be read from a ROOT File. - histMax.C: a tutorial demoing how the hist->GetMaximumBin() can be used. ## Class Reference Guide. - Images for ROOT7 tutorials can be generated, in json format, using the directive using; `\macro_image (json)` in the macro header. - Clarify THStack drawing options. - Add missing documentation to TH1 functions. - Restructure the math reference guide. - Make the web gui documentation visible in the reference guide. - Make clear THtml is legacy code. Add deprecated flag on PROOF and TGeoTrack. - Improve many classes documentation: TContext, TTreePlayer, THistPainter, TGraph, TSelector,; integrator, GUI, TH1, TH2, TH3, TColor classes ... - Make the TFile layout doc visible in Reference Guide. - Update the external links of the reference guide main page. - Reformat TMVA mathcore Unuran Roostats documentation . ## Build, Configuration and Testing Infrastructure. - For users building from source the `latest-stable` branch and passing `-Droottest=ON` to the CMake command line, the corresponding revision of roottest pointed to by `latest-stable` will be downloaded as required. ## PyROOT. - The `ROOT` Python module is now properly serializable so that it is automatically available in the Python environment if a function or ROOT object needs to be serialized. See issue [#6764](https://github.com/root-project/root/issues/6764) for a concrete usecase.; - Improve overload resolution of functions that accept classes with long inheritance trees. Now prefer to call the function overload of the most derived class type (PR [#9092](https://github.com/root-project/root/pull/9092)).; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md:39259,Guid,Guide,39259,README/ReleaseNotes/v626/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md,2,"['Guid', 'guid']","['Guide', 'guide']"
Usability,"ec), [](const std::string &fieldName) {; if (fieldName == ""aliasVec"") return ""vec"";; else return ""vec._0"";; });; ```; Projected fields are stored as part of the metadata. - Improvements on the internal `RField` value API. The `RFieldValue` class has been deprecated in favor of `RField::Value` and the related interfaces have changed accordingly (see [#13219](https://github.com/root-project/root/pull/13219) and [#13264](https://github.com/root-project/root/pull/13264)).; If you were not using `RField::(Read|Append)` directly, this change should not impact you. - The new `RNTupleImporter` class provides automatic conversion of TTree to RNTuple.; Note that not all of the C++ types supported in TTree are currently supported in RNTuple. - Many bug fixes and performance improvements. Please, report any issues regarding the abovementioned features should you encounter them.; RNTuple is still experimental and is scheduled to become production grade by end of 2024.; Thus, we appreciate feedback and suggestions for improvement. ## Histogram Libraries. ## Math Libraries. ### Minuit2 is now the default minimizer. Many ROOT-based frameworks and users employ Minuit2 as the minimizer of choice for a long time already.; Therefore, Minuit2 is now the default minimizer used by ROOT.; This affects also **RooFit**, which inherits the default minimizer from ROOT Math. The default can be changed back to the old Minuit implementation as follows:; ```c++; ROOT::Math::MinimizerOptions::SetDefaultMinimizer(""Minuit"");; ```. Alternatively, you can add this line to your `~/.rootrc` file:; ```; Root.Fitter: Minuit; ```. ### Behavior change of `TMath::AreEqualAbs()`. The `TMath::AreEqualAbs()` compares two numbers for equality within a certain absolute range.; So far, it would tell you that `inf != inf` if you define `inf` as `std::numeric_limits<double>::infinity()`, which is inconsistent with the regular `==` operator. This is unexpected, because one would expect that if two numbers are considere",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v630/index.md:9925,feedback,feedback,9925,README/ReleaseNotes/v630/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v630/index.md,1,['feedback'],['feedback']
Usability,"econd argument of the `coro.suspend`_ intrinsic to `true`.; Such a suspend point has two properties:. * it is possible to check whether a suspended coroutine is at the final suspend; point via `coro.done`_ intrinsic;. * a resumption of a coroutine stopped at the final suspend point leads to; undefined behavior. The only possible action for a coroutine at a final; suspend point is destroying it via `coro.destroy`_ intrinsic. From the user perspective, the final suspend point represents an idea of a; coroutine reaching the end. From the compiler perspective, it is an optimization; opportunity for reducing number of resume points (and therefore switch cases) in; the resume function. The following is an example of a function that keeps resuming the coroutine; until the final suspend point is reached after which point the coroutine is; destroyed:. .. code-block:: llvm. define i32 @main() {; entry:; %hdl = call ptr @f(i32 4); br label %while; while:; call void @llvm.coro.resume(ptr %hdl); %done = call i1 @llvm.coro.done(ptr %hdl); br i1 %done, label %end, label %while; end:; call void @llvm.coro.destroy(ptr %hdl); ret i32 0; }. Usually, final suspend point is a frontend injected suspend point that does not; correspond to any explicitly authored suspend point of the high level language.; For example, for a Python generator that has only one suspend point:. .. code-block:: python. def coroutine(n):; for i in range(n):; yield i. Python frontend would inject two more suspend points, so that the actual code; looks like this:. .. code-block:: c. void* coroutine(int n) {; int current_value;; <designate current_value to be coroutine promise>; <SUSPEND> // injected suspend point, so that the coroutine starts suspended; for (int i = 0; i < n; ++i) {; current_value = i; <SUSPEND>; // corresponds to ""yield i""; }; <SUSPEND final=true> // injected final suspend point; }. and python iterator `__next__` would look like:. .. code-block:: c++. int __next__(void* hdl) {; coro.resume(hdl);; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:25587,resume,resume,25587,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"ecord stream, and are referenced from this stream. - **PdbDllVersion** - The version number of ``mspdbXXXX.dll`` used to produce this; PDB. Note this obviously does not apply for LLVM as LLVM does not use ``mspdb.dll``. - **SymRecordStream** - The stream containing all CodeView symbol records used; by the program. This is used for deduplication, so that many different; compilands can refer to the same symbols without having to include the full record; content inside of each module stream. - **PdbDllRbld** - Unknown. - **MFCTypeServerIndex** - The index of the MFC type server in the; :ref:`dbi_type_server_map_substream`. - **Flags** - A bitfield with the following layout, containing various; information about how the program was built:. .. code-block:: c++. uint16_t WasIncrementallyLinked : 1;; uint16_t ArePrivateSymbolsStripped : 1;; uint16_t HasConflictingTypes : 1;; uint16_t Reserved : 13;. The only one of these that is not self-explanatory is ``HasConflictingTypes``.; Although undocumented, ``link.exe`` contains a hidden flag ``/DEBUG:CTYPES``.; If it is passed to ``link.exe``, this field will be set. Otherwise it will; not be set. It is unclear what this flag does, although it seems to have; subtle implications on the algorithm used to look up type records. - **Machine** - A value from the `CV_CPU_TYPE_e <https://msdn.microsoft.com/en-us/library/b2fc64ek.aspx>`__; enumeration. Common values are ``0x8664`` (x86-64) and ``0x14C`` (x86). Immediately after the fixed-size DBI Stream header are ``7`` variable-length; `substreams`. The following ``7`` fields of the DBI Stream header specify the; number of bytes of the corresponding substream. Each substream's contents will; be described in detail :ref:`below <dbi_substreams>`. The length of the entire; DBI Stream should equal ``64`` (the length of the header above) plus the value; of each of the following ``7`` fields. - **ModInfoSize** - The length of the :ref:`dbi_mod_info_substream`. - **SectionContributionSize** - ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PDB/DbiStream.rst:3985,undo,undocumented,3985,interpreter/llvm-project/llvm/docs/PDB/DbiStream.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PDB/DbiStream.rst,1,['undo'],['undocumented']
Usability,"ecords are passed on; to various *backends*, which extract information from a subset of the records; and generate one or more output files. These output files are typically; ``.inc`` files for C++, but may be any type of file that the backend; developer needs. This document describes the LLVM TableGen facility in detail. It is intended; for the programmer who is using TableGen to produce code for a project. If; you are looking for a simple overview, check out the :doc:`TableGen Overview; <./index>`. The various ``*-tblgen`` commands used to invoke TableGen are; described in :doc:`tblgen Family - Description to C++; Code<../CommandGuide/tblgen>`. An example of a backend is ``RegisterInfo``, which generates the register; file information for a particular target machine, for use by the LLVM; target-independent code generator. See :doc:`TableGen Backends <./BackEnds>`; for a description of the LLVM TableGen backends, and :doc:`TableGen; Backend Developer's Guide <./BackGuide>` for a guide to writing a new; backend. Here are a few of the things backends can do. * Generate the register file information for a particular target machine. * Generate the instruction definitions for a target. * Generate the patterns that the code generator uses to match instructions; to intermediate representation (IR) nodes. * Generate semantic attribute identifiers for Clang. * Generate abstract syntax tree (AST) declaration node definitions for Clang. * Generate AST statement node definitions for Clang. Concepts; --------. TableGen source files contain two primary items: *abstract records* and; *concrete records*. In this and other TableGen documents, abstract records; are called *classes.* (These classes are different from C++ classes and do; not map onto them.) In addition, concrete records are usually just called; records, although sometimes the term *record* refers to both classes and; concrete records. The distinction should be clear in context. Classes and concrete records have a unique",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst:1517,guid,guide,1517,interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,1,['guid'],['guide']
Usability,"ect: RE: LLVM Concerns... > 1. Reference types; > Right now, I've spec'd out the language to have a pointer type, which; > works fine for lots of stuff... except that Java really has; > references: constrained pointers that cannot be manipulated: added and; > subtracted, moved, etc... Do we want to have a type like this? It; > could be very nice for analysis (pointer always points to the start of; > an object, etc...) and more closely matches Java semantics. The; > pointer type would be kept for C++ like semantics. Through analysis,; > C++ pointers could be promoted to references in the LLVM; > representation. You're right, having references would be useful. Even for C++ the *static*; compiler could generate references instead of pointers with fairly; straightforward analysis. Let's include a reference type for now. But I'm; also really concerned that LLVM is becoming big and complex and (perhaps); too high-level. After we get some initial performance results, we may have; a clearer idea of what our goals should be and we should revisit this; question then. > 2. Our ""implicit"" memory references in assembly language:; > After thinking about it, this model has two problems:; > A. If you do pointer analysis and realize that two stores are; > independent and can share the same memory source object,. not sure what you meant by ""share the same memory source object"". > there is; > no way to represent this in either the bytecode or assembly.; > B. When parsing assembly/bytecode, we effectively have to do a full; > SSA generation/PHI node insertion pass to build the dependencies; > when we don't want the ""pinned"" representation. This is not; > cool. I understand the concern. But again, let's focus on the performance first; and then look at the language design issues. E.g., it would be good to know; how big the bytecode files are before expanding them further. I am pretty; keen to explore the implications of LLVM for mobile devices. Both bytecode; size and power consumption a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-13-Reference-MemoryResponse.txt:1113,clear,clearer,1113,interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-13-Reference-MemoryResponse.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-13-Reference-MemoryResponse.txt,1,['clear'],['clearer']
Usability,"ected that; this list will change following experimentation:. * TableGen; * llvm/tools; * clang-tools-extra; * clang; * ARM backend; * AArch64 backend; * AMDGPU backend; * ARC backend; * AVR backend; * BPF backend; * Hexagon backend; * Lanai backend; * MIPS backend; * NVPTX backend; * PowerPC backend; * RISC-V backend; * Sparc backend; * SystemZ backend; * WebAssembly backend; * X86 backend; * XCore backend; * libLTO; * Debug Information; * Remainder of llvm; * compiler-rt; * libunwind; * openmp; * parallel-libs; * polly; * lldb. #. Remove the old variable name rule from the policy page. #. Repeat many of the steps in the sequence, using a script to expand acronyms. References; ==========. .. [LLDB] LLDB Coding Conventions https://llvm.org/svn/llvm-project/lldb/branches/release_39/www/lldb-coding-conventions.html; .. [Google] Google C++ Style Guide https://google.github.io/styleguide/cppguide.html#Variable_Names; .. [WebKit] WebKit Code Style Guidelines https://webkit.org/code-style-guidelines/#names; .. [Qt] Qt Coding Style https://wiki.qt.io/Qt_Coding_Style#Declaring_variables; .. [Rust] Rust naming conventions https://doc.rust-lang.org/1.0.0/style/style/naming/README.html; .. [Swift] Swift API Design Guidelines https://swift.org/documentation/api-design-guidelines/#general-conventions; .. [Python] Style Guide for Python Code https://www.python.org/dev/peps/pep-0008/#function-and-variable-names; .. [Mozilla] Mozilla Coding style: Prefixes https://firefox-source-docs.mozilla.org/tools/lint/coding-style/coding_style_cpp.html#prefixes; .. [SVE] LLVM with support for SVE https://github.com/ARM-software/LLVM-SVE; .. [AminiInconsistent] Mehdi Amini, http://lists.llvm.org/pipermail/llvm-dev/2019-February/130329.html; .. [ArsenaultAgree] Matt Arsenault, http://lists.llvm.org/pipermail/llvm-dev/2019-February/129934.html; .. [BeylsDistinguish] Kristof Beyls, http://lists.llvm.org/pipermail/llvm-dev/2019-February/130292.html; .. [BradburyConcern] Alex Bradbury, http://lists.l",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst:13602,guid,guidelines,13602,interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst,1,['guid'],['guidelines']
Usability,"ection below for more details, or see [the tutorial](https://root.cern/doc/master/rf408__RDataFrameToRooFit_8C.html). ### Notable changes in behavior. - Using `Alias`, it is now possible to register homonymous aliases (alternative column names) in different branches of the computation graph, in line with the behavior of `Define` (until now, aliases were required to be unique in the whole computaton graph).; - The `Histo*D` methods now support the combination of scalar values and vector-like weight values. For each entry, the histogram is filled once for each weight, always with the same scalar value.; - The `Histo*D` methods do not work on columns of type `std::string` anymore. They used to fill the histogram with the integer value corresponding to each of the characters in the string. Please use `Fill` with a custom class to recover the old behavior if that was what was desired. ### Other improvements. - The scaling to a large amount of threads of computation graphs with many simple `Filter`s or `Define`s has been greatly improved, see also [this talk](https://indico.cern.ch/event/1036730/#1-a-performance-study-of-the-r) for more details; - The output format of `Display` has been significantly improved.; - The `Fill` method now correctly supports user-defined classes with arbitrary `Fill` signatures (see [#9428](https://github.com/root-project/root/issues/9428)). ### Experimental Distributed RDataFrame. The distributed RDataFrame module has been improved. Now it supports sending RDataFrame tasks to a [Dask](https://dask.org/) scheduler. Through Dask, RDataFrame can be also scaled to a cluster of machines managed through a batch system like HTCondor or Slurm. Here is an example:. ```python; import ROOT; from dask.distributed import Client; RDataFrame = ROOT.RDF.Experimental.Distributed.Dask.RDataFrame. # In a Python script the Dask client needs to be initalized in a context; # Jupyter notebooks / Python session don't need this; if __name__ == ""__main__"":; client = Cl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md:9847,simpl,simple,9847,README/ReleaseNotes/v626/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md,1,['simpl'],['simple']
Usability,"ects is unaffected. However with extremely small zooms (FOV; large/focal length short) noticeable distortions, causing straight; lines to become curved, can be seen with objects near the camera -; the ‘fisheye' lens effect. - Generally dollying is more ‘natural', but you may need to use both; to achieve the desired perspective and eye position - particularly; when you are working inside or very close to 3D objects. Configure the camera by calling the methods `SetPerspectiveCamera(`) or; `SetOrthographicCamera()` of **`TGLViewer`**:. ``` {.cpp}; TGLViewer * v = (TGLViewer *)gPad->GetViewer3D();; v->SetOrthoCamera(TGLViewer::kCameraOrthoXOY,; left,right,top,bottom);; ...; v->SetPerspectiveCamera (camera,fov,dolly,center,hRotate,vRotate);; ```. Note - you can configure any of the six cameras in the viewer at any; time, but you will not see the result until the camera is made current. #### Draw Styles. The GL Viewer supports three different rendering modes, which are; applied to all the objects in your scene, but not Clip Shapes and Guides; (See ""Clipping"" and ""Manipulators""). These are shown below, along with; the key used to activate the style. ![GL Viewer draw styles](pictures/020000DC.jpg). **Filled Polygons** **Wireframe** **Outline** Enable with ‘r' key Enable; with ‘w' key Enable with ‘t' key Solid polygons, with hidden surface; Object edges in color, with Combination of Filled Polygons removal,; color surface materials, no surface filling/hiding. and Outline styles.; Solid opacity, specular reflection etc. shapes with edges. Black; background. Black background. White background. Call method `TGLViewer::SetStyle` with one of; **`TGLRnrCtx::EDrawStyle `flags `kFill`, `kOutline`, `kWireFrame`:**. ``` {.cpp}; v->SetStyle(TGLRnrCtx::kFill);; ```. #### Lighting / Style. The GL viewer creates five diffuse lights (left, right, top, bottom, and; front) arranged around the 3D scene. These lights are carried with the; camera - that is they are always in same position relat",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:112635,Guid,Guides,112635,documentation/users-guide/Graphics.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md,1,['Guid'],['Guides']
Usability,"ects of the call must happen whether; the assert is enabled or not. In this case, the value should be cast to void to; disable the warning. To be specific, it is preferred to write the code like; this:. .. code-block:: c++. assert(V.size() > 42 && ""Vector smaller than it should be"");. bool NewToSet = Myset.insert(Value); (void)NewToSet;; assert(NewToSet && ""The value shouldn't be in the set yet"");. Do Not Use ``using namespace std``; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. In LLVM, we prefer to explicitly prefix all identifiers from the standard; namespace with an ""``std::``"" prefix, rather than rely on ""``using namespace; std;``"". In header files, adding a ``'using namespace XXX'`` directive pollutes the; namespace of any source file that ``#include``\s the header, creating; maintenance issues. In implementation files (e.g. ``.cpp`` files), the rule is more of a stylistic; rule, but is still important. Basically, using explicit namespace prefixes; makes the code **clearer**, because it is immediately obvious what facilities; are being used and where they are coming from. And **more portable**, because; namespace clashes cannot occur between LLVM code and other namespaces. The; portability rule is important because different standard library implementations; expose different symbols (potentially ones they shouldn't), and future revisions; to the C++ standard will add more symbols to the ``std`` namespace. As such, we; never use ``'using namespace std;'`` in LLVM. The exception to the general rule (i.e. it's not an exception for the ``std``; namespace) is for implementation files. For example, all of the code in the; LLVM project implements code that lives in the 'llvm' namespace. As such, it is; ok, and actually clearer, for the ``.cpp`` files to have a ``'using namespace; llvm;'`` directive at the top, after the ``#include``\s. This reduces; indentation in the body of the file for source editors that indent based on; braces, and keeps the conceptual context cleaner. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst:49332,clear,clearer,49332,interpreter/llvm-project/llvm/docs/CodingStandards.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst,1,['clear'],['clearer']
Usability,"ects; (""shapes"") - filled /added by negotiation with viewer via; **`TVirtualViewer3D`**. A typical interaction between viewer and client using these, taken from; **`TGeoPainter`** is:. ``` {.cpp}; TVirtualViewer3D * viewer = gPad->GetViewer3D();; // Does viewer prefer local frame positions?; Bool_t localFrame = viewer->PreferLocalFrame();; // Perform first fetch of buffer from the shape and try adding it to the viewer; const TBuffer3D &buffer = shape.GetBuffer3D(TBuffer3D::kCore |; TBuffer3D::kBoundingBox |; TBuffer3D::kShapeSpecific,; localFrame);; Int_t reqSections = viewer->AddObject(buffer, &addDaughters);. // If the viewer requires additional sections fetch from the shape; // (if possible) and add again; if (reqSections != TBuffer3D::kNone); shape.GetBuffer3D(reqSections, localFrame);; ```. Together these allow clients to publish objects to any one of the 3D; viewers free of viewer specific drawing code. They allow our simple x3d; viewer, and considerably more sophisticated OpenGL one to both work with; both geometry libraries (`g3d` and `geom`) efficiently. In addition to external viewers, created in separate windows, this; architecture is also used by internal **`TPad`** drawing when it; requires 3D projections. Publishing to a viewer consists of the; following steps:. 1- Create / obtain viewer handle. 2- Begin scene on viewer. 3- Fill mandatory parts of TBuffer3D describing object. 4- Add to viewer. 5- Fill optional parts of TBuffer3D as requested by viewer. [ .... repeat 3/4/5 as required for other/child objects]. 6- End scene on viewer. You should attach the top-level node of your external geometry (or the; manager) to a **`TPad`** object using **`TObject::Draw()`, and perform; the publishing to the viewer in your object's `TObject::Paint()`; overloaded method. See ""Scene Rebuilds"", and example scripts, for more; details.**. #### Creating / Obtaining Viewer Handle. External viewers are bound to a **`TPad`** object (this may be removed; as a requirement in t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:123775,simpl,simple,123775,documentation/users-guide/Graphics.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md,1,['simpl'],['simple']
Usability,ecutionEngine/Orc/ObjectLinkingLayer.h; llvm/include/llvm/ExecutionEngine/Orc/ObjectTransformLayer.h; llvm/include/llvm/ExecutionEngine/Orc/OrcABISupport.h; llvm/include/llvm/ExecutionEngine/Orc/RTDyldObjectLinkingLayer.h; llvm/include/llvm/ExecutionEngine/Orc/SpeculateAnalyses.h; llvm/include/llvm/ExecutionEngine/Orc/Speculation.h; llvm/include/llvm/ExecutionEngine/Orc/ThreadSafeModule.h; llvm/include/llvm/ExecutionEngine/Orc/Shared/ExecutorAddress.h; llvm/include/llvm/ExecutionEngine/Orc/Shared/OrcRTBridge.h; llvm/include/llvm/ExecutionEngine/Orc/Shared/SimplePackedSerialization.h; llvm/include/llvm/ExecutionEngine/Orc/Shared/SimpleRemoteEPCUtils.h; llvm/include/llvm/ExecutionEngine/Orc/TargetProcess/ExecutorBootstrapService.h; llvm/include/llvm/ExecutionEngine/Orc/TargetProcess/JITLoaderGDB.h; llvm/include/llvm/ExecutionEngine/Orc/TargetProcess/RegisterEHFrames.h; llvm/include/llvm/ExecutionEngine/Orc/TargetProcess/SimpleExecutorDylibManager.h; llvm/include/llvm/ExecutionEngine/Orc/TargetProcess/SimpleExecutorMemoryManager.h; llvm/include/llvm/ExecutionEngine/Orc/TargetProcess/SimpleRemoteEPCServer.h; llvm/include/llvm/ExecutionEngine/Orc/TargetProcess/TargetExecutionUtils.h; llvm/include/llvm/FileCheck/FileCheck.h; llvm/include/llvm/Frontend/OpenMP/OMPAssume.h; llvm/include/llvm/Frontend/OpenMP/OMPConstants.h; llvm/include/llvm/Frontend/OpenMP/OMPContext.h; llvm/include/llvm/Frontend/OpenMP/OMPGridValues.h; llvm/include/llvm/InterfaceStub/ELFObjHandler.h; llvm/include/llvm/InterfaceStub/IFSHandler.h; llvm/include/llvm/InterfaceStub/IFSStub.h; llvm/include/llvm/IR/Assumptions.h; llvm/include/llvm/IR/BuiltinGCs.h; llvm/include/llvm/IR/Comdat.h; llvm/include/llvm/IR/Constants.h; llvm/include/llvm/IR/DebugInfo.h; llvm/include/llvm/IR/DebugInfoMetadata.h; llvm/include/llvm/IR/DiagnosticHandler.h; llvm/include/llvm/IR/DiagnosticPrinter.h; llvm/include/llvm/IR/EHPersonalities.h; llvm/include/llvm/IR/GlobalIFunc.h; llvm/include/llvm/IR/GlobalObject.h; llvm/include/llvm/I,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt:254442,Simpl,SimpleExecutorMemoryManager,254442,interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,1,['Simpl'],['SimpleExecutorMemoryManager']
Usability,"ed by a single call: `ROOT::EnableThreadSafety()` which is the successor of the existing `TThread::Initialize`. This call must take place if ROOT needs to be used in a thread safe manner. The implementation of TSemaphore was redone based on C++11 thread primitive in order to prevent cases where some of request post were lost. ### TDirectory::TContext. We added a default constructor to `TDirectory::TContext` which record the current directory; and will restore it at destruction time and does not change the current directory. The constructor for `TDirectory::TContext` that takes a single TDirectory pointer as; an argument was changed to set `gDirectory` to zero when being passed a null pointer;; previously it was interpreting a null pointer as a request to *not* change the current; directory - this behavior is now implement by the default constructor. ### Collections. In THashList and THashTable, GetListForObject now returns a pointer to const as modifying the returned list (in particular adding to it) can break invariant of THashTable so we need to clearly mark the list as not being allowed to be modified. In TSeqCollection::Merge, we no longer delete the object in the case where the original collection is marked as a owner. We resolved a memory leakage occuring as a consequence of repeated calls to `TClonesArray::AbsorbObjects` and `TClonesArray::Clear` [ROOT-6996]. A similar problem was affecting `TClonesArray::operator=`, `TClonesArray::Expand` and `TClonesArray::ExpandCreate` and was also solved. `TClonesArray` reliance on global state during the destruction of the elements was decreased (removing use of `TObject::SetDtorOnly`). ### Global resources. Several tweaks to if and when, resources held by the global ROOT object (TROOT, TApplication) are deleted. When the default TApplication is replaced by a user provide TApplication, do not call EndOfProcessCleanups and co. and thus do not delete TFiles, TSockets or TColors that have already been created. In EndOfProce",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v606/index.md:3719,clear,clearly,3719,README/ReleaseNotes/v606/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v606/index.md,1,['clear'],['clearly']
Usability,"ed by the European Organisation for; Nuclear Research, CERN in Geneva. ROOT is very flexible and provides both a programming interface to use in own; applications and a graphical user interface for interactive data analysis. The; purpose of this document is to serve as a beginners guide and provides extendable; examples for your own use cases, based on typical problems addressed in; student labs. This guide will hopefully lay the ground for more complex; applications in your future scientific work building on a modern,; state-of the art tool for data analysis. This guide in form of a tutorial is intended to introduce you quickly to the; ROOT package. This goal will be accomplished using concrete examples, according; to the ""learning by doing"" principle. Also because of this reason, this guide; cannot cover all the complexity of the ROOT package. Nevertheless, once you feel; confident with the concepts presented in the following chapters, you will be; able to appreciate the ROOT Users Guide [@ROOT_Users_Guide] and navigate through; the Class Reference [@ROOT_Class_Reference] to find all the details you might be; interested in. You can even look at the code itself, since ROOT is a; free, open-source product. Use these documents in parallel to this; tutorial!. The ROOT Data Analysis Framework itself is written in and heavily relies; on the `C++` programming language: some knowledge about `C++` is required.; Jus take advantage from the immense available literature about `C++` if you do; not have any idea of what this language is about. ROOT is available for many platforms (Linux, Mac OS X, Windows...), but; in this guide we will implicitly assume that you are using Linux. The; first thing you need to do with ROOT is install it, don't you ? Obtaining; the latest ROOT version is straightforward. Just seek the ""Pro"" version; on this webpage <http://root.cern.ch/downloading-root>.; You will find precompiled versions for the different architectures, or; the ROOT source code ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/Introduction.md:4078,Guid,Guide,4078,documentation/primer/Introduction.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/Introduction.md,1,['Guid'],['Guide']
Usability,"ed from a thread. Some compilers, for example `gcc` version 2.95.2,; may not allow the `(void(*) (void*))s` cast and just stop if `Thread0`; is not static. On the other hand, if `Thread0` is static, no compiler; warnings are generated at all. Because the `'this'` pointer is passed in; `'arg'` in the call to `Thread0(void *arg),` you have access to the; instance of the class even if `Thread0` is static. Using the `'this'`; pointer, non static members can still be read and written from; `Thread0`, as long as you have provided Getter and Setter methods for; these members. For example:. ``` {.cpp}; Bool_t state = arg->GetRunStatus();; arg->SetRunStatus(state);; ```. Second, the pointer to the current instance of `Myclass`, i.e. (void\*); this, has to be passed as first argument of the threaded function; Thread0 (C++ member functions internally expect this pointer as first; argument to have access to class members of the same instance).; `pthreads` are made for simple C functions and do not know about Thread0; being a member function of a class. Thus, you have to pass this; information by hand, if you want to access all members of the `Myclass`; instance from the Thread0 function. Note: Method Thread0 cannot be a virtual member function, since the cast; of `Thread0` to `void(*)` in the **`TThread`** constructor may raise; problems with C++ virtual function table. However, Thread0 may call; another virtual member function virtual void `Myclass::Func0()` which; then can be overridden in a derived class of `Myclass`. (See example; `TMhs3`). Class `Myclass` may also provide a method to stop the running thread:. ``` {.cpp}; Int_t Myclass::Threadstop() {; if (mTh) {; TThread::Delete(mTh);; delete mTh;; mTh=0;; return 0;; }; return 1;; }; ```. Example `TMhs3:` Class **`TThreadframe`**; (`TThreadframe.h, TThreadframe.cxx`) is a simple example of a framework; class managing up to four threaded methods. Class `TMhs3`; (`TMhs3.h, TMhs3.cxx)` inherits from this base class, showing th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:15622,simpl,simple,15622,documentation/users-guide/Threads.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md,1,['simpl'],['simple']
Usability,"ed if the coroutine frame needs to be allocated dynamically.; The `coro.id`_ intrinsic serves as coroutine identity useful in cases when the; `coro.begin`_ intrinsic get duplicated by optimization passes such as; jump-threading. The `cleanup` block destroys the coroutine frame. The `coro.free`_ intrinsic,; given the coroutine handle, returns a pointer of the memory block to be freed or; `null` if the coroutine frame was not allocated dynamically. The `cleanup`; block is entered when coroutine runs to completion by itself or destroyed via; call to the `coro.destroy`_ intrinsic. The `suspend` block contains code to be executed when coroutine runs to; completion or suspended. The `coro.end`_ intrinsic marks the point where; a coroutine needs to return control back to the caller if it is not an initial; invocation of the coroutine. The `loop` blocks represents the body of the coroutine. The `coro.suspend`_; intrinsic in combination with the following switch indicates what happens to; control flow when a coroutine is suspended (default case), resumed (case 0) or; destroyed (case 1). Coroutine Transformation; ------------------------. One of the steps of coroutine lowering is building the coroutine frame. The; def-use chains are analyzed to determine which objects need be kept alive across; suspend points. In the coroutine shown in the previous section, use of virtual register; `%inc` is separated from the definition by a suspend point, therefore, it; cannot reside on the stack frame since the latter goes away once the coroutine; is suspended and control is returned back to the caller. An i32 slot is; allocated in the coroutine frame and `%inc` is spilled and reloaded from that; slot as needed. We also store addresses of the resume and destroy functions so that the; `coro.resume` and `coro.destroy` intrinsics can resume and destroy the coroutine; when its identity cannot be determined statically at compile time. For our; example, the coroutine frame will be:. .. code-bloc",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:13682,resume,resumed,13682,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resumed']
Usability,"ed int par, unsigned int npoint, double low, double high) ###. Scans the value of the user function by varying parameter number; $\mbox{par}$, leaving all other parameters fixed at the current; value. If $\mbox{par}$ is not specified, all variable parameters are; scanned in sequence. The number of points $\mbox{npoints}$ in the; scan is 40 by default, and cannot exceed 100. The range of the scan is; by default 2 standard deviations on each side of the current best value,; but can be specified as from $\mbox{low}$ to $\mbox{high}$.; After each scan, if a new minimum is found, the best parameter values; are retained as start values for future scans or minimizations. The; curve resulting from each scan can be plotted on the output terminal; using MnPlot [api:plot] in order to show the approximate behaviour of; the function. ### ScanMinimizer ###. Although the $\mbox{SCAN}$ method is not intended for minimization; it can be used as a minimizer in its most primitive form. ## MnSimplex and SimplexMinimizer ##. [api:simplex]. $\mbox{SIMPLEX}$ is a function minimization method using the simplex; method of Nelder and Mead. MnSimplex provides minimization of the; function by the method of $\mbox{SIMPLEX}$ and the functionality for; parameters interaction. It also retains the result from the last; minimization in case the user may want to do subsequent minimization; steps with parameter interactions in between the minimization requests.; The minimization is done by the SimplexMinimizer. Minimization of the; function can be done by directly using the SimplexMinimizer if no; parameters interaction is required. As $\mbox{SIMPLEX}$ is a; stepping method it does not produce a covariance matrix. ### MnSimplex(const FCNBase&, const std::vector$<$double$>$&,\; const std::vector$<$double$>$&, unsigned int) ###. Constructor for the minimal required interface: $\mbox{FCN}$ and; starting values for parameters and uncertainties. Optional the strategy; level in MnStrategy can be specified. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:48380,Simpl,SimplexMinimizer,48380,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['Simpl'],['SimplexMinimizer']
Usability,"ed is not allowed in general.; (Specifically, in the case where another thread might write to and read; from an address, introducing a store can change a load that may see; exactly one write into a load that may see multiple writes.). .. _ordering:. Atomic Memory Ordering Constraints; ----------------------------------. Atomic instructions (:ref:`cmpxchg <i_cmpxchg>`,; :ref:`atomicrmw <i_atomicrmw>`, :ref:`fence <i_fence>`,; :ref:`atomic load <i_load>`, and :ref:`atomic store <i_store>`) take; ordering parameters that determine which other atomic instructions on; the same address they *synchronize with*. These semantics implement; the Java or C++ memory models; if these descriptions aren't precise; enough, check those specs (see spec references in the; :doc:`atomics guide <Atomics>`). :ref:`fence <i_fence>` instructions; treat these orderings somewhat differently since they don't take an; address. See that instruction's documentation for details. For a simpler introduction to the ordering constraints, see the; :doc:`Atomics`. ``unordered``; The set of values that can be read is governed by the happens-before; partial order. A value cannot be read unless some operation wrote; it. This is intended to provide a guarantee strong enough to model; Java's non-volatile shared variables. This ordering cannot be; specified for read-modify-write operations; it is not strong enough; to make them atomic in any interesting way.; ``monotonic``; In addition to the guarantees of ``unordered``, there is a single; total order for modifications by ``monotonic`` operations on each; address. All modification orders must be compatible with the; happens-before order. There is no guarantee that the modification; orders can be combined to a global total order for the whole program; (and this often will not be possible). The read in an atomic; read-modify-write operation (:ref:`cmpxchg <i_cmpxchg>` and; :ref:`atomicrmw <i_atomicrmw>`) reads the value in the modification; order immediately befo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:152925,simpl,simpler,152925,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['simpl'],['simpler']
Usability,"ed to manipulate an existing; coroutine. They can be used in any function which happen to have a pointer; to a `coroutine frame`_ or a pointer to a `coroutine promise`_. .. _coro.destroy:. 'llvm.coro.destroy' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.coro.destroy(ptr <handle>). Overview:; """""""""""""""""". The '``llvm.coro.destroy``' intrinsic destroys a suspended; switched-resume coroutine. Arguments:; """""""""""""""""""". The argument is a coroutine handle to a suspended coroutine. Semantics:; """""""""""""""""""". When possible, the `coro.destroy` intrinsic is replaced with a direct call to; the coroutine destroy function. Otherwise it is replaced with an indirect call; based on the function pointer for the destroy function stored in the coroutine; frame. Destroying a coroutine that is not suspended leads to undefined behavior. .. _coro.resume:. 'llvm.coro.resume' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ::. declare void @llvm.coro.resume(ptr <handle>). Overview:; """""""""""""""""". The '``llvm.coro.resume``' intrinsic resumes a suspended switched-resume coroutine. Arguments:; """""""""""""""""""". The argument is a handle to a suspended coroutine. Semantics:; """""""""""""""""""". When possible, the `coro.resume` intrinsic is replaced with a direct call to the; coroutine resume function. Otherwise it is replaced with an indirect call based; on the function pointer for the resume function stored in the coroutine frame.; Resuming a coroutine that is not suspended leads to undefined behavior. .. _coro.done:. 'llvm.coro.done' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ::. declare i1 @llvm.coro.done(ptr <handle>). Overview:; """""""""""""""""". The '``llvm.coro.done``' intrinsic checks whether a suspended; switched-resume coroutine is at the final suspend point or not. Arguments:; """""""""""""""""""". The argument is a handle to a suspended coroutine. Semantics:; """""""""""""""""""". Using this intrinsic on a coroutine that does not have a `final suspend`_ point; or on a c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:27825,resume,resume,27825,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"ed with a null resume function. There is a somewhat complex protocol of intrinsics for allocating and; deallocating the coroutine object. It is complex in order to allow the; allocation to be elided due to inlining. This protocol is discussed; in further detail below. The frontend may generate code to call the coroutine function directly;; this will become a call to the ramp function and will return a pointer; to the coroutine object. The frontend should always resume or destroy; the coroutine using the corresponding intrinsics. Returned-Continuation Lowering; ------------------------------. In returned-continuation lowering, signaled by the use of; `llvm.coro.id.retcon` or `llvm.coro.id.retcon.once`, some aspects of; the ABI must be handled more explicitly by the frontend. In this lowering, every suspend point takes a list of ""yielded values""; which are returned back to the caller along with a function pointer,; called the continuation function. The coroutine is resumed by simply; calling this continuation function pointer. The original coroutine; is divided into the ramp function and then an arbitrary number of; these continuation functions, one for each suspend point. LLVM actually supports two closely-related returned-continuation; lowerings:. - In normal returned-continuation lowering, the coroutine may suspend; itself multiple times. This means that a continuation function; itself returns another continuation pointer, as well as a list of; yielded values. The coroutine indicates that it has run to completion by returning; a null continuation pointer. Any yielded values will be `undef`; should be ignored. - In yield-once returned-continuation lowering, the coroutine must; suspend itself exactly once (or throw an exception). The ramp; function returns a continuation function pointer and yielded; values, the continuation function may optionally return ordinary; results when the coroutine has run to completion. The coroutine frame is maintained in a fixed-size buf",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:5712,resume,resumed,5712,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,2,"['resume', 'simpl']","['resumed', 'simply']"
Usability,"ed with them will see many familiar elements. Where appropriate; we will make this connection with the earlier APIs explicit to help people who; are transitioning from them to ORC. JIT API Basics; ==============. The purpose of a JIT compiler is to compile code ""on-the-fly"" as it is needed,; rather than compiling whole programs to disk ahead of time as a traditional; compiler does. To support that aim our initial, bare-bones JIT API will have; just two functions:. 1. ``Error addModule(std::unique_ptr<Module> M)``: Make the given IR module; available for execution.; 2. ``Expected<ExecutorSymbolDef> lookup()``: Search for pointers to; symbols (functions or variables) that have been added to the JIT. A basic use-case for this API, executing the 'main' function from a module,; will look like:. .. code-block:: c++. JIT J;; J.addModule(buildModule());; auto *Main = J.lookup(""main"").getAddress().toPtr<int(*)(int, char *[])>();; int Result = Main();. The APIs that we build in these tutorials will all be variations on this simple; theme. Behind this API we will refine the implementation of the JIT to add; support for concurrent compilation, optimization and lazy compilation.; Eventually we will extend the API itself to allow higher-level program; representations (e.g. ASTs) to be added to the JIT. KaleidoscopeJIT; ===============. In the previous section we described our API, now we examine a simple; implementation of it: The KaleidoscopeJIT class [1]_ that was used in the; `Implementing a language with LLVM <LangImpl01.html>`_ tutorials. We will use; the REPL code from `Chapter 7 <LangImpl07.html>`_ of that tutorial to supply the; input for our JIT: Each time the user enters an expression the REPL will add a; new IR module containing the code for that expression to the JIT. If the; expression is a top-level expression like '1+1' or 'sin(x)', the REPL will also; use the lookup method of our JIT class find and execute the code for the; expression. In later chapters of this tu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT1.rst:3420,simpl,simple,3420,interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT1.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT1.rst,1,['simpl'],['simple']
Usability,"ed) on an as-needed basis.; Note carefully how this is different from other Python (extension); modules, and what to expect if you use the normal inspection tools (such; as e.g. '`dir()`'). This feature prevents the inspection tools from; being swamped by an enormous amount of classes, but they can no longer; be used to explore unknown parts of the system (e.g. to find out which; classes are available). Furthermore, because of this approach,; \<`tab`\>-completion will usually not be available until after the first; use (and hence creation) of a class. Access to class static functions, public data members, enums, etc. is as; expected. Many more example uses of ROOT classes from Python can be; found in the tutorials directory in the ROOT distribution. The recipes; section contains a description on working with your own classes (see; ""Using Your Own Classes""). #### Access to STL Classes. The STL classes live in the ROOT.std namespace (or, if you prefer to get; them from there, in the ROOT module directly, but doing so makes the; code less clear, of course). Be careful in their use, because Python; already has types called ""`string`"" and ""`list`."". In order to understand how to get access to a templated class, think of; the general template as a meta class. By instantiating the meta class; with the proper parameters, you get an actual class, which can then be; used to create object instances. An example usage:. ``` {.cpp}; >>> from ROOT import std; >>> v = std.vector(int)(); >>> for i in range(0,10):; ... v.push_back(i); ...; >>> for i in v:; ... print(i, end=' '); 1 2 3 4 5 6 7 8 9; >>>; >>> list(v); [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]; >>>; ```. The parameters to the template instantiation can either be an actual; type or value (as is used here, ""int""), or a string representation of; the parameters (e.g. ""'double'""), or a mixture of both (e.g. ""'TCanvas,; 0'"" or ""'double', 0"" ). The ""std::vector\<int\>"" class is one of the; classes builtin by default into the Cling extensio",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:11682,clear,clear,11682,documentation/users-guide/PythonRuby.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md,1,['clear'],['clear']
Usability,"ed). In addition,; the separation indices are protected against negative S or; S+B returning 0.5 (no separation at all) in case that; occurs.; ; BDT: In addition there is a new BDT option to; ignore events with negative event weights for the; training. This option could be used as a cross check of a; ""worst case"" solution for Monte Carlo samples with; negative weights. Note that the results of the testing; phase still include these events and are hence objective.; ; BDT: Added randomised trees: similar to the; ""Random Forests"" technique of Leo Breiman and Adele; Cutler, it uses the ""bagging"" algorithm and bases the; determination of the best node-split during the training; on a random subset of variables only, which is; individually chosen for each split.; ; BDT: Move to TRandom2 for the ""bagging"" algorithm; and throw random weights according to Poisson; statistics. (This way the random weights are closer to a; resampling with replacement algorithm.); ; TMlpANN: Extended options to; TMultilayerPerceptron learning methods. Added example for; reader application: TMVApplication.py; . GUI:. Parallel Coordinates: New GUI button for Parallel; Coordinate plotting.; . Application:. Added Python example for reader application: TMVApplication.py; . Bug fixes:. TMlpANN: fixed crash with ROOT>=5.17 when using; large number of test events; also corrected bias in cross; validation: before the test events were used, which led to; an overestimated performance evaluation in case of a small; number of degrees of freedom; separate now training tree; in two parts for training and validation with configurable; ValidationFraction; ; Cuts: Corrected inconsistency in MethodCuts:; the signal efficiency written out into the weight file does; not correspond to the center of the bin within which the; background rejection is maximised (as before) but to the; lower left edge of it. This is because the cut optimisation; algorithm determines the best background rejection for all; signal efficienci",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/doc/v520/index.html:4152,learn,learning,4152,tmva/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/doc/v520/index.html,1,['learn'],['learning']
Usability,"ed. Each virtual register can only be mapped to physical registers of a; particular class. For instance, in the X86 architecture, some virtuals can only; be allocated to 8 bit registers. A register class is described by; ``TargetRegisterClass`` objects. To discover if a virtual register is; compatible with a given physical, this code can be used:. .. code-block:: c++. bool RegMapping_Fer::compatible_class(MachineFunction &mf,; unsigned v_reg,; unsigned p_reg) {; assert(TargetRegisterInfo::isPhysicalRegister(p_reg) &&; ""Target register must be physical"");; const TargetRegisterClass *trc = mf.getRegInfo().getRegClass(v_reg);; return trc->contains(p_reg);; }. Sometimes, mostly for debugging purposes, it is useful to change the number of; physical registers available in the target architecture. This must be done; statically, inside the ``TargetRegisterInfo.td`` file. Just ``grep`` for; ``RegisterClass``, the last parameter of which is a list of registers. Just; commenting some out is one simple way to avoid them being used. A more polite; way is to explicitly exclude some registers from the *allocation order*. See the; definition of the ``GR8`` register class in; ``lib/Target/X86/X86RegisterInfo.td`` for an example of this. Virtual registers are also denoted by integer numbers. Contrary to physical; registers, different virtual registers never share the same number. Whereas; physical registers are statically defined in a ``TargetRegisterInfo.td`` file; and cannot be created by the application developer, that is not the case with; virtual registers. In order to create new virtual registers, use the method; ``MachineRegisterInfo::createVirtualRegister()``. This method will return a new; virtual register. Use an ``IndexedMap<Foo, VirtReg2IndexFunctor>`` to hold; information per virtual register. If you need to enumerate all virtual; registers, use the function ``TargetRegisterInfo::index2VirtReg()`` to find the; virtual register numbers:. .. code-block:: c++. for (unsigned",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:60592,simpl,simple,60592,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,1,['simpl'],['simple']
Usability,"ed.; reserved ``s_trap 0x05`` Reserved.; reserved ``s_trap 0x06`` Reserved.; reserved ``s_trap 0x07`` Reserved.; reserved ``s_trap 0x08`` Reserved.; reserved ``s_trap 0xfe`` Reserved.; reserved ``s_trap 0xff`` Reserved.; =================== =============== =============== =======================================. .. .. table:: AMDGPU Trap Handler for AMDHSA OS Code Object V4 and Above; :name: amdgpu-trap-handler-for-amdhsa-os-v4-onwards-table. =================== =============== ================ ================= =======================================; Usage Code Sequence GFX6-GFX8 Inputs GFX9-GFX11 Inputs Description; =================== =============== ================ ================= =======================================; reserved ``s_trap 0x00`` Reserved by hardware.; debugger breakpoint ``s_trap 0x01`` *none* *none* Reserved for debugger to use for; breakpoints. Causes wave to be halted; with the PC at the trap instruction.; The debugger is responsible to resume; the wave, including the instruction; that the breakpoint overwrote.; ``llvm.trap`` ``s_trap 0x02`` ``SGPR0-1``: *none* Causes wave to be halted with the PC at; ``queue_ptr`` the trap instruction. The associated; queue is signalled to put it into the; error state. When the queue is put in; the error state, the waves executing; dispatches on the queue will be; terminated.; ``llvm.debugtrap`` ``s_trap 0x03`` *none* *none* - If debugger not enabled then behaves; as a no-operation. The trap handler; is entered and immediately returns to; continue execution of the wavefront.; - If the debugger is enabled, causes; the debug trap to be reported by the; debugger and the wavefront is put in; the halt state with the PC at the; instruction. The debugger must; increment the PC and resume the wave.; reserved ``s_trap 0x04`` Reserved.; reserved ``s_trap 0x05`` Reserved.; reserved ``s_trap 0x06`` Reserved.; reserved ``s_trap 0x07`` Reserved.; reserved ``s_trap 0x08`` Reserved.; reserved ``s_trap 0xfe`` Reserved.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:384638,resume,resume,384638,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['resume'],['resume']
Usability,"ed; standard e.g. libcxx.; The list is roughly in chronological order of renaming.; Some items may not make sense to rename individually - it is expected that; this list will change following experimentation:. * TableGen; * llvm/tools; * clang-tools-extra; * clang; * ARM backend; * AArch64 backend; * AMDGPU backend; * ARC backend; * AVR backend; * BPF backend; * Hexagon backend; * Lanai backend; * MIPS backend; * NVPTX backend; * PowerPC backend; * RISC-V backend; * Sparc backend; * SystemZ backend; * WebAssembly backend; * X86 backend; * XCore backend; * libLTO; * Debug Information; * Remainder of llvm; * compiler-rt; * libunwind; * openmp; * parallel-libs; * polly; * lldb. #. Remove the old variable name rule from the policy page. #. Repeat many of the steps in the sequence, using a script to expand acronyms. References; ==========. .. [LLDB] LLDB Coding Conventions https://llvm.org/svn/llvm-project/lldb/branches/release_39/www/lldb-coding-conventions.html; .. [Google] Google C++ Style Guide https://google.github.io/styleguide/cppguide.html#Variable_Names; .. [WebKit] WebKit Code Style Guidelines https://webkit.org/code-style-guidelines/#names; .. [Qt] Qt Coding Style https://wiki.qt.io/Qt_Coding_Style#Declaring_variables; .. [Rust] Rust naming conventions https://doc.rust-lang.org/1.0.0/style/style/naming/README.html; .. [Swift] Swift API Design Guidelines https://swift.org/documentation/api-design-guidelines/#general-conventions; .. [Python] Style Guide for Python Code https://www.python.org/dev/peps/pep-0008/#function-and-variable-names; .. [Mozilla] Mozilla Coding style: Prefixes https://firefox-source-docs.mozilla.org/tools/lint/coding-style/coding_style_cpp.html#prefixes; .. [SVE] LLVM with support for SVE https://github.com/ARM-software/LLVM-SVE; .. [AminiInconsistent] Mehdi Amini, http://lists.llvm.org/pipermail/llvm-dev/2019-February/130329.html; .. [ArsenaultAgree] Matt Arsenault, http://lists.llvm.org/pipermail/llvm-dev/2019-February/129934.html; .. [Be",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst:13459,Guid,Guide,13459,interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst,1,['Guid'],['Guide']
Usability,"edOperatorKind``). ``CXXLiteralOperatorName``. The name is a C++11 user defined literal operator. User defined; Literal operators are named according to the suffix they define,; e.g., ""``_foo``"" for ""``operator """" _foo``"". Use; ``N.getCXXLiteralIdentifier()`` to retrieve the corresponding; ``IdentifierInfo*`` pointing to the identifier. ``CXXUsingDirective``. The name is a C++ using directive. Using directives are not really; NamedDecls, in that they all have the same name, but they are; implemented as such in order to store them in DeclContext; effectively. ``DeclarationName``\ s are cheap to create, copy, and compare. They require; only a single pointer's worth of storage in the common cases (identifiers,; zero- and one-argument Objective-C selectors) and use dense, uniqued storage; for the other kinds of names. Two ``DeclarationName``\ s can be compared for; equality (``==``, ``!=``) using a simple bitwise comparison, can be ordered; with ``<``, ``>``, ``<=``, and ``>=`` (which provide a lexicographical ordering; for normal identifiers but an unspecified ordering for other kinds of names),; and can be placed into LLVM ``DenseMap``\ s and ``DenseSet``\ s. ``DeclarationName`` instances can be created in different ways depending on; what kind of name the instance will store. Normal identifiers; (``IdentifierInfo`` pointers) and Objective-C selectors (``Selector``) can be; implicitly converted to ``DeclarationNames``. Names for C++ constructors,; destructors, conversion functions, and overloaded operators can be retrieved; from the ``DeclarationNameTable``, an instance of which is available as; ``ASTContext::DeclarationNames``. The member functions; ``getCXXConstructorName``, ``getCXXDestructorName``,; ``getCXXConversionFunctionName``, and ``getCXXOperatorName``, respectively,; return ``DeclarationName`` instances for the four kinds of C++ special function; names. .. _DeclContext:. Declaration contexts; --------------------. Every declaration in a program exists with",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:72049,simpl,simple,72049,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['simpl'],['simple']
Usability,"ed_inlined 'InlineFunction' -> 'int'; [003] {Block}; [004] 5 {Variable} 'Var_2' -> 'int'; [003] 2 {Parameter} 'Param' -> 'int'; [003] 3 {Variable} 'Var_1' -> 'int'; [002] 11 {Function} extern not_inlined 'test' -> 'int'; [003] 12 {Variable} 'A' -> 'int'; [003] 13 {InlinedFunction} declared_inlined 'InlineFunction' -> 'int'; [004] {Block}; [005] {Variable} 'Var_2' -> 'int'; [004] {Parameter} 'Param' -> 'int'; [004] {Variable} 'Var_1' -> 'int'; [003] 11 {Parameter} 'Param_1' -> 'int'; [003] 11 {Parameter} 'Param_2' -> 'int'. From the previous logical views, we can see that the CodeView debug; information generated by the Clang compiler shows the variables **Var_1**; and **Var_2** are at the same lexical scope (**4**) in the function; **InlineFuction**. The DWARF generated by GCC/Clang and CodeView; generated by MSVC, show those variables at the correct lexical scope:; **3** and **4** respectively. Using the :program:`llvm-debuginfo-analyzer` selection facilities, we; can produce a simple tabular output showing just the logical elements; that have in their name the *var* pattern. The logical view is sorted; by the variables name. .. code-block:: none. llvm-debuginfo-analyzer --attribute=level,format; --output-sort=name; --select-regex --select-nocase --select=Var; --report=list; --print=symbols; pr-43860-*.o. .. code-block:: none. Logical View:; [000] {File} 'pr-43860-codeview-clang.o' -> COFF-x86-64. [001] {CompileUnit} 'pr-43860.cpp'; [004] {Variable} 'Var_1' -> 'int'; [004] {Variable} 'Var_2' -> 'int'. Logical View:; [000] {File} 'pr-43860-codeview-msvc.o' -> COFF-i386. [001] {CompileUnit} 'pr-43860.cpp'; [003] {Variable} 'Var_1' -> 'int'; [004] {Variable} 'Var_2' -> 'int'. Logical View:; [000] {File} 'pr-43860-dwarf-clang.o' -> elf64-x86-64. [001] {CompileUnit} 'pr-43860.cpp'; [004] {Variable} 'Var_1' -> 'int'; [003] 3 {Variable} 'Var_1' -> 'int'; [005] {Variable} 'Var_2' -> 'int'; [004] 5 {Variable} 'Var_2' -> 'int'. Logical View:; [000] {File} 'pr-43860-dwarf-gcc.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst:53415,simpl,simple,53415,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst,1,['simpl'],['simple']
Usability,"editors`*. Any object editor; provides an object specific GUI. The main purpose of the ROOT graphics; editor is the organization of the object editors' appearance and the; task sequence between them. ### Object Editors. Every object editor follows a simple naming convention: to have as a; name the object class name concatenated with ‘*`Editor`*' (e.g. for; **`TGraph`** objects the object editor is **`TGraphEditor`**). Thanks to; the signals/slots communication mechanism and to the method; `DistancetoPrimitive()` that computes a ‘‘distance'' to an object from; the mouse position, it was possible to implement a signal method of the; canvas that says which is the selected object and to which pad it; belongs. Having this information the graphics editor loads the; corresponding object editor and the user interface is ready for use.; This way after a click on ‘axis'—the axis editor is active; a click on a; ‘pad' activates the pad editor, etc. The algorithm in use is simple and is based on the object-oriented; relationship and communication. When the user activates the editor,; according to the selected object **`<obj>`** in the canvas it looks for; a class name **`<obj>Editor`**. For that reason, the correct naming is; very important. If a class with this name is found, the editor verifies; that this class derives from the base editor class **`TGedFrame`**. If; all checks are satisfied, the editor makes an instance of the object; editor. Then, it scans all object base classes searching the; corresponding object editors. When it finds one, it makes an instance of; the base class editor too. Once the object editor is in place, it sets the user interface elements; according to the object's status. After that, it is ready to interact; with the object following the user actions. The graphics editor gives an intuitive way to edit objects in a canvas; with immediate feedback. Complexity of some object editors is reduced by; hiding GUI elements and revealing them only on users' r",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:102937,simpl,simple,102937,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,2,['simpl'],['simple']
Usability,"eds to provide a function.; ROOT provides a common way of specifying them via some interfaces. ## ROOT::Math Function interfaces. To get a consistency in the mathematical methods within ROOT, there exists a set of interfaces to define the basic behaviour of a mathematical function.; In order to use the classes presented in this chapter, the mathematical functions defined by the user must inherit from any of the classes seen in the figure:. ![ROOT::Math Function interface structure](pictures/function-hierarchy.png). ### One-dimensional Function Interfaces. These interfaces are used for numerical algorithms operating only on one-dimensional functions and cannot be applied to multi-dimensional functions.; For this case the users needs to define a function object which evaluates in one dimension, and the object will have to derivate from the following:. * `ROOT::Math::IBaseFunctionOneDim`: This class is the most basic function. Provides a method to evaluate the function given a value (simple double) by implementing; `double operator() (const double )`. The user class defined only needs to reimplement the pure abstract method `double DoEval(double x)`,; that will do the work of evaluating the function at point x. Example on how to create a class that represents a mathematical function. The user only has to override two methods from `IBaseFunctionOneDim`:. ```{.cpp}; #include ""Math/IFunction.h"". class MyFunction: public ROOT::Math::IBaseFunctionOneDim; {; double DoEval(double x) const; {; return x*x;; }. ROOT::Math::IBaseFunctionOneDim* Clone() const; {; return new MyFunction();; }; };; ```. * `ROOT::Math::IGradientFunctionOneDim`: Some of the numerical algorithm will need to calculate the derivatives of the function. In these cases, the user will have to provide the necessary code for; this to happen. The interface defined in `IGradientFunctionOneDim` introduced the method `double Derivative(double x)` that will return the derivative of the function at the point `x`. The ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:35631,simpl,simple,35631,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['simpl'],['simple']
Usability,"eds, the collector copies objects from one heap; area to another, compacting them in the process. Copying collectors enable; highly efficient ""bump pointer"" allocation and can improve locality of; reference. Incremental; (Including generational collectors.) Incremental collectors generally have all; the properties of a copying collector (regardless of whether the mature heap; is compacting), but bring the added complexity of requiring write barriers. Threaded; Denotes a multithreaded mutator; the collector must still stop the mutator; (""stop the world"") before beginning reachability analysis. Stopping a; multithreaded mutator is a complicated problem. It generally requires highly; platform-specific code in the runtime, and the production of carefully; designed machine code at safe points. Concurrent; In this technique, the mutator and the collector run concurrently, with the; goal of eliminating pause times. In a *cooperative* collector, the mutator; further aids with collection should a pause occur, allowing collection to take; advantage of multiprocessor hosts. The ""stop the world"" problem of threaded; collectors is generally still present to a limited extent. Sophisticated; marking algorithms are necessary. Read barriers may be necessary. As the matrix indicates, LLVM's garbage collection infrastructure is already; suitable for a wide variety of collectors, but does not currently extend to; multithreaded programs. This will be added in the future as there is; interest. .. _stack-map:. Computing stack maps; --------------------. LLVM automatically computes a stack map. One of the most important features; of a ``GCStrategy`` is to compile this information into the executable in; the binary representation expected by the runtime library. The stack map consists of the location and identity of each GC root in the; each function in the module. For each root:. * ``RootNum``: The index of the root. * ``StackOffset``: The offset of the object relative to the frame pointer",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst:31462,pause,pause,31462,interpreter/llvm-project/llvm/docs/GarbageCollection.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst,1,['pause'],['pause']
Usability,"ee TNamed::GetName() in its list of functions.; A click on this name will send you to the documentation for the method.; If you enabled the display of inherited members you will see; some members with a class name prefix. It tells you where this method has been defined.; Display Options; The info box contains options that influence how; the list of members is displayed: you can e.g. show or hide non-public methods. If you; just want to use ROOT you should hide them - you cannot access protected or private; members anyway. And you can select whether member that are inherited from a base class; should be shown. Again, if you just want to use ROOT you should probably show them,; as you often want to use them whether they are defined in the current class or in one; of its base classes. Whatever you set these options to should be stored in a cookie,; so you will have the same setting next time you look at the class documentation. Access (public / protected / private); Not all members are available to everyone (check any C++ introduction to learn why).; Public members have a green bar on their left, protected ones have a yellow one, and; private members are marked with a red bar. Of course you won't see any protected or; private members if you hide them in the display options. Inheritance; You can often access members of a class's base classes, just as if they are defined; in the derived class. A histogram,; for example, has a name, and you can access it using GetName() as defined in its base; class TNamed. If you want to see; all available members, and not just the ones defined in the current class, in the; display options. They will be prefixed with the name of; the class they are defined in. Class Charts; The class charts are shown in a tabbed box; click on the names ontop to select a tab. Inheritance; This chart shows the inheritance hierarchy for the current class. Arrows point to; base classes. You can click the classes to get to their reference page. Inherited Memb",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/etc/html/HELP.html:6180,learn,learn,6180,etc/html/HELP.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/etc/html/HELP.html,1,['learn'],['learn']
Usability,"ee later). User convenient typedefs are also provided.; 	They derive from the common generic interface multi-dimensional for function evaluation, `ROOT::Math::IBaseFunctionMultiDim`. In addition the fitter classes make uses of the generic interfaces for parametric function evaluations, `ROOT::Math::IParametricFunctionMultiDim`; to define the fit model function and use the `ROOT::Math::Minimizer` interface to perform the minimization of the objective function.; More information about the function interface and the multi-dimensional minimization in ROOT is given in the Mathematical Library chapter. Here we present a detailed description of the `ROOT::Fit` classes and how to use them.; Using these classes instead of the interface provided directly in the ROOT data objects, like `TH1::Fit` allow are more fine control; to configure and customise the fits. For example, using these classes a combined fit of several histograms can be performed. To understand how these class work, let's go through a simple example, such as fitting an histogram. When fitting an histogram, instead of using `TH1::Fit` we will show in the following hot wo use the `ROOT::Fit` classes.; We will show how to perform the following different type of fits with the histogram data:; * a least square fit using the observed errors (Neyman chi-squared);; * a least square fit using the expected errors from the function (Pearson chi-squared);; * a binned likelihood fit;; * an extended unbinned likelihood fits, if the histogram has been set to store in the buffer the original data used to fill it. Let's go through all the steps required for performing these fits using the `ROOT::Fit::Fitter` class.; These steps are:; 1. Create the input fit data object.; 2. Create the input model function.; 3. Configure the fit.; 4. Perform the data fitting.; 5. Examine the result. ### Creating the input fit data. We have two types of input data, binned data (class `ROOT::Fit::BinData`) used for least square (chi-square) fits o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:28728,simpl,simple,28728,documentation/users-guide/FittingHistograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md,1,['simpl'],['simple']
Usability,"ee(a); // warn: argument is not allocated by malloc; }. void test() {; int *p = malloc(sizeof(char));; p = p - 1;; free(p); // warn: argument to free() is offset by -4 bytes; }. unix.MallocSizeof; (C); Check for dubious malloc, calloc or; realloc arguments involving sizeof. void test() {; long *p = malloc(sizeof(short));; // warn: result is converted to 'long *', which is; // incompatible with operand type 'short'; free(p);; }. unix.MismatchedDeallocator; (C, C++, ObjC); Check for mismatched deallocators (e.g. passing a pointer allocating; with new to free()). // C, C++; void test() {; int *p = (int *)malloc(sizeof(int));; delete p; // warn; }. // C, C++; void __attribute((ownership_returns(malloc))) *user_malloc(size_t);. void test() {; int *p = (int *)user_malloc(sizeof(int));; delete p; // warn; }. // C, C++; void test() {; int *p = new int;; free(p); // warn; }. // C, C++; void test() {; int *p = new int[1];; realloc(p, sizeof(long)); // warn; }. // C, C++; template <typename T>; struct SimpleSmartPointer {; T *ptr;. explicit SimpleSmartPointer(T *p = 0) : ptr(p) {}; ~SimpleSmartPointer() {; delete ptr; // warn; }; };. void test() {; SimpleSmartPointer<int> a((int *)malloc(4));; }. // C++; void test() {; int *p = (int *)operator new(0);; delete[] p; // warn; }. // Objective-C, C++; void test(NSUInteger dataLength) {; int *p = new int;; NSData *d = [NSData dataWithBytesNoCopy:p; length:sizeof(int) freeWhenDone:1];; // warn +dataWithBytesNoCopy:length:freeWhenDone: cannot take; // ownership of memory allocated by 'new'; }. unix.Vfork; (C); Check for proper usage of vfork. int test(int x) {; pid_t pid = vfork(); // warn; if (pid != 0); return 0;. switch (x) {; case 0:; pid = 1;; execl("""", """", 0);; _exit(1);; break;; case 1:; x = 0; // warn: this assignment is prohibited; break;; case 2:; foo(); // warn: this function call is prohibited; break;; default:; return 0; // warn: return is prohibited; }. while(1);; }. unix.cstring.BadSizeArg; (C); Check the size argument ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:25604,Simpl,SimpleSmartPointer,25604,interpreter/llvm-project/clang/www/analyzer/available_checks.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html,1,['Simpl'],['SimpleSmartPointer']
Usability,"eed.dyn.free, label %dyn.free, label %if.end; dyn.free:; call void @CustomFree(ptr %mem); br label %if.end; if.end:; ... With allocations and deallocations represented as described as above, after; coroutine heap allocation elision optimization, the resulting main will be:. .. code-block:: llvm. define i32 @main() {; entry:; call void @print(i32 4); call void @print(i32 5); call void @print(i32 6); ret i32 0; }. Multiple Suspend Points; -----------------------. Let's consider the coroutine that has more than one suspend point:. .. code-block:: c++. void *f(int n) {; for(;;) {; print(n++);; <suspend>; print(-n);; <suspend>; }; }. Matching LLVM code would look like (with the rest of the code remaining the same; as the code in the previous section):. .. code-block:: llvm. loop:; %n.addr = phi i32 [ %n, %entry ], [ %inc, %loop.resume ]; call void @print(i32 %n.addr) #4; %2 = call i8 @llvm.coro.suspend(token none, i1 false); switch i8 %2, label %suspend [i8 0, label %loop.resume; i8 1, label %cleanup]; loop.resume:; %inc = add nsw i32 %n.addr, 1; %sub = xor i32 %n.addr, -1; call void @print(i32 %sub); %3 = call i8 @llvm.coro.suspend(token none, i1 false); switch i8 %3, label %suspend [i8 0, label %loop; i8 1, label %cleanup]. In this case, the coroutine frame would include a suspend index that will; indicate at which suspend point the coroutine needs to resume. .. code-block:: llvm. %f.frame = type { ptr, ptr, i32, i32 }. The resume function will use an index to jump to an appropriate basic block and will look; as follows:. .. code-block:: llvm. define internal fastcc void @f.Resume(ptr %FramePtr) {; entry.Resume:; %index.addr = getelementptr inbounds %f.Frame, ptr %FramePtr, i64 0, i32 2; %index = load i8, ptr %index.addr, align 1; %switch = icmp eq i8 %index, 0; %n.addr = getelementptr inbounds %f.Frame, ptr %FramePtr, i64 0, i32 3; %n = load i32, ptr %n.addr, align 4. br i1 %switch, label %loop.resume, label %loop. loop.resume:; %sub = sub nsw i32 0, %n; call void @pr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:18533,resume,resume,18533,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"een the two as part of overload resolution and ``cppyy``; allows C++ exceptions as such, enabling detailed type disambiguation and; input validation.; (The original use case was for filling database fields, requiring an exact; field label and data type match.). If, however, all methods fail and there is only one C++ exception (the other; exceptions originating from argument conversion, never succeeding to call; into C++), this C++ exception will be preferentially reported and will have; the original C++ type. `Return values`; ---------------. Most return types are readily amenable to automatic memory management: builtin; returns, by-value returns, (const-)reference returns to internal data, smart; pointers, etc.; The important exception is pointer returns.; ; A function that returns a pointer to an object over which Python should claim; ownership, should have its ``__creates__`` flag set through its; :doc:`pythonization <pythonizations>`.; Well-written APIs will have clear clues in their naming convention about the; ownership rules.; For example, functions called ``New...``, ``Clone...``, etc. can be expected; to return freshly allocated objects.; A basic name-matching in the pythonization then makes it simple to mark all; these functions as creators. The return values are :ref:`auto-casted <sec-auto-casting-label>`. `\*args and \*\*kwds`; ---------------------. C++ default arguments work as expected.; Keywords, however, are a Python language feature that does not exist in C++.; Many C++ function declarations do have formal arguments, but these are not; part of the C++ interface (the argument names are repeated in the definition,; making the names in the declaration irrelevant: they do not even need to be; provided).; Thus, although ``cppyy`` will map keyword argument names to formal argument; names from the C++ declaration, use of this feature is not recommended unless; you have a guarantee that the names in C++ the interface are maintained.; Example:. .. code-bloc",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/functions.rst:12765,clear,clear,12765,bindings/pyroot/cppyy/cppyy/doc/source/functions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/functions.rst,1,['clear'],['clear']
Usability,"ef SimpleStreamChecker : Checker<""SimpleStream"">,; HelpText<""Check for misuses of stream APIs"">,; DescFile<""SimpleStreamChecker.cpp"">;; ...; } // end ""alpha.unix"". The source code file was made visible to CMake by adding it to; lib/StaticAnalyzer/Checkers/CMakeLists.txt. After adding a new checker to the analyzer, one can verify that the new checker; was successfully added by seeing if it appears in the list of available checkers:; $clang -cc1 -analyzer-checker-help; Events, Callbacks, and Checker Class Structure; All checkers inherit from the ; Checker template class; the template parameter(s) describe the type of; events that the checker is interested in processing. The various types of events; that are available are described in the file ; CheckerDocumentation.cpp; For each event type requested, a corresponding callback function must be; defined in the checker class (; CheckerDocumentation.cpp shows the; correct function name and signature for each event type). As an example, consider SimpleStreamChecker. This checker needs to; take action at the following times:. Before making a call to a function, check if the function is fclose.; If so, check the parameter being passed.; After making a function call, check if the function is fopen. If; so, process the return value.; When values go out of scope, check whether they are still-open file; descriptors, and report a bug if so. In addition, remove any information about; them from the program state in order to keep the state as small as possible.; When file pointers ""escape"" (are used in a way that the analyzer can no longer; track them), mark them as such. This prevents false positives in the cases where; the analyzer cannot be sure whether the file was closed or not. These events that will be used for each of these actions are, respectively, PreCall,; PostCall,; DeadSymbols,; and PointerEscape.; The high-level structure of the checker's class is thus:. class SimpleStreamChecker : public Checker<check::PreCall,; check:",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/checker_dev_manual.html:10597,Simpl,SimpleStreamChecker,10597,interpreter/llvm-project/clang/www/analyzer/checker_dev_manual.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/checker_dev_manual.html,1,['Simpl'],['SimpleStreamChecker']
Usability,"efault argument; >>> c.m_int; 42; >>> c = Concrete(13) # uses provided argument; >>> c.m_int; 13; >>> args = (27,); >>> c = Concrete(*args) # argument pack; >>> c.m_int; 27; >>> c = Concrete(n=17); >>> c.m_int; 17; >>> kwds = {'n' : 18}; >>> c = Concrete(**kwds); >>> c.m_int; 18; >>>. `Callbacks`; -----------. Python callables (functions/lambdas/instances) can be passed to C++ through; function pointers and/or ``std::function``.; This involves creation of a temporary wrapper, which has the same life time as; the Python callable it wraps, so the callable needs to be kept alive on the; Python side if the C++ side stores the callback.; Example:. .. code-block:: python. >>> from cppyy.gbl import call_int_int; >>> print(call_int_int.__doc__); int ::call_int_int(int(*)(int,int) f, int i1, int i2); >>> def add(a, b):; ... return a+b; ...; >>> call_int_int(add, 3, 7); 7; >>> call_int_int(lambda x, y: x*y, 3, 7); 21; >>>. Python functions can be used to instantiate C++ templates, assuming the; type information of the arguments and return types can be inferred.; If this can not be done directly from the template arguments, then it can; be provided through Python annotations, by explicitly adding the; ``__annotations__`` special data member (e.g. for older versions of Python; that do not support annotations), or by the function having been bound by; ``cppyy`` in the first place.; For example:. .. code-block:: python. >>> import cppyy; >>> cppyy.cppdef(""""""\; ... template<typename R, typename... U, typename... A>; ... R callT(R(*f)(U...), A&&... a) {; ... return f(a...);; ... }""""""); True; >>> def f(a: 'int') -> 'double':; ... return 3.1415*a; ...; >>> cppyy.gbl.callT(f, 2); 6.283; >>> def f(a: 'int', b: 'int') -> 'int':; ... return 3*a*b; ...; >>> cppyy.gbl.callT(f, 6, 7); 126; >>>. `extern ""C""`; ------------. Functions with C linkage are supported and are simply represented as; overloads of a single function.; Such functions are allowed both globally as well as in namespaces.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/functions.rst:15734,simpl,simply,15734,bindings/pyroot/cppyy/cppyy/doc/source/functions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/functions.rst,1,['simpl'],['simply']
Usability,"efault_%m.profraw`` in the directory named ``dirname`` if specified.; If ``dirname`` does not exist, it will be created at runtime. ``%m`` specifier; will be substituted with a unique id documented in step 2 above. In other words,; with ``-fprofile-generate[=<dirname>]`` option, the ""raw"" profile data automatic; merging is turned on by default, so there will no longer any risk of profile; clobbering from different running processes. For example,. .. code-block:: console. $ clang++ -O2 -fprofile-generate=yyy/zzz code.cc -o code. When ``code`` is executed, the profile will be written to the file; ``yyy/zzz/default_xxxx.profraw``. To generate the profile data file with the compiler readable format, the; ``llvm-profdata`` tool can be used with the profile directory as the input:. .. code-block:: console. $ llvm-profdata merge -output=code.profdata yyy/zzz/. If the user wants to turn off the auto-merging feature, or simply override the; the profile dumping path specified at command line, the environment variable; ``LLVM_PROFILE_FILE`` can still be used to override; the directory and filename for the profile file at runtime.; To override the path and filename at compile time, use; ``-Xclang -fprofile-instrument-path=/path/to/file_pattern.profraw``. .. option:: -fcs-profile-generate[=<dirname>]. The ``-fcs-profile-generate`` and ``-fcs-profile-generate=`` flags will use; the same instrumentation method, and generate the same profile as in the; ``-fprofile-generate`` and ``-fprofile-generate=`` flags. The difference is; that the instrumentation is performed after inlining so that the resulted; profile has a better context sensitive information. They cannot be used; together with ``-fprofile-generate`` and ``-fprofile-generate=`` flags.; They are typically used in conjunction with ``-fprofile-use`` flag.; The profile generated by ``-fcs-profile-generate`` and ``-fprofile-generate``; can be merged by llvm-profdata. A use example:. .. code-block:: console. $ clang++ -O2 -fprofi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:108435,simpl,simply,108435,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['simpl'],['simply']
Usability,"eference frame of the current volume and to; compute the distance to exit its shape from inside. The returned value; is again compared to the maximum allowed step (the proposed one) and in; case the distance is safe no other action is performed and the proposed; step is approved. In case the boundary is closer, the computed distance; is taken as maximum allowed step. For optimization purposed, for; particles starting very close to the current volume boundary (less than; 0.01 microns) and exiting the algorithm stops here. After computing the distance to exit the current node, the distance to; the daughter of the current volume which is crossed next is computed by; TGeoManager::FindNextDaughterBoundary(). This computes the; distance to all daughter candidates that can be possibly crossed by; using volume voxelization. The algorithm is efficient in average only in; case the number of daughters is greater than 4. For fewer nodes, a; simple loop is performed and the minimum distance (from a point outside; each shape) is taken and compared to the maximum allowed step. The step; value is again updated if `step<stepmax` . A special case is when the current node is declared as possibly; overlapping with something else. If this is the case, the distance is; computed for all possibly overlapping candidates, taking into account; the overlapping priorities (see also: "" Overlapping volumes ""). The global matrix describing the next crossed physical node is; systematically computed in case the value of the proposed step is; negative. In this case, one can subsequently call; TGeoManager::ComputeNormalFast() to get the normal vector to the; crossed surface, after propagating the current point with the; TGeoManager::GetStep() value. This propagation can be done like:. ~~~{.cpp}; Double_t *current_point = gGeoManager->GetCurrentPoint();; Double_t *current_dir = gGeoManager->GetCurrentDirection();; for (Int_t i=0; i<3; i++); current_point[i] += step * current_dir[I];; ~~~. Note: The met",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:124043,simpl,simple,124043,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['simpl'],['simple']
Usability,"egarding the report and parties involved. All incident reports should be assessed if they require immediate response and; acted on accordingly. .. _Incident Response Assessment:. Incident Response Assessment; ============================. The committee will assess the incident and determine an appropriate response.; The assessment will be documented and retained in records. Here are some; guidelines for the process:. * Review report documentation to determine the content and context of the; incident. * Request additional information if needed from the reporter. * Determine if it occurred within the scope of the CoC.; * Determine if it violated the CoC and specifically which part.; * Consult documentation of past incidents for patterns of behavior (if; available and applicable).; * Follow up with the reportee to get their view or any other additional; information.; * Determine appropriate resolutions to the incident when all information has; been gathered.; * Notify the reporter of the resolution and request feedback. This may or may; not be used to reevaluate the resolution. The committee will aim to have a resolution agreed upon within two weeks of; receipt of the incident report. In the event that a resolution cannot be; determined within that time, the CoC committee will respond to the reporter(s); with an updated and projected timeline for resolution. . .. _Following Up With the Reportee:. Following Up With the Reportee; ==============================. When following up with the reportee, the committee will:. * Explain that an incident was reported that involves the reportee.; * In this explanation, the focus will be on the impact of their behavior, not; their intent.; * Reiterate the Code of Conduct and that their behavior may be deemed; inappropriate.; * Give them the opportunity to state their view of the incident.; * Explain the possible resolutions that may be enforced should the CoC; committee determine there is a breach. The reportee will be given a week t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ResponseGuide.rst:5671,feedback,feedback,5671,interpreter/llvm-project/llvm/docs/ResponseGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ResponseGuide.rst,1,['feedback'],['feedback']
Usability,"el put a; limitation on the maximum applied depth. Combined with visibility; settings per volume, these can tune quite well what should appear on the; screen. However, there are situations when users want to see a volume; branch displayed down to the maximum depth, keeping at the same time a; limitation or even suppressing others. In order to accomplish that, one; should use the volume attribute: ""Visible daughters"". By default, all; daughters of all volumes are displayed if there is no limitation related; with their level depth with respect to the top drawn volume. \anchor GP04c; ### Ray Tracing. Ray tracing is a quite known drawing technique based on tracking rays; from the eye position through all pixels of a view port device. The; pixel color is derived from the properties of the first crossed surface,; according some illumination model and material optical properties. While; there are currently existing quite sophisticated ray tracing models,; `TGeo` is currently using a very simple approach where the light; source is matching the eye position (no shadows or back-tracing of the; reflected ray). In future we are considering providing a base class in; order to be able to derive more complex models. Due to the fact that the number of rays that have to be tracked matches; the size in pixels of the pad, the time required by this algorithm is; proportional to the pad size. On the other hand, the speed is quite; acceptable for the default ROOT pad size and the images produced by; using this technique have high quality. Since the algorithm is; practically using all navigation features, producing ray-traced pictures; is also a geometry validation check. Ray tracing can be activated at; volume level as the normal `Draw()`. \image html geometry013.jpg ""Ray-traced view in a pad"". ~~~{.cpp}; myVolume->Raytrace(); ~~~. Once ray-tracing a view, this can be zoomed or rotated as a usual one.; Objects on the screen are no longer highlighted when picking the; vertices but the corr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:104014,simpl,simple,104014,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['simpl'],['simple']
Usability,"elected object, executed from method **`TGedEditor::SetModel()`**.; When a new object of a different class is selected, the unneeded; GED-frames are cached in memory for potential reuse. The frames are; deleted automatically when the editor is closed. Note: A deep cleanup is assumed for all frames put into the editor. This; implies:. - do not share the layout-hints among GUI components;. - do not delete child widgets in the destructor as this is done; automatically. #### Using Several Tabs. Sometimes you might need to use several tabs to organize properly your; class-editor. Each editor tab is a resource shared among all the; class-editors. Tabs must be created from the constructor of your; editor-class by using the method:. ``` {.cpp}; TGVerticalFrame* TGedFrame::CreateEditorTabSubFrame(const Text_t *name),; ```. It returns a pointer to a new tab container frame ready for use in your; class. If you need to hide/show this frame depending on the object's; status, you should store it in a data member. See for examples:; **`TH1Editor`**, **`TH2Editor`**. #### Base-Class Editors Control. Full control over base-class editors can be achieved by re-implementing; virtual method void `TGedFrame::ActivateBaseClassEditors(TClass` `*cl)`.; It is called during each compound editor rebuild and the default; implementation simply offers all base-classes to the publishing; mechanism. To prevent inclusion of a base-class into the compound editor, call:. ``` {.cpp}; void TGedEditor::ExcludeClassEditor(TClass* class, Bool_t recurse); ```. Pointer to the compound GED-editor is available in **`TGedFrame`**‘s; data-member:. ``` {.cpp}; TGedEditor *fGedEditor; ```. Ordering of base-class editor frames follows the order of the classes in; the class hierarchy. This order can be changed by modifying the value of; **`TGedFrame`**'s data member `Int_t fPriority`. The default value is; 50; smaller values move the frame towards to the top. This priority; should be set in the editor constructor.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/ged/doc/index.md:5896,simpl,simply,5896,gui/ged/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/ged/doc/index.md,1,['simpl'],['simply']
Usability,"electionDAG.cpp``:. Add code to print the node to ``getOperationName``. If your new node can be; evaluated at compile time when given constant arguments (such as an add of a; constant with another constant), find the ``getNode`` method that takes the; appropriate number of arguments, and add a case for your node to the switch; statement that performs constant folding for nodes that take the same number; of arguments as your new node. #. ``lib/CodeGen/SelectionDAG/LegalizeDAG.cpp``:. Add code to `legalize, promote, and expand; <CodeGenerator.html#selectiondag_legalize>`_ the node as necessary. At a; minimum, you will need to add a case statement for your node in; ``LegalizeOp`` which calls LegalizeOp on the node's operands, and returns a; new node if any of the operands changed as a result of being legalized. It; is likely that not all targets supported by the SelectionDAG framework will; natively support the new node. In this case, you must also add code in your; node's case statement in ``LegalizeOp`` to Expand your node into simpler,; legal operations. The case for ``ISD::UREM`` for expanding a remainder into; a divide, multiply, and a subtract is a good example. #. ``lib/CodeGen/SelectionDAG/LegalizeDAG.cpp``:. If targets may support the new node being added only at certain sizes, you; will also need to add code to your node's case statement in ``LegalizeOp``; to Promote your node's operands to a larger size, and perform the correct; operation. You will also need to add code to ``PromoteOp`` to do this as; well. For a good example, see ``ISD::BSWAP``, which promotes its operand to; a wider size, performs the byteswap, and then shifts the correct bytes right; to emulate the narrower byteswap in the wider type. #. ``lib/CodeGen/SelectionDAG/LegalizeDAG.cpp``:. Add a case for your node in ``ExpandOp`` to teach the legalizer how to; perform the action represented by the new node on a value that has been split; into high and low halves. This case will be used to suppor",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ExtendingLLVM.rst:5092,simpl,simpler,5092,interpreter/llvm-project/llvm/docs/ExtendingLLVM.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ExtendingLLVM.rst,1,['simpl'],['simpler']
Usability,"elements (but could contain many), for example, it's much better to use; :ref:`SmallVector <dss_smallvector>` than :ref:`vector <dss_vector>`. Doing so; avoids (relatively) expensive malloc/free calls, which dwarf the cost of adding; the elements to the container. .. _ds_sequential:. Sequential Containers (std::vector, std::list, etc); ---------------------------------------------------. There are a variety of sequential containers available for you, based on your; needs. Pick the first in this section that will do what you want. .. _dss_arrayref:. llvm/ADT/ArrayRef.h; ^^^^^^^^^^^^^^^^^^^. The ``llvm::ArrayRef`` class is the preferred class to use in an interface that; accepts a sequential list of elements in memory and just reads from them. By; taking an ``ArrayRef``, the API can be passed a fixed size array, an; ``std::vector``, an ``llvm::SmallVector`` and anything else that is contiguous; in memory. .. _dss_fixedarrays:. Fixed Size Arrays; ^^^^^^^^^^^^^^^^^. Fixed size arrays are very simple and very fast. They are good if you know; exactly how many elements you have, or you have a (low) upper bound on how many; you have. .. _dss_heaparrays:. Heap Allocated Arrays; ^^^^^^^^^^^^^^^^^^^^^. Heap allocated arrays (``new[]`` + ``delete[]``) are also simple. They are good; if the number of elements is variable, if you know how many elements you will; need before the array is allocated, and if the array is usually large (if not,; consider a :ref:`SmallVector <dss_smallvector>`). The cost of a heap allocated; array is the cost of the new/delete (aka malloc/free). Also note that if you; are allocating an array of a type with a constructor, the constructor and; destructors will be run for every element in the array (re-sizable vectors only; construct those elements actually used). .. _dss_tinyptrvector:. llvm/ADT/TinyPtrVector.h; ^^^^^^^^^^^^^^^^^^^^^^^^. ``TinyPtrVector<Type>`` is a highly specialized collection class that is; optimized to avoid allocation in the case whe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:58138,simpl,simple,58138,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['simpl'],['simple']
Usability,"elistorder <ty> <value>, { <order-indexes> }; uselistorder_bb @function, %block { <order-indexes> }. :Examples:. ::. define void @foo(i32 %arg1, i32 %arg2) {; entry:; ; ... instructions ...; bb:; ; ... instructions ... ; At function scope.; uselistorder i32 %arg1, { 1, 0, 2 }; uselistorder label %bb, { 1, 0 }; }. ; At global scope.; uselistorder ptr @global, { 1, 2, 0 }; uselistorder i32 7, { 1, 0 }; uselistorder i32 (i32) @bar, { 1, 0 }; uselistorder_bb @foo, %bb, { 5, 1, 3, 2, 0, 4 }. .. _source_filename:. Source Filename; ---------------. The *source filename* string is set to the original module identifier,; which will be the name of the compiled source file when compiling from; source through the clang front end, for example. It is then preserved through; the IR and bitcode. This is currently necessary to generate a consistent unique global; identifier for local functions used in profile data, which prepends the; source file name to the local function name. The syntax for the source file name is simply:. .. code-block:: text. source_filename = ""/path/to/source.c"". .. _typesystem:. Type System; ===========. The LLVM type system is one of the most important features of the; intermediate representation. Being typed enables a number of; optimizations to be performed on the intermediate representation; directly, without having to do extra analyses on the side before the; transformation. A strong type system makes it easier to read the; generated code and enables novel analyses and transformations that are; not feasible to perform on normal three address code representations. .. _t_void:. Void Type; ---------. :Overview:. The void type does not represent any value and has no size. :Syntax:. ::. void. .. _t_function:. Function Type; -------------. :Overview:. The function type can be thought of as a function signature. It consists of a; return type and a list of formal parameter types. The return type of a function; type is a void type or first class type --- except f",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:165106,simpl,simply,165106,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['simpl'],['simply']
Usability,"elpful. In this approach, you can modify the source code of instcombine to; disable just those transformations that are being performed on your test input; and perform a binary search over the set of transformations. One set of places; to modify are the ""``visit*``"" methods of ``InstCombiner`` (*e.g.*; ``visitICmpInst``) by adding a ""``return false``"" as the first line of the; method. If that still doesn't remove enough, then change the caller of; ``InstCombiner::DoOneIteration``, ``InstCombiner::runOnFunction`` to limit the; number of iterations. You may also find it useful to use ""``-stats``"" now to see what parts of; instcombine are firing. This can guide where to put additional reporting code. At this point, if the amount of transformations is still too large, then; inserting code to limit whether or not to execute the body of the code in the; visit function can be helpful. Add a static counter which is incremented on; every invocation of the function. Then add code which simply returns false on; desired ranges. For example:. .. code-block:: c++. static int calledCount = 0;; calledCount++;; LLVM_DEBUG(if (calledCount < 212) return false);; LLVM_DEBUG(if (calledCount > 217) return false);; LLVM_DEBUG(if (calledCount == 213) return false);; LLVM_DEBUG(if (calledCount == 214) return false);; LLVM_DEBUG(if (calledCount == 215) return false);; LLVM_DEBUG(if (calledCount == 216) return false);; LLVM_DEBUG(dbgs() << ""visitXOR calledCount: "" << calledCount << ""\n"");; LLVM_DEBUG(dbgs() << ""I: ""; I->dump());. could be added to ``visitXOR`` to limit ``visitXor`` to being applied only to; calls 212 and 217. This is from an actual test case and raises an important; point---a simple binary search may not be sufficient, as transformations that; interact may require isolating more than one call. In TargetLowering, use; ``return SDNode();`` instead of ``return false;``. Now that the number of transformations is down to a manageable number, try; examining the output to see if you ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Bugpoint.rst:10014,simpl,simply,10014,interpreter/llvm-project/llvm/docs/Bugpoint.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Bugpoint.rst,1,['simpl'],['simply']
Usability,"els will end up at; different addresses though. It's perfectly legal to output something like this; to the .s file:. ::. foo:; bar:; .byte 4. In this case, both the foo and bar symbols will have the same address. The ``MCSection`` class; -----------------------. The ``MCSection`` class represents an object-file specific section. It is; subclassed by object file specific implementations (e.g. ``MCSectionMachO``,; ``MCSectionCOFF``, ``MCSectionELF``) and these are created and uniqued by; MCContext. The MCStreamer has a notion of the current section, which can be; changed with the SwitchToSection method (which corresponds to a "".section""; directive in a .s file). .. _MCInst:. The ``MCInst`` class; --------------------. The ``MCInst`` class is a target-independent representation of an instruction.; It is a simple class (much more so than `MachineInstr`_) that holds a; target-specific opcode and a vector of MCOperands. MCOperand, in turn, is a; simple discriminated union of three cases: 1) a simple immediate, 2) a target; register ID, 3) a symbolic expression (e.g. ""``Lfoo-Lbar+42``"") as an MCExpr. MCInst is the common currency used to represent machine instructions at the MC; layer. It is the type used by the instruction encoder, the instruction printer,; and the type generated by the assembly parser and disassembler. .. _ObjectFormats:. Object File Format; ------------------. The MC layer's object writers support a variety of object formats. Because of; target-specific aspects of object formats each target only supports a subset of; the formats supported by the MC layer. Most targets support emitting ELF; objects. Other vendor-specific objects are generally supported only on targets; that are supported by that vendor (i.e. MachO is only supported on targets; supported by Darwin, and XCOFF is only supported on targets that support AIX).; Additionally some targets have their own object formats (i.e. DirectX, SPIR-V; and WebAssembly). The table below captures a snapshot of",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:30733,simpl,simple,30733,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,2,['simpl'],['simple']
Usability,"eltoX(apx)` | Double\_t |; | user | | |; | | `AbsPixeltoY(apy)` | Double\_t |; | | | |; | | `AbsPixeltoXY(apx,apy,&ux,&uy)` | Double\_t ux,uy |; +-----------------------+----------------------------------+--------------------+. Note: all the pixel conversion functions along the Y axis consider that; `py=0` is at the top of the pad except `PixeltoY()` which assume that; the position `py=0` is at the bottom of the pad. To make `PixeltoY()`; converting the same way as the other conversion functions, it should be; used the following way (`p` is a pointer to a **`TPad`**):. ``` {.cpp}; p->PixeltoY(py - p->GetWh());; ```. ### Dividing a Pad into Sub-pads. Dividing a pad into sub pads in order for instance to draw a few; histograms, may be done in two ways. The first is to build pad objects; and to draw them into a parent pad, which may be a canvas. The second is; to automatically divide a pad into horizontal and vertical sub pads. #### Creating a Single Sub-pad. The simplest way to divide a pad is to build sub-pads in it. However,; this forces the user to explicitly indicate the size and position of; those sub-pads. Suppose we want to build a sub-pad in the active pad; (pointed by ***`gPad`***). First, we build it, using a **`TPad`**; constructor:. ``` {.cpp}; root[] spad1 = new TPad(""spad1"",""The first subpad"",.1,.1,.5,.5); ```. One gives the coordinates of the lower left point (0.1, 0.1) and of the; upper right one (0.5, 0.5). These coordinates are in NDC. This means; that they are independent of the user coordinates system, in particular; if you have already drawn for example a histogram in the mother pad. The; only thing left is to draw the pad:. ``` {.cpp}; root[] spad1->Draw(); ```. If you want more sub-pads, you have to repeat this procedure as many; times as necessary. #### Dividing a Canvas into Sub-Pads. The manual way of dividing a pad into sub-pads is sometimes very; tedious. There is a way to automatically generate horizontal and; vertical sub-pads inside a giv",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:24048,simpl,simplest,24048,documentation/users-guide/Graphics.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md,1,['simpl'],['simplest']
Usability,"ement is a compiler that supports; C++14, this in order to build LLVM. With CPython on Linux or MacOS, probably by far the easiest way to install; cppyy, is through conda-forge on `Anaconda`_ (or `miniconda`_).; A Windows recipe for ``conda`` is not available yet, but is forthcoming, so; use ``pip`` for that platform for now (see below).; PyPI always has the authoritative releases (conda-forge pulls the sources; from there), so conda-forge may sometimes lag PyPI.; If you absolutely need the latest release, use PyPI or consider; :ref:`building from source <building_from_source>`. To install using ``conda``, create and/or activate your (new) work environment; and install from the conda-forge channel::. $ conda create -n WORK; $ conda activate WORK; (WORK) $ conda install -c conda-forge cppyy; (WORK) [current compiler] $. To install with ``pip`` through `PyPI`_, use `venv`.; The use of virtual environment (`venv`) prevents pollution of any system directories and allows; you to wipe out the full installation simply by removing the virtual environment (`venv`); created directory (""WORK"" in this example)::. $ python -m venv WORK ; $ WORK\Scripts\activate; (WORK) $ python -m pip install cppyy; (WORK) $. .. note:: ; If you are using python version less than 3.3, you should use `virtualenv` instead of `venv`.; First install virtualenv package that allows you to create virtual environment. $ python -m pip install virtualenv . $ virtualenv WORK. $ source WORK/bin/activate. (WORK) $ python -m pip install cppyy. (WORK) $. If you use the ``--user`` option to ``pip`` and use ``pip`` directly on the; command line, instead of through ``python``, make sure that the ``PATH``; envar points to the bin directory that will contain the installed entry; points during the installation, as the build process needs them.; You may also need to install ``wheel`` first if you have an older version of; ``pip`` and/or do not use virtualenv (which installs wheel by default).; Example::. $ python -m pi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/installation.rst:1576,simpl,simply,1576,bindings/pyroot/cppyy/cppyy/doc/source/installation.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/installation.rst,1,['simpl'],['simply']
Usability,"emote node: it will effectively; decode the Base64 string back to the proxy file and write it into the; `/tmp` directory. Note also that the first `$UID` is not escaped and; will be substituted *locally* with your user ID *on your client; machine*, while the second one has the dollar escaped (`\$UID`) and will; be substituted *remotely* with your user ID *on the remote node*. > It is worth noting that the remote environment scripts will be sent to; > the remote node using a secure connection (SSH), thus there is no; > concern in placing sensitive user data there. Installing the Virtual Analysis Facility client; -----------------------------------------------. ### Download the client from Git. The Virtual Analysis Facility client is available on; [GitHub](https://github.com/dberzano/virtual-analysis-facility):. ``` {.bash}; git clone git://github.com/dberzano/virtual-analysis-facility.git /dest/dir; ```. The client will be found in `/dest/dir/client/bin/vaf-enter`: it is; convenient to add it to the `$PATH` so that the users might simply start; it by typing `vaf-enter`. ### Install the experiment's configuration files system-wide. A system administrator might find convenient to install the experiment; environment scripts system-wide. Configuration scripts for LHC experiments are shipped with the VAF; client and can be found in; `/dest/dir/client/config-samples/<experiment_name>`. To make them used; by default by the VAF client, place them in the `/dest/dir/etc`; directory like this:. ``` {.bash}; rsync -a /dest/dir/client/config-samples/<experiment_name>/ /dest/dir/etc/; ```. Remember that the trailing slash in the source directory name has a; meaning in `rsync` and must not be omitted. > Remember that system-wide configuration files will always have; > precedence over user's configuration files, so *don't place there; > files that are supposed to be provided by the user!*. Entering the Virtual Analysis Facility environment; -------------------------------------------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/UsingVirtualAnalysisFacility.md:7244,simpl,simply,7244,proof/doc/confman/UsingVirtualAnalysisFacility.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/UsingVirtualAnalysisFacility.md,1,['simpl'],['simply']
Usability,"en to have a pointer; to a `coroutine frame`_ or a pointer to a `coroutine promise`_. .. _coro.destroy:. 'llvm.coro.destroy' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.coro.destroy(ptr <handle>). Overview:; """""""""""""""""". The '``llvm.coro.destroy``' intrinsic destroys a suspended; switched-resume coroutine. Arguments:; """""""""""""""""""". The argument is a coroutine handle to a suspended coroutine. Semantics:; """""""""""""""""""". When possible, the `coro.destroy` intrinsic is replaced with a direct call to; the coroutine destroy function. Otherwise it is replaced with an indirect call; based on the function pointer for the destroy function stored in the coroutine; frame. Destroying a coroutine that is not suspended leads to undefined behavior. .. _coro.resume:. 'llvm.coro.resume' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ::. declare void @llvm.coro.resume(ptr <handle>). Overview:; """""""""""""""""". The '``llvm.coro.resume``' intrinsic resumes a suspended switched-resume coroutine. Arguments:; """""""""""""""""""". The argument is a handle to a suspended coroutine. Semantics:; """""""""""""""""""". When possible, the `coro.resume` intrinsic is replaced with a direct call to the; coroutine resume function. Otherwise it is replaced with an indirect call based; on the function pointer for the resume function stored in the coroutine frame.; Resuming a coroutine that is not suspended leads to undefined behavior. .. _coro.done:. 'llvm.coro.done' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ::. declare i1 @llvm.coro.done(ptr <handle>). Overview:; """""""""""""""""". The '``llvm.coro.done``' intrinsic checks whether a suspended; switched-resume coroutine is at the final suspend point or not. Arguments:; """""""""""""""""""". The argument is a handle to a suspended coroutine. Semantics:; """""""""""""""""""". Using this intrinsic on a coroutine that does not have a `final suspend`_ point; or on a coroutine that is not suspended leads to undefined behavior. .. _coro.promise:. 'llv",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:27886,resume,resume,27886,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,3,['resume'],"['resume', 'resumes']"
Usability,"en.i.i.i.i.i, label %_ZNSt12_Vector_baseIiSaIiEEC2EmRKS0_.exit.i.i. if.then.i.i.i.i.i: ; preds = %cond.true.i.i.i.i; call void @_ZSt17__throw_bad_allocv() noreturn nounwind; unreachable. _ZNSt12_Vector_baseIiSaIiEEC2EmRKS0_.exit.i.i: ; preds = %cond.true.i.i.i.i; %mul.i.i.i.i.i = shl i64 %conv, 2; %call3.i.i.i.i.i = call noalias i8* @_Znwm(i64 %mul.i.i.i.i.i) nounwind; %0 = bitcast i8* %call3.i.i.i.i.i to i32*; store i32* %0, i32** %v2.sub, align 8, !tbaa !0; store i32* %0, i32** %tmp3.i.i.i.i.i, align 8, !tbaa !0; %add.ptr.i.i.i = getelementptr inbounds i32* %0, i64 %conv; store i32* %add.ptr.i.i.i, i32** %tmp4.i.i.i.i.i, align 8, !tbaa !0; call void @llvm.memset.p0i8.i64(i8* %call3.i.i.i.i.i, i8 0, i64 %mul.i.i.i.i.i, i32 4, i1 false); br label %_ZNSt6vectorIiSaIiEEC1EmRKiRKS0_.exit. This is just the handling the construction of the vector. Most surprising here; is the fact that all three null stores in %entry are dead (because we do no; cross-block DSE). Also surprising is that %conv isn't simplified to 0 in %....exit.thread.i.i.; This is a because the client of LazyValueInfo doesn't simplify all instruction; operands, just selected ones. //===---------------------------------------------------------------------===//. clang -O3 -fno-exceptions currently compiles this code:. void f(char* a, int n) {; __builtin_memset(a, 0, n);; for (int i = 0; i < n; ++i); a[i] = 0;; }. into:. define void @_Z1fPci(i8* nocapture %a, i32 %n) nounwind {; entry:; %conv = sext i32 %n to i64; tail call void @llvm.memset.p0i8.i64(i8* %a, i8 0, i64 %conv, i32 1, i1 false); %cmp8 = icmp sgt i32 %n, 0; br i1 %cmp8, label %for.body.lr.ph, label %for.end. for.body.lr.ph: ; preds = %entry; %tmp10 = add i32 %n, -1; %tmp11 = zext i32 %tmp10 to i64; %tmp12 = add i64 %tmp11, 1; call void @llvm.memset.p0i8.i64(i8* %a, i8 0, i64 %tmp12, i32 1, i1 false); ret void. for.end: ; preds = %entry; ret void; }. This shouldn't need the ((zext (%n - 1)) + 1) game, and it should ideally fold; the two memset's ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt:58227,simpl,simplified,58227,interpreter/llvm-project/llvm/lib/Target/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt,1,['simpl'],['simplified']
Usability,"en/else. In this case the only thing left to do is to return to the; caller of the function. The question then becomes: how does the code; know which expression to return?. The answer to this question involves an important SSA operation: the; `Phi; operation <http://en.wikipedia.org/wiki/Static_single_assignment_form>`_.; If you're not familiar with SSA, `the wikipedia; article <http://en.wikipedia.org/wiki/Static_single_assignment_form>`_; is a good introduction and there are various other introductions to it; available on your favorite search engine. The short version is that; ""execution"" of the Phi operation requires ""remembering"" which block; control came from. The Phi operation takes on the value corresponding to; the input control block. In this case, if control comes in from the; ""then"" block, it gets the value of ""calltmp"". If control comes from the; ""else"" block, it gets the value of ""calltmp1"". At this point, you are probably starting to think ""Oh no! This means my; simple and elegant front-end will have to start generating SSA form in; order to use LLVM!"". Fortunately, this is not the case, and we strongly; advise *not* implementing an SSA construction algorithm in your; front-end unless there is an amazingly good reason to do so. In; practice, there are two sorts of values that float around in code; written for your average imperative programming language that might need; Phi nodes:. #. Code that involves user variables: ``x = 1; x = x + 1;``; #. Values that are implicit in the structure of your AST, such as the; Phi node in this case. In `Chapter 7 <LangImpl07.html>`_ of this tutorial (""mutable variables""),; we'll talk about #1 in depth. For now, just believe me that you don't; need SSA construction to handle this case. For #2, you have the choice; of using the techniques that we will describe for #1, or you can insert; Phi nodes directly, if convenient. In this case, it is really; easy to generate the Phi node, so we choose to do it directly. Okay, eno",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst:8051,simpl,simple,8051,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst,1,['simpl'],['simple']
Usability,"enGL (drawing options ""glbox"" and; ""glbox1"") a minus sign on negative bins is added in order to; distinguish them from positive bins.; ; In THistPainter::PaintH3 the palette is drawn in case of option; COLZ. This is useful when a TTree 4D plot is painted with that option.; ; This image has been prodiced with the command:; ntuple->Draw(""px:py:pz:px*px"","""",""COLZ"");. TGraph2D. The operator ""="" was not correct. TGraph. Protection added in PaintPolyLineHatches (division by zero in some; cases).; All the graphical code has been moved from the TGraph classes to; TGraphPainter. TGraphPolar. Protection added in case a GraphPolar is plotted with option; ""E"" but has no errors defined.; The markers clipping (in TGraphPainter) was wrong in case of TGraphPolar.; The constructor's parameters naming was wrong.; Documentation: better example (easier to understand).; In the constructors some data members were not initialized. TPie. Add the TPie::GetEntries() method that return the number slices.; (Guido Volpi).; Implement Editors for TPie and TPieSlice (Guido Volpi). TPaletteAxis. Attributes are now accessible in the context menu.; (requested by Mathieu de Naurois <denauroi@in2p3.fr>). TPolyLine. Implement the possibility to draw TPolyLine in NDC coordinates; (it was partially done but the code was not used). Documentation. Better comments in THelix.; Option ""FUNC"" was not documented in THistPainter..; Update the help for animated gif generation in TPad.; Update TAttMarker documentation about the non scalable markers.; Re-writting of the THistPainter documentation. TCutG. The graphical cuts applied on histograms did not work when the cut name; contained a mix of lower and upper case characters. This problem occured; because the option used to draw an histogram was always converted into; lower case before begin stored in a pad (in Draw and DrawCopy). Now in; Draw() and DrawCopy() the AppendPad() procedure is called with the option; string not converted in lower; case. QT; Version 3 of",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/doc/v520/index.html:5272,Guid,Guido,5272,graf2d/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/doc/v520/index.html,1,['Guid'],['Guido']
Usability,"ency of throw-expression specification; Unknown. 2700; review; #error disallows existing implementation practice; Not resolved. 2701; open; Default arguments in multiple scopes / inheritance of array bounds in the same scope; Not resolved. 2702; open; Constant destruction of reference members; Not resolved. 2703; review; Three-way comparison requiring strong ordering for floating-point types, take 2; Not resolved. 2704; open; Clarify meaning of ""bind directly""; Not resolved. 2705; open; Accessing ambiguous subobjects; Not resolved. 2706; open; Repeated structured binding declarations; Not resolved. 2707; tentatively ready; Deduction guides cannot have a trailing requires-clause; Unknown. 2708; DRWP; Parenthesized initialization of arrays; Unknown. 2709; NAD; Parenthesized initialization of reference-to-aggregate; Unknown. 2710; DRWP; Loops in constant expressions; Unknown. 2711; DRWP; Source for copy-initializing the exception object; Unknown. 2712; DRWP; Simplify restrictions on built-in assignment operator candidates; Unknown. 2713; DRWP; Initialization of reference-to-aggregate from designated initializer list; Unknown. 2714; open; Implicit deduction guides omit properties from the parameter-declaration-clause of a constructor; Not resolved. 2715; DRWP; ""calling function"" for parameter initialization may not exist; Unknown. 2716; DRWP; Rule about self-or-base conversion is normatively redundant; Unknown. 2717; DRWP; Pack expansion for alignment-specifier; Unknown. 2718; DRWP; Type completeness for derived-to-base conversions; Unknown. 2719; DRWP; Creating objects in misaligned storage; Unknown. 2720; DRWP; Template validity rules for templated entities and alias templates; Unknown. 2721; DRWP; When exactly is storage reused?; Unknown. 2722; DRWP; Temporary materialization conversion for noexcept operator; Unknown. 2723; DRWP; Range of representable values for floating-point types; Unknown. 2724; DRWP; Clarify rounding for arithmetic right shift; Unknown. 2725; DR;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:187346,Simpl,Simplify,187346,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['Simpl'],['Simplify']
Usability,"end; * PowerPC backend; * RISC-V backend; * Sparc backend; * SystemZ backend; * WebAssembly backend; * X86 backend; * XCore backend; * libLTO; * Debug Information; * Remainder of llvm; * compiler-rt; * libunwind; * openmp; * parallel-libs; * polly; * lldb. #. Remove the old variable name rule from the policy page. #. Repeat many of the steps in the sequence, using a script to expand acronyms. References; ==========. .. [LLDB] LLDB Coding Conventions https://llvm.org/svn/llvm-project/lldb/branches/release_39/www/lldb-coding-conventions.html; .. [Google] Google C++ Style Guide https://google.github.io/styleguide/cppguide.html#Variable_Names; .. [WebKit] WebKit Code Style Guidelines https://webkit.org/code-style-guidelines/#names; .. [Qt] Qt Coding Style https://wiki.qt.io/Qt_Coding_Style#Declaring_variables; .. [Rust] Rust naming conventions https://doc.rust-lang.org/1.0.0/style/style/naming/README.html; .. [Swift] Swift API Design Guidelines https://swift.org/documentation/api-design-guidelines/#general-conventions; .. [Python] Style Guide for Python Code https://www.python.org/dev/peps/pep-0008/#function-and-variable-names; .. [Mozilla] Mozilla Coding style: Prefixes https://firefox-source-docs.mozilla.org/tools/lint/coding-style/coding_style_cpp.html#prefixes; .. [SVE] LLVM with support for SVE https://github.com/ARM-software/LLVM-SVE; .. [AminiInconsistent] Mehdi Amini, http://lists.llvm.org/pipermail/llvm-dev/2019-February/130329.html; .. [ArsenaultAgree] Matt Arsenault, http://lists.llvm.org/pipermail/llvm-dev/2019-February/129934.html; .. [BeylsDistinguish] Kristof Beyls, http://lists.llvm.org/pipermail/llvm-dev/2019-February/130292.html; .. [BradburyConcern] Alex Bradbury, http://lists.llvm.org/pipermail/llvm-dev/2019-February/130266.html; .. [BradburyTransition] Alex Bradbury, http://lists.llvm.org/pipermail/llvm-dev/2019-February/130388.html; .. [CarruthAcronym] Chandler Carruth, http://lists.llvm.org/pipermail/llvm-dev/2019-February/130313.html; .. [CarruthC",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst:13881,guid,guidelines,13881,interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst,1,['guid'],['guidelines']
Usability,"ends for various; format / architecture combinations (as of July 2023). Support levels:. * None: No backend. JITLink will return an ""architecture not supported"" error.; Represented by empty cells in the table below.; * Skeleton: A backend exists, but does not support commonly used relocations.; Even simple programs are likely to trigger an ""unsupported relocation"" error.; Backends in this state may be easy to improve by implementing new relocations.; Consider getting involved!; * Basic: The backend supports simple programs, isn't ready for general use yet.; * Usable: The backend is useable for general use for at least one code and; relocation model.; * Good: The backend supports almost all relocations. Advanced features like; native thread local storage may not be available yet.; * Complete: The backend supports all relocations and object format features. .. list-table:: Availability and Status; :widths: 10 30 30 30; :header-rows: 1; :stub-columns: 1. * - Architecture; - ELF; - COFF; - MachO; * - arm32; - Skeleton; -; -; * - arm64; - Usable; -; - Good; * - LoongArch; - Good; -; -; * - PowerPC 64; - Usable; -; -; * - RISC-V; - Good; -; -; * - x86-32; - Basic; -; -; * - x86-64; - Good; - Usable; - Good. .. [1] See ``llvm/examples/OrcV2Examples/LLJITWithObjectLinkingLayerPlugin`` for; a full worked example. .. [2] If not for *hidden* scoped symbols we could eliminate the; ``JITLinkDylib*`` argument to ``JITLinkMemoryManager::allocate`` and; treat every object as a separate simulated dylib for the purposes of; memory layout. Hidden symbols break this by generating in-range accesses; to external symbols, requiring the access and symbol to be allocated; within range of one another. That said, providing a pre-reserved address; range pool for each simulated dylib guarantees that the relaxation; optimizations will kick in for all intra-dylib references, which is good; for performance (at the cost of whatever overhead is introduced by; reserving the address-range up-front).; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst:46418,Usab,Usable,46418,interpreter/llvm-project/llvm/docs/JITLink.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst,3,['Usab'],['Usable']
Usability,"enerate:; 	ldr	r2, .LCPI0_0; 	and	r0, r0, r2; 	ldr	r2, .LCPI0_1; 	and	r1, r1, r2; 	orr	r0, r1, r0; 	bx	lr. We should be able to replace the second ldr+and with a bic (i.e. reuse the; constant which was already loaded). Not sure what's necessary to do that. //===---------------------------------------------------------------------===//. The code generated for bswap on armv4/5 (CPUs without rev) is less than ideal:. int a(int x) { return __builtin_bswap32(x); }. a:; 	mov	r1, #255, 24; 	mov	r2, #255, 16; 	and	r1, r1, r0, lsr #8; 	and	r2, r2, r0, lsl #8; 	orr	r1, r1, r0, lsr #24; 	orr	r0, r2, r0, lsl #24; 	orr	r0, r0, r1; 	bx	lr. Something like the following would be better (fewer instructions/registers):; 	eor r1, r0, r0, ror #16; 	bic r1, r1, #0xff0000; 	mov r1, r1, lsr #8; 	eor r0, r1, r0, ror #8; 	bx	lr. A custom Thumb version would also be a slight improvement over the generic; version. //===---------------------------------------------------------------------===//. Consider the following simple C code:. void foo(unsigned char *a, unsigned char *b, int *c) {; if ((*a | *b) == 0) *c = 0;; }. currently llvm-gcc generates something like this (nice branchless code I'd say):. ldrb r0, [r0]; ldrb r1, [r1]; orr r0, r1, r0; tst r0, #255; moveq r0, #0; streq r0, [r2]; bx lr. Note that both ""tst"" and ""moveq"" are redundant. //===---------------------------------------------------------------------===//. When loading immediate constants with movt/movw, if there are multiple; constants needed with the same low 16 bits, and those values are not live at; the same time, it would be possible to use a single movw instruction, followed; by multiple movt instructions to rewrite the high bits to different values.; For example:. volatile store i32 -1, i32* inttoptr (i32 1342210076 to i32*), align 4,; !tbaa; !0; volatile store i32 -1, i32* inttoptr (i32 1342341148 to i32*), align 4,; !tbaa; !0. is compiled and optimized to:. movw r0, #32796; mov.w r1, #-1; movt r0, #20480; str r1, [r0]; m",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/README.txt:18993,simpl,simple,18993,interpreter/llvm-project/llvm/lib/Target/ARM/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/README.txt,1,['simpl'],['simple']
Usability,"enough to show all items. The; choices may be mutually exclusive (a list box with single selection) or; not mutually exclusive (a list box with multiple selection). ![](pictures/02000219.jpg). The proper usage of the list boxes is for selecting values, or objects,; or setting attributes. You have to create them to display 4 to 8 choices; at one time (3 is a required minimum in case of lack of screen space).; The list should contain not more than 40 items accessible by scrolling; view (vertical scroll bar). If more are required, you should provide a; method for using search criteria or scoping the options. The best list; boxes use is for textual data or choices. They should be wide enough to; display fully all items. When it is not possible, break the long items; with ellipsis and provide tool tip that displays the full item text. The list box widget is represented by **`TGListBox`**,; **`TGLBContainer`**, **`TGLBEntry`** and **`TGTextLBEntry`** classes.; Currently entries are simple text strings (**`TGTextLBEntry`**). A; **`TGListBox`** looks a lot like a **`TGCanvas`**. It has a; **`TGViewPort`** containing a **`TGLBContainer`** which contains the; entries and it also has a vertical scrollbar which becomes visible if; there are more items than fit in the visible part of the container. The; **`TGListBox`** is user callable. The other classes are service classes; of the list box. Here is a sample code showing how to create a list box; with ten entries:. ``` {.cpp}; // list box widget containing 10 entries; int fFirstEntry = 0, fLastEntry = 10;; char tmp[20];; TGListBox *fListBox = new TGListBox(parent, 90);; for (i = fFirstEntry; i < fLastEntry; i++) {; sprintf(tmp, ""Entry %i"", i+1);; fListBox->AddEntry(tmp, i);; }; fListBox->Resize(150, 80);; parent->AddFrame(fListBox,new TGLayoutHints(kLHintsTop|kLHintsLeft,; 5, 5, 5, 5));; ```. We create the list box widget passing the parent window pointer and; giving an ID number. Next we add entries with specified string and ID",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:79624,simpl,simple,79624,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,1,['simpl'],['simple']
Usability,"ent RWebWindow instances for connection. ## Montecarlo Libraries. ## PROOF Libraries. ## Language Bindings. ## JavaScript ROOT. ## Jupyter lab. - Let use created notebooks with viewers like https://nbviewer.jupyter.org/; - Fix problem with using of local JSROOT version. ## Tutorials. - The tutorial games.C was not working properly. - Improve tutorial ErrorIntegral.C. - Schrödinger's Hydrogen Atom example. - Tutorial demonstrating how the changing of the range can zoom into the histogram. - Tutorial demonstrating how a Histogram can be read from a ROOT File. - histMax.C: a tutorial demoing how the hist->GetMaximumBin() can be used. ## Class Reference Guide. - Images for ROOT7 tutorials can be generated, in json format, using the directive using; `\macro_image (json)` in the macro header. - Clarify THStack drawing options. - Add missing documentation to TH1 functions. - Restructure the math reference guide. - Make the web gui documentation visible in the reference guide. - Make clear THtml is legacy code. Add deprecated flag on PROOF and TGeoTrack. - Improve many classes documentation: TContext, TTreePlayer, THistPainter, TGraph, TSelector,; integrator, GUI, TH1, TH2, TH3, TColor classes ... - Make the TFile layout doc visible in Reference Guide. - Update the external links of the reference guide main page. - Reformat TMVA mathcore Unuran Roostats documentation . ## Build, Configuration and Testing Infrastructure. - For users building from source the `latest-stable` branch and passing `-Droottest=ON` to the CMake command line, the corresponding revision of roottest pointed to by `latest-stable` will be downloaded as required. ## PyROOT. - The `ROOT` Python module is now properly serializable so that it is automatically available in the Python environment if a function or ROOT object needs to be serialized. See issue [#6764](https://github.com/root-project/root/issues/6764) for a concrete usecase.; - Improve overload resolution of functions that accept classes with long",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md:38992,clear,clear,38992,README/ReleaseNotes/v626/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md,1,['clear'],['clear']
Usability,"ent pads. When a displayed histogram is deleted, its image is; automatically removed from the pad. To create a copy of the histogram; when drawing it, you can use **`TH1`**`::DrawClone()`. This will clone; the histogram and allow you to change and delete the original one; without affecting the clone. You can use **`TH1`**`::DrawNormalized()`; to draw a normalized copy of a histogram. ``` {.cpp}; TH1 *TH1::DrawNormalized(Option_t *option,Double_t norm) const; ```. A clone of this histogram is normalized to norm and drawn with option.; A pointer to the normalized histogram is returned. The contents of the; histogram copy are scaled such that the new sum of weights (excluding; under and overflow) is equal to `norm` . Note that the returned normalized histogram is not added to the list; of histograms in the current directory in memory. It is the user's; responsibility to delete this histogram. The `kCanDelete` bit is set; for the returned object. If a pad containing this copy is cleared, the; histogram will be automatically deleted. See ""Draw Options"" for the; list of options. ### Setting the Style. Histograms use the current style ***`gStyle`***, which is the global; object of class **`TStyle`**. To change the current style for; histograms, the **`TStyle`** class provides a multitude of methods; ranging from setting the fill color to the axis tick marks. Here are; a few examples:. ``` {.cpp}; void SetHistFillColor(Color_t color = 1); void SetHistFillStyle(Style_t styl = 0); void SetHistLineColor(Color_t color = 1); void SetHistLineStyle(Style_t styl = 0); void SetHistLineWidth(Width_t width = 1); ```. When you change the current style and would like to propagate the; change to a previously created histogram you can call; **`TH1`**`::UseCurrentStyle()`. You will need to call; `UseCurrentStyle()` on each histogram. When reading many histograms; from a file and you wish to update them to the current style, you can; use ***`gROOT`***`::ForceStyle` and all histograms read a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:15160,clear,cleared,15160,documentation/users-guide/Histograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md,1,['clear'],['cleared']
Usability,"ental.convergence.loop() [ ""convergencectrl""(token %outer) ]; ; (B); call void @convergent.operation() [ ""convergencectrl""(token %inner) ]; call void @convergent.operation() [ ""convergencectrl""(token %inner) ]; counter -= 2;; }; ; (C); if (counter > 0) {; %remainder = call token @llvm.experimental.convergence.loop() [ ""convergencectrl""(token %outer) ]; ; (D); call void @convergent.operation() [ ""convergencectrl""(token %remainder) ]; }; ; (E). First of all, note some interesting problems surrounding the loop intrinsic:. 1. It is *not* duplicated inside the unrolled loop. This is to comply with; the :ref:`convergence_static_rules`. 2. It is unclear whether the loop intrinsic ought to be duplicated in the; remainder, or whether the final ``@convergent.operation`` in D should just; refer to either ``%inner`` (which is possible in SSA form) or directly to; ``%outer``. The decision made here is arbitrary and doesn't change the; argument that follows. Ultimately, it simply doesn't matter because the; transform is incorrect either way. The threads now execute the following sequences of blocks:. .. code-block:: text. Thread 1: A B C D E; Thread 2: A B B C D E. Analogous to the argument above, they execute converged dynamic instances of the; ``%inner`` intrinsic and the ``@convergent.operation`` in the first iteration; of the unrolled loop, which corresponds to the first 2 iterations of the; original loop. However, they execute different static calls to ``@convergent.operation`` for; the 3rd iteration of the original loop. In thread 1, that iteration corresponds; to the call in the remainder, while in thread 2 it corresponds to the first; call to ``@convergent.operation`` in the unrolled loop. Therefore, they execute; non-converged dynamic instances, which means that the set of communicating threads; for the 3rd iteration of the original loop is different. This is why the; unrolling is incorrect. On the other hand, unrolling without ""tail"" is allowed. For example, assuming; th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergentOperations.rst:53224,simpl,simply,53224,interpreter/llvm-project/llvm/docs/ConvergentOperations.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergentOperations.rst,1,['simpl'],['simply']
Usability,"ently.; There are a number of ways to fix this bug, see what you can come up with! Here; is a testcase:. ::. extern foo(a); # ok, defines foo.; def foo(b) b; # Error: Unknown variable name. (decl using 'a' takes precedence). Driver Changes and Closing Thoughts; ===================================. For now, code generation to LLVM doesn't really get us much, except that; we can look at the pretty IR calls. The sample code inserts calls to; codegen into the ""``HandleDefinition``"", ""``HandleExtern``"" etc; functions, and then dumps out the LLVM IR. This gives a nice way to look; at the LLVM IR for simple functions. For example:. ::. ready> 4+5;; Read top-level expression:; define double @0() {; entry:; ret double 9.000000e+00; }. Note how the parser turns the top-level expression into anonymous; functions for us. This will be handy when we add `JIT; support <LangImpl04.html#adding-a-jit-compiler>`_ in the next chapter. Also note that the; code is very literally transcribed, no optimizations are being performed; except simple constant folding done by IRBuilder. We will `add; optimizations <LangImpl04.html#trivial-constant-folding>`_ explicitly in the next; chapter. ::. ready> def foo(a b) a*a + 2*a*b + b*b;; Read function definition:; define double @foo(double %a, double %b) {; entry:; %multmp = fmul double %a, %a; %multmp1 = fmul double 2.000000e+00, %a; %multmp2 = fmul double %multmp1, %b; %addtmp = fadd double %multmp, %multmp2; %multmp3 = fmul double %b, %b; %addtmp4 = fadd double %addtmp, %multmp3; ret double %addtmp4; }. This shows some simple arithmetic. Notice the striking similarity to the; LLVM builder calls that we use to create the instructions. ::. ready> def bar(a) foo(a, 4.0) + bar(31337);; Read function definition:; define double @bar(double %a) {; entry:; %calltmp = call double @foo(double %a, double 4.000000e+00); %calltmp1 = call double @bar(double 3.133700e+04); %addtmp = fadd double %calltmp, %calltmp1; ret double %addtmp; }. This shows some function",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst:18264,simpl,simple,18264,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst,1,['simpl'],['simple']
Usability,"entries in the Index (\< 0 indicates; failure). ## Branches. The organization of branches allows the designer to optimize the data; for the anticipated use. The class for a branch is called **`TBranch`**.; If two variables are independent, and the designer knows the variables; will not be used together, they should be placed on separate branches.; If, however, the variables are related, such as the coordinates of a; point, it is most efficient to create one branch with both coordinates; on it. A variable on a **`TBranch`** is called a leaf (yes -; **`TLeaf`**). Another point to keep in mind when designing trees is that; branches of the same **`TTree`** can be written to separate files. To; add a **`TBranch`** to a **`TTree`** we call the; method **`TTree::Branch()`**. Note that we DO NOT use the `TBranch`; constructor. The `TTree::Branch` method has several signatures. The branch type; differs by what is stored in it. A branch can hold an entire object, a; list of simple variables, contents of a folder, contents of a; **`TList`**, or an array of objects. Let's see some examples. To follow; along you will need the shared library `libEvent.so`. First, check if it; is in `$ROOTSYS/test`. If it is, copy it to your own area. If it is not; there, you have to build it by typing make in `$ROOTSYS/test`. ## Adding a Branch to Hold a List of Variables. As in the very first example (`cernstaff.root.root`); the data we want to save is a list of simple variables, such as integers; or floats. In this case, we use the following `TTree::Branch` signature:. ``` {.cpp}; tree->Branch(""Ev_Branch"",&event,; ""temp/F:ntrack/I:nseg:nvtex:flag/i"");; ```. The first parameter is the branch name. The second parameter is the address from which the first variable is to; be read. In the code above, ""event"" is a structure with one float and; three integers and one unsigned integer. You should not assume that the; compiler aligns the elements of a structure without gaps. To avoid; alignment problems,",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:18926,simpl,simple,18926,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['simpl'],['simple']
Usability,"ents --> BaggedSampleFraction. have been replaced by options that are now given in terms of the relative; size of the training sample rather than in absulut numbers of events. This; is in order to facilitate the parameter tuning on different sample sizes; (i.e when starting on a smaller data sample to tune the parameter in order; to speed up the training); Furthermore, this option here has been changed name. GradBaggingFraction --> BaggedSampleFraction. in an attempt to consolidate and avoid idential duplicate code; ; The option UseWeightedTrees has been removed and set to ""true"", as was default; anyway, as a measure of further consolidation. Removed the option NNodesMax --> This should be replaced by specifying MaxDepth; instead (limiting the maximum tree depth also limits the number of possible nodes!). b) Added a trial version of a new ""cost sensitive"" boosting algorithem according to; Wei Fan and Salvatore J. Stolfo, {\em AdaCost: misclassification cost-sensitive boosting}, Proceedings of the 16th International conference on machine learning (ICML 1999)}. With the currently; chosen DEFAULT settings (all costs equal and set to ""one""), it is equivalent to the ""real-AdaBoost"" (i.e. using the option !UseYesNoLeaf (which uses the leave node purity rather than a signal or background attribute in the leaf node of each individual tree). Unfortunatly, no reasonable performance has been achieved yet when choosing different cost parameters. c) BDT's with little tree depth (as favoured for good performance) do not *like* it if; there are very clean signal and background separation cuts available, which however ; have NOT been applied yet as preselection. Now there is a possibility to choose the option; ""DoPreselection"" that looks for suitable preselection cuts and applies them prior to ; the Decision Tree training. While that works fine, this clearly gives ""sharp"" peaks at +1 (-1); for the MVA output distribution and therefore the ""smoothing"" of this distribution used to; pr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/ReleaseNotes4.2.0.txt:2152,learn,learning,2152,documentation/tmva/UsersGuide/ReleaseNotes4.2.0.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/ReleaseNotes4.2.0.txt,1,['learn'],['learning']
Usability,"enumeration member (with a prefix, e.g. ``LS_Auto``), and as a value usable in; the configuration (without a prefix: ``Auto``). .. _BasedOnStyle:. **BasedOnStyle** (``String``) :ref:`¶ <BasedOnStyle>`; The style used for all options not specifically set in the configuration. This option is supported only in the :program:`clang-format` configuration; (both within ``-style='{...}'`` and the ``.clang-format`` file). Possible values:. * ``LLVM``; A style complying with the `LLVM coding standards; <https://llvm.org/docs/CodingStandards.html>`_; * ``Google``; A style complying with `Google's C++ style guide; <https://google.github.io/styleguide/cppguide.html>`_; * ``Chromium``; A style complying with `Chromium's style guide; <https://chromium.googlesource.com/chromium/src/+/refs/heads/main/styleguide/styleguide.md>`_; * ``Mozilla``; A style complying with `Mozilla's style guide; <https://firefox-source-docs.mozilla.org/code-quality/coding-style/index.html>`_; * ``WebKit``; A style complying with `WebKit's style guide; <https://www.webkit.org/coding/coding-style.html>`_; * ``Microsoft``; A style complying with `Microsoft's style guide; <https://docs.microsoft.com/en-us/visualstudio/ide/editorconfig-code-style-settings-reference>`_; * ``GNU``; A style complying with the `GNU coding standards; <https://www.gnu.org/prep/standards/standards.html>`_; * ``InheritParentConfig``; Not a real style, but allows to use the ``.clang-format`` file from the; parent directory (or its parent if there is none). If there is no parent; file found it falls back to the ``fallback`` style, and applies the changes; to that. With this option you can overwrite some parts of your main style for your; subdirectories. This is also possible through the command line, e.g.:; ``--style={BasedOnStyle: InheritParentConfig, ColumnLimit: 20}``. .. START_FORMAT_STYLE_OPTIONS. .. _AccessModifierOffset:. **AccessModifierOffset** (``Integer``) :versionbadge:`clang-format 3.3` :ref:`¶ <AccessModifierOffset>`; The ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:5950,guid,guide,5950,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['guid'],['guide']
Usability,"ep->Fill(destep);; }. // we do not close the file; we want to keep the generated histograms;; // we fill a 3-d scatter plot with the particle step coordinates; TCanvas *c1 = new TCanvas(""c1"",""c1"",600,800);; c1->SetFillColor(42);; c1->Divide(1,2);. c1->cd(1);; hdestep->SetFillColor(45);; hdestep->Fit(""gaus"");. c1->cd(2);; gPad->SetFillColor(37); // continued...; t2->SetMarkerColor(kRed);; t2->Draw(""vect[0]:vect[1]:vect[2]"");; if (gROOT->IsBatch()) return;. // invoke the x3d viewer; gPad->GetViewer3D(""x3d"");; }; ```. ## Example 3: Adding Friends to Trees. In this example, we will show how to extend a tree with a branch from; another tree with the Friends feature. ### Adding a Branch to an Existing Tree. You may want to add a branch to an existing tree. For example, if one; variable in the tree was computed with a certain algorithm, you may want; to try another algorithm and compare the results. One solution is to add; a new branch, fill it, and save the tree. The code below adds a simple; branch to an existing tree. Note that the `kOverwrite` option in the; `Write` method overwrites the existing tree. If it is not specified, two; copies of the tree headers are saved. ``` {.cpp}; void tree3AddBranch() {; TFile f(""tree3.root"",""update"");; Float_t new_v;; TTree *t3 = (TTree*)f->Get(""t3"");; TBranch *newBranch = t3-> Branch(""new_v"",&new_v,""new_v/F"");; //read the number of entries in the t3; Int_t nentries = (Int_t)t3->GetEntries();; for (Int_t i = 0; i < nentries; i++){; new_v= gRandom->Gaus(0,1);; newBranch->Fill();; }; t3->Write("""",TObject::kOverwrite); // save only the new version of; // the tree; }; ```. Adding a branch is often not possible because the tree is in a read-only; file and you do not have permission to save the modified tree with the; new branch. Even if you do have the permission, you risk loosing the; original tree with an unsuccessful attempt to save the modification.; Since trees are usually large, adding a branch could extend it over the; 2GB limit. In",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:51307,simpl,simple,51307,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['simpl'],['simple']
Usability,"eportee at LLVM events.; * Ending a talk/tutorial/etc at an LLVM event early. See immediate response; checklist for further clarification.; * Not publishing the video or slides of a talk.; * Not allowing a speaker to give (further) talks at LLVM events for a specified; amount of time or ever.; * Requiring that the reportee immediately leave an event and not return.; * Immediately ending any volunteer responsibilities and privileges the reportee; holds.; * An imposed suspension (e.g., asking someone to ""take a week off"" from mailing; lists, bug tracker, IRC, Discord, repositories, or other communication; forms). ; * A permanent or temporary ban from some or all LLVM Project spaces (online or; in person). Once a resolution is agreed upon, but before it is enacted, the committee will; contact the reporter and any other affected parties to explain the proposed; resolution. They will ask if this resolution is acceptable and must note; feedback for the record. However, the committee is not required to act on this; feedback. .. _Appeal Process:. Appeal Process; ===============. Any individual(s) determined to have violated the CoC have the right to appeal; a decision. An appeal can be made directly to the committee by sending an email; to conduct@llvm.org with subject line Code of Conduct Incident Appeal. The email should include documentation related to the incident to support the; appeal. The said documentation may include, but does not have to be limited to:. * Information from the reportee justifying reasoning for the appeal.; * Statements from other individuals involved in the incident to support the; appeal. Appeals can be requested up to 30 days after a resolution has been communicated; to the individual(s). The committee will aim to evaluate appeals within two weeks of receipt. In the event that appeal can not be evaluated within that time, the CoC committee will respond with an updated and projected timeline. . Conflicts of Interest; =====================. Committe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ResponseGuide.rst:8849,feedback,feedback,8849,interpreter/llvm-project/llvm/docs/ResponseGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ResponseGuide.rst,1,['feedback'],['feedback']
Usability,"epping through optimized programs. Secondly, optimization; can move variables in ways that are either optimized out, shared in memory; with other variables, or difficult to track. For the purposes of this; tutorial we're going to avoid optimization (as you'll see with one of the; next sets of patches). Ahead-of-Time Compilation Mode; ==============================. To highlight only the aspects of adding debug information to a source; language without needing to worry about the complexities of JIT debugging; we're going to make a few changes to Kaleidoscope to support compiling; the IR emitted by the front end into a simple standalone program that; you can execute, debug, and see results. First we make our anonymous function that contains our top level; statement be our ""main"":. .. code-block:: udiff. - auto Proto = std::make_unique<PrototypeAST>("""", std::vector<std::string>());; + auto Proto = std::make_unique<PrototypeAST>(""main"", std::vector<std::string>());. just with the simple change of giving it a name. Then we're going to remove the command line code wherever it exists:. .. code-block:: udiff. @@ -1129,7 +1129,6 @@ static void HandleTopLevelExpression() {; /// top ::= definition | external | expression | ';'; static void MainLoop() {; while (true) {; - fprintf(stderr, ""ready> "");; switch (CurTok) {; case tok_eof:; return;; @@ -1184,7 +1183,6 @@ int main() {; BinopPrecedence['*'] = 40; // highest. // Prime the first token.; - fprintf(stderr, ""ready> "");; getNextToken();. Lastly we're going to disable all of the optimization passes and the JIT so; that the only thing that happens after we're done parsing and generating; code is that the LLVM IR goes to standard error:. .. code-block:: udiff. @@ -1108,17 +1108,8 @@ static void HandleExtern() {; static void HandleTopLevelExpression() {; // Evaluate a top-level expression into an anonymous function.; if (auto FnAST = ParseTopLevelExpr()) {; - if (auto *FnIR = FnAST->codegen()) {; - // We're just doing this to make",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl09.rst:3112,simpl,simple,3112,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl09.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl09.rst,1,['simpl'],['simple']
Usability,"equested [here](https://sft.its.cern.ch/jira/browse/ROOT-9184); - New color palette ""cividis"" implemented by Sven Augustin.; This colormap aims to solve problems that people with color vision deficiency have; with the common colormaps. For more details see:; Nuñez J, Anderton C, and Renslow R. Optimizing colormaps with consideration; for color vision deficiency to enable accurate interpretation of scientific data.; See the article [here](https://arxiv.org/abs/1712.01662); - New graphics style ""ATLAS"" from M.Sutton.; - In `TGraphPainter` the fit parameters were painted too early. [In some cases graph's; error bars overlapped the stat box](https://root-forum.cern.ch/t/hide-error-bars-behind-tpavestats/27996).; - Implement the possibility to generate high definition bitmap pictures in `TImageDump`.; This done via `gStyle->SetImageScaling(x);` `x` being a multiplication factor.; This new feature is now used to generate the reference guide with `x=3`.; Pictures in the reference guide are now much shaper and in particular the text. ## 3D Graphics Libraries; - When a LEGO plot was drawn with Theta=90, the X and Y axis were misplaced. ## Geometry Libraries. ## Database Libraries; - Fix issue related to time stamps manipulation done by `TPgSQLStatement` as suggested [here](https://root-forum.cern.ch/t/please-correct-bug-reading-date-time-from-postgresql-tpgsqlstatement). ## Networking Libraries; - New THttpWSHandler class should be used to work with websockets. It includes all necessary methods to handle multiple connections correctly. See in tutorials/http/ws.C how it can be used.; - Interface of THttpWSEngine class was changed, all its instances handled internally in THttpWSHandler. ## GUI Libraries. ## Montecarlo Libraries. ## Parallelism; - `TTree::GetEntry`: if IMT is enabled, run work in tasks if we have at least more than one top level branch.; - Make EnableImplicitMT no-op if IMT is already on; - Decompress `TTreeCache` in parallel if IMT is on (upgrade of the `TTreeC",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v614/index.md:13978,guid,guide,13978,README/ReleaseNotes/v614/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v614/index.md,1,['guid'],['guide']
Usability,"er 3 is corrupt. Size is 10 when it should be 20. This is a bad message, since it does not provide useful information and uses the; wrong style:. .. code-block:: none. error: file.o: Corrupt section header. As with other coding standards, individual projects, such as the Clang Static; Analyzer, may have preexisting styles that do not conform to this. If a; different formatting scheme is used consistently throughout the project, use; that style instead. Otherwise, this standard applies to all LLVM tools,; including clang, clang-tidy, and so on. If the tool or project does not have existing functions to emit warnings or; errors, use the error and warning handlers provided in ``Support/WithColor.h``; to ensure they are printed in the appropriate style, rather than printing to; stderr directly. When using ``report_fatal_error``, follow the same standards for the message as; regular error messages. Assertion messages and ``llvm_unreachable`` calls do not; necessarily need to follow these same styles as they are automatically; formatted, and thus these guidelines may not be suitable. ``#include`` Style; ^^^^^^^^^^^^^^^^^^. Immediately after the `header file comment`_ (and include guards if working on a; header file), the `minimal list of #includes`_ required by the file should be; listed. We prefer these ``#include``\s to be listed in this order:. .. _Main Module Header:; .. _Local/Private Headers:. #. Main Module Header; #. Local/Private Headers; #. LLVM project/subproject headers (``clang/...``, ``lldb/...``, ``llvm/...``, etc); #. System ``#include``\s. and each category should be sorted lexicographically by the full path. The `Main Module Header`_ file applies to ``.cpp`` files which implement an; interface defined by a ``.h`` file. This ``#include`` should always be included; **first** regardless of where it lives on the file system. By including a; header file first in the ``.cpp`` files that implement the interfaces, we ensure; that the header does not have any hid",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst:15689,guid,guidelines,15689,interpreter/llvm-project/llvm/docs/CodingStandards.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst,1,['guid'],['guidelines']
Usability,"er HTML element position (#121); 2. Fix - prevent I/O failure when server automatically gzip response (#119); 3. Fix - lego drawing for stacked TH1 histograms; 4. Fix - when change global tooltips settings, also change for each sub-pad. ## Changes in 5.0.2; 1. Fix - read branch entries as arrays; 2. Fix - command submission to THttpServer; 3. Fix - let refill statbox also for empty histogram; 4. Fix - problem with online TTree::Draw and ROOT6. ## Changes in 5.0.1; 1. Support older ROOT files, created before 2010; 2. Support TBranchObject - appears in old files; 3. Correctly set TBasket buffer position for the entry; 4. Fix - problem with empty STL containers; 5. Fix - empty baskets at the end of branch store; 6. Fix - problem with zooming in THStack. ## Changes in 5.0.0; 1. Reading TTree data; - all kinds of branches, including split STL containers; - branches with several elementary leaves; - branches from different ROOT files; - JSROOT.TSelector class to access TTree data; - simple access to branch data with ""dump"" draw option; 2. TTree::Draw support; - simple 1D/2D/3D histograms; - simple cut conditions; - configurable histogram like ""px:py>>hist(50,-5,5,50,-5,5)""; - strings support; - iterate over arrays indexes, let use another branch as index values; - support ""Entry$"" and ""Entries$"" variables in expressions; - bits histogram like ""event.fTracks.fBits>>bits(16)""; - special handling of TBits; - arbitrary math function from JavaScript Math class, some TMath:: function from ROOT; - if branch is object, one could use methods ""TMath::Abs(lep1_p4.X()+lep1_p4.Y())""; - interactive player to configure and execute draw expression; 3. Full support of Float16_t and Double32_t types in I/O; 4. Drawing of RooPlot objects, I/O support for RooFit classes; 5. Many improvements in object inspector; - support of large lists; only first part is shown; - support of large arrays; values group in decades; - allow to call draw function for sub-elements in inspector; 6. Canvas or sele",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/changes.md:46867,simpl,simple,46867,js/changes.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/changes.md,1,['simpl'],['simple']
Usability,"er SimpleStreamChecker. This checker needs to; take action at the following times:. Before making a call to a function, check if the function is fclose.; If so, check the parameter being passed.; After making a function call, check if the function is fopen. If; so, process the return value.; When values go out of scope, check whether they are still-open file; descriptors, and report a bug if so. In addition, remove any information about; them from the program state in order to keep the state as small as possible.; When file pointers ""escape"" (are used in a way that the analyzer can no longer; track them), mark them as such. This prevents false positives in the cases where; the analyzer cannot be sure whether the file was closed or not. These events that will be used for each of these actions are, respectively, PreCall,; PostCall,; DeadSymbols,; and PointerEscape.; The high-level structure of the checker's class is thus:. class SimpleStreamChecker : public Checker<check::PreCall,; check::PostCall,; check::DeadSymbols,; check::PointerEscape> {; public:. void checkPreCall(const CallEvent &Call, CheckerContext &C) const;. void checkPostCall(const CallEvent &Call, CheckerContext &C) const;. void checkDeadSymbols(SymbolReaper &SR, CheckerContext &C) const;. ProgramStateRef checkPointerEscape(ProgramStateRef State,; const InvalidatedSymbols &Escaped,; const CallEvent *Call,; PointerEscapeKind Kind) const;; };. Custom Program States; Checkers often need to keep track of information specific to the checks they; perform. However, since checkers have no guarantee about the order in which the; program will be explored, or even that all possible paths will be explored, this; state information cannot be kept within individual checkers. Therefore, if; checkers need to store custom information, they need to add new categories of; data to the ProgramState. The preferred way to do so is to use one of; several macros designed for this purpose. They are:. REGISTER_TRAIT_WITH_PROGRAMSTAT",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/checker_dev_manual.html:11535,Simpl,SimpleStreamChecker,11535,interpreter/llvm-project/clang/www/analyzer/checker_dev_manual.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/checker_dev_manual.html,1,['Simpl'],['SimpleStreamChecker']
Usability,"er ``--precompile``; or ``-fmodule-output`` flags. The ``--precompile`` option generates the BMI as the output of the compilation and the output path; can be specified using the ``-o`` option. The ``-fmodule-output`` option generates the BMI as a by-product of the compilation.; If ``-fmodule-output=`` is specified, the BMI will be emitted the specified location. Then if; ``-fmodule-output`` and ``-c`` are specified, the BMI will be emitted in the directory of the; output file with the name of the input file with the new extension ``.pcm``. Otherwise, the BMI; will be emitted in the working directory with the name of the input file with the new extension; ``.pcm``. The style to generate BMIs by ``--precompile`` is called two-phase compilation since it takes; 2 steps to compile a source file to an object file. The style to generate BMIs by ``-fmodule-output``; is called one-phase compilation respectively. The one-phase compilation model is simpler; for build systems to implement and the two-phase compilation has the potential to compile faster due; to higher parallelism. As an example, if there are two module units A and B, and B depends on A, the; one-phase compilation model would need to compile them serially, whereas the two-phase compilation; model may be able to compile them simultaneously if the compilation from A.pcm to A.o takes a long; time. File name requirement; ~~~~~~~~~~~~~~~~~~~~~. The file name of an ``importable module unit`` should end with ``.cppm``; (or ``.ccm``, ``.cxxm``, ``.c++m``). The file name of a ``module implementation unit``; should end with ``.cpp`` (or ``.cc``, ``.cxx``, ``.c++``). The file name of BMIs should end with ``.pcm``.; The file name of the BMI of a ``primary module interface unit`` should be ``module_name.pcm``.; The file name of BMIs of ``module partition unit`` should be ``module_name-partition_name.pcm``. If the file names use different extensions, Clang may fail to build the module.; For example, if the filename of an ``imp",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:7849,simpl,simpler,7849,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,1,['simpl'],['simpler']
Usability,"er `eps` is defined as `max(epsRel * x, epsAbs)`. The values of the relative and absolute epsilons were inconsistent among the overloads:. * [RooAbsRealLValue::inRange(const char* rangeName)](https://root.cern.ch/doc/v626/classRooAbsRealLValue.html#ab6050a0c3e5583b9d755a38fd7fb82f7): `epsRel = 1e-8, epsAbs = 0`; * [RooAbsRealLValue::inRange(double value, const char* rangeName, double* clippedValPtr)](https://root.cern.ch/doc/v626/classRooAbsRealLValue.html#afc2a8818f433a9a4ec0c437cbdad4e8a): `epsRel = 0, epsAbs = 1e-6`; * [RooAbsRealLValue::inRange(std::span<const double> values, std::string const& rangeName, std::vector<bool>& out)](https://root.cern.ch/doc/v626/classRooAbsRealLValue.html#af9217abd0afe34364562ad0c194f5d2c): `epsRel = 0, epsAbs = 1e-6`. With this release, the default absolute and relative epsilon is zero to avoid confusion.; You can change them with `RooNumber::setRangeEpsRel(epsRel)` and `RooNumber::setRangeEpsAbs(epsAbs)`. ## TMVA. ### SOFIE : Code generation for fast inference of Deep Learning models. A large number of new features have been added in the TMVA SOFIE library. The list of all operators supported in the `RModel` class is the one provided below for the ONNX parser. The interface of `RModel::Generate` has been changed to; ```; RModel::Generate(Options options = Options::kDefault, int batchsize = 1)`; ```; where `Options` is a new enumeration having 3 different values:; - `kDefault = 0x0` : default case, a session class is generated and the weights are stored in a separate `.dat` file (in text format).; - `kNoSession = 0x1` : no session class is generated and the internal intermediate tensors are declared in the global namespace `TMVA_SOFIE_$ModelName`.; - `kNoWeightFile = 0x2` the weight values are not written in a separate `.dat` file, but they are included in the generated header file. In addition, the `RModel::Generate` function takes as an additional optional argument the batch size (default is = 1) and the inference code can then ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md:26308,Learn,Learning,26308,README/ReleaseNotes/v628/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md,1,['Learn'],['Learning']
Usability,"er around the ``ExtractLoop()`` scalar transformation to extract; each top-level loop into its own new function. If the loop is the *only* loop; in a given function, it is not touched. This is a pass most useful for; debugging via bugpoint. ``loop-reduce``: Loop Strength Reduction; ----------------------------------------. This pass performs a strength reduction on array references inside loops that; have as one or more of their components the loop induction variable. This is; accomplished by creating a new value to hold the initial value of the array; access for the first iteration, and then creating a new GEP instruction in the; loop to increment the value by the appropriate amount. .. _passes-loop-rotate:. ``loop-rotate``: Rotate Loops; -----------------------------. A simple loop rotation transformation. A summary of it can be found in; :ref:`Loop Terminology for Rotated Loops <loop-terminology-loop-rotate>`. .. _passes-loop-simplify:. ``loop-simplify``: Canonicalize natural loops; ---------------------------------------------. This pass performs several transformations to transform natural loops into a; simpler form, which makes subsequent analyses and transformations simpler and; more effective. A summary of it can be found in; :ref:`Loop Terminology, Loop Simplify Form <loop-terminology-loop-simplify>`. Loop pre-header insertion guarantees that there is a single, non-critical entry; edge from outside of the loop to the loop header. This simplifies a number of; analyses and transformations, such as :ref:`LICM <passes-licm>`. Loop exit-block insertion guarantees that all exit blocks from the loop (blocks; which are outside of the loop that have predecessors inside of the loop) only; have predecessors from inside of the loop (and are thus dominated by the loop; header). This simplifies transformations such as store-sinking that are built; into LICM. This pass also guarantees that loops will have exactly one backedge. Note that the :ref:`simplifycfg <passes-simpl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst:26607,simpl,simplify,26607,interpreter/llvm-project/llvm/docs/Passes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst,1,['simpl'],['simplify']
Usability,"er bound for the second parameter. ``` {.cpp}; fitter.SetFunction( fitFunction, false);; fitter.Config().ParSettings(0).SetLimits(0,1.E6);; fitter.Config().ParSettings(2).SetLowerLimit(0);; ```. Note that a `ROOT::Fit::ParameterSettings` objects exists for each fit parameter and it created by the `ROOT::Fit::FitConfig` class, after the model function has been set in the Fitter.; Only when the function is set, the number of parameter is known and; automatically the `FitConfig` creates the corresponding `ParameterSetting` objects. When fitting, different minimizer can be used. The can be implemented in different libraries and loaded ar run time by the plug-in manager system of ROOT.; Each different minimizer (e.g. *Minuit, Minuit2, Fumili,* etc.) consists of a different implementation of the `ROOT::Math::Minimizer` interface.; Within the same minimizer, thus within the same class implementing the `Minimizer` interface, different algorithms can exist.; For example in the case of Minuit, we have *Migrad, Simplex* or *Minimize*. The minimizer and its corresponding algorithm, when available,; can be set by using the function `FitConfig::SetMinimizer(""minimizerName"")` or by using directly the `ROOT:Math::MinimizerOptions` class. If the requested minimizer is not available in ROOT, the default one is used. The default minimizer type and algorithm can be specified by using the; static function `ROOT::Math::MinimizerOptions::SetDefaultMinimizer(""minimizerName"")`. ### Minimizer Libraries and Algorithms. The list of available minimizer libraries currently available in ROOT, with their corresponding available algorithms is the following one.; Some minimizers (e.g. *Minuit*) contain several algorithms that the user can; choose. Others are based on a single algorithm (e.g. *Fumili*). - **`Minuit`** (library *libMinuit*). Old version of Minuit, based on the `TMinuit` class. The list of possible algorithms are:; - *`Migrad`* (default one); 	 - *`Simplex`*; - *`Minimize`* (it is a com",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:40200,Simpl,Simplex,40200,documentation/users-guide/FittingHistograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md,1,['Simpl'],['Simplex']
Usability,"er function; ROOT::Math::Functor1D f3(&myf1,&MyFunction1D::Eval);. cout << f1(2) << endl;; cout << f2(2) << endl;; cout << f3(2) << endl;. return 0;; }; ```. #### Wrapping One Dimensional Gradient Functions. The `ROOT::Math::GradFunctor1D` class is used to wrap one-dimensional gradient functions. It can be constructed in three different ways:; * Any object implementing both `double operator()( double)` for the function evaluation and `double Derivative(double)` for the function derivative.; * Any object implementing any member function like `Foo::XXX(double )` for the function evaluation and any other member function like `Foo::YYY(double )` for the derivative.; * Any two function objects implementing `double operator()( double )` . One object provides the function evaluation, the other the derivative. One or both function object can be a free C function of; type `double ()(double )`. #### Wrapping Multi-dimensional Functions. The class `ROOT::Math::Functor` is used to wrap in a very simple and convenient way multi-dimensional function objects. It can wrap all the following types:; * Any C++ callable object implementing `double operator()( const double * )`.; * A free C function of type `double ()(const double * )`.; * A member function with the correct signature like `Foo::Eval(const double * )`. In this case one pass the object pointer and a pointer to the member function `(&Foo::Eval)`. The function dimension is required when constructing the functor. Example of using `Functor`:; ```{.cpp}; #include ""Math/Functor.h"". class MyFunction {. public:; double operator()(const double *x) const {; return x[0]+x[1];; }. double Eval(const double * x) const { return x[0]+x[1]; }; };. double freeFunction(const double * x ); {; return x[0]+x[1];; }. int main(); {; // test directly calling the function object; MyFunction myf;. // test from a free function pointer; ROOT::Math::Functor f1(&freeFunction,2);. // test from function object; ROOT::Math::Functor f2(myf,2);. // test fro",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:44873,simpl,simple,44873,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['simpl'],['simple']
Usability,"er is involved in a report, the member will be asked to recuse themselves; from ongoing conversations, and they will not have access to reports after the; enforcement decision has been made. . In the event of a temporary suspension or ban, the appropriate people must be; notified of the ban in order to restrict access to infrastructure or events.; These individuals will only be notified of the person's name and the; restrictions imposed. They will be under a confidentiality clause and not; allowed to respond to questions regarding the ban and should direct all; questions to the CoC committee. . .. _Transparency Reports:. Transparency Reports; ====================. Lack of transparency in the outcomes of our Code of Conduct incidents leaves; our community without an understanding of how or if the organizers worked to; resolve incidents. The CoC committee should aim to publish transparency; reports, if reports are received, after major events (such as the LLVM; Developers' meetings) and on the following dates: Jan 15, April 15, July 15,; Oct 15. . A transparency report consists of 2 parts:. * An overview of the reports received, and resolutions.; * A more detailed summary of each reported incident and the resolution while; maintaining confidentiality. These reports will be published on the LLVM website. Thanks!; =======. This guide was created and inspired by the following: the `Django Project`_,; `Carpentries Response Guide`_, and the `Write The Docs Response Guide`_. License; =======. All content on this page is licensed under a `Creative Commons Attribution 3.0; Unported License`_. .. _Django Project: https://www.djangoproject.com/conduct/; .. _Carpentries Response Guide: https://docs.carpentries.org/topic_folders/policies/enforcement-guidelines.html; .. _Write The Docs Response Guide: https://www.writethedocs.org/code-of-conduct/#guidelines-for-reporting-incidents; .. _Creative Commons Attribution 3.0 Unported License: http://creativecommons.org/licenses/by/3.0/. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ResponseGuide.rst:12701,guid,guide,12701,interpreter/llvm-project/llvm/docs/ResponseGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ResponseGuide.rst,7,"['Guid', 'guid']","['Guide', 'guide', 'guidelines', 'guidelines-for-reporting-incidents']"
Usability,"er time. This lets us cover a range of language design and LLVM-specific; ideas, showing and explaining the code for it all along the way,; and reduces the overwhelming amount of details up front. We strongly; encourage that you *work with this code* - make a copy and hack it up and; experiment. **Warning**: In order to focus on teaching compiler techniques and LLVM; specifically,; this tutorial does *not* show best practices in software engineering; principles. For example, the code uses global variables; pervasively, doesn't use; `visitors <http://en.wikipedia.org/wiki/Visitor_pattern>`_, etc... but; instead keeps things simple and focuses on the topics at hand. This tutorial is structured into chapters covering individual topics,; allowing you to skip ahead as you wish:. - `Chapter #1: Kaleidoscope language and Lexer <LangImpl01.html>`_ -; This shows where we are; going and the basic functionality that we want to build. A lexer; is also the first part of building a parser for a language, and we; use a simple C++ lexer which is easy to understand.; - `Chapter #2: Implementing a Parser and AST <LangImpl02.html>`_ -; With the lexer in place, we can talk about parsing techniques and; basic AST construction. This tutorial describes recursive descent; parsing and operator precedence parsing.; - `Chapter #3: Code generation to LLVM IR <LangImpl03.html>`_ - with; the AST ready, we show how easy it is to generate LLVM IR, and show; a simple way to incorporate LLVM into your project.; - `Chapter #4: Adding JIT and Optimizer Support <LangImpl04.html>`_ -; One great thing about LLVM is its support for JIT compilation, so; we'll dive right into it and show you the 3 lines it takes to add JIT; support. Later chapters show how to generate .o files.; - `Chapter #5: Extending the Language: Control Flow <LangImpl05.html>`_ - With; the basic language up and running, we show how to extend; it with control flow operations ('if' statement and a 'for' loop). This; gives us a chance to t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/index.rst:1846,simpl,simple,1846,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/index.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/index.rst,1,['simpl'],['simple']
Usability,"er') to break the input up into ""tokens"". Each token returned by; the lexer includes a token code and potentially some metadata (e.g. the; numeric value of a number). First, we define the possibilities:. .. code-block:: c++. // The lexer returns tokens [0-255] if it is an unknown character, otherwise one; // of these for known things.; enum Token {; tok_eof = -1,. // commands; tok_def = -2,; tok_extern = -3,. // primary; tok_identifier = -4,; tok_number = -5,; };. static std::string IdentifierStr; // Filled in if tok_identifier; static double NumVal; // Filled in if tok_number. Each token returned by our lexer will either be one of the Token enum; values or it will be an 'unknown' character like '+', which is returned; as its ASCII value. If the current token is an identifier, the; ``IdentifierStr`` global variable holds the name of the identifier. If; the current token is a numeric literal (like 1.0), ``NumVal`` holds its; value. We use global variables for simplicity, but this is not the; best choice for a real language implementation :). The actual implementation of the lexer is a single function named; ``gettok``. The ``gettok`` function is called to return the next token; from standard input. Its definition starts as:. .. code-block:: c++. /// gettok - Return the next token from standard input.; static int gettok() {; static int LastChar = ' ';. // Skip any whitespace.; while (isspace(LastChar)); LastChar = getchar();. ``gettok`` works by calling the C ``getchar()`` function to read; characters one at a time from standard input. It eats them as it; recognizes them and stores the last character read, but not processed,; in LastChar. The first thing that it has to do is ignore whitespace; between tokens. This is accomplished with the loop above. The next thing ``gettok`` needs to do is recognize identifiers and; specific keywords like ""def"". Kaleidoscope does this with this simple; loop:. .. code-block:: c++. if (isalpha(LastChar)) { // identifier: [a-zA-Z][a-zA-",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl01.rst:3163,simpl,simplicity,3163,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl01.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl01.rst,1,['simpl'],['simplicity']
Usability,"er, when using ``/Zc:dllexportInlines-``, the inline; definition of `S::foo()` is used directly, resulting in a link error since; `internal()` is not available. Even worse, if there is an inline definition of; `internal()` containing a static local variable, we will now refer to a; different instance of that variable than in the DLL:. .. code-block:: c. inline int internal() { static int x; return x++; }. struct __declspec(dllimport) S {; int foo() { return internal(); }; }. This could lead to very subtle bugs. Using ``-fvisibility-inlines-hidden`` can; lead to the same issue. To avoid it in this case, make `S::foo()` or; `internal()` non-inline, or mark them `dllimport/dllexport` explicitly. Finding Clang runtime libraries; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. clang-cl supports several features that require runtime library support:. - Address Sanitizer (ASan): ``-fsanitize=address``; - Undefined Behavior Sanitizer (UBSan): ``-fsanitize=undefined``; - Code coverage: ``-fprofile-instr-generate -fcoverage-mapping``; - Profile Guided Optimization (PGO): ``-fprofile-generate``; - Certain math operations (int128 division) require the builtins library. In order to use these features, the user must link the right runtime libraries; into their program. These libraries are distributed alongside Clang in the; library resource directory. Clang searches for the resource directory by; searching relative to the Clang executable. For example, if LLVM is installed; in ``C:\Program Files\LLVM``, then the profile runtime library will be located; at the path; ``C:\Program Files\LLVM\lib\clang\11.0.0\lib\windows\clang_rt.profile-x86_64.lib``. For UBSan, PGO, and coverage, Clang will emit object files that auto-link the; appropriate runtime library, but the user generally needs to help the linker; (whether it is ``lld-link.exe`` or MSVC ``link.exe``) find the library resource; directory. Using the example installation above, this would mean passing; ``/LIBPATH:C:\Program Files\LLVM\lib\clang",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:190570,Guid,Guided,190570,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['Guid'],['Guided']
Usability,"er/Checkers folder. The steps below describe; how the checker SimpleStreamChecker, which checks for misuses of; stream APIs, was registered with the analyzer.; Similar steps should be followed for a new checker. A new checker implementation file, SimpleStreamChecker.cpp, was; created in the directory lib/StaticAnalyzer/Checkers.; The following registration code was added to the implementation file:. void ento::registerSimpleStreamChecker(CheckerManager &mgr) {; mgr.registerChecker<SimpleStreamChecker>();; }. A package was selected for the checker and the checker was defined in the; table of checkers at include/clang/StaticAnalyzer/Checkers/Checkers.td.; Since all checkers should first be developed as ""alpha"", and the SimpleStreamChecker; performs UNIX API checks, the correct package is ""alpha.unix"", and the following; was added to the corresponding UnixAlpha section of Checkers.td:. let ParentPackage = UnixAlpha in {; ...; def SimpleStreamChecker : Checker<""SimpleStream"">,; HelpText<""Check for misuses of stream APIs"">,; DescFile<""SimpleStreamChecker.cpp"">;; ...; } // end ""alpha.unix"". The source code file was made visible to CMake by adding it to; lib/StaticAnalyzer/Checkers/CMakeLists.txt. After adding a new checker to the analyzer, one can verify that the new checker; was successfully added by seeing if it appears in the list of available checkers:; $clang -cc1 -analyzer-checker-help; Events, Callbacks, and Checker Class Structure; All checkers inherit from the ; Checker template class; the template parameter(s) describe the type of; events that the checker is interested in processing. The various types of events; that are available are described in the file ; CheckerDocumentation.cpp; For each event type requested, a corresponding callback function must be; defined in the checker class (; CheckerDocumentation.cpp shows the; correct function name and signature for each event type). As an example, consider SimpleStreamChecker. This checker needs to; take action at t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/checker_dev_manual.html:9597,Simpl,SimpleStreamChecker,9597,interpreter/llvm-project/clang/www/analyzer/checker_dev_manual.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/checker_dev_manual.html,3,['Simpl'],"['SimpleStream', 'SimpleStreamChecker']"
Usability,"er:. Stream Header; =============; At offset 0 of the DBI Stream is a header with the following layout:. .. code-block:: c++. struct DbiStreamHeader {; int32_t VersionSignature;; uint32_t VersionHeader;; uint32_t Age;; uint16_t GlobalStreamIndex;; uint16_t BuildNumber;; uint16_t PublicStreamIndex;; uint16_t PdbDllVersion;; uint16_t SymRecordStream;; uint16_t PdbDllRbld;; int32_t ModInfoSize;; int32_t SectionContributionSize;; int32_t SectionMapSize;; int32_t SourceInfoSize;; int32_t TypeServerMapSize;; uint32_t MFCTypeServerIndex;; int32_t OptionalDbgHeaderSize;; int32_t ECSubstreamSize;; uint16_t Flags;; uint16_t Machine;; uint32_t Padding;; };. - **VersionSignature** - Unknown meaning. Appears to always be ``-1``. - **VersionHeader** - A value from the following enum. .. code-block:: c++. enum class DbiStreamVersion : uint32_t {; VC41 = 930803,; V50 = 19960307,; V60 = 19970606,; V70 = 19990903,; V110 = 20091201; };. Similar to the :doc:`PDB Stream <PdbStream>`, this value always appears to be; ``V70``, and it is not clear what the other values are for. - **Age** - The number of times the PDB has been written. Equal to the same; field from the :ref:`PDB Stream header <pdb_stream_header>`. - **GlobalStreamIndex** - The index of the :doc:`Global Symbol Stream <GlobalStream>`,; which contains CodeView symbol records for all global symbols. Actual records; are stored in the symbol record stream, and are referenced from this stream. - **BuildNumber** - A bitfield containing values representing the major and minor; version number of the toolchain (e.g. 12.0 for MSVC 2013) used to build the; program, with the following layout:. .. code-block:: c++. uint16_t MinorVersion : 8;; uint16_t MajorVersion : 7;; uint16_t NewVersionFormat : 1;. For the purposes of LLVM, we assume ``NewVersionFormat`` to be always ``true``.; If it is ``false``, the layout above does not apply and the reader should consult; the `Microsoft Source Code <https://github.com/Microsoft/microsoft-pdb>`__ for",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PDB/DbiStream.rst:1810,clear,clear,1810,interpreter/llvm-project/llvm/docs/PDB/DbiStream.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PDB/DbiStream.rst,1,['clear'],['clear']
Usability,"er_context;; }. .. code-block:: llvm. %resume_func_ptr = call ptr @llvm.coro.async.resume(); call {ptr, ptr, ptr} (ptr, ptr, ...) @llvm.coro.suspend.async(; ptr %resume_func_ptr,; ptr %context_projection_function. The frontend should provide a `async function pointer` struct associated with; each async coroutine by `llvm.coro.id.async`'s argument. The initial size and; alignment of the `async context` must be provided as arguments to the; `llvm.coro.id.async` intrinsic. Lowering will update the size entry with the; coroutine frame requirements. The frontend is responsible for allocating the; memory for the `async context` but can use the `async function pointer` struct; to obtain the required size. .. code-block:: c. struct async_function_pointer {; uint32_t relative_function_pointer_to_async_impl;; uint32_t context_size;; }. Lowering will split an async coroutine into a ramp function and one resume; function per suspend point. How control-flow is passed between caller, suspension point, and back to; resume function is left up to the frontend. The suspend point takes a function and its arguments. The function is intended; to model the transfer to the callee function. It will be tail called by; lowering and therefore must have the same signature and calling convention as; the async coroutine. .. code-block:: llvm. call {ptr, ptr, ptr} (ptr, ptr, ...) @llvm.coro.suspend.async(; ptr %resume_func_ptr,; ptr %context_projection_function,; ptr %suspend_function,; ptr %arg1, ptr %arg2, i8 %arg3). Coroutines by Example; =====================. The examples below are all of switched-resume coroutines. Coroutine Representation; ------------------------. Let's look at an example of an LLVM coroutine with the behavior sketched; by the following pseudo-code. .. code-block:: c++. void *f(int n) {; for(;;) {; print(n++);; <suspend> // returns a coroutine handle on first suspend; }; }. This coroutine calls some function `print` with value `n` as an argument and; suspends execution. E",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:10177,resume,resume,10177,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"eral, hoisting and sinking of convergent operations is forbidden. This is; because moving the operation to a different point in control flow generally; changes the set of threads that reach the operation and therefore, the set of; threads that execute converged dynamic instances of the operation. By; definition, this changes the set of threads that participate in the; communication of the convergent operation, which will typically change its; result. There are a number of exceptions, though most of them require additional; knowledge. For example, hoisting and sinking across *uniform* conditional branches -- i.e.,; conditional branches where within every possible relevant set of threads, all; threads will always take the same direction -- is generally allowed. See the end; of the :ref:`example of reductions inside control flow; <convergence_example_reductions>` for a brief discussion. Some convergent operations can be hoisted but not sunk, or vice versa. A simple; example is the ``subgroupShuffle(data, id)`` operation. It returns the ``data``; operand of the thread identified by ``id``, where thread IDs are fixed and; assigned to each thread at launch. The result is undefined (or perhaps there is; UB, depending on the language and environment) if thread ``id`` is not in the; communicating set of threads. So hoisting is allowed in the following; pseudo-code example:. .. code-block:: llvm. define void @example(...) convergent {; %entry = call token @llvm.experimental.convergence.entry(); %data = ...; %id = ...; if (condition) {; %shuffled = call i32 @subgroupShuffle(i32 %data, i32 %id) [ ""convergencectrl""(token %entry) ]; ...; } else {; %shuffled = call i32 @subgroupShuffle(i32 %data, i32 %id) [ ""convergencectrl""(token %entry) ]; ...; }; }. After hoisting the calls to ``@subgroupShuffle``, the communicating set of; threads is the union of the two sets of threads in the original program, so; ``%id`` can only go ""out of range"" after hoisting if it did so in the original;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergentOperations.rst:56051,simpl,simple,56051,interpreter/llvm-project/llvm/docs/ConvergentOperations.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergentOperations.rst,1,['simpl'],['simple']
Usability,"erface. Home; Download; News; Docs. Documentation. Developer. Doxygen; Extensions; Error Recovery; Late Binding. End User. User Manual; Status of ObjC[++] Support. Get Involved. Latest News; Cling goes public; July 25th, 2011; Cling was officially announced to the Clang community Read more. New website launched; July 1st, 2011; Welcome to the new website of the project. Read more; Useful Links. CERN. Extensions. Cling has several additional features. The main reason for their implementation is to improve the interactivity of the prompt. We call them language extensions.; ; For instance, language extensions are:; Execution of statements and expressions on the fly - From user's point of view it would make much sense if functions could be called by typing the function name at the prompt. This is true for other handy operations like creation of objects. However, the operations that do it are classified as statements and expressions, entered on the global scope. Statements and expressions on the global scope are not allowed by the C/C++/ObjC/ObjC++ grammar. Cling's prompt allows entering statements and expression on the global scope as transforming them into proper language constructs. ; Easy print out of the execution results - The way of signaling that the user wants to see the result of the entered and executed code is done by omitting the semicolon in the end. The standard doesn't allow statements (except those that change the control flow - such as if, for, while) without semicolon (;) in the end. However, this appears to be really simple and useful language extension that improves the user-cling interplay. Imagine if you had to write printf every time that you want to see the result of a function call. . See Also:; ; Statements and expression on the global scope in details; Easy printing of execution results in details. Copyright © Cling Team; . The ROOT Framework |; LLVM |; Clang |; Web Design. Page was modified on $Date$ in $Rev: 41615 $ by $Author: vvassilev $. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/docs/internal/extensions.html:1633,simpl,simple,1633,interpreter/cling/www/docs/internal/extensions.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/docs/internal/extensions.html,1,['simpl'],['simple']
Usability,"erface. Implementing a loop pass is usually straightforward.; ``LoopPass``\ es may override three virtual methods to do their work. All; these methods should return ``true`` if they modified the program, or ``false``; if they didn't. A ``LoopPass`` subclass which is intended to run as part of the main loop pass; pipeline needs to preserve all of the same *function* analyses that the other; loop passes in its pipeline require. To make that easier,; a ``getLoopAnalysisUsage`` function is provided by ``LoopUtils.h``. It can be; called within the subclass's ``getAnalysisUsage`` override to get consistent; and correct behavior. Analogously, ``INITIALIZE_PASS_DEPENDENCY(LoopPass)``; will initialize this set of function analyses. The ``doInitialization(Loop *, LPPassManager &)`` method; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. .. code-block:: c++. virtual bool doInitialization(Loop *, LPPassManager &LPM);. The ``doInitialization`` method is designed to do simple initialization type of; stuff that does not depend on the functions being processed. The; ``doInitialization`` method call is not scheduled to overlap with any other; pass executions (thus it should be very fast). ``LPPassManager`` interface; should be used to access ``Function`` or ``Module`` level analysis information. .. _writing-an-llvm-pass-runOnLoop:. The ``runOnLoop`` method; ^^^^^^^^^^^^^^^^^^^^^^^^. .. code-block:: c++. virtual bool runOnLoop(Loop *, LPPassManager &LPM) = 0;. The ``runOnLoop`` method must be implemented by your subclass to do the; transformation or analysis work of your pass. As usual, a ``true`` value; should be returned if the function is modified. ``LPPassManager`` interface; should be used to update loop nest. The ``doFinalization()`` method; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. .. code-block:: c++. virtual bool doFinalization();. The ``doFinalization`` method is an infrequently used method that is called; when the pass framework has finished calling :ref:`runOnLoop; <writ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst:21558,simpl,simple,21558,interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,1,['simpl'],['simple']
Usability,"ering, a coroutine is assumed to take the current `async context` as; one of its arguments (the argument position is determined by; `llvm.coro.id.async`). It is used to marshal arguments and return values of the; coroutine. Therefore an async coroutine returns `void`. .. code-block:: llvm. define swiftcc void @async_coroutine(ptr %async.ctxt, ptr, ptr) {; }. Values live across a suspend point need to be stored in the coroutine frame to; be available in the continuation function. This frame is stored as a tail to the; `async context`. Every suspend point takes an `context projection function` argument which; describes how-to obtain the continuations `async context` and every suspend; point has an associated `resume function` denoted by the; `llvm.coro.async.resume` intrinsic. The coroutine is resumed by calling this; `resume function` passing the `async context` as the one of its arguments; argument. The `resume function` can restore its (the caller's) `async context`; by applying a `context projection function` that is provided by the frontend as; a parameter to the `llvm.coro.suspend.async` intrinsic. .. code-block:: c. // For example:; struct async_context {; struct async_context *caller_context;; ...; }. char *context_projection_function(struct async_context *callee_ctxt) {; return callee_ctxt->caller_context;; }. .. code-block:: llvm. %resume_func_ptr = call ptr @llvm.coro.async.resume(); call {ptr, ptr, ptr} (ptr, ptr, ...) @llvm.coro.suspend.async(; ptr %resume_func_ptr,; ptr %context_projection_function. The frontend should provide a `async function pointer` struct associated with; each async coroutine by `llvm.coro.id.async`'s argument. The initial size and; alignment of the `async context` must be provided as arguments to the; `llvm.coro.id.async` intrinsic. Lowering will update the size entry with the; coroutine frame requirements. The frontend is responsible for allocating the; memory for the `async context` but can use the `async function pointer` struct;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:8756,resume,resume,8756,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"ernel. This notebook is running `llvm-tblgen`. ```tablegen; %reset; // This is some tablegen; class Foo {}; ```. ------------- Classes -----------------; class Foo {; }; ------------- Defs -----------------. Errors printed to stderr are shown. ```tablegen; %reset; This is not tablegen.; ```. <stdin>:1:1: error: Unexpected token at top level; This is not tablegen.; ^. Add some classes to get some output. ```tablegen; %reset; class Stuff {}; def thing : Stuff {}; ```. ------------- Classes -----------------; class Stuff {; }; ------------- Defs -----------------; def thing {	// Stuff; }. By default cells are connected. Meaning that we cache the code and magic directives from the previously run cells. This means that the next cell still sees the `Stuff` class. ```tablegen; def other_thing : Stuff {}; ```. ------------- Classes -----------------; class Stuff {; }; ------------- Defs -----------------; def other_thing {	// Stuff; }; def thing {	// Stuff; }. You can use the magic `%reset` to clear this cache and start fresh. ```tablegen; %reset; def other_thing : Stuff {}; ```. <stdin>:1:19: error: Couldn't find class 'Stuff'; def other_thing : Stuff {}; ^. You can also configure the default reset behaviour using the `%config` magic. ```tablegen; %config cellreset on; class Thing {}; ```. ------------- Classes -----------------; class Thing {; }; ------------- Defs -----------------. ```tablegen; // The cache is reset here so this is an error.; def AThing: Thing {}; ```. <stdin>:2:13: error: Couldn't find class 'Thing'; def AThing: Thing {}; ^. The default value is `off`, meaning cells are connected. If you want to override the default for one cell only, use the `%reset` or `%noreset` magic. These always override the default. ```tablegen; class Thing {}; ```. ------------- Classes -----------------; class Thing {; }; ------------- Defs -----------------. ```tablegen; %noreset; // This works because of the noreset above.; def AThing: Thing {}; ```. ------------- Classes --",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/jupyter/LLVM_TableGen.md:1018,clear,clear,1018,interpreter/llvm-project/llvm/utils/TableGen/jupyter/LLVM_TableGen.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/jupyter/LLVM_TableGen.md,1,['clear'],['clear']
Usability,"ers whose; type is a qualified-``id`` (e.g., ``id<Foo>``). This mangling allows such; parameters to be differentiated from those with the regular unqualified ``id``; type. This was a non-backward compatible mangling change to the ABI. This change; allows proper overloading, and also prevents mangling conflicts with template; parameters of protocol-qualified type. Query the presence of this new mangling with; ``__has_feature(objc_protocol_qualifier_mangling)``. Initializer lists for complex numbers in C; ==========================================. clang supports an extension which allows the following in C:. .. code-block:: c++. #include <math.h>; #include <complex.h>; complex float x = { 1.0f, INFINITY }; // Init to (1, Inf). This construct is useful because there is no way to separately initialize the; real and imaginary parts of a complex variable in standard C, given that clang; does not support ``_Imaginary``. (Clang also supports the ``__real__`` and; ``__imag__`` extensions from gcc, which help in some cases, but are not usable; in static initializers.). Note that this extension does not allow eliding the braces; the meaning of the; following two lines is different:. .. code-block:: c++. complex float x[] = { { 1.0f, 1.0f } }; // [0] = (1, 1); complex float x[] = { 1.0f, 1.0f }; // [0] = (1, 0), [1] = (1, 0). This extension also works in C++ mode, as far as that goes, but does not apply; to the C++ ``std::complex``. (In C++11, list initialization allows the same; syntax to be used with ``std::complex`` with the same meaning.). For GCC compatibility, ``__builtin_complex(re, im)`` can also be used to; construct a complex number from the given real and imaginary components. OpenCL Features; ===============. Clang supports internal OpenCL extensions documented below. ``__cl_clang_bitfields``; --------------------------------. With this extension it is possible to enable bitfields in structs; or unions using the OpenCL extension pragma mechanism detailed in; `the Op",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:84784,usab,usable,84784,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['usab'],['usable']
Usability,"ersion 5.16 and version 5.18 in addition to these notes. Bindings - packages related to the interplay with other programming languages (Python, Ruby); Cint - the C++ interpreter; Core - the basic ROOT functionality; Geometry - building, representing and drawing geometrical objects; 2D Graphics - ROOT's two dimensional graphics interface; 3D Graphics - ROOT's three dimensional graphics interface; Graphical User Interface - from basic GUI elements to ROOT's own, complete dialogs; Histograming - counting values, spectra, and drawing them; HTML - the documentation generator; Input/Ouput - storing and reading data; Mathemathics - everything one can use to calculate: minimizers, matrixes, FFT, and much more; Miscellaneous - things that didn't make it into the other groups: table ; Monte Carlo - monte carlo and physics simulation interfaces; Networking - network-related parts, e.g. protocols and authentication interfaces; PROOF - parallel ROOT facility; RooFit - a fitting library; SQL - database interfaces; TMVA - multivariate analysis tools; Trees - ROOT's unique container class and related utilities. Binaries for all supported platforms are available at:. http://root.cern.ch/root/Version520.html; Versions for AFS have also been updated. See the list of supported; platforms:; http://root.cern.ch/Welcome.html. For more information, see:. http://root.cern.ch; The following people have contributed to this new version:; Ilka Antcheva,; Jean-Fran�ois Bastien, ; Bertrand Bellenot,; Rene Brun,; Philippe Canal,; Olivier Couet,; Valeri Fine,; Leo Franco, ; Gerri Ganis,; Andrei Gheata,; Mihaela Gheata,; David Gonzalez Maline, ; Andreas Hoecker, ; Jan Iwaszkiewicz, ; Lukasz Janyst, ; Anna Kreshuk, ; Wim Lavrijsen,; Sergei Linev,; Anar Manafov, ; Diego Marcos-Segura, ; Lorenzo Moneta,; Axel Naumann,; Mathieu de Naurois, ; Eddy Offermann, ; Valeriy Onuchin,; Timur Pocheptsov,; Fons Rademakers,; Paul Russo, ; Alja Tadel, ; Matevz Tadel, ; Wouter Verkerke, ; Guido Volpi, ; Hady Zalek . ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/doc/v520/index.html:2182,Guid,Guido,2182,doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/doc/v520/index.html,1,['Guid'],['Guido']
Usability,"erwise, the DWARF expression is ill-formed. *Many compilers store a single variable in sets of registers or store a; variable partially in memory and partially in registers.* ``DW_OP_piece``; *provides a way of describing where a part of a variable is located.*. *If a non-0 byte displacement is required, the* ``DW_OP_LLVM_offset``; *operation can be used to update the location description before using it as; the part location description of a* ``DW_OP_piece`` *operation.*. *The evaluation rules for the* ``DW_OP_piece`` *operation allow it to be; compatible with the DWARF Version 5 definition.*. .. note::. Since these extensions allow location descriptions to be entries on the; stack, a simpler operation to create composite location descriptions could; be defined. For example, just one operation that specifies how many parts,; and pops pairs of stack entries for the part size and location; description. Not only would this be a simpler operation and avoid the; complexities of incomplete composite location descriptions, but it may; also have a smaller encoding in practice. However, the desire for; compatibility with DWARF Version 5 is likely a stronger consideration. 2. ``DW_OP_bit_piece``. ``DW_OP_bit_piece`` has two operands. The first is an unsigned LEB128; integer that represents the part bit size S. The second is an unsigned; LEB128 integer that represents a bit displacement B. The action is the same as for ``DW_OP_piece``, except that any part created; has the bit size S, and the location description PL of any created part is; updated as if the ``DW_OP_constu B; DW_OP_LLVM_bit_offset`` operations were; applied. ``DW_OP_bit_piece`` *is used instead of* ``DW_OP_piece`` *when the piece to; be assembled is not byte-sized or is not at the start of the part location; description.*. *If a computed bit displacement is required, the* ``DW_OP_LLVM_bit_offset``; *operation can be used to update the location description before using it as; the part location description of a*",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:136192,simpl,simpler,136192,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['simpl'],['simpler']
Usability,"es A, va, fa; class A {};; class B; // Doesn't match, as it has no body.; int va;; extern int vb; // Doesn't match, as it doesn't define the variable.; void fa() {}; void fb(); // Doesn't match, as it has no body.; @interface X; - (void)ma; // Doesn't match, interface is declaration.; @end; @implementation X; - (void)ma {}; @end. Usable as: Matcher<TagDecl>, Matcher<VarDecl>, Matcher<FunctionDecl>,; Matcher<ObjCMethodDecl>. Matcher<FunctionDecl>isDeleted; Matches deleted function declarations. Given:; void Func();; void DeletedFunc() = delete;; functionDecl(isDeleted()); matches the declaration of DeletedFunc, but not Func. Matcher<FunctionDecl>isExplicitTemplateSpecialization; Matches explicit template specializations of function, class, or; static member variable template instantiations. Given; template<typename T> void A(T t) { }; template<> void A(int N) { }; functionDecl(isExplicitTemplateSpecialization()); matches the specialization A<int>(). Usable as: Matcher<FunctionDecl>, Matcher<VarDecl>, Matcher<CXXRecordDecl>. Matcher<FunctionDecl>isExternC; Matches extern ""C"" function or variable declarations. Given:; extern ""C"" void f() {}; extern ""C"" { void g() {} }; void h() {}; extern ""C"" int x = 1;; extern ""C"" int y = 2;; int z = 3;; functionDecl(isExternC()); matches the declaration of f and g, but not the declaration of h.; varDecl(isExternC()); matches the declaration of x and y, but not the declaration of z. Matcher<FunctionDecl>isInline; Matches functions, variables and namespace declarations that are marked with; the inline keyword. Given; inline void f();; void g();; namespace n {; inline namespace m {}; }; inline int Foo = 5;; functionDecl(isInline()) will match ::f().; namespaceDecl(isInline()) will match n::m.; varDecl(isInline()) will match Foo;. Matcher<FunctionDecl>isMain; Determines whether the function is ""main"", which is the entry point; into an executable program. Matcher<FunctionDecl>isNoReturn; Matches FunctionDecls that have a noreturn attribut",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:92539,Usab,Usable,92539,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['Usab'],['Usable']
Usability,"es also need to be; checked if they are invalidated:. .. code-block:: c++. bool FooAnalysisResult::invalidate(Function &F, const PreservedAnalyses &PA,; FunctionAnalysisManager::Invalidator &Inv) {; auto PAC = PA.getChecker<FooAnalysis>();; if (!PAC.preserved() && !PAC.preservedSet<AllAnalysesOn<Function>>()); return true;. // Check transitive dependencies.; return Inv.invalidate<BarAnalysis>(F, PA) ||; Inv.invalidate<BazAnalysis>(F, PA);; }. Combining invalidation and analysis manager proxies results in some; complexity. For example, when we invalidate all analyses in a module pass,; we have to make sure that we also invalidate function analyses accessible via; any existing inner proxies. The inner proxy's ``invalidate()`` first checks; if the proxy itself should be invalidated. If so, that means the proxy may; contain pointers to IR that is no longer valid, meaning that the inner proxy; needs to completely clear all relevant analysis results. Otherwise the proxy; simply forwards the invalidation to the inner analysis manager. Generally for outer proxies, analysis results from the outer analysis manager; should be immutable, so invalidation shouldn't be a concern. However, it is; possible for some inner analysis to depend on some outer analysis, and when; the outer analysis is invalidated, we need to make sure that dependent inner; analyses are also invalidated. This actually happens with alias analysis; results. Alias analysis is a function-level analysis, but there are; module-level implementations of specific types of alias analysis. Currently; ``GlobalsAA`` is the only module-level alias analysis and it generally is not; invalidated so this is not so much of a concern. See; ``OuterAnalysisManagerProxy::Result::registerOuterAnalysisInvalidation()``; for more details. Invoking ``opt``; ================. .. code-block:: shell. $ opt -passes='pass1,pass2' /tmp/a.ll -S; # -p is an alias for -passes; $ opt -p pass1,pass2 /tmp/a.ll -S. The new PM typically requires exp",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NewPassManager.rst:17495,simpl,simply,17495,interpreter/llvm-project/llvm/docs/NewPassManager.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NewPassManager.rst,1,['simpl'],['simply']
Usability,"es can be identified using the AST call VarDecl::isNRVOVariable.; . Handle constructors of lambda captures; Variables which are captured by value into a lambda require a call to; a copy constructor.; This call is not currently modeled.; . Handle constructors for default arguments; Default arguments in C++ are recomputed at every call,; and are therefore local, and not static, variables.; See tests cases in handle_constructors_for_default_arguments.cpp.; . Default arguments are annoying because the initializer expression is; evaluated at the call site but doesn't syntactically belong to the; caller's AST; instead it belongs to the ParmVarDecl for the default; parameter. This can lead to situations when the same expression has to; carry different values simultaneously -; when multiple instances of the same function are evaluated as part of the; same full-expression without specifying the default arguments.; Even simply calling the function twice (not necessarily within the; same full-expression) may lead to program points agglutinating because; it's the same expression. There are some nasty test cases already; in temporaries.cpp (struct DefaultParam and so on). I recommend adding a; new LocationContext kind specifically to deal with this problem. It'll; also help you figure out the construction context when you evaluate the; construct-expression (though you might still need to do some additional; CFG work to get construction contexts right).; . Enhance the modeling of the standard library.; The analyzer needs a better understanding of STL in order to be more; useful on C++ codebases.; While full library modeling is not an easy task,; large gains can be achieved by supporting only a few cases:; e.g. calling .length() on an empty; std::string always yields zero.; (Difficulty: Medium). Enhance CFG to model exception-handling.; Currently exceptions are treated as ""black holes"", and exception-handling; control structures are poorly modeled in order to be conservative.; This",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/open_projects.html:5108,simpl,simply,5108,interpreter/llvm-project/clang/www/analyzer/open_projects.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/open_projects.html,1,['simpl'],['simply']
Usability,"es flags are present |; | | - PDB contains an :doc:`IPI Stream <TpiStream>` |; +------------------+-------------------------------------------------+; | VC140 | - Other feature flags may be present |; | | - PDB contains an :doc:`IPI Stream <TpiStream>` |; +------------------+-------------------------------------------------+; | NoTypeMerge | - Presumably duplicate types can appear in the |; | | TPI Stream, although it's unclear why this |; | | might happen. |; +------------------+-------------------------------------------------+; | MinimalDebugInfo | - Program was linked with /DEBUG:FASTLINK |; | | - There is no TPI / IPI stream, all type info |; | | is contained in the original object files. |; +------------------+-------------------------------------------------+. Matching a PDB to its executable; ================================; The linker is responsible for writing both the PDB and the final executable, and; as a result is the only entity capable of writing the information necessary to; match the PDB to the executable. In order to accomplish this, the linker generates a guid for the PDB (or; re-uses the existing guid if it is linking incrementally) and increments the Age; field. The executable is a PE/COFF file, and part of a PE/COFF file is the presence of; number of ""directories"". For our purposes here, we are interested in the ""debug; directory"". The exact format of a debug directory is described by the; `IMAGE_DEBUG_DIRECTORY structure <https://msdn.microsoft.com/en-us/library/windows/desktop/ms680307(v=vs.85).aspx>`__.; For this particular case, the linker emits a debug directory of type; ``IMAGE_DEBUG_TYPE_CODEVIEW``. The format of this record is defined in; ``llvm/DebugInfo/CodeView/CVDebugRecord.h``, but it suffices to say here only; that it includes the same ``Guid`` and ``Age`` fields. At runtime, a; debugger or tool can scan the COFF executable image for the presence of; a debug directory of the correct type and verify that the Guid and Age match.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PDB/PdbStream.rst:5727,guid,guid,5727,interpreter/llvm-project/llvm/docs/PDB/PdbStream.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PDB/PdbStream.rst,4,"['Guid', 'guid']","['Guid', 'guid']"
Usability,"es in the ""``.debug_names``"" section. In the ""``.apple_names``"" section for Objective-C functions, the full name is; the entire function name with the brackets (""``-[NSString; stringWithCString:]``"") and the basename is the selector only; (""``stringWithCString:``""). Mach-O Changes; """""""""""""""""""""""""""". The sections names for the apple hash tables are for non-mach-o files. For; mach-o files, the sections should be contained in the ``__DWARF`` segment with; names as follows:. * ""``.apple_names``"" -> ""``__apple_names``""; * ""``.apple_types``"" -> ""``__apple_types``""; * ""``.apple_namespaces``"" -> ""``__apple_namespac``"" (16 character limit); * ""``.apple_objc``"" -> ""``__apple_objc``"". .. _codeview:. CodeView Debug Info Format; ==========================. LLVM supports emitting CodeView, the Microsoft debug info format, and this; section describes the design and implementation of that support. Format Background; -----------------. CodeView as a format is clearly oriented around C++ debugging, and in C++, the; majority of debug information tends to be type information. Therefore, the; overriding design constraint of CodeView is the separation of type information; from other ""symbol"" information so that type information can be efficiently; merged across translation units. Both type information and symbol information is; generally stored as a sequence of records, where each record begins with a; 16-bit record size and a 16-bit record kind. Type information is usually stored in the ``.debug$T`` section of the object; file. All other debug info, such as line info, string table, symbol info, and; inlinee info, is stored in one or more ``.debug$S`` sections. There may only be; one ``.debug$T`` section per object file, since all other debug info refers to; it. If a PDB (enabled by the ``/Zi`` MSVC option) was used during compilation,; the ``.debug$T`` section will contain only an ``LF_TYPESERVER2`` record pointing; to the PDB. When using PDBs, symbol information appears to remain in the ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:82630,clear,clearly,82630,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['clear'],['clearly']
Usability,"es that Clang has; historically rejected. In order to parse widely distributed headers for; libraries such as the Active Template Library (ATL) and Windows Runtime Library; (WRL), some template rules have been relaxed or extended in Clang on Windows. The first major semantic difference is that MSVC appears to defer all parsing; an analysis of inline method bodies in class templates until instantiation; time. By default on Windows, Clang attempts to follow suit. This behavior is; controlled by the ``-fdelayed-template-parsing`` flag. While Clang delays; parsing of method bodies, it still parses the bodies *before* template argument; substitution, which is not what MSVC does. The following compatibility tweaks; are necessary to parse the template in those cases. MSVC allows some name lookup into dependent base classes. Even on other; platforms, this has been a `frequently asked question`_ for Clang users. A; dependent base class is a base class that depends on the value of a template; parameter. Clang cannot see any of the names inside dependent bases while it; is parsing your template, so the user is sometimes required to use the; ``typename`` keyword to assist the parser. On Windows, Clang attempts to; follow the normal lookup rules, but if lookup fails, it will assume that the; user intended to find the name in a dependent base. While parsing the; following program, Clang will recover as if the user had written the; commented-out code:. .. _frequently asked question:; https://clang.llvm.org/compatibility.html#dep_lookup. .. code-block:: c++. template <typename T>; struct Foo : T {; void f() {; /*typename*/ T::UnknownType x = /*this->*/unknownMember;; }; };. After recovery, Clang warns the user that this code is non-standard and issues; a hint suggesting how to fix the problem. As of this writing, Clang is able to compile a simple ATL hello world; application. There are still issues parsing WRL headers for modern Windows 8; apps, but they should be addressed soon.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MSVCCompatibility.rst:6829,simpl,simple,6829,interpreter/llvm-project/clang/docs/MSVCCompatibility.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MSVCCompatibility.rst,1,['simpl'],['simple']
Usability,"es use of this feature to enable running C++; within Python. It enables transporting values/information between C++; and Python. Note: `cppyy <https://github.com/wlav/cppyy/>`_ is an automatic, run-time,; Python-to-C++ bindings generator, for calling C++ from Python and Python from C++.; It uses LLVM along with a C++ interpreter (e.g., Cling) to enable features like; run-time instantiation of C++ templates, cross-inheritance, callbacks,; auto-casting, transparent use of smart pointers, etc. In a nutshell, this feature enables a new way of developing code, paving the; way for language interoperability and easier interactive programming. Implementation Details; ======================. Interpreter as a REPL vs. as a Library; --------------------------------------. 1 - If we're using the interpreter in interactive (REPL) mode, it will dump; the value (i.e., value printing). .. code-block:: console. if (LastValue.isValid()) {; if (!V) {; LastValue.dump();; LastValue.clear();; } else; *V = std::move(LastValue);; }. 2 - If we're using the interpreter as a library, then it will pass the value; to the user. Incremental AST Consumer; ------------------------. The ``IncrementalASTConsumer`` class wraps the original code generator; ``ASTConsumer`` and it performs a hook, to traverse all the top-level decls, to; look for expressions to synthesize, based on the ``isSemiMissing()`` condition. If this condition is found to be true, then ``Interp.SynthesizeExpr()`` will be; invoked. **Note:** Following is a sample code snippet. Actual code may vary over time. .. code-block:: console. for (Decl *D : DGR); if (auto *TSD = llvm::dyn_cast<TopLevelStmtDecl>(D);; TSD && TSD->isSemiMissing()); TSD->setStmt(Interp.SynthesizeExpr(cast<Expr>(TSD->getStmt())));. return Consumer->HandleTopLevelDecl(DGR);. The synthesizer will then choose the relevant expression, based on its type. Communication between Compiled Code and Interpreted Code; --------------------------------------------------------.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst:11726,clear,clear,11726,interpreter/llvm-project/clang/docs/ClangRepl.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst,1,['clear'],['clear']
Usability,"es, translations, rotations,; etc. \image html geometry020.png ""Selection dialogs for different TGeo objects"". Once a selection is made and the dialog is closed, the selected item; name will appear in the corresponding label and the button Edit will; start the object editor in a transient frame. Closing these transient; frames will not delete, but just hide existing opened editors for later; reuse. Their lifetime is determined by the canvas to which the manager; editor is attached to, since these will be destroyed together. \image html geometry021.png ""Editors for shapes, materials, media, matrices"" width=600px. For most editors, the functionalities Apply and Undo are provided. For shapes, changing any of the shape parameters will activate the; ""Apply"" button only if the check button ""Delayed draw"" is checked,; otherwise the changes are immediately applied. Once the apply button is; pressed, the changes are applied to the edited shape and drawn. The; ""Undo"" button becomes active after the first modification has been; applied. It allows restoring the initial parameters of the shape. NOTE: In this version the ""Undo"" does not allow restoring an; intermediate state of the parameters that was applied - it will always; restore the parameters at the moment the shape was edited. All material properties changes are undoable. The mixture editor; currently allows adding elements one by one in the mixture composition.; This can be done either by element weight fraction or by number of; atoms. Once an element was added using one method the other method is not; selectable anymore. Summing component fractions up to 1 in the final; mixture is the user responsibility. Adding materials as components of a; mixture is not supported in this version. The elements that were added to the mixture appear in the bottom of the; mixture editor. The operations performed on mixture are not undoable. \anchor GP08d; ### Creation of New Objects. As described above, all geometry object creators are a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:130763,Undo,Undo,130763,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['Undo'],['Undo']
Usability,"es<gv_summary>`, and; :ref:`type identifiers<typeid_summary>`. .. _module_path_summary:. Module Path Summary Entry; -------------------------. Each module path summary entry lists a module containing global values included; in the summary. For a single IR module there will be one such entry, but; in a combined summary index produced during the thin link, there will be; one module path entry per linked module with summary. Example:. .. code-block:: text. ^0 = module: (path: ""/path/to/file.o"", hash: (2468601609, 1329373163, 1565878005, 638838075, 3148790418)). The ``path`` field is a string path to the bitcode file, and the ``hash``; field is the 160-bit SHA-1 hash of the IR bitcode contents, used for; incremental builds and caching. .. _gv_summary:. Global Value Summary Entry; --------------------------. Each global value summary entry corresponds to a global value defined or; referenced by a summarized module. Example:. .. code-block:: text. ^4 = gv: (name: ""f""[, summaries: (Summary)[, (Summary)]*]?) ; guid = 14740650423002898831. For declarations, there will not be a summary list. For definitions, a; global value will contain a list of summaries, one per module containing; a definition. There can be multiple entries in a combined summary index; for symbols with weak linkage. Each ``Summary`` format will depend on whether the global value is a; :ref:`function<function_summary>`, :ref:`variable<variable_summary>`, or; :ref:`alias<alias_summary>`. .. _function_summary:. Function Summary; ^^^^^^^^^^^^^^^^. If the global value is a function, the ``Summary`` entry will look like:. .. code-block:: text. function: (module: ^0, flags: (linkage: external, notEligibleToImport: 0, live: 0, dsoLocal: 0), insts: 2[, FuncFlags]?[, Calls]?[, TypeIdInfo]?[, Params]?[, Refs]?. The ``module`` field includes the summary entry id for the module containing; this definition, and the ``flags`` field contains information such as; the linkage type, a flag indicating whether it is legal to im",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:340864,guid,guid,340864,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['guid'],['guid']
Usability,"es`. See `SetMakeSharedLib()`; for more information on those variables. When the file being passed to; ACLiC is on a read only file system, ACLiC warns the user and creates; the library in a temporary directory:. ``` {.cpp}; root[] .L readonly/t.C++; Warning in <ACLiC>: /scratch/aclic/subs/./readonly is not writable!; Warning in <ACLiC>: Output will be written to /tmp; Info in <TUnixSystem::ACLiC>: creating shared library; /tmp//scratch/aclic/subs/./readonly/t_C.so; ```. To select the temporary directory ACLiC looks at `$TEMP`, `$TEMP_DIR`,; `$TEMPDIR`, `$TMP`, `$TMPDIR`, `$TMP_DIR `or uses `/tmp (`or `C:/)`.; Also, a new interface `TSystem::Get/SetBuildDir` is introduced; to let users select an alternative 'root' for building of the ACLiC; libraries. For `filename/full/path/name/macro.C`, the library is; created as `fBuildDir/full/path/name/macro_C.so.`. ### Dictionary Generation. You can direct what is added to the dictionary generated by ACLiC in; two ways. The simplest way is to add at the end of script (i.e. after; the symbols have been defined) something like:. ``` {.cpp}; #if defined(__ROOTCLING__); #pragma link C++ class MyOtherClass;; #endif; ```. You can also write this portion of code in a file name; `MyScript_linkdef.h` where the suffix `'_linkdef' `is the prefix; defined by the key `‘ACLiC.Linkdef`‘ in the currently used resource; file (usually `.rootrc `or` $ROOTSYS/etc/system.rootrc`) and the; prefix is the name of your script. The default behavior of `rootcling` is to; not link in (i.e. generate the dictionary for) any of the symbols. In; particular, this means that the following lines are, in the; general case, unnecessary. ``` {.cpp}; #pragma link off all globals;; #pragma link off all classes;; #pragma link off all functions;; ```. This also means that linking the instantiation of a class template:. ``` {.cpp}; #pragma link C++ class mytemplate<int>;; ```. ONLY links this specific class. You need to; request the generation of the iterators explici",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md:18796,simpl,simplest,18796,documentation/users-guide/Cling.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md,1,['simpl'],['simplest']
Usability,"escendant(cxxRecordDecl()); ))); will match 10 times (plus injected class name matches) on:; class A { class B { class C { class D { class E {}; }; }; }; };. Usable as: Any Matcher. Matcher<*>forEachMatcher<*>; Matches AST nodes that have child AST nodes that match the; provided matcher. Example matches X, Y, Y::X, Z::Y, Z::Y::X; (matcher = cxxRecordDecl(forEach(cxxRecordDecl(hasName(""X""))); class X {};; class Y { class X {}; }; // Matches Y, because Y::X is a class of name X; // inside Y.; class Z { class Y { class X {}; }; }; // Does not match Z. ChildT must be an AST base type. As opposed to 'has', 'forEach' will cause a match for each result that; matches instead of only on the first one. Usable as: Any Matcher. Matcher<*>hasAncestorMatcher<*>; Matches AST nodes that have an ancestor that matches the provided; matcher. Given; void f() { if (true) { int x = 42; } }; void g() { for (;;) { int x = 43; } }; expr(integerLiteral(hasAncestor(ifStmt()))) matches 42, but not 43. Usable as: Any Matcher. Matcher<*>hasDescendantMatcher<*>; Matches AST nodes that have descendant AST nodes that match the; provided matcher. Example matches X, Y, Z; (matcher = cxxRecordDecl(hasDescendant(cxxRecordDecl(hasName(""X""))))); class X {}; // Matches X, because X::X is a class of name X inside X.; class Y { class X {}; };; class Z { class Y { class X {}; }; };. DescendantT must be an AST base type. Usable as: Any Matcher. Matcher<*>hasMatcher<*>; Matches AST nodes that have child AST nodes that match the; provided matcher. Example matches X, Y; (matcher = cxxRecordDecl(has(cxxRecordDecl(hasName(""X""))); class X {}; // Matches X, because X::X is a class of name X inside X.; class Y { class X {}; };; class Z { class Y { class X {}; }; }; // Does not match Z. ChildT must be an AST base type. Usable as: Any Matcher; Note that has is direct matcher, so it also matches things like implicit; casts and paren casts. If you are matching with expr then you should; probably consider using ignoringPa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:133765,Usab,Usable,133765,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['Usab'],['Usable']
Usability,"esigned and built with many grand plans for how we can use it. The; driving force is the fact that we use C and C++ daily, and have to suffer due to; a lack of good tools available for it. We believe that the C and C++ tools; ecosystem has been significantly limited by how difficult it is to parse and; represent the source code for these languages, and we aim to rectify this; problem in clang.; The problem with this goal is that different clients have very different; requirements. Consider code generation, for example: a simple front-end that; parses for code generation must analyze the code for validity and emit code; in some intermediate form to pass off to a optimizer or backend. Because; validity analysis and code generation can largely be done on the fly, there is; not hard requirement that the front-end actually build up a full AST for all; the expressions and statements in the code. TCC and GCC are examples of; compilers that either build no real AST (in the former case) or build a stripped; down and simplified AST (in the later case) because they focus primarily on; codegen.; On the opposite side of the spectrum, some clients (like refactoring) want; highly detailed information about the original source code and want a complete; AST to describe it with. Refactoring wants to have information about macro; expansions, the location of every paren expression '(((x)))' vs 'x', full; position information, and much more. Further, refactoring wants to look; across the whole program to ensure that it is making transformations; that are safe. Making this efficient and getting this right requires a; significant amount of engineering and algorithmic work that simply are; unnecessary for a simple static compiler.; The beauty of the clang approach is that it does not restrict how you use it.; In particular, it is possible to use the clang preprocessor and parser to build; an extremely quick and light-weight on-the-fly code generator (similar to TCC); that does not build an ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html:7463,simpl,simplified,7463,interpreter/llvm-project/clang/www/features.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html,1,['simpl'],['simplified']
Usability,"esn't make it more difficult to; understand the code. One great way to do this is by making use of early exits; and the ``continue`` keyword in long loops. Consider this code that does not; use an early exit:. .. code-block:: c++. Value *doSomething(Instruction *I) {; if (!I->isTerminator() &&; I->hasOneUse() && doOtherThing(I)) {; ... some long code ....; }. return 0;; }. This code has several problems if the body of the ``'if'`` is large. When; you're looking at the top of the function, it isn't immediately clear that this; *only* does interesting things with non-terminator instructions, and only; applies to things with the other predicates. Second, it is relatively difficult; to describe (in comments) why these predicates are important because the ``if``; statement makes it difficult to lay out the comments. Third, when you're deep; within the body of the code, it is indented an extra level. Finally, when; reading the top of the function, it isn't clear what the result is if the; predicate isn't true; you have to read to the end of the function to know that; it returns null. It is much preferred to format the code like this:. .. code-block:: c++. Value *doSomething(Instruction *I) {; // Terminators never need 'something' done to them because ...; if (I->isTerminator()); return 0;. // We conservatively avoid transforming instructions with multiple uses; // because goats like cheese.; if (!I->hasOneUse()); return 0;. // This is really just here for example.; if (!doOtherThing(I)); return 0;. ... some long code ....; }. This fixes these problems. A similar problem frequently happens in ``for``; loops. A silly example is something like this:. .. code-block:: c++. for (Instruction &I : BB) {; if (auto *BO = dyn_cast<BinaryOperator>(&I)) {; Value *LHS = BO->getOperand(0);; Value *RHS = BO->getOperand(1);; if (LHS != RHS) {; ...; }; }; }. When you have very, very small loops, this sort of structure is fine. But if it; exceeds more than 10-15 lines, it becomes difficult f",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst:36462,clear,clear,36462,interpreter/llvm-project/llvm/docs/CodingStandards.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst,1,['clear'],['clear']
Usability,"esp; 	ret. Note the load into xmm0, then xor (to negate), then store. In PIC mode,; this code computes the pic base and does two loads to do the constant pool ; load, so the improvement is much bigger. The tricky part about this xform is that the argument load/store isn't exposed; until post-legalize, and at that point, the fneg has been custom expanded into ; an X86 fxor. This means that we need to handle this case in the x86 backend; instead of in target independent code. //===---------------------------------------------------------------------===//. Non-SSE4 insert into 16 x i8 is atrociously bad. //===---------------------------------------------------------------------===//. <2 x i64> extract is substantially worse than <2 x f64>, even if the destination; is memory. //===---------------------------------------------------------------------===//. INSERTPS can match any insert (extract, imm1), imm2 for 4 x float, and insert; any number of 0.0 simultaneously. Currently we only use it for simple; insertions. See comments in LowerINSERT_VECTOR_ELT_SSE4. //===---------------------------------------------------------------------===//. On a random note, SSE2 should declare insert/extract of 2 x f64 as legal, not; Custom. All combinations of insert/extract reg-reg, reg-mem, and mem-reg are; legal, it'll just take a few extra patterns written in the .td file. Note: this is not a code quality issue; the custom lowered code happens to be; right, but we shouldn't have to custom lower anything. This is probably related; to <2 x i64> ops being so bad. //===---------------------------------------------------------------------===//. LLVM currently generates stack realignment code, when it is not necessary; needed. The problem is that we need to know about stack alignment too early,; before RA runs. At that point we don't know, whether there will be vector spill, or not.; Stack realignment logic is overly conservative here, but otherwise we can; produce unaligned loads/stores. F",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/README-SSE.txt:14195,simpl,simple,14195,interpreter/llvm-project/llvm/lib/Target/X86/README-SSE.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/README-SSE.txt,1,['simpl'],['simple']
Usability,"esponding iterator, and; this is a constant time operation (very efficient). The following code snippet; illustrates use of the conversion constructors provided by LLVM iterators. By; using these, you can explicitly grab the iterator of something without actually; obtaining it via iteration over some structure:. .. code-block:: c++. void printNextInstruction(Instruction* inst) {; BasicBlock::iterator it(inst);; ++it; // After this line, it refers to the instruction after *inst; if (it != inst->getParent()->end()) errs() << *it << ""\n"";; }. .. _iterate_complex:. Finding call sites: a slightly more complex example; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Say that you're writing a FunctionPass and would like to count all the locations; in the entire module (that is, across every ``Function``) where a certain; function (i.e., some ``Function *``) is already in scope. As you'll learn; later, you may want to use an ``InstVisitor`` to accomplish this in a much more; straight-forward manner, but this example will allow us to explore how you'd do; it if you didn't have ``InstVisitor`` around. In pseudo-code, this is what we; want to do:. .. code-block:: none. initialize callCounter to zero; for each Function f in the Module; for each BasicBlock b in f; for each Instruction i in b; if (i a Call and calls the given function); increment callCounter. And the actual code is (remember, because we're writing a ``FunctionPass``, our; ``FunctionPass``-derived class simply has to override the ``runOnFunction``; method):. .. code-block:: c++. Function* targetFunc = ...;. class OurFunctionPass : public FunctionPass {; public:; OurFunctionPass(): callCounter(0) { }. virtual runOnFunction(Function& F) {; for (BasicBlock &B : F) {; for (Instruction &I: B) {; if (auto *CB = dyn_cast<CallBase>(&I)) {; // We know we've encountered some kind of call instruction (call,; // invoke, or callbr), so we need to determine if it's a call to; // the function pointed to by m_func or not.; if",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:109637,learn,learn,109637,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['learn'],['learn']
Usability,"esponse team to immediately respond; to an incident. For example:. * Each LLVM Developers' Meeting has a Code of Conduct response team.; * For LLVM meetups, the local organizers will be the first point of contact.; * Any other event funded by the LLVM Foundation or listed on the LLVM website,; will have a code of conduct response team or point of contact for CoC ; reports. These teams should determine if an :ref:`immediate response<Immediate Response; Checklist>` is needed before sending the report to the Code of Conduct; committee. .. _Receiving a report:. Receiving a Report; ==================. Reports are typically received by email (conduct@llvm.org) or in person from; the reporter or event CoC response team. When receiving a report by email, the CoC Committee should acknowledge receipt; within 24 hours. The acknowledgement should be understanding and compassionate; but no commitment should be made on whether this is a violation or which action; will be taken. Specific guidance is in the checklist below. For in-person events that have a violation reported, the report should be sent; to the Code of Conduct committee within 24 hours by the on-site CoC response; team. . .. _Immediate Response Checklist:. Immediate Response Checklist; ============================. The CoC committee generally works, decides, and communicates together. If the; report indicates that an immediate response is required and other committee; members are not available, any committee member may take the immediate action; they think is necessary. In-person Code of Conduct response teams should use; this checklist to determine if an immediate response is needed. * If the incident involves physical danger, contact the appropriate law; enforcement or event security immediately. Ensure the reporter feels safe and; stay with them if possible until help arrives.; * If the act is ongoing and involves harassment or threats against someone in; any space (online or physical), any appropriate response (e.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ResponseGuide.rst:1578,guid,guidance,1578,interpreter/llvm-project/llvm/docs/ResponseGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ResponseGuide.rst,1,['guid'],['guidance']
Usability,"essages posted after the; statement is executed. We will describe the corresponding operations; later. ``` {.cpp}; root[] gGeoManager->CloseGeometry();; ```. Now we are really done with geometry building stage, but we would like; to see our simple world:. ``` {.cpp}; root[] top->SetLineColor(kMagenta);; root[] gGeoManager->SetTopVisible(); // the TOP is invisible; root[] top->Draw();; ```. ### Example 2: A Geometrical Hierarchy Look and Feel. Before going further, let us get a look and feel of interacting with the; modeller. For this, we will use one of the examples illustrating the; geometry package. To get an idea on the geometry structure created in; this example, just look at the link:; <http://root.cern.ch/root/html/tutorials/geom/rootgeom.C.html>. You will; notice that this is a bit more complex that just creating the ""world""; since several other volumes are created and put together in a hierarchy.; The purpose here is just to learn how to interact with a geometry that; is already built, but just few hints on the building steps in this; example might be useful. The geometry here represents the word ROOT that; is replicated in some symmetric manner. You might for instance ask some; questions after having a first look:. ***`Q:`*** ""OK, I understand the first lines that load the libGeom library and create; a geometry manager object. I also recognize from the previous example the following; lines creating some materials and media, but what about the geometrical transformations below?"". ***`A:`*** As explained before, the model that we are trying to create; is a hierarchy of volumes based on ***`containment`***. This is; accomplished by ***`positioning`*** some volumes ***`inside`*** others.; Any volume is an un-positioned object in the sense that it defines only; a ***`local frame`*** (matching the one of its ***`shape`***). In order; to fully define the mother-daughter relationship between two volumes one; has to specify how the daughter will be positioned inside",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:4773,learn,learn,4773,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['learn'],['learn']
Usability,est.cpp; llvm/unittests/AsmParser/AsmParserTest.cpp; llvm/unittests/BinaryFormat/DwarfTest.cpp; llvm/unittests/BinaryFormat/MsgPackDocumentTest.cpp; llvm/unittests/BinaryFormat/MsgPackReaderTest.cpp; llvm/unittests/BinaryFormat/MsgPackWriterTest.cpp; llvm/unittests/BinaryFormat/TestFileMagic.cpp; llvm/unittests/Bitcode/DataLayoutUpgradeTest.cpp; llvm/unittests/Bitstream/BitstreamWriterTest.cpp; llvm/unittests/CodeGen/AllocationOrderTest.cpp; llvm/unittests/CodeGen/AMDGPUMetadataTest.cpp; llvm/unittests/CodeGen/AsmPrinterDwarfTest.cpp; llvm/unittests/CodeGen/DIETest.cpp; llvm/unittests/CodeGen/LexicalScopesTest.cpp; llvm/unittests/CodeGen/MachineInstrBundleIteratorTest.cpp; llvm/unittests/CodeGen/RegAllocScoreTest.cpp; llvm/unittests/CodeGen/SelectionDAGAddressAnalysisTest.cpp; llvm/unittests/CodeGen/TestAsmPrinter.cpp; llvm/unittests/CodeGen/TestAsmPrinter.h; llvm/unittests/CodeGen/GlobalISel/CSETest.cpp; llvm/unittests/CodeGen/GlobalISel/KnownBitsVectorTest.cpp; llvm/unittests/DebugInfo/CodeView/GUIDFormatTest.cpp; llvm/unittests/DebugInfo/CodeView/TypeHashingTest.cpp; llvm/unittests/DebugInfo/DWARF/DWARFAcceleratorTableTest.cpp; llvm/unittests/DebugInfo/DWARF/DWARFDataExtractorTest.cpp; llvm/unittests/DebugInfo/DWARF/DWARFDebugArangeSetTest.cpp; llvm/unittests/DebugInfo/DWARF/DWARFDebugFrameTest.cpp; llvm/unittests/DebugInfo/DWARF/DWARFDieManualExtractTest.cpp; llvm/unittests/DebugInfo/DWARF/DWARFDieTest.cpp; llvm/unittests/DebugInfo/DWARF/DWARFExpressionCompactPrinterTest.cpp; llvm/unittests/DebugInfo/DWARF/DWARFExpressionCopyBytesTest.cpp; llvm/unittests/DebugInfo/DWARF/DwarfGenerator.h; llvm/unittests/DebugInfo/DWARF/DWARFListTableTest.cpp; llvm/unittests/DebugInfo/DWARF/DWARFLocationExpressionTest.cpp; llvm/unittests/DebugInfo/DWARF/DwarfUtils.cpp; llvm/unittests/DebugInfo/DWARF/DwarfUtils.h; llvm/unittests/DebugInfo/MSF/MSFBuilderTest.cpp; llvm/unittests/DebugInfo/MSF/MSFCommonTest.cpp; llvm/unittests/DebugInfo/PDB/NativeSessionTest.cpp; llvm/unittests/DebugI,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt:343831,GUID,GUIDFormatTest,343831,interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,1,['GUID'],['GUIDFormatTest']
Usability,"esult] != __reject3); ++__result;; return __result;; }. This should turn into a switch on the character. See PR3253 for some notes on; codegen. 456.hmmer apparently uses strcspn and strspn a lot. 471.omnetpp uses strspn. //===---------------------------------------------------------------------===//. simplifylibcalls should turn these snprintf idioms into memcpy (GCC PR47917). char buf1[6], buf2[6], buf3[4], buf4[4];; int i;. int foo (void) {; int ret = snprintf (buf1, sizeof buf1, ""abcde"");; ret += snprintf (buf2, sizeof buf2, ""abcdef"") * 16;; ret += snprintf (buf3, sizeof buf3, ""%s"", i++ < 6 ? ""abc"" : ""def"") * 256;; ret += snprintf (buf4, sizeof buf4, ""%s"", i++ > 10 ? ""abcde"" : ""defgh"")*4096;; return ret;; }. //===---------------------------------------------------------------------===//. ""gas"" uses this idiom:; else if (strchr (""+-/*%|&^:[]()~"", *intel_parser.op_string)); ..; else if (strchr (""<>"", *intel_parser.op_string). Those should be turned into a switch. SimplifyLibCalls only gets the second; case. //===---------------------------------------------------------------------===//. 252.eon contains this interesting code:. %3072 = getelementptr [100 x i8]* %tempString, i32 0, i32 0; %3073 = call i8* @strcpy(i8* %3072, i8* %3071) nounwind; %strlen = call i32 @strlen(i8* %3072) ; uses = 1; %endptr = getelementptr [100 x i8]* %tempString, i32 0, i32 %strlen; call void @llvm.memcpy.i32(i8* %endptr, ; i8* getelementptr ([5 x i8]* @""\01LC42"", i32 0, i32 0), i32 5, i32 1); %3074 = call i32 @strlen(i8* %endptr) nounwind readonly ; ; This is interesting for a couple reasons. First, in this:. The memcpy+strlen strlen can be replaced with:. %3074 = call i32 @strlen([5 x i8]* @""\01LC42"") nounwind readonly . Because the destination was just copied into the specified memory buffer. This,; in turn, can be constant folded to ""4"". In other code, it contains:. %endptr6978 = bitcast i8* %endptr69 to i32* ; store i32 7107374, i32* %endptr6978, align 1; %3167 = call i32 @strlen(i8* ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt:38125,Simpl,SimplifyLibCalls,38125,interpreter/llvm-project/llvm/lib/Target/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt,1,['Simpl'],['SimplifyLibCalls']
Usability,"et""(token %tok) ]; cleanupret from %tok unwind label %RestOfTheCleanup. The `CoroSplit` pass, if the funclet bundle is present, will insert; ``cleanupret from %tok unwind to caller`` before; the `coro.end`_ intrinsic and will remove the rest of the block. In the unwind path (when the argument is `true`), `coro.end` will mark the coroutine; as done, making it undefined behavior to resume the coroutine again and causing ; `llvm.coro.done` to return `true`. This is not necessary in the normal path because; the coroutine will already be marked as done by the final suspend. The following table summarizes the handling of `coro.end`_ intrinsic. +--------------------------+------------------------+---------------------------------+; | | In Start Function | In Resume/Destroy Functions |; +--------------------------+------------------------+---------------------------------+; |unwind=false | nothing |``ret void`` |; +------------+-------------+------------------------+---------------------------------+; | | WinEH | mark coroutine as done || ``cleanupret unwind to caller``|; | | | || mark coroutine done |; |unwind=true +-------------+------------------------+---------------------------------+; | | Landingpad | mark coroutine as done | mark coroutine done |; +------------+-------------+------------------------+---------------------------------+. .. _coro.end.results:. 'llvm.coro.end.results' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; ::. declare token @llvm.coro.end.results(...). Overview:; """""""""""""""""". The '``llvm.coro.end.results``' intrinsic captures values to be returned from; unique-suspend returned-continuation coroutines. Arguments:; """""""""""""""""""". The number of arguments must match the return type of the continuation function:. - if the return type of the continuation function is ``void`` there must be no; arguments. - if the return type of the continuation function is a ``struct``, the arguments; will be of element types of that ``struct`` in order;. - otherw",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:46549,Resume,Resume,46549,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['Resume'],['Resume']
Usability,"eta_i^{min}\le\theta_i\le\theta^{max}_i$$. They form parallelepiped $P$ ($P_0$ may be deformed by $P$). Very; similar step formulae are used in FUMILI for negative logarithm of; the likelihood function with the same idea - linearization of function; argument. ## Neural Networks. ### Introduction. Neural Networks are used in various fields for data analysis and; classification, both for research and commercial institutions. Some; randomly chosen examples are image analysis, financial movements'; predictions and analysis, or sales forecast and product shipping; optimization. In particles physics neural networks are mainly used for; classification tasks (signal over background discrimination). A vast; majority of commonly used neural networks are multilayer perceptrons.; This implementation of multilayer perceptrons is inspired from the; `MLPfit` package, which remains one of the fastest tools for neural; networks studies. ### The MLP. The multilayer perceptron is a simple feed-forward network with the; following structure showed on the left. ![](pictures/0300008D.png). It is made of neurons characterized by a bias and weighted links in; between - let's call those links synapses. The input neurons receive; the inputs, normalize them and forward them to the first hidden layer.; Each neuron in any subsequent layer first computes a linear; combination of the outputs of the previous layer. The output of the; neuron is then function of that combination with f being linear for; output neurons or a sigmoid for hidden layers. Such a structure is very useful because of two theorems:. 1- A linear combination of `sigmoids` can approximate any continuous; function. 2- Trained with `output=1` for the signal and 0 for the background,; the approximated function of inputs `X` is the probability of signal,; knowing `X`. ### Learning Methods. The aim of all learning methods is to minimize the total error on a; set of weighted examples. The error is defined as the sum in quadrate,; divide",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:70526,simpl,simple,70526,documentation/users-guide/FittingHistograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md,1,['simpl'],['simple']
Usability,"ethod 2. Another method allows to create the evolution of a given radioactive; material/mixture at a given moment in time:. ~~~{.cpp}; TGeoMaterial::DecayMaterial(Double_t time, Double_t precision=0.001); ~~~. The method will create the mixture that result from the decay of a; initial material/mixture at time, while all resulting elements having a; fractional weight less than precision are excluded. A demo macro for radioactive material features is; `$ROOTSYS/tutorials/geom/RadioNuclides.C` It demonstrates also the decay; of a mixture made of radionuclides. \image html geometry004.png width=600px. \anchor GM00c; ### Tracking Media. The class TGeoMedium describes tracking media properties. This has; a pointer to a material and the additional data members representing the; properties related to tracking. ~~~{.cpp}; TGeoMedium(const char *name,Int_t numed,TGeoMaterial *mat,; Double_t *params=0);; ~~~. - `name:` name assigned to the medium; - `mat:` pointer to a material; - `params:` array of additional parameters. Another constructor allows effectively defining tracking parameters in; GEANT3 style:. ~~~{.cpp}; TGeoMedium(const char *name,Int_t numed,Int_t imat,Int_t ifield,; Double_t fieldm,Double_t tmaxfd,Double_t stemax,; Double_t deemax,Double_t epsil,Double_t stmin);; ~~~. This constructor is reserved for creating tracking media from the VMC; interface [...]:. - `numed:` user-defined medium index; - `imat:` unique ID of the material; - `others:` see G3 documentation. Looking at our simple world example, one can see that for creating; volumes one needs to create tracking media before. The way to proceed; for those not interested in performing tracking with external MC's is to; define and use only one `dummy tracking medium` as in the example (or a; `NULL` pointer). \anchor GM00d; ### User Interface for Handling Materials and Media. The TGeoManager class contains the API for accessing and handling; defined materials:. ~~~{.cpp}; TGeoManager::GetMaterial(name);; ~~~. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/materials.md:10039,simpl,simple,10039,geom/geom/doc/materials.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/materials.md,1,['simpl'],['simple']
Usability,"eturn_object() { return std::coroutine_handle<promise_type>::from_promise(*this); }; std::suspend_always initial_suspend() { return {}; }; std::suspend_always final_suspend() noexcept { return {}; }; void return_void() noexcept {}; void unhandled_exception() noexcept {}. int count = 0;; };. void resume() noexcept {; handle.resume();; }. task(std::coroutine_handle<promise_type> hdl) : handle(hdl) {}; ~task() {; if (handle); handle.destroy();; }. std::coroutine_handle<> handle;; };. class await_counter : public std::suspend_always {; public:; template<class PromiseType>; void await_suspend(std::coroutine_handle<PromiseType> handle) noexcept {; handle.promise().count++;; }; };. static task coro_task(int v) {; int a = v;; co_await await_counter{};; a++;; std::cout << a << ""\n"";; a++;; std::cout << a << ""\n"";; a++;; std::cout << a << ""\n"";; co_await await_counter{};; a++;; std::cout << a << ""\n"";; a++;; std::cout << a << ""\n"";; }. int main() {; task t = coro_task(43);; t.resume();; t.resume();; t.resume();; return 0;; }. In debug mode (`O0` + `g`), the printing result would be:. .. parsed-literal::. {__resume_fn = 0x4019e0 <coro_task(int)>, __destroy_fn = 0x402000 <coro_task(int)>, __promise = {count = 1}, v = 43, a = 45, __coro_index = 1 '\001', struct_std__suspend_always_0 = {__int_8 = 0 '\000'},; class_await_counter_1 = {__int_8 = 0 '\000'}, class_await_counter_2 = {__int_8 = 0 '\000'}, struct_std__suspend_always_3 = {__int_8 = 0 '\000'}}. In the above, the values of `v` and `a` are clearly expressed, as are the; temporary values for `await_counter` (`class_await_counter_1` and; `class_await_counter_2`) and `std::suspend_always` (; `struct_std__suspend_always_0` and `struct_std__suspend_always_3`). The index; of the current suspension point of the coroutine is emitted as `__coro_index`.; In the above example, the `__coro_index` value of `1` means the coroutine; stopped at the second suspend point (Note that `__coro_index` is zero indexed); which is the first `co_await ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst:7147,resume,resume,7147,interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst,1,['resume'],['resume']
Usability,"even if no compression is selected). The compression algorithm used is an in memory ZIP compression written for the; DELPHI collaboration at CERN. Its author is E. Chernyaev (IHEP/Protvino).; The source code is internal to ROOTIO. \anchor si; ## StreamerInfo. The ""StreamerInfo"" data record is used by ROOTIO to support the storage of; self-identifying objects. Its detailed format is given in \ref streamerinfo.; A ROOTIO file contains exactly one StreamerInfo record, which is written to disk; automatically when a new or modified file is closed. The StreamerInfo record is a list (ROOTIO class TList) of ""StreamerInfo"" objects; (ROOTIO class TStreamerInfo). There is one StreamerInfo object in the list for; every class used in the file in a data record, other than a core layer record.; There is no streamerinfo object for a class used in a core layer record unless the; class is also used elsewhere in a data record. When reading a self-identifying; object from a file, the system uses the StreamerInfo list to decompose the object; recursively into its simple data members. Each streamerinfo object is an array of ""streamer element"" objects, each of which; describes a base class of the object or a (non-static and non-transient) data member; of the object. If the base class or data member is itself a class, then there will; also be a streamerinfo object in the record for that class. In this way, each; class is recursively decomposed into its atomic elements, each of which is a simple; type (e.g. ""int""). A ""long"" or ""unsigned long"" member is always written; as an 8 byte quantity, even if it occupies only 4 bytes in memory. A data member of a class is marked transient on the line of its declaration by a; comment beginning with ""//!"". Such members are not written to disk, nor is there; any streamerinfo for such a member. A data member that is a C++ pointer (not to be confused with ""pointers to persistent; objects"" described below) is never written to disk as a pointer value. If it ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/doc/TFile/README.md:6879,simpl,simple,6879,io/doc/TFile/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/doc/TFile/README.md,1,['simpl'],['simple']
Usability,"events and react to them according to the; application functionality. ![](pictures/0200020B.jpg). The signals/slot communication mechanism is an advanced object; communication concept; it largely replaces the concept of callback; functions to handle actions in GUI's. Signals and slots are just like; any object-oriented methods implemented in C++. The objects are the; instances of classes that don't know anything about each other. They; interact and allow method calls of other object's methods. The idea is; simple: any object can send out (emit) a signal in certain situations; saying that something happened. This is all it does to communicate and; it does not know whether anything is interested in this information. On; the other side there might be an object waiting for that signal and; ready to react to it. This object disposes of special instruments to; listen to the sent out signals. To have a communication we need a; message transmission between the objects. In this simple example we use; signals and slots. The code of the method **`TGButton::Clicked()`** is:. ``` {.cpp}; virtual void Clicked() { Emit(""Clicked()""); } // *SIGNAL*; ```. I.e. any button emits the signal `Clicked()` any time someone clicks on; it. As you can see this method is virtual and could be overridden if you; need to. In our simple example we call the `Connect()` method to connect; the `Clicked()` signal of Draw button with `MyMainFrame::DoDraw():`. ``` {.cpp}; draw->Connect(""Clicked()"",""MyMainFrame"",this,""DoDraw()"");; ```. In the same way we can connect to the signal `Clicked()` of the Exit; button with the system call `gApplication->Terminate(0).` We declare a; new slot `DoExit(),` implement it to invoke the termination call and; associate this slot with the signal `Clicked()` of the Exit button. The code of `example.C` can be changed as follows:. ``` {.cpp}; public:; ...; void DoExit(); // a new slot is added; }; void MyMainFrame::DoExit() {; gApplication->Terminate(0);; }; MyMainFrame::MyM",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:41572,simpl,simple,41572,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,1,['simpl'],['simple']
Usability,"ew algorithmic optimization in the caching of pdfs. So far - in the likelihood - two classes of; objects are identified: those that change with every event (i.e. the pdf) and those that change; only with the parameters (typically pdf normalization integrals). Pdfs are always recalculated; for every event, whereas integrals are only evaluated when needed. The exception to the first type are pdfs; that only depend on constant parameters (or no parameters) - these are identified at the beginning, and precalculated once ; to avoid recalculating an expression with the same outcome for every iteration of the likelihood calculation. For composite pdfs a further optimization has been included: for a M(x,a,b) = f*F(x,a)+(1-f)G(x,b) ; it is e.g. not needed to recalculate G(x,b) if only parameter a has changed w.r.t to the previous likelihood; calculation. This optimization is now implemented by extending the value caching originally designed; for constant terms to be usable for non-constant terms, with a check executed at the beginning of each; likelihood evaluation if selected columns need to be updated because parameters have changed. The speed gain; of this optimization depends much on the structure of the pdf: in models with many free parameters most of the; likelihood evaluations are executed when MINUIT calculates numerical likelihood derivatives which vary ; one parameter at a time and the speedup is potentially larger. In models with few free parameters the; effect will be smaller. The new per-component caching strategy is enabled by default for all pdfs that are a component of; a RooAddPdf or a RooRealSumPdf, unless that component is a RooProdPdf or a RooProduct, in that; case the components of the product are cached instead of the product itself. You can disable this; new optimization by adding Optimize(1) to the RooAbsPdf::fitTo() command line (0 = no caching,; 1 = cache constant terms only, 2 = cache also variable terms according to above mentioned strategy (DEFAUL",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v532/index.html:2652,usab,usable,2652,roofit/doc/v532/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v532/index.html,1,['usab'],['usable']
Usability,"example $ROOTSYS/tutorials/histfactory/example_channel.xml; This file is edited by the user. It specifies for each channel. observed data (if absent the tool will use the expectation, which is useful for expected sensitivity); several 'Samples' (eg. signal, bkg1, bkg2, ...), each of which has:; ; a name; if the sample is normalized by theory (eg N = L*sigma) or not (eg. data driven); a nominal expectation histogram; a named 'Normalization Factor' (which can be fixed or allowed to float in a fit); several 'Overall Systematics' in normalization with:; 	 ; a name; +/- 1 sigma variations (eg. 1.05 and 0.95 for a 5% uncertainty); 	 ; several 'Histogram Systematics' in shape with:; 	 ; a name (which can be shared with the OverallSyst if correlated); +/- 1 sigma variational histograms; 	 . RooStats; ModelConfig. This class is now used extensively by the calculator tools. It encapsulates the configuration of a model to define a particular hypothesis.; Various fixes by and improvements to make it usable with all; the existing calculator.; ModelConfig contains now always a reference to an; external workspace who manages all the objects being part of the model (pdf's and parameter sets). The user needs then to; set always a workspace pointer before setting the various objects.; . General Improvements. ModelConfig is now used extensively by the calculator tools. It encapsulates the configuration of a model to define a particular hypothesis.; ProfileLikelihood::GetInterval now returns LikleihoodInterval in the interface to avoid unnecessary casting; FeldmanCousins::GetInterval now returns PointSetInterval in the interface to avoid unnecessary casting. Profile Likelihood . When running ProfileLikelihoodCalculator::GetHypoTest; the user does not need anymore to clone the null parameter set. It; is done now inside the calculator; LikelihoodInterval::LowerLimit (and UpperLimit); returns now a boolean flag with the status of the limit search.; In case of a failure in finding the uppe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v528/index.html:3264,usab,usable,3264,roofit/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v528/index.html,1,['usab'],['usable']
Usability,"example a sequence; of mappings in which one of the mapping values is itself a sequence:. .. code-block:: yaml. # a sequence of mappings with one key's value being a sequence; - name: Tom; cpus:; - x86; - x86_64; - name: Bob; cpus:; - x86; - name: Dan; cpus:; - PowerPC; - x86. Sometime sequences are known to be short and the one entry per line is too; verbose, so YAML offers an alternate syntax for sequences called a ""Flow; Sequence"" in which you put comma separated sequence elements into square; brackets. The above example could then be simplified to :. .. code-block:: yaml. # a sequence of mappings with one key's value being a flow sequence; - name: Tom; cpus: [ x86, x86_64 ]; - name: Bob; cpus: [ x86 ]; - name: Dan; cpus: [ PowerPC, x86 ]. Introduction to YAML I/O; ========================. The use of indenting makes the YAML easy for a human to read and understand,; but having a program read and write YAML involves a lot of tedious details.; The YAML I/O library structures and simplifies reading and writing YAML; documents. YAML I/O assumes you have some ""native"" data structures which you want to be; able to dump as YAML and recreate from YAML. The first step is to try; writing example YAML for your data structures. You may find after looking at; possible YAML representations that a direct mapping of your data structures; to YAML is not very readable. Often the fields are not in the order that; a human would find readable. Or the same information is replicated in multiple; locations, making it hard for a human to write such YAML correctly. In relational database theory there is a design step called normalization in; which you reorganize fields and tables. The same considerations need to; go into the design of your YAML encoding. But, you may not want to change; your existing native data structures. Therefore, when writing out YAML; there may be a normalization step, and when reading YAML there would be a; corresponding denormalization step. YAML I/O uses a non-in",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/YamlIO.rst:1806,simpl,simplifies,1806,interpreter/llvm-project/llvm/docs/YamlIO.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/YamlIO.rst,1,['simpl'],['simplifies']
Usability,"example, the module map file for the C standard library might look a bit like this:. .. parsed-literal::. module std [system] [extern_c] {; module assert {; textual header ""assert.h""; header ""bits/assert-decls.h""; export *; }. module complex {; header ""complex.h""; export *; }. module ctype {; header ""ctype.h""; export *; }. module errno {; header ""errno.h""; header ""sys/errno.h""; export *; }. module fenv {; header ""fenv.h""; export *; }. // ...more headers follow...; }. Here, the top-level module ``std`` encompasses the whole C standard library. It has a number of submodules containing different parts of the standard library: ``complex`` for complex numbers, ``ctype`` for character types, etc. Each submodule lists one of more headers that provide the contents for that submodule. Finally, the ``export *`` command specifies that anything included by that submodule will be automatically re-exported. Lexical structure; -----------------; Module map files use a simplified form of the C99 lexer, with the same rules for identifiers, tokens, string literals, ``/* */`` and ``//`` comments. The module map language has the following reserved words; all other C identifiers are valid identifiers. .. parsed-literal::. ``config_macros`` ``export_as`` ``private``; ``conflict`` ``framework`` ``requires``; ``exclude`` ``header`` ``textual``; ``explicit`` ``link`` ``umbrella``; ``extern`` ``module`` ``use``; ``export``. Module map file; ---------------; A module map file consists of a series of module declarations:. .. parsed-literal::. *module-map-file*:; *module-declaration**. Within a module map file, modules are referred to by a *module-id*, which uses periods to separate each part of a module's name:. .. parsed-literal::. *module-id*:; *identifier* ('.' *identifier*)*. Module declaration; ------------------; A module declaration describes a module, including the headers that contribute to that module, its submodules, and other aspects of the module. .. parsed-literal::. *module-decl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:28896,simpl,simplified,28896,interpreter/llvm-project/clang/docs/Modules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst,1,['simpl'],['simplified']
Usability,expr defaulted constructors; Unknown. 1655; drafting; Line endings in raw string literals; Not resolved. 1656; CD6; Encoding of numerically-escaped characters; Unknown. 1657; CD4; Attributes for namespaces and enumerators; Unknown. 1658; C++14; Deleted default constructor for abstract class via destructor; Clang 5. 1659; open; Initialization order of thread_local template static data members; Not resolved. 1660; C++14; member-declaration requirements and unnamed bit-fields; Unknown. 1661; NAD; Preservation of infinite loops; Unknown. 1662; C++14; Capturing function parameter packs; Unknown. 1663; NAD; Capturing an empty pack expansion; Unknown. 1664; C++14; Argument-dependent lookup of lambdas used in default arguments; Unknown. 1665; drafting; Declaration matching in explicit instantiations; Not resolved. 1666; C++14; Address constant expressions; Unknown. 1667; NAD; Function exiting via exception called by destructor during unwinding; Unknown. 1668; drafting; Parameter type determination still not clear enough; Not resolved. 1669; C++14; auto return type for main; Unknown. 1670; drafting; auto as conversion-type-id; Not resolved. 1671; NAD; Unclear rules for deduction with cv-qualification; Unknown. 1672; CD4; Layout compatibility with multiple empty bases; Clang 7. 1673; C++14; Clarifying overload resolution for the second step of copy-initialization; Unknown. 1674; C++14; Return type deduction for address of function; Unknown. 1675; NAD; Size limit for automatic array object; Unknown. 1676; drafting; auto return type for allocation and deallocation functions; Not resolved. 1677; C++17; Constant initialization via aggregate initialization; Unknown. 1678; NAD; Naming the type of an array of runtime bound; Unknown. 1679; NAD; Range-based for and array of runtime bound; Unknown. 1680; drafting; Including <initializer_list> for range-based for; Not resolved. 1681; C++14; init-captures and nested lambdas; Unknown. 1682; open; Overly-restrictive rules on function templa,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:112845,clear,clear,112845,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['clear'],['clear']
Usability,expr if; Unknown. 2275; drafting; Type-dependence of function template; Not resolved. 2276; C++17; Dependent noexcept and function type-dependence; Unknown. 2277; CD5; Ambiguity inheriting constructors with default arguments; Unknown. 2278; CD5; Copy elision in constant expressions reconsidered; Unknown. 2279; NAD; Multiple attribute-specifiers in one attribute-list; Unknown. 2280; C++20; Matching a usual deallocation function with placement new; Unknown. 2281; drafting; Consistency of aligned operator delete replacement; Not resolved. 2282; C++20; Consistency with mismatched aligned/non-over-aligned allocation/deallocation functions; Unknown. 2283; drafting; Missing complete type requirements; Not resolved. 2284; open; Sequencing of braced-init-list arguments; Not resolved. 2285; CD5; Issues with structured bindings; Unknown. 2286; NAD; Assignment evaluation order; Unknown. 2287; CD5; Pointer-interconvertibility in non-standard-layout unions; Unknown. 2288; NAD; Contradictory optionality in simple-declaration; Unknown. 2289; CD5; Uniqueness of structured binding names; Unknown. 2290; CD5; Unclear specification for overload resolution and deleted special member functions; Unknown. 2291; dup; Implicit conversion sequences in non-call contexts; Unknown. 2292; CD5; simple-template-id is ambiguous between class-name and type-name; Clang 9. 2293; CD5; Requirements for simple-template-id used as a class-name; Unknown. 2294; CD5; Dependent auto static data members; Unknown. 2295; CD5; Aggregates with deleted defaulted constructors; Unknown. 2296; open; Are default argument instantiation failures in the “immediate context”?; Not resolved. 2297; open; Unclear specification of atomic operations; Not resolved. 2298; open; Actions and expression evaluation; Not resolved. 2299; CD5; constexpr vararg functions; Unknown. 2300; CD5; Lambdas in multiple definitions; Unknown. 2301; open; Value-initialization and constexpr constructor evaluation; Not resolved. 2302; NAD; Address compar,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:156040,simpl,simple-declaration,156040,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['simpl'],['simple-declaration']
Usability,"f .js and .css files.; Minimized scripts used by default on web servers.; - Implement JSROOT.extend instead of jQuery.extend, reduce; usage of jquery.js in core JSROOT classes; - Implement main graphics without jquery at all,; such mode used in `nobrowser` mode.; - Provide optional latex drawing with MathJax SVG.; TMathText always drawn with MathJax,; other classes require `mathjax` option in URL; - Improve drawing of different text classes, correctly handle; their alignment and scaling, special handling for IE. ## TTree Libraries. ### TTree Behavior change. #### Merging. Added fast cloning support to TTree::MergeTrees and TTree::Merge(TCollection*,Option_t*). #### TTreeCache. The TTreeCache is now enabled by default. The default size of the TTreeCache; is the estimated size of a cluster size for the TTree. The TTreeCache; prefilling is also enabled by default; when in learning phase rather than; reading each requested branch individually, the TTreeCache will read all the; branches thus trading off the latencies inherent to multiple small reads for; the potential of requesting more data than needed by read from the disk or; server the baskets for too many branches. The default behavior can be changed by either updating one of the rootrc files; or by setting environment variables. The rootrc files, both the global and the; local ones, now support the following the resource variable TTreeCache.Size; which set the default size factor for auto sizing TTreeCache for TTrees. The; estimated cluster size for the TTree and this factor is used to give the cache; size. If option is set to zero auto cache creation is disabled and the default; cache size is the historical one (equivalent to factor 1.0). If set to; non zero auto cache creation is enabled and both auto created and; default sized caches will use the configured factor: 0.0 no automatic cache; and greater than 0.0 to enable cache. This value can be overridden by the; environment variable ROOT_TTREECACHE_SIZE. The reso",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v604/index.md:12745,learn,learning,12745,README/ReleaseNotes/v604/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v604/index.md,1,['learn'],['learning']
Usability,"f Transformer is the *rewrite rule*, which specifies how; to change a given program pattern into a new form. Here are some examples of; tasks you can achieve with Transformer:. * warn against using the name ``MkX`` for a declared function,; * change ``MkX`` to ``MakeX``, where ``MkX`` is the name of a declared function,; * change ``s.size()`` to ``Size(s)``, where ``s`` is a ``string``,; * collapse ``e.child().m()`` to ``e.m()``, for any expression ``e`` and method named; ``m``. All of the examples have a common form: they identify a pattern that is the; target of the transformation, they specify an *edit* to the code identified by; the pattern, and their pattern and edit refer to common variables, like ``s``,; ``e``, and ``m``, that range over code fragments. Our first and second examples also; specify constraints on the pattern that aren't apparent from the syntax alone,; like ""``s`` is a ``string``."" Even the first example (""warn ..."") shares this form,; even though it doesn't change any of the code -- it's ""edit"" is simply a no-op. Transformer helps users succinctly specify rules of this sort and easily execute; them locally over a collection of files, apply them to selected portions of; a codebase, or even bundle them as a clang-tidy check for ongoing application. Who is Clang Transformer for?; -----------------------------. Clang Transformer is for developers who want to write clang-tidy checks or write; tools to modify a large number of C++ files in (roughly) the same way. What; qualifies as ""large"" really depends on the nature of the change and your; patience for repetitive editing. In our experience, automated solutions become; worthwhile somewhere between 100 and 500 files. Getting Started; ---------------. Patterns in Transformer are expressed with :doc:`clang's AST matchers <LibASTMatchers>`.; Matchers are a language of combinators for describing portions of a clang; Abstract Syntax Tree (AST). Since clang's AST includes complete type information; (within",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst:1545,simpl,simply,1545,interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,1,['simpl'],['simply']
Usability,"f `fPID`; is written in addition to the **`TObject`** part of the **`TRef`**; (`fBits,fUniqueID`). When the **`TRef`** is read, its pointer `fPID` is; set to the value stored in the **`TObjArray`** of; `TFile::fProcessIDs `(`fProcessIDs[pidf]`). When a referenced object is written, `TObject::Streamer` writes the; `pidf` in addition to the standard `fBits and fUniqueID`. When; `TObject::Streamer` reads a reference object, the `pidf` is read. At; this point, the referenced object is entered into the table of objects; of the **`TProcessID`** corresponding to `pidf`. WARNING: If `MyClass` is the class of the referenced object, The; **`TObject`** part of `MyClass` must be streamed. One should not call; `MyClass::Class()->IgnoreTObjectStreamer()`. #### TProccessID and TUUID. A **`TProcessID`** uniquely identifies a ROOT job. The **`TProcessID`**; title consists of a **`TUUID`** object, which provides a globally unique; identifier. The **`TUUID`** class implements the UUID (Universally; Unique Identifier), also known as GUID (Globally Unique Identifier). A; UUID is 128 bits long, and if generated according to this algorithm, is; either guaranteed to be different from all other UUID generated until; 3400 A.D. or extremely likely to be different. The **`TROOT`** constructor automatically creates a **`TProcessID`**.; When a **`TFile`** contains referenced objects, the **`TProcessID`**; object is written to the file. If a file has been written in multiple; sessions (same machine or not), a **`TProcessID`** is written for each; session. The **`TProcessID`** objects are used by **`TRef`** to uniquely; identify the referenced **`TObject`**. When a referenced object is read from a file (its bit `kIsReferenced` is; set), this object is entered into the objects table of the corresponding; **`TProcessID`**. Each **`TFile`** has a list of **`TProcessIDs`** (see; `TFile::fProcessIDs`) also accessible from `TProcessID::fgPIDs`; (for all files). When this object is deleted, it is removed ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:60769,GUID,GUID,60769,documentation/users-guide/InputOutput.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md,1,['GUID'],['GUID']
Usability,"f a fourth field is present, it must be; a ``ConstantInt`` valued at 0 or 1. If it is 1 then the access tag states; that the location being accessed is ""constant"" (meaning; ``pointsToConstantMemory`` should return true; see `other useful; AliasAnalysis methods <AliasAnalysis.html#OtherItfs>`_). The TBAA root of; the access type and the base type of an access tag must be the same, and; that is the TBAA root of the access tag. '``tbaa.struct``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^. The :ref:`llvm.memcpy <int_memcpy>` is often used to implement; aggregate assignment operations in C and similar languages, however it; is defined to copy a contiguous region of memory, which is more than; strictly necessary for aggregate types which contain holes due to; padding. Also, it doesn't contain any TBAA information about the fields; of the aggregate. ``!tbaa.struct`` metadata can describe which memory subregions in a; memcpy are padding and what the TBAA tags of the struct are. The current metadata format is very simple. ``!tbaa.struct`` metadata; nodes are a list of operands which are in conceptual groups of three.; For each group of three, the first operand gives the byte offset of a; field in bytes, the second gives its size in bytes, and the third gives; its tbaa tag. e.g.:. .. code-block:: llvm. !4 = !{ i64 0, i64 4, !1, i64 8, i64 4, !2 }. This describes a struct with two fields. The first is at offset 0 bytes; with size 4 bytes, and has tbaa tag !1. The second is at offset 8 bytes; and has size 4 bytes and has tbaa tag !2. Note that the fields need not be contiguous. In this example, there is a; 4 byte gap between the two fields. This gap represents padding which; does not carry useful data and need not be preserved. '``noalias``' and '``alias.scope``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ``noalias`` and ``alias.scope`` metadata provide the ability to specify generic; noalias memory-access sets. This means that some collection of memory access; instructi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:280171,simpl,simple,280171,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['simpl'],['simple']
Usability,"f class X. Usable as: Matcher<AddrLabelExpr>, Matcher<CallExpr>,; Matcher<CXXConstructExpr>, Matcher<CXXNewExpr>, Matcher<DeclRefExpr>,; Matcher<EnumType>, Matcher<InjectedClassNameType>, Matcher<LabelStmt>,; Matcher<MemberExpr>, Matcher<QualType>, Matcher<RecordType>,; Matcher<TagType>, Matcher<TemplateSpecializationType>,; Matcher<TemplateTypeParmType>, Matcher<TypedefType>,; Matcher<UnresolvedUsingType>. Matcher<ReferenceTypeLoc>hasReferentLocMatcher<TypeLoc> ReferentMatcher; Matches reference `TypeLoc`s that have a referent `TypeLoc` matching; `ReferentMatcher`. Given; int x = 3;; int& xx = x;; referenceTypeLoc(hasReferentLoc(loc(asString(""int"")))); matches `int&`. Matcher<ReferenceType>pointeeMatcher<Type>; Narrows PointerType (and similar) matchers to those where the; pointee matches a given matcher. Given; int *a;; int const *b;; float const *f;; pointerType(pointee(isConstQualified(), isInteger())); matches ""int const *b"". Usable as: Matcher<BlockPointerType>, Matcher<MemberPointerType>,; Matcher<PointerType>, Matcher<ReferenceType>. Matcher<ReturnStmt>hasReturnValueMatcher<Expr> InnerMatcher; Matches the return value expression of a return statement. Given; return a + b;; hasReturnValue(binaryOperator()); matches 'return a + b'; with binaryOperator(); matching 'a + b'. Matcher<StmtExpr>hasAnySubstatementMatcher<Stmt> InnerMatcher; Matches compound statements where at least one substatement matches; a given matcher. Also matches StmtExprs that have CompoundStmt as children. Given; { {}; 1+2; }; hasAnySubstatement(compoundStmt()); matches '{ {}; 1+2; }'; with compoundStmt(); matching '{}'. Matcher<Stmt>alignOfExprMatcher<UnaryExprOrTypeTraitExpr> InnerMatcher; Same as unaryExprOrTypeTraitExpr, but only matching; alignof. Matcher<Stmt>forCallableMatcher<Decl> InnerMatcher; Matches declaration of the function, method, or block the statement; belongs to. Given:; F& operator=(const F& o) {; std::copy_if(o.begin(), o.end(), begin(), [](V v) { return v > 0; });; ret",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:231215,Usab,Usable,231215,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['Usab'],['Usable']
Usability,"f operands) and later can not be used as multiple level. .. code-block:: text. IR for ""*ptr = 4;""; --------------; call void @llvm.dbg.value(metadata i32 4, metadata !17, metadata !20); !17 = !DILocalVariable(name: ""ptr1"", scope: !12, file: !3, line: 5,; type: !18); !18 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !19, size: 64); !19 = !DIBasicType(name: ""int"", size: 32, encoding: DW_ATE_signed); !20 = !DIExpression(DW_OP_LLVM_implicit_pointer)). IR for ""**ptr = 4;""; --------------; call void @llvm.dbg.value(metadata i32 4, metadata !17, metadata !21); !17 = !DILocalVariable(name: ""ptr1"", scope: !12, file: !3, line: 5,; type: !18); !18 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !19, size: 64); !19 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !20, size: 64); !20 = !DIBasicType(name: ""int"", size: 32, encoding: DW_ATE_signed); !21 = !DIExpression(DW_OP_LLVM_implicit_pointer,; DW_OP_LLVM_implicit_pointer)). DWARF specifies three kinds of simple location descriptions: Register, memory,; and implicit location descriptions. Note that a location description is; defined over certain ranges of a program, i.e the location of a variable may; change over the course of the program. Register and memory location; descriptions describe the *concrete location* of a source variable (in the; sense that a debugger might modify its value), whereas *implicit locations*; describe merely the actual *value* of a source variable which might not exist; in registers or in memory (see ``DW_OP_stack_value``). A ``llvm.dbg.declare`` intrinsic describes an indirect value (the address) of a; source variable. The first operand of the intrinsic must be an address of some; kind. A DIExpression attached to the intrinsic refines this address to produce a; concrete location for the source variable. A ``llvm.dbg.value`` intrinsic describes the direct value of a source variable.; The first operand of the intrinsic may be a direct or indirect value. A; DIExpression attached to the i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:267300,simpl,simple,267300,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['simpl'],['simple']
Usability,"f the redeclaration chain. This may result in long; redeclaration chains in certain cases, e.g. if we import from several; translation units which include the same header with the prototype. .. Squashing prototypes. To mitigate the problem of long redeclaration chains of free functions, we; could compare prototypes to see if they have the same properties and if yes; then we could merge these prototypes. The implementation of squashing of; prototypes for free functions is future work. .. Exception: Cannot have more than 1 prototype in-class. Chaining functions this way ensures that we do copy all information from the; source AST. Nonetheless, there is a problem with member functions: While we can; have many prototypes for free functions, we must have only one prototype for a; member function. .. code-block:: c++. void f(); // OK; void f(); // OK. struct X {; void f(); // OK; void f(); // ERROR; };; void X::f() {} // OK. Thus, prototypes of member functions must be squashed, we cannot just simply; attach a new prototype to the existing in-class prototype. Consider the; following contexts:. .. code-block:: c++. // ""to"" context; struct X {; void f(); // D0; };. .. code-block:: c++. // ""from"" context; struct X {; void f(); // D1; };; void X::f() {} // D2. When we import the prototype and the definition of ``f`` from the ""from""; context, then the resulting redecl chain will look like this ``D0 -> D2'``,; where ``D2'`` is the copy of ``D2`` in the ""to"" context. .. Redecl chains of other declarations. Generally speaking, when we import declarations (like enums and classes) we do; attach the newly imported declaration to the existing redeclaration chain (if; there is structural equivalency). We do not import, however, the whole; redeclaration chain as we do in case of functions. Up till now, we haven't; found any essential property of forward declarations which is similar to the; case of the virtual flag in a member function prototype. In the future, this; may change, though.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:96826,simpl,simply,96826,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['simpl'],['simply']
Usability,"f the successors, we forward the edge; from the predecessor to the successor by duplicating the contents of this; block. An example of when this can occur is code like this:. .. code-block:: c++. if () { ...; X = 4;; }; if (X < 3) {. In this case, the unconditional branch at the end of the first if can be; revectored to the false side of the second if. .. _passes-lcssa:. ``lcssa``: Loop-Closed SSA Form Pass; ------------------------------------. This pass transforms loops by placing phi nodes at the end of the loops for all; values that are live across the loop boundary. For example, it turns the left; into the right code:. .. code-block:: c++. for (...) for (...); if (c) if (c); X1 = ... X1 = ...; else else; X2 = ... X2 = ...; X3 = phi(X1, X2) X3 = phi(X1, X2); ... = X3 + 4 X4 = phi(X3); ... = X4 + 4. This is still valid LLVM; the extra phi nodes are purely redundant, and will be; trivially eliminated by ``InstCombine``. The major benefit of this; transformation is that it makes many other loop optimizations, such as; ``LoopUnswitch``\ ing, simpler. You can read more in the; :ref:`loop terminology section for the LCSSA form <loop-terminology-lcssa>`. .. _passes-licm:. ``licm``: Loop Invariant Code Motion; ------------------------------------. This pass performs loop invariant code motion, attempting to remove as much; code from the body of a loop as possible. It does this by either hoisting code; into the preheader block, or by sinking code to the exit blocks if it is safe.; This pass also promotes must-aliased memory locations in the loop to live in; registers, thus hoisting and sinking ""invariant"" loads and stores. Hoisting operations out of loops is a canonicalization transform. It enables; and simplifies subsequent optimizations in the middle-end. Rematerialization; of hoisted instructions to reduce register pressure is the responsibility of; the back-end, which has more accurate information about register pressure and; also handles other optimizations than LICM",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst:23285,simpl,simpler,23285,interpreter/llvm-project/llvm/docs/Passes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst,1,['simpl'],['simpler']
Usability,"f you experience unexpected problems related to the likelihood evaluation, you; can revert back to the old backend by passing `RooFit::EvalBackend(""legacy"")`; to `RooAbsPdf::fitTo()` or `RooAbsPdf::createNLL()`. In case you observe any slowdowns with the new likelihood evaluation, please; open a GitHub issue about this, as such a performance regression is considered; a bug. ### Asymptotically correct uncertainties for extended unbinned likelihood fits. Added correct treatment of extended term in asymptotically correct method for uncertainty determination in the presence of weights.; This improvement will allow for extended unbinned maximum likelihood fits to use the asymptotically correct method when using the `RooFit::AsymptoticError()` command argument in [RooAbsPdf::fitTo()](https://root.cern.ch/doc/master/classRooAbsPdf.html#ab0721374836c343a710f5ff92a326ff5).; See also this [writeup on extended weighted fits](https://root.cern/files/extended_weighted_fits.pdf) that is also linked from the reference guide.; The [pull request](https://github.com/root-project/root/pull/14751) that introduced this feature might also be a good reference. ### Compile your code with memory safe interfaces. If you define the `ROOFIT_MEMORY_SAFE_INTERFACES` preprocessor macro, the; RooFit interface changes in a way such that memory leaks are avoided. The most prominent effect of this change is that many functions that used to; return an owning pointer (e.g., a pointer to an object that you need to; manually `delete`) are then returning a `std::unique_pt` for automatic memory; management. For example this code would not compile anymore, because there is the risk that; the caller forgets to `delete params`:; ```c++; RooArgSet * params = pdf.getParameters(nullptr);; ```; If you wrap such return values in a `std::unique_ptr`, then your code will; compile both with and without memory safe interfaces:; ```c++; std::unique_ptr<RooArgSet> params{pdf.getParameters(nullptr)};; ```. Also some `vir",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md:8240,guid,guide,8240,README/ReleaseNotes/v632/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md,1,['guid'],['guide']
Usability,"failure. In the last case the file cannot be used; anymore. ## Remotely Access to ROOT Files. ROOT files can be accessed remotely in many ways, on the base of the protocol; URL. Among the most popular are XRootD (protocols 'root://' and 'xrd://') and; a Web server (protocl 'http://' or 'https://'). The rootd daemon is deprecated and has been removed in version 6.16/00. Please refer to the XRootD documentation for starting and ensuring that such a; daemon is running. Reading and writing ROOT files over the net can be done by creating a; **`TFile`** object using the static method **`TFile::Open()`** object.; This will instantiate the appropriate derivation of **`TFile`** to handle the; request. Inheriting from the **`TFile`** class, the returned instance will have; exactly the same interface and behavior of **`TFile`**. The only difference; is that it reads and writes from a remote service.; In the example below the file is read via a web server through the TDavixFile plug-in. ### A Simple Session. ``` {.cpp}; root[] TFile *f1 = TFile::Open(""local/file.root"",""update""); root[] TFile *f2 = TFile::Open(""root://my.server.org/data/file.root"",""new""); root[] TFile *f3 = TFile::Open(""http://root.cern.ch/files/hsimple.root""); root[] f3.ls(); TDavixFile** http://root.cern.ch/files/hsimple.root; TDavixFile* http://root.cern.ch/files/hsimple.root; KEY: TH1F hpx;1 This is the px distribution; KEY: TH2F hpxpy;1 py vs px; KEY: TProfile hprof;1 Profile of pz versus px; KEY: TNtuple ntuple;1 Demo ntuple; root[] hpx.Draw(); ```. ## XML Interface. A new module `xml` as implemented by Sergey Linev (GSI). It is an; optional package that can be used to save a canvas into `file.xml` file; format instead of `file.root`. XML files do not have any advantages; compared to the normal ROOT files, except that the information in these; files can be edited via a normal editor. The main motivation for this; new format is to facilitate the communication with other non ROOT; applications. Currently wri",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:96434,Simpl,Simple,96434,documentation/users-guide/InputOutput.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md,1,['Simpl'],['Simple']
Usability,"fcmp one double %x, %y		; <i1> [#uses=1]; 	%tmp345 = zext i1 %tmp3 to i32		; <i32> [#uses=1]; 	ret i32 %tmp345; }. define i32 @test3(double %x, double %y) nounwind {; entry:; 	%tmp3 = fcmp ugt double %x, %y		; <i1> [#uses=1]; 	%tmp34 = zext i1 %tmp3 to i32		; <i32> [#uses=1]; 	ret i32 %tmp34; }. //===---------------------------------------------------------------------===//; for the following code:. void foo (float *__restrict__ a, int *__restrict__ b, int n) {; a[n] = b[n] * 2.321;; }. we load b[n] to GPR, then move it VSX register and convert it float. We should ; use vsx scalar integer load instructions to avoid direct moves. //===----------------------------------------------------------------------===//; ; RUN: llvm-as < %s | llc -march=ppc32 | not grep fneg. ; This could generate FSEL with appropriate flags (FSEL is not IEEE-safe, and ; ; should not be generated except with -enable-finite-only-fp-math or the like).; ; With the correctness fixes for PR642 (58871) LowerSELECT_CC would need to; ; recognize a more elaborate tree than a simple SETxx. define double @test_FNEG_sel(double %A, double %B, double %C) {; %D = fsub double -0.000000e+00, %A ; <double> [#uses=1]; %Cond = fcmp ugt double %D, -0.000000e+00 ; <i1> [#uses=1]; %E = select i1 %Cond, double %B, double %C ; <double> [#uses=1]; ret double %E; }. //===----------------------------------------------------------------------===//; The save/restore sequence for CR in prolog/epilog is terrible:; - Each CR subreg is saved individually, rather than doing one save as a unit.; - On Darwin, the save is done after the decrement of SP, which means the offset; from SP of the save slot can be too big for a store instruction, which means we; need an additional register (currently hacked in 96015+96020; the solution there; is correct, but poor).; - On SVR4 the same thing can happen, and I don't think saving before the SP; decrement is safe on that target, as there is no red zone. This is currently; broken AFAIK, althou",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/README.txt:12744,simpl,simple,12744,interpreter/llvm-project/llvm/lib/Target/PowerPC/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/README.txt,1,['simpl'],['simple']
Usability,"fer to the `error handling <https://llvm.org/docs/ProgrammersManual.html#recoverable-errors>`_ documentation for details. .. code-block:: cpp. if (!ImportedOrErr) {; llvm::Error Err = ImportedOrErr.takeError();; llvm::errs() << ""ERROR: "" << Err << ""\n"";; consumeError(std::move(Err));; return 1;; }. If there's no error then we can get the underlying value.; In this example we will print the AST of the ""to"" context. .. code-block:: cpp. Decl *Imported = *ImportedOrErr;; Imported->getTranslationUnitDecl()->dump();. Since we set **minimal import** in the constructor of the importer, the AST will not contain the declaration of the members (once we run the test tool). .. code-block:: bash. TranslationUnitDecl 0x68b9a8 <<invalid sloc>> <invalid sloc>; `-CXXRecordDecl 0x6c7e30 <line:2:7, col:13> col:13 class MyClass definition; `-DefinitionData pass_in_registers standard_layout trivially_copyable trivial literal; |-DefaultConstructor exists trivial needs_implicit; |-CopyConstructor simple trivial has_const_param needs_implicit implicit_has_const_param; |-MoveConstructor exists simple trivial needs_implicit; |-CopyAssignment trivial has_const_param needs_implicit implicit_has_const_param; |-MoveAssignment exists simple trivial needs_implicit; `-Destructor simple irrelevant trivial needs_implicit. We'd like to get the members too, so, we use ``ImportDefinition`` to copy the whole definition of ``MyClass`` into the ""to"" context.; Then we dump the AST again. .. code-block:: cpp. if (llvm::Error Err = Importer.ImportDefinition(From)) {; llvm::errs() << ""ERROR: "" << Err << ""\n"";; consumeError(std::move(Err));; return 1;; }; llvm::errs() << ""Imported definition.\n"";; Imported->getTranslationUnitDecl()->dump();. This time the AST is going to contain the members too. .. code-block:: bash. TranslationUnitDecl 0x68b9a8 <<invalid sloc>> <invalid sloc>; `-CXXRecordDecl 0x6c7e30 <line:2:7, col:13> col:13 class MyClass definition; |-DefinitionData pass_in_registers standard_layout trivial",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst:6711,simpl,simple,6711,interpreter/llvm-project/clang/docs/LibASTImporter.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst,4,['simpl'],['simple']
Usability,"fer; contains all simple data members of all the classes that make up this; particular object. Data members that are references (as; `MyClass &fObj;`) are never saved, it is always the responsibility of; the object's constructor to set them properly. ### Automatically Generated Streamers. A `Streamer `usually calls other `Streamers`: the `Streamer `of its; parents and data members. This architecture depends on all classes; having `Streamers`, because eventually they will be called. To ensure; that a class has a `Streamer`, `rootcling` automatically creates one in; the `ClassDef` macro that is defined in `$ROOTSYS/include/Rtypes.h`.; `ClassDef` defines several methods for any class, and one of them is the; `Streamer`. The automatically generated `Streamer `is complete and can; be used as long as no customization is needed. The `Event` class is defined in `$ROOTSYS/test/Event.h`. Looking at the; class definition, we find that it inherits from **`TObject`**. It is a; simple example of a class with diverse data members. ``` {.cpp}; class Event : public TObject {; private:; TDirectory *fTransient; //! current directory; Float_t fPt; //! transient value; char fType[20];; Int_t fNtrack;; Int_t fNseg;; Int_t fNvertex;; UInt_t fFlag;; Float_t fTemperature;; EventHeader fEvtHdr; //|| don't split; TClonesArray *fTracks; //->; TH1F *fH; //->; Int_t fMeasures[10];; Float_t fMatrix[4][4];; Float_t *fClosestDistance; //[fNvertex]; ...; ```. The Event class is added to the dictionary by the `rootcling`; utility. This is the `rootcling` statement in the; `$ROOTSYS/test/Makefile`:. ``` {.cpp}; @rootcling -f EventDict.cxx -c Event.h EventLinkDef.h; ```. The `EventDict.cxx` file contains the automatically generated; `Streamer `for Event:. ``` {.cpp}; void Event::Streamer(TBuffer &R__b){; // Stream an object of class Event.; if (R__b.IsReading()) {; Event::Class()->ReadBuffer(R__b, this);; } else {; Event::Class()->WriteBuffer(R__b, this);; }; }; ```. When writing an `Event` object, `TC",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:44250,simpl,simple,44250,documentation/users-guide/InputOutput.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md,1,['simpl'],['simple']
Usability,"ferent libraries interact; due to macro collisions, and users are forced to reorder; ``#include`` directives or introduce ``#undef`` directives to break; the (unintended) dependency. * **Conventional workarounds**: C programmers have; adopted a number of conventions to work around the fragility of the; C preprocessor model. Include guards, for example, are required for; the vast majority of headers to ensure that multiple inclusion; doesn't break the compile. Macro names are written with; ``LONG_PREFIXED_UPPERCASE_IDENTIFIERS`` to avoid collisions, and some; library/framework developers even use ``__underscored`` names; in headers to avoid collisions with ""normal"" names that (by; convention) shouldn't even be macros. These conventions are a; barrier to entry for developers coming from non-C languages, are; boilerplate for more experienced developers, and make our headers; far uglier than they should be. * **Tool confusion**: In a C-based language, it is hard to build tools; that work well with software libraries, because the boundaries of; the libraries are not clear. Which headers belong to a particular; library, and in what order should those headers be included to; guarantee that they compile correctly? Are the headers C, C++,; Objective-C++, or one of the variants of these languages? What; declarations in those headers are actually meant to be part of the; API, and what declarations are present only because they had to be; written as part of the header file?. Semantic import; ---------------; Modules improve access to the API of software libraries by replacing the textual preprocessor inclusion model with a more robust, more efficient semantic model. From the user's perspective, the code looks only slightly different, because one uses an ``import`` declaration rather than a ``#include`` preprocessor directive:. .. code-block:: c. import std.io; // pseudo-code; see below for syntax discussion. However, this module import behaves quite differently from the corresp",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:3425,clear,clear,3425,interpreter/llvm-project/clang/docs/Modules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst,1,['clear'],['clear']
Usability,"ficient instead; of complicating the API. Right now I have no preference or objections between the alternatives but there; are some random thoughts:. * Maybe it would be great to have a guideline how to evolve the analyzer and; follow it, so it can help us to decide in similar situations. * I do care about performance in this case. The reason is that we have a; limited performance budget. And I think we should not expect most of the checker; writers to add modeling of language constructs. So, in my opinion, it is ok to; have less nice/more verbose API for language modeling if we can have better; performance this way, since it only needs to be done once, and is done by the; framework developers. **Artem:** These are some great questions, i guess it'd be better to discuss; them more openly. As a quick dump of my current mood:. * To me it seems obvious that we need to aim for a checker API that is both; simple and powerful. This can probably by keeping the API as powerful as; necessary while providing a layer of simple ready-made solutions on top of it.; Probably a few reusable components for assembling checkers. And this layer; should ideally be pleasant enough to work with, so that people would prefer to; extend it when something is lacking, instead of falling back to the complex; omnipotent API. I'm thinking of AST matchers vs. AST visitors as a roughly; similar situation: matchers are not omnipotent, but they're so nice. * Separation between core and checkers is usually quite strange. Once we have; shared state traits, i generally wouldn't mind having region store or range; constraint manager as checkers (though it's probably not worth it to transform; them - just a mood). The main thing to avoid here would be the situation when; the checker overwrites stuff written by the core because it thinks it has a; better idea what's going on, so the core should provide a good default behavior. * Yeah, i totally care about performance as well, and if i try to implement; appr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst:6338,simpl,simple,6338,interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst,1,['simpl'],['simple']
Usability,"file. Its purpose is similar to TParallelMergingFile,; but instead of using processes that connect to a network; socket, TBufferMerger uses threads that each write to a; TBufferMergerFile, which in turn push data into a queue; managed by the TBufferMerger. An excerpt of the; [tutorial](https://github.com/root-project/root/blob/master/tutorials/multicore/mt103_fillNtuples.C); is shown below.; ```{.cpp}; // Create the TBufferMerger; TBufferMerger merger(""mp103_fillNtuple.root"");. // Define what each worker will do; auto work_function = [&]() {; auto f = merger.GetFile();; TNtuple ntrand(""ntrand"", ""Random Numbers"", ""r"");; fill(ntrand, nEventsPerWorker);; ntrand.Write();; f->Write();; };; ```. ## Language Bindings. - Add in PyROOT the converter for std::string_view; - Fix ROOT-8811: pickling of ROOT.Long now works; - Fix ROOT-8809: push_back on a vector of pointers; - Fix ROOT-8805: itemsize was not set on buffers returned by PyROOT functions. ## JavaScript ROOT. ## Tutorials. ## Class Reference Guide. ## Build, Configuration and Testing Infrastructure. - rlibmap has been removed; it was deprecated for three years.; - Added the CMake exported ROOT libraries into the ROOT:: namespace. In this way, projects based on CMake using ROOT can avoid; conflicts in library target names. As an example, this is the way to build a project consisting of one library and one; executable using ROOT.; ```; find_package(ROOT REQUIRED); include(${ROOT_USE_FILE}). include_directories(${CMAKE_SOURCE_DIR} ${ROOT_INCLUDE_DIRS}); add_definitions(${ROOT_CXX_FLAGS}). ROOT_GENERATE_DICTIONARY(G__Event Event.h LINKDEF EventLinkDef.h). add_library(Event SHARED Event.cxx G__Event.cxx); target_link_libraries(Event ROOT::Hist ROOT::Tree). add_executable(Main MainEvent.cxx); target_link_libraries(Main Event); ```; - Added option `builtin_all` to enable all the built in options.; - For rootcling_stage1 (formerly known as rootcling_tmp), the package structure was changed to enable homogenous visibility; se",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v610/index.md:17443,Guid,Guide,17443,README/ReleaseNotes/v610/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v610/index.md,1,['Guid'],['Guide']
Usability,"filing tests are very limited, and generating the profile takes a; significant amount of time, but it can result in a significant improvement in; the performance of the generated binaries. In addition to PGO profiling we also have limited support in-tree for generating; linker order files. These files provide the linker with a suggested ordering for; functions in the final binary layout. This can measurably speed up clang by; physically grouping functions that are called temporally close to each other.; The current tooling is only available on Darwin systems with ``dtrace(1)``. It; is worth noting that dtrace is non-deterministic, and so the order file; generation using dtrace is also non-deterministic. Options for Reducing Size; =========================. .. warning::; Any steps taken to reduce the binary size will come at a cost of runtime; performance in the generated binaries. The simplest and least significant way to reduce binary size is to set the; *CMAKE_BUILD_TYPE* variable to ``MinSizeRel``, which will set the compiler; optimization level to ``-Os`` which optimizes for binary size. This will have; both the least benefit to size and the least impact on performance. The most impactful way to reduce binary size is to dynamically link LLVM into; all the tools. This reduces code size by decreasing duplication of common code; between the LLVM-based tools. This can be done by setting the following two; CMake options to ``On``: *LLVM_BUILD_LLVM_DYLIB* and *LLVM_LINK_LLVM_DYLIB*. .. warning::; Distributions should never be built using the *BUILD_SHARED_LIBS* CMake; option. (:ref:`See the warning above for more explanation <shared_libs>`.). Relevant CMake Options; ======================. This section provides documentation of the CMake options that are intended to; help construct distributions. This is not an exhaustive list, and many; additional options are documented in the :doc:`CMake` page. Some key options; that are already documented include: *LLVM_TARGETS_TO_B",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BuildingADistribution.rst:10031,simpl,simplest,10031,interpreter/llvm-project/llvm/docs/BuildingADistribution.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BuildingADistribution.rst,1,['simpl'],['simplest']
Usability,"first and simplest to use is the compiler optimization level by setting the; *CMAKE_BUILD_TYPE* option. The main values of interest are ``Release`` or; ``RelWithDebInfo``. By default the ``Release`` option uses the ``-O3``; optimization level, and ``RelWithDebInfo`` uses ``-O2``. If you want to generate; debug information and use ``-O3`` you can override the; *CMAKE_<LANG>_FLAGS_RELWITHDEBINFO* option for C and CXX.; DistributionExample.cmake does this. Another easy to use option is Link-Time-Optimization. You can set the; *LLVM_ENABLE_LTO* option on your stage-2 build to ``Thin`` or ``Full`` to enable; building LLVM with LTO. These options will significantly increase link time of; the binaries in the distribution, but it will create much faster binaries. This; option should not be used if your distribution includes static archives, as the; objects inside the archive will be LLVM bitcode, which is not portable. The :doc:`AdvancedBuilds` documentation describes the built-in tooling for; generating LLVM profiling information to drive Profile-Guided-Optimization. The; in-tree profiling tests are very limited, and generating the profile takes a; significant amount of time, but it can result in a significant improvement in; the performance of the generated binaries. In addition to PGO profiling we also have limited support in-tree for generating; linker order files. These files provide the linker with a suggested ordering for; functions in the final binary layout. This can measurably speed up clang by; physically grouping functions that are called temporally close to each other.; The current tooling is only available on Darwin systems with ``dtrace(1)``. It; is worth noting that dtrace is non-deterministic, and so the order file; generation using dtrace is also non-deterministic. Options for Reducing Size; =========================. .. warning::; Any steps taken to reduce the binary size will come at a cost of runtime; performance in the generated binaries. The simplest ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BuildingADistribution.rst:9096,Guid,Guided-Optimization,9096,interpreter/llvm-project/llvm/docs/BuildingADistribution.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BuildingADistribution.rst,1,['Guid'],['Guided-Optimization']
Usability,"flow (`RET` instructions) can be hijacked; via overwriting the return address (`RA`) on stack.; Various mitigation techniques (e.g. `SafeStack`_, `RFG`_, `Intel CET`_); try to detect or prevent `RA` corruption on stack. RCFI enforces the expected control flow in several different ways described below.; RCFI heavily relies on LTO. Leaf Functions; --------------; If `f()` is a leaf function (i.e. it has no calls; except maybe no-return calls) it can be called using a special calling convention; that stores `RA` in a dedicated register `R` before the `CALL` instruction.; `f()` does not spill `R` and does not use the `RET` instruction,; instead it uses the value in `R` to `JMP` to `RA`. This flavour of CFI is *precise*, i.e. the function is guaranteed to return; to the point exactly following the call. An alternative approach is to; copy `RA` from stack to `R` in the first instruction of `f()`,; then `JMP` to `R`.; This approach is simpler to implement (does not require changing the caller); but weaker (there is a small window when `RA` is actually stored on stack). Functions called once; ---------------------; Suppose `f()` is called in just one place in the program; (assuming we can verify this in LTO mode).; In this case we can replace the `RET` instruction with a `JMP` instruction; with the immediate constant for `RA`.; This will *precisely* enforce the return control flow no matter what is stored on stack. Another variant is to compare `RA` on stack with the known constant and abort; if they don't match; then `JMP` to the known constant address. Functions called in a small number of call sites; ------------------------------------------------; We may extend the above approach to cases where `f()`; is called more than once (but still a small number of times).; With LTO we know all possible values of `RA` and we check them; one-by-one (or using binary search) against the value on stack.; If the match is found, we `JMP` to the known constant address, otherwise abort. T",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst:25126,simpl,simpler,25126,interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst,1,['simpl'],['simpler']
Usability,"for GPU and optimized for speed and with multi-class support. ; * `Architecture=GPU` to select the newer GPU version. Requires configuration of ROOT with CUDA or OpenCL enabled. ; * Support for Cross Validation (see tutorial `tmva/TMVACrossValidation` as an example).; * Support for Hyper-Parameter tuning for BDT and SVM methods.; * New Variable Importance algorithm independent of the MVA method.; * New Loss Function class for regression.; * Improvements in the SVM method: new kernel functions.; * New `ROCCurve` class. ; * New interface to Keras (PyKeras) available in the PyMVA library.; * Support for Jupyter notebooks; * Support for all the functionality available in GUI: preprocessing, variable correlations, classifier output.; * New classifier visualization for BDT, ANN and DNN.; * Interactive training for all methods. ## 2D Graphics Libraries. * In `TColor::SetPalette`, make sure the high quality palettes are defined; only once taking care of transparency. Also `CreateGradientColorTable` has been; simplified.; * New fast constructor for `TColor` avoiding to call `gROOT->GetColor()`. The; normal constructor generated a big slow down when creating a Palette with; `CreateGradientColorTable`.; * In `CreateGradientColorTable` we do not need anymore to compute the highest; color index.; * In `TGraphPainter`, when graphs are painted with lines, they are split into; chunks of length `fgMaxPointsPerLine`. This allows to paint line with an ""infinite""; number of points. In some case this ""chunks painting"" technic may create artefacts; at the chunk's boundaries. For instance when zooming deeply in a PDF file. To avoid; this effect it might be necessary to increase the chunks' size using the new function:; `TGraphPainter::SetMaxPointsPerLine(20000)`.; * When using line styles different from 1 (continuous line), the behavior of TArrow; was suboptimal. The problem was that the line style is also applied to the arrow; head, which is usually not what one wants.; The arrow tip is ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v608/index.md:13951,simpl,simplified,13951,README/ReleaseNotes/v608/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v608/index.md,1,['simpl'],['simplified']
Usability,"for `loop induction; variables <LangImpl05.html#for-loop-expression>`_ in the symbol table, and for `local; variables <LangImpl07.html#user-defined-local-variables>`_. .. code-block:: c++. Value *BinaryExprAST::codegen() {; Value *L = LHS->codegen();; Value *R = RHS->codegen();; if (!L || !R); return nullptr;. switch (Op) {; case '+':; return Builder->CreateFAdd(L, R, ""addtmp"");; case '-':; return Builder->CreateFSub(L, R, ""subtmp"");; case '*':; return Builder->CreateFMul(L, R, ""multmp"");; case '<':; L = Builder->CreateFCmpULT(L, R, ""cmptmp"");; // Convert bool 0/1 to double 0.0 or 1.0; return Builder->CreateUIToFP(L, Type::getDoubleTy(TheContext),; ""booltmp"");; default:; return LogErrorV(""invalid binary operator"");; }; }. Binary operators start to get more interesting. The basic idea here is; that we recursively emit code for the left-hand side of the expression,; then the right-hand side, then we compute the result of the binary; expression. In this code, we do a simple switch on the opcode to create; the right LLVM instruction. In the example above, the LLVM builder class is starting to show its; value. IRBuilder knows where to insert the newly created instruction,; all you have to do is specify what instruction to create (e.g. with; ``CreateFAdd``), which operands to use (``L`` and ``R`` here) and; optionally provide a name for the generated instruction. One nice thing about LLVM is that the name is just a hint. For instance,; if the code above emits multiple ""addtmp"" variables, LLVM will; automatically provide each one with an increasing, unique numeric; suffix. Local value names for instructions are purely optional, but it; makes it much easier to read the IR dumps. `LLVM instructions <../../LangRef.html#instruction-reference>`_ are constrained by strict; rules: for example, the Left and Right operands of an `add; instruction <../../LangRef.html#add-instruction>`_ must have the same type, and the; result type of the add must match the operand types. Because all ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst:7184,simpl,simple,7184,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst,1,['simpl'],['simple']
Usability,"for constructor failure; Not resolved. 2624; C++23; Array delete expression with no array cookie; Unknown. 2625; C++23; Deletion of pointer to out-of-lifetime object; Unknown. 2626; C++23; Rephrase ones' complement using base-2 representation; Unknown. 2627; C++23; Bit-fields and narrowing conversions; Unknown. 2628; DR; Implicit deduction guides should propagate constraints; No. 2629; C++23; Variables of floating-point type as switch conditions; Unknown. 2630; C++23; Syntactic specification of class completeness; Unknown. 2631; C++23; Immediate function evaluations in default arguments; Clang 16. 2632; review; 'user-declared' is not defined; Not resolved. 2633; open; typeid of constexpr-unknown dynamic type; Not resolved. 2634; tentatively ready; Avoid circularity in specification of scope for friend class declarations; Unknown. 2635; C++23; Constrained structured bindings; Clang 16. 2636; C++23; Update Annex E based on Unicode 15.0 UAX #31; N/A. 2637; tentatively ready; Injected-class-name as a simple-template-id; Unknown. 2638; tentatively ready; Improve the example for initializing by initializer list; Unknown. 2639; C++23; new-lines after phase 1; Unknown. 2640; C++23; Allow more characters in an n-char sequence; Clang 16. 2641; C++23; Redundant specification of value category of literals; Unknown. 2642; C++23; Inconsistent use of T and C; N/A. 2643; C++23; Completing a pointer to array of unknown bound; Unknown. 2644; C++23; Incorrect comment in example; Clang 8. 2645; C++23; Unused term ""default argument promotions""; Unknown. 2646; C++23; Defaulted special member functions; Unknown. 2647; C++23; Fix for ""needed for constant evaluation""; Unknown. 2648; C++23; Correspondence of surrogate call function and conversion function; Unknown. 2649; C++23; Incorrect note about implicit conversion sequence; Unknown. 2650; C++23; Incorrect example for ill-formed non-type template arguments; Clang 17. 2651; C++23; Conversion function templates and ""noexcept""; Unknown. 2652;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:181797,simpl,simple-template-id,181797,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['simpl'],['simple-template-id']
Usability,"for resumption prior to a call to; `async_op` function that may trigger resumption of a coroutine from the same or; a different thread possibly prior to `async_op` call returning control back; to the coroutine:. .. code-block:: llvm. %save1 = call token @llvm.coro.save(ptr %hdl); call void @async_op1(ptr %hdl); %suspend1 = call i1 @llvm.coro.suspend(token %save1, i1 false); switch i8 %suspend1, label %suspend [i8 0, label %resume1; i8 1, label %cleanup]. .. _coro.suspend.async:. 'llvm.coro.suspend.async' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; ::. declare {ptr, ptr, ptr} @llvm.coro.suspend.async(; ptr <resume function>,; ptr <context projection function>,; ... <function to call>; ... <arguments to function>). Overview:; """""""""""""""""". The '``llvm.coro.suspend.async``' intrinsic marks the point where; execution of an async coroutine is suspended and control is passed to a callee. Arguments:; """""""""""""""""""". The first argument should be the result of the `llvm.coro.async.resume` intrinsic.; Lowering will replace this intrinsic with the resume function for this suspend; point. The second argument is the `context projection function`. It should describe; how-to restore the `async context` in the continuation function from the first; argument of the continuation function. Its type is `ptr (ptr)`. The third argument is the function that models transfer to the callee at the; suspend point. It should take 3 arguments. Lowering will `musttail` call this; function. The fourth to six argument are the arguments for the third argument. Semantics:; """""""""""""""""""". The result of the intrinsic are mapped to the arguments of the resume function.; Execution is suspended at this intrinsic and resumed when the resume function is; called. .. _coro.prepare.async:. 'llvm.coro.prepare.async' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; ::. declare ptr @llvm.coro.prepare.async(ptr <coroutine function>). Overview:; """""""""""""""""". The '``llvm.coro.prepare.async``' intrinsic is used t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:53719,resume,resume,53719,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"form of a; README file, mission statement, and/or manifesto.; * Should conform to coding standards, incremental development process, and; other expectations.; * Should have a sense of the community that it hopes to eventually foster, and; there should be interest from members with different affiliations /; organizations.; * Should have a feasible path to eventually graduate as a dedicated top-level; or sub-project within the `LLVM monorepo; <https://github.com/llvm/llvm-project>`_.; * Should include a notice (e.g. in the project README or web page) that the; project is in ‘incubation status’ and is not included in LLVM releases (see; suggested wording below).; * Must be proposed through the LLVM RFC process, and have its addition; approved by the LLVM community - this ultimately mediates the resolution of; the ""should"" concerns above. That said, the project need not have any code to get started, and need not have; an established community at all! Furthermore, incubating projects may pass; through transient states that violate the ""Should"" guidelines above, or would; otherwise make them unsuitable for direct inclusion in the monorepo (e.g.; dependencies that have not yet been factored appropriately, leveraging; experimental components or APIs that are not yet upstream, etc). When approved, the llvm-admin group can grant the new project:; * A new repository in the LLVM Github Organization - but not the LLVM monorepo.; * New mailing list, discourse forum, and/or discord chat hosted with other LLVM; forums.; * Other infrastructure integration can be discussed on a case-by-case basis. Graduation to the mono-repo would follow existing processes and standards for; becoming a first-class part of the monorepo. Similarly, an incubating project; may be eventually retired, but no process has been established for that yet. If; and when this comes up, please start an RFC discussion on the `LLVM Discourse forums`_. This process is very new - please expect the details to change, it",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst:49128,guid,guidelines,49128,interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,1,['guid'],['guidelines']
Usability,"format suitable to your needs, see documentation of; class `TCanvas`:. ``` {.cpp}; TCanvas c1(""c1"",""<Title>"",0,0,400,300); // create a canvas, specify position and size in pixels; c1.Divide(2,2); //set subdivisions, called pads; c1.cd(1); //change to pad 1 of canvas c1; ```. These parts of a well-written macro are pretty standard, and you should; remember to include pieces of code like in the examples above to make; sure your plots always look as you had intended. Below, in section [Interpretation and Compilation](#interpretation-and-compilation), some more code fragments; will be shown, allowing you to use the system compiler to compile macros for; more efficient execution, or turn macros into stand-alone applications linked; against the ROOT libraries. ## A more complete example ##. Let us now look at a rather complete example of a typical task in data; analysis, a macro that constructs a graph with errors, fits a (linear); model to it and saves it as an image. To run this macro, simply type in; the shell:. ``` {.cpp}; > root macro1.C; ```. The code is built around the ROOT class `TGraphErrors`, which was; already introduced previously. Have a look at it in the class reference; guide, where you will also find further examples. The macro shown below; uses additional classes, `TF1` to define a function, `TCanvas` to define; size and properties of the window used for our plot, and `TLegend` to; add a nice legend. For the moment, ignore the commented include; statements for header files, they will only become important at the end; in section [Interpretation and Compilation](#interpretation-and-compilation). ``` {.cpp .numberLines}; @ROOT_INCLUDE_FILE macros/macro1.C; ```. Let's comment it in detail:. - Line *13*: the name of the principal function (it plays the role of; the ""main"" function in compiled programs) in the macro file. It has; to be the same as the file name without extension. - Line *24-25*: instance of the `TGraphErrors` class. The constructor; takes the n",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/your_first_ROOT_macro.md:2759,simpl,simply,2759,documentation/primer/your_first_ROOT_macro.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/your_first_ROOT_macro.md,1,['simpl'],['simply']
Usability,"found on the; [MINUIT Web Site](http://www.cern.ch/minuit). Minuit2, originally developed in the SEAL project, is now distributed within %ROOT.; The API has been then changed in this new version to follow the %ROOT coding convention; (function names starting with capital letters) and the classes have been moved inside; the namespace _ROOT::Minuit2_. In addition, the %ROOT distribution contains classes; needed to integrate Minuit2 in the %ROOT framework. A new class has been introduced, ROOT::Minuit2::Minuit2Minimizer, which implements; the interface ROOT::Math::Minimizer. Within %ROOT, it can be instantiates also using; the %ROOT plug-in manager. This class provides a convenient entry point for using Minuit2\.; An example of using this interface is the %ROOT tutorial _tutorials/fit/NumericalMinimization.C_; or the Minuit2 test program; [<tt>testMinimize.cxx</tt>](https://github.com/cxx-hep/root-cern/blob/master/math/minuit2/test/testMinimize.cxx). A standalone version of Minuit2 (independent of %ROOT) can be easily built and installed using `CMake`. See this [`README`](https://github.com/root-project/root/blob/master/math/minuit2/README.md) for the instructions on how to get the sources, building and installing a stand-alone Minuit2. The [Minuit2 User Guide](https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html); provides all the information needed for using directly (without add-on packages like %ROOT) Minuit2. ## References. 1. F. James, _Fortran MINUIT Reference Manual_ ([html](https://cern-tex.web.cern.ch/cern-tex/minuit/minmain.html));; 2. F. James and M. Winkler, _C++ MINUIT User's Guide_ ([html](https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html) and [pdf](https://root.cern/root/htmldoc/guides/minuit2/Minuit2.pdf));; 3. F. James, _Minuit Tutorial on Function Minimization_ ([pdf](http://seal.cern.ch/documents/minuit/mntutorial.pdf));; 4. F. James, _The Interpretation of Errors in Minuit_ ([pdf](http://seal.cern.ch/documents/minuit/mnerror.pdf));; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/doc/Minuit2.md:1923,Guid,Guide,1923,math/minuit2/doc/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/doc/Minuit2.md,4,"['Guid', 'guid']","['Guide', 'guides']"
Usability,"from C++ functions to pure Python bindings using the; public cppyy API. This helps in the integration with the tool but also improves code efficiency and memory usage. ## Class Reference Guide. - Define missing doxygen groups.; - Fix a few typos in the `THStack` documentation.; - Small fixes in the `THistPainter` documentation.; - Improve the `TColor` documentation: use modern C++ in the examples.; - Make sure the python examples do not generate wrong namespaces in the documentation.; - The dataframe tutorials json spec files were not displayed properly. Moreover there was; no direct correspondence between the code source and the json file. Those files do not; have any doc in them. With a direct link to the GitHub source file the dependency between source; code and json is now more obvious.; - Document how to remove shadow of `TPave`, as it was not evident (only explanations were hidden here and there in the forum).; - Improve the `SetFillColorAlpha` documentation.; - Simplify some graphics examples: arrow.C, crown.C, diamond.C and ellipse.C.; - Fix a typo in the documentation of `TGraph::SetHighlight` in `TGraph.cxx`.; - Change the marker style in the tutorial `df014_CSVDataSource`.; - Remove useless settings in the tutorial `scatter.C`.; - Fix the tutorial `h1analysisTreeReader.C`.; - Fix doxygen formatting in `TGNumberEntry.cxx`.; - Avoid the CDT documentation to appear in the reference guide.; - Remove last references to the old ROOT `drupal` website. ## Build, Configuration and Testing Infrastructure. Release v6.32.00 is the first one integrated and tested entirely through the new GitHub based build system. ## Bugs and Issues fixed in this release. More than 200 items were addressed for this release. The full list is:. * [[#15621](https://github.com/root-project/root/issues/15621)] - Buffer overflow in TBranch::Init; * [[#15610](https://github.com/root-project/root/issues/15610)] - Memory leak in TTree __getattr__ pythonization; * [[#15590](https://github.com/ro",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md:24087,Simpl,Simplify,24087,README/ReleaseNotes/v632/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md,1,['Simpl'],['Simplify']
Usability,"fsets into the string table rather than embedding the string's value; directly. The format of this substream is as follows:. .. code-block:: c++. struct FileInfoSubstream {; uint16_t NumModules;; uint16_t NumSourceFiles;. uint16_t ModIndices[NumModules];; uint16_t ModFileCounts[NumModules];; uint32_t FileNameOffsets[NumSourceFiles];; char NamesBuffer[][NumSourceFiles];; };. **NumModules** - The number of modules for which source file information is; contained within this substream. Should match the corresponding value from the; ref:`dbi_header`. **NumSourceFiles**: In theory this is supposed to contain the number of source; files for which this substream contains information. But that would present a; problem in that the width of this field being ``16``-bits would prevent one from; having more than 64K source files in a program. In early versions of the file; format, this seems to have been the case. In order to support more than this, this; field of the is simply ignored, and computed dynamically by summing up the values of; the ``ModFileCounts`` array (discussed below). In short, this value should be; ignored. **ModIndices** - This array is present, but does not appear to be useful. **ModFileCountArray** - An array of ``NumModules`` integers, each one containing; the number of source files which contribute to the module at the specified index.; While each individual module is limited to 64K contributing source files, the; union of all modules' source files may be greater than 64K. The real number of; source files is thus computed by summing this array. Note that summing this array; does not give the number of `unique` source files, only the total number of source; file contributions to modules. **FileNameOffsets** - An array of **NumSourceFiles** integers (where **NumSourceFiles**; here refers to the 32-bit value obtained from summing **ModFileCountArray**), where; each integer is an offset into **NamesBuffer** pointing to a null terminated string. **NamesBuffer** ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PDB/DbiStream.rst:13457,simpl,simply,13457,interpreter/llvm-project/llvm/docs/PDB/DbiStream.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PDB/DbiStream.rst,1,['simpl'],['simply']
Usability,"ften useful when putting; together quick little hacks like the Kaleidoscope compiler itself.; Fortunately, our current setup makes it very easy to add global; variables: just have value lookup check to see if an unresolved; variable is in the global variable symbol table before rejecting it.; To create a new global variable, make an instance of the LLVM; ``GlobalVariable`` class.; - **typed variables** - Kaleidoscope currently only supports variables; of type double. This gives the language a very nice elegance, because; only supporting one type means that you never have to specify types.; Different languages have different ways of handling this. The easiest; way is to require the user to specify types for every variable; definition, and record the type of the variable in the symbol table; along with its Value\*.; - **arrays, structs, vectors, etc** - Once you add types, you can start; extending the type system in all sorts of interesting ways. Simple; arrays are very easy and are quite useful for many different; applications. Adding them is mostly an exercise in learning how the; LLVM `getelementptr <../../LangRef.html#getelementptr-instruction>`_ instruction; works: it is so nifty/unconventional, it `has its own; FAQ <../../GetElementPtr.html>`_!; - **standard runtime** - Our current language allows the user to access; arbitrary external functions, and we use it for things like ""printd""; and ""putchard"". As you extend the language to add higher-level; constructs, often these constructs make the most sense if they are; lowered to calls into a language-supplied runtime. For example, if; you add hash tables to the language, it would probably make sense to; add the routines to a runtime, instead of inlining them all the way.; - **memory management** - Currently we can only access the stack in; Kaleidoscope. It would also be useful to be able to allocate heap; memory, either with calls to the standard libc malloc/free interface; or with a garbage collector. If you would",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.rst:2421,Simpl,Simple,2421,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.rst,1,['Simpl'],['Simple']
Usability,"ftware and method performance; validation has been implemented.; . Methods. BDT Automatic parameter optimisation for building the; tree architecture: The optimisation procedure uses the; performance of the trained classifier on the ""test sample"" for; finding the set of optimal parameters. Two different methods to; traverse the parameter space are available (scanning, genetic; algorithm). Currently parameter optimization is implemented only; for these three parameters that influence the tree architectur:; the maximum depth of a tree, MaxDepth, the minimum; number of events in each node, NodeMinEvents, and; the number of tress, NTrees. Optimization can; is invoked by calling; factory->OptimizeAllMethods(); prior to the call; factory->TrainAllMethods();. Automated and configurable parameter optimization is soon to; be enabled for all methods (for those parameters where; optimization is applicable).; . BDT node splitting: While Decision Trees; typically have only univariate splits, in TMVA one can now; also opt for multivariate splits that use a ""Fisher; Discriminant"" (option: UseFisherCuts), built from all; observables that show correlations larger than some threshold; (MinLinCorrForFisher). The training will then test at each; split a cut on this fisher discriminant in addition to all; univariate cuts on the variables (or only on those variables; that have not been used in the Fisher discriminant, option; UseExcusiveVars). No obvious improvement betwen very simple; decision trees after boosting has been observed so far, but; only a limited number of studies has been performed concerning; potiential benenfit of these simple multivariate splits.; . Bug fixes. A problem in the BDTG has been fixed, leading to a much; improved regression performance.; A problem in the TMVA::Reader has been fixed.; With the new test framework and the coverity checks of ROOT; a number of bugs were discovered and fixed. They mainly concerned; memory leaks, and did not affect the performance. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/doc/v528/index.html:2961,simpl,simple,2961,tmva/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/doc/v528/index.html,2,['simpl'],['simple']
Usability,"function stored in the coroutine; frame. Destroying a coroutine that is not suspended leads to undefined behavior. .. _coro.resume:. 'llvm.coro.resume' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ::. declare void @llvm.coro.resume(ptr <handle>). Overview:; """""""""""""""""". The '``llvm.coro.resume``' intrinsic resumes a suspended switched-resume coroutine. Arguments:; """""""""""""""""""". The argument is a handle to a suspended coroutine. Semantics:; """""""""""""""""""". When possible, the `coro.resume` intrinsic is replaced with a direct call to the; coroutine resume function. Otherwise it is replaced with an indirect call based; on the function pointer for the resume function stored in the coroutine frame.; Resuming a coroutine that is not suspended leads to undefined behavior. .. _coro.done:. 'llvm.coro.done' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ::. declare i1 @llvm.coro.done(ptr <handle>). Overview:; """""""""""""""""". The '``llvm.coro.done``' intrinsic checks whether a suspended; switched-resume coroutine is at the final suspend point or not. Arguments:; """""""""""""""""""". The argument is a handle to a suspended coroutine. Semantics:; """""""""""""""""""". Using this intrinsic on a coroutine that does not have a `final suspend`_ point; or on a coroutine that is not suspended leads to undefined behavior. .. _coro.promise:. 'llvm.coro.promise' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ::. declare ptr @llvm.coro.promise(ptr <ptr>, i32 <alignment>, i1 <from>). Overview:; """""""""""""""""". The '``llvm.coro.promise``' intrinsic obtains a pointer to a; `coroutine promise`_ given a switched-resume coroutine handle and vice versa. Arguments:; """""""""""""""""""". The first argument is a handle to a coroutine if `from` is false. Otherwise,; it is a pointer to a coroutine promise. The second argument is an alignment requirements of the promise.; If a frontend designated `%promise = alloca i32` as a promise, the alignment; argument to `coro.promise` should be the alignment of `i32` on the target; plat",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:28592,resume,resume,28592,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"functions support temporary ranges, for example:. .. code-block:: c++. for (auto [Letter, Count] : zip(SmallVector<char>{'a', 'b', 'c'}, Counts)); errs() << Letter << "": "" << Count << ""\n"";. The difference between the functions in the ``zip`` family is how they behave; when the supplied ranges have different lengths:. * ``zip_equal`` -- requires all input ranges have the same length.; * ``zip`` -- iteration stops when the end of the shortest range is reached.; * ``zip_first`` -- requires the first range is the shortest one.; * ``zip_longest`` -- iteration continues until the end of the longest range is; reached. The non-existent elements of shorter ranges are replaced with; ``std::nullopt``. The length requirements are checked with ``assert``\ s. As a rule of thumb, prefer to use ``zip_equal`` when you expect all; ranges to have the same lengths, and consider alternative ``zip`` functions only; when this is not the case. This is because ``zip_equal`` clearly communicates; this same-length assumption and has the best (release-mode) runtime performance. .. _uf_enumerate:. ``enumerate``; ^^^^^^^^^^^^^. The ``enumerate`` functions allows to iterate over one or more ranges while; keeping track of the index of the current loop iteration. For example:. .. code-block:: c++. for (auto [Idx, BB, Value] : enumerate(Phi->blocks(),; Phi->incoming_values())); errs() << ""#"" << Idx << "" "" << BB->getName() << "": "" << *Value << ""\n"";. The current element index is provided as the first structured bindings element.; Alternatively, the index and the element value can be obtained with the; ``index()`` and ``value()`` member functions:. .. code-block:: c++. char Letters[26] = ...;; for (auto En : enumerate(Letters)); errs() << ""#"" << En.index() << "" "" << En.value() << ""\n"";. Note that ``enumerate`` has ``zip_equal`` semantics and provides elements; through a 'reference wrapper' proxy, which makes them modifiable when accessed; through structured bindings or the ``value()`` member function.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:101831,clear,clearly,101831,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['clear'],['clearly']
Usability,"fvar`` variables. 5. Make a pass over all the fields to resolve any inter-field references. 6. Add the record to the final record list. Because references between fields are resolved (step 5) after ``let`` bindings are; applied (step 3), the ``let`` statement has unusual power. For example:. .. code-block:: text. class C <int x> {; int Y = x;; int Yplus1 = !add(Y, 1);; int xplus1 = !add(x, 1);; }. let Y = 10 in {; def rec1 : C<5> {; }; }. def rec2 : C<5> {; let Y = 10;; }. In both cases, one where a top-level ``let`` is used to bind ``Y`` and one; where a local ``let`` does the same thing, the results are:. .. code-block:: text. def rec1 { // C; int Y = 10;; int Yplus1 = 11;; int xplus1 = 6;; }; def rec2 { // C; int Y = 10;; int Yplus1 = 11;; int xplus1 = 6;; }. ``Yplus1`` is 11 because the ``let Y`` is performed before the ``!add(Y,; 1)`` is resolved. Use this power wisely. Using Classes as Subroutines; ============================. As described in `Simple values`_, a class can be invoked in an expression; and passed template arguments. This causes TableGen to create a new anonymous; record inheriting from that class. As usual, the record receives all the; fields defined in the class. This feature can be employed as a simple subroutine facility. The class can; use the template arguments to define various variables and fields, which end; up in the anonymous record. Those fields can then be retrieved in the; expression invoking the class as follows. Assume that the field ``ret``; contains the final value of the subroutine. .. code-block:: text. int Result = ... CalcValue<arg>.ret ...;. The ``CalcValue`` class is invoked with the template argument ``arg``. It; calculates a value for the ``ret`` field, which is then retrieved at the; ""point of call"" in the initialization for the Result field. The anonymous; record created in this example serves no other purpose than to carry the; result value. Here is a practical example. The class ``isValidSize`` determines whether a;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst:55047,Simpl,Simple,55047,interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,1,['Simpl'],['Simple']
Usability,"g Linux::. $ g++ `cling-config --cppflags` -fPIC -O2 -shared MyClass_rflx.cxx -o MyClassDict.so. Instead of loading the header text into ``cling``, you can now load the; dictionary:. .. code-block:: python. >>> import cppyy; >>> cppyy.load_reflection_info('MyClassDict'); >>> cppyy.gbl.MyClass(42); <cppyy.gbl.MyClass object at 0x7ffb9f230950>; >>> print(_.get_int()); 42; >>>. and use the selected C++ entities as if the header was loaded. The dictionary shared library can be relocated, as long as it can be found; by the dynamic loader (e.g. through ``LD_LIBRARY_PATH``) and the header file; is fully embedded or still accessible (e.g. through a path added to; ``cppyy.add_include_path`` at run-time, or with ``-I`` to; ``rootcling``/``genreflex`` during build time).; When relocating the shared library, move the .pcm with it.; Once support for C++ modules is fully fleshed out, access to the header file; will no longer be needed. .. _`rootcling manual`: https://root.cern.ch/root/html/guides/users-guide/AddingaClass.html#the-linkdef.h-file; .. _`helper script`: https://github.com/wlav/cppyy/blob/master/test/make_dict_win32.py. Class loader; ^^^^^^^^^^^^. Explicitly loading dictionaries is fine if this is hidden under the hood of; a Python package and thus transparently done on ``import``.; Otherwise, the automatic class loader is more convenient, as it allows direct; use without having to manually find and load dictionaries (assuming these are; locatable by the dynamic loader). The class loader utilizes so-called rootmap files, which by convention should; live alongside the dictionary shared library (and C++ module file).; These are simple text files, which map C++ entities (such as classes) to the; dictionaries and other libraries that need to be loaded for their use. With ``genreflex``, the mapping file can be automatically created with; ``--rootmap-lib=MyClassDict``, where ""MyClassDict"" is the name of the shared; library (without the extension) build from the dictionary fi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/utilities.rst:8008,guid,guides,8008,bindings/pyroot/cppyy/cppyy/doc/source/utilities.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/utilities.rst,2,['guid'],"['guide', 'guides']"
Usability,"g as the `CMakeCache.txt` file is not removed. Remember that after building a tarball or a binary package you should remove the copied files using:. ```bash; make purge; ```. Otherwise git shows the file as untracked, unless you explicitly remove their tracking yourself with a .gitignore file. ## Building a tarball. Minuit2 standalone also has support for CPack to make installers for different platforms. To build a source package:. ```bash; make package_source; ```. This will create a source file in several formats that you can distribute. Reminder: You **must** have used `-Dminuit2_standalone=ON` when you configured CMake, or many of the files will be missing. ## Building a binary. To build a binary package (add other generators with `-G`):; ```bash; make; make package; ```. ## Maintenance. If new files are needed by Minuit2 due to additions to [ROOT], they should be added to the source files lists in `src/Math/CMakeLists.txt` and `src/Minuit2/CMakeLists.txt` (depending on if it's a new Math or Minuit2 requirement). For testing, the main `test/CMakeLists.txt` is used by ROOT, and the `test/*/CMakeLists.txt` files are used by the standalone build. ## How it works. Extracting from the ROOT sources is made possible through a few careful design features:. * A CMake variable `minuit2_inroot` lets the build system know we are inside ROOT (it looks for `../../build/version_info`); * All files that are not part of the minuit2 directory are passed into `copy_standalone`, and that handles selecting the correct location; * `copy_standalone` copies the files into the minuit2 source directory if `minuit2_standalone` is `ON`. After this happens, all the standard CMake machinery can produce the source distribution. And, CMake correctly builds and installs in either mode, since all source and header files are explicitly listed. [ROOT]: https://root.cern; [minuitdoc]: https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html#minuit2-package; [CMake]: https://cmake.org; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/DEVELOP.md:2745,guid,guides,2745,math/minuit2/DEVELOP.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/DEVELOP.md,2,['guid'],"['guide', 'guides']"
Usability,"g classes and records,; which are then processed by TableGen. The internalized records are passed on; to various *backends*, which extract information from a subset of the records; and generate one or more output files. These output files are typically; ``.inc`` files for C++, but may be any type of file that the backend; developer needs. This document describes the LLVM TableGen facility in detail. It is intended; for the programmer who is using TableGen to produce code for a project. If; you are looking for a simple overview, check out the :doc:`TableGen Overview; <./index>`. The various ``*-tblgen`` commands used to invoke TableGen are; described in :doc:`tblgen Family - Description to C++; Code<../CommandGuide/tblgen>`. An example of a backend is ``RegisterInfo``, which generates the register; file information for a particular target machine, for use by the LLVM; target-independent code generator. See :doc:`TableGen Backends <./BackEnds>`; for a description of the LLVM TableGen backends, and :doc:`TableGen; Backend Developer's Guide <./BackGuide>` for a guide to writing a new; backend. Here are a few of the things backends can do. * Generate the register file information for a particular target machine. * Generate the instruction definitions for a target. * Generate the patterns that the code generator uses to match instructions; to intermediate representation (IR) nodes. * Generate semantic attribute identifiers for Clang. * Generate abstract syntax tree (AST) declaration node definitions for Clang. * Generate AST statement node definitions for Clang. Concepts; --------. TableGen source files contain two primary items: *abstract records* and; *concrete records*. In this and other TableGen documents, abstract records; are called *classes.* (These classes are different from C++ classes and do; not map onto them.) In addition, concrete records are usually just called; records, although sometimes the term *record* refers to both classes and; concrete records. The d",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst:1490,Guid,Guide,1490,interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,1,['Guid'],['Guide']
Usability,"g code. The bulk of the code is; generic and should be split into an ELFLinkGraphBuilder base class along the; same lines as the existing generic MachOLinkGraphBuilder. * Implement support for arm32. * Implement support for other new architectures. JITLink Availability and Feature Status; ---------------------------------------. The following table describes the status of the JITlink backends for various; format / architecture combinations (as of July 2023). Support levels:. * None: No backend. JITLink will return an ""architecture not supported"" error.; Represented by empty cells in the table below.; * Skeleton: A backend exists, but does not support commonly used relocations.; Even simple programs are likely to trigger an ""unsupported relocation"" error.; Backends in this state may be easy to improve by implementing new relocations.; Consider getting involved!; * Basic: The backend supports simple programs, isn't ready for general use yet.; * Usable: The backend is useable for general use for at least one code and; relocation model.; * Good: The backend supports almost all relocations. Advanced features like; native thread local storage may not be available yet.; * Complete: The backend supports all relocations and object format features. .. list-table:: Availability and Status; :widths: 10 30 30 30; :header-rows: 1; :stub-columns: 1. * - Architecture; - ELF; - COFF; - MachO; * - arm32; - Skeleton; -; -; * - arm64; - Usable; -; - Good; * - LoongArch; - Good; -; -; * - PowerPC 64; - Usable; -; -; * - RISC-V; - Good; -; -; * - x86-32; - Basic; -; -; * - x86-64; - Good; - Usable; - Good. .. [1] See ``llvm/examples/OrcV2Examples/LLJITWithObjectLinkingLayerPlugin`` for; a full worked example. .. [2] If not for *hidden* scoped symbols we could eliminate the; ``JITLinkDylib*`` argument to ``JITLinkMemoryManager::allocate`` and; treat every object as a separate simulated dylib for the purposes of; memory layout. Hidden symbols break this by generating in-range accesses; to e",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst:45934,Usab,Usable,45934,interpreter/llvm-project/llvm/docs/JITLink.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst,1,['Usab'],['Usable']
Usability,"g on macOS, download; and install the macOS `Graphviz program; <http://www.pixelglow.com/graphviz/>`_ and add; ``/Applications/Graphviz.app/Contents/MacOS/`` (or wherever you install it) to; your path. The programs need not be present when configuring, building or; running LLVM and can simply be installed when needed during an active debug; session. ``SelectionDAG`` has been extended to make it easier to locate *interesting*; nodes in large complex graphs. From gdb, if you ``call DAG.setGraphColor(node,; ""color"")``, then the next ``call DAG.viewGraph()`` would highlight the node in; the specified color (choices of colors can be found at `colors; <http://www.graphviz.org/doc/info/colors.html>`_.) More complex node attributes; can be provided with ``call DAG.setGraphAttrs(node, ""attributes"")`` (choices can; be found at `Graph attributes <http://www.graphviz.org/doc/info/attrs.html>`_.); If you want to restart and clear all the current graph attributes, then you can; ``call DAG.clearGraphAttrs()``. Note that graph visualization features are compiled out of Release builds to; reduce file size. This means that you need a Debug+Asserts or Release+Asserts; build to use these features. .. _datastructure:. Picking the Right Data Structure for a Task; ===========================================. LLVM has a plethora of data structures in the ``llvm/ADT/`` directory, and we; commonly use STL data structures. This section describes the trade-offs you; should consider when you pick one. The first step is a choose your own adventure: do you want a sequential; container, a set-like container, or a map-like container? The most important; thing when choosing a container is the algorithmic properties of how you plan to; access the container. Based on that, you should use:. * a :ref:`map-like <ds_map>` container if you need efficient look-up of a; value based on another value. Map-like containers also support efficient; queries for containment (whether a key is in the map). Map-like co",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:54547,clear,clearGraphAttrs,54547,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['clear'],['clearGraphAttrs']
Usability,"g the function bodies. This graph can then be processed with the; :program:`dot` tool to convert it to postscript or some other suitable format. ``dot-post-dom``: Print postdominance tree of function to ""dot"" file; --------------------------------------------------------------------. This pass, only available in ``opt``, prints the post dominator tree into a; ``.dot`` graph. This graph can then be processed with the :program:`dot` tool; to convert it to postscript or some other suitable format. ``dot-post-dom-only``: Print postdominance tree of function to ""dot"" file (with no function bodies); ---------------------------------------------------------------------------------------------------. This pass, only available in ``opt``, prints the post dominator tree into a; ``.dot`` graph, omitting the function bodies. This graph can then be processed; with the :program:`dot` tool to convert it to postscript or some other suitable; format. ``globals-aa``: Simple mod/ref analysis for globals; ---------------------------------------------------. This simple pass provides alias and mod/ref information for global values that; do not have their address taken, and keeps track of whether functions read or; write memory (are ""pure""). For this simple (but very common) case, we can; provide pretty accurate and useful information. ``instcount``: Counts the various types of ``Instruction``\ s; -------------------------------------------------------------. This pass collects the count of all instructions and reports them. ``iv-users``: Induction Variable Users; --------------------------------------. Bookkeeping for ""interesting"" users of expressions computed from induction; variables. ``lazy-value-info``: Lazy Value Information Analysis; ----------------------------------------------------. Interface for lazy computation of value constraint information. ``lint``: Statically lint-checks LLVM IR; ----------------------------------------. This pass statically checks for common and easil",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst:5430,Simpl,Simple,5430,interpreter/llvm-project/llvm/docs/Passes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst,1,['Simpl'],['Simple']
Usability,"g the old name - Reve):. - [EVE - Event Visualization Environment of the ROOT framework]; (http://pos.sissa.it//archive/conferences/070/103/ACAT08_103.pdf); presented at ACAT 2008. - [Event Visualization Environment of the ALICE experiment]; (http://indico.cern.ch/contributionDisplay.py?contribId=25&confId=13356); presented at ROOT Workshop 2007. - [Raw-data display and visual reconstruction validation in ALICE]; (http://indico.cern.ch/contributionDisplay.py?contribId=442&sessionId=23&confId=3580); presented at CHEP 2007. Eve is built on top of ROOT's GUI, GL and GED infrastructure and; delivers the following main features:. - Base-classes for representation of visual objects that can; be presented in list-tree views, object-editors and rendered; via OpenGL (TEveElement and sub-classes). - Application manager class TEveManager for top-level; management of elements, GUI components, geometries and events;. - Classes for presentation of full TGeo geometries; (TEveGeoNode and TEveGeoTopNode) as well as of; simplifed geometries via extraction of shape-data; (TEveGeoShape). \image html eve_cmsgeo.png ""CMS geometry"". - Classes for presentation of trajectories or tracks; (TEveTrack, TEveTrackPropagator) and hits or; clusters (TEvePointSet, TEvePointSetArray). \image html eve_alice3d.png ""A simulated ALICE pp@14TeV event in 3D"". - Base-classes for presentation of raw-data or digits; (TEveDigitSet, TEveQuadSet and; TEveBoxSet). A collection of objects can be assigned; common signal-to-color mapping (TEveRGBAPelette) and; surrounding frame (TEveFrameBox). \image html eve_quadset.png ""Hexagonal and rectangular digits"". - Base-classes for 2D projections with dynamically controllable; fish-eye magnification of the vertex region; (TEveProjectionManager and; TEveProjection). Tracks, points and geometries can be; projected automatically. R-phi and Rho-z projections are; currently supported. \image html eve_aliceproj.png ""A r-phi projection with fish-eye transformation of a simulated ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/doc/index.md:1598,simpl,simplifed,1598,graf3d/eve/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/doc/index.md,1,['simpl'],['simplifed']
Usability,"g to add, is codegen support for these binary; operators. Given our current structure, this is a simple addition of a; default case for our existing binary operator node:. .. code-block:: c++. Value *BinaryExprAST::codegen() {; Value *L = LHS->codegen();; Value *R = RHS->codegen();; if (!L || !R); return nullptr;. switch (Op) {; case '+':; return Builder->CreateFAdd(L, R, ""addtmp"");; case '-':; return Builder->CreateFSub(L, R, ""subtmp"");; case '*':; return Builder->CreateFMul(L, R, ""multmp"");; case '<':; L = Builder->CreateFCmpULT(L, R, ""cmptmp"");; // Convert bool 0/1 to double 0.0 or 1.0; return Builder->CreateUIToFP(L, Type::getDoubleTy(*TheContext),; ""booltmp"");; default:; break;; }. // If it wasn't a builtin binary operator, it must be a user defined one. Emit; // a call to it.; Function *F = getFunction(std::string(""binary"") + Op);; assert(F && ""binary operator not found!"");. Value *Ops[2] = { L, R };; return Builder->CreateCall(F, Ops, ""binop"");; }. As you can see above, the new code is actually really simple. It just; does a lookup for the appropriate operator in the symbol table and; generates a function call to it. Since user-defined operators are just; built as normal functions (because the ""prototype"" boils down to a; function with the right name) everything falls into place. The final piece of code we are missing, is a bit of top-level magic:. .. code-block:: c++. Function *FunctionAST::codegen() {; // Transfer ownership of the prototype to the FunctionProtos map, but keep a; // reference to it for use below.; auto &P = *Proto;; FunctionProtos[Proto->getName()] = std::move(Proto);; Function *TheFunction = getFunction(P.getName());; if (!TheFunction); return nullptr;. // If this is an operator, install it.; if (P.isBinaryOp()); BinopPrecedence[P.getOperatorName()] = P.getBinaryPrecedence();. // Create a new basic block to start insertion into.; BasicBlock *BB = BasicBlock::Create(*TheContext, ""entry"", TheFunction);; ... Basically, before codegening a func",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl06.rst:8807,simpl,simple,8807,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl06.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl06.rst,1,['simpl'],['simple']
Usability,"g to define all the upcasts and downcasts that are; valid for the operands of each instruction (you probably have thought; of other benefits also); - it could make the bytecode significantly larger because there could; be a lot of cast operations. o Making the second arg. to 'shl' a ubyte seems good enough to me.; 255 positions seems adequate for several generations of machines; and is more compact than uint. o I still have some major concerns about including malloc and free in the; language (either as builtin functions or instructions). LLVM must be; able to represent code from many different languages. Languages such as; C, C++ Java and Fortran 90 would not be able to use our malloc anyway; because each of them will want to provide a library implementation of it. This gets even worse when code from different languages is linked; into a single executable (which is fairly common in large apps).; Having a single malloc would just not suffice, and instead would simply; complicate the picture further because it adds an extra variant in; addition to the one each language provides. Instead, providing a default library version of malloc and free; (and perhaps a malloc_gc with garbage collection instead of free); would make a good implementation available to anyone who wants it. I don't recall all your arguments in favor so let's discuss this again,; and soon. o 'alloca' on the other hand sounds like a good idea, and the; implementation seems fairly language-independent so it doesn't have the; problems with malloc listed above. o About indirect call:; Your option #2 sounded good to me. I'm not sure I understand your; concern about an explicit 'icall' instruction?. o A pair of important synchronization instr'ns to think about:; load-linked; store-conditional. o Other classes of instructions that are valuable for pipeline performance:; conditional-move		 ; predicated instructions. o I believe tail calls are relatively easy to identify; do you know why; .NET has a tailcall in",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-09-AdveComments.txt:2571,simpl,simply,2571,interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-09-AdveComments.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-09-AdveComments.txt,1,['simpl'],['simply']
Usability,"g*`` *to be used instead of*; ``DW_OP_breg* 0``\ *.*. .. note::. This rule could be removed and require the producer to create the required; location description directly using ``DW_OP_call_frame_cfa``,; ``DW_OP_breg*``, or ``DW_OP_LLVM_aspace_bregx``. This would also then; allow a target to implement the call frames within a large register. Otherwise, the DWARF is ill-formed if SL is not a memory location; description in any of the target architecture specific address spaces. The resulting L is the *frame base* for the subprogram or entry point. *Typically, E will use the* ``DW_OP_call_frame_cfa`` *operation or be a; stack pointer register plus or minus some offset.*. *The frame base for a subprogram is typically an address relative to the; first unit of storage allocated for the subprogram's stack frame. The*; ``DW_AT_frame_base`` *attribute can be used in several ways:*. 1. *In subprograms that need location lists to locate local variables, the*; ``DW_AT_frame_base`` *can hold the needed location list, while all; variables' location descriptions can be simpler ones involving the frame; base.*. 2. *It can be used in resolving ""up-level"" addressing within; nested routines. (See also* ``DW_AT_static_link``\ *, below)*. *Some languages support nested subroutines. In such languages, it is; possible to reference the local variables of an outer subroutine from within; an inner subroutine. The* ``DW_AT_static_link`` *and* ``DW_AT_frame_base``; *attributes allow debuggers to support this same kind of referencing.*. 3. If a ``DW_TAG_subprogram`` or ``DW_TAG_entry_point`` debugger information; entry is lexically nested, it may have a ``DW_AT_static_link`` attribute,; whose value is a DWARF expression E. The result of the attribute is obtained by evaluating E with a context that; has a result kind of a location description, an unspecified object, the; compilation unit that contains E, an empty initial stack, and other context; elements corresponding to the source language th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:159034,simpl,simpler,159034,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['simpl'],['simpler']
Usability,"g. Attribute 'nonnull'. Mac OS X API Annotations. Cocoa & Core Foundation Memory Management Annotations. Attribute 'ns_returns_retained'; Attribute 'ns_returns_not_retained'; Attribute 'cf_returns_retained'; Attribute 'cf_returns_not_retained'; Attribute 'ns_consumed'; Attribute 'cf_consumed'; Attribute 'ns_consumes_self'. Libkern Memory Management Annotations. Attribute 'os_returns_retained'; Attribute 'os_returns_not_retained'; Attribute 'os_consumed'; Attribute 'os_consumes_this'; Out Parameters. Custom Assertion Handlers. Attribute 'noreturn'; Attribute 'analyzer_noreturn'. Annotations to Enhance Generic Checks. Null Pointer Checking; Attribute 'nonnull'; The analyzer recognizes the GCC attribute 'nonnull', which indicates that a; function expects that a given function parameter is not a null pointer. Specific; details of the syntax of using the 'nonnull' attribute can be found in GCC's; documentation.; Both the Clang compiler and GCC will flag warnings for simple cases where a; null pointer is directly being passed to a function with a 'nonnull' parameter; (e.g., as a constant). The analyzer extends this checking by using its deeper; symbolic analysis to track what pointer values are potentially null and then; flag warnings when they are passed in a function call via a 'nonnull'; parameter.; Example. $ cat test.m; int bar(int*p, int q, int *r) __attribute__((nonnull(1,3)));. int foo(int *p, int *q) {; return !p ? bar(q, 2, p); : bar(p, 2, q);; }. Running scan-build over this source produces the following; output:. Mac OS X API Annotations. Cocoa & Core Foundation Memory Management; Annotations. The analyzer supports the proper management of retain counts for; both Cocoa and Core Foundation objects. This checking is largely based on; enforcing Cocoa and Core Foundation naming conventions for Objective-C methods; (Cocoa) and C functions (Core Foundation). Not strictly following these; conventions can cause the analyzer to miss bugs or flag false positives.; One c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:1926,simpl,simple,1926,interpreter/llvm-project/clang/www/analyzer/annotations.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html,1,['simpl'],['simple']
Usability,"g., ban, physical; removal, or moderation) may be used to immediately stop it.; * For events that include talks, organizers should end talks early if the; violations include harassment or violent threats. There may be talks where; other types of code of conduct violations occur and organizers should do ; their best to determine if a talk should be ended early or not. . When undertaking an immediate response, document the action and notify the; committee within 24 hours. . Response Procedure; ==================. The following is a summary of the steps the committee takes when responding to; a reported incident. . 1. Determine if there is a need for an :ref:`immediate response<Immediate; Response Checklist>`. 2. :ref:`Acknowledge the report<Receiving a report>` within 24 hours. 3. :ref:`Discuss the incident report<Incident Response Assessment>`, gather; more information, and determine a :ref:`resolution<Resolutions>`. 4. During this process, the :ref:`reporter will be informed of the; resolution<Following Up With the Reportee>` and feedback is requested. This; feedback may or may not be used to re-evaluate the resolution. 5. Inform the reportee of the resolution. The reportee is provided options to; :ref:`appeal<Appeal Process>`. . 6. The :ref:`resolution<Resolutions>` is implemented. 7. All reports, data, notes, and resolutions are logged in a private location; (e.g., Google Drive or other database). The committee will never make public statements about a resolution and will; only publish :ref:`transparency reports<Transparency Reports>`. If a public; statement is necessary and requested by the committee, it will be given by the; LLVM Foundation Board of Directors. Report Acknowledgement; ======================. When a report is received, the committee will reply to the reporter to confirm; receipt within 24 hours of the incident being reported. . This acknowledgement will contain:. * Acknowledgement of the incident report; * Next steps of the committee for respondin",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ResponseGuide.rst:3637,feedback,feedback,3637,interpreter/llvm-project/llvm/docs/ResponseGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ResponseGuide.rst,1,['feedback'],['feedback']
Usability,"g., for a draft PR), use `[skip-CI]` as the first tag.; Note that for functional changes this tag needs to be removed and it has to pass the CI before merging to ensure; the change does not break anything. The PR description describes (and in case of multiple commits, summarizes) the change in more detail.; Again, try to describe the **why** (and in this case, to a lesser extent the **what**), rather than the **how**. If your PR is related to an open [issue](https://github.com/root-project/root/issues), make sure to link it.; This will be done automatically if you add; [closing keywords](https://docs.github.com/en/issues/tracking-your-work-with-issues/linking-a-pull-request-to-an-issue); to the PR description. Once a PR is created, a member of the ROOT team will review it as quickly as possible. If you are familiar with the; ROOT community, it may be beneficial to add a suggested reviewer to the PR in order to get quicker attention.; Please ping people :wave: should you not get timely feedback, for instance with `@root-project/core ping!`. ## Tests. As you contribute code, this code will likely fix an issue or add a feature.; Whatever it is: this requires you to add a new test, or to extend an existing test. Depending on the size and complexity; of this test, it exists either in the `test/` subdirectory of each part of ROOT (see for instance; [`tree/dataframe/test`](https://github.com/root-project/root/tree/master/tree/dataframe/test)), or in; [roottest](https://github.com/root-project/roottest.git). Tests in `test/` subdirectories are unit tests, mostly based on; [Google Test](https://github.com/google/googletest) and easily extended. Tests in; [roottest](https://github.com/root-project/roottest.git) are more involved (e.g., tests requiring custom dictionaries or; data files). When you create a branch in the main ROOT repository (i.e., this repository) and add a test to `roottest`,; make sure to do this under the same branch name (and open a PR for it). Our CI infra",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/CONTRIBUTING.md:5339,feedback,feedback,5339,CONTRIBUTING.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/CONTRIBUTING.md,1,['feedback'],['feedback']
Usability,"g/posts/2020-11-30-interactive-cpp-with-cling/>`_; - *Vassil Vassilev* 2020 The LLVM Project Blog; - This blog page briefly discusses the concept of interactive C++ by presenting Cling’s main features, such as wrapper functions, entity redefinition, error recovery. ; * - `Using the Cling C++ Interpreter on the Bela Platform <https://gist.github.com/jarmitage/6e411ae8746c04d6ecbee1cbc1ebdcd4>`_; - Jack Armitage 2019; - Cling has been installed on a BeagleBoard to bring live coding to the Bela interactive audio platform.; * - `Implementation of GlobalModuleIndex in ROOT and Cling <https://indico.cern.ch/event/840376/contributions/3525646/attachments/1895398/3127159/GSoC_Presentation__GMI.pdf>`_; - *Arpitha Raghunandan* 2012 Google Summer of Code GSoC; - GlobalModuleIndex can be used for improving ROOT’s and Cling’s performance ; * - `Example project using cling as library <https://github.com/root-project/cling/tree/master/tools/demo>`_; - *Axel Naumann* 2016 GitHub; - This video showcases how to use Cling as a library, and shows how to set up a simple CMake configuration that uses Cling.; * - `Cling C++ interpreter testdrive <https://www.youtube.com/watch?v=1IGTHusaJ18>`_; - *Mika* 2015 Youtube; - In this tutorial, a developer tries Cling for the first time by uploading a few simple C++ user-cases onto Cling, involving also the loading of external files; * - `Building an Order Book in C++ <https://www.youtube.com/watch?v=fxN4xEZvrxI>`_; - *Dimitri Nesteruk* 2015 Youtube; - This demo shows how to build a simple order book using C++, CLion, Google Test and, of course, Cling. ; * - `Cling C++ interpreter testdrive <https://www.youtube.com/watch?v=1IGTHusaJ18>`_; - Dimitri Nesteruk 2015 Youtube; - This tutorial describes Cling’s general features. You will learn how to start Cling on Ubuntu, how to write a simple expression (N=5, N++) and how to define a Class for calculating body mass index. ; * - `Cling Interactive OpenGL Demo <https://www.youtube.com/watch?v=eoIuqLNvzFs>",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/docs/chapters/references.rst:4581,simpl,simple,4581,interpreter/cling/docs/chapters/references.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/docs/chapters/references.rst,1,['simpl'],['simple']
Usability,"g; a common set of fields to all the records created by the ``defm``. The name is parsed in the same special mode used by ``def``. If the name is; not included, an unspecified but globally unique name is provided. That is,; the following examples end up with different names::. defm : SomeMultiClass<...>; // A globally unique name.; defm """" : SomeMultiClass<...>; // An empty name. The ``defm`` statement can be used in a multiclass body. When this occurs,; the second variant is equivalent to::. defm NAME : SomeMultiClass<...>;. More generally, when ``defm`` occurs in a multiclass and its name does not; include a use of the implicit template argument ``NAME``, then ``NAME`` will; be prepended automatically. That is, the following are equivalent inside a; multiclass::. defm Foo : SomeMultiClass<...>;; defm NAME # Foo : SomeMultiClass<...>;. See `Examples: multiclasses and defms`_ for examples. Examples: multiclasses and defms; --------------------------------. Here is a simple example using ``multiclass`` and ``defm``. Consider a; 3-address instruction architecture whose instructions come in two formats:; ``reg = reg op reg`` and ``reg = reg op imm`` (immediate). The SPARC is an; example of such an architecture. .. code-block:: text. def ops;; def GPR;; def Imm;; class inst <int opc, string asmstr, dag operandlist>;. multiclass ri_inst <int opc, string asmstr> {; def _rr : inst<opc, !strconcat(asmstr, "" $dst, $src1, $src2""),; (ops GPR:$dst, GPR:$src1, GPR:$src2)>;; def _ri : inst<opc, !strconcat(asmstr, "" $dst, $src1, $src2""),; (ops GPR:$dst, GPR:$src1, Imm:$src2)>;; }. // Define records for each instruction in the RR and RI formats.; defm ADD : ri_inst<0b111, ""add"">;; defm SUB : ri_inst<0b101, ""sub"">;; defm MUL : ri_inst<0b100, ""mul"">;. Each use of the ``ri_inst`` multiclass defines two records, one with the; ``_rr`` suffix and one with ``_ri``. Recall that the name of the ``defm``; that uses a multiclass is prepended to the names of the records defined in; that multic",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst:39135,simpl,simple,39135,interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,1,['simpl'],['simple']
Usability,"gation rule built-in to the checker or given in the YAML configuration; file. This causes potential true positive findings to be lost. alpha.unix; ^^^^^^^^^^. .. _alpha-unix-BlockInCriticalSection:. alpha.unix.BlockInCriticalSection (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for calls to blocking functions inside a critical section.; Applies to: ``lock, unlock, sleep, getc, fgets, read, recv, pthread_mutex_lock,``; `` pthread_mutex_unlock, mtx_lock, mtx_timedlock, mtx_trylock, mtx_unlock, lock_guard, unique_lock``. .. code-block:: c. void test() {; std::mutex m;; m.lock();; sleep(3); // warn: a blocking function sleep is called inside a critical; // section; m.unlock();; }. .. _alpha-unix-Chroot:. alpha.unix.Chroot (C); """"""""""""""""""""""""""""""""""""""""""; Check improper use of chroot. .. code-block:: c. void f();. void test() {; chroot(""/usr/local"");; f(); // warn: no call of chdir(""/"") immediately after chroot; }. .. _alpha-unix-PthreadLock:. alpha.unix.PthreadLock (C); """"""""""""""""""""""""""""""""""""""""""""""""""""; Simple lock -> unlock checker.; Applies to: ``pthread_mutex_lock, pthread_rwlock_rdlock, pthread_rwlock_wrlock, lck_mtx_lock, lck_rw_lock_exclusive``; ``lck_rw_lock_shared, pthread_mutex_trylock, pthread_rwlock_tryrdlock, pthread_rwlock_tryrwlock, lck_mtx_try_lock,; lck_rw_try_lock_exclusive, lck_rw_try_lock_shared, pthread_mutex_unlock, pthread_rwlock_unlock, lck_mtx_unlock, lck_rw_done``. .. code-block:: c. pthread_mutex_t mtx;. void test() {; pthread_mutex_lock(&mtx);; pthread_mutex_lock(&mtx);; // warn: this lock has already been acquired; }. lck_mtx_t lck1, lck2;. void test() {; lck_mtx_lock(&lck1);; lck_mtx_lock(&lck2);; lck_mtx_unlock(&lck1);; // warn: this was not the most recently acquired lock; }. lck_mtx_t lck1, lck2;. void test() {; if (lck_mtx_try_lock(&lck1) == 0); return;. lck_mtx_lock(&lck2);; lck_mtx_unlock(&lck1);; // warn: this was not the most recently acquired lock; }. .. _alpha-unix-SimpleStream:. alpha.unix.SimpleStream (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""; Ch",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:75319,Simpl,Simple,75319,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['Simpl'],['Simple']
Usability,"ge(-10,10);; ```. ### Triple Slider. The new **`TGTripleHSlider`** and **`TGTripleVSlider`** classes inherit; from the double slider widgets and allow easy selection of a range and a; pointer value. The pointer position can be constrained into the selected; range or can be relative to it. ![](pictures/0300021D.png). To change the slider range value press the left mouse button near to the; left/right (top/bottom) edges of the slider. To change both values; simultaneously press the mouse button near to the slider center. To; change pointer value press the mouse on the pointer and drag it to the; desired position. ``` {.cpp}; fSlider = new TGTripleHSlider(parent,100,kDoubleScaleBoth,kSLD_ID,; kHorizontalFrame);; parent->AddFrame(fSlider,new TGLayoutHints(kLHintsExpandX,5,5,5,5));; fSlider->SetConstrained(kTRUE);; fSlider->SetRange(rmin, rmax);; fSlider->SetPosition(pmin, pmax);; fSlider ->SetPointerPosition(pvalue);; ```. ### Progress Bars. A progress bar is a widget that shows that an operation is in progress; and how much time is left. It is a long rectangular bar, initially; empty, that fills with a color as a process is being performed. The; filled-in area indicates the percentage of the process that has been; completed. You should use this widget for waits exceeding `one minute`.; For a very time consuming operation it is better to break the operation; into subtasks and provide a progress bar for each of them. ![](pictures/0200021E.jpg). A progress bar may be oriented horizontally or vertically. The; horizontally oriented progress bar fills with a color from left to; right; the vertically oriented - from bottom to top. A percent complete; message provides an indication of the completed part of the process. It; is a good practice to include some descriptive text of the process to; keep users informed and entertained while they are waiting for process; completion. The picture below shows the progress bars you can create using the; classes **`TGProgressBar`**, **`TGHP",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:87755,progress bar,progress bar,87755,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,1,['progress bar'],['progress bar']
Usability,"gen(mtm);; const TVectorD eigenVal = eigen.GetEigenValues();; const Bool_t ok = VerifyVectorIdentity(sig,eigenVal,1,1.-e-14);; ```. ## Speed Comparisons. Speed of four matrix operations have been compared between four matrix; libraries, `GSL` `CLHEP`, `ROOT v3.10` and `ROOT v4.0`. Next figure; shows the `CPU` time for these four operations as a function of the; matrix size:. 1. `A*B` The execution time is measured for the sum of A \* Bsym,; Bsym\* A and A \* B. Notice the matrix\_size3 dependence of execution; time. `CLHEP` results are hampered by a poor implementation of symmetric; matrix multiplications. For instance, for general matrices of size; 100x100, the time is 0.015 sec. while A \* Bsym takes 0.028 sec and; Bsym\* A takes 0.059 sec. Both `GSL` and `ROOT v4.0` can be setup to use the hardware-optimized; multiplication routines of the `BLAS` libraries. It was tested on a G4; PowerPC. The improvement becomes clearly visible around sizes of (50x50); were the execution speed improvement of the Altivec processor becomes; more significant than the overhead of filling its pipe. 2. $A^{-1}$ Here, the time is measured for an in-place matrix inversion. Except for `ROOT v3.10`, the algorithms are all based on an; `LU `factorization followed by forward/back-substitution. `ROOT v3.10`; is using the slower Gaussian elimination method. The numerical accuracy; of the `CLHEP` routine is poor:. - up to 6x6 the numerical imprecise Cramer multiplication is hard-coded.; For instance, calculating `U=H*H-1`, where `H` is a (5x5) Hilbert; matrix, results in off-diagonal elements of $10^{-7}$ instead of the $10^{-13}$; using an `LU `according to `Crout`. - scaling protection is non-existent and limits are hard-coded, as a; consequence inversion of a Hilbert matrix for `sizes>(12x12)` fails. In; order to gain speed the `CLHEP` algorithm stores its permutation info of; the pivots points in a static array, making multi-threading not; possible. `GSL` uses LU decomposition without the i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md:50404,clear,clearly,50404,documentation/users-guide/LinearAlgebra.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md,1,['clear'],['clearly']
Usability,"generated with elements |; | | | uniformly distributed |; | | | between $\alpha$ and $\beta$ |; +--------------------------+------------+---------------------------------------------+. Output **`TMatrixX`** indicates that the returned matrix is of the same; type as `A`, being **`TMatrixD`**, **`TMatrixDSym`** or; **`TMatrixDSparse`**. Next table shows miscellaneous operations for; **`TMatrixD`**. +--------------------------------+------------+---------------------------------+; | Format | Output | Description |; +--------------------------------+------------+---------------------------------+; | `A.Rank1Update(v1,v2,alpha)` | `TMatrixD` | Perform with vector `v1` and |; | | | `v2`, a rank 1 operation on the |; | | | matrix: |; | | | $A = A + \alpha.\nu.\nu2^T$ |; +--------------------------------+------------+---------------------------------+. ## Matrix Views. Another way to access matrix elements is through the matrix-view; classes, **`TMatrixDRow`**, **`TMatrixDColumn`**, **`TMatrixDDiag`** and; **`TMatrixDSub`** (each has also a const version which is obtained by; simply appending const to the class name). These classes create a; reference to the underlying matrix, so no memory management is involved.; The next table shows how the classes access different parts of the; matrix:. +--------------------------------+-----------------------------------------+; | class | view |; +--------------------------------+-----------------------------------------+; | | $$ \left(\begin{array}{ccccc} |; | | x_{00} & & & & x_{0n} \\ |; | | & & & & \\ |; | `TMatrixDRow const(X,i)` | x_{i0} & ... & x_{ij} & ... & x_{in} \\ |; | `TMatrixDRow(X,i)` | & & & & \\ |; | | x_{n0} & & & & x_{nn} |; | | \end{array}\right)$$ |; +--------------------------------+-----------------------------------------+; | | $$ \left(\begin{array}{ccccc} |; | | x_{00} & & x_{0j} & & x_{0n} \\ |; | | & & ... & & \\ |; | `TMatrixDColumn const(X,j)` | & & x_{ij} & & \\ |; | `TMatrixDColumn(X,j)` | & & ... & & \\ ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md:25052,simpl,simply,25052,documentation/users-guide/LinearAlgebra.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md,1,['simpl'],['simply']
Usability,"github.com/mozilla/dxr>`_; ""DXR is a source code cross-reference tool that uses static analysis; data collected by instrumented compilers."". `<https://github.com/eschulte/clang-mutate>`_; ""This tool performs a number of operations on C-language source files."". `<https://github.com/gmarpons/Crisp>`_; ""A coding rule validation add-on for LLVM/clang. Crisp rules are written; in Prolog. A high-level declarative DSL to easily write new rules is under; development. It will be called CRISP, an acronym for *Coding Rules in; Sugared Prolog*."". `<https://github.com/drothlis/clang-ctags>`_; ""Generate tag file for C++ source code."". `<https://github.com/exclipy/clang_indexer>`_; ""This is an indexer for C and C++ based on the libclang library."". `<https://github.com/holtgrewe/linty>`_; ""Linty - C/C++ Style Checking with Python & libclang."". `<https://github.com/axw/cmonster>`_; ""cmonster is a Python wrapper for the Clang C++ parser."". `<https://github.com/rizsotto/Constantine>`_; ""Constantine is a toy project to learn how to write clang plugin.; Implements pseudo const analysis. Generates warnings about variables,; which were declared without const qualifier."". `<https://github.com/jessevdk/cldoc>`_; ""cldoc is a Clang based documentation generator for C and C++.; cldoc tries to solve the issue of writing C/C++ software documentation; with a modern, non-intrusive and robust approach."". `<https://github.com/AlexDenisov/ToyClangPlugin>`_; ""The simplest Clang plugin implementing a semantic check for Objective-C.; This example shows how to use the ``DiagnosticsEngine`` (emit warnings,; errors, fixit hints). See also `<http://l.rw.rw/clang_plugin>`_ for; step-by-step instructions."". `<https://phabricator.kde.org/source/clazy>`_; ""clazy is a compiler plugin which allows clang to understand Qt semantics.; You get more than 50 Qt related compiler warnings, ranging from unneeded; memory allocations to misusage of API, including fix-its for automatic; refactoring."". `<https://gerrit.libreo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ExternalClangExamples.rst:2850,learn,learn,2850,interpreter/llvm-project/clang/docs/ExternalClangExamples.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ExternalClangExamples.rst,1,['learn'],['learn']
Usability,"glbox1"") a minus sign on negative bins is added in order to; distinguish them from positive bins.; ; In THistPainter::PaintH3 the palette is drawn in case of option; COLZ. This is useful when a TTree 4D plot is painted with that option.; ; This image has been prodiced with the command:; ntuple->Draw(""px:py:pz:px*px"","""",""COLZ"");. TGraph2D. The operator ""="" was not correct. TGraph. Protection added in PaintPolyLineHatches (division by zero in some; cases).; All the graphical code has been moved from the TGraph classes to; TGraphPainter. TGraphPolar. Protection added in case a GraphPolar is plotted with option; ""E"" but has no errors defined.; The markers clipping (in TGraphPainter) was wrong in case of TGraphPolar.; The constructor's parameters naming was wrong.; Documentation: better example (easier to understand).; In the constructors some data members were not initialized. TPie. Add the TPie::GetEntries() method that return the number slices.; (Guido Volpi).; Implement Editors for TPie and TPieSlice (Guido Volpi). TPaletteAxis. Attributes are now accessible in the context menu.; (requested by Mathieu de Naurois <denauroi@in2p3.fr>). TPolyLine. Implement the possibility to draw TPolyLine in NDC coordinates; (it was partially done but the code was not used). Documentation. Better comments in THelix.; Option ""FUNC"" was not documented in THistPainter..; Update the help for animated gif generation in TPad.; Update TAttMarker documentation about the non scalable markers.; Re-writting of the THistPainter documentation. TCutG. The graphical cuts applied on histograms did not work when the cut name; contained a mix of lower and upper case characters. This problem occured; because the option used to draw an histogram was always converted into; lower case before begin stored in a pad (in Draw and DrawCopy). Now in; Draw() and DrawCopy() the AppendPad() procedure is called with the option; string not converted in lower; case. QT; Version 3 of QT is not supported anymore. If you ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/doc/v520/index.html:5329,Guid,Guido,5329,graf2d/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/doc/v520/index.html,1,['Guid'],['Guido']
Usability,"gle unsigned 1-byte operand that represents an index; I. A copy of the stack entry with index I is pushed onto the stack. 4. ``DW_OP_over``. ``DW_OP_over`` pushes a copy of the entry with index 1. *This is equivalent to a* ``DW_OP_pick 1`` *operation.*. 5. ``DW_OP_swap``. ``DW_OP_swap`` swaps the top two stack entries. The entry at the top of the; stack becomes the second stack entry, and the second stack entry becomes the; top of the stack. 6. ``DW_OP_rot``. ``DW_OP_rot`` rotates the first three stack entries. The entry at the top of; the stack becomes the third stack entry, the second entry becomes the top of; the stack, and the third entry becomes the second entry. *Examples illustrating many of these stack operations are found in Appendix; D.1.2 on page 289.*. .. _amdgpu-dwarf-control-flow-operations:. A.2.5.4.2 Control Flow Operations; #################################. .. note::. This section replaces DWARF Version 5 section 2.5.1.5. The following operations provide simple control of the flow of a DWARF operation; expression. 1. ``DW_OP_nop``. ``DW_OP_nop`` is a place holder. It has no effect on the DWARF stack; entries. 2. ``DW_OP_le``, ``DW_OP_ge``, ``DW_OP_eq``, ``DW_OP_lt``, ``DW_OP_gt``,; ``DW_OP_ne``. .. note::. The same as in DWARF Version 5 section 2.5.1.5. 3. ``DW_OP_skip``. ``DW_OP_skip`` is an unconditional branch. Its single operand is a 2-byte; signed integer constant. The 2-byte constant is the number of bytes of the; DWARF expression to skip forward or backward from the current operation,; beginning after the 2-byte constant. If the updated position is at one past the end of the last operation, then; the operation expression evaluation is complete. Otherwise, the DWARF expression is ill-formed if the updated operation; position is not in the range of the first to last operation inclusive, or; not at the start of an operation. 4. ``DW_OP_bra``. ``DW_OP_bra`` is a conditional branch. Its single operand is a 2-byte signed; integer constant. This op",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:70639,simpl,simple,70639,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['simpl'],['simple']
Usability,"gma = 1 by calling; `gRandom->Rannor(px,py)`, and calculate` pz`. Then we call the; `TTree::Fill()` method. The call `t1.Fill()` fills all branches in the; tree because we have already organized the tree into branches and told; each branch where to get the value from. After this script is executed; we have a ROOT file called `tree1.root` with a tree called `t1`. There; is a possibility to fill branches one by one using the method; `TBranch::Fill()`. In this case you do not need to call `TTree::Fill()`; method. The entries can be set by `TTree::SetEntries(Double_t n)`.; Calling this method makes sense only if the number of existing entries; is null. ### Viewing the Tree. ![The tree1.root file and its tree in the browser and a leaf histogram](pictures/030000FC.png). In the right panel of the ROOT object browse are the branches: `ev`,; `px`, `py`, `pz`, and `random`. Note that these are shown as leaves; because they are ""end"" branches with only one leaf. To histogram a leaf,; we can simply double click on it in the browser. This is how the tree; `t1` looks in the Tree Viewer. Here we can add a cut and add other; operations for histogramming the leaves. See ""The Tree Viewer"". For; example, we can plot a two dimensional histogram. ![The tree viewer](pictures/030000FE.png). ### Reading the Tree. The `tree1r` function shows how to read the tree and access each entry; and each leaf. We first define the variables to hold the read values. ``` {.cpp}; Float_t px, py, pz;; ```. Then we tell the tree to populate these variables when reading an entry.; We do this with the method `TTree::SetBranchAddress`. The first; parameter is the branch name, and the second is the address of the; variable where the branch data is to be placed. In this example, the; branch name is `px`. This name was given when the tree was written (see; `tree1w`). The second parameter is the address of the variable `px`. ``` {.cpp}; t1->SetBranchAddress(""px"",&px);; ```. #### GetEntry. Once the branches have bee",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:37642,simpl,simply,37642,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['simpl'],['simply']
Usability,"gn or zero extended. If spilled, we should be able; to spill these to a 8-bit or 16-bit stack slot, zero or sign extending as part; of the reload. Doing this reduces the size of the stack frame (important for thumb etc), and; also increases the likelihood that we will be able to reload multiple values; from the stack with a single load. //===---------------------------------------------------------------------===//. The constant island pass is in good shape. Some cleanups might be desirable,; but there is unlikely to be much improvement in the generated code. 1. There may be some advantage to trying to be smarter about the initial; placement, rather than putting everything at the end. 2. There might be some compile-time efficiency to be had by representing; consecutive islands as a single block rather than multiple blocks. 3. Use a priority queue to sort constant pool users in inverse order of; position so we always process the one closed to the end of functions; first. This may simply CreateNewWater. //===---------------------------------------------------------------------===//. Eliminate copysign custom expansion. We are still generating crappy code with; default expansion + if-conversion. //===---------------------------------------------------------------------===//. Eliminate one instruction from:. define i32 @_Z6slow4bii(i32 %x, i32 %y) {; %tmp = icmp sgt i32 %x, %y; %retval = select i1 %tmp, i32 %x, i32 %y; ret i32 %retval; }. __Z6slow4bii:; cmp r0, r1; movgt r1, r0; mov r0, r1; bx lr; =>. __Z6slow4bii:; cmp r0, r1; movle r0, r1; bx lr. //===---------------------------------------------------------------------===//. Implement long long ""X-3"" with instructions that fold the immediate in. These; were disabled due to badness with the ARM carry flag on subtracts. //===---------------------------------------------------------------------===//. More load / store optimizations:; 1) Better representation for block transfer? This is from Olden/power:. 	fldd d0, [r4];",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/README.txt:1933,simpl,simply,1933,interpreter/llvm-project/llvm/lib/Target/ARM/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/README.txt,1,['simpl'],['simply']
Usability,"gname !getdagop !gt !head !if; : !interleave !isa !le !listconcat !listremove; : !listsplat !logtwo !lt !mul !ne; : !not !or !range !repr !setdagarg; : !setdagname !setdagop !shl !size !sra; : !srl !strconcat !sub !subst !substr; : !tail !tolower !toupper !xor. The ``!cond`` operator has a slightly different; syntax compared to other bang operators, so it is defined separately:. .. productionlist::; CondOperator: !cond. See `Appendix A: Bang Operators`_ for a description of each bang operator. Include files; -------------. TableGen has an include mechanism. The content of the included file; lexically replaces the ``include`` directive and is then parsed as if it was; originally in the main file. .. productionlist::; IncludeDirective: ""include"" `TokString`. Portions of the main file and included files can be conditionalized using; preprocessor directives. .. productionlist::; PreprocessorDirective: ""#define"" | ""#ifdef"" | ""#ifndef"". Types; =====. The TableGen language is statically typed, using a simple but complete type; system. Types are used to check for errors, to perform implicit conversions,; and to help interface designers constrain the allowed input. Every value is; required to have an associated type. TableGen supports a mixture of low-level types (e.g., ``bit``) and; high-level types (e.g., ``dag``). This flexibility allows you to describe a; wide range of records conveniently and compactly. .. productionlist::; Type: ""bit"" | ""int"" | ""string"" | ""dag""; :| ""bits"" ""<"" `TokInteger` "">""; :| ""list"" ""<"" `Type` "">""; :| `ClassID`; ClassID: `TokIdentifier`. ``bit``; A ``bit`` is a boolean value that can be 0 or 1. ``int``; The ``int`` type represents a simple 64-bit integer value, such as 5 or; -42. ``string``; The ``string`` type represents an ordered sequence of characters of arbitrary; length. ``bits<``\ *n*\ ``>``; The ``bits`` type is a fixed-sized integer of arbitrary length *n* that; is treated as separate bits. These bits can be accessed individually.; A field ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst:10228,simpl,simple,10228,interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,1,['simpl'],['simple']
Usability,"gnment exists simple trivial needs_implicit; `-Destructor simple irrelevant trivial needs_implicit. We'd like to get the members too, so, we use ``ImportDefinition`` to copy the whole definition of ``MyClass`` into the ""to"" context.; Then we dump the AST again. .. code-block:: cpp. if (llvm::Error Err = Importer.ImportDefinition(From)) {; llvm::errs() << ""ERROR: "" << Err << ""\n"";; consumeError(std::move(Err));; return 1;; }; llvm::errs() << ""Imported definition.\n"";; Imported->getTranslationUnitDecl()->dump();. This time the AST is going to contain the members too. .. code-block:: bash. TranslationUnitDecl 0x68b9a8 <<invalid sloc>> <invalid sloc>; `-CXXRecordDecl 0x6c7e30 <line:2:7, col:13> col:13 class MyClass definition; |-DefinitionData pass_in_registers standard_layout trivially_copyable trivial literal; | |-DefaultConstructor exists trivial needs_implicit; | |-CopyConstructor simple trivial has_const_param needs_implicit implicit_has_const_param; | |-MoveConstructor exists simple trivial needs_implicit; | |-CopyAssignment trivial has_const_param needs_implicit implicit_has_const_param; | |-MoveAssignment exists simple trivial needs_implicit; | `-Destructor simple irrelevant trivial needs_implicit; |-CXXRecordDecl 0x6c7f48 <col:7, col:13> col:13 implicit class MyClass; |-FieldDecl 0x6c7ff0 <line:3:9, col:13> col:13 m1 'int'; `-FieldDecl 0x6c8058 <line:4:9, col:13> col:13 m2 'int'. We can spare the call for ``ImportDefinition`` if we set up the importer to do a ""normal"" (not minimal) import. .. code-block:: cpp. ASTImporter Importer( .... /*MinimalImport=*/false);. With **normal import**, all dependent declarations are imported normally.; However, with minimal import, the dependent Decls are imported without definition, and we have to import their definition for each if we later need that. Putting this all together here is how the source of the tool looks like:. .. code-block:: cpp. #include ""clang/AST/ASTImporter.h""; #include ""clang/ASTMatchers/ASTMatchFinder.h""",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst:7825,simpl,simple,7825,interpreter/llvm-project/clang/docs/LibASTImporter.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst,4,['simpl'],['simple']
Usability,"gram to adjust; the scale of the function. In case of extended p.d.f.s, the adjustment is made with the expected; number of events, rather than the observed number of events. Tutorial macro rf602_chi2fit.C has been updated to use this new interface. Chi-squared fits to X-Y datasets now possible; In addition to the ability to perform chi-squared fits to histograms it is now also possible; to perform chi-squared fits to unbinned datasets containing a series of X and Y values; with associated errors on Y and optionally on X. These 'X-Y' chi-squared fits are interfaced through newly added method; RooAbsReal::chi2FitTo(const RooDataSet&,...). By default the event weight is; interpreted as the 'Y' value, but an YVar() argument can designate any other; dataset column as Y value. If X errors are defined, one can choose to integrate the fitted; function over the range of the X errors, rather than taking the central value by adding; an Integrate(true) argument to chi2FitTo(); Two new arguments, StoreError(const RooArgSet&) and StoreAsymError(const RooArgSet&); have been added to the RooDataSet constructor to simplify the process of storing the errors; of X and Y variables along with their values in a dataset. The newly added tutorial macro rf609_xychi2fit.C illustrates the use of all this; new functionality. Uniform interface for creation of (profile likelihoods) and chi-squared from p.d.f.s; It is now recommended to use the method RooAbsPdf::createNLL(RooAbsData&,...) to; create a likelihood from a p.d.f and a dataset rather than constructing a RooNLLVar; object directly. This is because part of the likelihood construction functionality such a using; multiple Range()s, or the inclusion for constraint terms are only available through; createNLL(). To promote the consistency of this interface, a similar method RooAbsReal::createChi2(); has been added to construct chi-squared functions of a dataset and a function or p.d.f. Along the same lines, it is recommended to use RooAbsRe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html:9019,simpl,simplify,9019,roofit/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html,1,['simpl'],['simplify']
Usability,"guments. matcher = objCMessageExpr(numSelectorArgs(0));; matches self.bodyView in the code below. matcher = objCMessageExpr(numSelectorArgs(2));; matches the invocation of ""loadHTMLString:baseURL:"" but not that; of self.bodyView; [self.bodyView loadHTMLString:html baseURL:NULL];. Matcher<ObjCMethodDecl>isClassMethod; Returns true when the Objective-C method declaration is a class method. Example; matcher = objcMethodDecl(isClassMethod()); matches; @interface I + (void)foo; @end; but not; @interface I - (void)bar; @end. Matcher<ObjCMethodDecl>isDefinition; Matches if a declaration has a body attached. Example matches A, va, fa; class A {};; class B; // Doesn't match, as it has no body.; int va;; extern int vb; // Doesn't match, as it doesn't define the variable.; void fa() {}; void fb(); // Doesn't match, as it has no body.; @interface X; - (void)ma; // Doesn't match, interface is declaration.; @end; @implementation X; - (void)ma {}; @end. Usable as: Matcher<TagDecl>, Matcher<VarDecl>, Matcher<FunctionDecl>,; Matcher<ObjCMethodDecl>. Matcher<ObjCMethodDecl>isInstanceMethod; Returns true when the Objective-C method declaration is an instance method. Example; matcher = objcMethodDecl(isInstanceMethod()); matches; @interface I - (void)bar; @end; but not; @interface I + (void)foo; @end. Matcher<ParmVarDecl>hasDefaultArgument; Matches a declaration that has default arguments. Example matches y (matcher = parmVarDecl(hasDefaultArgument())); void x(int val) {}; void y(int val = 0) {}. Deprecated. Use hasInitializer() instead to be able to; match on the contents of the default argument. For example:. void x(int val = 7) {}; void y(int val = 42) {}; parmVarDecl(hasInitializer(integerLiteral(equals(42)))); matches the parameter of y. A matcher such as; parmVarDecl(hasInitializer(anything())); is equivalent to parmVarDecl(hasDefaultArgument()). Matcher<ParmVarDecl>isAtPositionunsigned N; Matches the ParmVarDecl nodes that are at the N'th position in the parameter; list. The par",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:109400,Usab,Usable,109400,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['Usab'],['Usable']
Usability,"h basic block is a node in the graph, and each node contains the instructions; in the block. Similarly, there also exists ``Function::viewCFGOnly()`` (does; not include the instructions), the ``MachineFunction::viewCFG()`` and; ``MachineFunction::viewCFGOnly()``, and the ``SelectionDAG::viewGraph()``; methods. Within GDB, for example, you can usually use something like ``call; DAG.viewGraph()`` to pop up a window. Alternatively, you can sprinkle calls to; these functions in your code in places you want to debug. Getting this to work requires a small amount of setup. On Unix systems; with X11, install the `graphviz <http://www.graphviz.org>`_ toolkit, and make; sure 'dot' and 'gv' are in your path. If you are running on macOS, download; and install the macOS `Graphviz program; <http://www.pixelglow.com/graphviz/>`_ and add; ``/Applications/Graphviz.app/Contents/MacOS/`` (or wherever you install it) to; your path. The programs need not be present when configuring, building or; running LLVM and can simply be installed when needed during an active debug; session. ``SelectionDAG`` has been extended to make it easier to locate *interesting*; nodes in large complex graphs. From gdb, if you ``call DAG.setGraphColor(node,; ""color"")``, then the next ``call DAG.viewGraph()`` would highlight the node in; the specified color (choices of colors can be found at `colors; <http://www.graphviz.org/doc/info/colors.html>`_.) More complex node attributes; can be provided with ``call DAG.setGraphAttrs(node, ""attributes"")`` (choices can; be found at `Graph attributes <http://www.graphviz.org/doc/info/attrs.html>`_.); If you want to restart and clear all the current graph attributes, then you can; ``call DAG.clearGraphAttrs()``. Note that graph visualization features are compiled out of Release builds to; reduce file size. This means that you need a Debug+Asserts or Release+Asserts; build to use these features. .. _datastructure:. Picking the Right Data Structure for a Task; ==============",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:53844,simpl,simply,53844,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['simpl'],['simply']
Usability,"h can be recuperated by using the newer, much faster,; gold linker. In addition we added the linker option ""-Wl,--no-undefined"",; so you will get an error if symbols are unresolved.; Explicit linking is required by newer distributions, like Ubuntu 11.10,; that require all dependent shared libs to be specified when linking. They; also have default options set to dead strip shared libs that don't resolve; any symbols (equivalent to the MacOS X build changes described above). Core Libraries; TClonesArray. Introduce TClonesArray::ConstructedAt which; always returns an already constructed object. If the slot is being used for the; first time, it calls the default constructor otherwise it returns the object as; is (unless a string is passed as the 2nd argument to the function in which case,; it also calls Clear(second_argument) on the object).; This allows to replace code like:. for (int i = 0; i < ev->Ntracks; i++) {; new(a[i]) TTrack(x,y,z,...);; ...; ...; }; ...; a.Delete(); // or a.Clear(""C""). with the simpler and more efficient:. for (int i = 0; i < ev->Ntracks; i++) {; TTrack *track = (TTrack*)a.ConstructedAt(i);; track->Set(x,y,z,....);; ...; ...; }; ...; a.Clear();. even in case where the TTrack class allocates memory. TClonesArray: update ExpandCreateFast to also reset the non-used slots; so that calling Clear (which does too much) is no longer necessary; when using ExpandCreateFast. New Thread Pool class. A first version of TThreadPool class has been introduced.; This class implements a Thread Pool pattern.; So far it supports only one type of queue - FIFO. Thread library. Reduces risk of internal dead lock by using a private internal lock to protect the internals of TThread, rather than using TThread::Lock. New header TThreadSlots.h to centralize and formalize the use of the TThread local memory slots amongst the ROOT packages. Global Variables. The global values gPad, gVirtualX, gInterpreter, gDirectory and gFile; are now all accessed via a static function of t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/doc/v532/index.html:2018,Clear,Clear,2018,core/doc/v532/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/doc/v532/index.html,1,['Clear'],['Clear']
Usability,"h the GCC; implementation, these attributes must appertain to the *declarator-id* in a; declaration, which means they must go either at the start of the declaration or; immediately after the name being declared. For example, this applies the GNU ``unused`` attribute to ``a`` and ``f``, and; also applies the GNU ``noreturn`` attribute to ``f``. .. code-block:: c++. [[gnu::unused]] int a, f [[gnu::noreturn]] ();. Target-Specific Extensions; ==========================. Clang supports some language features conditionally on some targets. ARM/AArch64 Language Extensions; -------------------------------. Memory Barrier Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^; Clang implements the ``__dmb``, ``__dsb`` and ``__isb`` intrinsics as defined; in the `Arm C Language Extensions; <https://github.com/ARM-software/acle/releases>`_.; Note that these intrinsics are implemented as motion barriers that block; reordering of memory accesses and side effect instructions. Other instructions; like simple arithmetic may be reordered around the intrinsic. If you expect to; have no reordering at all, use inline assembly instead. X86/X86-64 Language Extensions; ------------------------------. The X86 backend has these language extensions:. Memory references to specified segments; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Annotating a pointer with address space #256 causes it to be code generated; relative to the X86 GS segment register, address space #257 causes it to be; relative to the X86 FS segment, and address space #258 causes it to be; relative to the X86 SS segment. Note that this is a very very low-level; feature that should only be used if you know what you're doing (for example in; an OS kernel). Here is an example:. .. code-block:: c++. #define GS_RELATIVE __attribute__((address_space(256))); int foo(int GS_RELATIVE *P) {; return *P;; }. Which compiles to (on X86-32):. .. code-block:: gas. _foo:; movl 4(%esp), %eax; movl %gs:(%eax), %eax; ret. You can also use the GCC compatibility macr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:154949,simpl,simple,154949,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['simpl'],['simple']
Usability,"h the ``<<`` operator: the first argument; becomes ``%0``, the second becomes ``%1``, etc. The diagnostic interface; allows you to specify arguments of many different types, including ``int`` and; ``unsigned`` for integer arguments, ``const char*`` and ``std::string`` for; string arguments, ``DeclarationName`` and ``const IdentifierInfo *`` for names,; ``QualType`` for types, etc. ``SourceRange``\ s are also specified with the; ``<<`` operator, but do not have a specific ordering requirement. As you can see, adding and producing a diagnostic is pretty straightforward.; The hard part is deciding exactly what you need to say to help the user,; picking a suitable wording, and providing the information needed to format it; correctly. The good news is that the call site that issues a diagnostic should; be completely independent of how the diagnostic is formatted and in what; language it is rendered. Fix-It Hints; ^^^^^^^^^^^^. In some cases, the front end emits diagnostics when it is clear that some small; change to the source code would fix the problem. For example, a missing; semicolon at the end of a statement or a use of deprecated syntax that is; easily rewritten into a more modern form. Clang tries very hard to emit the; diagnostic and recover gracefully in these and other cases. However, for these cases where the fix is obvious, the diagnostic can be; annotated with a hint (referred to as a ""fix-it hint"") that describes how to; change the code referenced by the diagnostic to fix the problem. For example,; it might add the missing semicolon at the end of the statement or rewrite the; use of a deprecated construct into something more palatable. Here is one such; example from the C++ front end, where we warn about the right-shift operator; changing meaning from C++98 to C++11:. .. code-block:: text. test.cpp:3:7: warning: use of right-shift operator ('>>') in template argument; will require parentheses in C++11; A<100 >> 2> *a;; ^; ( ). Here, the fix-it hint is sugge",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:17919,clear,clear,17919,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['clear'],['clear']
Usability,"h. The first diagram shows a system without folders. The objects have; pointers to each other to access each other's data. Pointers are an; efficient way to share data between classes. However, a direct pointer; creates a direct coupling between classes. This design can become a very; tangled web of dependencies in a system with a large number of classes. ![](pictures/020000E2.jpg). In the second diagram, a reference to the data is in the folder and the; consumers refer to the folder rather than each other to access the data.; The naming and search service provided by the ROOT folders hierarchy; provides an alternative. It loosely couples the classes and greatly; enhances I/O operations. In this way, folders separate the data from the; algorithms and greatly improve the modularity of an application by; minimizing the class dependencies. ![](pictures/020000E3.jpg). In addition, the folder hierarchy creates a picture of the data; organization. This is useful when discussing data design issues or when; learning the data organization. The example below illustrates this; point. ## How to Use Folders. Using folders means to build a hierarchy of folders, posting the; reference to the data in the folder by the producer, and creating a; reference to the folder by the user. ### Creating a Folder Hierarchy. To create a folder hierarchy you add the top folder of your hierarchy to; `//root`. Then you add a folder to an existing folder with the; **`TFolder::AddFolder`** method. This method takes two parameters: the; name and title of the folder to be added. It returns a pointer of the; newly created folder. The code below creates the folder hierarchy shown in the browser. In; this macro, the folder is also added to the list of browsable. This way,; it is visible in the browser on the top level. ``` {.cpp}; {; // Add the top folder of my hierary to //root; TFolder *aliroot=gROOT->GetRootFolder()->AddFolder(""aliroot"",; ""aliroot top level folders"");; // Add the hierarchy to the list ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FoldersTasks.md:2132,learn,learning,2132,documentation/users-guide/FoldersTasks.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FoldersTasks.md,1,['learn'],['learning']
Usability,"h`` from the compiler-rt ``xray`` directory. The important API; functions we list below:. - ``__xray_log_register_mode(...)``: Register a logging implementation against; a string Mode identifier. The implementation is an instance of; ``XRayLogImpl`` defined in ``xray/xray_log_interface.h``.; - ``__xray_log_select_mode(...)``: Select the mode to install, associated with; a string Mode identifier. Only implementations registered with; ``__xray_log_register_mode(...)`` can be chosen with this function.; - ``__xray_log_init_mode(...)``: This function allows for initializing and; re-initializing an installed logging implementation. See; ``xray/xray_log_interface.h`` for details, part of the XRay compiler-rt; installation. Once a logging implementation has been initialized, it can be ""stopped"" by; finalizing the implementation through the ``__xray_log_finalize()`` function.; The finalization routine is the opposite of the initialization. When finalized,; an implementation's data can be cleared out through the; ``__xray_log_flushLog()`` function. For implementations that support in-memory; processing, these should register an iterator function to provide access to the; data via the ``__xray_log_set_buffer_iterator(...)`` which allows code calling; the ``__xray_log_process_buffers(...)`` function to deal with the data in; memory. All of this is better explained in the ``xray/xray_log_interface.h`` header. Basic Mode; ----------. XRay supports a basic logging mode which will trace the application's; execution, and periodically append to a single log. This mode can be; installed/enabled by setting ``xray_mode=xray-basic`` in the ``XRAY_OPTIONS``; environment variable. Combined with ``patch_premain=true`` this can allow for; tracing applications from start to end. Like all the other modes installed through ``__xray_log_select_mode(...)``, the; implementation can be configured through the ``__xray_log_init_mode(...)``; function, providing the mode string and the flag options. B",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/XRay.rst:7657,clear,cleared,7657,interpreter/llvm-project/llvm/docs/XRay.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/XRay.rst,1,['clear'],['cleared']
Usability,"hading according to channels counts-; // PICTURE2_MODE_GROUP_HEIGHT, modes of combination of; // shading according to light and to channels counts-; // PICTURE2_MODE_GROUP_LIGHT_HEIGHT); int display_mode; // spectrum display mode (points, grid, contours, bars, x_lines,; // y_lines, bars_x, bars_y, needles, surface, triangles); int z_scale; // z scale (linear, log, sqrt); int nodesx; // number of nodes in x dimension of grid; int nodesy; // number of nodes in y dimension of grid; int count_reg; // width between contours, applies only for contours display mode; int alfa; // angles of display,alfa+beta must be less or equal to 90, alpha- angle; // between base line of Canvas and left lower edge of picture picture; // base plane; int beta; // angle between base line of Canvas and right lower edge of picture base plane; int view_angle; // rotation angle of the view, it can be 0, 90, 180, 270 degrees; int levels; // # of color levels for rainbowed display modes, it does not apply for; // simple display modes algorithm group; float rainbow1_step; // determines the first component step for neighboring color; // levels, applies only for rainbowed display modes, it does not apply; // for simple display modes algorithm group; float rainbow2_step; // determines the second component step for neighboring; // color levels, applies only for rainbowed display modes, it does not; // apply for simple display modes algorithm group; float rainbow3_step; // determines the third component step for neighboring; // color levels, applies only for rainbowed display modes, it does not; // apply for simple display modes algorithm group; int color_alg; // applies only for rainbowed display modes (rgb smooth algorithm,; // rgb modulo color component, cmy smooth algorithm, cmy modulo; // color component, cie smooth algorithm, cie modulo color component,; // yiq smooth algorithm, yiq modulo color component, hsv smooth; // algorithm, hsv modulo color component, it does not apply for simple; // displa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:77387,simpl,simple,77387,documentation/spectrum/Spectrum.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md,1,['simpl'],['simple']
Usability,"hance CFG to model exception-handling.; Currently exceptions are treated as ""black holes"", and exception-handling; control structures are poorly modeled in order to be conservative.; This could be improved for both C++ and Objective-C exceptions.; (Difficulty: Hard). Core Analyzer Infrastructure; ; Handle unions.; Currently in the analyzer the value of a union is always regarded as; an unknown.; This problem was; previously discussed; on the mailing list, but no solution was implemented.; (Difficulty: Medium) . Floating-point support.; Currently, the analyzer treats all floating-point values as unknown.; This project would involve adding a new SVal kind; for constant floats, generalizing the constraint manager to handle floats,; and auditing existing code to make sure it doesn't; make incorrect assumptions (most notably, that X == X; is always true, since it does not hold for NaN).; (Difficulty: Medium). Improved loop execution modeling.; The analyzer simply unrolls each loop N times before; dropping the path, for a fixed constant N.; However, that results in lost coverage in cases where the loop always; executes more than N times.; A Google Summer Of Code; project; was completed to make the loop bound parameterizable,; but the widening; problem still remains open. (Difficulty: Hard). Basic function summarization support; The analyzer performs inter-procedural analysis using; either inlining or ""conservative evaluation"" (invalidating all data; passed to the function).; Often, a very simple summary; (e.g. ""this function is pure"") would be; enough to be a large improvement over conservative evaluation.; Such summaries could be obtained either syntactically,; or using a dataflow framework.; (Difficulty: Hard). Implement a dataflow flamework.; The analyzer core; implements a symbolic execution; engine, which performs checks; (use-after-free, uninitialized value read, etc.); over a single program path.; However, many useful properties; (dead code, check-after-use, etc.) ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/open_projects.html:6964,simpl,simply,6964,interpreter/llvm-project/clang/www/analyzer/open_projects.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/open_projects.html,1,['simpl'],['simply']
Usability,"hardware anti-aliasing and; shaders is possible. Prototype visualization of 5-dimensional distributions:. New option for TTree::Draw - ""gl5d"", for the case you have 5 and; more dimensional dataset.; Set of iso-surfaces created, 4-th dimension is used to select iso-level.; ""gl5d"" is now very similar to ""gliso"" option, but instead of; filling TH3 object (very primitive and rude ""density estimator""),; points are fed directly to the kernel density estimator, based on; Fast Gauss Transform. See TGL5D* classes. Limitations: 5-th dimension is not shown correctly at the moment; (lacks sofisticated algorithms, we do not have in a ROOT's math; library now). Because of this limitation, GUI is just a toy now, must; be changed. Future directions:. GUI improvements.; Support several different density estimators.; Implement regression tools. Minor changes, fixes and improvements. It is now possible to draw a histogram with the ""GLBOX"" in the; GL-viewer. New class TGLColor has been introduced to simplify color; management in TGLViewer and TGLRnrCtx. Add support for several color-sets (class TGLColorSet -; each defines colors for background, foreground, outline, markup and; for outlines of selected and highlighted objects. This also allows for independent changing of background color and; outline mode in the GL viewer - the e key now toggles between; dark / light background. New class TGLAnnotation - it allows display of; annotation-text on top of displayed objects. The annotation can be created from the TGLViewer editor; (""Guides"" tab). After that it can be dragged around the screen, edited; or closed. TGLAxisPainter - reimplemented to completely separate; label and tick-mark positioning code from the rendering itself. TGLSAViewer - when exporting an image properly take into; account image extension if it was typed by the user. TGLFont now uses the same font-naming scheme as the rest; of ROOT (had to specify font-file names before). Overlay-object management has been improved. Allow",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/doc/v524/index.html:2648,simpl,simplify,2648,graf3d/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/doc/v524/index.html,1,['simpl'],['simplify']
Usability,"has three integers called; `ntrack`, `nseg`, and `nvtex`. ``` {.cpp}; ""ntrack/I:nseg:nvtex""; ```. There is one more rule: when no type is given for the very first leaf,; it becomes a `float` (F). This leaf list has three floats called `temp`,; `mass`, and `px`. ``` {.cpp}; ""temp:mass:px""; ```. The symbols used for the type are:. - `C`: a character string terminated by the 0 character; - `B`: an 8 bit signed integer; - `b`: an 8 bit unsigned integer; - `S`: a 16 bit signed integer; - `s`: a 16 bit unsigned integer; - `I`: a 32 bit signed integer; - `i`: a 32 bit unsigned integer; - `L`: a 64 bit signed integer; - `l`: a 64 bit unsigned integer; - `G`: a long signed integer, stored as 64 bit; - `g`: a long unsigned integer, stored as 64 bit; - `F`: a 32 bit floating point; - `D`: a 64 bit floating point; - `O`: [the letter 'o', not a zero] a boolean (Bool\_t). The type is used for a byte count to decide how much space to allocate.; The variable written is simply the block of bytes starting at the; starting address given in the second parameter. It may or may not match; the leaf list depending on whether or not the programmer is being; careful when choosing the leaf address, name, and type. By default, a variable will be copied with the number of bytes specified; in the type descriptor symbol. However, if the type consists of two; characters, the number specifies the number of bytes to be used when; copying the variable to the output buffer. The line below describes; `ntrack` to be written as a 16-bit integer (rather than a 32-bit; integer). ``` {.cpp}; ""ntrack/I2""; ```. With this Branch method, you can also add a leaf that holds an entire; array of variables. To add an array of floats use the `f[n]` notation; when describing the leaf. ``` {.cpp}; Float_t f[10];; tree->Branch(""fBranch"",f,""f[10]/F"");; ```. You can also add an array of variable length:. ``` {.cpp}; {; TFile *f = new TFile(""peter.root"",""recreate"");; Int_t nPhot;; Float_t E[500];; TTree* nEmcPhotons = new ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:21782,simpl,simply,21782,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['simpl'],['simply']
Usability,"hat gives public access to the generation of toy data with all the same options for the treatment of nuisance parameters, binned or unbinned data, treatment of the global observables, importance sampling, etc. This is new method particularly useful for producing the expected limit bands where one needs to generate background-only pseudo-experiments in the same way that was used for the primary limit calculation. HypoTestResult. In the process of writing the new HypoTestInverter the conventions for p-values, CLb, CLs+b, and CLs were revisited. The situation is complicated by the fact that when performing a hypothesis test for discovery the null is background-only, but when performing an inverted hypothesis test the null is a signal+background model. The new convention is that the p-value for both the null and the alternate are taken from the same tail (as specified by the test statistic). Both CLs+b and CLb are equivalent to these p-values, and the HypoTestResult has a simple switch SetBackgroundIsAlt() to specify the pairing between (null p-value, alternate p-value) and (CLb, CLs+b). HypoTestInverter, HypoTestInverterResult, HypoTestInverterPlot. These classes have been rewritten for using them with the new hypothesis test calculators. The HypoTestInverter; class can now be constructed by any generic HypoTestCalculator, and both the HybridCalculator and the new; FrequentistCalculator are supported. The HypoTestInverter class can be constructed in two ways: either passing an; HypoTestCalculator and a data set or by passing the model for the signal, for the background and a data set.; In the first case the user configure the HypoTestCalculator before passing to the HypoTestInverter.; It must be configured using as null model the signal plus background model as alternate model the background; model. Optionally the user can pass the parameter to scan, if it is not passed, the first parameter of interest of the; null model will be used. In the second case (when passing d",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v530/index.html:3155,simpl,simple,3155,roofit/doc/v530/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v530/index.html,1,['simpl'],['simple']
Usability,"he ``preferred_name`` attribute, if any.; This implies that the ``preferred_name`` wouldn't show in debugger or dumping. This is tracked in: https://github.com/llvm/llvm-project/issues/56490. Don't emit macros about module declaration; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. This is covered by P1857R3. We mention it again here since users may abuse it before we implement it. Someone may want to write code which could be compiled both by modules or non-modules.; A direct idea would be use macros like:. .. code-block:: c++. MODULE; IMPORT header_name; EXPORT_MODULE MODULE_NAME;; IMPORT header_name; EXPORT ... So this file could be triggered like a module unit or a non-module unit depending on the definition; of some macros.; However, this kind of usage is forbidden by P1857R3 but we haven't implemented P1857R3 yet.; This means that is possible to write illegal modules code now, and obviously this will stop working; once P1857R3 is implemented.; A simple suggestion would be ""Don't play macro tricks with module declarations"". This is tracked in: https://github.com/llvm/llvm-project/issues/56917. In consistent filename suffix requirement for importable module units; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. Currently, clang requires the file name of an ``importable module unit`` should end with ``.cppm``; (or ``.ccm``, ``.cxxm``, ``.c++m``). However, the behavior is inconsistent with other compilers. This is tracked in: https://github.com/llvm/llvm-project/issues/57416. clang-cl is not compatible with the standard C++ modules; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. Now we can't use the `/clang:-fmodule-file` or `/clang:-fprebuilt-module-path` to specify; the BMI within ``clang-cl.exe``. This is tracked in: https://github.com/llvm/llvm-project/issues/64118. false positive ODR violation diagnostic due to using inconsistent qualified but the same type; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:24128,simpl,simple,24128,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,1,['simpl'],['simple']
Usability,"he above statements is not; expected to be the same cycle for different headers. Cycles and; their headers are tightly coupled; for different headers in the; same outermost cycle, the child cycles detected may be different.; The property relevant to the above examples is that for every; closed path, there is a cycle ``C`` that contains the path and; whose header is on that path. The diverged entry criterion must be checked for every closed path; passing through a divergent branch ``B`` and its join ``J``. Since; :ref:`every closed path passes through the header of some; cycle<cycle-closed-path-header>`, this amounts to checking every cycle; ``C`` that contains ``B`` and ``J``. When the header of ``C``; dominates the join ``J``, there can be no entry to any path from the; header to ``J``, which includes any diverged path from ``B`` to ``J``.; This is also true for any closed paths passing through the header of; an outer cycle that contains ``C``. Thus, the diverged entry criterion can be conservatively simplified; as follows:. For a divergent branch ``B`` and its join node ``J``, the nodes in a; cycle ``C`` that contains both ``B`` and ``J`` are m-converged only; if:. - ``B`` strictly dominates ``J``, or,; - The header ``H`` of ``C`` strictly dominates ``J``, or,; - Recursively, there is cycle ``C'`` inside ``C`` that satisfies the; same condition. When ``J`` is the same as ``H`` or ``B``, the trivial dominance is; insufficient to make any statement about entries to diverged paths. .. _convergence-diverged-outside:. Diverged Paths reaching a Cycle; -------------------------------. .. figure:: convergence-divergent-outside.png; :name: convergence-divergent-outside. The figure shows two cycle hierarchies with a divergent branch in; ``Entry`` instead of ``Q``. For two threads that enter the closed path; ``P -> Q -> R -> S`` at ``P`` and ``R`` respectively, the convergence; of dynamic instances generated along the path depends on whether ``P``; or ``R`` is the header. - ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergenceAndUniformity.rst:25826,simpl,simplified,25826,interpreter/llvm-project/llvm/docs/ConvergenceAndUniformity.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergenceAndUniformity.rst,1,['simpl'],['simplified']
Usability,"he command line option; when you declare it. `Custom parsers`_ are no problem. #. Labor Saving: The CommandLine library cuts down on the amount of grunt work; that you, the user, have to do. For example, it automatically provides a; ``-help`` option that shows the available command line options for your tool.; Additionally, it does most of the basic correctness checking for you. #. Capable: The CommandLine library can handle lots of different forms of; options often found in real programs. For example, `positional`_ arguments,; ``ls`` style `grouping`_ options (to allow processing '``ls -lad``'; naturally), ``ld`` style `prefix`_ options (to parse '``-lmalloc; -L/usr/lib``'), and interpreter style options. This document will hopefully let you jump in and start using CommandLine in your; utility quickly and painlessly. Additionally it should be a simple reference; manual to figure out how stuff works. Quick Start Guide; =================. This section of the manual runs through a simple CommandLine'ification of a; basic compiler tool. This is intended to show you how to jump into using the; CommandLine library in your own program, and show you some of the cool things it; can do. To start out, you need to include the CommandLine header file into your program:. .. code-block:: c++. #include ""llvm/Support/CommandLine.h"". Additionally, you need to add this as the first line of your main program:. .. code-block:: c++. int main(int argc, char **argv) {; cl::ParseCommandLineOptions(argc, argv);; ...; }. ... which actually parses the arguments and fills in the variable declarations. Now that you are ready to support command line arguments, we need to tell the; system which ones we want, and what type of arguments they are. The CommandLine; library uses a declarative syntax to model command line arguments with the; global variable declarations that capture the parsed values. This means that; for every command line option that you would like to support, there should be a; glob",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst:3716,simpl,simple,3716,interpreter/llvm-project/llvm/docs/CommandLine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst,1,['simpl'],['simple']
Usability,"he connection to the system. - Definition of main frame (top level window). - Creation of widgets as children of the top-level frame; assign them; desired properties following the steps:. - Create a new widget passing its parent in the constructor. - Connect widget's signals with desired slots to ensure desired; functionality. - Define widget's layout and add it to the parent list of children. - Set main window attributes. - Map all sub windows. - Initialize the layout algorithm via `Resize(GetDefaultSize())`; method. - Map the main frame. - Execution of the even-processing loop. ### A Standalone Version. As usual a standalone program in C++ has to contain a main() function -; the starting point for the application execution. In this case it is; better to separate the program code creating a program header file; example2a.h with the `MyMainFrame` class declaration and; `example2a.cxx `- with the class methods implementation. To run our; simple example as a standalone application we need to create in addition; an object of class **`TApplication`**. It will make a correct; initialization of the dictionaries if it is not yet done. It will be; responsible for holding everything together and to handle all events in; the application. Its environment provides an interface to the ROOT; graphics system and by calling the `Run()` method the event loop starts; and the application program is waiting for the user action. The; application exits only if the top level window is not closed. Two header; files are used in addition: `TApplication.h` - for the class; **`TApplication`** and `TGClient.h` that is used to make initial; connection to the graphics system. The class **`TApplication`** must be; instantiated only once in any given application. The original list of; argument options can be retrieved via the `Argc()` and `Argv()` methods. Note: to have signals/slots working we need to create a dictionary for; the class `MyMainFrame`, i.e. we create the file `ex2aLinkDef.h`; contain",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:15741,simpl,simple,15741,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,1,['simpl'],['simple']
Usability,"he criteria; :ref:`described earlier <convergence-uniformity>`. The discovery of; divergent outputs may cause their uses (including branches) to also; become divergent. The analysis propagates this divergence until a; fixed point is reached. The convergence inferred using these criteria is a safe subset of the; maximal converged-with relation for any cycle hierarchy. In; particular, it is sufficient to determine if a static instance is; m-converged for a given cycle hierarchy ``T``, even if that fact is; not detected when examining some other cycle hierarchy ``T'``. This property allows compiler transforms to use the uniformity; analysis without being affected by DFS choices made in the underlying; cycle analysis. When two transforms use different instances of the; uniformity analysis for the same CFG, a ""divergent value"" result in; one analysis instance cannot contradict a ""uniform value"" result in; the other. Generic transforms such as SimplifyCFG, CSE, and loop transforms; commonly change the program in ways that change the maximal; converged-with relations. This also means that a value that was; previously uniform can become divergent after such a transform.; Uniformity has to be recomputed after such transforms. Divergent Branch inside a Cycle; -------------------------------. .. figure:: convergence-divergent-inside.png; :name: convergence-divergent-inside. The above figure shows a divergent branch ``Q`` inside an irreducible; cyclic region. When two threads diverge at ``Q``, the convergence of; dynamic instances within the cyclic region depends on the cycle; hierarchy chosen:. 1. In an implementation that detects a single cycle ``C`` with header; ``P``, convergence inside the cycle is determined by ``P``. 2. In an implementation that detects two nested cycles with headers; ``R`` and ``S``, convergence inside those cycles is determined by; their respective headers. .. _convergence-diverged-entry:. A conservative approach would be to simply report all nodes insi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergenceAndUniformity.rst:20584,Simpl,SimplifyCFG,20584,interpreter/llvm-project/llvm/docs/ConvergenceAndUniformity.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergenceAndUniformity.rst,1,['Simpl'],['SimplifyCFG']
Usability,"he generated class of lambda expressions. Given:; auto x = []{};. cxxRecordDecl(isLambda()) matches the implicit class declaration of; decltype(x). Matcher<CXXRecordDecl>isSameOrDerivedFromstd::string BaseName; Overloaded method as shortcut for; isSameOrDerivedFrom(hasName(...)). Matcher<CXXRecordDecl>isTemplateInstantiation; Matches template instantiations of function, class, or static; member variable template instantiations. Given; template <typename T> class X {}; class A {}; X<A> x;; or; template <typename T> class X {}; class A {}; template class X<A>;; or; template <typename T> class X {}; class A {}; extern template class X<A>;; cxxRecordDecl(hasName(""::X""), isTemplateInstantiation()); matches the template instantiation of X<A>. But given; template <typename T> class X {}; class A {};; template <> class X<A> {}; X<A> x;; cxxRecordDecl(hasName(""::X""), isTemplateInstantiation()); does not match, as X<A> is an explicit template specialization. Usable as: Matcher<FunctionDecl>, Matcher<VarDecl>, Matcher<CXXRecordDecl>. Matcher<CXXRewrittenBinaryOperator>hasAnyOperatorNameStringRef, ..., StringRef; Matches operator expressions (binary or unary) that have any of the; specified names. hasAnyOperatorName(""+"", ""-""); Is equivalent to; anyOf(hasOperatorName(""+""), hasOperatorName(""-"")). Matcher<CXXRewrittenBinaryOperator>hasOperatorNamestd::string Name; Matches the operator Name of operator expressions and fold expressions; (binary or unary). Example matches a || b (matcher = binaryOperator(hasOperatorName(""||""))); !(a || b). Example matches `(0 + ... + args)`; (matcher = cxxFoldExpr(hasOperatorName(""+""))); template <typename... Args>; auto sum(Args... args) {; return (0 + ... + args);; }. Matcher<CXXRewrittenBinaryOperator>isAssignmentOperator; Matches all kinds of assignment operators. Example 1: matches a += b (matcher = binaryOperator(isAssignmentOperator())); if (a == b); a += b;. Example 2: matches s1 = s2; (matcher = cxxOperatorCallExpr(isAssignmentOperator())); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:75071,Usab,Usable,75071,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['Usab'],['Usable']
Usability,"he generated; // histograms we open a browser and the TreeViewer; if (gROOT->IsBatch()) return;; new TBrowser ();; t1->StartViewer();. //In the browser, click on ""ROOT Files"", then on ""tree1.root""; //You can click on the histogram icons in the right panel to draw; //them in the TreeViewer, follow the instructions in the Help.; }; ```. ## Example 2: A Tree with a C Structure. The executable script for this example is; `$ROOTSYS/tutorials/tree/tree2.C. `In this example we show:. - how to build branches from a C structure; - how to make a branch with a fixed length array; - how to make a branch with a variable length array; - how to read selective branches; - how to fill a histogram from a branch; - how to use `TTree::Draw` to show a 3D plot. A C structure (`struct`) is used to build a ROOT tree. In general we; discourage the use of C structures`,` we recommend using a class; instead. However, we do support them for legacy applications written in; C or FORTRAN. The example `struct` holds simple variables and arrays. It; maps to a Geant3 common block `/gctrak/. `This is the definition of the; common block/structure:. ``` {.cpp}; const Int_t MAXMEC = 30;; // PARAMETER (MAXMEC=30); // COMMON/GCTRAK/VECT(7),GETOT,GEKIN,VOUT(7); // + ,NMEC,LMEC(MAXMEC); // + ,NAMEC(MAXMEC),NSTEP; // + ,PID,DESTEP,DESTEL,SAFETY,SLENG; // + ,STEP,SNEXT,SFIELD,TOFG,GEKRAT,UPWGHT. typedef struct {; Float_t vect[7];; Float_t getot;; Float_t gekin;; Float_t vout[7];; Int_t nmec;; Int_t lmec[MAXMEC];; Int_t namec[MAXMEC];; Int_t nstep;; Int_t pid;; Float_t destep;; Float_t destel;; Float_t safety;; Float_t sleng;; Float_t step;; Float_t snext;; Float_t sfield;; Float_t tofg;; Float_t gekrat;; Float_t upwght;; } Gctrak_t;; ```. When using Geant3, the common block is filled by Geant3 routines at each; step and only the `TTree::Fill` method needs to be called. In this; example we emulate the Geant3 step routine with the `helixStep`; function. We also emulate the filling of the particle values. The ca",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:43464,simpl,simple,43464,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['simpl'],['simple']
Usability,"he long standing issue of ACliC linking all previously created; shared libs even when not needed). Linux. Make --enable-explictlink the default on linux too (was already the case for:; macosx, freebsd, openbsd, aix and win32). This adds some extra time to; the link stage, which can be recuperated by using the newer, much faster,; gold linker. In addition we added the linker option ""-Wl,--no-undefined"",; so you will get an error if symbols are unresolved.; Explicit linking is required by newer distributions, like Ubuntu 11.10,; that require all dependent shared libs to be specified when linking. They; also have default options set to dead strip shared libs that don't resolve; any symbols (equivalent to the MacOS X build changes described above). Core Libraries; TClonesArray. Introduce TClonesArray::ConstructedAt which; always returns an already constructed object. If the slot is being used for the; first time, it calls the default constructor otherwise it returns the object as; is (unless a string is passed as the 2nd argument to the function in which case,; it also calls Clear(second_argument) on the object).; This allows to replace code like:. for (int i = 0; i < ev->Ntracks; i++) {; new(a[i]) TTrack(x,y,z,...);; ...; ...; }; ...; a.Delete(); // or a.Clear(""C""). with the simpler and more efficient:. for (int i = 0; i < ev->Ntracks; i++) {; TTrack *track = (TTrack*)a.ConstructedAt(i);; track->Set(x,y,z,....);; ...; ...; }; ...; a.Clear();. even in case where the TTrack class allocates memory. TClonesArray: update ExpandCreateFast to also reset the non-used slots; so that calling Clear (which does too much) is no longer necessary; when using ExpandCreateFast. New Thread Pool class. A first version of TThreadPool class has been introduced.; This class implements a Thread Pool pattern.; So far it supports only one type of queue - FIFO. Thread library. Reduces risk of internal dead lock by using a private internal lock to protect the internals of TThread, rather than usi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/doc/v532/index.html:1834,Clear,Clear,1834,core/doc/v532/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/doc/v532/index.html,1,['Clear'],['Clear']
Usability,"he lower and higher axis limits are always; different.; - Protection added to avoid a Seg Fault on `.q` when `SetHistogram()`; is called on a `TGraph2D`. ### TMultiGraph. - In `TMultiGraph::Add(TMultiGraph *multigraph, Option_t *chopt)`; If `chopt` is defined all the graphs in `multigraph` will be added; with the `chopt` option. If `chopt` is undefined each graph will; be added with the option it had in `multigraph`.; - The option ""A"" in the `Draw()` was not cleaning properly the; current pad.; - Implement this option `pads`. This option is equivalent to the one in; `THStack`. It allows to draw all the `TGraphs` in separated pads. ### THStack. - By default the background of the histograms is erased before drawing the; histograms. The new option `noclear` avoid this behaviour. This is useful; when drawing a `THStack` on top of an other plot. If the patterns used to; draw the histograms in the stack are transparents, then the plot behind; will be visible. ### TH2Poly. - Implement a simple version of ""Scale"". ### TF1. - Change `TF1::Integral(double a, double b, double * params = 0, double eps = 1.E-12)` to; `TF1::Integral(doubnle a, double b, double epsrel=1.E-12)`. One should use `TF1::SetParameters` to; set the function parameters before computing the integral. - Add a new function `TF1::IntegralOneDim(Double_t a, Double_t b, Double_t epsrel, Double_t epsabs, Double_t &err)`; that returns as last argument the error in the integration. `TF1::Integral` is implemented using `Tf1::IntegralOneDim`. - The one-dim and multi-dim integral functions are now implemented using the `ROOT::Math::IntegratorOneDim` and `ROOT::Math::IntegratorMultiDim`; classes. This allows to change the integration algorithm used in `TF1` using the static methods of the classes; `ROOT::Math::IntegratorOneDimOptions` and `ROOT::Math::IntegratorMultiDimOptions`. The default algorithm used are; `ROOT::Math::IntegratorOneDimOptions::DefaultIntegratorType()` and `ROOT::Math::IntegratorMultiDimOptions::Def",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v600/index.md:12323,simpl,simple,12323,hist/doc/v600/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v600/index.md,1,['simpl'],['simple']
Usability,"he mouse. The Graphical User Interface is as a bridge between the; user and the program - it provides methods to detect the user actions; and instruments that do something as a reaction of these actions. The; user communicates with an application through the window system. The; window system reports interaction events to the application. The; application in turn forwards them to the currently active window. The; objects/widgets receive the events and react to them according to the; application functionality. ![](pictures/0200020B.jpg). The signals/slot communication mechanism is an advanced object; communication concept; it largely replaces the concept of callback; functions to handle actions in GUI's. Signals and slots are just like; any object-oriented methods implemented in C++. The objects are the; instances of classes that don't know anything about each other. They; interact and allow method calls of other object's methods. The idea is; simple: any object can send out (emit) a signal in certain situations; saying that something happened. This is all it does to communicate and; it does not know whether anything is interested in this information. On; the other side there might be an object waiting for that signal and; ready to react to it. This object disposes of special instruments to; listen to the sent out signals. To have a communication we need a; message transmission between the objects. In this simple example we use; signals and slots. The code of the method **`TGButton::Clicked()`** is:. ``` {.cpp}; virtual void Clicked() { Emit(""Clicked()""); } // *SIGNAL*; ```. I.e. any button emits the signal `Clicked()` any time someone clicks on; it. As you can see this method is virtual and could be overridden if you; need to. In our simple example we call the `Connect()` method to connect; the `Clicked()` signal of Draw button with `MyMainFrame::DoDraw():`. ``` {.cpp}; draw->Connect(""Clicked()"",""MyMainFrame"",this,""DoDraw()"");; ```. In the same way we can connect to ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:41100,simpl,simple,41100,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,1,['simpl'],['simple']
Usability,"he need for more design discussions),; they may ask for a revert to the original author who is responsible to revert; the patch promptly. Developers often disagree, and erring on the side of the; developer asking for more review prevents any lingering disagreement over; code in the tree. This does not indicate any fault from the patch author,; this is inherent to our post-commit review practices.; Reverting a patch ensures that design discussions can happen without blocking; other development; it's entirely possible the patch will end up being reapplied; essentially as-is once concerns have been resolved. Before being recommitted, the patch generally should undergo further review.; The community member who identified the problem is expected to engage; actively in the review. In cases where the problem is identified by a buildbot,; a community member with access to hardware similar to that on the buildbot is; expected to engage in the review. Please note: The bar for post-commit feedback is not higher than for pre-commit; feedback. Don't delay unnecessarily in providing feedback. However, if you see; something after code has been committed about which you would have commented; pre-commit (had you noticed it earlier), please feel free to provide that; feedback at any time. That having been said, if a substantial period of time has passed since the; original change was committed, it may be better to create a new patch to; address the issues than comment on the original commit. The original patch; author, for example, might no longer be an active contributor to the project. What Tools Are Used for Code Review?; ------------------------------------. Pre-commit code reviews are conducted on GitHub with Pull Requests. See; :ref:`GitHub <github-reviews>` documentation. When Is an RFC Required?; ------------------------. Some changes are too significant for just a code review. Changes that should; change the LLVM Language Reference (e.g., adding new target-independent; intrin",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeReview.rst:3148,feedback,feedback,3148,interpreter/llvm-project/llvm/docs/CodeReview.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeReview.rst,2,['feedback'],['feedback']
Usability,"he new flag `RSnapshotOption::fOverwriteIfExists` to `true` to force the deletion of the TTree that is; already present and the writing of a new TTree with the same name. See; [ROOT-10573](https://sft.its.cern.ch/jira/browse/ROOT-10573) for more details.; - RDataFrame changed its error handling strategy in case of unreadable input files. Instead of simply logging an error; and skipping the file, it now throws an exception if any of the input files is unreadable (this could also happen in; the middle of an event loop). See [ROOT-10549](https://sft.its.cern.ch/jira/browse/ROOT-10549) for more details.; - New analysis examples based on the recent ATLAS Open Data release ([`Higgs to two photons`](https://root.cern/doc/master/df104__HiggsToTwoPhotons_8py.html), [`W boson analysis`](https://root.cern/doc/master/df105__WBosonAnalysis_8py.html), [`Higgs to four leptons`](https://root.cern/doc/master/df106__HiggsToFourLeptons_8py.html)); - An exception is now thrown in case the size of ROOT's thread-pool changes between RDataFrame construction time and the time the event loop begins.; - Just-in-time compilation of large portions of the computation graph has been optimized, and it is now much faster. Please report any regressions you might encounter on [our issue tracker](https://sft.its.cern.ch/jira/projects/ROOT).; - `MakeRootDataFrame` is now a safe way to construct RDFs. It used to return RDFs with more limited functionality. ## PyROOT. - Introduce the `ROOT.Numba.Declare` decorator which provides a simple way to call Python callables from C++. The Python callables are; just-in-time compiled with [numba](http://numba.pydata.org/), which ensures a runtime performance similar to a C++ implementation.; The feature is targeted to improve the performance of Python based analyses, e.g., allows seamless integration into `RDataFrame` workflows.; See the tutorial [`pyroot004_NumbaDeclare.py`](https://root.cern/doc/master/pyroot004__NumbaDeclare_8py.html) for further information.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v622/index.md:10964,simpl,simple,10964,README/ReleaseNotes/v622/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v622/index.md,1,['simpl'],['simple']
Usability,"he other branch; event not split is not expandable and we can not browse the data; members. The **`TClonesArray`** of tracks `fTracks` is also split because we set; the split level to 2. The output on the command line is the result of; `tree4->Show()`. It shows the first entry with more than 587 tracks:. ``` {.cpp}; ======> EVENT:26; event_split =; fUniqueID = 0; fBits = 50331648; fType[20] = 116 121 112 101 49 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0; fNtrack = 585; fNseg = 5834; fNvertex = 17; fFlag = 0; fTemperature = 20.044315; fEvtHdr.fEvtNum = 26; fEvtHdr.fRun = 200; fEvtHdr.fDate = 960312; fTracks = 585; fTracks.fUniqueID = 0, 0, 0, 0, 0, 0, 0, 0, 0, 0; ...; ```. ## Example 5: Import an ASCII File into a TTree. The method `TTree::ReadFile` can be used to automatic define the; structure of the **`TTree`** and read the data from a formatted ascii; file. ``` {.cpp}; Long64_t TTree::ReadFile(const char *filename,; const char *branchDescriptor); ```. Creates or simply read branches from the file named whose name is passed; in `'filename'`. ``` {.cpp}; {; gROOT->Reset();; TFile *f = new TFile(""basic2.root"",""RECREATE"");; TH1F *h1 = new TH1F(""h1"",""x distribution"",100,-4,4);; TTree *T = new TTree(""ntuple"",""data from ascii file"");; Long64_t nlines = T->ReadFile(""basic.dat"",""x:y:z"");; printf("" found %lld pointsn"",nlines);; T->Draw(""x"",""z>2"");; T->Write();; }; ```. If `branchDescriptor` is set to an empty string (the default), it is; assumed that the **`Tree`** descriptor is given in the first line of the; file with a syntax like: `A/D:Table[2]/F:Ntracks/I:astring/C`. Otherwise branchDescriptor must be specified with the above syntax.Lines; in the input file starting with ""\#"" are ignored. A **`TBranch`** object; is created for each variable in the expression. The total number of rows; read from the file is returned. ## Trees in Analysis. The methods `TTree::Draw`, `TTree::MakeClass` and; `TTree::MakeSelector` are available for data analysis using trees. The; **`TTree::Draw`** metho",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:66660,simpl,simply,66660,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['simpl'],['simply']
Usability,"he palette axis title is correct after a histogram cloning. This; problem was mentioned [here](https://sft.its.cern.ch/jira/browse/ROOT-8007).; * `TASImage` When the first or last point of a wide line is exactly on the; window limit the line is drawn vertically or horizontally.; This problem was mentioned [here](https://sft.its.cern.ch/jira/browse/ROOT-8021); * Make sure that `TLatex` text strings containing ""\\"" (ie: rendered using `TMathText`); produce an output in PDF et SVG files.; * In TLatex, with the Cocoa backend on Mac the Angstroem characters did not render correctly.; This problem was mentioned [here](https://root.cern.ch/phpBB3/viewtopic.php?f=3&t=21321); * New version of libpng (1.2.55) as requested [here](https://sft.its.cern.ch/jira/browse/ROOT-8045).; * Enhancement of the CANDLE drawing option (implemented by Georg Troska georg.troska@tu-dortmund.de).; This option has been completely rewritten and offers a wide range of possibilities.; See the THistPainter reference guide for all the details and examples.; * Fix `TText` copy constructor as requested [here](https://sft.its.cern.ch/jira/browse/ROOT-8116).; New example to check this fix.; * SVG boxes were not correct when `x2<1` (reported [here](https://sft.its.cern.ch/jira/browse/ROOT-8126)).; * In TASImage there was no protection against graphics being drawn outside the assigned; memory. That may generate some crashes like described [here](https://sft.its.cern.ch/jira/browse/ROOT-8123).; * In TASImage: transparent rectangles did not work when png files were created in batch mode.; * In TASImage: implement transparent text for png files created in batch mode.; * TCanvas title was not set correctly when a TCanvas was read from a TFile.; (reported [here](https://root.cern.ch/phpBB3/viewtopic.php?f=3&t=21540&p=94053#p93981)).; * The text generated by `TSVG` has now the `xml:space=""preserve""` attribute in order; to be editable later on using external softwares like ""inkscape"". This improvement; was suggest",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v608/index.md:17078,guid,guide,17078,README/ReleaseNotes/v608/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v608/index.md,1,['guid'],['guide']
Usability,"he position; of the fictive light source; - 2 = Height - the shading is carried out according to the channel; contents; - 3 = LightHeight - combination of two previous shading algorithms; (one can control the weight between both algorithms). ""Display modes"" can take the following values:. - 1 = Points; - 2 = Grid; - 3 = Contours; - 4 = Bars; - 5 = LinesX; - 6 = LinesY; - 7 = BarsX; - 8 = BarsY; - 9 = Needles; - 10 = Surface; - 11 = Triangles. These parameters can be set by using the ""`dm`"" operator in the; option. ``` {.cpp}; h2->Draw(""SPEC dm(1,2)"");; ```. The above example draws the histogram using the ""Light Display mode; group"" and the ""Grid Display mode"". The following tables summarize all; the possible combinations of both groups:. +-----------+------+----+--------+----+------+------+; | |Points|Grid|Contours|Bars|LinesX|LinesY|; +-----------+------+----+--------+----+------+------+; |Simple | x | x | x |x |x |x |; +-----------+------+----+--------+----+------+------+; |Light | x | x | - |- |x |x |; +-----------+------+----+--------+----+------+------+; |Height | x | x | x |x |x |x |; +-----------+------+----+--------+----+------+------+; |LightHeight| x | x | - |- |x |x |; +-----------+------+----+--------+----+------+------+. +------------+-----+-----+-------+-------+----------+; | |BarsX|BarsY|Needles|Surface|Triangles |; +------------+-----+-----+-------+-------+----------+; |Simple |x |x |x |- |x |; +------------+-----+-----+-------+-------+----------+; |Light |- |- |- |x |x |; +------------+-----+-----+-------+-------+----------+; |Height |x |x |- |x |x |; +------------+-----+-----+-------+-------+----------+; |LightHeight |- |- |- |x |x |; +------------+-----+-----+-------+-------+----------+. The ""Pen Attributes"" can be changed using `pa(color,style,width)`.; Next example sets line color to 2, line type to 1 and line width to 2.; Note that if `pa()` is not specified, the histogram line attributes; are used:. ``` {.cpp}; h2->Draw(""SPEC dm(1,2) pa(2,1,2)",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:35631,Simpl,Simple,35631,documentation/users-guide/Histograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md,1,['Simpl'],['Simple']
Usability,"he presence; of a single statement that is accompanied by a comment (assuming the comment; can't be hoisted above the ``if`` or loop statement, see below). Similarly, braces should be used when a single-statement body is complex enough; that it becomes difficult to see where the block containing the following; statement began. An ``if``/``else`` chain or a loop is considered a single; statement for this rule, and this rule applies recursively. This list is not exhaustive. For example, readability is also harmed if an; ``if``/``else`` chain does not use braced bodies for either all or none of its; members, or has complex conditionals, deep nesting, etc. The examples below; intend to provide some guidelines. Maintainability is harmed if the body of an ``if`` ends with a (directly or; indirectly) nested ``if`` statement with no ``else``. Braces on the outer ``if``; would help to avoid running into a ""dangling else"" situation. .. code-block:: c++. // Omit the braces since the body is simple and clearly associated with the; // `if`.; if (isa<FunctionDecl>(D)); handleFunctionDecl(D);; else if (isa<VarDecl>(D)); handleVarDecl(D);. // Here we document the condition itself and not the body.; if (isa<VarDecl>(D)) {; // It is necessary that we explain the situation with this surprisingly long; // comment, so it would be unclear without the braces whether the following; // statement is in the scope of the `if`.; // Because the condition is documented, we can't really hoist this; // comment that applies to the body above the `if`.; handleOtherDecl(D);; }. // Use braces on the outer `if` to avoid a potential dangling `else`; // situation.; if (isa<VarDecl>(D)) {; if (shouldProcessAttr(A)); handleAttr(A);; }. // Use braces for the `if` block to keep it uniform with the `else` block.; if (isa<FunctionDecl>(D)) {; handleFunctionDecl(D);; } else {; // In this `else` case, it is necessary that we explain the situation with; // this surprisingly long comment, so it would be unclear wit",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst:62936,simpl,simple,62936,interpreter/llvm-project/llvm/docs/CodingStandards.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst,2,"['clear', 'simpl']","['clearly', 'simple']"
Usability,"he process; exit. Example:. .. code-block:: console. % cat -n cov.cc; 1 #include <stdio.h>; 2 __attribute__((noinline)); 3 void foo() { printf(""foo\n""); }; 4; 5 int main(int argc, char **argv) {; 6 if (argc == 2); 7 foo();; 8 printf(""main\n"");; 9 }; % clang++ -g cov.cc -fsanitize=address -fsanitize-coverage=trace-pc-guard; % ASAN_OPTIONS=coverage=1 ./a.out; wc -c *.sancov; main; SanitizerCoverage: ./a.out.7312.sancov 2 PCs written; 24 a.out.7312.sancov; % ASAN_OPTIONS=coverage=1 ./a.out foo ; wc -c *.sancov; foo; main; SanitizerCoverage: ./a.out.7316.sancov 3 PCs written; 24 a.out.7312.sancov; 32 a.out.7316.sancov. Every time you run an executable instrumented with SanitizerCoverage; one ``*.sancov`` file is created during the process shutdown.; If the executable is dynamically linked against instrumented DSOs,; one ``*.sancov`` file will be also created for every DSO. Sancov data format; ------------------. The format of ``*.sancov`` files is very simple: the first 8 bytes is the magic,; one of ``0xC0BFFFFFFFFFFF64`` and ``0xC0BFFFFFFFFFFF32``. The last byte of the; magic defines the size of the following offsets. The rest of the data is the; offsets in the corresponding binary/DSO that were executed during the run. Sancov Tool; -----------. A simple ``sancov`` tool is provided to process coverage files.; The tool is part of LLVM project and is currently supported only on Linux.; It can handle symbolization tasks autonomously without any extra support; from the environment. You need to pass .sancov files (named; ``<module_name>.<pid>.sancov`` and paths to all corresponding binary elf files.; Sancov matches these files using module names and binaries file names. .. code-block:: console. USAGE: sancov [options] <action> (<binary file>|<.sancov file>)... Action (required); -print - Print coverage addresses; -covered-functions - Print all covered functions.; -not-covered-functions - Print all not covered functions.; -symbolize - Symbolizes the report. Options; -blocklis",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerCoverage.rst:17026,simpl,simple,17026,interpreter/llvm-project/clang/docs/SanitizerCoverage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerCoverage.rst,1,['simpl'],['simple']
Usability,"he type that your expression; expects, STOP! Go fix semantic analysis and the AST so that you don't; need these bitcasts.; * The ``CodeGenFunction`` class has a number of helper functions to make; certain operations easy, such as generating code to produce an lvalue or; an rvalue, or to initialize a memory location with a given value. Prefer; to use these functions rather than directly writing loads and stores,; because these functions take care of some of the tricky details for you; (e.g., for exceptions).; * If your expression requires some special behavior in the event of an; exception, look at the ``push*Cleanup`` functions in ``CodeGenFunction``; to introduce a cleanup. You shouldn't have to deal with; exception-handling directly.; * Testing is extremely important in IR generation. Use ``clang -cc1; -emit-llvm`` and `FileCheck; <https://llvm.org/docs/CommandGuide/FileCheck.html>`_ to verify that you're; generating the right IR. #. Teach template instantiation how to cope with your AST node, which requires; some fairly simple code:. * Make sure that your expression's constructor properly computes the flags; for type dependence (i.e., the type your expression produces can change; from one instantiation to the next), value dependence (i.e., the constant; value your expression produces can change from one instantiation to the; next), instantiation dependence (i.e., a template parameter occurs; anywhere in your expression), and whether your expression contains a; parameter pack (for variadic templates). Often, computing these flags; just means combining the results from the various types and; subexpressions.; * Add ``TransformXXX`` and ``RebuildXXX`` functions to the ``TreeTransform``; class template in ``Sema``. ``TransformXXX`` should (recursively); transform all of the subexpressions and types within your expression,; using ``getDerived().TransformYYY``. If all of the subexpressions and; types transform without error, it will then call the ``RebuildXXX``; function",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:152408,simpl,simple,152408,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['simpl'],['simple']
Usability,"he; demangled AST. Why are there multiple copies of the this library in the source tree?; ---------------------------------------------------------------------. The canonical sources are in libcxxabi/src/demangle and some of the; files are copied to llvm/include/llvm/Demangle. The simple reason for; this comes from before the monorepo, and both [sub]projects need to; demangle symbols, but neither can depend on each other. * libcxxabi needs the demangler to implement __cxa_demangle, which is; part of the itanium ABI spec. * LLVM needs a copy for a bunch of places, and cannot rely on the; system's __cxa_demangle because it a) might not be available (i.e.,; on Windows), and b) may not be up-to-date on the latest language; features. The copy of the demangler in LLVM has some extra stuff that aren't; needed in libcxxabi (ie, the MSVC demangler, ItaniumPartialDemangler),; which depend on the shared generic components. Despite these; differences, we want to keep the ""core"" generic demangling library; identical between both copies to simplify development and testing. If you're working on the generic library, then do the work first in; libcxxabi, then run libcxxabi/src/demangle/cp-to-llvm.sh. This; script takes as an optional argument the path to llvm, and copies the; changes you made to libcxxabi over. Note that this script just; blindly overwrites all changes to the generic library in llvm, so be; careful. Because the core demangler needs to work in libcxxabi, everything; needs to be declared in an anonymous namespace (see; DEMANGLE_NAMESPACE_BEGIN), and you can't introduce any code that; depends on the libcxx dylib. FIXME: Now that LLVM is a monorepo, it should be possible to; de-duplicate this code, and have both LLVM and libcxxabi depend on a; shared demangler library. Testing; -------. The tests are split up between libcxxabi/test/{unit,}test_demangle.cpp, and; llvm/unittest/Demangle. The llvm directory should only get tests for stuff not; included in the core library.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Demangle/README.txt:1471,simpl,simplify,1471,interpreter/llvm-project/llvm/include/llvm/Demangle/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Demangle/README.txt,1,['simpl'],['simplify']
Usability,"heckDependents()`: use `checkObservables()`; - `RooAbsArg::recursiveCheckDependents()`: use `recursiveCheckObservables()`. ## Graphics Backends. ## 2D Graphics Libraries. ## 3D Graphics Libraries. ## Geometry Libraries. ## Database Libraries. ## Networking Libraries. ## GUI Libraries. ## Montecarlo Libraries. ## PROOF Libraries. ## PyROOT. ### Typesafe `TTree::SetBranchAddress()` for array inputs. If you call `TTree::SetBranchAddress` with NumPy array or `array.array` inputs, ROOT will now check if the array type matches with the column type.; If it doesn't, `SetBranchAddress()` will return a negative status code and print an error.; Take for example this code snippet:; ```python; arr = array.array(typecode, ""d""); status = t.SetBranchAddress(""name"", arr); print(""Status = %s"" % (status, )); ```; If the branch type is also `double` (like the type of the array indicated by `""d""`), the call to `SetBranchAddress()` would succeed with status code zero.; If the type doesn't match, you now get a clear error instead of garbage values.; ```txt; Error in <TTree::SetBranchAddress>: The pointer type given ""Double_t"" (8) does not correspond to the type needed ""Float_t"" (5) by the branch: a; Status = -2; ```. ### Deprecation of `TPython::Eval()`. The `TPython::Eval()` method is deprecated and scheduled for removal in ROOT 6.36.; Its implementation was fragile, and the same functionality can be achieved with `TPython::Exec()`, using a C++ variable that is known to the ROOT interpreter for crossing over from Python to C++. Example:; ```c++; // Before, with TPython::Eval(); std::string stringVal = static_cast<const char*>(TPython::Eval(""'done'""));; std::cout << stringVal << std::endl;. // Now, with TPython::Exec(). You can set `_anyresult` to whatever std::any you want.; // It will be swapped into the return variable in the end. std::any result;; TPython::Exec(""_anyresult = ROOT.std.make_any['std::string']('done')"", &result);; std::cout << std::any_cast<std::string>(result) << std::en",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v634/index.md:7607,clear,clear,7607,README/ReleaseNotes/v634/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v634/index.md,1,['clear'],['clear']
Usability,"hen subsequent calls to ``LLVMDisasmInstruction()`` will return output strings; with the marked up annotations. Instruction Annotations; =======================. .. _contextual markups:. Contextual markups; ------------------. Annotated assembly display will supply contextual markup to help clients more; efficiently implement things like pretty printers. Most markup will be target; independent, so clients can effectively provide good display without any target; specific knowledge. Annotated assembly goes through the normal instruction printer, but optionally; includes contextual tags on portions of the instruction string. An annotation; is any '<' '>' delimited section of text(1). .. code-block:: bat. annotation: '<' tag-name tag-modifier-list ':' annotated-text '>'; tag-name: identifier; tag-modifier-list: comma delimited identifier list. The tag-name is an identifier which gives the type of the annotation. For the; first pass, this will be very simple, with memory references, registers, and; immediates having the tag names ""mem"", ""reg"", and ""imm"", respectively. The tag-modifier-list is typically additional target-specific context, such as; register class. Clients should accept and ignore any tag-names or tag-modifiers they do not; understand, allowing the annotations to grow in richness without breaking older; clients. For example, a possible annotation of an ARM load of a stack-relative location; might be annotated as:. .. code-block:: text. ldr <reg gpr:r0>, <mem regoffset:[<reg gpr:sp>, <imm:#4>]>. 1: For assembly dialects in which '<' and/or '>' are legal tokens, a literal token is escaped by following immediately with a repeat of the character. For example, a literal '<' character is output as '<<' in an annotated assembly string. C API Details; -------------. The intended consumers of this information use the C API, therefore the new C; API function for the disassembler will be added to provide an option to produce; disassembled instructions with annotations",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MarkedUpDisassembly.rst:2219,simpl,simple,2219,interpreter/llvm-project/llvm/docs/MarkedUpDisassembly.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MarkedUpDisassembly.rst,1,['simpl'],['simple']
Usability,"hen-else CFG diamond into a ``select``. Preserving the; debug locations of speculated instructions can make it seem like a condition; is true when it's not (or vice versa), which leads to a confusing; single-stepping experience. The rule for; :ref:`dropping locations<WhenToDropLocation>` should apply here. * Hoisting identical instructions which appear in several successor blocks into; a predecessor block (see ``BranchFolder::HoistCommonCodeInSuccs``). In this; case there is no single merged instruction. The rule for; :ref:`dropping locations<WhenToDropLocation>` applies. .. _WhenToDropLocation:. When to drop an instruction location; ------------------------------------. A transformation should drop debug locations if the rules for; :ref:`preserving<WhenToPreserveLocation>` and; :ref:`merging<WhenToMergeLocation>` debug locations do not apply. The API to; use is ``Instruction::dropLocation()``. The purpose of this rule is to prevent erratic or misleading single-stepping; behavior in situations in which an instruction has no clear, unambiguous; relationship to a source location. To handle an instruction without a location, the DWARF generator; defaults to allowing the last-set location after a label to cascade forward, or; to setting a line 0 location with viable scope information if no previous; location is available. See the discussion in the section about; :ref:`merging locations<WhenToMergeLocation>` for examples of when the rule for; dropping locations applies. Rules for updating debug values; ===============================. Deleting an IR-level Instruction; --------------------------------. When an ``Instruction`` is deleted, its debug uses change to ``undef``. This is; a loss of debug info: the value of one or more source variables becomes; unavailable, starting with the ``llvm.dbg.value(undef, ...)``. When there is no; way to reconstitute the value of the lost instruction, this is the best; possible outcome. However, it's often possible to do better:. * If th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToUpdateDebugInfo.rst:5972,clear,clear,5972,interpreter/llvm-project/llvm/docs/HowToUpdateDebugInfo.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToUpdateDebugInfo.rst,1,['clear'],['clear']
Usability,"her:; cxxRecordDecl(hasName(""::A""),; findAll(cxxRecordDecl(isDefinition()).bind(""m""))); will generate results for A, B and C. Usable as: Any Matcher. Matcher<*>forEachDescendantMatcher<*>; Matches AST nodes that have descendant AST nodes that match the; provided matcher. Example matches X, A, A::X, B, B::C, B::C::X; (matcher = cxxRecordDecl(forEachDescendant(cxxRecordDecl(hasName(""X""))))); class X {};; class A { class X {}; }; // Matches A, because A::X is a class of name; // X inside A.; class B { class C { class X {}; }; };. DescendantT must be an AST base type. As opposed to 'hasDescendant', 'forEachDescendant' will cause a match for; each result that matches instead of only on the first one. Note: Recursively combined ForEachDescendant can cause many matches:; cxxRecordDecl(forEachDescendant(cxxRecordDecl(; forEachDescendant(cxxRecordDecl()); ))); will match 10 times (plus injected class name matches) on:; class A { class B { class C { class D { class E {}; }; }; }; };. Usable as: Any Matcher. Matcher<*>forEachMatcher<*>; Matches AST nodes that have child AST nodes that match the; provided matcher. Example matches X, Y, Y::X, Z::Y, Z::Y::X; (matcher = cxxRecordDecl(forEach(cxxRecordDecl(hasName(""X""))); class X {};; class Y { class X {}; }; // Matches Y, because Y::X is a class of name X; // inside Y.; class Z { class Y { class X {}; }; }; // Does not match Z. ChildT must be an AST base type. As opposed to 'has', 'forEach' will cause a match for each result that; matches instead of only on the first one. Usable as: Any Matcher. Matcher<*>hasAncestorMatcher<*>; Matches AST nodes that have an ancestor that matches the provided; matcher. Given; void f() { if (true) { int x = 42; } }; void g() { for (;;) { int x = 43; } }; expr(integerLiteral(hasAncestor(ifStmt()))) matches 42, but not 43. Usable as: Any Matcher. Matcher<*>hasDescendantMatcher<*>; Matches AST nodes that have descendant AST nodes that match the; provided matcher. Example matches X, Y, Z; (matcher = cx",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:132934,Usab,Usable,132934,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['Usab'],['Usable']
Usability,"hese frame indices will be; encoded as ``Direct`` locations in the form ``BP + Offset``. LLVM may; also optimize constants by emitting them directly in the stack map,; either in the ``Offset`` of a ``Constant`` location or in the constant; pool, referred to by ``ConstantIndex`` locations. At each callsite, a ""liveout"" register list is also recorded. These; are the registers that are live across the stackmap and therefore must; be saved by the runtime. This is an important optimization when the; patchpoint intrinsic is used with a calling convention that by default; preserves most registers as callee-save. Each entry in the liveout register list contains a DWARF register; number and size in bytes. The stackmap format deliberately omits; specific subregister information. Instead the runtime must interpret; this information conservatively. For example, if the stackmap reports; one byte at ``%rax``, then the value may be in either ``%al`` or; ``%ah``. It doesn't matter in practice, because the runtime will; simply save ``%rax``. However, if the stackmap reports 16 bytes at; ``%ymm0``, then the runtime can safely optimize by saving only; ``%xmm0``. The stack map format is a contract between an LLVM SVN revision and; the runtime. It is currently experimental and may change in the short; term, but minimizing the need to update the runtime is; important. Consequently, the stack map design is motivated by; simplicity and extensibility. Compactness of the representation is; secondary because the runtime is expected to parse the data; immediately after compiling a module and encode the information in its; own format. Since the runtime controls the allocation of sections, it; can reuse the same stack map space for multiple modules. Stackmap support is currently only implemented for 64-bit; platforms. However, a 32-bit implementation should be able to use the; same format with an insignificant amount of wasted space. .. _stackmap-section:. Stack Map Section; ^^^^^^^^^^^^^^^^^. A ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/StackMaps.rst:15191,simpl,simply,15191,interpreter/llvm-project/llvm/docs/StackMaps.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/StackMaps.rst,1,['simpl'],['simply']
Usability,"hese large savings. The **`TTree`** is also used to optimize the data access. A tree uses a; hierarchy of branches, and each branch can be read independently from; any other branch. Now, assume that `Px` and `Py` are data members of the; event, and we would like to compute `Px2 + Py2` for every event; and histogram the result. If we had saved the million events without a **`TTree`** we would have; to:. - read each event in its entirety into memory; - extract the `Px` and `Py` from the event; - compute the sum of the squares; - fill a histogram. We would have to do that a million times! This is very time consuming,; and we really do not need to read the entire event, every time. All we; need are two little data members (`Px` and `Py`). On the other hand, if; we use a tree with one branch containing `Px` and another branch; containing `Py`, we can read all values of `Px` and `Py` by only reading; the `Px` and `Py` branches. This makes the use of the **`TTree`** very; attractive. ## A Simple TTree. This script builds a **`TTree`** from an ASCII file containing; statistics about the staff at CERN. This script, `cernbuild.C` and its input; file `cernstaff.dat` are in `$ROOTSYS/tutorials/tree`. ``` {.cpp}; {; // Simplified version of cernbuild.C.; // This macro to read data from an ascii file and; // create a root file with a TTree. Int_t Category;; UInt_t Flag;; Int_t Age;; Int_t Service;; Int_t Children;; Int_t Grade;; Int_t Step;; Int_t Hrweek;; Int_t Cost;; Char_t Division[4];; Char_t Nation[3];. FILE *fp = fopen(""cernstaff.dat"",""r"");. TFile *hfile = hfile = TFile::Open(""cernstaff.root"",""RECREATE"");. TTree *tree = new TTree(""T"",""CERN 1988 staff data"");; tree->Branch(""Category"",&Category,""Category/I"");; tree->Branch(""Flag"",&Flag,""Flag/i"");; tree->Branch(""Age"",&Age,""Age/I"");; tree->Branch(""Service"",&Service,""Service/I"");; tree->Branch(""Children"",&Children,""Children/I"");; tree->Branch(""Grade"",&Grade,""Grade/I"");; tree->Branch(""Step"",&Step,""Step/I"");; tree->Branch(""Hrweek"",",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:2650,Simpl,Simple,2650,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['Simpl'],['Simple']
Usability,hing a usual deallocation function with placement new; Unknown. 2281; drafting; Consistency of aligned operator delete replacement; Not resolved. 2282; C++20; Consistency with mismatched aligned/non-over-aligned allocation/deallocation functions; Unknown. 2283; drafting; Missing complete type requirements; Not resolved. 2284; open; Sequencing of braced-init-list arguments; Not resolved. 2285; CD5; Issues with structured bindings; Unknown. 2286; NAD; Assignment evaluation order; Unknown. 2287; CD5; Pointer-interconvertibility in non-standard-layout unions; Unknown. 2288; NAD; Contradictory optionality in simple-declaration; Unknown. 2289; CD5; Uniqueness of structured binding names; Unknown. 2290; CD5; Unclear specification for overload resolution and deleted special member functions; Unknown. 2291; dup; Implicit conversion sequences in non-call contexts; Unknown. 2292; CD5; simple-template-id is ambiguous between class-name and type-name; Clang 9. 2293; CD5; Requirements for simple-template-id used as a class-name; Unknown. 2294; CD5; Dependent auto static data members; Unknown. 2295; CD5; Aggregates with deleted defaulted constructors; Unknown. 2296; open; Are default argument instantiation failures in the “immediate context”?; Not resolved. 2297; open; Unclear specification of atomic operations; Not resolved. 2298; open; Actions and expression evaluation; Not resolved. 2299; CD5; constexpr vararg functions; Unknown. 2300; CD5; Lambdas in multiple definitions; Unknown. 2301; open; Value-initialization and constexpr constructor evaluation; Not resolved. 2302; NAD; Address comparison between different member subobjects; Unknown. 2303; CD5; Partial ordering and recursive variadic inheritance; Clang 12. 2304; NAD; Incomplete type vs overload resolution; Unknown. 2305; CD5; Explicit instantiation of constexpr or inline variable template; Unknown. 2306; NAD; Nested friend templates of class templates; Unknown. 2307; CD5; Unclear definition of “equivalent to a nontype tem,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:156419,simpl,simple-template-id,156419,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['simpl'],['simple-template-id']
Usability,"hints about the correlations between the axes. Avery simple technique allows to make the clusters appearing:; Instead of painting solid lines we paint dotted lines. The cluttering of; each individual line is reduced and the clusters show clearly as we can; see on the next figure. The spacing between the dots is a parameter which; can be adjusted in order to get the best results. ![Using dotted lines is a very simple method to reduce the cluttering.](pictures/para5.png). Interactivity is a very important aspect of the Parallel Coordinates plots.; To really explore the data set it is essential to act directly with the; events and the axes. For instance, changing the axes order may show clusters; which were not visible in a different order. On the next figure the axes; order has been changed interactively. We can see that many more clusters; appear and all the “random spheres” we put in the data set are now; clearly visible. Having moved the variables `u,v,w` after the variables; `x,y,z` the correlation between these two sets of variables is clear also. ![Axis order is very important to show clusters.](pictures/para6.png). To pursue further data sets exploration we have implemented the possibility; to define selections interactively. A selection is a set of ranges combined; together. Within a selection, ranges along the same axis are combined with; logical OR, and ranges on different axes with logical AND. A selection is; displayed on top of the complete data set using its own color. Only the; events fulfilling the selection criteria (ranges) are displayed. Ranges; are defined interactively using cursors, like on the first axis on the; figure. Several selections can be defined at the same time,; each selection having its own color. ![Selections are set of ranges which can be defined interactively.](pictures/para7.png). Several selections can been defined. Each cluster is now clearly visible; and the zone with crossing clusters is now understandable whereas,; without any",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:100179,clear,clear,100179,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['clear'],['clear']
Usability,"his case with probability 10%; case 0: break; // Take this case with probability 10%; case 3: break; // Take this case with probability 10%; case 5: break; // This case is likely to be taken with probability 70%; }. CFG Modifications; =================. Branch Weight Metatada is not proof against CFG changes. If terminator operands'; are changed some action should be taken. In other case some misoptimizations may; occur due to incorrect branch prediction information. Function Entry Counts; =====================. To allow comparing different functions during inter-procedural analysis and; optimization, ``MD_prof`` nodes can also be assigned to a function definition.; The first operand is a string indicating the name of the associated counter. Currently, one counter is supported: ""function_entry_count"". The second operand; is a 64-bit counter that indicates the number of times that this function was; invoked (in the case of instrumentation-based profiles). In the case of; sampling-based profiles, this operand is an approximation of how many times; the function was invoked. For example, in the code below, the instrumentation for function foo(); indicates that it was called 2,590 times at runtime. .. code-block:: llvm. define i32 @foo() !prof !1 {; ret i32 0; }; !1 = !{!""function_entry_count"", i64 2590}. If ""function_entry_count"" has more than 2 operands, the later operands are; the GUID of the functions that needs to be imported by ThinLTO. This is only; set by sampling based profile. It is needed because the sampling based profile; was collected on a binary that had already imported and inlined these functions,; and we need to ensure the IR matches in the ThinLTO backends for profile; annotation. The reason why we cannot annotate this on the callsite is that it; can only goes down 1 level in the call chain. For the cases where; foo_in_a_cc()->bar_in_b_cc()->baz_in_c_cc(), we will need to go down 2 levels; in the call chain to import both bar_in_b_cc and baz_in_c_cc.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BranchWeightMetadata.rst:6538,GUID,GUID,6538,interpreter/llvm-project/llvm/docs/BranchWeightMetadata.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BranchWeightMetadata.rst,1,['GUID'],['GUID']
Usability,"his intrinsic is implementation-defined. It is an error to pass a ``convergencectrl`` operand bundle at a; call to this intrinsic. .. note::. The expectation is that all threads within a group that ""happen to be active; at the same time"" will execute converged dynamic instances, so that programs; can detect the maximal set of threads that can communicate efficiently within; some local region of the program. .. _convergence_uncontrolled:. Uncontrolled Convergent Operations; ==================================. Convergent operations with an explicit ``convergencectrl`` operand bundle are; called *controlled convergent operations*. All other convergent operations are; said to be *uncontrolled*. An uncontrolled convergent operation is said to have *implicit convergence; control* determined by the ``convergent`` attribute alone. The semantics of the; ``convergent`` attribute as implemented in LLVM differs from the documented; semantics. The implementation tries to follow common intuition about convergent; operations, which remains under-specified. As such, it is not possible to fully; translate implicit convergence control into explicit convergence control tokens,; and these two modes cannot be mixed in the same function. If a function contains a controlled convergent operation, then all convergent; operations in that function must either be controlled operations or calls to; the convergence control intrinsics. Inferring Tokens; ----------------. (This section is informational). Sometimes, it may be necessary to reinterpret the implicit convergence control; in terms of explicit convergence control tokens. For example, this may happen; when a function call is inlined, and either the caller or the callee contains; uncontrolled convergent operations. Some uses of uncontrolled convergent operations may need to satisfy the; following property:. For an environment-defined group of threads (such as an OpenCL workgroup or; subgroup), if one thread in the group executes a convergen",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergentOperations.rst:27697,intuit,intuition,27697,interpreter/llvm-project/llvm/docs/ConvergentOperations.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergentOperations.rst,1,['intuit'],['intuition']
Usability,"his may be acceptable if LLVM's coroutine support is primarily being; used for low-level lowering and inlining is expected to be applied; earlier in the pipeline. Async Lowering; --------------. In async-continuation lowering, signaled by the use of `llvm.coro.id.async`,; handling of control-flow must be handled explicitly by the frontend. In this lowering, a coroutine is assumed to take the current `async context` as; one of its arguments (the argument position is determined by; `llvm.coro.id.async`). It is used to marshal arguments and return values of the; coroutine. Therefore an async coroutine returns `void`. .. code-block:: llvm. define swiftcc void @async_coroutine(ptr %async.ctxt, ptr, ptr) {; }. Values live across a suspend point need to be stored in the coroutine frame to; be available in the continuation function. This frame is stored as a tail to the; `async context`. Every suspend point takes an `context projection function` argument which; describes how-to obtain the continuations `async context` and every suspend; point has an associated `resume function` denoted by the; `llvm.coro.async.resume` intrinsic. The coroutine is resumed by calling this; `resume function` passing the `async context` as the one of its arguments; argument. The `resume function` can restore its (the caller's) `async context`; by applying a `context projection function` that is provided by the frontend as; a parameter to the `llvm.coro.suspend.async` intrinsic. .. code-block:: c. // For example:; struct async_context {; struct async_context *caller_context;; ...; }. char *context_projection_function(struct async_context *callee_ctxt) {; return callee_ctxt->caller_context;; }. .. code-block:: llvm. %resume_func_ptr = call ptr @llvm.coro.async.resume(); call {ptr, ptr, ptr} (ptr, ptr, ...) @llvm.coro.suspend.async(; ptr %resume_func_ptr,; ptr %context_projection_function. The frontend should provide a `async function pointer` struct associated with; each async coroutine by `llvm.co",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:8555,resume,resume,8555,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"his pass performs several transformations to transform natural loops into a; simpler form, which makes subsequent analyses and transformations simpler and; more effective. A summary of it can be found in; :ref:`Loop Terminology, Loop Simplify Form <loop-terminology-loop-simplify>`. Loop pre-header insertion guarantees that there is a single, non-critical entry; edge from outside of the loop to the loop header. This simplifies a number of; analyses and transformations, such as :ref:`LICM <passes-licm>`. Loop exit-block insertion guarantees that all exit blocks from the loop (blocks; which are outside of the loop that have predecessors inside of the loop) only; have predecessors from inside of the loop (and are thus dominated by the loop; header). This simplifies transformations such as store-sinking that are built; into LICM. This pass also guarantees that loops will have exactly one backedge. Note that the :ref:`simplifycfg <passes-simplifycfg>` pass will clean up blocks; which are split out but end up being unnecessary, so usage of this pass should; not pessimize generated code. This pass obviously modifies the CFG, but updates loop information and; dominator information. ``loop-unroll``: Unroll loops; -----------------------------. This pass implements a simple loop unroller. It works best when loops have; been canonicalized by the :ref:`indvars <passes-indvars>` pass, allowing it to; determine the trip counts of loops easily. ``loop-unroll-and-jam``: Unroll and Jam loops; ---------------------------------------------. This pass implements a simple unroll and jam classical loop optimisation pass.; It transforms loop from:. .. code-block:: c++. for i.. i+= 1 for i.. i+= 4; for j.. for j..; code(i, j) code(i, j); code(i+1, j); code(i+2, j); code(i+3, j); remainder loop. Which can be seen as unrolling the outer loop and ""jamming"" (fusing) the inner; loops into one. When variables or loads can be shared in the new inner loop, this; can lead to significant performance i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst:27621,simpl,simplifycfg,27621,interpreter/llvm-project/llvm/docs/Passes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst,2,['simpl'],['simplifycfg']
Usability,"his pattern is intended for use by classes which hide locking; details behind an abstract interface. For example:. .. code-block:: c++. template <class T>; class CAPABILITY(""mutex"") Container {; private:; Mutex mu;; T* data;. public:; // Hide mu from public interface.; void Lock() ACQUIRE() { mu.Lock(); }; void Unlock() RELEASE() { mu.Unlock(); }. T& getElem(int i) { return data[i]; }; };. void test() {; Container<int> c;; c.Lock();; int i = c.getElem(0);; c.Unlock();; }. EXCLUDES(...); -------------. *Previously*: ``LOCKS_EXCLUDED``. ``EXCLUDES`` is an attribute on functions or methods, which declares that; the caller must *not* hold the given capabilities. This annotation is; used to prevent deadlock. Many mutex implementations are not re-entrant, so; deadlock can occur if the function acquires the mutex a second time. .. code-block:: c++. Mutex mu;; int a GUARDED_BY(mu);. void clear() EXCLUDES(mu) {; mu.Lock();; a = 0;; mu.Unlock();; }. void reset() {; mu.Lock();; clear(); // Warning! Caller cannot hold 'mu'.; mu.Unlock();; }. Unlike ``REQUIRES``, ``EXCLUDES`` is optional. The analysis will not issue a; warning if the attribute is missing, which can lead to false negatives in some; cases. This issue is discussed further in :ref:`negative`. NO_THREAD_SAFETY_ANALYSIS; -------------------------. ``NO_THREAD_SAFETY_ANALYSIS`` is an attribute on functions or methods, which; turns off thread safety checking for that method. It provides an escape hatch; for functions which are either (1) deliberately thread-unsafe, or (2) are; thread-safe, but too complicated for the analysis to understand. Reasons for; (2) will be described in the :ref:`limitations`, below. .. code-block:: c++. class Counter {; Mutex mu;; int a GUARDED_BY(mu);. void unsafeIncrement() NO_THREAD_SAFETY_ANALYSIS { a++; }; };. Unlike the other attributes, NO_THREAD_SAFETY_ANALYSIS is not part of the; interface of a function, and should thus be placed on the function definition; (in the ``.cc`` or ``.cpp`` ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:10582,clear,clear,10582,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,1,['clear'],['clear']
Usability,"hoose their color. The simplest way is to pick colors in the current active color; palette. Palette coloring for histogram is activated thanks to the options `PFC`; (Palette Fill Color), `PLC` (Palette Line Color) and `AMC` (Palette Marker Color).; When one of these options is given to `TH1::Draw` the histogram get its color; from the current color palette defined by `gStyle->SetPalette(…)`. The color; is determined according to the number of objects having palette coloring in; the current pad.; - The line width and line style can be change on 2d histograms painted with; option `ARR`.; - When the angle of a TGraphPolar was not in radian, the error bars were misplaced.; The problem was reported [here](https://sft.its.cern.ch/jira/browse/ROOT-8476).; - In `TASimage::DrawLineInternal` the case of a line with 0 pixel along X and 0; pixel along Y was not treated properly. An horizontal line was drawn instead.; - In `TGraphPainter::PaintGrapHist`: Decouple the `P` option (histogram drawn with; a simple polymarker) from the `L` option (Histogram drawn as a simple polyline). This; improved (in some cases some extra markers were drawn) and simplified the code.; - Candle plot improvements:; * Rearragement of TCandle-code - split into calculate and paint; * Implementation for a ""raw-data candle"" inside TCandle - to be used from TTreeViewer in the future; * Implementation of 1D histograms along each candle (left, right and violin) - to be used for violin-charts; * Implementation of a zero indicator line for TCandle - to be used for violin-charts; * Reimplementation if THistPainter draw option VIOLIN; * Implementations of presets and individual options for VIOLIN-charts; * Implementation of VIOLIN-charts in THStack - can be combined with CANDLE; * Update of the docs (THistPainter and THStack); * New tutorials; - In various places in TGraph the underlying histogram was deleted when the graph; range should be recomputed. This has the side effect that some graph parameters; (like t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v610/index.md:10047,simpl,simple,10047,README/ReleaseNotes/v610/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v610/index.md,2,['simpl'],['simple']
Usability,"hose values to human-readable form. Instead, logging text uses the; markup format defined here to identify pieces of information that should be; converted to human-readable form after the fact. As with other markup formats,; the expectation is that most of the text will be displayed as is, while the; markup elements will be replaced with expanded text, or converted into active UI; elements, that present more details in symbolic form. This means there is no need for symbol tables, DWARF debugging sections, or; similar information to be directly accessible at runtime. There is also no need; at runtime for any logic intended to compute human-readable presentation of; information, such as C++ symbol demangling. Instead, logging must include markup; elements that give the contextual information necessary to make sense of the raw; data, such as memory layout details. This format identifies markup elements with a syntax that is both simple and; distinctive. It's simple enough to be matched and parsed with straightforward; code. It's distinctive enough that character sequences that look like the start; or end of a markup element should rarely if ever appear incidentally in logging; text. It's specifically intended not to require sanitizing plain text, such as; the HTML/XML requirement to replace ``<`` with ``&lt;`` and the like. :doc:`llvm-symbolizer <CommandGuide/llvm-symbolizer>` includes a symbolizing; filter via its ``--filter-markup`` option. Also, LLVM utilites emit stack; traces as markup when the ``LLVM_ENABLE_SYMBOLIZER_MARKUP`` environment; variable is set. Scope and assumptions; =====================. A symbolizing filter implementation will be independent both of the target; operating system and machine architecture where the logs are generated and of; the host operating system and machine architecture where the filter runs. This format assumes that the symbolizing filter processes intact whole lines. If; long lines might be split during some stage of a logging ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SymbolizerMarkupFormat.rst:1350,simpl,simple,1350,interpreter/llvm-project/llvm/docs/SymbolizerMarkupFormat.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SymbolizerMarkupFormat.rst,1,['simpl'],['simple']
Usability,"hould be:; #. A proposal for removal / deactivation should be made to the Discourse forums ; (under the appropriate category), with a clear; statement of the maintenance costs imposed and the alternatives, if; applicable.; #. There must be enough consensus on the list that removal is warranted, and no; pending proposals to fix the situation from a sub-community.; #. An announcement for removal must be made on the same lists, with ample time; for downstream users to take action on their local infrastructure. The time; will depend on what is being removed. #. If a script or documents are to be removed, they can always be pulled; from previous revision, and can be removed within days.; #. if a whole target is removed, we need to first announce publicly, and; potentially mark as deprecated in one release, only to remove on the; next release.; #. Everything else will fall in between those two extremes.; #. The removal is made by either the proposer or the sub-community that used to; maintain it, with replacements and arrangements made atomically on the same; commit. If a proposal for removal is delayed by the promise a sub-community will take; care of the code affected, the sub-community will have a time to fix all the; issues (depending on each case, as above), and if those are not fixed in time, a; subsequent request for removal should be made and the community may elect to; eject the component without further attempts to fix. Reinstatement; -------------. If a component is removed from LLVM, it may, at a later date, request inclusion; of a modified version, with evidence that all of the issues were fixed and that; there is a clear sub-community that will maintain it. By consequence, the pressure on such sub-community will be higher to keep; overall maintenance costs to a minimum and will need to show steps to mitigate; all of the issues that were listed as reasons for its original removal. Failing on those again, will lead to become a candidate for removal yet again. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportPolicy.rst:11058,clear,clear,11058,interpreter/llvm-project/llvm/docs/SupportPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportPolicy.rst,1,['clear'],['clear']
Usability,"hout complying; with the conditions of Sections 4(a), 4(b) and 4(d) of the License. In addition, if you combine or link compiled forms of this Software with; software that is licensed under the GPLv2 (""Combined Software"") and if a; court of competent jurisdiction determines that the patent provision (Section; 3), the indemnity provision (Section 9) or other Section of the License; conflicts with the conditions of the GPLv2, you may retroactively and; prospectively choose to deem waived or otherwise exclude such Section(s) of; the License, but only in their entirety and only with respect to the Combined; Software. ==============================================================================; Software from third parties included in the LLVM Project:; ==============================================================================; The LLVM Project contains third party software which is under different license; terms. All such code will be identified clearly using at least one of two; mechanisms:; 1) It will be in a separate directory tree with its own `LICENSE.txt` or; `LICENSE` file at the top containing the specific license and restrictions; which apply to that software, or; 2) It will contain specific license and restriction terms at the top of every; file. ==============================================================================; Legacy LLVM License (https://llvm.org/docs/DeveloperPolicy.html#legacy):; ==============================================================================; University of Illinois/NCSA; Open Source License. Copyright (c) 2003-2019 University of Illinois at Urbana-Champaign.; All rights reserved. Developed by:. LLVM Team. University of Illinois at Urbana-Champaign. http://llvm.org. Permission is hereby granted, free of charge, to any person obtaining a copy of; this software and associated documentation files (the ""Software""), to deal with; the Software without restriction, including without limitation the rights to; use, copy, modify, mer",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/LICENSE.TXT:11834,clear,clearly,11834,interpreter/llvm-project/llvm/LICENSE.TXT,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/LICENSE.TXT,2,['clear'],['clearly']
Usability,"hout complying; with the conditions of Sections 4(a), 4(b) and 4(d) of the License. In addition, if you combine or link compiled forms of this Software with; software that is licensed under the GPLv2 (""Combined Software"") and if a; court of competent jurisdiction determines that the patent provision (Section; 3), the indemnity provision (Section 9) or other Section of the License; conflicts with the conditions of the GPLv2, you may retroactively and; prospectively choose to deem waived or otherwise exclude such Section(s) of; the License, but only in their entirety and only with respect to the Combined; Software. ==============================================================================; Software from third parties included in the LLVM Project:; ==============================================================================; The LLVM Project contains third party software which is under different license; terms. All such code will be identified clearly using at least one of two; mechanisms:; 1) It will be in a separate directory tree with its own `LICENSE.txt` or; `LICENSE` file at the top containing the specific license and restrictions; which apply to that software, or; 2) It will contain specific license and restriction terms at the top of every; file. ==============================================================================; Legacy LLVM License (https://llvm.org/docs/DeveloperPolicy.html#legacy):; ==============================================================================; University of Illinois/NCSA; Open Source License. Copyright (c) 2007-2018 University of Illinois at Urbana-Champaign.; All rights reserved. Developed by:. LLVM Team. University of Illinois at Urbana-Champaign. http://llvm.org. Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the ""Software""), to deal with the Software without restriction, including without limitation the rights to use, copy, modify, merge,",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format-vs/ClangFormat/license.txt:11834,clear,clearly,11834,interpreter/llvm-project/clang/tools/clang-format-vs/ClangFormat/license.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format-vs/ClangFormat/license.txt,1,['clear'],['clearly']
Usability,"hout complying; with the conditions of Sections 4(a), 4(b) and 4(d) of the License. In addition, if you combine or link compiled forms of this Software with; software that is licensed under the GPLv2 (""Combined Software"") and if a; court of competent jurisdiction determines that the patent provision (Section; 3), the indemnity provision (Section 9) or other Section of the License; conflicts with the conditions of the GPLv2, you may retroactively and; prospectively choose to deem waived or otherwise exclude such Section(s) of; the License, but only in their entirety and only with respect to the Combined; Software. ==============================================================================; Software from third parties included in the LLVM Project:; ==============================================================================; The LLVM Project contains third party software which is under different license; terms. All such code will be identified clearly using at least one of two; mechanisms:; 1) It will be in a separate directory tree with its own `LICENSE.txt` or; `LICENSE` file at the top containing the specific license and restrictions; which apply to that software, or; 2) It will contain specific license and restriction terms at the top of every; file. ==============================================================================; Legacy LLVM License (https://llvm.org/docs/DeveloperPolicy.html#legacy):; ==============================================================================; University of Illinois/NCSA; Open Source License. Copyright (c) 2007-2019 University of Illinois at Urbana-Champaign.; All rights reserved. Developed by:. LLVM Team. University of Illinois at Urbana-Champaign. http://llvm.org. Permission is hereby granted, free of charge, to any person obtaining a copy of; this software and associated documentation files (the ""Software""), to deal with; the Software without restriction, including without limitation the rights to; use, copy, modify, mer",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/LICENSE.TXT:11834,clear,clearly,11834,interpreter/llvm-project/clang/LICENSE.TXT,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/LICENSE.TXT,1,['clear'],['clearly']
Usability,"how some of the other pieces work in a bigger example. $ clang -fsyntax-only t.c; t.c:80:3: error: invalid operands to binary expression ('typeof(P)' (aka 'struct mystruct') and 'typeof(F)' (aka 'float')); X = MYMAX(P, F);; ^~~~~~~~~~~; t.c:76:94: note: expanded from:; #define MYMAX(A,B) __extension__ ({ __typeof__(A) __a = (A); __typeof__(B) __b = (B); __a < __b ? __b : __a; }); ~~~ ^ ~~~. Here's another real world warning that occurs in the ""window"" Unix package (which; implements the ""wwopen"" class of APIs):. $ clang -fsyntax-only t.c; t.c:22:2: warning: type specifier missing, defaults to 'int'; ILPAD();; ^; t.c:17:17: note: expanded from:; #define ILPAD() PAD((NROW - tt.tt_row) * 10) /* 1 ms per char */; ^; t.c:14:2: note: expanded from:; register i; \; ^. In practice, we've found that Clang's treatment of macros is actually more useful in multiply nested; macros than in simple ones.; Quality of Implementation and Attention to Detail; Finally, we have put a lot of work polishing the little things, because; little things add up over time and contribute to a great user experience.; The following example shows that we recover from the simple case of; forgetting a ; after a struct definition much better than GCC. $ cat t.cc; template<class T>; class a {};; struct b {}; a<int> c;; $ gcc-4.9 t.cc; t.cc:4:8: error: invalid declarator before 'c'; a<int> c;; ^; $ clang t.cc; t.cc:3:12: error: expected ';' after struct; struct b {}; ^; ;. The following example shows that we diagnose and recover from a missing; typename keyword well, even in complex circumstances where GCC; cannot cope. $ cat t.cc; template<class T> void f(T::type) { }; struct A { };; void g(); {; A a;; f<A>(a);; }; $ gcc-4.9 t.cc; t.cc:1:33: error: variable or field 'f' declared void; template<class T> void f(T::type) { }; ^; t.cc: In function 'void g()':; t.cc:6:5: error: 'f' was not declared in this scope; f<A>(a);; ^; t.cc:6:8: error: expected primary-expression before '>' token; f<A>(a);; ^; $ clang t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html:10157,user experience,user experience,10157,interpreter/llvm-project/clang/www/diagnostics.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html,1,['user experience'],['user experience']
Usability,"however,; be exactly representable as bfloat, IEEE 754 half, and IEEE 754 single; precision respectively. Hexadecimal format is always used for long double, and; there are three forms of long double. The 80-bit format used by x86 is; represented as ``0xK`` followed by 20 hexadecimal digits. The 128-bit format; used by PowerPC (two adjacent doubles) is represented by ``0xM`` followed by 32; hexadecimal digits. The IEEE 128-bit format is represented by ``0xL`` followed; by 32 hexadecimal digits. Long doubles will only work if they match the long; double format on your target. The IEEE 16-bit format (half precision) is; represented by ``0xH`` followed by 4 hexadecimal digits. The bfloat 16-bit; format is represented by ``0xR`` followed by 4 hexadecimal digits. All; hexadecimal formats are big-endian (sign bit at the left). There are no constants of type x86_mmx and x86_amx. .. _complexconstants:. Complex Constants; -----------------. Complex constants are a (potentially recursive) combination of simple; constants and smaller complex constants. **Structure constants**; Structure constants are represented with notation similar to; structure type definitions (a comma separated list of elements,; surrounded by braces (``{}``)). For example:; ""``{ i32 4, float 17.0, ptr @G }``"", where ""``@G``"" is declared as; ""``@G = external global i32``"". Structure constants must have; :ref:`structure type <t_struct>`, and the number and types of elements; must match those specified by the type.; **Array constants**; Array constants are represented with notation similar to array type; definitions (a comma separated list of elements, surrounded by; square brackets (``[]``)). For example:; ""``[ i32 42, i32 11, i32 74 ]``"". Array constants must have; :ref:`array type <t_array>`, and the number and types of elements must; match those specified by the type. As a special case, character array; constants may also be represented as a double-quoted string using the ``c``; prefix. For example: ""``c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:187731,simpl,simple,187731,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['simpl'],['simple']
Usability,"howto:errordef]). ### Parameter interaction ###. MnMigrad retains the result after each minimization; (MnUserParameterStae, see [api:state]) and forwards the interface. ### VariableMetricMinimizer() ###. The VariableMetricMinimizer is instantiated using default constructor. ### minimize(const FCNBase&, ...) ###. The VariableMetricMinimizer provides several overloaded methods minimize; with return value FunctionMinimum. Together with the user; $\mbox{FCN}$ (either an implementation of FCNBase or; FCNGradientBase) the user has to give as input the parameters with; starting values in one of the defined formats (std::vector$<$double$>$,; MnUserParameters or MnUserParameterState). ## MnMinimize and CombinedMinimizer ##. [api:minimize]. Causes minimization of the function by the method of; $\mbox{MIGRAD}$, as does the MnMigrad class, but switches to the; $\mbox{SIMPLEX}$ method if $\mbox{MIGRAD}$ fails to converge.; Constructor arguments, methods arguments and names of methods are the; same as for MnMigrad or MnSimplex and VariableMetricMinimizer or; SimplexMinimizer. ## MnMinos ##. [api:minos] Causes a $\mbox{MINOS}$ error analysis to be performed; on the parameter whose number is specified. $\mbox{MINOS}$ errors; may be expensive to calculate, but are very reliable since they take; account of non-linearities in the problem as well as parameter; correlations, and are in general asymmetric. The optional argument; $\mbox{maxcalls}$ specifies the (approximate) maximum number of; function calls **per parameter requested**, after which the calculation; will be stopped for that parameter. ### MnMinos(const FCNBase&, const FunctionMinimum&) ###. Construct an MnMinos object from the user's $\mbox{FCN}$ and a valid; FunctionMinimum. Additional constructors for user specific MnStrategy; settings are provided. ### operator() ###. MnMinos::operator()(unsigned int n, unsigned int maxcalls) causes a; $\mbox{MINOS}$ error analysis for external parameter $\mbox{n}$.; The return value is",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:44984,Simpl,SimplexMinimizer,44984,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['Simpl'],['SimplexMinimizer']
Usability,"htforwards for line number information, as mapping; instructions to line numbers is a simple association. For variable locations; however the story is more complex. As each ``llvm.dbg.value`` intrinsic; represents a source-level assignment of a value to a source variable, the; variable location intrinsics effectively embed a small imperative program; within the LLVM IR. By the end of CodeGen, this becomes a mapping from each; variable to their machine locations over ranges of instructions.; From IR to object emission, the major transformations which affect variable; location fidelity are:. 1. Instruction Selection; 2. Register allocation; 3. Block layout. each of which are discussed below. In addition, instruction scheduling can; significantly change the ordering of the program, and occurs in a number of; different passes. Some variable locations are not transformed during CodeGen. Stack locations; specified by ``llvm.dbg.declare`` are valid and unchanging for the entire; duration of the function, and are recorded in a simple MachineFunction table.; Location changes in the prologue and epilogue of a function are also ignored:; frame setup and destruction may take several instructions, require a; disproportionate amount of debugging information in the output binary to; describe, and should be stepped over by debuggers anyway. Variable locations in Instruction Selection and MIR; ---------------------------------------------------. Instruction selection creates a MIR function from an IR function, and just as; it transforms ``intermediate`` instructions into machine instructions, so must; ``intermediate`` variable locations become machine variable locations.; Within IR, variable locations are always identified by a Value, but in MIR; there can be different types of variable locations. In addition, some IR; locations become unavailable, for example if the operation of multiple IR; instructions are combined into one machine instruction (such as; multiply-and-accumulate) t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:25174,simpl,simple,25174,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['simpl'],['simple']
Usability,"https://llvm.org/docs/DeveloperPolicy.html#introducing-new-components-into-llvm>`_; roadmap or similar efforts.; * Code that is making its way out of LLVM, via deprecation, replacement or; bit-rot, and will be removed if the sub-community that cares about it; cannot maintain it.; * Code that isn't meant to be in LLVM core and can coexist with the code in; the core tier (and others in the peripheral tier) long term, without causing; breakages or disturbances. What is covered; ---------------. The peripheral tier is composed of:; * Experimental targets and options that haven't been enable by default yet.; * Main repository projects that don't get released or regularly tested.; * Legacy tools and scripts that aren't used in upstream validation.; * Alternative build systems (ex. GN, Bazel) and related infrastructure.; * Tools support (ex. gdb scripts, editor configuration, helper scripts). Requirements; ------------. Code in this tier must:; * Have a clear benefit for residing in the main repository, catering to an; active sub-community (upstream or downstream).; * Be actively maintained by such sub-community and have its problems addressed; in a timely manner. Code in this tier must **not**:; * Break or invalidate core tier code or infrastructure. If that happens; accidentally, reverting functionality and working on the issues offline; is the only acceptable course of action.; * Negatively affect development of core tier code, with the sub-community; involved responsible for making changes to address specific concerns.; * Negatively affect other peripheral tier code, with the sub-communities; involved tasked to resolve the issues, still making sure the solution doesn't; break or invalidate the core tier.; * Impose sub-optimal implementation strategies on core tier components as a; result of idiosyncrasies in the peripheral component.; * Have build infrastructure that spams all developers about their breakages.; * Fall into disrepair. This is a reflection of lack of an ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportPolicy.rst:4788,clear,clear,4788,interpreter/llvm-project/llvm/docs/SupportPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportPolicy.rst,1,['clear'],['clear']
Usability,"human-readable error cause to the end user. A debug info consumer; that is unaware of this sees an inlined function whose name encodes an error; message (e.g., : ``__bounds_safety$Bounds check failed``). Expression Parsing; ------------------. In our implementation, LLDB’s expression evaluator does not enable the; ``-fbounds-safety`` language option because it’s currently unable to fully; reconstruct the pointers with external bounds annotations, and also because the; evaluator operates in C++ mode, utilizing C++ reference types, while; ``-fbounds-safety`` does not currently support C++. This means LLDB’s expression; evaluator can only evaluate a subset of the ``-fbounds-safety`` language model.; Specifically, it’s capable of evaluating the wide pointers that already exist in; the source code. All other expressions are evaluated according to C/C++; semantics. C++ support; ===========. C++ has multiple options to write code in a bounds-safe manner, such as; following the bounds-safety core guidelines and/or using hardened libc++ along; with the `C++ Safe Buffer model; <https://discourse.llvm.org/t/rfc-c-buffer-hardening/65734>`_. However, these; techniques may require ABI changes and may not be applicable to code; interoperating with C. When the ABI of an existing program needs to be preserved; and for headers shared between C and C++, ``-fbounds-safety`` offers a potential; solution. ``-fbounds-safety`` is not currently supported in C++, but we believe the; general approach would be applicable for future efforts. Upstreaming plan; ================. Gradual updates with experimental flag; --------------------------------------. The upstreaming will take place as a series of smaller PRs and we will guard our; implementation with an experimental flag ``-fexperimental-bounds-safety`` until; the usable model is fully upstreamed. Once the model is ready for use, we will; expose the flag ``-fbounds-safety``. Possible patch sets; -------------------. * External bounds annot",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst:10541,guid,guidelines,10541,interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst,1,['guid'],['guidelines']
Usability,"i Gheata, CERN/SFT,\; Sergey Linev, GSI, http,\; Pere Mato, CERN/SFT,\; Lorenzo Moneta, CERN/SFT,\; Axel Naumann, CERN/SFT,\; Danilo Piparo, CERN/SFT,\; Fons Rademakers, CERN/SFT,\; Enric Tejedor Saavedra, CERN/SFT,\; Vassil Vassilev, Fermilab/CMS,\; Wouter Verkerke, NIKHEF/Atlas, RooFit. ## Removed interfaces. The following interfaces have been removed, after deprecation in v6.08. ### CINT remnants, dysfunctional for ROOT 6. - `TInterpreter`'s `Getgvp()`, `Getp2f2funcname(void*)`, `Setgvp(Long_t)`, `SetRTLD_NOW()`, `SetRTLD_LAZY()`.; - `SetFCN(void*)` from TVirtualFitter, TFitter, TBackCompFitter, TMinuit; - `TFoam::SetRhoInt(void*)`. ### Core. - The enum constant `TRef::kNotComputed`, `TLink::kObjIsParent` were never used and have been removed.; - The enum constant `TClonesArray::kNoSplit` has not been used since v2.26 and has been removed. ## Interpreter. - Automatic declaration of variables (`h = new TH1F(...)`) is *only* available at the prompt. The side-effects of relying on this in source files is simply too grave. Due to a bug (ROOT-8538), automatically declared variables must currently reside on the top-most scope, i.e. not inside an `if` block etc.; - Improved the stack frame information generated by the JIT. By avoiding interleaving of the memory associated to multiple JIT module, the generation of stack trace involving jitted code and the catching of exception going through jitted code has been repaired.; - Interpreted code is now optimized; `.O 0/1/2/3` can be used to change the optimization level, as well as `#pragma cling optimize`.; - The prompt colors are now much more visible, both on terminals with light and dark background.; - Significant speedup of `TMethodCall`.; - One can now run `.x 12file-with@funny=name.C`; it will expect a function called `_12file_with_funny_name()`. ## Core Libraries. - See ""Build, Configuration and Testing Infrastructure"" below for changes in the directory structure.; - libCling now exports only a minimal set of symbols.;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v610/index.md:1462,simpl,simply,1462,README/ReleaseNotes/v610/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v610/index.md,1,['simpl'],['simply']
Usability,"i;}; unsigned int f2(unsigned int i, unsigned int n) {++i; i += i == n; return i;}; These should combine to the same thing. Currently, the first function; produces better code on X86. //===---------------------------------------------------------------------===//. From GCC Bug 15784:; #define abs(x) x>0?x:-x; int f(int x, int y); {; return (abs(x)) >= 0;; }; This should optimize to x == INT_MIN. (With -fwrapv.) Currently not; optimized with ""clang -emit-llvm-bc | opt -O3"". //===---------------------------------------------------------------------===//. From GCC Bug 14753:; void; rotate_cst (unsigned int a); {; a = (a << 10) | (a >> 22);; if (a == 123); bar ();; }; void; minus_cst (unsigned int a); {; unsigned int tem;. tem = 20 - a;; if (tem == 5); bar ();; }; void; mask_gt (unsigned int a); {; /* This is equivalent to a > 15. */; if ((a & ~7) > 8); bar ();; }; void; rshift_gt (unsigned int a); {; /* This is equivalent to a > 23. */; if ((a >> 2) > 5); bar ();; }. All should simplify to a single comparison. All of these are; currently not optimized with ""clang -emit-llvm-bc | opt; -O3"". //===---------------------------------------------------------------------===//. From GCC Bug 32605:; int c(int* x) {return (char*)x+2 == (char*)x;}; Should combine to 0. Currently not optimized with ""clang; -emit-llvm-bc | opt -O3"" (although llc can optimize it). //===---------------------------------------------------------------------===//. int a(unsigned b) {return ((b << 31) | (b << 30)) >> 31;}; Should be combined to ""((b >> 1) | b) & 1"". Currently not optimized; with ""clang -emit-llvm-bc | opt -O3"". //===---------------------------------------------------------------------===//. unsigned a(unsigned x, unsigned y) { return x | (y & 1) | (y & 2);}; Should combine to ""x | (y & 3)"". Currently not optimized with ""clang; -emit-llvm-bc | opt -O3"". //===---------------------------------------------------------------------===//. int a(int a, int b, int c) {return (~a & c) | ((c|a) & b)",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt:23183,simpl,simplify,23183,interpreter/llvm-project/llvm/lib/Target/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt,1,['simpl'],['simplify']
Usability,"i[5];; void f() { i[1] = 42; }; arraySubscriptExpression(hasIndex(integerLiteral())); matches i[1] with the integerLiteral() matching 1. Matcher<ArraySubscriptExpr>hasLHSMatcher<Expr> InnerMatcher; Matches the left hand side of binary operator expressions. Example matches a (matcher = binaryOperator(hasLHS())); a || b. Matcher<ArraySubscriptExpr>hasRHSMatcher<Expr> InnerMatcher; Matches the right hand side of binary operator expressions. Example matches b (matcher = binaryOperator(hasRHS())); a || b. Matcher<ArrayType>hasElementTypeMatcher<Type>; Matches arrays and C99 complex types that have a specific element; type. Given; struct A {};; A a[7];; int b[7];; arrayType(hasElementType(builtinType())); matches ""int b[7]"". Usable as: Matcher<ArrayType>, Matcher<ComplexType>. Matcher<AtomicType>hasValueTypeMatcher<Type>; Matches atomic types with a specific value type. Given; _Atomic(int) i;; _Atomic(float) f;; atomicType(hasValueType(isInteger())); matches ""_Atomic(int) i"". Usable as: Matcher<AtomicType>. Matcher<AutoType>hasDeducedTypeMatcher<Type>; Matches AutoType nodes where the deduced type is a specific type. Note: There is no TypeLoc for the deduced type and thus no; getDeducedLoc() matcher. Given; auto a = 1;; auto b = 2.0;; autoType(hasDeducedType(isInteger())); matches ""auto a"". Usable as: Matcher<AutoType>. Matcher<BaseUsingDecl>hasAnyUsingShadowDeclMatcher<UsingShadowDecl> InnerMatcher; Matches any using shadow declaration. Given; namespace X { void b(); }; using X::b;; usingDecl(hasAnyUsingShadowDecl(hasName(""b"")))); matches using X::b ; Matcher<BinaryOperator>hasEitherOperandMatcher<Expr> InnerMatcher; Matches if either the left hand side or the right hand side of a; binary operator or fold expression matches. Matcher<BinaryOperator>hasLHSMatcher<Expr> InnerMatcher; Matches the left hand side of binary operator expressions. Example matches a (matcher = binaryOperator(hasLHS())); a || b. Matcher<BinaryOperator>hasOperandsMatcher<Expr> Matcher1, Matcher<Expr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:140334,Usab,Usable,140334,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['Usab'],['Usable']
Usability,"iagnostics-fixit-info:. .. option:: -f[no-]diagnostics-fixit-info. Enable ""FixIt"" information in the diagnostics output. This option, which defaults to on, controls whether or not Clang; prints the information on how to fix a specific diagnostic; underneath it when it knows. For example, in this output:. ::. test.c:28:8: warning: extra tokens at end of #endif directive [-Wextra-tokens]; #endif bad; ^; //. Passing **-fno-diagnostics-fixit-info** will prevent Clang from; printing the ""//"" line at the end of the message. This information; is useful for users who may not understand what is wrong, but can be; confusing for machine parsing. .. _opt_fdiagnostics-print-source-range-info:. .. option:: -fdiagnostics-print-source-range-info. Print machine parsable information about source ranges.; This option makes Clang print information about source ranges in a machine; parsable format after the file/line/column number information. The; information is a simple sequence of brace enclosed ranges, where each range; lists the start and end line/column locations. For example, in this output:. ::. exprs.c:47:15:{47:8-47:14}{47:17-47:24}: error: invalid operands to binary expression ('int *' and '_Complex float'); P = (P-42) + Gamma*4;; ~~~~~~ ^ ~~~~~~~. The {}'s are generated by -fdiagnostics-print-source-range-info. The printed column numbers count bytes from the beginning of the; line; take care if your source contains multibyte characters. .. option:: -fdiagnostics-parseable-fixits. Print Fix-Its in a machine parseable form. This option makes Clang print available Fix-Its in a machine; parseable format at the end of diagnostics. The following example; illustrates the format:. ::. fix-it:""t.cpp"":{7:25-7:29}:""Gamma"". The range printed is a half-open range, so in this example the; characters at column 25 up to but not including column 29 on line 7; in t.cpp should be replaced with the string ""Gamma"". Either the; range or the replacement string may be empty (representing strict; ins",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:16143,simpl,simple,16143,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['simpl'],['simple']
Usability,"ial; invocation of the coroutine. The `loop` blocks represents the body of the coroutine. The `coro.suspend`_; intrinsic in combination with the following switch indicates what happens to; control flow when a coroutine is suspended (default case), resumed (case 0) or; destroyed (case 1). Coroutine Transformation; ------------------------. One of the steps of coroutine lowering is building the coroutine frame. The; def-use chains are analyzed to determine which objects need be kept alive across; suspend points. In the coroutine shown in the previous section, use of virtual register; `%inc` is separated from the definition by a suspend point, therefore, it; cannot reside on the stack frame since the latter goes away once the coroutine; is suspended and control is returned back to the caller. An i32 slot is; allocated in the coroutine frame and `%inc` is spilled and reloaded from that; slot as needed. We also store addresses of the resume and destroy functions so that the; `coro.resume` and `coro.destroy` intrinsics can resume and destroy the coroutine; when its identity cannot be determined statically at compile time. For our; example, the coroutine frame will be:. .. code-block:: llvm. %f.frame = type { ptr, ptr, i32 }. After resume and destroy parts are outlined, function `f` will contain only the; code responsible for creation and initialization of the coroutine frame and; execution of the coroutine until a suspend point is reached:. .. code-block:: llvm. define ptr @f(i32 %n) {; entry:; %id = call token @llvm.coro.id(i32 0, ptr null, ptr null, ptr null); %alloc = call noalias ptr @malloc(i32 24); %frame = call noalias ptr @llvm.coro.begin(token %id, ptr %alloc); %1 = getelementptr %f.frame, ptr %frame, i32 0, i32 0; store ptr @f.resume, ptr %1; %2 = getelementptr %f.frame, ptr %frame, i32 0, i32 1; store ptr @f.destroy, ptr %2. %inc = add nsw i32 %n, 1; %inc.spill.addr = getelementptr inbounds %f.Frame, ptr %FramePtr, i32 0, i32 2; store i32 %inc, ptr %inc.spill.a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:14425,resume,resume,14425,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"ializing the Driver API:. .. code-block:: c++. CUdevice device;; CUcontext context;. // Initialize the driver API; cuInit(0);; // Get a handle to the first compute device; cuDeviceGet(&device, 0);; // Create a compute device context; cuCtxCreate(&context, 0, device);. JIT compiling a PTX string to a device binary:. .. code-block:: c++. CUmodule module;; CUfunction function;. // JIT compile a null-terminated PTX string; cuModuleLoadData(&module, (void*)PTXString);. // Get a handle to the ""myfunction"" kernel function; cuModuleGetFunction(&function, module, ""myfunction"");. For full examples of executing PTX assembly, please see the `CUDA Samples; <https://developer.nvidia.com/cuda-downloads>`_ distribution. Common Issues; =============. ptxas complains of undefined function: __nvvm_reflect; -----------------------------------------------------. When linking with libdevice, the ``NVVMReflect`` pass must be used. See; :ref:`libdevice` for more information. Tutorial: A Simple Compute Kernel; =================================. To start, let us take a look at a simple compute kernel written directly in; LLVM IR. The kernel implements vector addition, where each thread computes one; element of the output vector C from the input vectors A and B. To make this; easier, we also assume that only a single CTA (thread block) will be launched,; and that it will be one dimensional. The Kernel; ----------. .. code-block:: llvm. target datalayout = ""e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v16:16:16-v32:32:32-v64:64:64-v128:128:128-n16:32:64""; target triple = ""nvptx64-nvidia-cuda"". ; Intrinsic to read X component of thread ID; declare i32 @llvm.nvvm.read.ptx.sreg.tid.x() readnone nounwind. define void @kernel(float addrspace(1)* %A,; float addrspace(1)* %B,; float addrspace(1)* %C) {; entry:; ; What is my ID?; %id = tail call i32 @llvm.nvvm.read.ptx.sreg.tid.x() readnone nounwind. ; Compute pointers into A, B, and C; %ptrA = getelementptr float, floa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NVPTXUsage.rst:12430,Simpl,Simple,12430,interpreter/llvm-project/llvm/docs/NVPTXUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NVPTXUsage.rst,1,['Simpl'],['Simple']
Usability,"ials; - Add the ""Legacy"" category collecting the old tutorials which do not represent any more best practices. ## Class Reference Guide; - Images in tutorials can now be displayed à JavaScript thanks to the (js) option; added next to the directive `\macro_image`; - As the tutorial `palettes.C` is often hit when searching the keyword `palette`; in the reference guide, a direct link from this example to the full list of; predefined palettes given in `TColor` has been added.; - Revisited the TSpectrum2 documentation. All the static images have been replaced; by macros generating images at reference guide build time. These macros have; been added in the tutorial section of the reference guide.; - The Reference Guide can now be accessed directly from the ROOT prompt thanks to; a great extension (implemented by Desislava Kalaydjieva) of the `.help` command.; For example to access the Reference Guide for `TTree` it is enough to type:; ~~~ {.cpp}; root[0] .help TTree; ~~~; To open the reference guide for a function/member:; ~~~ {.cpp}; root[0] .help TTree::Draw; ~~~. ## Build, Configuration and Testing Infrastructure. - Make MLP optional via the `-Dmlp={OFF,ON}` switch for CMake; - Make Spectrum optional via the `-Dspectrum={OFF,ON}` switch for CMake; - ROOT now fails to configure when any package is missing; when `-Dfail-on-missing=ON` is passed to CMake; - The `-Dall=ON` now switches the default value of all optional packages to `ON`; - The options `astiff`, `cling`, `pch`, `thread`, and `explicitlink` have been; removed and are now ignored. They either had no effect (their value was not; being used in the build system), or could not be disabled (like `cling` and; `explicitlink`).; - ROOT library targets now export which C++ standard they were built with via; the target compile features `cxx_std_11`, `cxx_std_14`, and `cxx_std_17`.; - The file `RootNewMacros.cmake` has been renamed to `RootMacros.cmake`.; Including the old file by name is deprecated and will generate a war",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v620/index.md:7732,guid,guide,7732,README/ReleaseNotes/v620/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v620/index.md,1,['guid'],['guide']
Usability,"iately followed by return from the checker callback.; Multiple implementations of evalCall in different checkers should not conflict.; When implementing evalAssume, the checker should always return a non-null state; for either the true assumption or the false assumption (or both).; Checkers shall not mutate values of expressions, i.e. use the ProgramState::BindExpr API,; unless they are fully responsible for computing the value.; Under no circumstances should they change non-Unknown values of expressions.; Currently the only valid use case for this API in checkers is to model the return value in the evalCall callback.; If expression values are incorrect, ExprEngine needs to be fixed instead. Additional Sources of Information. Here are some additional resources that are useful when working on the Clang; Static Analyzer:. Xu, Zhongxing &; Kremenek, Ted & Zhang, Jian. (2010). A Memory Model for Static Analysis of C; Programs. The Clang Static Analyzer README. Documentation for how the Store works. Documentation about inlining; The ""Building a Checker in 24 hours"" presentation given at the November 2012 LLVM Developer's; meeting. Describes the construction of SimpleStreamChecker. Slides; and video; are available. Artem Degrachev: Clang Static Analyzer: A Checker Developer's Guide; (reading the previous items first might be a good idea); The list of Implicit Checkers; Clang doxygen. Contains; up-to-date documentation about the APIs available in Clang. Relevant entries; have been linked throughout this page. Also of use is the; LLVM doxygen, when dealing with classes; from LLVM. The Clang Frontend Discourse site.; This is the primary forum discussing ideas and posting questions about Clang development.; For posting Clang Static Analyzer specific questions, please visit the; Static Analyzer subcategory; of the same site. In the past, Static Analyzer discussions took place at the; cfe-dev mailing list, which is now; archived and superseeded by the mentioned Discourse site. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/checker_dev_manual.html:29707,Simpl,SimpleStreamChecker,29707,interpreter/llvm-project/clang/www/analyzer/checker_dev_manual.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/checker_dev_manual.html,2,"['Guid', 'Simpl']","['Guide', 'SimpleStreamChecker']"
Usability,"ib64""`` to cmake to add an absolute; path to ``libstdc++.so.6`` as above. Since these binaries are not distributed,; having an absolute local path is fine for them. When you build Clang, you will need to give *it* access to modern C++; standard library in order to use it as your new host in part of a bootstrap.; There are two easy ways to do this, either build (and install) libc++ along; with Clang and then use it with the ``-stdlib=libc++`` compile and link flag,; or install Clang into the same prefix (``$HOME/toolchains`` above) as GCC.; Clang will look within its own prefix for libstdc++ and use it if found. You; can also add an explicit prefix for Clang to look in for a GCC toolchain with; the ``--gcc-toolchain=/opt/my/gcc/prefix`` flag, passing it to both compile and; link commands when using your just-built-Clang to bootstrap. .. _Getting Started with LLVM:. Getting Started with LLVM; =========================. The remainder of this guide is meant to get you up and running with LLVM and to; give you some basic information about the LLVM environment. The later sections of this guide describe the `general layout`_ of the LLVM; source tree, a `simple example`_ using the LLVM tool chain, and `links`_ to find; more information about LLVM or to get help via e-mail. Terminology and Notation; ------------------------. Throughout this manual, the following names are used to denote paths specific to; the local system and working environment. *These are not environment variables; you need to set but just strings used in the rest of this document below*. In; any of the examples below, simply replace each of these names with the; appropriate pathname on your local system. All these paths are absolute:. ``SRC_ROOT``. This is the top level directory of the LLVM source tree. ``OBJ_ROOT``. This is the top level directory of the LLVM object tree (i.e. the tree where; object files and compiled programs will be placed. It can be the same as; SRC_ROOT). Unpacking the LLVM Archives;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst:20218,guid,guide,20218,interpreter/llvm-project/llvm/docs/GettingStarted.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst,1,['guid'],['guide']
Usability,"ibCore.so`) contains the essentials; it is a part of all; ROOT applications. In the Figure 1-2 you see that libCore.so is made; up of base classes, container classes, meta information classes,; operating system specific classes, and the ZIP algorithm used for; compression of the ROOT files. The Cling library (`libCling.so`) is also needed in all ROOT; applications, and even by `libCore`. A; program referencing only **`TObject`** only needs `libCore`;; `libCling` will be opened automatically. To add the ability to read and write; ROOT objects one also has to load `libRIO`. As one would expect, none of that; depends on graphics or the GUI. Library dependencies have different consequences; depending on whether; you try to build a binary, or you just try to access a class that is; defined in a library. #### Linktime Library Dependencies. When building your own executable you will have to link against the; libraries that contain the classes you use. The ROOT reference guide; states the library a class is reference guide defined in. Almost all; relevant classes can be found in libraries returned by; `root-config -glibs`; the graphics libraries are retuned by; `root-config --libs`. These commands are commonly used in `Makefiles`.; Using `root-config` instead of enumerating the libraries by hand; allows you to link them in a platform independent way. Also, if ROOT; library names change you will not need to change your Makefile. A batch program that does not have a graphic display, which creates,; fills, and saves histograms and trees, only needs to link the core; libraries (`libCore`, `libRIO`), `libHist` and `libTree`.; If ROOT needs access to other libraries, it loads them dynamically.; For example, if the **`TreeViewer`** is used, `libTreePlayer` and all; libraries `libTreePlayer` depends on are loaded also. The dependent; libraries are shown in the ROOT reference guide's library dependency; graph. The difference between reference guide `libHist` and; `libHistPainter` is",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:17216,guid,guide,17216,documentation/users-guide/Introduction.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md,2,['guid'],['guide']
Usability,"ic information in the IR. Why do struct member indices always use ``i32``?; ------------------------------------------------. The specific type i32 is probably just a historical artifact, however it's wide; enough for all practical purposes, so there's been no need to change it. It; doesn't necessarily imply i32 address arithmetic; it's just an identifier which; identifies a field in a struct. Requiring that all struct indices be the same; reduces the range of possibilities for cases where two GEPs are effectively the; same but have distinct operand types. What's an uglygep?; ------------------. Some LLVM optimizers operate on GEPs by internally lowering them into more; primitive integer expressions, which allows them to be combined with other; integer expressions and/or split into multiple separate integer expressions. If; they've made non-trivial changes, translating back into LLVM IR can involve; reverse-engineering the structure of the addressing in order to fit it into the; static type of the original first operand. It isn't always possibly to fully; reconstruct this structure; sometimes the underlying addressing doesn't; correspond with the static type at all. In such cases the optimizer instead will; emit a GEP with the base pointer casted to a simple address-unit pointer, using; the name ""uglygep"". This isn't pretty, but it's just as valid, and it's; sufficient to preserve the pointer aliasing guarantees that GEP provides. Summary; =======. In summary, here's some things to always remember about the GetElementPtr; instruction:. #. The GEP instruction never accesses memory, it only provides pointer; computations. #. The second operand to the GEP instruction is always a pointer and it must be; indexed. #. There are no superfluous indices for the GEP instruction. #. Trailing zero indices are superfluous for pointer aliasing, but not for the; types of the pointers. #. Leading zero indices are not superfluous for pointer aliasing nor the types; of the pointers.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GetElementPtr.rst:21136,simpl,simple,21136,interpreter/llvm-project/llvm/docs/GetElementPtr.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GetElementPtr.rst,1,['simpl'],['simple']
Usability,"ical and, which does not short circuit.; def binary& 6 (LHS RHS); if !LHS then; 0; else; !!RHS;. # Define = with slightly lower precedence than relationals.; def binary = 9 (LHS RHS); !(LHS < RHS | LHS > RHS);. # Define ':' for sequencing: as a low-precedence operator that ignores operands; # and just returns the RHS.; def binary : 1 (x y) y;. Given the previous if/then/else support, we can also define interesting; functions for I/O. For example, the following prints out a character; whose ""density"" reflects the value passed in: the lower the value, the; denser the character:. ::. ready> extern putchard(char);; ...; ready> def printdensity(d); if d > 8 then; putchard(32) # ' '; else if d > 4 then; putchard(46) # '.'; else if d > 2 then; putchard(43) # '+'; else; putchard(42); # '*'; ...; ready> printdensity(1): printdensity(2): printdensity(3):; printdensity(4): printdensity(5): printdensity(9):; putchard(10);; **++.; Evaluated to 0.000000. Based on these simple primitive operations, we can start to define more; interesting things. For example, here's a little function that determines; the number of iterations it takes for a certain function in the complex; plane to diverge:. ::. # Determine whether the specific location diverges.; # Solve for z = z^2 + c in the complex plane.; def mandelconverger(real imag iters creal cimag); if iters > 255 | (real*real + imag*imag > 4) then; iters; else; mandelconverger(real*real - imag*imag + creal,; 2*real*imag + cimag,; iters+1, creal, cimag);. # Return the number of iterations required for the iteration to escape; def mandelconverge(real imag); mandelconverger(real, imag, 0, real, imag);. This ""``z = z2 + c``"" function is a beautiful little creature that is; the basis for computation of the `Mandelbrot; Set <http://en.wikipedia.org/wiki/Mandelbrot_set>`_. Our; ``mandelconverge`` function returns the number of iterations that it; takes for a complex orbit to escape, saturating to 255. This is not a; very useful function by itsel",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl06.rst:16364,simpl,simple,16364,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl06.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl06.rst,1,['simpl'],['simple']
Usability,"ically-unreachable handlers; Not resolved. 2220; C++17; Hiding index variable in range-based for; Unknown. 2221; CD6; Copying volatile objects; Unknown. 2222; drafting; Additional contexts where instantiation is not required; Not resolved. 2223; drafting; Multiple alignas specifiers; Not resolved. 2224; C++17; Member subobjects and base-class casts; Unknown. 2225; NAD; reinterpret_cast to same floating-point type; Unknown. 2226; CD5; Xvalues vs lvalues in conditional expressions; Unknown. 2227; CD5; Destructor access and default member initializers; Unknown. 2228; open; Ambiguity resolution for cast to function type; Not resolved. 2229; CD5; Volatile unnamed bit-fields; Clang 7. 2230; NAD; Linkage of extern ""C"" function in unnamed namespace; Unknown. 2231; NAD; Class member access to static data member template; Unknown. 2232; open; thread_local anonymous unions; Not resolved. 2233; CD5; Function parameter packs following default arguments; Clang 11. 2234; CD5; Missing rules for simple-template-id as class-name; Unknown. 2235; CD5; Partial ordering and non-dependent types; Unknown. 2236; drafting; When is an alias template specialization dependent?; Not resolved. 2237; CD5; Can a template-id name a constructor?; Unknown. 2238; NAD; Contradictory alignment requirements for allocation; Unknown. 2239; NAD; Sized deallocation with a trivial destructor; Unknown. 2240; NAD; this is not odr-used in a constant expression; Unknown. 2241; CD5; Overload resolution is not invoked with a single function; Unknown. 2242; C++23; ODR violation with constant initialization possibly omitted; Unknown. 2243; drafting; Incorrect use of implicit conversion sequence; Not resolved. 2244; open; Base class access in aggregate initialization; Not resolved. 2245; drafting; Point of instantiation of incomplete class template; Not resolved. 2246; drafting; Access of indirect virtual base class constructors; Not resolved. 2247; C++17; Lambda capture and variable argument list; Unknown. 2248; C++17",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:152207,simpl,simple-template-id,152207,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['simpl'],['simple-template-id']
Usability,"icator; Passes; ReportingGuide; ResponseGuide; Remarks; RemoveDIsDebugInfo; RISCVUsage; SourceLevelDebugging; SPIRVUsage; StackSafetyAnalysis; SupportLibrary; TableGen/index; TableGenFundamentals; Vectorizers; WritingAnLLVMPass; WritingAnLLVMNewPMPass; WritingAnLLVMBackend; yaml2obj. Clang; -----. :doc:`HowToBuildOnARM`; Notes on building and testing LLVM/Clang on ARM. :doc:`HowToBuildWithPGO`; Notes on building LLVM/Clang with PGO. :doc:`HowToCrossCompileLLVM`; Notes on cross-building and testing LLVM/Clang. `How to build the C, C++, ObjC, and ObjC++ front end`__; Instructions for building the clang front-end from source. .. __: https://clang.llvm.org/get_started.html. :doc:`CoverageMappingFormat`; This describes the format and encoding used for LLVM’s code coverage mapping. :doc:`CFIVerify`; A description of the verification tool for Control Flow Integrity. LLVM Builds and Distributions; -----------------------------. :doc:`BuildingADistribution`; A best-practices guide for using LLVM's CMake build system to package and; distribute LLVM-based tools. :doc:`CMake`; An addendum to the main Getting Started guide for those using the `CMake; build system <http://www.cmake.org>`_. :doc:`Docker`; A reference for using Dockerfiles provided with LLVM. :doc:`Support Library <SupportLibrary>`; This document describes the LLVM Support Library (``lib/Support``) and; how to keep LLVM source code portable. :doc:`AdvancedBuilds`; This document describes more advanced build configurations. Optimizations; -------------. :doc:`WritingAnLLVMPass`; Information on how to write LLVM transformations and analyses. :doc:`WritingAnLLVMNewPMPass`; Information on how to write LLVM transformations under the new pass; manager. :doc:`Passes`; A list of optimizations and analyses implemented in LLVM. :doc:`StackSafetyAnalysis`; This document describes the design of the stack safety analysis of local; variables. :doc:`MergeFunctions`; Describes functions merging optimization. :doc:`AliasAnalysis`; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/UserGuides.rst:2082,guid,guide,2082,interpreter/llvm-project/llvm/docs/UserGuides.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/UserGuides.rst,1,['guid'],['guide']
Usability,"icitly version locked so you'll need to make sure; you're using a Clang built from the same git revision or release as the LLVM; library you're using. As always, it's *strongly* recommended that you track; tip of tree development, particularly during bring up of a new project. The Basics; ^^^^^^^^^^^. #. Make sure that your Modules contain both a data layout specification and; target triple. Without these pieces, non of the target specific optimization; will be enabled. This can have a major effect on the generated code quality. #. For each function or global emitted, use the most private linkage type; possible (private, internal or linkonce_odr preferably). Doing so will; make LLVM's inter-procedural optimizations much more effective. #. Avoid high in-degree basic blocks (e.g. basic blocks with dozens or hundreds; of predecessors). Among other issues, the register allocator is known to; perform badly with confronted with such structures. The only exception to; this guidance is that a unified return block with high in-degree is fine. Use of allocas; ^^^^^^^^^^^^^^. An alloca instruction can be used to represent a function scoped stack slot,; but can also represent dynamic frame expansion. When representing function; scoped variables or locations, placing alloca instructions at the beginning of; the entry block should be preferred. In particular, place them before any; call instructions. Call instructions might get inlined and replaced with; multiple basic blocks. The end result is that a following alloca instruction; would no longer be in the entry basic block afterward. The SROA (Scalar Replacement Of Aggregates) and Mem2Reg passes only attempt; to eliminate alloca instructions that are in the entry basic block. Given; SSA is the canonical form expected by much of the optimizer; if allocas can; not be eliminated by Mem2Reg or SROA, the optimizer is likely to be less; effective than it could be. Avoid loads and stores of large aggregate type; ^^^^^^^^^^^^^^^^^^^^^^^^",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Frontend/PerformanceTips.rst:2043,guid,guidance,2043,interpreter/llvm-project/llvm/docs/Frontend/PerformanceTips.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Frontend/PerformanceTips.rst,1,['guid'],['guidance']
Usability,"ickling:. .. code-block:: python. >>> from cppyy.gbl import Namespace; >>> Concrete == Namespace.Concrete; False; >>> n = Namespace.Concrete.NestedClass(); >>> type(n); <class cppyy.gbl.Namespace.Concrete.NestedClass at 0x22114c0>; >>> type(n).__name__; NestedClass; >>> type(n).__module__; cppyy.gbl.Namespace.Concrete; >>> type(n).__cpp_name__; Namespace::Concrete::NestedClass; >>>. `Constructors`; --------------. Python and C++ both make a distinction between allocation (``__new__`` in; Python, ``operator new`` in C++) and initialization (``__init__`` in Python,; the constructor call in C++).; When binding, however, there comes a subtle semantic difference: the Python; ``__new__`` allocates memory for the proxy object only, and ``__init__``; initializes the proxy by creating or binding the C++ object.; Thus, no C++ memory is allocated until ``__init__``.; The advantages are simple: the proxy can now check whether it is initialized,; because the pointer to C++ memory will be NULL if not; it can be a reference; to another proxy holding the actual C++ memory; and it can now transparently; implement a C++ smart pointer.; If ``__init__`` is never called, eg. when a call to the base class; ``__init__`` is missing in a derived class override, then accessing the proxy; will result in a Python ``ReferenceError`` exception. `Destructors`; -------------. There should no be reason to call a destructor directly in CPython, but e.g.; PyPy uses a garbage collector and that makes it sometimes useful to destruct; a C++ object exactly when you want it destroyed.; Destructors are by convention accessible through the ``__destruct__`` method; (since ""~"" can not be part of a Python method name).; If a Python-side derived class overrides ``__destruct__``, that method will; be called when the instance gets deleted in C++.; The Python destructor, ``__del__``, gets called when the Python proxy goes; away, which will only delete the C++ instance if owned by Python.; Note that ``__del__`` is n",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/classes.rst:2260,simpl,simple,2260,bindings/pyroot/cppyy/cppyy/doc/source/classes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/classes.rst,1,['simpl'],['simple']
Usability,idy/readability/RedundantAccessSpecifiersCheck.h; clang-tools-extra/clang-tidy/readability/RedundantControlFlowCheck.cpp; clang-tools-extra/clang-tidy/readability/RedundantControlFlowCheck.h; clang-tools-extra/clang-tidy/readability/RedundantDeclarationCheck.cpp; clang-tools-extra/clang-tidy/readability/RedundantDeclarationCheck.h; clang-tools-extra/clang-tidy/readability/RedundantMemberInitCheck.cpp; clang-tools-extra/clang-tidy/readability/RedundantMemberInitCheck.h; clang-tools-extra/clang-tidy/readability/RedundantPreprocessorCheck.cpp; clang-tools-extra/clang-tidy/readability/RedundantPreprocessorCheck.h; clang-tools-extra/clang-tidy/readability/RedundantSmartptrGetCheck.cpp; clang-tools-extra/clang-tidy/readability/RedundantSmartptrGetCheck.h; clang-tools-extra/clang-tidy/readability/RedundantStringCStrCheck.h; clang-tools-extra/clang-tidy/readability/RedundantStringInitCheck.cpp; clang-tools-extra/clang-tidy/readability/RedundantStringInitCheck.h; clang-tools-extra/clang-tidy/readability/SimplifyBooleanExprCheck.cpp; clang-tools-extra/clang-tidy/readability/SimplifyBooleanExprCheck.h; clang-tools-extra/clang-tidy/readability/SimplifyBooleanExprMatchers.h; clang-tools-extra/clang-tidy/readability/SimplifySubscriptExprCheck.cpp; clang-tools-extra/clang-tidy/readability/StaticAccessedThroughInstanceCheck.cpp; clang-tools-extra/clang-tidy/readability/StaticAccessedThroughInstanceCheck.h; clang-tools-extra/clang-tidy/readability/StaticDefinitionInAnonymousNamespaceCheck.cpp; clang-tools-extra/clang-tidy/readability/StaticDefinitionInAnonymousNamespaceCheck.h; clang-tools-extra/clang-tidy/readability/StringCompareCheck.cpp; clang-tools-extra/clang-tidy/readability/StringCompareCheck.h; clang-tools-extra/clang-tidy/readability/SuspiciousCallArgumentCheck.cpp; clang-tools-extra/clang-tidy/readability/SuspiciousCallArgumentCheck.h; clang-tools-extra/clang-tidy/readability/UniqueptrDeleteReleaseCheck.cpp; clang-tools-extra/clang-tidy/readability/UniqueptrDeleteReleaseCh,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt:70726,Simpl,SimplifyBooleanExprCheck,70726,interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,1,['Simpl'],['SimplifyBooleanExprCheck']
Usability,"ieces; is not defined by neighbors, but by `containment`. In other words,; volumes are put one inside another making an in-depth hierarchy. From; outside, the whole thing looks like a big pack that you can open finding; out other smaller packs nicely arranged waiting to be opened at their; turn. The biggest one containing all others defines the ""`world`"" of the; model. We will often call this `master reference system (MARS)`. Going; on and opening our packs, we will obviously find out some empty ones,; otherwise, something is very wrong... We will call these leaves (by; analogy with a tree structure). On the other hand, any volume is a small world by itself - what we need; to do is to take it out and to ignore all the rest since it is a; self-contained object. In fact, the modeller can act like this,; considering a given volume as temporary MARS, but we will describe this; feature later on. Let us focus on the biggest pack - it is mandatory to; define one. Consider the simplest geometry that is made of a single box.; Here is an example on how to build it:. ### Example 1: Creating the World. We first need to load the geometry library. This is not needed if one; does `make map` in root folder. ``` {.cpp}; root[] gSystem->Load(""libGeom"");; ```. Second, we have to create an instance of the geometry manager class.; This takes care of all the modeller components, performing several tasks; to insure geometry validity and containing the user interface for; building and interacting with the geometry. After its creation, the; geometry manager class can be accessed with the global; ***`gGeoManager`***:. ``` {.cpp}; root[] new TGeoManager(""world"", ""the simplest geometry"");; ```. We want to create a single volume in our geometry, but since any volume; needs to have an associated medium, we will create a dummy one. You can; safely ignore the following lines for the time being, since materials; and media will be explained in detail later on. ``` {.cpp}; root[] TGeoMaterial *mat = n",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:1988,simpl,simplest,1988,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['simpl'],['simplest']
Usability,"ields.io/badge/License-LGPL%20v2.1+-blue.svg)](https://www.gnu.org/licenses/lgpl.html); [![CII Best Practices](https://bestpractices.coreinfrastructure.org/projects/5060/badge)](https://bestpractices.coreinfrastructure.org/projects/5060). ## Contribution Guidelines; - [How to contribute](https://github.com/root-project/root/blob/master/CONTRIBUTING.md); - [Coding conventions](https://root.cern/coding-conventions); - [Meetings](https://root.cern/meetings). ## Cite; When citing ROOT, please use both the reference reported below and the DOI specific to your ROOT version available [on Zenodo](https://zenodo.org/badge/latestdoi/10994345) [![DOI](https://zenodo.org/badge/10994345.svg)](https://zenodo.org/badge/latestdoi/10994345). For example, you can copy-paste and fill in the following citation:. Rene Brun and Fons Rademakers, ROOT - An Object Oriented Data Analysis Framework,; Proceedings AIHENP'96 Workshop, Lausanne, Sep. 1996,; Nucl. Inst. & Meth. in Phys. Res. A 389 (1997) 81-86.; See also ""ROOT"" [software], Release vX.YY/ZZ, dd/mm/yyyy. ## Live Demo for CERN Users; [![](https://img.shields.io/badge/Launch-SWAN-orange)](http://cern.ch/swanserver/cgi-bin/go?projurl=https://github.com/cernphsft/rootbinder.git). See more screenshots on our [gallery](https://root.cern/gallery). ## Installation and Getting Started; See https://root.cern/install for installation instructions.; For instructions on how to build ROOT from these source files, see https://root.cern/install/build_from_source. Our [""Getting started with ROOT""](https://root.cern/learn) page is then the perfect place to get familiar with ROOT. ## Help and Support; - [Forum](https://root.cern/forum/); - [Issue tracker](https://github.com/root-project/root/issues); * [Previous now read-only Jira issue tracker](https://sft.its.cern.ch/jira/projects/ROOT/issues/ROOT-5820?filter=allopenissues); - [Documentation](https://root.cern/guides/reference-guide); - [Tutorials](https://root.cern/doc/master/group__Tutorials.html)",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README.md:3344,learn,learn,3344,README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README.md,3,"['guid', 'learn']","['guide', 'guides', 'learn']"
Usability,"ient frame. Closing these transient; frames will not delete, but just hide existing opened editors for later; reuse. Their lifetime is determined by the canvas to which the manager; editor is attached to, since these will be destroyed together. ![Editors for shapes, materials, media, matrices](pictures/020001F0.jpg); ![Editors for shapes, materials, media, matrices](pictures/020001F1.jpg); ![Editors for shapes, materials, media, matrices](pictures/020001F2.jpg); ![Editors for shapes, materials, media, matrices](pictures/020001F3.jpg); ![Editors for shapes, materials, media, matrices](pictures/030001F4.png). For most editors, the functionalities Apply and Undo are provided. For shapes, changing any of the shape parameters will activate the; ""*Apply*"" button only if the check button ""*Delayed draw*"" is checked,; otherwise the changes are immediately applied. Once the apply button is; pressed, the changes are applied to the edited shape and drawn. The; ""*Undo*"" button becomes active after the first modification has been; applied. It allows restoring the initial parameters of the shape. NOTE: In this version the ""*Undo*"" does not allow restoring an; intermediate state of the parameters that was applied - it will always; restore the parameters at the moment the shape was edited. All material properties changes are undoable. The mixture editor; currently allows adding elements one by one in the mixture composition.; This can be done either by element weight fraction or by number of; atoms. Once an element was added using one method the other method is not; selectable anymore. Summing component fractions up to 1 in the final; mixture is the user responsibility. Adding materials as components of a; mixture is not supported in this version. The elements that were added to the mixture appear in the bottom of the; mixture editor. The operations performed on mixture are not undoable. ### Creation of New Objects. As described above, all geometry object creators are accessible wi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:170822,Undo,Undo,170822,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['Undo'],['Undo']
Usability,"ies : 20 : Total Size= 19334 bytes File Size = 1671 *; *Baskets : 2 : Basket Size= 16000 bytes Compression= 11.29 *; *............................................................................*; *Br 18 :fTriggerBits : TBits *; *Entries : 20 : Total Size= 1398 bytes File Size = 400 *; *Baskets : 1 : Basket Size= 16000 bytes Compression= 2.23 *; *............................................................................*; *Br 19 :fIsValid : Bool_t *; *Entries : 20 : Total Size= 582 bytes File Size = 92 *; *Baskets : 1 : Basket Size= 16000 bytes Compression= 1.00 *. Add a new function TBranch::SetStatus It is much faster to call this function in case of a Tree with many branches; instead of calling TTree::SetBranchStatus.; Implement TTreeCache::Print that shows information like:; // ******TreeCache statistics for file: cms2.root ******; // Number of branches in the cache ...: 1093; // Cache Efficiency ..................: 0.997372; // Cache Efficiency Rel...............: 1.000000; // Learn entries......................: 100; // Reading............................: 72761843 bytes in 7 transactions; // Readahead..........................: 256000 bytes with overhead = 0 bytes; // Average transaction................: 10394.549000 Kbytes; // Number of blocks in current cache..: 210, total size: 6280352; This function can be called directly from TTree: T->PrintCacheStats();. Add support for variable size array of object in a TTree (when the owner of the array is split.); And many other bug fixes, security fixes, thread safety and performance improvements ; see the svn log for details. TTree Scan and Draw. Insured that the generated histogram as an integral bin width when plotting a string or integer.; Improved the output of TTree::Scan by inserting a blank space whenever a value is not available because there is no proper row in a friend.; (Previously it was re-printing the previous value). This required changes in ; When the draw option to TTree::Draw contains ""norm"" the ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/doc/v528/index.html:5907,Learn,Learn,5907,tree/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/doc/v528/index.html,1,['Learn'],['Learn']
Usability,"ies ``GlobalsAA``, one that always stops at ``MemoryPhi`` nodes, etc). Default walker APIs; ^^^^^^^^^^^^^^^^^^^. There are two main APIs used to retrieve the clobbering access using the walker:. - ``MemoryAccess *getClobberingMemoryAccess(MemoryAccess *MA);`` return the; clobbering memory access for ``MA``, caching all intermediate results; computed along the way as part of each access queried. - ``MemoryAccess *getClobberingMemoryAccess(MemoryAccess *MA, const MemoryLocation &Loc);``; returns the access clobbering memory location ``Loc``, starting at ``MA``.; Because this API does not request the clobbering access of a specific memory; access, there are no results that can be cached. Locating clobbers yourself; ^^^^^^^^^^^^^^^^^^^^^^^^^^. If you choose to make your own walker, you can find the clobber for a; ``MemoryAccess`` by walking every ``MemoryDef`` that dominates said; ``MemoryAccess``. The structure of ``MemoryDef``\ s makes this relatively simple;; they ultimately form a linked list of every clobber that dominates the; ``MemoryAccess`` that you're trying to optimize. In other words, the; ``definingAccess`` of a ``MemoryDef`` is always the nearest dominating; ``MemoryDef`` or ``MemoryPhi`` of said ``MemoryDef``. Use and Def optimization; ------------------------. ``MemoryUse``\ s keep a single operand, which is their defining or optimized; access.; Traditionally ``MemorySSA`` optimized ``MemoryUse``\ s at build-time, up to a; given threshold.; Specifically, the operand of every ``MemoryUse`` was optimized to point to the; actual clobber of said ``MemoryUse``. This can be seen in the above example; the; second ``MemoryUse`` in ``if.end`` has an operand of ``1``, which is a; ``MemoryDef`` from the entry block. This is done to make walking,; value numbering, etc, faster and easier.; As of `this revision <https://reviews.llvm.org/D121381>`_, the default was; changed to not optimize uses at build time, in order to provide the option to; reduce compile-time if th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MemorySSA.rst:10675,simpl,simple,10675,interpreter/llvm-project/llvm/docs/MemorySSA.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MemorySSA.rst,1,['simpl'],['simple']
Usability,"ies; involved tasked to resolve the issues, still making sure the solution doesn't; break or invalidate the core tier.; * Impose sub-optimal implementation strategies on core tier components as a; result of idiosyncrasies in the peripheral component.; * Have build infrastructure that spams all developers about their breakages.; * Fall into disrepair. This is a reflection of lack of an active sub-community; and will result in removal. Code in this tier should:; * Have infrastructure to test, whenever meaningful, with either no warnings or; notification contained within the sub-community.; * Have support and testing that scales with the complexity and resilience of; the component, with the bar for simple and gracefully-degrading components; (such as editor bindings) much lower than for complex components that must; remain fresh with HEAD (such as experimental back-ends or alternative build; systems).; * Have a document making clear the status of implementation, level of support; available, who the sub-community is and, if applicable, roadmap for inclusion; into the core tier.; * Be restricted to a specific directory or have a consistent pattern (ex.; unique file suffix), making it easy to remove when necessary. Inclusion Policy; ================. To add a new peripheral component, send an RFC to the appropriate dev list; proposing its addition and explaining how it will meet the support requirements; listed above. Different types of components could require different levels of; detail. when in doubt, ask the community what's the best approach. Inclusion must reach consensus in the RFC by the community and the approval of; the corresponding review (by multiple members of the community) is the official; note of acceptance. After merge, there often is a period of transition, where teething issues on; existing buildbots are discovered and fixed. If those cannot be fixed straight; away, the sub-community is responsible for tracking and reverting all the; pertinent patches a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportPolicy.rst:6377,clear,clear,6377,interpreter/llvm-project/llvm/docs/SupportPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportPolicy.rst,1,['clear'],['clear']
Usability,if (NOT HAVE_CXX_ATOMICS64_WITHOUT_LIB); set (atomic_lib atomic); endif(). if( CMAKE_HOST_UNIX AND HAVE_LIBRT ); set(rt_lib rt); endif(). add_llvm_component_library(LLVMOrcJIT; COFFVCRuntimeSupport.cpp; COFFPlatform.cpp; CompileOnDemandLayer.cpp; CompileUtils.cpp; Core.cpp; DebugObjectManagerPlugin.cpp; DebugUtils.cpp; EPCDynamicLibrarySearchGenerator.cpp; EPCDebugObjectRegistrar.cpp; EPCEHFrameRegistrar.cpp; EPCGenericDylibManager.cpp; EPCGenericJITLinkMemoryManager.cpp; EPCGenericRTDyldMemoryManager.cpp; EPCIndirectionUtils.cpp; ExecutionUtils.cpp; ObjectFileInterface.cpp; IndirectionUtils.cpp; IRCompileLayer.cpp; IRTransformLayer.cpp; JITTargetMachineBuilder.cpp; LazyReexports.cpp; Layer.cpp; LookupAndRecordAddrs.cpp; LLJIT.cpp; MachOPlatform.cpp; MapperJITLinkMemoryManager.cpp; MemoryMapper.cpp; ELFNixPlatform.cpp; Mangling.cpp; ObjectLinkingLayer.cpp; ObjectTransformLayer.cpp; OrcABISupport.cpp; OrcV2CBindings.cpp; RTDyldObjectLinkingLayer.cpp; SimpleRemoteEPC.cpp; Speculation.cpp; SpeculateAnalyses.cpp; ExecutorProcessControl.cpp; TaskDispatch.cpp; ThreadSafeModule.cpp; ADDITIONAL_HEADER_DIRS; ${LLVM_MAIN_INCLUDE_DIR}/llvm/ExecutionEngine/Orc. DEPENDS; intrinsics_gen. LINK_LIBS; ${LLVM_PTHREAD_LIB}; ${rt_lib}; ${atomic_lib}. LINK_COMPONENTS; Core; ExecutionEngine; JITLink; Object; OrcShared; OrcTargetProcess; WindowsDriver; MC; Passes; RuntimeDyld; Support; Target; TargetParser; TransformUtils; ). add_subdirectory(Debugging); add_subdirectory(Shared); add_subdirectory(TargetProcess). target_link_libraries(LLVMOrcJIT; PRIVATE; LLVMAnalysis; LLVMBitReader; LLVMBitWriter; LLVMPasses; ); ,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/CMakeLists.txt:964,Simpl,SimpleRemoteEPC,964,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/CMakeLists.txt,1,['Simpl'],['SimpleRemoteEPC']
Usability,if( CMAKE_HOST_UNIX AND HAVE_LIBRT ); set(rt_lib rt); endif(). add_llvm_component_library(LLVMOrcTargetProcess; ExecutorSharedMemoryMapperService.cpp; JITLoaderGDB.cpp; JITLoaderPerf.cpp; OrcRTBootstrap.cpp; RegisterEHFrames.cpp; SimpleExecutorDylibManager.cpp; SimpleExecutorMemoryManager.cpp; SimpleRemoteEPCServer.cpp; TargetExecutionUtils.cpp. ADDITIONAL_HEADER_DIRS; ${LLVM_MAIN_INCLUDE_DIR}/llvm/ExecutionEngine/Orc. LINK_LIBS; ${LLVM_PTHREAD_LIB}; ${rt_lib}. LINK_COMPONENTS; OrcShared; Support; TargetParser; ); ,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/TargetProcess/CMakeLists.txt:230,Simpl,SimpleExecutorDylibManager,230,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/TargetProcess/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/TargetProcess/CMakeLists.txt,3,['Simpl'],"['SimpleExecutorDylibManager', 'SimpleExecutorMemoryManager', 'SimpleRemoteEPCServer']"
Usability,"if(LLVM_EXAMPLEIRTRANSFORMS_LINK_INTO_TOOLS); message(WARNING ""Setting LLVM_EXAMPLEIRTRANSFORMS_LINK_INTO_TOOLS=ON only makes sense for testing purpose""); endif(). # The plugin expects to not link against the Support and Core libraries,; # but expects them to exist in the process loading the plugin. This doesn't; # work with DLLs on Windows (where a shared library can't have undefined; # references), so just skip this example on Windows.; if (NOT WIN32 AND NOT CYGWIN); add_llvm_pass_plugin(ExampleIRTransforms; SimplifyCFG.cpp; DEPENDS; intrinsics_gen; BUILDTREE_ONLY; ). install(TARGETS ${name} RUNTIME DESTINATION ""${LLVM_EXAMPLES_INSTALL_DIR}""); set_target_properties(${name} PROPERTIES FOLDER ""Examples""); endif(); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/IRTransforms/CMakeLists.txt:516,Simpl,SimplifyCFG,516,interpreter/llvm-project/llvm/examples/IRTransforms/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/IRTransforms/CMakeLists.txt,1,['Simpl'],['SimplifyCFG']
Usability,"igation and Tracking. Tracking is the feature allowing the transport of a given particle; knowing its kinematics. A state is determined by any combination of the; position \f$\vec{r}\f$ and direction \f$\vec{n}\f$ with respect to the world; reference frame. The direction \f$\vec{n}\f$ must be a unit vector having as; components the director cosines. The full classification of a given; state will provide the following information: the deepest physical node; containing the position vector, the distance to the closest boundary; along the direction vector, the next physical node after propagating the; current point with this distance and the safety distance to the nearest; boundary. This information allows the propagation of particles inside a; detector geometry by taking into account both geometrical and physical; constraints. We will hereby describe the user interface of `TGeo` to access; tracking functionality. This allows either developing a tracker for; simple navigation within a given geometry, either interfacing to an; external tracking engine such as GEANT. Note that the abstract interface; for external trackers can be found in `$ROOTSYS/vmc` folder and it can; be used to run GEANT3, GEANT4 and FLUKA-based simulations (\*) by using; directly a geometry described with %ROOT. The interface methods related to tracking are incorporated into; TGeoManager class and implemented in the navigator class; TGeoNavigator. In order to be able to start tracking, one has to; define the initial state providing the starting point \f$\vec{r_0}\f$; and direction \f$\vec{n_0}\f$ .; There are several ways of doing that. \anchor GP02a; ### TGeoNavigator Class. One geometry may have several independent navigators to query to; localize points or compute distances. The geometry manager holds a list; of active navigators accessible via:. ~~~{.cpp}; TObjArray *navigators = gGeoManager->GetListOfNavigators();; ~~~. Upon closing the geometry a default navigator is provided as first one; in t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:62206,simpl,simple,62206,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['simpl'],['simple']
Usability,"ights that; you have. You must make sure that they, too, receive or can get the; source code. And you must show them these terms so they know their; rights. We protect your rights with two steps: (1) copyright the software, and; (2) offer you this license which gives you legal permission to copy,; distribute and/or modify the software. Also, for each author's protection and ours, we want to make certain; that everyone understands that there is no warranty for this free; software. If the software is modified by someone else and passed on, we; want its recipients to know that what they have is not the original, so; that any problems introduced by others will not reflect on the original; authors' reputations. Finally, any free program is threatened constantly by software; patents. We wish to avoid the danger that redistributors of a free; program will individually obtain patent licenses, in effect making the; program proprietary. To prevent this, we have made it clear that any; patent must be licensed for everyone's free use or not licensed at all. The precise terms and conditions for copying, distribution and; modification follow. GNU GENERAL PUBLIC LICENSE; TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION. 0. This License applies to any program or other work which contains; a notice placed by the copyright holder saying it may be distributed; under the terms of this General Public License. The ""Program"", below,; refers to any such program or work, and a ""work based on the Program""; means either the Program or any derivative work under copyright law:; that is to say, a work containing the Program or a portion of it,; either verbatim or with modifications and/or translated into another; language. (Hereinafter, translation is included without limitation in; the term ""modification"".) Each licensee is addressed as ""you"". Activities other than copying, distribution and modification are not; covered by this License; they are outside its scope. The act of; runn",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/misc/rootql/LICENSE.txt:2646,clear,clear,2646,misc/rootql/LICENSE.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/misc/rootql/LICENSE.txt,2,['clear'],['clear']
Usability,"igned and built by experienced compiler developers who are; increasingly frustrated with the problems that existing open source; compilers have. Clang is carefully and thoughtfully designed and; built to provide the foundation of a whole new generation of; C/C++/Objective C development tools, and we intend for it to be; production quality.; Being a production quality compiler means many things: it means being high; performance, being solid and (relatively) bug free, and it means eventually; being used and depended on by a broad range of people. While we are still in; the early development stages, we strongly believe that this will become a; reality. A simple and hackable code base. Our goal is to make it possible for anyone with a basic understanding; of compilers and working knowledge of the C/C++/ObjC languages to understand and; extend the clang source base. A large part of this falls out of our decision to; make the AST mirror the languages as closely as possible: you have your friendly; if statement, for statement, parenthesis expression, structs, unions, etc, all; represented in a simple and explicit way.; In addition to a simple design, we work to make the source base approachable; by commenting it well, including citations of the language standards where; appropriate, and designing the code for simplicity. Beyond that, clang offers; a set of AST dumpers, printers, and visualizers that make it easy to put code in; and see how it is represented. A single unified parser for C, Objective C, C++,; and Objective C++. Clang is the ""C Language Family Front-end"", which means we intend to support; the most popular members of the C family. We are convinced that the right; parsing technology for this class of languages is a hand-built recursive-descent; parser. Because it is plain C++ code, recursive descent makes it very easy for; new developers to understand the code, it easily supports ad-hoc rules and other; strange hacks required by C/C++, and makes it straight-forw",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html:12381,simpl,simple,12381,interpreter/llvm-project/clang/www/features.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html,1,['simpl'],['simple']
Usability,"igned to eliminate unreachable internal globals from the; program. It uses an aggressive algorithm, searching out globals that are known; to be alive. After it finds all of the globals which are needed, it deletes; whatever is left over. This allows it to delete recursive chunks of the; program which are unreachable. ``globalopt``: Global Variable Optimizer; ----------------------------------------. This pass transforms simple global variables that never have their address; taken. If obviously true, it marks read/write globals as constant, deletes; variables only stored to, etc. ``gvn``: Global Value Numbering; -------------------------------. This pass performs global value numbering to eliminate fully and partially; redundant instructions. It also performs redundant load elimination. .. _passes-indvars:. ``indvars``: Canonicalize Induction Variables; ---------------------------------------------. This transformation analyzes and transforms the induction variables (and; computations derived from them) into simpler forms suitable for subsequent; analysis and transformation. This transformation makes the following changes to each loop with an; identifiable induction variable:. * All loops are transformed to have a *single* canonical induction variable; which starts at zero and steps by one.; * The canonical induction variable is guaranteed to be the first PHI node in; the loop header block.; * Any pointer arithmetic recurrences are raised to use array subscripts. If the trip count of a loop is computable, this pass also makes the following; changes:. * The exit condition for the loop is canonicalized to compare the induction; value against the exit value. This turns loops like:. .. code-block:: c++. for (i = 7; i*i < 1000; ++i). into. .. code-block:: c++. for (i = 0; i != 25; ++i). * Any use outside of the loop of an expression derived from the indvar is; changed to compute the derived value outside of the loop, eliminating the; dependence on the exit value of the ind",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst:17742,simpl,simpler,17742,interpreter/llvm-project/llvm/docs/Passes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst,1,['simpl'],['simpler']
Usability,"igned with the local coordinates;; - Algorithms for dividing the shape along a given axis. The modeller currently provides a set of 20 basic shapes, which we will; call `primitives`. It also provides a special class allowing the; creation of shapes as a result of Boolean operations between primitives.; These are called `composite shapes` and the composition operation can be; recursive (combined composites). This allows the creation of a quite; large number of different shape topologies and combinations. You can; have a look and run the tutorial: geodemo.C. \image html geom_primitive_shapes.png Primitive Shapes - the general inheritance scheme. Shapes are named objects and all primitives have constructors like:. ~~~ {.cpp}; TGeoXXX(const char *name,<type> param1,<type> param2, ...);; TGeoXXX(<type> param1,<type> param2, ...);; ~~~. Naming shape primitive is mandatory only for the primitives used in; Boolean composites (see ""Composite Shapes""). For the sake of simplicity,; we will describe only the constructors in the second form. \anchor SHAPES01; ### Primitive Shapes. - Boxes: TGeoBBox class; - Parallelepiped: TGeoPara class; - Trapezoids: TGeoTrd1, TGeoTrd2 classes; - General Trapezoid: TGeoTrap class; - Twisted Trapezoid: TGeoGtra class; - Arbitrary 8 vertices shapes: TGeoArb8 class; - Tubes: TGeoTube class; - Tube Segments: TGeoTubeSeg class; - Cut Tubes: TGeoCtub class; - Elliptical Tubes: TGeoEltu class; - Hyperboloids: TGeoHype class; - Cones: TGeoCone class; - Cone Segments: TGeoConeSeg class; - Sphere: TGeoSphere class; - Torus: TGeoTorus class; - Paraboloid: TGeoParaboloid class; - Polycone: TGeoPcon class; - Polygon: TGeoPgon class; - Polygonal extrusion: TGeoXtru class; - Half Spaces: TGeoHalfSpace class; - Composite Shapes: TGeoCompositeShape class. \anchor SHAPES02; ### Navigation Methods Performed By Shapes. Shapes are named objects and register themselves to the `manager class`; at creation time. This is responsible for their final deletion. Shapes; c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/shapes.md:2294,simpl,simplicity,2294,geom/geom/doc/shapes.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/shapes.md,1,['simpl'],['simplicity']
Usability,"ild the plugin, and then call clang with the plugin from the; source tree:. .. code-block:: console. $ export BD=/path/to/build/directory; $ (cd $BD && make PrintFunctionNames ); $ clang++ -D_GNU_SOURCE -D_DEBUG -D__STDC_CONSTANT_MACROS \; -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS -D_GNU_SOURCE \; -I$BD/tools/clang/include -Itools/clang/include -I$BD/include -Iinclude \; tools/clang/tools/clang-check/ClangCheck.cpp -fsyntax-only \; -Xclang -load -Xclang $BD/lib/PrintFunctionNames.so -Xclang \; -plugin -Xclang print-fns. Also see the print-function-name plugin example's; `README <https://github.com/llvm/llvm-project/blob/main/clang/examples/PrintFunctionNames/README.txt>`_. Using the clang command line; ----------------------------. Using `-fplugin=plugin` on the clang command line passes the plugin; through as an argument to `-load` on the cc1 command line. If the plugin; class implements the ``getActionType`` method then the plugin is run; automatically. For example, to run the plugin automatically after the main AST; action (i.e. the same as using `-add-plugin`):. .. code-block:: c++. // Automatically run the plugin after the main AST action; PluginASTAction::ActionType getActionType() override {; return AddAfterMainAction;; }. Interaction with ``-clear-ast-before-backend``; ----------------------------------------------. To reduce peak memory usage of the compiler, plugins are recommended to run; *before* the main action, which is usually code generation. This is because; having any plugins that run after the codegen action automatically turns off; ``-clear-ast-before-backend``. ``-clear-ast-before-backend`` reduces peak; memory by clearing the Clang AST after generating IR and before running IR; optimizations. Use ``CmdlineBeforeMainAction`` or ``AddBeforeMainAction`` as; ``getActionType`` to run plugins while still benefitting from; ``-clear-ast-before-backend``. Plugins must make sure not to modify the AST,; otherwise they should run after the main action. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst:7259,clear,clear-ast-before-backend,7259,interpreter/llvm-project/clang/docs/ClangPlugins.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst,5,['clear'],"['clear-ast-before-backend', 'clearing']"
Usability,"ilders are; constructed explicitly. In general, ``Stencil``\ s produce text from a match result. So, they are not; limited to generating source code, but can also be used to generate diagnostic; messages that reference (named) elements of the matched code, like we saw in the; example of rewriting method calls. Further details of the ``Stencil`` type are documented in the header file; `clang/Tooling/Transformer/Stencil.h <https://github.com/llvm/llvm-project/blob/main/clang/include/clang/Tooling/Transformer/Stencil.h>`_. Edits; ^^^^^. Transformer supports additional forms of edits. First, in a ``changeTo``, we can; specify the particular portion of code to be replaced, using the same; ``RangeSelector`` we saw earlier. For example, we could change the function name; in a function declaration with:. .. code-block:: c++. makeRule(functionDecl(hasName(""bad"")).bind(f),; 	 changeTo(name(f), cat(""good"")),; 	 cat(""bad is now good""));. We also provide simpler editing primitives for insertion and deletion:; ``insertBefore``, ``insertAfter`` and ``remove``. These can all be found in the header; file; `clang/Tooling/Transformer/RewriteRule.h <https://github.com/llvm/llvm-project/blob/main/clang/include/clang/Tooling/Transformer/RewriteRule.h>`_. We are not limited one edit per match found. Some situations require making; multiple edits for each match. For example, suppose we wanted to swap two; arguments of a function call. For this, we provide an overload of ``makeRule`` that takes a list of edits,; rather than just a single one. Our example might look like:. .. code-block:: c++. makeRule(callExpr(...),; 	 {changeTo(node(arg0), cat(node(arg2))),; 	 changeTo(node(arg2), cat(node(arg0)))},; 	 cat(""swap the first and third arguments of the call""));. ``EditGenerator``\ s (Advanced); ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The particular edits we've seen so far are all instances of the ``ASTEdit`` class,; or a list of such. But, not all edits can be expressed as ``ASTEdit``\ s. So, we; als",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst:12781,simpl,simpler,12781,interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,1,['simpl'],['simpler']
Usability,"ile, add switch to control the way histograms; are merged by TFileMerger, i.e. one-by-one or all-in-one-go. The; default is one-by-one which requires much less memory. Merging in; one-go (the previous default) can be activated by passing 'H' in the; constructor options.; In ProofBench, add possibility to change the location of the; generated files via the third argument of TProofBench::MakeDataSet.; Several optimizations in the low level PROOF event loop; (TProofPlayer::Process),  allowing to reduce dramatically the; overhead introduced by the operations PROOF needs to perform during the; event loop. A measurement of the overhead can be obtained from a very; light computational task, for example, generating one random number and; filling one histogram; executing this task within a PROOF-Lite session; with 1 worker now takes only 1.8 times the time required by a straight; loop in the parent ROOT session; the same number before was about 13. ; In TDrawFeedback::Feedback, call method Draw() of objects not; identified as TH1 derivation. This allows user-defined objects; implementing Draw to be displayed via this utility class.; In TProof::LoadPackageOnClient, do not create a symlink; 'pack_name' to the package dir, but add directly the package dir to the; include path. This solves the longstanding annoying problem of failure; when a directory or file with the name of the package did already exist; in the local working directory. . Fixes; ; Fix merging issue affecting automatic dataset creation when; only one worker is active.; Fix the realtime reported by TProof::GetRealTime() for masters; (it was overwritten with the ones coming from workers).; Fix serious problem with TProof::Load: additional files were; not copied in the master sandbox but left in the cache. A workaround; for backward compatibility has also been implemented.; Fix a problem preventing actions requiring access to worker; nodes (log file retrieval, reset) to work on workers where the username; is differe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v534/index.html:4000,Feedback,Feedback,4000,proof/doc/v534/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v534/index.html,1,['Feedback'],['Feedback']
Usability,"iler it is generally advised to perform a; bootstrap build of the compiler. That means building a ""stage 1"" compiler with; your host toolchain, then building the ""stage 2"" compiler using the ""stage 1""; compiler. This is done so that the compiler you distribute benefits from all the; bug fixes, performance optimizations and general improvements provided by the; new compiler. In deciding how to build your distribution there are a few trade-offs that you; will need to evaluate. The big two are:. #. Compile time of the distribution against performance of the built compiler. #. Binary size of the distribution against performance of the built compiler. The guidance for maximizing performance of the generated compiler is to use LTO,; PGO, and statically link everything. This will result in an overall larger; distribution, and it will take longer to generate, but it provides the most; opportunity for the compiler to optimize. The guidance for minimizing distribution size is to dynamically link LLVM and; Clang libraries into the tools to reduce code duplication. This will come at a; substantial performance penalty to the generated binary both because it reduces; optimization opportunity, and because dynamic linking requires resolving symbols; at process launch time, which can be very slow for C++ code. .. _shared_libs:. .. warning::; One very important note: Distributions should never be built using the; *BUILD_SHARED_LIBS* CMake option. That option exists for optimizing developer; workflow only. Due to design and implementation decisions, LLVM relies on; global data which can end up being duplicated across shared libraries; resulting in bugs. As such this is not a safe way to distribute LLVM or; LLVM-based tools. The simplest example of building a distribution with reasonable performance is; captured in the DistributionExample CMake cache file located at; clang/cmake/caches/DistributionExample.cmake. The following command will perform; and install the distribution build:. .",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BuildingADistribution.rst:1691,guid,guidance,1691,interpreter/llvm-project/llvm/docs/BuildingADistribution.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BuildingADistribution.rst,1,['guid'],['guidance']
Usability,"ile} 'pr-44884-dwarf-gcc.o' -> elf32-littlearm. [001] {CompileUnit} 'pr-44884.cpp'; [002] {Producer} 'GNU C++14 10.2.1 20201103'; [002] 1 {Function} extern not_inlined 'bar' -> 'int'; [003] 1 {Parameter} 'Input' -> 'float'; [003] 1 {Line}; [003] 1 {Line}; [003] 1 {Line}; [002] 3 {Function} extern not_inlined 'foo' -> 'unsigned int'; [003] {Block}; [004] {Block}; [005] 9 {Variable} 'Added' -> 'FLOAT'; [005] 9 {Line}; [005] 9 {Line}; [005] 9 {Line}; [005] 10 {Line}; [005] 13 {Line}; [004] 7 {TypeAlias} 'FLOAT' -> 'float'; [003] 3 {Parameter} 'Param' -> 'char'; [003] 4 {TypeAlias} 'INT' -> 'int'; [003] 5 {Variable} 'Value' -> 'INT'; [003] 3 {Line}; [003] 5 {Line}; [003] 13 {Line}; [003] 14 {Line}; [003] 14 {Line}. From the previous logical views, we can see that the Clang compiler; emits **both typedefs at the same lexical scope (3)**, which is wrong.; GCC and MSVC emit correct lexical scope for both typedefs. Using the :program:`llvm-debuginfo-analyzer` selection facilities, we; can produce a simple tabular output showing just the logical types that; are **Typedef**. .. code-block:: none. llvm-debuginfo-analyzer --attribute=level,format; --output-sort=name; --select-types=Typedef; --report=list; --print=types; pr-44884-*.o. Logical View:; [000] {File} 'pr-44884-codeview-clang.o' -> COFF-x86-64. [001] {CompileUnit} 'pr_44884.cpp'; [003] {TypeAlias} 'FLOAT' -> 'float'; [003] {TypeAlias} 'INT' -> 'int'. Logical View:; [000] {File} 'pr-44884-codeview-msvc.o' -> COFF-i386. [001] {CompileUnit} 'pr_44884.cpp'; [004] {TypeAlias} 'FLOAT' -> 'float'; [003] {TypeAlias} 'INT' -> 'int'. Logical View:; [000] {File} 'pr-44884-dwarf-clang.o' -> elf64-x86-64. [001] {CompileUnit} 'pr_44884.cpp'; [003] 7 {TypeAlias} 'FLOAT' -> 'float'; [003] 4 {TypeAlias} 'INT' -> 'int'. Logical View:; [000] {File} 'pr-44884-dwarf-gcc.o' -> elf32-littlearm. [001] {CompileUnit} 'pr_44884.cpp'; [004] 7 {TypeAlias} 'FLOAT' -> 'float'; [003] 4 {TypeAlias} 'INT' -> 'int'. It also shows, that the CodeView debu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst:40861,simpl,simple,40861,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst,1,['simpl'],['simple']
Usability,iliMinimize.h; Minuit2/MnFunctionCross.h; Minuit2/MnGlobalCorrelationCoeff.h; Minuit2/MnHesse.h; Minuit2/MnLineSearch.h; Minuit2/MnMachinePrecision.h; Minuit2/MnMatrix.h; Minuit2/MnMatrixfwd.h; Minuit2/MnMigrad.h; Minuit2/MnMinimize.h; Minuit2/MnMinos.h; Minuit2/MnParabola.h; Minuit2/MnParabolaFactory.h; Minuit2/MnParabolaPoint.h; Minuit2/MnParameterScan.h; Minuit2/MnPlot.h; Minuit2/MnPosDef.h; Minuit2/MnPrint.h; Minuit2/MnScan.h; Minuit2/MnSeedGenerator.h; Minuit2/MnSimplex.h; Minuit2/MnStrategy.h; Minuit2/MnTiny.h; Minuit2/MnTraceObject.h; Minuit2/MnUserCovariance.h; Minuit2/MnUserFcn.h; Minuit2/MnUserParameterState.h; Minuit2/MnUserParameters.h; Minuit2/MnUserTransformation.h; Minuit2/MnVectorTransform.h; Minuit2/ModularFunctionMinimizer.h; Minuit2/NegativeG2LineSearch.h; Minuit2/Numerical2PGradientCalculator.h; Minuit2/NumericalDerivator.h; Minuit2/ParametricFunction.h; Minuit2/ScanBuilder.h; Minuit2/ScanMinimizer.h; Minuit2/SimplexBuilder.h; Minuit2/SimplexMinimizer.h; Minuit2/SimplexParameters.h; Minuit2/SimplexSeedGenerator.h; Minuit2/SinParameterTransformation.h; Minuit2/SqrtLowParameterTransformation.h; Minuit2/SqrtUpParameterTransformation.h; Minuit2/StackAllocator.h; Minuit2/VariableMetricBuilder.h; Minuit2/VariableMetricEDMEstimator.h; Minuit2/VariableMetricMinimizer.h; Minuit2/VectorOuterProduct.h; TMinuit2TraceObject.h; SOURCES; src/AnalyticalGradientCalculator.cxx; src/BFGSErrorUpdator.cxx; src/CMakeLists.txt; src/CombinedMinimumBuilder.cxx; src/DavidonErrorUpdator.cxx; src/ExternalInternalGradientCalculator.cxx; src/FumiliBuilder.cxx; src/FumiliErrorUpdator.cxx; src/FumiliGradientCalculator.cxx; src/FumiliMinimizer.cxx; src/FumiliStandardChi2FCN.cxx; src/FumiliStandardMaximumLikelihoodFCN.cxx; src/HessianGradientCalculator.cxx; src/InitialGradientCalculator.cxx; src/LaEigenValues.cxx; src/LaInnerProduct.cxx; src/LaInverse.cxx; src/LaOuterProduct.cxx; src/LaSumOfElements.cxx; src/LaVtMVSimilarity.cxx; src/MPIProcess.cxx; src/MinimumBuilder.cxx; src/Min,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/CMakeLists.txt:3116,Simpl,SimplexParameters,3116,math/minuit2/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/CMakeLists.txt,1,['Simpl'],['SimplexParameters']
Usability,"ill in progress, results in the blog post show that; ThinLTO already performs well compared to LTO, in many cases matching; the performance improvement. Current Status; ==============. Clang/LLVM; ----------; .. _compiler:. The 3.9 release of clang includes ThinLTO support. However, ThinLTO; is under active development, and new features, improvements and bugfixes; are being added for the next release. For the latest ThinLTO support,; `build a recent version of clang and LLVM; <https://llvm.org/docs/CMake.html>`_. Linkers; -------; .. _linkers:; .. _linker:. ThinLTO is currently supported for the following linkers:. - **gold (via the gold-plugin)**:; Similar to monolithic LTO, this requires using; a `gold linker configured with plugins enabled; <https://llvm.org/docs/GoldPlugin.html>`_.; - **ld64**:; Starting with `Xcode 8 <https://developer.apple.com/xcode/>`_.; - **lld**:; Starting with r284050 for ELF, r298942 for COFF. Usage; =====. Basic; -----. To utilize ThinLTO, simply add the -flto=thin option to compile and link. E.g. .. code-block:: console. % clang -flto=thin -O2 file1.c file2.c -c; % clang -flto=thin -O2 file1.o file2.o -o a.out. When using lld-link, the -flto option need only be added to the compile step:. .. code-block:: console. % clang-cl -flto=thin -O2 -c file1.c file2.c; % lld-link /out:a.exe file1.obj file2.obj. As mentioned earlier, by default the linkers will launch the ThinLTO backend; threads in parallel, passing the resulting native object files back to the; linker for the final native link. As such, the usage model is the same as; non-LTO. With gold, if you see an error during the link of the form:. .. code-block:: console. /usr/bin/ld: error: /path/to/clang/bin/../lib/LLVMgold.so: could not load plugin library: /path/to/clang/bin/../lib/LLVMgold.so: cannot open shared object file: No such file or directory. Then either gold was not configured with plugins enabled, or clang; was not built with ``-DLLVM_BINUTILS_INCDIR`` set properly. See; th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst:2481,simpl,simply,2481,interpreter/llvm-project/clang/docs/ThinLTO.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst,1,['simpl'],['simply']
Usability,"ime to time. Such new versions will; be similar in spirit to the present version, but may differ in detail to; address new problems or concerns. Each version is given a distinguishing version number. If the Program; specifies a version number of this License which applies to it and ""any; later version"", you have the option of following the terms and conditions; either of that version or of any later version published by the Free; Software Foundation. If the Program does not specify a version number of; this License, you may choose any version ever published by the Free Software; Foundation. 10. If you wish to incorporate parts of the Program into other free; programs whose distribution conditions are different, write to the author; to ask for permission. For software which is copyrighted by the Free; Software Foundation, write to the Free Software Foundation; we sometimes; make exceptions for this. Our decision will be guided by the two goals; of preserving the free status of all derivatives of our free software and; of promoting the sharing and reuse of software generally. NO WARRANTY. 11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY; FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN; OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES; PROVIDE THE PROGRAM ""AS IS"" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED; OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF; MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE ENTIRE RISK AS; TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD THE; PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,; REPAIR OR CORRECTION. 12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING; WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR; REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,; INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARI",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/misc/rootql/LICENSE.txt:13608,guid,guided,13608,misc/rootql/LICENSE.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/misc/rootql/LICENSE.txt,2,['guid'],['guided']
Usability,"imple: they are fixed strings that; must occur in order. FileCheck defaults to ignoring horizontal whitespace; differences (e.g. a space is allowed to match a tab) but otherwise, the contents; of the ""``CHECK:``"" line is required to match some thing in the test file exactly. One nice thing about FileCheck (compared to grep) is that it allows merging; test cases together into logical groups. For example, because the test above; is checking for the ""``sub1:``"" and ""``inc4:``"" labels, it will not match; unless there is a ""``subl``"" in between those labels. If it existed somewhere; else in the file, that would not count: ""``grep subl``"" matches if ""``subl``""; exists anywhere in the file. The FileCheck -check-prefix option; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. The FileCheck `-check-prefix` option allows multiple test; configurations to be driven from one `.ll` file. This is useful in many; circumstances, for example, testing different architectural variants with; :program:`llc`. Here's a simple example:. .. code-block:: llvm. ; RUN: llvm-as < %s | llc -mtriple=i686-apple-darwin9 -mattr=sse41 \; ; RUN: | FileCheck %s -check-prefix=X32; ; RUN: llvm-as < %s | llc -mtriple=x86_64-apple-darwin9 -mattr=sse41 \; ; RUN: | FileCheck %s -check-prefix=X64. define <4 x i32> @pinsrd_1(i32 %s, <4 x i32> %tmp) nounwind {; %tmp1 = insertelement <4 x i32>; %tmp, i32 %s, i32 1; ret <4 x i32> %tmp1; ; X32: pinsrd_1:; ; X32: pinsrd $1, 4(%esp), %xmm0. ; X64: pinsrd_1:; ; X64: pinsrd $1, %edi, %xmm0; }. In this case, we're testing that we get the expected code generation with; both 32-bit and 64-bit code generation. The ""COM:"" directive; ~~~~~~~~~~~~~~~~~~~~. Sometimes you want to disable a FileCheck directive without removing it; entirely, or you want to write comments that mention a directive by name. The; ""``COM:``"" directive makes it easy to do this. For example, you might have:. .. code-block:: llvm. ; X32: pinsrd_1:; ; X32: pinsrd $1, 4(%esp), %xmm0. ; COM: FIXME: X64 isn't working corr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst:10135,simpl,simple,10135,interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,1,['simpl'],['simple']
Usability,"implicit `this`. Given; struct X {; int m;; int f(X x) { x.m; return m; }; };; memberExpr(hasObjectExpression(hasType(cxxRecordDecl(hasName(""X""))))); matches `x.m`, but not `m`; however,; memberExpr(hasObjectExpression(hasType(pointsTo(; cxxRecordDecl(hasName(""X"")))))); matches `m` (aka. `this->m`), but not `x.m`. Matcher<MemberExpr>memberMatcher<ValueDecl> InnerMatcher; Matches a member expression where the member is matched by a; given matcher. Given; struct { int first, second; } first, second;; int i(second.first);; int j(first.second);; memberExpr(member(hasName(""first""))); matches second.first; but not first.second (because the member name there is ""second""). Matcher<MemberPointerType>pointeeMatcher<Type>; Narrows PointerType (and similar) matchers to those where the; pointee matches a given matcher. Given; int *a;; int const *b;; float const *f;; pointerType(pointee(isConstQualified(), isInteger())); matches ""int const *b"". Usable as: Matcher<BlockPointerType>, Matcher<MemberPointerType>,; Matcher<PointerType>, Matcher<ReferenceType>. Matcher<NamedDecl>hasUnderlyingDeclMatcher<NamedDecl> InnerMatcher; Matches a NamedDecl whose underlying declaration matches the given; matcher. Given; namespace N { template<class T> void f(T t); }; template <class T> void g() { using N::f; f(T()); }; unresolvedLookupExpr(hasAnyDeclaration(; namedDecl(hasUnderlyingDecl(hasName(""::N::f""))))); matches the use of f in g() . Matcher<NestedNameSpecifierLoc>hasPrefixMatcher<NestedNameSpecifierLoc> InnerMatcher; Matches on the prefix of a NestedNameSpecifierLoc. Given; struct A { struct B { struct C {}; }; };; A::B::C c;; nestedNameSpecifierLoc(hasPrefix(loc(specifiesType(asString(""struct A""))))); matches ""A::"". Matcher<NestedNameSpecifierLoc>locMatcher<NestedNameSpecifier> InnerMatcher; Matches NestedNameSpecifierLocs for which the given inner; NestedNameSpecifier-matcher matches. Matcher<NestedNameSpecifierLoc>specifiesTypeLocMatcher<TypeLoc> InnerMatcher; Matches nested name specifi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:215583,Usab,Usable,215583,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['Usab'],['Usable']
Usability,"improvements in the experimental Intel DAOS backend. - `RNTupleWriter::Fill()` now returns the number of uncompressed bytes written, which is align with TTree behavior. - Support for user-defined classes that behave as a collection via the `TVirtualCollectionProxy` interface.; Fields created via `RFieldBase::Create()` automatically detect the presence of a collection proxy at run-time. However, if `RField<T>` (`T` being a class) is used instead, the trait `IsCollectionProxy<T>` must be set for the given type (see PR [#11525](https://github.com/root-project/root/pull/11525) for details).; Note that associative collections are not yet supported. - Some internal support for per field post-read callbacks. This functionality will be presented in upcoming releases through custom I/O rules. Please, report any issues regarding the abovementioned features should you encounter them.; RNTuple is still experimental and is scheduled to become production grade in 2024. Thus, we appreciate feedback and suggestions for improvement. ## RDataFrame. ### New features. - Add [`GraphAsymmErrors`](https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html#acea30792eef607489d498bf6547a00a6) action that fills a TGraphAsymmErrors object.; - Introduce [`RDatasetSpec`](https://root.cern/doc/master/classROOT_1_1RDF_1_1Experimental_1_1RDatasetSpec.html) as an; experimental class to specify the input dataset to an RDataFrame.; - Arbitrary metadata can be associated to the samples in the dataset specified via `RDatasetSpect`. The metadata of each; sample can then be retrieved during the execution by calling `DefinePerSample`.; - Users can create an RDataFrame with a dataset specification written in a JSON file via the factory function; [ROOT::RDF::Experimental::FromSpec](https://root.cern/doc/master/namespaceROOT_1_1RDF_1_1Experimental.html#a7193987f3c1b65c649399656cc6acce8). ### Notable bug fixes and improvements. - Fix the node counter of [`SaveGraph`](https://root.cern/doc/master/namespac",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md:10634,feedback,feedback,10634,README/ReleaseNotes/v628/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md,1,['feedback'],['feedback']
Usability,"in a; unique section. It will also place all basic blocks of functions ``bar``; in unique sections. Further, section clusters can also be specified using the ``list=<arg>``; option. For example, ``list=spec.txt`` where ``spec.txt`` contains:. ::. !foo; !!1 !!3 !!5; !!2 !!4 !!6. will create two unique sections for function ``foo`` with the first; containing the odd numbered basic blocks and the second containing the; even numbered basic blocks. Basic block sections allow the linker to reorder basic blocks and enables; link-time optimizations like whole program inter-procedural basic block; reordering. Profile Guided Optimization; ---------------------------. Profile information enables better optimization. For example, knowing that a; branch is taken very frequently helps the compiler make better decisions when; ordering basic blocks. Knowing that a function ``foo`` is called more; frequently than another function ``bar`` helps the inliner. Optimization; levels ``-O2`` and above are recommended for use of profile guided optimization. Clang supports profile guided optimization with two different kinds of; profiling. A sampling profiler can generate a profile with very low runtime; overhead, or you can build an instrumented version of the code that collects; more detailed profile information. Both kinds of profiles can provide execution; counts for instructions in the code and information on branches taken and; function invocation. Regardless of which kind of profiling you use, be careful to collect profiles; by running your code with inputs that are representative of the typical; behavior. Code that is not exercised in the profile will be optimized as if it; is unimportant, and the compiler may make poor optimization choices for code; that is disproportionately used while profiling. Differences Between Sampling and Instrumentation; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Although both techniques are used for similar purposes, there are important; differences ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:89978,guid,guided,89978,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['guid'],['guided']
Usability,"in batch:; ; {; TCanvas *canvas = new TCanvas(""c5"",""c5"",900,900);; TH1F *histo = new TH1F(""Histo"",""123456x_{i}abcdefy^{2}"",100,0,20);; canvas->Print(""drawing.gif"");; }; ; Suppress annoying messages like:; ; root : looking for image ""filename"" in path [/home/username/icons]; ; printed by libAfterImage when using TImage::Open(""filename""); In TImageDump the hollow filled areas were not correct:; ; they used the line attributes,; a line was drawn around the polygons filled with patterns. This fixes the problem mentionned here:; https://savannah.cern.ch/bugs/index.php?59263; as well as the test #22 in stressGraphics (no need to change; the reference file). Interface to graphviz. Thanks to three new classes (TGraphStruct, TGraphNode and; TGraphEdge) ROOT provides; an interface to the graphs visualization package graphviz. Graph; visualization is a way of representing structural information as diagrams of; abstract graphs and networks. Example:. The previous image is produced by the following ROOT macro:; ; // Draw a simple graph structure.; // The graph layout is made using graphviz. This macro creates some; // nodes and edges and change a few graphical attributes on some of them.; // Author: Olivier Couet; {; TGraphStruct *gs = new TGraphStruct();. // create some nodes and put them in the graph in one go ...; TGraphNode *n0 = gs->AddNode(""n0"",""Node 0"");; TGraphNode *n1 = gs->AddNode(""n1"",""First node"");; TGraphNode *n2 = gs->AddNode(""n2"",""Second node"");; TGraphNode *n3 = gs->AddNode(""n3"",""Third node"");; TGraphNode *n4 = gs->AddNode(""n4"",""Fourth node"");; TGraphNode *n5 = gs->AddNode(""n5"",""5th node"");; TGraphNode *n6 = gs->AddNode(""n6"",""Node number six"");; TGraphNode *n7 = gs->AddNode(""n7"",""Node 7"");; TGraphNode *n8 = gs->AddNode(""n8"",""Node 8"");; TGraphNode *n9 = gs->AddNode(""n9"",""Node 9"");. n4->SetTextSize(0.03);; n6->SetTextSize(0.03);; n2->SetTextSize(0.04);. n3->SetTextFont(132);. n0->SetTextColor(kRed);. n9->SetFillColor(kRed-10);; n0->SetFillColor(kYellow-9);; n7->SetF",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/doc/v526/index.html:1797,simpl,simple,1797,graf2d/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/doc/v526/index.html,1,['simpl'],['simple']
Usability,"in one of these modifiers:. - - `%txt` : to print the text label associated with the slice. - - `%val` : to print the numeric value of the slice. - - `%frac` : to print the relative fraction of this slice. - - `%perc` : to print the % of this slice. ``` {.cpp}; mypie->SetLabelFormat(""%txt (%frac)"");; ```. See the macro `$ROOTSYS/tutorials/graphics/piechart.C` . ![The picture generated by tutorial macro piechart.C](pictures/03000042.png). ## The User Interface for Histograms. The classes **`T`** **`H1`** **`Editor`** and **`T`** **`H2`**; **`Editor`** provides the user interface for setting histogram's; attributes and rebinning interactively. ### TH1Editor. ![](pictures/03000043.png). #### The Style Tab. ##### Title. sets the title of the histogram. ##### Plot. draw a 2D or 3D plot; according to the dimension, different drawing; possibilities can be set. ##### Error; add different error bars to the histogram (no errors, simple, etc.). ##### Add; further things which can be added to the histogram (None,; simple/smooth line, fill area, etc.). #### 2-D Plot. ##### Simple Drawing; draw a simple histogram without errors (= ""HIST"" draw; option). In combination with some other draw options an outer line is; drawn on top of the histogram. ##### Show markers; draw a marker on to of each bin (=""P"" draw option). ##### Draw bar chart; draw a bar chart (=""B"" draw option). ##### Bar option; draw a bar chart (=""BAR"" draw option); if selected, it will; show an additional interface elements for bars: width, offset,; percentage and the possibility to draw horizontal bars. #### 3-D Plot. ##### Add; set histogram type Lego-Plot or Surface draw (Lego, Lego1.2, Surf,; Surf1...5). ##### Coords; set the coordinate system (Cartesian, Spheric, etc.). ##### Error; same as for 2D plot. ##### Bar; set the bar attributes: width and offset. ##### Horizontal Bar; draw a horizontal bar chart. #### The Binning tab; The binning tab has two different layouts. One is for a histogram,; which is not drawn",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:71865,simpl,simple,71865,documentation/users-guide/Histograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md,1,['simpl'],['simple']
Usability,"in the frame; co_await await_counter{};; a = load __int_32_0; std::cout << a+1 << ""\n"";; std::cout << a+2 << ""\n"";; std::cout << a+3 << ""\n"";; co_await await_counter{};; a = load __int_32_0; std::cout << a+4 << ""\n"";; std::cout << a+5 << ""\n"";; }. It should now be obvious why the value of `__int_32_0` remains unchanged; throughout the function. It is important to recognize that `__int_32_0`; does not directly correspond to `a`, but is instead a variable generated; to assist the compiler in code generation. The variables in an optimized; coroutine frame should not be thought of as directly representing the; variables in the C++ source. Get the suspended points; ========================. An important requirement for debugging coroutines is to understand suspended; points, which are where the coroutine is currently suspended and awaiting. For simple cases like the above, inspecting the value of the `__coro_index`; variable in the coroutine frame works well. However, it is not quite so simple in really complex situations. In these; cases, it is necessary to use the coroutine libraries to insert the; line-number. For example:. .. code-block:: c++. // For all the promise_type we want:; class promise_type {; ...; + unsigned line_number = 0xffffffff;; };. #include <source_location>. // For all the awaiter types we need:; class awaiter {; ...; template <typename Promise>; void await_suspend(std::coroutine_handle<Promise> handle,; std::source_location sl = std::source_location::current()) {; ...; handle.promise().line_number = sl.line();; }; };. In this case, we use `std::source_location` to store the line number of the; await inside the `promise_type`. Since we can locate the coroutine function; from the address of the coroutine, we can identify suspended points this way; as well. The downside here is that this comes at the price of additional runtime cost.; This is consistent with the C++ philosophy of ""Pay for what you use"". Get the asynchronous stack; =====================",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst:10805,simpl,simple,10805,interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst,1,['simpl'],['simple']
Usability,"in this case is scaled by the histogram bin width. ### TFormula. * Fix several bugs in the new TFormula class.; * Add as new pre-defined functions: `crystalball`, `breitwigner` and `cheb0,cheb1,...cheb10` for the Chebyshev polynomials. . ## Math Libraries. ### Random numbers. * Move from MathMore to MathCore the class `ROOT::Math::Random`. Make it a new interface class for random number generation. Add interfaces for standard; ROOT random engines, GSL random engines and random engines provided by the C++ standard library (`std::random`).; * Add a new randomengine, `MIXMAX` based on matrix-recursive random number generator from Kostas and George Savvidy. See this [paper](http://dx.doi.org/10.1016/j.cpc.2015.06.003). ## R Interface. Apply several improvements in the interface to R, allowing to use R functions within ROOT.; See more at the [ROOT-R User Guide](http://oproject.org/tiki-index.php?page=ROOT%20R%20Users%20Guide). . ## TMVA. Add new TMVA plug-in based on R and Python (using Scikit-Learn) ; * See the [RMVA Web page](http://oproject.org/tiki-index.php?page=RMVA) for a detailed description of the new TMVA method based on R; * See the [PyMVA Web page](http://oproject.org/tiki-index.php?page=PyMVA) for detailed description of the machine learning methods added in TMVA and based on the Python Scikit-Learn package. ## RooFit Libraries; . ## 2D Graphics Libraries. ### THistPainter. Improve the algorithm to compute the lower limit of an axis in log scale when its; real lower limit is 0. The problem was reported in ROOT-7414. Using the `COL` option with histograms having some negative bins; the empty bins; (containing 0) are drawn. In some cases one wants to not draw empty bins; (containing 0) of histograms having a negative minimum. The option `1`, used with; the option `COL`, allows to do that. Implement the Log option for `CANDLE` plots as requested; [here](https://root.cern.ch/phpBB3/viewtopic.php?f=3&t=20225&p=87006#p87006). ### TTeXDump. From Dmitry Kalinkin (via",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v606/index.md:14126,Learn,Learn,14126,README/ReleaseNotes/v606/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v606/index.md,1,['Learn'],['Learn']
Usability,"in turn. The relationship between a; collection and its iterator is very close and may require that the; iterator has full access to the collection (i.e. it is a friend class).; In general iterator will be used via the **`TIter`** wrapper class. For; example:. - **`TList`** **`TListIter`**. - **`TMap`** **`TMapIter`**. ## Foundation Classes. All collections are based on the fundamental classes: **`TCollection`**; and **`TIterator`**. They are so generic that it is not possible to; create objects from them; they are only used as base classes for other; classes (i.e. they are abstract base classes). The **`TCollection`** class provides the basic protocol (i.e. the; minimum set of member functions) that all collection classes have to; implement. These include:. - `Add` `Adds another object to the collection.`. - `GetSize` `Returns the number of objects in the collection.`. - `Clear`; `Clears out the collection, but does not delete the removed objects.`. - `Delete`; `Clears out the collection and deletes the removed objects. This should only `; `be used if the collection owns its objects (which are not normally the case).`. - `FindObject` `Finds an object given either its name or address.`. - `MakeIterator` `Returns an iterator associated with the collection.`. - `Remove` `Removes an object from the collection.`. The code example below shows a class containing three lists, where the; `fTracks` list is the owning collection and the other two lists are used; to store a sub-set of the track objects. In the destructor of the class,; the method `Delete` is called for the owning collection to delete; correctly its entire track objects. To delete the objects in the; container use `fTrack->Delete()`. To delete the container itself, do; '`delete fTracks'.`. ``` {.cpp}; class TEvent : public TObject {; private:; TList *fTracks; //list of all tracks; TList *fVertex1; //subset of tracks part of vertex1; TList *fVertex2; //subset of tracks part of vertex2; };; TEvent::~TEvent(); {; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md:6902,Clear,Clears,6902,documentation/users-guide/CollectionClasses.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md,1,['Clear'],['Clears']
