quality_attribute,sentence,source,author,repo,version,id,keyword,matched_word,match_idx,filename,wiki,url,total_similar,target_keywords,target_matched_words
Energy Efficiency," E. DePrince and C. D. Sherrill,; J. Chem. Theory Comput. 9, 2687-2696 (2013).; (doi: 10.1021/ct400250u). Implementation of the asymmetric triples correction for the density-fitted; and cholesky-decomposed coupled-cluster singles and doubles method. “A noniterative asymmetric triple excitation correction for the density-fitted; coupled-cluster singles and doubles method: Preliminary applications,”; U. Bozkaya, J. Chem. Phys. 144, 144108 (2016).; (doi: 10.1063/1.4945706). Implementation of analytic gradients for the density-fitted; coupled-cluster singles and doubles method. “Analytic energy gradients for the coupled-cluster singles and doubles method with; the density-fitting approximation,”; U. Bozkaya and C. D. Sherrill, J. Chem. Phys. 144, 174103 (2016).; (doi: 10.1063/1.4948318). Implementation of analytic gradients for the density-fitted; coupled-cluster singles and doubles with perturbative triples method. “Analytic energy gradients for the coupled-cluster singles and doubles; with perturbative triples method with the density-fitting approximation,”; U. Bozkaya and C. D. Sherrill, J. Chem. Phys. 147, 044104 (2017).; (doi: 10.1063/1.4994918). Mukherjee State-Specific Multi-Reference Coupled Cluster (Mk-MRCC)¶; PSI4 features production-level Mukherjee-style state-specific; coupled-cluster theory, including perturbative triples and also associated; multi-reference perturbation theories. The theory and PSI4; implementation of these methods is discussed in the following papers.; General Mk-MRCC. “Coupling Term Derivation and General Implementation of; State-Specific Multireference Coupled-Cluster Theories,”; F. A. Evangelista, W. D. Allen, and H. F. Schaefer,; J. Chem. Phys. 127, 024102 (2007).; (doi: 10.1063/1.2743014). Mk-MRCCSD(T). “Perturbative Triples Corrections in State-Specific Multireference; Coupled Cluster Theory,”; F. A. Evangelista, E. Prochnow, J. Gauss, and H. F. Schaefer,; J. Chem. Phys. 132, 074107 (2010).; (doi: 10.1063/1.3305335). Mk-MRCCSDT(-n).",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/introduction-1.html:8220,energy,energy,8220,psi4manual/1.2.1/introduction-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/introduction-1.html,13,['energy'],['energy']
Energy Efficiency," E. DePrince, T. D. Crawford, K. Patkowski, and C. D. Sherrill; J. Chem. Theory Comput. 14, 3504-3511 (2018). Schriber:2021:234107; J. B. Schriber, D. A. Sirianni, D. G. A. Smith, L. A. Burns, D. Sitkoff, D. L. Cheney, C. D. Sherrill; J. Chem. Phys. 154, 234107 (2021). Caldeweyher:2019:154122; “A generally applicable atomic-charge dependent London dispersion correction”,; E. Caldeweyher, S. Ehlert, A. Hansen, H. Neugebauer, S. Spicher, C. Bannwarth, and S. Grimme,; J. Chem. Phys. 150, 154122 (2019).; https://doi.org/10.1063/1.5090222. Haser:1989:104; M. Haser and R. Ahlrichs,; J. Comp. Chem. 10(1), 104 (1989).; doi: 10.1002/jcc.540100111. Thompson:2017:144101; T. H. Thompson and C. Ochsenfeld; J. Chem. Phys. 147, 144101 (2017).; doi: 10.1063/1.4994190. Smith:2020:184108; “PSI4 1.4: Open-source software for high-throughput quantum chemistry”,; D. G. A. Smith, L. A. Burns, A. C. Simmonett, R. M. Parrish, M. C. Schieber, R. Galvelis, P. Kraus, H. Kruse, R. Di Remigio, A. Alenaizan, A. M. James, S. Lehtola, J. P. Misiewicz, M. Scheurer, R. A. Shaw, J. B. Schriber, Y. Xie, Z. L. Glick, D. A. Sirianni, J. S. O’Brien, J. M. Waldrop, A. Kumar, E. G. Hohenstein, B. P. Pritchard, B. R. Brooks, H. F. Schaefer III, A. Yu. Sokolov, K. Patkowski, A. E. DePrince III, U. Bozkaya, R. King, F. A. Evangelista, J. M. Turney, T. D. Crawford, and C. D. Sherrill; J. Chem. Phys. 152, 184108 (2020).; doi: 10.1063/5.0006002. Waldrop:2021:024103; “Nonapproximated third-order exchange induction energy in symmetry-adapted perturbation theory”,; J. M. Waldrop and K. Patkowski; J. Chem. Phys. 154, 024103 (2021).; doi: 10.1063/1.4994190. Ochsenfeld:1998:1663; C. Ochsenfeld, C. A. White, M. Head-Gordon; J. Chem. Phys. 109, 1663 (1998); doi: 10.1063/1.476741. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Appendices; Bibliography. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/bibliography.html:14098,energy,energy,14098,psi4manual/1.6.x/bibliography.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/bibliography.html,2,"['adapt', 'energy']","['adapted', 'energy']"
Energy Efficiency," EA_POLES (OCC)¶OCC — Do compute OCC poles for electron affinities? Only valid for OMP2. Type: boolean; Default: false. EFP_DISP (EFP)¶EFP — Do include dispersion energy term in EFP computation?. Type: boolean; Default: true. EFP_DISP_DAMPING (EFP)¶EFP — Fragment-fragment dispersion damping type. TT is a damping formula by Tang and Toennies. OVERLAP is overlap-based dispersion damping. Type: string; Possible Values: TT, OVERLAP, OFF; Default: OVERLAP. EFP_ELST (EFP)¶EFP — Do include electrostatics energy term in EFP computation?. Type: boolean; Default: true. EFP_ELST_DAMPING (EFP)¶EFP — Fragment-fragment electrostatic damping type. SCREEN is a damping formula based on screen group in the EFP potential. OVERLAP is damping that computes charge penetration energy. Type: string; Possible Values: SCREEN, OVERLAP, OFF; Default: SCREEN. EFP_EXCH (EFP)¶EFP — Do include exchange repulsion energy term in EFP computation?. Type: boolean; Default: true. EFP_IND (EFP)¶EFP — Do include polarization energy term in EFP computation? (EFP_POL c. v1.1). Type: boolean; Default: true. EFP_IND_DAMPING (EFP)¶EFP — Fragment-fragment polarization damping type. TT is a damping formula like Tang and Toennies. (EFP_POL_DAMPING c. v1.1). Type: string; Possible Values: TT, OFF; Default: TT. EFP_QM_ELST (EFP)¶EFP — Do include electrostatics energy term in QM/EFP computation? (QMEFP_ELST c. v1.1). Type: boolean; Default: true. EFP_QM_IND (EFP)¶EFP — Do include polarization energy term in QM/EFP computation? (QMEFP_POL c. v1.1). Type: boolean; Default: true. EKT_EA (OCC)¶OCC — Do compute virtual orbital energies based on extended Koopmans’ theorem?. Type: boolean; Default: false. EKT_IP (DFOCC)¶DFOCC — Do compute ionization potentials based on the extended Koopmans’ theorem?. Type: boolean; Default: false. EKT_IP (OCC)¶OCC — Do compute occupied orbital energies based on extended Koopmans’ theorem?. Type: boolean; Default: false. ENERGY_LEVEL_SHIFT (DCT)¶DCT (Expert) — Level shift applied to the di",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:119950,energy,energy,119950,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,9,['energy'],['energy']
Energy Efficiency," EFP_IND_DAMPING (EFP)¶EFP — Fragment-fragment polarization damping type. TT is a damping formula like Tang and Toennies. (EFP_POL_DAMPING c. v1.1). Type: string; Possible Values: TT, OFF; Default: TT. EFP_QM_ELST (EFP)¶EFP — Do include electrostatics energy term in QM/EFP computation? (QMEFP_ELST c. v1.1). Type: boolean; Default: true. EFP_QM_IND (EFP)¶EFP — Do include polarization energy term in QM/EFP computation? (QMEFP_POL c. v1.1). Type: boolean; Default: true. EKT_EA (OCC)¶OCC — Do compute virtual orbital energies based on extended Koopmans’ theorem?. Type: boolean; Default: false. EKT_IP (DFOCC)¶DFOCC — Do compute ionization potentials based on the extended Koopmans’ theorem?. Type: boolean; Default: false. EKT_IP (OCC)¶OCC — Do compute occupied orbital energies based on extended Koopmans’ theorem?. Type: boolean; Default: false. ENERGY_LEVEL_SHIFT (DCT)¶DCT (Expert) — Level shift applied to the diagonal of the density-weighted Fock operator. While this shift can improve convergence, it does change the DCT energy. Type: double; Default: 0.0. ENSURE_BT_CONVERGENCE (OPTKING)¶OPTKING — Reduce step size as necessary to ensure back-transformation of internal coordinate step to cartesian coordinates. Type: boolean; Default: false. EOM_GUESS (CCEOM)¶CCEOM — Specifies a set of single-excitation guess vectors for the EOM-CC procedure. If EOM_GUESS = SINGLES, the guess will be taken from the singles-singles block of the similarity-transformed Hamiltonian, Hbar. If EOM_GUESS = DISK, guess vectors from a previous computation will be read from disk. If EOM_GUESS = INPUT, guess vectors will be specified in user input. The latter method is not currently available. Type: string; Possible Values: SINGLES, DISK, INPUT; Default: SINGLES. EOM_REFERENCE (CCEOM)¶CCEOM — Reference wavefunction type for EOM computations. Type: string; Possible Values: RHF, ROHF, UHF; Default: RHF. EOM_REFERENCE (CCHBAR)¶CCHBAR — Reference wavefunction type for EOM computations. Type: string; Default",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:121060,energy,energy,121060,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,9,['energy'],['energy']
Energy Efficiency," ENERGIES¶. MP2 ALPHA-BETA PAIR ENERGIES¶; Restricted-reference opposite-spin (alpha first) pair energies for coupled-cluster; theories. Size number of active doubly occupied orbitals, square. CC SINGLET PAIR ENERGIES¶. CCSD SINGLET PAIR ENERGIES¶. CC2 SINGLET PAIR ENERGIES¶. CC3 SINGLET PAIR ENERGIES¶. MP2 SINGLET PAIR ENERGIES¶; Restricted-reference singlet-adapted pair energies for coupled-cluster theories.; Size number of active doubly occupied orbitals, square. CC TRIPLET PAIR ENERGIES¶. CCSD TRIPLET PAIR ENERGIES¶. CC2 TRIPLET PAIR ENERGIES¶. CC3 TRIPLET PAIR ENERGIES¶. MP2 TRIPLET PAIR ENERGIES¶; Restricted-reference triplet-adapted pair energies for coupled-cluster theories.; Size number of active doubly occupied orbitals, square. CCSD TOTAL ENERGY¶. CCSD CORRELATION ENERGY¶. CCSDT TOTAL ENERGY¶. CCSDT CORRELATION ENERGY¶. CCSDTQ TOTAL ENERGY¶. CCSDTQ CORRELATION ENERGY¶. CCn TOTAL ENERGY¶. CCn CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the requested full coupled-cluster (CCSD, CCSDT, up to CCn); level of theory. CCSD(T) TOTAL ENERGY¶. CCSD(T) CORRELATION ENERGY¶. CCSD(AT) TOTAL ENERGY¶. CCSD(AT) CORRELATION ENERGY¶. A-CCSD(T) TOTAL ENERGY¶. A-CCSD(T) CORRELATION ENERGY¶. CCSDT(Q) TOTAL ENERGY¶. CCSDT(Q) CORRELATION ENERGY¶. CC(n-1)(n) TOTAL ENERGY¶. CC(n-1)(n) CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the perturbatively corrected coupled-cluster (CCSD(T), A-CCSD(T) = CCSD(AT), CCSDT(Q),; up to CC(n-1)(n) level of theory. CCSDT-1a TOTAL ENERGY¶. CCSDT-1a CORRELATION ENERGY¶. CCSDTQ-1a TOTAL ENERGY¶. CCSDTQ-1a CORRELATION ENERGY¶. CCn-1a TOTAL ENERGY¶. CCn-1a CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the approximate coupled-cluster (CCSD(T)-1a, CCSDT(Q)-1a,; up to CCn-1a) level of theory. CCSDT-1b TOTAL ENERGY¶. CCSDT-1b CORRELATION ENERGY¶. CCSDTQ-1b TOTAL ENERGY¶. CCSDTQ-1b CORRELATION ENERGY¶. CC",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/glossary_psivariables.html:18175,energy,energy,18175,psi4manual/1.6.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/glossary_psivariables.html,2,['energy'],['energy']
Energy Efficiency," ENERGY""); cemp4sdq = core.variable(""MP4(SDQ) CORRELATION ENERGY""); core.set_variable(""CURRENT ENERGY"", emp4sdq); core.set_variable(""CURRENT CORRELATION ENERGY"", cemp4sdq); elif name == 'fno-mp4(sdq)':; emp4sdq = core.variable(""MP4(SDQ) TOTAL ENERGY""); cemp4sdq = core.variable(""MP4(SDQ) CORRELATION ENERGY""); core.set_variable(""CURRENT ENERGY"", emp4sdq); core.set_variable(""CURRENT CORRELATION ENERGY"", cemp4sdq); elif name == 'fno-mp4':; emp4 = core.variable(""MP4 TOTAL ENERGY""); cemp4 = core.variable(""MP4 CORRELATION ENERGY""); core.set_variable(""CURRENT ENERGY"", emp4); core.set_variable(""CURRENT CORRELATION ENERGY"", cemp4); elif name == 'mp4':; emp4 = core.variable(""MP4 TOTAL ENERGY""); cemp4 = core.variable(""MP4 CORRELATION ENERGY""); core.set_variable(""CURRENT ENERGY"", emp4); core.set_variable(""CURRENT CORRELATION ENERGY"", cemp4). optstash.restore(); return fnocc_wfn. def run_cepa(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a cepa-like calculation. >>> energy('cepa(1)'). """"""; kwargs = p4util.kwargs_lower(kwargs). # save user options; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['FNOCC', 'NAT_ORBS'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'USE_DF_INTS'],; ['FNOCC', 'CEPA_NO_SINGLES']). core.set_local_option('FNOCC', 'RUN_CEPA', True); core.set_local_option('FNOCC', 'USE_DF_INTS', False). # what type of cepa?; if name in ['lccd', 'fno-lccd']:; cepa_level = 'cepa(0)'; core.set_local_option('FNOCC', 'CEPA_NO_SINGLES', True); elif name in ['cepa(0)', 'fno-cepa(0)', 'lccsd', 'fno-lccsd']:; cepa_level = 'cepa(0)'; core.set_local_option('FNOCC', 'CEPA_NO_SINGLES', False); elif name in ['cepa(1)', 'fno-cepa(1)']:; cepa_level = 'cepa(1)'; elif name in ['cepa(3)', 'fno-cepa(3)']:; cepa_level = 'cepa(3)'; elif name in ['acpf', 'fno-acpf']:; cepa_level = 'acpf'; elif name in ['aqcc', 'fno-aqcc']:; cepa_level = 'aqcc'; elif name in ['cisd', 'fno-cisd']:; cepa_level = 'cisd'; else:; raise ValidationError(""""""Error: %s not implemented\n"""""" % name). c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html:126005,energy,energy,126005,psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,1,['energy'],['energy']
Energy Efficiency," ENERGY'); rows.append((R, A)); table.append([escf, escsmp2, edfmp2]). import pandas as pd; df = pd.DataFrame(table, columns = [""E(SCF)"", ""E(SCS)"", ""E(DFMP2)""], index=rows); print(df). # E(SCF) E(SCS) E(DFMP2); # (0.9, 100) -76.020680 -76.217006 -76.221189; # (0.9, 102) -76.021305 -76.217439 -76.221605; # (1.0, 100) -76.021264 -76.224987 -76.228727; # (1.0, 102) -76.021460 -76.224946 -76.228668; # (1.1, 100) -75.990195 -76.201891 -76.205087; # (1.1, 102) -75.990085 -76.201498 -76.204676. Python Wrappers¶; The Python foundations of the PSI4 driver and Psithon syntax permit; many commonly performed post-processing procedures to be integrated into; the PSI4 suite.; As seen in the neon dimer example from the tutorial section,; the nbody() wrapper provides automatic computation of; counterpoise-corrected interaction energies between two molecules. For; example,. PSIthonPsiAPIenergy('mp2', bsse_type='cp'). psi4.energy('mp2', bsse_type='cp'). will compute the counterpoise-corrected density-fitted MP2 interaction energy; between two molecules.; PSI4 also provides the cbs() wrapper,; which automatically computes a complete-basis-set extrapolation (and; automatically sets up the computations with different basis sets required to; do the extrapolation). For example,. PSIthonPsiAPI# all equivalent. energy('mp2', corl_basis='cc-pv[dt]z', corl_scheme='corl_xtpl_helgaker_2'). energy('mp2/cc-pv[dt]z'). # all equivalent. psi4.energy('mp2', corl_basis='cc-pv[dt]z', corl_scheme='corl_xtpl_helgaker_2'). psi4.energy('mp2/cc-pv[dt]z'). will compute a 2-point Helgaker extrapolation of the correlation energy; using the cc-pVDZ and cc-pVTZ basis sets (with method MP2) and add this; extrapolated correlation energy to the Hartree–Fock energy in the; largest basis (cc-pVTZ). cbs() can; be configured behind-the-scenes with explicit arguments, as in the; first example, or the convenience syntax of the equivalent second; example can be used.; Another very useful and powerful feature of PSI4 is th",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/psithoninput.html:16466,energy,energy,16466,psi4manual/master/psithoninput.html,https://psicode.org,https://psicode.org/psi4manual/master/psithoninput.html,1,['energy'],['energy']
Energy Efficiency," ENERGY. EFP TORQUE. EFP TOTAL ENERGY. EFP_DISP (EFP). EFP_DISP_DAMPING (EFP). EFP_ELST (EFP). EFP_ELST_DAMPING (EFP). EFP_EXCH (EFP). EFP_IND (EFP). EFP_IND_DAMPING (EFP). EFP_QM_ELST (EFP). EFP_QM_IND (EFP). efzc() psi4.core.Wavefunction method. EKT_EA (OCC). EKT_IP (DFOCC). (OCC). electric_field() psi4.core.IntegralFactory method. psi4.core.MintsHelper method. electric_field_value() psi4.core.MintsHelper method. ElectricFieldInt class in psi4.core. electrostatic() psi4.core.IntegralFactory method. electrostatic_potential_value() psi4.core.MintsHelper method. ElectrostaticInt class in psi4.core. elevation psi4.driver.p4util.InPsight attribute. elst() psi4.core.FISAPT method. embedding_charges psi4.driver.driver_nbody.ManyBodyComputer attribute. EmpiricalDispersion class in psi4.driver. class in psi4.driver.procrouting.empirical_dispersion. end() psi4.core.Slice method. energies_from_fcidump() in module psi4.driver. in module psi4.driver.p4util. energy(). setting keywords. energy() in module psi4.driver. psi4.core.Wavefunction method. ENERGY_LEVEL_SHIFT (DCT). engine psi4.driver.EmpiricalDispersion attribute. psi4.driver.procrouting.empirical_dispersion.EmpiricalDispersion attribute. ENSURE_BT_CONVERGENCE (OPTKING). ENTHALPY. ENTHALPY CORRECTION. environment variable. ; BRIANQC_ENABLE, [1]. BRIANQC_INSTALL_PATH, [1], [2]. BRIANQC_SDK_INSTALL, [1]. CONDA_PREFIX, [1], [2]. CRAY_ADD_RPATH. CRAYPE_LINK_TYPE. HOST, [1], [2]. MATH_ROOT. MKL_NUM_THREADS, [1]. MKL_ROOT. MONTAGE, [1]. OMP_NESTED, [1], [2]. OMP_NUM_THREADS, [1], [2], [3], [4], [5], [6], [7], [8], [9]. PATH, [1], [2], [3], [4], [5], [6], [7], [8], [9], [10], [11], [12], [13], [14], [15], [16], [17], [18], [19], [20], [21], [22], [23], [24], [25], [26], [27], [28], [29], [30], [31], [32], [33]. PSI_SCRATCH, [1], [2], [3], [4], [5], [6], [7], [8], [9], [10], [11], [12]. PSIDATADIR, [1], [2], [3], [4], [5], [6], [7], [8], [9]. PSIPATH, [1], [2], [3], [4], [5], [6], [7], [8], [9], [10], [11], [12], [13], [14], [15",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/genindex.html:45578,energy,energy,45578,psi4manual/1.7.x/genindex.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/genindex.html,2,['energy'],['energy']
Energy Efficiency, ENERGY¶. BBB (T) CORRECTION ENERGY¶; Components of the coupled-cluster perturbative triples correction [H]. BRUECKNER CONVERGED¶; Value 1 (0) when the Brueckner orbitals have (have not) converged. CBS TOTAL ENERGY¶. CBS CORRELATION ENERGY¶. CBS REFERENCE ENERGY¶; The total electronic energy [H] and its breakdown into reference total; energy [H] and correlation correction components [H] for the compound; method requested through cbs(). CC ROOT n TOTAL ENERGY¶; The total electronic energy [H]; for the requested coupled cluster level of theory and root; n (numbering starts at GS = 0). CC TOTAL ENERGY¶. CC CORRELATION ENERGY¶. CC2 TOTAL ENERGY¶. CC2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the CC2 level of theory. CC3 TOTAL ENERGY¶. CC3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the CC3 level of theory. CCSD TOTAL ENERGY¶. CCSD CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the CCSD level of theory. CCSD(T) TOTAL ENERGY¶. CCSD(T) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the CCSD(T) level of theory. CI DIPOLE X¶. CI DIPOLE Y¶. CI DIPOLE Z¶; The three components of the dipole [Debye] for the requested; configuration interaction level of theory and root. CI QUADRUPOLE XX¶. CI QUADRUPOLE XY¶. CI QUADRUPOLE XZ¶. CI QUADRUPOLE YY¶. CI QUADRUPOLE YZ¶. CI QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; configuration interaction level of theory and root. CI ROOT n -> ROOT m DIPOLE X¶. CI ROOT n -> ROOT m DIPOLE Y¶. CI ROOT n -> ROOT m DIPOLE Z¶; The three components of the transition dipole [Debye] between roots n; and m for the requested configuration interaction level of theory. CI ROOT n -> ROOT m QUADRUPOLE XX¶. CI ROOT n -> ROOT m QUADRUPOLE XY¶. CI ROOT n -> ROOT m QUADRUPOLE XZ¶. CI ROOT n -> ROOT m QUADRUPOLE YY¶. CI ROOT n -> ROO,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/glossary_psivariables-1.html:1473,energy,energy,1473,psi4manual/4.0b2/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/glossary_psivariables-1.html,4,['energy'],['energy']
Energy Efficiency," ENERGY¶. CC CORRELATION ENERGY¶. CC CORRELATION KINETIC ENERGY¶; The correlation correction to the kinetic energy [E_h], as computed by a coupled cluster method. CC CORRELATION POTENTIAL ENERGY¶; The correlation correction to the potential energy [E_h], as computed by a coupled cluster method. CC CORRELATION VIRIAL RATIO¶; The correlation virial ratio, as defined in https://doi/org/10.1063/1.1535440 for basis set completeness analysis. Computed using coupled cluster. CC VIRIAL RATIO¶; The virial ratio, as computed by a coupled cluster method. Only defined for a fully quantum mechanical computation, i.e., not QM/MM or solvated. CC T1 DIAGNOSTIC¶. CC D1 DIAGNOSTIC¶. CC NEW D1 DIAGNOSTIC¶. CC D2 DIAGNOSTIC¶; Diagnostic of multireference character. CC2 TOTAL ENERGY¶. CC2 CORRELATION ENERGY¶. CC3 TOTAL ENERGY¶. CC3 CORRELATION ENERGY¶. CC4 TOTAL ENERGY¶. CC4 CORRELATION ENERGY¶. CCnn TOTAL ENERGY¶. CCnn CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the requested approximate coupled-cluster (CC2, CC3, up to CCnn); level of theory. CC DIPOLE¶; Dipole array [e a0] for the requested coupled cluster level of theory and root, (3,). CC2 DIPOLE POLARIZABILITY @ xNM¶. CCSD DIPOLE POLARIZABILITY @ xNM¶; The dipole polarizability in atomic units [(e^2 a0^2)/E_h] calculated at; the CC level for a given (x) wavelength, (x) rounded to nearest integer. CC2 DIPOLE POLARIZABILITY TENSOR @ xNM¶. CCSD DIPOLE POLARIZABILITY TENSOR @ xNM¶; The dipole polarizability tensor in atomic units [(e^2 a0^2)/E_h] calculated at; the CC level for a given (x) wavelength, (x) rounded to nearest integer. CC2 QUADRUPOLE POLARIZABILITY @ xNM¶. CCSD QUADRUPOLE POLARIZABILITY @ xNM¶; The quadrupole polarizability in atomic units [(e^2 a0^3)/E_h] calculated at; the CC level for a given (x) wavelength, (x) rounded to nearest integer. CC2 QUADRUPOLE POLARIZABILITY TENSOR @ xNM¶. CCSD QUADRUPOLE POLARIZABILITY TENSOR @ xNM¶; The quadrupole polarizability in ato",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html:14762,energy,energy,14762,psi4manual/1.7.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html,8,['energy'],['energy']
Energy Efficiency," ENERGY¶. LCCSD CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the linearized coupled cluster singles and doubles level of theory. LCC2 (+LMP2) TOTAL ENERGY¶; The total electronic energy [Eh] for the local CC2 level of theory. LCCSD (+LMP2) TOTAL ENERGY¶; The total electronic energy [Eh] for the local CCSD level of theory. LEFT-RIGHT CC2 EIGENVECTOR OVERLAP¶. LEFT-RIGHT CC3 EIGENVECTOR OVERLAP¶. LEFT-RIGHT CCSD EIGENVECTOR OVERLAP¶. LEFT-RIGHT CCSD(T) EIGENVECTOR OVERLAP¶; The overlap between the right-hand coupled coupled cluster eigenvector and the; left-hand eigenvector from the coupled cluster lambda (response) equations. LOWDIN CHARGES¶; Property of partial atomic charges [e] by the method of Löwdin, (nat,). MAYER INDICES¶; Property of Mayer bond indices, (nat, nat). MBIS CHARGES¶. MBIS DIPOLES¶. MBIS OCTUPOLES¶. MBIS QUADRUPOLES¶; Per-atom charges [e], dipoles [e a0], quadrupoles [e a0^2], and octupoles [e a0^3]; resulting from partitioning the total electron density through the Minimal Basis; Iterative Stockholder (MBIS) Charge Partitioning Scheme. MBIS FREE ATOM n VOLUME¶; Free-atom volume [a0^3] for atom n, computed using the MBIS charge; partitioning scheme. Free atom densities are computed at the same; level of theory as the parent MBIS calculation, with UHF turned on; as needed. MBIS RADIAL MOMENTS <R^3>¶; Per-atom expectation value of r^3 [a0^3], equivalent to the volume; of the MBIS-partitioned density. MBIS VALENCE WIDTHS¶; Per-atom density width [a0] of the associated valence charge computed; from an MBIS partitioned density. Equivalent to the inverse of the; linear decay rate of the atomic density. MBIS VOLUME RATIOS¶; Per-atom ratio between the atomic volume (<R^3>) and the free-atomic; volume, unitless. MCSCF TOTAL ENERGY¶; Multiconfigurational self-consistent-field energy [Eh] in the course of; a configuration interaction computation. May be single-root or state-averaged. mtd DIPOLE¶; Dipole array",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/glossary_psivariables.html:33467,charge,charges,33467,psi4manual/1.6.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/glossary_psivariables.html,1,['charge'],['charges']
Energy Efficiency," ENERGY¶. OLCCD OPPOSITE-SPIN CORRELATION ENERGY¶; The unscaled portion [E_h] of the named correlation energy; from opposite-spin or singlet doubles correlations. MRPT TOTAL ENERGY¶. MP2-CCSD TOTAL ENERGY¶. MRCC TOTAL ENERGY¶; Energies [E_h] from correlated multi-reference theories. MULLIKEN CHARGES¶; Property of partial atomic charges [e] by the method of Mulliken, (nat,). NAUX (SCF)¶. NAUX (CC)¶; Convenience storage of number of functions [] in the auxiliary basis; set for named stage of the calculation. NBODY (i, j, ..., k)@(a, b, ..., c) TOTAL ENERGY¶; The total energy [E_h] of a component of the requested N-Body energy.; The first parenthetical list over i, j, …, k enumerates; molecular fragments included in the computation in 1-indexed,; input-file order, while the second enumerates list over a, b,; …, c enumerates which fragments contribute basis functions to the; computation. For example, (1, 2)@(1, 2, 3, 4) indicates that the; fragments 1 and 2 are explicitly included in the energy computation,; with basis functions from each of fragments 1, 2, 3, & 4 included in; the basis set. Therefore, the basis functions from fragments 3 and 4; are included as ghost functions within the energy computation. NUCLEAR REPULSION ENERGY¶; The nuclear repulsion energy contribution [E_h] to the total SCF energy.; Quantity \(E_{NN}\) in Eq. (4). (3)¶\[E_{NN} = \sum_{i, j<i}^{N_{atom}}\frac{Z_i Z_j}{|\mathbf{R}_i - \mathbf{R}_j|}\]. OCEPA(0) TOTAL ENERGY¶. OCEPA(0) CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the orbital-optimized CEPA(0) level of theory. OLCCD TOTAL ENERGY¶. OLCCD CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the orbital-optimized linearized coupled cluster doubles level of theory. OLCCD REFERENCE CORRECTION ENERGY¶; The difference [E_h] between the single-determinant energy of the final and; initial orbitals for the orbital-optimized linearized coupled cl",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html:41429,energy,energy,41429,psi4manual/1.7.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html,4,['energy'],['energy']
Energy Efficiency," ENERGY¶. SAPT2+3(CCD)DMP2 EXCH ENERGY¶. SAPT2+3(CCD)DMP2 IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [E_h] for the; given SAPT level of theory that incorporates MP2 induction correction.; The sum of these four components yields the SAPT Level TOTAL ENERGY. SAPT2+DMP2 TOTAL ENERGY¶. SAPT2+(3)DMP2 TOTAL ENERGY¶. SAPT2+3DMP2 TOTAL ENERGY¶. SAPT2+(CCD)DMP2 TOTAL ENERGY¶. SAPT2+(3)(CCD)DMP2 TOTAL ENERGY¶. SAPT2+3(CCD)DMP2 TOTAL ENERGY¶; The total electronic interaction energy [E_h] for the labeled SAPT level; of theory that incorporates MP2 induction correction. SCF ITERATIONS¶. ADC ITERATIONS¶. CCSD ITERATIONS¶. OPTIMIZATION ITERATIONS¶; Number of iterations [] in the named iterative method or optimization procedure. SCF DIPOLE¶; Dipole array [e a0] for the SCF stage, (3,). SCF QUADRUPOLE¶; Redundant quadrupole array [e a0^2] for the SCF stage, (3, 3). SCF TOTAL ENERGY¶; The total electronic energy [E_h] of the SCF stage of the calculation.; The method CORRELATION ENERGY variables from subsequent stages of a; calculation are often the corresponding method TOTAL ENERGY; variables less this quantity. Constructed from Eq. (4),; where this quantity is \(E_{\text{SCF}}\). \begin{align*}; E_{\text{SCF}} & = E_{NN} + E_{1e^-} + E_{2e^-} + E_{xc} + E_{\text{-D}} \\; & = E_{\text{FCTL/HF}} + E_{\text{-D}}; \end{align*}Unless the method includes a dispersion correction, this quantity is; equal to HF TOTAL ENERGY (for HF) or; DFT FUNCTIONAL TOTAL ENERGY (for; DFT). Unless the method is a DFT double-hybrid, this quantity is equal; to DFT TOTAL ENERGY. SCF TOTAL GRADIENT¶; The total electronic gradient [E_h/a0] of the SCF stage of the calculation, ({nat}, 3). SCF DIPOLE GRADIENT¶; The derivative of the SCF stage dipole [E_h a0/u] = [(e a0/a0)^2/u] with respect to nuclear perturbations; as a degree-of-freedom by dipole component array, (3 * {nat}, 3). SCF TOTAL HESSIAN¶; The total electroni",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html:53088,energy,energy,53088,psi4manual/1.7.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html,4,['energy'],['energy']
Energy Efficiency," ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [Eh] for the; requested SAPT level of theory. The sum of these four components yields; SAPT TOTAL ENERGY. SAPT TOTAL ENERGY¶. SAPT ENERGY¶; The total electronic interaction energy [Eh] for the requested SAPT; level of theory. SAPT ELST10,R ENERGY¶; An electrostatics-classified SAPT term energy [Eh] implemented for SAPT0. SAPT ELST EXTERN-EXTERN ENERGY¶; Electrostatic interaction [Eh] between the point charges in fragments; A and B in F/I-SAPT. SAPT EXCH10 ENERGY¶; An exchange-classified SAPT term energy [Eh] implemented for SAPT0. SAPT EXCH10(S^2) ENERGY¶; An exchange-classified SAPT term energy [Eh] implemented for SAPT0. SAPT IND20,R ENERGY¶. SAPT EXCH-IND20,R ENERGY¶. SAPT IND20,U ENERGY¶. SAPT EXCH-IND20,U ENERGY¶; An induction-classified SAPT term energy [Eh] implemented for SAPT0. SAPT DISP20 ENERGY¶. SAPT EXCH-DISP20 ENERGY¶; A dispersion-classified SAPT term energy [Eh] implemented for SAPT0. SAPT EXCH-DISP20(S^INF) ENERGY¶; A dispersion-classified SAPT term energy [Eh] implemented for SAPT0. See Higher-Order Exchange Terms without Single-Exchange Approximation. SAPT SAME-SPIN DISP20 ENERGY¶. SAPT SAME-SPIN EXCH-DISP20 ENERGY¶; The portion of SAPT DISP20 ENERGY or; SAPT EXCH-DISP20 ENERGY resulting from; from same-spin or triplet doubles correlations. SAPT HF(2) ENERGY ABC(HF)¶; The total Hartree–Fock energy [Eh] of the supersystem implemented for F/I-SAPT. SAPT HF(2) ENERGY AC(0)¶; The Hartree–Fock energy [Eh] of subsystems A and C implemented for F/I-SAPT. SAPT HF(2) ENERGY BC(0)¶; The Hartree–Fock energy [Eh] of subsystems B and C implemented for F/I-SAPT. SAPT HF(2) ENERGY A(0)¶; The Hartree–Fock energy [Eh] of subsystem A implemented for F/I-SAPT. SAPT HF(2) ENERGY B(0)¶; The Hartree–Fock energy [Eh] of subsystem B implemented for F/I-SAPT. SAPT HF(2) ENERGY AC(HF)¶; The Hartree–Fock localized energy [Eh] of subsystems A ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/glossary_psivariables.html:43468,energy,energy,43468,psi4manual/1.6.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/glossary_psivariables.html,1,['energy'],['energy']
Energy Efficiency," ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [Eh] for the; requested SAPT level of theory. The sum of these four components yields; SAPT TOTAL ENERGY. SAPT TOTAL ENERGY¶. SAPT ENERGY¶; The total electronic interaction energy [Eh] for the requested SAPT; level of theory. SAPT ELST10,R ENERGY¶; An electrostatics-classified SAPT term energy [Eh] implemented for SAPT0. SAPT ELST EXTERN-EXTERN ENERGY¶; Electrostatic interaction [Eh] between the point charges in fragments; A and B in F/I-SAPT. SAPT EXCH10 ENERGY¶; An exchange-classified SAPT term energy [Eh] implemented for SAPT0. SAPT EXCH10(S^2) ENERGY¶; An exchange-classified SAPT term energy [Eh] implemented for SAPT0. SAPT IND20,R ENERGY¶. SAPT EXCH-IND20,R ENERGY¶. SAPT IND20,U ENERGY¶. SAPT EXCH-IND20,U ENERGY¶; An induction-classified SAPT term energy [Eh] implemented for SAPT0. SAPT DISP20 ENERGY¶. SAPT EXCH-DISP20 ENERGY¶; A dispersion-classified SAPT term energy [Eh] implemented for SAPT0. SAPT EXCH-DISP20(S^INF) ENERGY¶; A dispersion-classified SAPT term energy [Eh] implemented for SAPT0. See Second-Order Exchange Terms without Single-Exchange Approximation. SAPT SAME-SPIN DISP20 ENERGY¶. SAPT SAME-SPIN EXCH-DISP20 ENERGY¶; The portion of SAPT DISP20 ENERGY or; SAPT EXCH-DISP20 ENERGY resulting from; from same-spin or triplet doubles correlations. SAPT HF(2) ENERGY ABC(HF)¶; The total Hartree–Fock energy [Eh] of the supersystem implemented for F/I-SAPT. SAPT HF(2) ENERGY AC(0)¶; The Hartree–Fock energy [Eh] of subsystems A and C implemented for F/I-SAPT. SAPT HF(2) ENERGY BC(0)¶; The Hartree–Fock energy [Eh] of subsystems B and C implemented for F/I-SAPT. SAPT HF(2) ENERGY A(0)¶; The Hartree–Fock energy [Eh] of subsystem A implemented for F/I-SAPT. SAPT HF(2) ENERGY B(0)¶; The Hartree–Fock energy [Eh] of subsystem B implemented for F/I-SAPT. SAPT HF(2) ENERGY AC(HF)¶; The Hartree–Fock localized energy [Eh] of subsystems A ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html:35950,energy,energy,35950,psi4manual/1.4.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html,4,['energy'],['energy']
Energy Efficiency," ENERGY¶; The one-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (3). SAPT DISP ENERGY¶. SAPT ELST ENERGY¶. SAPT EXCH ENERGY¶. SAPT IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [H] for the the; requested SAPT level of theory. The sum of these four components yields; SAPT ENERGY. SAPT ENERGY¶; The total electronic interaction energy [H] for the requested SAPT; level of theory. SAPT SAPT0 ENERGY¶. SAPT SAPT2 ENERGY¶. SAPT SAPT2+ ENERGY¶. SAPT SAPT2+(3) ENERGY¶. SAPT SAPT2+3 ENERGY¶; The total electronic interaction energy [H] for the labeled SAPT level; of theory. SCF DIPOLE X¶. SCF DIPOLE Y¶. SCF DIPOLE Z¶; The three components of the SCF dipole [Debye]. SCF QUADRUPOLE XX¶. SCF QUADRUPOLE XY¶. SCF QUADRUPOLE XZ¶. SCF QUADRUPOLE YY¶. SCF QUADRUPOLE YZ¶. SCF QUADRUPOLE ZZ¶; The six components of the SCF quadrupole [Debye Ang]. SCF TOTAL ENERGY¶; The total electronic energy [H] of the SCF stage of the calculation.; The CORRELATION ENERGY variables from subsequent stages of a; calculation are often the corresponding TOTAL ENERGY; variables less this quantity. Constructed from Eq. (3),; where this quantity is . (3); Unless the method includes a dispersion correction, this quantity is; equal to HF TOTAL ENERGY (for HF) or; DFT FUNCTIONAL TOTAL ENERGY (for; DFT). Unless the method is a DFT double-hybrid, this quantity is equal; to DFT TOTAL ENERGY. TWO-ELECTRON ENERGY¶; The two-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (3). UNCP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [H] considering only two-body interactions,; computed without counterpoise correction.; Related variable CP-CORRECTED 2-BODY INTERACTION ENERGY. ZAPTn TOTAL ENERGY¶. ZAPTn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Z-averaged perturbation theory level.; n is ZAPT perturbation",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:13566,energy,energy,13566,psi4manual/4.0b3/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html,2,['energy'],['energy']
Energy Efficiency," ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the approximate coupled-cluster (CCSD(T)-1b, CCSDT(Q)-1b,; up to CCn-1b) level of theory. CCSDT-3 TOTAL ENERGY¶. CCSDT-3 CORRELATION ENERGY¶. CCSDTQ-3 TOTAL ENERGY¶. CCSDTQ-3 CORRELATION ENERGY¶. CCn-3 TOTAL ENERGY¶. CCn-3 CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the approximate coupled-cluster (CCSD(T)-3, CCSDT(Q)-3,; up to CCn-3) level of theory. CCSD(T)_L TOTAL ENERGY¶. CCSD(T)_L CORRELATION ENERGY¶. CCSDT(Q)_L TOTAL ENERGY¶. CCSDT(Q)_L CORRELATION ENERGY¶. CC(n-1)(n)_L TOTAL ENERGY¶. CC(n-1)(n)_L CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the approximate coupled-cluster (CCSD(T)_L, CCSDT(Q)_L,; up to CC(n-1)(n)L level of theory. CCSDT(Q)/A TOTAL ENERGY¶. CCSDT(Q)/A CORRELATION ENERGY¶. CCSDT(Q)/B TOTAL ENERGY¶. CCSDT(Q)/B CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the modified CCSDT(Q) level of theory. CEPA(0) DIPOLE¶; Dipole array [e a0] for the coupled electron pair approximation variant 0 level of theory, (3,). CEPA(0) QUADRUPOLE¶; Redundant quadrupole array [e a0^2] for the coupled electron pair approximation variant 0 level of theory, (3, 3). CEPA(0) TOTAL ENERGY¶. CEPA(0) CORRELATION ENERGY¶. CEPA(1) TOTAL ENERGY¶. CEPA(1) CORRELATION ENERGY¶. CEPA(2) TOTAL ENERGY¶. CEPA(2) CORRELATION ENERGY¶. CEPA(3) TOTAL ENERGY¶. CEPA(3) CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the requested variant of coupled electron pair approximation level of theory. CFOUR ERROR CODE¶; The non-zero return value from a Cfour execution. CI DIPOLE¶; Dipole array [e a0] for the requested configuration interaction level of theory, (3,). CI QUADRUPOLE¶; Redundant quadrupole array [e a0^2] for the requested configuration interaction level of theory, (3, 3). CI ROOT n -> ROOT m DI",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html:20451,energy,energy,20451,psi4manual/1.7.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html,8,['energy'],['energy']
Energy Efficiency," ENERGY¶; The total electronic energy [E_h] for the requested theory and root n within irrep h (n starts at 0).; DFT functional labeled if canonical. CCname ROOT n (h) TOTAL ENERGY¶. TD-fctl ROOT n (h) TOTAL ENERGY¶; The total electronic energy [E_h] for the requested theory and root n, which is of irrep h (n starts at 0).; DFT functional labeled if canonical. CCname ROOT n TOTAL ENERGY - h TRANSITION¶. TD-fctl ROOT n TOTAL ENERGY - h TRANSITION¶; The total electronic energy [E_h] for the requested theory and root n, and the transition is of irrep h, (n starts at 0). CCname ROOT n CORRELATION ENERGY¶; The correlation energy [E_h] for the requested coupled cluster level of theory and root n (n starts at 0).; DFT functional labeled if canonical. CCname ROOT n (IN h) CORRELATION ENERGY¶; The correlation energy [E_h] for the requested coupled cluster level of theory and root n within irrep h (n starts at 0). CCname ROOT n (h) CORRELATION ENERGY¶; The correlation energy [E_h] for the requested coupled cluster level of theory and root n, which is of irrep h (n starts at 0). CCname ROOT n CORRELATION ENERGY - h TRANSITION¶; The correlation energy [E_h] for the requested coupled cluster level of theory and root n, and the transition is of irrep h, (n starts at 0). CCname ROOT n DIPOLE¶; Dipole array [e a0] for the requested coupled cluster level of theory and root n (n starts at 0), (3,). CCname ROOT n (IN h) DIPOLE¶; Dipole array [e a0] for the requested coupled cluster level of theory and root n within irrep h (n starts at 0), (3,). CCname ROOT n (h) DIPOLE¶; Dipole array [e a0] for the requested coupled cluster level of theory and root n, which is of irrep h (n starts at 0), (3,). CCname ROOT n DIPOLE - h TRANSITION¶; Dipole array [e a0] for the requested coupled cluster level of theory and root n, and the transition is of irrep h, (n starts at 0), (3,). CCname ROOT n QUADRUPOLE¶; Redundant quadrupole array [e a0^2] for the requested coupled cluster level of theory and ro",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html:9314,energy,energy,9314,psi4manual/1.7.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html,4,['energy'],['energy']
Energy Efficiency," ERGT[rgt] = 0.0; for envv in db_tabulate:; VRGT[rgt][envv.upper()] = 0.0; exec(banners); exec(actives); try:; freagent = open('%s.out' % (rgt), 'r'); except IOError:; core.print_out('Warning: Output file \'%s.out\' not found.\n' % (rgt)); core.print_out(' Database summary will have 0.0 and **** in its place.\n'); else:; while 1:; line = freagent.readline(); if not line:; if ERGT[rgt] == 0.0:; core.print_out('Warning: Output file \'%s.out\' has no DATABASE RESULT line.\n' % (rgt)); core.print_out(' Database summary will have 0.0 and **** in its place.\n'); break; s = line.split(); if (len(s) != 0) and (s[0:3] == ['DATABASE', 'RESULT:', 'computation']):; if int(s[3]) != db_linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (rgt, str(s[3]), str(db_linkage))); if s[6] != rgt:; raise ValidationError('Output file \'%s.out\' has nominal affiliation %s incompatible with reagent %s.'; % (rgt, s[6], rgt)); if (s[8:10] == ['electronic', 'energy']):; ERGT[rgt] = float(s[10]); core.print_out('DATABASE RESULT: electronic energy = %20.12f\n' % (ERGT[rgt])); elif (s[8:10] == ['variable', 'value']):; for envv in db_tabulate:; envv = envv.upper(); if (s[13:] == envv.split()):; VRGT[rgt][envv] = float(s[10]); core.print_out('DATABASE RESULT: variable %s value = %20.12f\n' % (envv, VRGT[rgt][envv])); freagent.close(). # end sow after writing files; if db_mode == 'sow':; return 0.0. # Reap all the necessary reaction computations; core.print_out(""\n""); p4util.banner((""Database %s Results"" % (db_name))); core.print_out(""\n""). maxactv = []; for rxn in HRXN:; maxactv.append(len(ACTV[dbse + '-' + str(rxn)])); maxrgt = max(maxactv); table_delimit = '-' * (62 + 20 * maxrgt); tables = ''. # find any reactions that are incomplete; FAIL = collections.defaultdict(int); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); for i in range(len(ACTV[db_rxn])):; if abs(ERGT[ACTV[db_rxn][i]]) < 1.0e-12:; FAIL[rxn] = 1. # tabulate requested pro",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/wrapper_database.html:23878,energy,energy,23878,psi4manual/1.1.0/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/wrapper_database.html,1,['energy'],['energy']
Energy Efficiency," ERGT[rgt] = 0.0; for envv in db_tabulate:; VRGT[rgt][envv.upper()] = 0.0; exec(banners); exec(actives); try:; freagent = open('%s.out' % (rgt), 'r'); except IOError:; core.print_out('Warning: Output file \'%s.out\' not found.\n' % (rgt)); core.print_out(' Database summary will have 0.0 and **** in its place.\n'); else:; while 1:; line = freagent.readline(); if not line:; if ERGT[rgt] == 0.0:; core.print_out('Warning: Output file \'%s.out\' has no DATABASE RESULT line.\n' % (rgt)); core.print_out(' Database summary will have 0.0 and **** in its place.\n'); break; s = line.split(); if (len(s) != 0) and (s[0:3] == ['DATABASE', 'RESULT:', 'computation']):; if int(s[3]) != db_linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (rgt, str(s[3]), str(db_linkage))); if s[6] != rgt:; raise ValidationError('Output file \'%s.out\' has nominal affiliation %s incompatible with reagent %s.'; % (rgt, s[6], rgt)); if (s[8:10] == ['electronic', 'energy']):; ERGT[rgt] = float(s[10]); core.print_out('DATABASE RESULT: electronic energy = %20.12f\n' % (ERGT[rgt])); elif (s[8:10] == ['variable', 'value']):; for envv in db_tabulate:; envv = envv.upper(); if (s[13:] == envv.split()):; VRGT[rgt][envv] = float(s[10]); core.print_out('DATABASE RESULT: variable %s value = %20.12f\n' % (envv, VRGT[rgt][envv])); freagent.close(). # end sow after writing files; if db_mode == 'sow':; return 0.0. # Reap all the necessary reaction computations; core.print_out(""\n""); p4util.banner((""Database %s Results"" % (db_name))); core.print_out(""\n""). maxactv = []; for rxn in HRXN:; maxactv.append(len(ACTV[dbse + '-' + str(rxn)])); maxrgt = max(maxactv); table_delimit = '-' * (62 + 20 * maxrgt); tables = ''. # find any reactions that are incomplete; FAIL = collections.defaultdict(int); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); for i in range(len(ACTV[db_rxn])):; if abs(ERGT[ACTV[db_rxn][i]]) < 1.0e-12:; if not allowoptexceeded:; FAIL[rxn] = 1",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html:23785,energy,energy,23785,psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html,2,['energy'],['energy']
Energy Efficiency," ERGT[rgt] = 0.0; for envv in db_tabulate:; VRGT[rgt][envv.upper()] = 0.0; exec(banners); exec(actives); try:; freagent = open('%s.out' % (rgt), 'r'); except IOError:; psi4.print_out('Warning: Output file \'%s.out\' not found.\n' % (rgt)); psi4.print_out(' Database summary will have 0.0 and **** in its place.\n'); else:; while 1:; line = freagent.readline(); if not line:; if ERGT[rgt] == 0.0:; psi4.print_out('Warning: Output file \'%s.out\' has no DATABASE RESULT line.\n' % (rgt)); psi4.print_out(' Database summary will have 0.0 and **** in its place.\n'); break; s = line.split(); if (len(s) != 0) and (s[0:3] == ['DATABASE', 'RESULT:', 'computation']):; if int(s[3]) != db_linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (rgt, str(s[3]), str(db_linkage))); if s[6] != rgt:; raise ValidationError('Output file \'%s.out\' has nominal affiliation %s incompatible with reagent %s.'; % (rgt, s[6], rgt)); if (s[8:10] == ['electronic', 'energy']):; ERGT[rgt] = float(s[10]); psi4.print_out('DATABASE RESULT: electronic energy = %20.12f\n' % (ERGT[rgt])); elif (s[8:10] == ['variable', 'value']):; for envv in db_tabulate:; envv = envv.upper(); if (s[13:] == envv.split()):; VRGT[rgt][envv] = float(s[10]); psi4.print_out('DATABASE RESULT: variable %s value = %20.12f\n' % (envv, VRGT[rgt][envv])); freagent.close(). # end sow after writing files; if (db_mode.lower() == 'sow'):; return 0.0. # Reap all the necessary reaction computations; psi4.print_out(""\n""); p4util.banner((""Database %s Results"" % (db_name))); psi4.print_out(""\n""). maxactv = []; for rxn in HRXN:; maxactv.append(len(ACTV[dbse + '-' + str(rxn)])); maxrgt = max(maxactv); table_delimit = '-' * (54 + 20 * maxrgt); tables = ''. # find any reactions that are incomplete; FAIL = collections.defaultdict(int); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); for i in range(len(ACTV[db_rxn])):; if abs(ERGT[ACTV[db_rxn][i]]) < 1.0e-12:; FAIL[rxn] = 1. # tabulate req",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:46883,energy,energy,46883,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,1,['energy'],['energy']
Energy Efficiency," ERGT[rgt] = 0.0; for envv in db_tabulate:; VRGT[rgt][envv.upper()] = 0.0; exec(banners); exec(actives); try:; freagent = open('%s.out' % (rgt), 'r'); except IOError:; psi4.print_out('Warning: Output file \'%s.out\' not found.\n' % (rgt)); psi4.print_out(' Database summary will have 0.0 and **** in its place.\n'); else:; while 1:; line = freagent.readline(); if not line:; if ERGT[rgt] == 0.0:; psi4.print_out('Warning: Output file \'%s.out\' has no DATABASE RESULT line.\n' % (rgt)); psi4.print_out(' Database summary will have 0.0 and **** in its place.\n'); break; s = line.split(); if (len(s) != 0) and (s[0:3] == ['DATABASE', 'RESULT:', 'computation']):; if int(s[3]) != db_linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (rgt, str(s[3]), str(db_linkage))); if s[6] != rgt:; raise ValidationError('Output file \'%s.out\' has nominal affiliation %s incompatible with reagent %s.'; % (rgt, s[6], rgt)); if (s[8:10] == ['electronic', 'energy']):; ERGT[rgt] = float(s[10]); psi4.print_out('DATABASE RESULT: electronic energy = %20.12f\n' % (ERGT[rgt])); elif (s[8:10] == ['variable', 'value']):; for envv in db_tabulate:; envv = envv.upper(); if (s[13:] == envv.split()):; VRGT[rgt][envv] = float(s[10]); psi4.print_out('DATABASE RESULT: variable %s value = %20.12f\n' % (envv, VRGT[rgt][envv])); freagent.close(). # end sow after writing files; if db_mode == 'sow':; return 0.0. # Reap all the necessary reaction computations; psi4.print_out(""\n""); p4util.banner((""Database %s Results"" % (db_name))); psi4.print_out(""\n""). maxactv = []; for rxn in HRXN:; maxactv.append(len(ACTV[dbse + '-' + str(rxn)])); maxrgt = max(maxactv); table_delimit = '-' * (62 + 20 * maxrgt); tables = ''. # find any reactions that are incomplete; FAIL = collections.defaultdict(int); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); for i in range(len(ACTV[db_rxn])):; if abs(ERGT[ACTV[db_rxn][i]]) < 1.0e-12:; FAIL[rxn] = 1. # tabulate requested pro",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:23752,energy,energy,23752,psi4manual/1.0.0/_modules/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html,1,['energy'],['energy']
Energy Efficiency," EXCH10(S^2) ENERGY¶; An exchange-classified SAPT term energy [Eh] implemented for SAPT0. SAPT IND20,R ENERGY¶. SAPT EXCH-IND20,R ENERGY¶. SAPT IND20,U ENERGY¶. SAPT EXCH-IND20,U ENERGY¶; An induction-classified SAPT term energy [Eh] implemented for SAPT0. SAPT DISP20 ENERGY¶. SAPT EXCH-DISP20 ENERGY¶; A dispersion-classified SAPT term energy [Eh] implemented for SAPT0. SAPT EXCH-DISP20(S^INF) ENERGY¶; A dispersion-classified SAPT term energy [Eh] implemented for SAPT0. See Higher-Order Exchange Terms without Single-Exchange Approximation. SAPT SAME-SPIN DISP20 ENERGY¶. SAPT SAME-SPIN EXCH-DISP20 ENERGY¶; The portion of SAPT DISP20 ENERGY or; SAPT EXCH-DISP20 ENERGY resulting from; from same-spin or triplet doubles correlations. SAPT HF(2) ENERGY ABC(HF)¶; The total Hartree–Fock energy [Eh] of the supersystem implemented for F/I-SAPT. SAPT HF(2) ENERGY AC(0)¶; The Hartree–Fock energy [Eh] of subsystems A and C implemented for F/I-SAPT. SAPT HF(2) ENERGY BC(0)¶; The Hartree–Fock energy [Eh] of subsystems B and C implemented for F/I-SAPT. SAPT HF(2) ENERGY A(0)¶; The Hartree–Fock energy [Eh] of subsystem A implemented for F/I-SAPT. SAPT HF(2) ENERGY B(0)¶; The Hartree–Fock energy [Eh] of subsystem B implemented for F/I-SAPT. SAPT HF(2) ENERGY AC(HF)¶; The Hartree–Fock localized energy [Eh] of subsystems A and C implemented for F/I-SAPT. SAPT HF(2) ENERGY BC(HF)¶; The Hartree–Fock localized energy [Eh] of subsystems B and C implemented for F/I-SAPT. SAPT HF(2) ENERGY AB(HF)¶; The Hartree–Fock localized energy [Eh] of subsystems A and B implemented for F/I-SAPT. SAPT HF(2) ENERGY A(HF)¶; The Hartree–Fock localized energy [Eh] of subsystem A implemented for F/I-SAPT. SAPT HF(2) ENERGY B(HF)¶; The Hartree–Fock localized energy [Eh] of subsystem B implemented for F/I-SAPT. SAPT HF(2) ENERGY C¶; The Hartree–Fock energy [Eh] of subsystem C implemented for F/I-SAPT. SAPT HF(2) ENERGY HF¶; The FI-SAPT Hartree–Fock interaction energy [Eh] implemented for F/I-SAPT. SAPT ELST12,R ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/glossary_psivariables.html:44123,energy,energy,44123,psi4manual/1.6.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/glossary_psivariables.html,1,['energy'],['energy']
Energy Efficiency," EXCH10(S^2) ENERGY¶; An exchange-classified SAPT term energy [Eh] implemented for SAPT0. SAPT IND20,R ENERGY¶. SAPT EXCH-IND20,R ENERGY¶. SAPT IND20,U ENERGY¶. SAPT EXCH-IND20,U ENERGY¶; An induction-classified SAPT term energy [Eh] implemented for SAPT0. SAPT DISP20 ENERGY¶. SAPT EXCH-DISP20 ENERGY¶; A dispersion-classified SAPT term energy [Eh] implemented for SAPT0. SAPT EXCH-DISP20(S^INF) ENERGY¶; A dispersion-classified SAPT term energy [Eh] implemented for SAPT0. See Second-Order Exchange Terms without Single-Exchange Approximation. SAPT SAME-SPIN DISP20 ENERGY¶. SAPT SAME-SPIN EXCH-DISP20 ENERGY¶; The portion of SAPT DISP20 ENERGY or; SAPT EXCH-DISP20 ENERGY resulting from; from same-spin or triplet doubles correlations. SAPT HF(2) ENERGY ABC(HF)¶; The total Hartree–Fock energy [Eh] of the supersystem implemented for F/I-SAPT. SAPT HF(2) ENERGY AC(0)¶; The Hartree–Fock energy [Eh] of subsystems A and C implemented for F/I-SAPT. SAPT HF(2) ENERGY BC(0)¶; The Hartree–Fock energy [Eh] of subsystems B and C implemented for F/I-SAPT. SAPT HF(2) ENERGY A(0)¶; The Hartree–Fock energy [Eh] of subsystem A implemented for F/I-SAPT. SAPT HF(2) ENERGY B(0)¶; The Hartree–Fock energy [Eh] of subsystem B implemented for F/I-SAPT. SAPT HF(2) ENERGY AC(HF)¶; The Hartree–Fock localized energy [Eh] of subsystems A and C implemented for F/I-SAPT. SAPT HF(2) ENERGY BC(HF)¶; The Hartree–Fock localized energy [Eh] of subsystems B and C implemented for F/I-SAPT. SAPT HF(2) ENERGY AB(HF)¶; The Hartree–Fock localized energy [Eh] of subsystems A and B implemented for F/I-SAPT. SAPT HF(2) ENERGY A(HF)¶; The Hartree–Fock localized energy [Eh] of subsystem A implemented for F/I-SAPT. SAPT HF(2) ENERGY B(HF)¶; The Hartree–Fock localized energy [Eh] of subsystem B implemented for F/I-SAPT. SAPT HF(2) ENERGY C¶; The Hartree–Fock energy [Eh] of subsystem C implemented for F/I-SAPT. SAPT HF(2) ENERGY HF¶; The FI-SAPT Hartree–Fock interaction energy [Eh] implemented for F/I-SAPT. SAPT ELST12,R ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html:36605,energy,energy,36605,psi4manual/1.4.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html,4,['energy'],['energy']
Energy Efficiency," E_{NN} + E_{1e^-} + E_{2e^-} + E_{xc} + E_{\text{-D}} + E_{\text{DH}} \\; & = E_{\text{FCTL}} + E_{\text{-D}} + E_{\text{DH}} \\; & = E_{\text{SCF}} + E_{\text{DH}}; \end{align*}Unless the method is a DFT double-hybrid, this quantity is equal to; SCF TOTAL ENERGY. If the method is neither a; double-hybrid, nor dispersion corrected, this quantity is equal to; DFT FUNCTIONAL TOTAL ENERGY. DFT TOTAL GRADIENT¶; The total electronic gradient [E_h/a0] of the requested DFT method, ({nat}, 3). DFT DIPOLE GRADIENT¶; The derivative of the requested DFT method dipole [E_h a0/u] = [(e a0/a0)^2/u] with respect to nuclear perturbations; as a degree-of-freedom by dipole component array, (3 * {nat}, 3). DFT TOTAL HESSIAN¶; The total electronic second derivative [Eh/a0/a0] for the requested DFT method, (3 * {nat}, 3 * {nat}). DFT XC ENERGY¶; The functional energy contribution [Eh] to the total SCF energy (DFT only).; Quantity \(E_{xc}\) in Eqs. (4) and (1). DFT VV10 ENERGY¶; The VV10 nonlocal contribution [Eh] to the total SCF energy (DFT only).; Included in DFT FUNCTIONAL TOTAL ENERGY. DISPERSION CORRECTION ENERGY¶. fctl DISPERSION CORRECTION ENERGY¶; The dispersion correction [Eh] appended to an underlying functional; when a DFT-D method is requested. Quantity \(E_{\text{-D}}\); in Eqs. (4) and (1).; When dispersion parameters are untweaked for a functional and dispersion; level, labeled QCVariable also defined. DOUBLE-HYBRID CORRECTION ENERGY¶; The scaled MP2 correlation energy correction [Eh] appended to an; underlying functional when a DH-DFT method is requested.; Quantity \(E_{\text{DH}}\) in Eq. (1). DMA DISTRIBUTED MULTIPOLES¶; Distributed multipoles in units given by GDMA_MULTIPOLE_UNITS; with the row index corresponding to the site and the column index; referencing the multipole component. Both indices are zero based,; and the Qlm components of the multipoles are ordered as Q00, Q10,; Q11c, Q11s, Q20, Q21c, Q21s, Q22c, Q22s, etc. DMA TOTAL MULTIPOLES¶; Distributed multipo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html:20610,energy,energy,20610,psi4manual/1.4.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html,5,['energy'],['energy']
Energy Efficiency," Energy Point. psimrcc-sp1; Mk-MRCCSD single point. \(^3 \Sigma ^-\) O2 state described using the Ms = 0 component of the triplet. Uses ROHF triplet orbitals. scf5; Test of all different algorithms and reference types for SCF, on singlet and triplet O2, using the cc-pVTZ basis set. dct8; DCT calculation for the NH3+ radical using the ODC-12 and ODC-13 functionals. This performs both simultaneous and QC update of the orbitals and cumulant using DIIS extrapolation. Four-virtual integrals are first handled in the MO Basis for the first two energy computations. In the next computation ao_basis=disk algorithm is used, where the transformation of integrals for four-virtual case is avoided. dft-vv10; He Dimer VV10 functional test. notes: DFT_VV10_B/C overwrites the NL_DISPERSION_PARAMETERS tuple updated ‘bench’ reference values for new BraggSlater radii. dfmp2-grad5; Tests DF-MP2 gradient in the presence of a dipole field. opt6; Various constrained energy minimizations of HOOH with cc-pvdz RHF Internal-coordinate constraints in internal-coordinate optimizations. molden2; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. dfccsd-t-grad1; DF-CCSD(T) cc-pVDZ gradients for the H2O molecule. dfmp2-grad2; DF-MP2 cc-pVDZ gradient for the NO molecule. casscf-semi; CASSCF/6-31G** energy point. Check energy with frozen core/virtual orbs. after semicanonicalization. dlpnomp2-1; comparison of DF-MP2 and DLPNO-MP2. scf4; RHF cc-pVDZ energy for water, automatically scanning the symmetric stretch and bending coordinates using Python’s built-in loop mechanisms. The geometry is specified using a Z-matrix with variables that are updated during the potential energy surface scan, and then the same procedure is performed ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html:6573,energy,energy,6573,psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency," Energy or Max Disp are fulfilled. [6](1, 2, 3, 4, 5) Normal convergence achieved when all four criteria (Max Force, RMS Force,; Max Disp, and RMS Disp) are fulfilled. To help with flat; potential surfaces, alternate convergence achieved when 100\(\times\)rms force is less; than RMS Force criterion. [7]Compensates for difficulties in converging geometry optmizations of supermolecular complexes; tightly, where large rms disp and max disp may result from flat potential surfaces even when; max force and/or rms force are small. For ultimate control, specifying a value for any of the five monitored options activates that; criterium and overwrites/appends it to the criteria set by G_CONVERGENCE.; Note that this revokes the special convergence arrangements detailed in notes [5] and [6]; and instead requires all active criteria to be fulfilled to; achieve convergence. To avoid this revokation, turn on keyword FLEXIBLE_G_CONVERGENCE. Output¶; The progress of a geometry optimization can be monitored by grepping the output file for the; tilde character (~). This produces a table like the one below that shows; for each iteration the value for each of the five quantities and whether the criterion; is active and fulfilled (*), active and unfulfilled ( ), or inactive (o).; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10--------------------------------------------------------------------------------------------- ~; Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~; --------------------------------------------------------------------------------------------- ~; Convergence Criteria 1.00e-06 * 3.00e-04 * o 1.20e-03 * o ~; --------------------------------------------------------------------------------------------- ~; 1 -38.91591820 -3.89e+01 6.91e-02 5.72e-02 o 1.42e-01 1.19e-01 o ~; 2 -38.92529543 -9.38e-03 6.21e-03 3.91e-03 o 2.00e-02 1.18e-02 o ~; 3 -38.92540669 -1.11e-04 4.04e-03 2.46e-03 o 3.63e-02 2.12e-02 o ~; 4 -38.92548668 -8.00e-05 2.30e-04 * 1.92e-04 o 1.99e-03 1.17e-03 o ~;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/optking-1.html:14352,monitor,monitored,14352,psi4manual/1.2.1/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/optking-1.html,4,['monitor'],['monitored']
Energy Efficiency," Exchange-Correlation Functional\n'); # Tab in, trailing newlines; sup.set_citation(' A.D. Becke, J. Chem. Phys., 107(20), 8554-8560, 1997\n'). # Add member functionals; X = build_functional('B97_X'); X.set_name('B97-0_X'); X.set_alpha(1.0 / 0.8057). X.set_parameter('B97_gamma', 0.004); X.set_parameter('B97_a0', 0.8094); X.set_parameter('B97_a1', 0.5073); X.set_parameter('B97_a2', 0.7481). C = build_functional('B_C'); C.set_name('B97-0_C'). C.set_parameter('B97_os_gamma', 0.006); C.set_parameter('B97_os_a0', 0.9454); C.set_parameter('B97_os_a1', 0.7471); C.set_parameter('B97_os_a2', -4.5961). C.set_parameter('B97_ss_gamma', 0.2); C.set_parameter('B97_ss_a0', 0.1737); C.set_parameter('B97_ss_a1', 2.3487); C.set_parameter('B97_ss_a2', -2.4868). sup.add_x_functional(X); sup.add_c_functional(C). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.1943); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_b971_superfunctional(name, npoints, deriv):. # Call this first; sup = PsiMod.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('B97-1'); # Tab in, trailing newlines; sup.set_description(' B97-1 Hybrid-GGA Exchange-Correlation Functional\n'); # Tab in, trailing newlines; sup.set_citation(' F.A. Hamprecht et. al., J. Chem. Phys., 109(15), 6264-6271, 1998\n'). # Add member functionals; X = build_functional('B97_X'); X.set_name('B97-1_X'); X.set_alpha(1.0 / 0.79). X.set_parameter('B97_gamma', 0.004); X.set_parameter('B97_a0', 0.789518); X.set_parameter('B97_a1', 0.573805); X.set_parameter('B97_a2', 0.660975). C = build_functional('B_C'); C.set_name('B97-1_C'). C.set_parameter('B97_os_gamma', 0.006); C.set_parameter('B97_os_a0', 0.955689); C.set_parameter('B97_os_a1', 0.788552); C.set_parameter('B97_os_a2', -5.47869). C.set_parameter('B97_s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/functional.html:28293,allocate,allocate,28293,psi4manual/4.0b2/_modules/functional.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/functional.html,3,['allocate'],['allocate']
Energy Efficiency," Exchange-Correlation Functional\n'); # Tab in, trailing newlines; sup.set_citation(' A.D. Becke, J. Chem. Phys., 107(20), 8554-8560, 1997\n'). # Add member functionals; X = build_functional('B97_X'); X.set_name('B97-0_X'); X.set_alpha(1.0 / 0.8057). X.set_parameter('B97_gamma', 0.004); X.set_parameter('B97_a0', 0.8094); X.set_parameter('B97_a1', 0.5073); X.set_parameter('B97_a2', 0.7481). C = build_functional('B_C'); C.set_name('B97-0_C'). C.set_parameter('B97_os_gamma', 0.006); C.set_parameter('B97_os_a0', 0.9454); C.set_parameter('B97_os_a1', 0.7471); C.set_parameter('B97_os_a2', -4.5961). C.set_parameter('B97_ss_gamma', 0.2); C.set_parameter('B97_ss_a0', 0.1737); C.set_parameter('B97_ss_a1', 2.3487); C.set_parameter('B97_ss_a2', -2.4868). sup.add_x_functional(X); sup.add_c_functional(C). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.1943); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_b971_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('B97-1'); # Tab in, trailing newlines; sup.set_description(' B97-1 Hybrid-GGA Exchange-Correlation Functional\n'); # Tab in, trailing newlines; sup.set_citation(' F.A. Hamprecht et. al., J. Chem. Phys., 109(15), 6264-6271, 1998\n'). # Add member functionals; X = build_functional('B97_X'); X.set_name('B97-1_X'); X.set_alpha(1.0 / 0.79). X.set_parameter('B97_gamma', 0.004); X.set_parameter('B97_a0', 0.789518); X.set_parameter('B97_a1', 0.573805); X.set_parameter('B97_a2', 0.660975). C = build_functional('B_C'); C.set_name('B97-1_C'). C.set_parameter('B97_os_gamma', 0.006); C.set_parameter('B97_os_a0', 0.955689); C.set_parameter('B97_os_a1', 0.788552); C.set_parameter('B97_os_a2', -5.47869). C.set_parameter('B97_ss_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/functional.html:32347,allocate,allocate,32347,psi4manual/4.0b5/_modules/functional.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/functional.html,2,['allocate'],['allocate']
Energy Efficiency," Expert¶. MRCC_METHOD¶. If more than one root is requested and calc=1, LR-CC (EOM-CC) calculation is performed automatically for the excited states. This overrides all automatic determination of method and will only work with energy(). This becomes CC/CI (option #5) in fort.56 | begin{tabular}{ccc} | Value & Method & Description \ | hline | 1 & CC & \ | 2 & CC(n-1)[n] & \ | 3 & CC(n-1)(n) & (CC(n-1)[n] energy is also calculated) \ | 4 & CC(n-1)(n)_L & (CC(n-1)[n] and CC(n-1)(n) energies are also calculated) \ | 5 & CC(n)-1a & \ | 6 & CC(n)-1b & \ | 7 & CCn & \ | 8 & CC(n)-3 & \ | end{tabular}. Type: integer; Default: 1. MRCC_OMP_NUM_THREADS¶. Sets the OMP_NUM_THREADS environment variable before calling MRCC. If the environment variable OMP_NUM_THREADS is set prior to calling PSI4 then that value is used. When set, this option overrides everything. Be aware the -n command-line option described in section Threading does not affect MRCC. Type: integer; Default: 1. MRCC_RESTART¶. The program restarts from the previously calculated parameters if it is 1. In case it is 2, the program executes automatically the lower-level calculations of the same type consecutively (e.g., CCSD, CCSDT, and CCSDTQ if CCSDTQ is requested) and restarts each calculation from the previous one (rest=2 is available only for energy calculations). Currently, only a value of 0 and 2 are supported. This becomes rest (option #4) in fort.56. Type: integer; Default: 0. Table Of Contents. MRCC; General; E_CONVERGENCE; INTS_TOLERANCE; MRCC_LEVEL; MRCC_NUM_SINGLET_ROOTS; MRCC_NUM_TRIPLET_ROOTS. Expert; MRCC_METHOD; MRCC_OMP_NUM_THREADS; MRCC_RESTART. Previous topic; WFN; Next topic; E_CONVERGENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Appendices »; Keywords by Module ». © Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodir_options_c/module__mrcc-1.html:2524,energy,energy,2524,psi4manual/4.0b3/autodir_options_c/module__mrcc-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/module__mrcc-1.html,2,['energy'],['energy']
Energy Efficiency," F-SAPT0 exchange. find(self: psi4.core.FISAPT) → None¶; F-SAPT0 induction. flocalize(self: psi4.core.FISAPT) → None¶; F-SAPT0 localize. freeze_core(self: psi4.core.FISAPT) → None¶; Freeze the core orbitals. ind(self: psi4.core.FISAPT) → None¶; SAPT0 induction. kinetic(self: psi4.core.FISAPT) → None¶; Build the kinetic integrals T. localize(self: psi4.core.FISAPT) → None¶; Localize the active occupied orbitals via IBO2. matrices(self: psi4.core.FISAPT) → Dict[str, psi4.core.Matrix]¶; Return the interally computed matrices (not copied). molecule(self: psi4.core.FISAPT) → psi4.core.Molecule¶; Returns the FISAPT’s molecule. nuclear(self: psi4.core.FISAPT) → None¶; Build the nuclear potentials V and interaction energies. overlap(self: psi4.core.FISAPT) → None¶; Build the overlap integrals S. partition(self: psi4.core.FISAPT) → None¶; Partition the nuclei and electrons. plot()¶; Filesystem wrapper for FISAPT::plot. print_header(self: psi4.core.FISAPT) → None¶; Print header, bases, sizes, etc. print_trailer(self: psi4.core.FISAPT) → None¶; Print SAPT results. raw_plot(self: psi4.core.FISAPT, arg0: str) → None¶; Plot some analysis files. scalars(self: psi4.core.FISAPT) → Dict[str, float]¶; Return the interally computed scalars (not copied). scf(self: psi4.core.FISAPT) → None¶; Solve the relaxed SCF equations for A0 and B0. sinf_disp(self: psi4.core.FISAPT, arg0: Dict[str, psi4.core.Matrix], arg1: Dict[str, psi4.core.Vector], arg2: bool) → None¶; Computes the MP2-based DispE20 and Exch-DispE20 energy without S^2. unify(self: psi4.core.FISAPT) → None¶; Produce unified matrices for A’, B’, and C’. vectors(self: psi4.core.FISAPT) → Dict[str, psi4.core.Vector]¶; Return the interally computed vectors (not copied). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. PSI4 API: Linking C++ and Python; FISAPT. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.core.FISAPT.html:4078,energy,energy,4078,psi4manual/1.7.x/api/psi4.core.FISAPT.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.FISAPT.html,1,['energy'],['energy']
Energy Efficiency," F. A. Evangelista, W. D. Allen, and H. F. Schaefer,; J. Chem. Phys. 127, 024102 (2007).; (doi: 10.1063/1.2743014). Mk-MRCCSD(T). “Perturbative Triples Corrections in State-Specific Multireference; Coupled Cluster Theory,”; F. A. Evangelista, E. Prochnow, J. Gauss, and H. F. Schaefer,; J. Chem. Phys. 132, 074107 (2010).; (doi: 10.1063/1.3305335). Mk-MRCCSDT(-n). “Triple Excitations in State-Specific Multireference Coupled; Cluster Theory: Application of Mk-MRCCSDT and Mk-MRCCSDT-n Methods to; Model Systems,” F. A. Evangelista, A. C. Simmonett, W. D. Allen,; H. F. Schaefer, and J. Gauss, J. Chem. Phys. 128, 124104; (2008).; (doi: 10.1063/1.2834927). Mk-MRPT2. “A Companion Perturbation Theory for State-specific; Multireference Coupled Cluster Methods,”; F. A. Evangelista, A. C. Simmonett, H. F. Schaefer, D. Mukherjee, and; W. D. Allen,; Phys. Chem. Chem. Phys. 11, 4728-4741 (2009).; (doi: 10.1039/b822910d). Symmetry-Adapted Perturbation Theory (SAPT)¶; PSI4 features an extremely efficient code to perform wavefunction-based; Symmetry Adapted Perturbation Theory (SAPT). A good review article for this; method is as follows:. “Perturbation Theory Approach to Intermolecular Potential Energy; Surfaces of van der Waals Complexes,” B. Jeziorski, R. Moszynski,; and K. Szalewicz, Chem. Rev. 94, 1887-1930 (1994).; (doi: 10.1021/cr00031a008). PSI4 benefits enormously from the introduction of density fitting (DF); into SAPT. The theory and implementation of DF-SAPT is discussed; in the following papers for various levels of SAPT.; DF-SAPT0. “Large-scale Symmetry-adapted Perturbation Theory Computations via; Density Fitting and Laplace Transformation Techniques: Investigating the; Fundamental Forces of DNA-Intercalator Interactions,” E. G. Hohenstein,; R. M. Parrish, C. D. Sherrill, J. M. Turney, and H. F. Schaefer, J.; Chem. Phys. 135, 174017 (2011).; (doi: 10.1063/1.3656681).; “Density Fitting and Cholesky Decomposition Approximations; in Symmetry-Adapted Perturbation Theory: Imp",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/introduction-1.html:6319,efficient,efficient,6319,psi4manual/4.0b4/introduction-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/introduction-1.html,4,['efficient'],['efficient']
Energy Efficiency," F. A. Evangelista, W. D. Allen, and H. F. Schaefer,; J. Chem. Phys. 127, 024102 (2007).; (doi: 10.1063/1.2743014). Mk-MRCCSD(T). “Perturbative Triples Corrections in State-Specific Multireference; Coupled Cluster Theory,”; F. A. Evangelista, E. Prochnow, J. Gauss, and H. F. Schaefer,; J. Chem. Phys. 132, 074107 (2010).; (doi: 10.1063/1.3305335). Mk-MRCCSDT(-n). “Triple Excitations in State-Specific Multireference Coupled; Cluster Theory: Application of Mk-MRCCSDT and Mk-MRCCSDT-n Methods to; Model Systems,” F. A. Evangelista, A. C. Simmonett, W. D. Allen,; H. F. Schaefer, and J. Gauss, J. Chem. Phys. 128, 124104; (2008).; (doi: 10.1063/1.2834927). Mk-MRPT2. “A Companion Perturbation Theory for State-specific; Multireference Coupled Cluster Methods,”; F. A. Evangelista, A. C. Simmonett, H. F. Schaefer, D. Mukherjee, and; W. D. Allen,; Phys. Chem. Chem. Phys. 11, 4728-4741 (2009).; (doi: 10.1039/b822910d). Symmetry-Adapted Perturbation Theory (SAPT)¶; PSI4 features an extremely efficient code to perform wavefunction-based; Symmetry Adapted Perturbation Theory (SAPT). A good review article for this; method is as follows:. “Perturbation Theory Approach to Intermolecular Potential Energy; Surfaces of van der Waals Complexes,” B. Jeziorski, R. Moszynski,; and K. Szalewicz, Chem. Rev. 94, 1887-1930 (1994).; (doi: 10.1021/cr00031a008). PSI4 benefits enormously from the introduction of density fitting (DF); into SAPT. There are several SAPT truncations available in PSI4. For; guidance on which one to choose, see the SAPT section of the manual; and refer to the following systematic study:. “Levels of Symmetry Adapted Perturbation Theory (SAPT). I. Efficiency and; Performance for Interaction Energies,’’ T. M. Parker, L. A. Burns, R. M.; Parrish, A. G. Ryno, and C. D. Sherrill, J. Chem. Phys. 140,; 094106 (2014).; (doi: 10.1063/1.4867135). The theory and implementation of DF-SAPT is discussed; in the following papers for various levels of SAPT.; DF-SAPT0. “Large-scale Symmetry",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/introduction-1.html:9213,efficient,efficient,9213,psi4manual/1.1.0/introduction-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/introduction-1.html,15,['efficient'],['efficient']
Energy Efficiency," F. A. Evangelista, W. D. Allen, and H. F. Schaefer,; J. Chem. Phys. 127, 024102 (2007).; (doi: 10.1063/1.2743014). Mk-MRCCSD(T). “Perturbative Triples Corrections in State-Specific Multireference; Coupled Cluster Theory,”; F. A. Evangelista, E. Prochnow, J. Gauss, and H. F. Schaefer,; J. Chem. Phys. 132, 074107 (2010).; (doi: 10.1063/1.3305335). Mk-MRCCSDT(-n). “Triple Excitations in State-Specific Multireference Coupled; Cluster Theory: Application of Mk-MRCCSDT and Mk-MRCCSDT-n Methods to; Model Systems,” F. A. Evangelista, A. C. Simmonett, W. D. Allen,; H. F. Schaefer, and J. Gauss, J. Chem. Phys. 128, 124104; (2008).; (doi: 10.1063/1.2834927). Mk-MRPT2. “A Companion Perturbation Theory for State-specific; Multireference Coupled Cluster Methods,”; F. A. Evangelista, A. C. Simmonett, H. F. Schaefer, D. Mukherjee, and; W. D. Allen,; Phys. Chem. Chem. Phys. 11, 4728-4741 (2009).; (doi: 10.1039/b822910d). Symmetry-Adapted Perturbation Theory (SAPT)¶; Psi4 features an extremely efficient code to perform wavefunction-based; Symmetry Adapted Perturbation Theory (SAPT). A good review article for this; method is as follows:. “Perturbation Theory Approach to Intermolecular Potential Energy; Surfaces of van der Waals Complexes,” B. Jeziorski, R. Moszynski,; and K. Szalewicz, Chem. Rev. 94, 1887-1930 (1994).; (doi: 10.1021/cr00031a008). Psi4 benefits enormously from the introduction of density fitting (DF); into SAPT. There are several SAPT truncations available in Psi4. For; guidance on which one to choose, see the SAPT section of the manual; and refer to the following systematic study:. “Levels of Symmetry Adapted Perturbation Theory (SAPT). I. Efficiency and; Performance for Interaction Energies,’’ T. M. Parker, L. A. Burns, R. M.; Parrish, A. G. Ryno, and C. D. Sherrill, J. Chem. Phys. 140,; 094106 (2014).; (doi: 10.1063/1.4867135). The theory and implementation of DF-SAPT is discussed; in the following papers for various levels of SAPT.; DF-SAPT0. “Large-scale Symmetry",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/introduction-1.html:7423,efficient,efficient,7423,psi4manual/1.0.0/introduction-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/introduction-1.html,2,['efficient'],['efficient']
Energy Efficiency," FCI/cc-pVDZ Transition Dipole Moment. scf-hess1; RHF STO-3G (Cartesian) and cc-pVDZ (spherical) water Hessian test, against Psi3 reference values. rasci-c2-active; 6-31G* C2 Test RASCI Energy Point, testing two different ways of specifying the active space, either with the ACTIVE keyword, or with RAS1, RAS2, RESTRICTED_DOCC, and RESTRICTED_UOCC. cc53; Matches Table II a-CCSD(T)/cc-pVDZ H2O @ 2.5 * Re value from Crawford and Stanton, IJQC 98, 601-611 (1998). scf1; RHF cc-pVQZ energy for the BH molecule, with Cartesian input. mom; Maximum Overlap Method (MOM) Test. MOM is designed to stabilize SCF convergence and to target excited Slater determinants directly. dft-custom-hybrid; DFT (hybrids) test of implementations in: hybrid_superfuncs.py. fsapt-ext-abc2; FSAPT with external charge on dimer. cc34; RHF-CCSD/cc-pVDZ energy of H2O partitioned into pair energy contributions. cc23; ROHF-EOM-CCSD/DZ analytic gradient lowest \(^{2}B_1\) state of H2O+ (A1 excitation). omp3-1; OMP3 cc-pVDZ energy for the H2O molecule. pywrap-db3; Test that Python Molecule class processes geometry like psi4 Molecule class. dft-freq-analytic; Analytic SVWN frequencies, compared to finite difference values. scf-response3; UHF Dipole Polarizability Test. psithon2; Accesses basis sets, databases, plugins, and executables in non-install locations. cc36; CC2(RHF)/cc-pVDZ energy of H2O. opt11; Transition-state optimizations of HOOH to both torsional transition states. opt6; Various constrained energy minimizations of HOOH with cc-pvdz RHF Internal-coordinate constraints in internal-coordinate optimizations. dfmp2-grad2; DF-MP2 cc-pVDZ gradient for the NO molecule. sapt11; sapt example with orbital freezing with alkali metal and dMP2. cc46; EOM-CC2/cc-pVDZ on H2O2 with two excited states in each irrep. cc52; CCSD Response for H2O2. dft-grad2; DF-BP86-D2 cc-pVDZ frozen core gradient of S22 HCN updated ref gradient due to new BraggSlater radii. dforemp-grad1; density fitted OO-REMP/cc-pVDZ engrad sing",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html:12061,energy,energy,12061,psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency," False; instance.PYmove_to_com = not no_com; instance.PYfix_orientation = no_reorient. if contentsNotFilename:; text = xyzfilename.splitlines(); else:; try:; infile = open(xyzfilename, 'r'); except IOError:; raise ValidationError(""""""Molecule::init_with_mol2: given filename '%s' does not exist."""""" % (xyzfilename)); if os.stat(xyzfilename).st_size == 0:; raise ValidationError(""""""Molecule::init_with_mol2: given filename '%s' is blank."""""" % (xyzfilename)); text = infile.readlines(). # fixed-width regex ((?=[ ]*-?\d+)[ -\d]{5}); v2000 = re.compile(r'^((?=[ ]*\d+)[ \d]{3})((?=[ ]*\d+)[ \d]{3})(.*)V2000\s*$'); vend = re.compile(r'^\s*M\s+END\s*$'); NUMBER = ""((?:[-+]?\\d*\\.\\d+(?:[DdEe][-+]?\\d+)?)|(?:[-+]?\\d+\\.\\d*(?:[DdEe][-+]?\\d+)?))""; xyzM = re.compile(r'^(?:\s*)' + NUMBER + '(?:\s+)' + NUMBER + '(?:\s+)' + NUMBER +; '(?:\s+)([A-Z](?:[a-z])?)(?:\s+)(.*)', re.IGNORECASE). ## now charge and multiplicity; # $chargem = 0 ; $multm = 1 ;; #while (<MOL>) {; #if (/CHARGE/) { $chargem = <MOL> ; chop($chargem) ;}; #if (/MULTIPLICITY/) { $multm = <MOL> ; chop($multm) }; # } # end while charge and multiplicity. if not text:; raise ValidationError(""Molecule::init_with_mol2: file blank""); # Try to match header/footer; if vend.match(text[-1]):; pass; else:; raise ValidationError(""Molecule::init_with_mol2: Malformed file termination\n%s"" % (text[-1])); sysname = '_'.join(text[0].strip().split()); comment = text[2].strip(); if comment:; instance.tagline = sysname + ' ' + comment; else:; instance.tagline = sysname; #instance.tagline = text[0].strip() + ' ' + text[2].strip(); fileUnits = 'Angstrom' # defined for MOL; #instance.set_molecular_charge(int(xyz2.match(text[1]).group(1))); #instance.set_multiplicity(int(xyz2.match(text[1]).group(2))); if v2000.match(text[3]):; fileNatom = int(v2000.match(text[3]).group(1)); fileNbond = int(v2000.match(text[3]).group(2)); else:; raise ValidationError(""Molecule::init_with_mol2: Malformed fourth line\n%s"" % (text[3])); if fileNatom < 1:; raise ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molecule.html:7749,charge,charge,7749,psi4manual/1.0.0/_modules/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molecule.html,5,['charge'],"['charge', 'chargem']"
Energy Efficiency," Fb(...); Returns the Beta Fock Matrix. H(...); Returns the ‘Core’ Matrix (Potential + Kinetic) Integrals. S(...); Returns the One-electron Overlap Matrix. X(...); Returns the Lagrangian Matrix. alpha_orbital_space(...); docstring. aotoso(...); Returns the Atomic Orbital to Symmetry Orbital transformer. arrays(...); Returns the map of all internal arrays. atomic_point_charges(...); Returns the set atomic point charges. basis_projection(...); Projects a orbital matrix from one basis to another. basisset(...); Returns the current orbital basis. beta_orbital_space(...); docstring. build(mol[, basis]). compute_energy(...); Computes the energy of the Wavefunction. compute_gradient(...); Computes the gradient of the Wavefunction. compute_hessian(...); Computes the Hessian of the Wavefunction. deep_copy((self: psi4.core.Wavefunction, ...); Deep copies the internal data. doccpi(...); Returns the number of doubly occupied orbitals per irrep. energy((self: psi4.core.Wavefunction) -> float); Returns the Wavefunctions energy. epsilon_a(...); Returns the Alpha Eigenvalues. epsilon_a_subset(...); Returns the requested Alpha Eigenvalues subset. epsilon_b(...); Returns the Beta Eigenvalues. epsilon_b_subset(...); Returns the requested Beta Eigenvalues subset. frequencies(...); Returns the frequencies of the Hessian. frzcpi(...); Returns the number of frozen core orbitals per irrep. frzvpi(...); Returns the number of frozen virtual orbitals per irrep. get_array((self: psi4.core.Wavefunction, ...); Sets the requested internal array. get_basisset((self: psi4.core.Wavefunction, ...); Returns the requested auxiliary basis. get_variable((self: psi4.core.Wavefunction, ...); Returns the requested internal variable. gradient(...); Returns the Wavefunctions gradient. hessian(...); Returns the Wavefunctions Hessian. molecule(...); Returns the Wavefunctions molecule. nalpha((self: psi4.core.Wavefunction) -> int); Number of Alpha electrons. nalphapi(...); Returns the number of alpha orbitals pe",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/api/psi4.core.wavefunction.html:1765,energy,energy,1765,psi4manual/1.1.0/api/psi4.core.wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.wavefunction.html,1,['energy'],['energy']
Energy Efficiency," For higher-order; methods in SAPT module, there is no workaround;; on-the-fly construction of an auxiliary basis through Cholesky; decomposition (not implemented) is the long-term solution. Spin-Flip SAPT¶; SAPT0 with two open-shell references will always yield a high-spin complex. In; order to obtain a SAPT-based estimate of the splittings between different spin; states of a complex the first-order exchange energies for all multiplets can be; shown to be a linear combination of two matrix elements: a diagonal exchange; term that determines the spin-averaged effect and a spin-flip term responsible; for the splittings between the states. The numerical factors in this linear; combination are determined solely by the Clebsch-Gordan coefficients:; accordingly, the \(S^{2}\) approximation implies a Heisenberg Hamiltonian; picture with a single coupling strength parameter determining all the; splittings. This method can be invoked with energy(“SF-SAPT”) and; publications resulting from the use of the SF-SAPT code should cite the; following publications: [Patkowski:2018:164110]. Second-Order Exchange Terms without Single-Exchange Approximation¶; Recently, the SAPT second-order exchange terms have been derived without; the \(S^{2}\) approximation in the works [Schaffer:2012:1235] and; [Schaffer:2013:2570]. These new terms can be computed with the following; settings:; set SAPT_DFT_FUNCTIONAL HF; set DO_IND_EXCH_SINF true # calculate Exch-Ind20 (S^inf); set SAPT_DFT_MP2_DISP_ALG fisapt; set DO_DISP_EXCH_SINF true # calculate Exch-Disp20 (S^inf); energy('sapt(dft)'). These calculations are performed with the atomic orbital and; density-fitting scheme of [J. M. Waldrop et al., to be published]. S^inf Keywords¶. DO_IND_EXCH_SINF¶. For SAPT(DFT) computes the \(S^{inf}\) Exchange-Induction terms. Type: boolean; Default: false. DO_DISP_EXCH_SINF¶. For SAPT(DFT) computes the \(S^{inf}\) Exchange-Dispersion terms. Type: boolean; Default: false. SAPT0-D¶; In SAPT0, the computation of",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/sapt-1.html:44046,energy,energy,44046,psi4manual/1.4.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/sapt-1.html,4,['energy'],['energy']
Energy Efficiency," For higher-order; methods in SAPT module, there is no workaround;; on-the-fly construction of an auxiliary basis through Cholesky; decomposition (not implemented) is the long-term solution. Spin-Flip SAPT¶; SAPT0 with two open-shell references will always yield a high-spin complex. In; order to obtain a SAPT-based estimate of the splittings between different spin; states of a complex the first-order exchange energies for all multiplets can be; shown to be a linear combination of two matrix elements: a diagonal exchange; term that determines the spin-averaged effect and a spin-flip term responsible; for the splittings between the states. The numerical factors in this linear; combination are determined solely by the Clebsch-Gordan coefficients:; accordingly, the \(S^{2}\) approximation implies a Heisenberg Hamiltonian; picture with a single coupling strength parameter determining all the; splittings. This method can be invoked with energy(“SF-SAPT”) and; publications resulting from the use of the SF-SAPT code should cite the; following publications: [Patkowski:2018:164110]. table of contents. SAPT: Symmetry-Adapted Perturbation Theory; The S2 approximation and scaling; A First Example; Advanced example; SAPT0; Basic SAPT0 Keywords; SAPT_LEVEL; BASIS; DF_BASIS_SAPT; DF_BASIS_ELST; FREEZE_CORE; D_CONVERGENCE; E_CONVERGENCE; MAXITER; PRINT. Advanced SAPT0 Keywords; AIO_CPHF; AIO_DF_INTS; COUPLED_INDUCTION; EXCH_SCALE_ALPHA; INTS_TOLERANCE; DENOMINATOR_DELTA; DENOMINATOR_ALGORITHM; DEBUG. Specific open-shell SAPT0 keywords; SAPT_MEM_SAFETY; COUPLED_INDUCTION. Higher-Order SAPT; Basic Keywords for Higher-order SAPT; BASIS; DF_BASIS_SAPT; FREEZE_CORE; PRINT. Advanced Keywords for Higher-order SAPT; DO_CCD_DISP; DO_MBPT_DISP; DO_THIRD_ORDER; INTS_TOLERANCE; SAPT_MEM_CHECK; DEBUG. MP2 Natural Orbitals; Basic Keywords Controlling MP2 NO Approximations; NAT_ORBS_T2; NAT_ORBS_T3; NAT_ORBS_V4; OCC_TOLERANCE. Charge-Transfer in SAPT; Monomer-Centered Basis Computations; Computatio",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/sapt-1.html:38841,energy,energy,38841,psi4manual/1.2.1/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/sapt-1.html,4,['energy'],['energy']
Energy Efficiency," Functional\n'); # Tab in, trailing newlines; sup.set_citation(' P.J. Wilson et. al., J. Chem. Phys., 115(20), 9233-9242, 2001\n'). # Add member functionals; X = build_functional('B97_X'); X.set_name('B97-2_X'); X.set_alpha(1.0 / 0.79). X.set_parameter('B97_gamma', 0.004); X.set_parameter('B97_a0', 0.827642); X.set_parameter('B97_a1', 0.047840); X.set_parameter('B97_a2', 1.761250). C = build_functional('B_C'); C.set_name('B97-2_C'). C.set_parameter('B97_os_gamma', 0.006); C.set_parameter('B97_os_a0', 0.999849); C.set_parameter('B97_os_a1', 1.40626); C.set_parameter('B97_os_a2', -7.44060). C.set_parameter('B97_ss_gamma', 0.2); C.set_parameter('B97_ss_a0', 0.585808); C.set_parameter('B97_ss_a1', -0.691682); C.set_parameter('B97_ss_a2', 0.394796). sup.add_x_functional(X); sup.add_c_functional(C). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.21); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_b97d2p4_superfunctional(name, npoints, deriv):. # Call this first; sup = PsiMod.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('B97-D2P4'); # Tab in, trailing newlines; sup.set_description(' B97-D Pure-GGA Exchange-Correlation Functional\n'); # Tab in, trailing newlines; sup.set_citation(' S. Grimme, J. Comput. Chem., 27, 1787-1799, 2006\n'). # Add member functionals; X = build_functional('B97_X'); X.set_name('B97-D_X'); X.set_alpha(1.0). X.set_parameter('B97_gamma', 0.004); X.set_parameter('B97_a0', 1.08662); X.set_parameter('B97_a1', -0.52127); X.set_parameter('B97_a2', 3.25429). C = build_functional('B_C'); C.set_name('B97-D_C'). C.set_parameter('B97_os_gamma', 0.006); C.set_parameter('B97_os_a0', 0.69041); C.set_parameter('B97_os_a1', 6.30270); C.set_parameter('B97_os_a2', -14.9712). C.set_parameter('B97_ss_gamma', 0.2); C.set_p",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/functional.html:34356,allocate,allocate,34356,psi4manual/4.0b4/_modules/functional.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/functional.html,1,['allocate'],['allocate']
Energy Efficiency," Functional\n'); # Tab in, trailing newlines; sup.set_citation(' P.J. Wilson et. al., J. Chem. Phys., 115(20), 9233-9242, 2001\n'). # Add member functionals; X = build_functional('B97_X'); X.set_name('B97-2_X'); X.set_alpha(1.0 / 0.79). X.set_parameter('B97_gamma', 0.004); X.set_parameter('B97_a0', 0.827642); X.set_parameter('B97_a1', 0.047840); X.set_parameter('B97_a2', 1.761250). C = build_functional('B_C'); C.set_name('B97-2_C'). C.set_parameter('B97_os_gamma', 0.006); C.set_parameter('B97_os_a0', 0.999849); C.set_parameter('B97_os_a1', 1.40626); C.set_parameter('B97_os_a2', -7.44060). C.set_parameter('B97_ss_gamma', 0.2); C.set_parameter('B97_ss_a0', 0.585808); C.set_parameter('B97_ss_a1', -0.691682); C.set_parameter('B97_ss_a2', 0.394796). sup.add_x_functional(X); sup.add_c_functional(C). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.21); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_b97d2p4_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('B97-D2P4'); # Tab in, trailing newlines; sup.set_description(' B97-D Pure-GGA Exchange-Correlation Functional\n'); # Tab in, trailing newlines; sup.set_citation(' S. Grimme, J. Comput. Chem., 27, 1787-1799, 2006\n'). # Add member functionals; X = build_functional('B97_X'); X.set_name('B97-D_X'); X.set_alpha(1.0). X.set_parameter('B97_gamma', 0.004); X.set_parameter('B97_a0', 1.08662); X.set_parameter('B97_a1', -0.52127); X.set_parameter('B97_a2', 3.25429). C = build_functional('B_C'); C.set_name('B97-D_C'). C.set_parameter('B97_os_gamma', 0.006); C.set_parameter('B97_os_a0', 0.69041); C.set_parameter('B97_os_a1', 6.30270); C.set_parameter('B97_os_a2', -14.9712). C.set_parameter('B97_ss_gamma', 0.2); C.set_par",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/functional.html:35104,allocate,allocate,35104,psi4manual/4.0b5/_modules/functional.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/functional.html,2,['allocate'],['allocate']
Energy Efficiency," Functional\n'); # Tab in, trailing newlines; sup.set_citation(' P.J. Wilson et. al., J. Chem. Phys., 115(20), 9233-9242, 2001\n'). # Add member functionals; X = build_functional('B97_X'); X.set_name('B97-2_X'); X.set_alpha(1.0 / 0.79). X.set_parameter('B97_gamma', 0.004); X.set_parameter('B97_a0', 0.827642); X.set_parameter('B97_a1', 0.047840); X.set_parameter('B97_a2', 1.761250). C = build_functional('B_C'); C.set_name('B97-2_C'). C.set_parameter('B97_os_gamma', 0.006); C.set_parameter('B97_os_a0', 0.999849); C.set_parameter('B97_os_a1', 1.40626); C.set_parameter('B97_os_a2', -7.44060). C.set_parameter('B97_ss_gamma', 0.2); C.set_parameter('B97_ss_a0', 0.585808); C.set_parameter('B97_ss_a1', -0.691682); C.set_parameter('B97_ss_a2', 0.394796). sup.add_x_functional(X); sup.add_c_functional(C). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.21); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_b97d_superfunctional(name, npoints, deriv):. # Call this first; sup = PsiMod.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('B97-D'); # Tab in, trailing newlines; sup.set_description(' B97-D Pure-GGA Exchange-Correlation Functional\n'); # Tab in, trailing newlines; sup.set_citation(' S. Grimme, J. Comput. Chem., 27, 1787-1799, 2006\n'). # Add member functionals; X = build_functional('B97_X'); X.set_name('B97-D_X'); X.set_alpha(1.0). X.set_parameter('B97_gamma', 0.004); X.set_parameter('B97_a0', 1.08662); X.set_parameter('B97_a1', -0.52127); X.set_parameter('B97_a2', 3.25429). C = build_functional('B_C'); C.set_name('B97-D_C'). C.set_parameter('B97_os_gamma', 0.006); C.set_parameter('B97_os_a0', 0.69041); C.set_parameter('B97_os_a1', 6.30270); C.set_parameter('B97_os_a2', -14.9712). C.set_parameter('B97_ss_gamma', 0.2); C.set_paramet",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/functional.html:31054,allocate,allocate,31054,psi4manual/4.0b2/_modules/functional.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/functional.html,2,['allocate'],['allocate']
Energy Efficiency," GAU_VERYTIGHT [6];  ; \(2.0 \times 10^{-6}\); \(1.0 \times 10^{-6}\); \(6.0 \times 10^{-6}\); \(4.0 \times 10^{-6}\). Footnotes. [1]Default. [2]Baker convergence criteria are the same. [3](1, 2) Counterpart NWCHEM convergence criteria are the same. [4](1, 2, 3) Convergence achieved when all active criteria are fulfilled. [5](1, 2, 3) Convergence achieved when Max Force and one of Max Energy or Max Disp are fulfilled. [6](1, 2, 3, 4, 5) Normal convergence achieved when all four criteria (Max Force, RMS Force,; Max Disp, and RMS Disp) are fulfilled. To help with flat; potential surfaces, alternate convergence achieved when 100\(\times\)rms force is less; than RMS Force criterion. [7]Compensates for difficulties in converging geometry optmizations of supermolecular complexes; tightly, where large rms disp and max disp may result from flat potential surfaces even when; max force and/or rms force are small. For ultimate control, specifying a value for any of the five monitored options activates that; criterium and overwrites/appends it to the criteria set by G_CONVERGENCE.; Note that this revokes the special convergence arrangements detailed in notes [5] and [6]; and instead requires all active criteria to be fulfilled to; achieve convergence. To avoid this revokation, turn on keyword FLEXIBLE_G_CONVERGENCE. Output¶; The progress of a geometry optimization can be monitored by grepping the output file for the; tilde character (~). This produces a table like the one below that shows; for each iteration the value for each of the five quantities and whether the criterion; is active and fulfilled (*), active and unfulfilled ( ), or inactive (o).; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10--------------------------------------------------------------------------------------------- ~; Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~; --------------------------------------------------------------------------------------------- ~; Convergence Criteria 1.00e-06 * 3.00e-04 * o ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/optking-1.html:13948,monitor,monitored,13948,psi4manual/1.2.1/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/optking-1.html,4,['monitor'],['monitored']
Energy Efficiency," GGA Correlation type is B97; C.set_parameter('B97_os_gamma', 0.0031 * 2.0) # This makes me mad. Truhlar is too lazy to report the B97 gradient expansion formula, but then does not use the canonical definition.; C.set_parameter('B97_os_a0', 1.00000); C.set_parameter('B97_os_a1', 1.09297); C.set_parameter('B97_os_a2',-3.79171); C.set_parameter('B97_os_a3', 2.82810); C.set_parameter('B97_os_a4',-10.58909). C.set_parameter('B97_ss_gamma', 0.06); C.set_parameter('B97_ss_a0', 1.00000); C.set_parameter('B97_ss_a1',-3.05430); C.set_parameter('B97_ss_a2', 7.61854); C.set_parameter('B97_ss_a3', 1.47665); C.set_parameter('B97_ss_a4',-11.92365). # Meta Correlation type is Becke metric, no parameters. # Add the functionals in; sup.add_x_functional(X); sup.add_c_functional(C). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.56) # Hartree-Fock exact exchange; sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_primitive_superfunctional(name, npoints, deriv):. # Call this first; sup = PsiMod.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. key = name.upper(); fun = build_functional(key). # No spaces, keep it short and according to convention; sup.set_name(key); # Tab in, trailing newlines; sup.set_description(fun.description()); # Tab in, trailing newlines; sup.set_citation(fun.citation()). # Add member functionals. if (key[-1] == 'X'):; sup.add_x_functional(fun); else:; sup.add_c_functional(fun). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. # Superfunctional lookup table; superfunctionals = {; 's_x' : build_primitive_superfunctional,; 'b88_x' : build_primitive_superfunctional,; 'b3_x' : build_primitive_superfunctional,; 'pbe_x' : build_primitive_sup",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/functional.html:55032,allocate,allocate,55032,psi4manual/4.0b2/_modules/functional.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/functional.html,1,['allocate'],['allocate']
Energy Efficiency," GGA Exchange-Correlation Functional\n'); sup.set_citation(' Adamo et. al., J. Chem. Phys., 110(13), 6158, 1999\n'); sup.set_x_alpha(0.25); return sup. [docs]def build_sogga_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('SOGGA'); # Tab in, trailing newlines; sup.set_description(' Second Order GGA Exchange-Correlation Functional\n'); # Tab in, trailing newlines; sup.set_citation(' Zhao et. al., J. Chem. Phys., 128(18), 184109, 2008\n'). # Add member functionals; sup.add_x_functional(build_functional('SOGGA_X')). C = build_functional('PBE_C'); C.set_parameter('bet', 0.037526); sup.add_c_functional(C). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_b3lyp_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('B3LYP'); # Tab in, trailing newlines; sup.set_description(' B3LYP Hybrid-GGA Exchange-Correlation Functional (VWN1-RPA)\n'); # Tab in, trailing newlines; sup.set_citation(' P.J. Stephens et. al., J. Phys. Chem., 98, 11623-11627, 1994\n'). # Add member functionals; b3 = build_functional('B3_X'); b3.set_alpha(1.0); sup.add_x_functional(b3); lyp = build_functional('LYP_C'); lyp.set_alpha(0.81); vwn = build_functional('VWN3RPA_C'); vwn.set_alpha(0.19); sup.add_c_functional(vwn); sup.add_c_functional(lyp). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.2); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/functional.html:32092,allocate,allocate,32092,psi4manual/1.0.0/_modules/procedures/functional.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/functional.html,1,['allocate'],['allocate']
Energy Efficiency," GGA Exchange-Correlation Functional\n'); sup.set_citation(' Adamo et. al., J. Chem. Phys., 110(13), 6158, 1999\n'); sup.set_x_alpha(0.25); return sup. [docs]def build_sogga_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('SOGGA'); # Tab in, trailing newlines; sup.set_description(' Second Order GGA Exchange-Correlation Functional\n'); # Tab in, trailing newlines; sup.set_citation(' Zhao et. al., J. Chem. Phys., 128(18), 184109, 2008\n'). # Add member functionals; sup.add_x_functional(build_functional('SOGGA_X')). C = build_functional('PBE_C'); C.set_parameter('bet', 0.037526); sup.add_c_functional(C). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_b3lyp_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('B3LYP'); # Tab in, trailing newlines; sup.set_description(' B3LYP Hybrid-GGA Exchange-Correlation Functional\n'); # Tab in, trailing newlines; sup.set_citation(' P.J. Stephens et. al., J. Phys. Chem., 98, 11623-11627, 1994\n'). # Add member functionals; b3 = build_functional('B3_X'); b3.set_alpha(1.0); sup.add_x_functional(b3); lyp = build_functional('LYP_C'); lyp.set_alpha(0.81); vwn = build_functional('VWN3RPA_C'); vwn.set_alpha(0.19); sup.add_c_functional(vwn); sup.add_c_functional(lyp). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.2); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_b",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/functional.html:29046,allocate,allocate,29046,psi4manual/4.0b5/_modules/functional.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/functional.html,1,['allocate'],['allocate']
Energy Efficiency," Gets specialization type of CoordValue. variable_to_string(precision)[source]¶; Takes a CoordValue object, and returns a string for printing. class VariableValue(name, geometryVariables, negate=False, fixed=False)[source]¶; Specialization of CoordValue, where the current value depends; on the list of geometry values stored by the molecule. clone()[source]¶; Returns new, independent VariableValue object. compute()[source]¶; Computes value of coordinate from member data. everything()[source]¶. name()[source]¶; Gets the name of the variable. negated()[source]¶; Gets whether the coordinate value is actually the negative of the variable value. rset(val)[source]¶; Resets value of coordinate if not fixed. type()[source]¶; Gets specialization type of CoordValue. variable_to_string(precision)[source]¶; Takes a CoordValue object, and returns a string for printing. class ZMatrixEntry(entry_number, Z, charge, mass, symbol, label, rto=None, rval=0, ato=None, aval=0, dto=None, dval=0, basis=None, shells=None)[source]¶; Class to hold all information about an atom, including its; coordinate specification as any position of ZMatrix. clone()[source]¶; Returns new, independent ZMatrixEntry object. compute()[source]¶; Compute the Cartesian coordinates in Bohr of current atom’s entry. everything()[source]¶. invalidate()[source]¶; Flags the current coordinates as being outdated. print_in_input_format()[source]¶; Prints the updated geometry, in the format provided by the user. print_in_input_format_cfour()[source]¶; Prints the updated geometry, in the format provided by the user. set_coordinates(x, y, z)[source]¶; Given the current set of coordinates, updates the values of this; atom’s coordinates, and any variables that may depend on it. type()[source]¶; The type of CoordEntry specialization. bond_profile(self)[source]¶; Obtain bonding topology of molecule. missing_bonds(bonds, bond_tree, at_types)[source]¶; Determine number of bonds missing for each atom. missing_neighbors(bond_tree, n_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:117973,charge,charge,117973,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,2,['charge'],['charge']
Energy Efficiency," Gradients are only; available if the ALGORITHM option is set to TWOSTEP or SIMULTANEOUS for; the energy computation. In addition, AO_BASIS option must be set to NONE; (default). Evaluation of the analytic gradients requires the solution of the; coupled response equations. Two algorithms are available for their iterative; solution: two-step (default) and simultaneous. These algorithms are similar to those; described for the orbital and cumulant updates in the Iterative Algorithms; section and usually exhibit the similar efficiency. The choice of the algorithm can; be made using the RESPONSE_ALGORITHM option. For the DC-12 method the; analytic gradients are not yet available, one has to use numerical gradients to; perform the geometry optimizations. Minimal Input¶; Minimal input for the DCFT single-point computation looks like this:; molecule {; H; H 1 1.0; }. set basis 3-21G. energy('dcft'). The energy('dcft') call to energy() executes the DCFT module, which will first call the SCF module and perform the SCF computation with UHF reference to obtain the guess for the DCFT orbitals. After the SCF is converged, the program will perform the energy computation using the DC-06 method. By default, the two-step algorithm will be used for the solution of the equations. Note that while the default value for the option REFERENCE is RHF, this option is set to UHF before the DCFT module is executed. For the DC-06 method one can also request to perform the geometry optimization following the example below:; molecule {; H; H 1 1.0; }. set basis 3-21G. optimize('dcft'). The optimize('dcft') call will first perform all of the procedures; described above to obtain the DC-06 energy. After that the DC-06 analytic; gradients code will be executed to perform the solution of the DCFT response; equations, compute the analytic gradients of the DCFT energy and perform the; geometry optimization. Recommendations¶; Here is the list of the recommendations for the DCFT module:. For the computatio",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/dcft-1.html:10093,energy,energy,10093,psi4manual/4.0b4/dcft-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/dcft-1.html,4,['energy'],['energy']
Energy Efficiency," Grimme, Vol. 24, pp. 1529, J. Comput. Chem.). Type: double; Default: 0.25. E_CONVERGENCE (CCEOM); CCEOM — Convergence criterion for excitation energy (change) in the Davidson algorithm for CC-EOM. Type: conv double; Default: 1e-8. E_CONVERGENCE (DETCI); DETCI — Convergence criterion for energy. Type: conv double; Default: 1e-6. E_CONVERGENCE (LMP2); LMP2 — Convergence criterion for energy (change). Type: conv double; Default: 1e-7. E_CONVERGENCE (MCSCF); MCSCF — Convergence criterion for energy. Type: conv double; Default: 1e-8. E_CONVERGENCE (MRCC); MRCC — This becomes tol (option #16) in fort.56. Type: conv double; Default: 1e-8. E_CONVERGENCE (OMP2); OMP2 — Convergence criterion for energy. Type: conv double; Default: 1e-8. E_CONVERGENCE (OMP3); OMP3 — Convergence criterion for energy. Type: conv double; Default: 1e-8. E_CONVERGENCE (PSIMRCC); PSIMRCC — Convergence criterion for energy. Type: conv double; Default: 1e-9. E_CONVERGENCE (SAPT); SAPT — Convergence criterion for energy (change) in the SAPT term during solution of the CPHF equations. Type: conv double; Default: 1e-10. E_CONVERGENCE (SCF); SCF — Convergence criterion for SCF energy. See Table SCF Convergence & Algorithm for default convergence criteria for different calculation types. Type: conv double; Default: 1e-8. EOM_GUESS (CCEOM); CCEOM — Specifies a set of single-excitation guess vectors for the EOM-CC procedure. If EOM_GUESS = SINGLES, the guess will be taken from the singles-singles block of the similarity-transformed Hamiltonian, Hbar. If EOM_GUESS = DISK, guess vectors from a previous computation will be read from disk. If EOM_GUESS = INPUT, guess vectors will be specified in user input. The latter method is not currently available. Type: string; Possible Values: SINGLES, DISK, INPUT; Default: SINGLES. EOM_REFERENCE (CCEOM); CCEOM — Reference wavefunction type for EOM computations. Type: string; Possible Values: RHF, ROHF, UHF; Default: RHF. EOM_REFERENCE (CCHBAR); CCHBAR — Reference wavefunc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html:36478,energy,energy,36478,psi4manual/4.0b3/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html,2,['energy'],['energy']
Energy Efficiency," H2O Computation. psi4.set_memory('500 MB'). h2o = psi4.geometry(""""""; O; H 1 0.96; H 1 0.96 2 104.5; """"""). psi4.energy('scf/cc-pvdz'). [3]:. -76.02663273488399. If everything goes well, the computation should complete and should report a final restricted Hartree-Fock energy in the output file output.dat in a section like this:; Energy converged. @DF-RHF Final Energy: -76.02663273486682. By default, the energy should be converged to about \(1.0\times 10^{-6}\), so agreement is only expected for about the first 6 digits after the decimal. If the computation does not complete, there is probably a problem with the compilation or installation of the program (see the installation instructions in the main Psi4 manual section Compiling and Installing from Source).; This very simple input is sufficient to run the requested information. Notice we didn’t tell the program some otherwise useful information like the charge of the molecule (0, it’s neutral), the spin multiplicity (1 for a closed-shell molecule with all electrons paired), or the reference wavefunction to use (restricted Hartree-Fock, or RHF, is usually appropriate for a closed-shell molecule). The program correctly guessed all of these options for us. We can change the default behavior through; additional keywords.; Let’s consider what we would do for an open-shell molecule, where not all the electrons are paired. For example, let’s run a computation on methylene (\(\text{CH}_2\)), whose ground electronic state has two unpaired electrons (triplet electronic state, or a spin multiplicity \(2S + 1 = 3\)). In this case, the default spin multiplicity (1) is not correct, so we need to tell the program the true value (3). Like many programs, Psi4 can get the charge and multiplicity as the first two; integers in the Z-matrix (note the line with 0 3 at the beginning of the molecule specification below). In this example, we will also specify the bond length and bond angle as variables (\(R\) and \(A\)), whose values are fir",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psiapi-1.html:4372,charge,charge,4372,psi4manual/1.3.2/psiapi-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psiapi-1.html,6,['charge'],['charge']
Energy Efficiency," H2O \(R_e\) geom from Olsen et al., JCP 104, 8007 (1996). pywrap-freq-e-sowreap; Finite difference of energies frequency, run in sow/reap mode. fsapt-allterms; This test case shows an example of running and analyzing a standard F-SAPT0/jun-cc-pvdz procedure for HSG-18-dimer from the HSG database. cc51; EOM-CC3/cc-pVTZ on H2O. opt12; SCF cc-pVDZ geometry optimzation of ketene, starting from bent structure. scf-ecp; Water-Argon complex with ECP present; check of energies and forces. molden1; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. psimrcc-ccsd_t-3; Mk-MRCCSD(T) single point. \(^1A_1\) CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. cc5; RHF CCSD(T) aug-cc-pvtz frozen-core energy of C4NH4 Anion. mints8; Patch of a glycine with a methyl group, to make alanine, then DF-SCF energy calculation with the cc-pVDZ basis set. psimrcc-fd-freq2; Mk-MRCCSD frequencies. \(^1A_1\) O$_3` state described using the Ms = 0 component of the singlet. Uses TCSCF orbitals. dft-grad2; DF-BP86-D2 cc-pVDZ frozen core gradient of S22 HCN. cepa0-grad2; CEPA cc-pVDZ gradient for the NO radical. tu6-cp-ne2; Example potential energy surface scan and CP-correction for Ne2. sapt7; SAPT0 open-shell computation of H2O-HO2 interaction energy First with cc-pVDZ and density fitted integrals with UHF Then with 6-31g and direct integrals, except for dispersion that is computed with cc-pVDZ-ri density fitting with UHF. mints-benchmark; run some BLAS benchmarks. scf-bs; UHF and broken-symmetry UHF energy for molecular hydrogen. fci-tdm; He2+ FCI/cc-pVDZ Transition Dipole Moment. omp2p5-grad2; OMP2.5 cc-pVDZ gradient for the NO radical. fci-h2o-fzcv; 6-31G H2O Test FCI Energy Point. sa",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html:38598,energy,energy,38598,psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency," H2O+ with EOM-CCSD. castup1; Test of SAD/Cast-up (mainly not dying due to file weirdness). dfomp3-grad1; DF-OMP3 cc-pVDZ gradients for the H2O molecule. pywrap-alias; Test parsed and exotic calls to energy() like zapt4, mp2.5, and cisd are working. fci-dipole; 6-31G H2O Test FCI Energy Point. cc2; 6-31G** H2O CCSD optimization by energies, with Z-Matrix input. dft1; DFT Functional Test. cc11; Frozen-core CCSD(ROHF)/cc-pVDZ on CN radical with disk-based AO algorithm. pywrap-cbs1; Various basis set extrapolation tests. dft-grad; DF-BP86-D2 cc-pVDZ frozen core gradient of S22 HCN. x2c3; Test of SFX2C-1e on Water uncontracted cc-pVDZ The reference numbers are from Lan Cheng’s implementation in Cfour. cubeprop-esp; RHF orbitals and density for water. cc49; EOM-CC3(UHF) on CH radical with user-specified basis and properties for particular root. opt-multi-dimer-c1; Multi-fragment opt of C2h methane dimer with user-combined reference points. pywrap-checkrun-uhf; This checks that all energy methods can run with a minimal input and set symmetry. cc13c; Tests RHF CCSD(T)gradients. mom; Maximum Overlap Method (MOM) Test. MOM is designed to stabilize SCF convergence and to target excited Slater determinants directly. zaptn-nh2; ZAPT(n)/6-31G NH2 Energy Point, with n=2-25. omp2-grad1; OMP2 cc-pVDZ gradient for the H2O molecule. pywrap-checkrun-convcrit; Advanced python example sets different sets of scf/post-scf conv crit and check to be sure computation has actually converged to the expected accuracy. dfrasscf-sp; 6-31G** H2O Test RASSCF Energy Point will default to only singles and doubles in the active space. ao-casscf-sp; CASSCF/6-31G** energy point. tu2-ch2-energy; Sample UHF/6-31G** CH2 computation. opt13; B3LYP cc-pVDZ geometry optimzation of phenylacetylene, starting from not quite linear structure. dft-b3lyp; Check flavors of B3LYP (b3lyp3/b3lyp5) against other programs. dfomp2-grad1; DF-OMP2 cc-pVDZ gradients for the H2O molecule. psimrcc-fd-freq1; Mk-MRCCSD single poi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/testsuite-1.html:11793,energy,energy,11793,psi4manual/1.1.0/testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/testsuite-1.html,4,['energy'],['energy']
Energy Efficiency," H2O2. gauge = both, omega = (589 355 nm). dct-grad2; RHF-ODC-12 analytic gradient computations for H2O use AO_BASIS=DISK and AO_BASIS=NONE, respectively. RHF-ODC-06 analytic gradient computations for H2O use AO_BASIS=DISK and AO_BASIS=NONE, respectively. opt-multi-dimer-c2h; Multi-fragment opt of C2h methane dimer with user-combined reference points. options1; check all variety of options parsing. dfccsd1; DF-CCSD cc-pVDZ energy for the H2O molecule. mbis-2; MBIS calculation on OH- (Expanded Arrays). scf-bz2; Benzene Dimer Out-of-Core HF/cc-pVDZ. fnocc3; Test FNO-QCISD(T) computation. dft-omega; Test omega is setable updated wb97x_20,wb97x_03 to account for new BraggSlater radii. cepa-module; routing check on lccd, lccsd, cepa(0). opt6; Various constrained energy minimizations of HOOH with cc-pvdz RHF Internal-coordinate constraints in internal-coordinate optimizations. dfomp2p5-1; DF-OMP2.5 cc-pVDZ energy for the H2O molecule. cc8a; ROHF-CCSD(T) cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Cartesian input. scf-dipder; Test SCF dipole derivatives against old Psi3 reference values. tu3-h2o-opt; Optimize H2O HF/cc-pVDZ. dft-dens-cut; LibXC density screening test. Tests empty, C-only, X-only and XC superfunctionals. ‘super_mix’ showcases how to use different screening values for X and C parts. SCF will fail or crash (nans) without screening!. aediis-2; EDIIS test case from 10.1063/1.1470195. cc56; EOM-CCSD/6-31g excited state transition data for water cation. scf-uhf-grad-nobeta; UHF gradient for a one-electron system (no beta electrons). dfomp3-grad2; DF-OMP3 cc-pVDZ gradients for the H2O+ cation. dfmp2-grad5; Tests DF-MP2 gradient in the presence of a dipole field. dfmp2-grad3; DF-MP2 cc-pVDZ gradients for the H2O molecule. scf-response2; Compute the dipole polarizability for water with custom basis set. sapt7; SAPT0 open-shell computation of H2O-HO2 interaction energy First with cc-pVDZ and density fitted integrals with UHF Then w",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html:22599,energy,energy,22599,psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency," H2OH2O.fz(4); 0.0. """"""; return self.input_units_to_au * self.full_atoms[atom].compute()[2]. [docs] def fxyz(self, atom):; """"""Returns a Vector3 with x, y, z position of atom; (0-indexed) in Bohr (includes dummies). >>> print H2OH2O.fxyz(4); [2.5523113582286716, 0.21064588230662976, 0.0]. """"""; return scale(self.full_atoms[atom].compute(), self.input_units_to_au). [docs] def fmass(self, atom):; """"""Returns mass of atom (0-indexed, includes dummies). >>> print H2OH2O.fmass(4); 15.9949146196. """"""; return self.full_atoms[atom].mass(). [docs] def fsymbol(self, atom):; """"""Returns the cleaned up label of the atom (C2 => C, H4 = H) (includes dummies) (0-indexed). >>> print H2OH2O.fsymbol(4); O. """"""; return self.full_atoms[atom].symbol(). [docs] def flabel(self, atom):; """"""Returns the original label of the atom (0-indexed) as given in; the input file (C2, H4) (includes dummies). >>> print H2OH2O.flabel(4); O2. """"""; return self.full_atoms[atom].label(). [docs] def fcharge(self, atom):; """"""Returns charge of atom (0-indexed, includes dummies).; Related to SAD guess in libmints version. >>> print H2OH2O.fcharge(4); 8.0. """"""; return self.full_atoms[atom].charge(). # <<< Simple Methods for Fragmentation >>>. [docs] def nfragments(self):; """"""The number of fragments in the molecule. >>> print H2OH2O.nfragments(); 2. """"""; return len(self.fragments). [docs] def nactive_fragments(self):; """"""The number of active fragments in the molecule. >>> print H2OH2O.nactive_fragments(); 2. """"""; n = 0; for fr in range(self.nfragments()):; if self.fragment_types[fr] == 'Real':; n += 1; return n. [docs] def activate_all_fragments(self):; """"""Sets all fragments in the molecule to be active.""""""; self.lock_frame = False; for fr in range(self.nfragments()):; self.fragment_types[fr] = 'Real'. [docs] def set_active_fragment(self, fr):; """"""Tags fragment index *fr* as composed of real atoms.""""""; self.lock_frame = False; self.fragment_types[fr - 1] = 'Real'. [docs] def set_active_fragments(self, reals):; """"""Tags",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:11052,charge,charge,11052,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,1,['charge'],['charge']
Energy Efficiency," H2OH2O.multiplicity(). multiplicity_specified()[source]¶; Whether the multiplicity was given by the user; >>> print H2OH2O.multiplicity_specified(); True. nactive_fragments()[source]¶; The number of active fragments in the molecule.; >>> print H2OH2O.nactive_fragments(); 2. nallatom()[source]¶; Number of all atoms (includes dummies); >>> print H2OH2O.nallatom(); 7. name()[source]¶; Get molecule name; >>> print H2OH2O.name(); water_dimer. natom()[source]¶; Number of atoms; >>> print H2OH2O.natom(); 6. nequivalent(iuniq)[source]¶; Returns the number of atoms equivalent to iuniq. nfragments()[source]¶; The number of fragments in the molecule.; >>> print H2OH2O.nfragments(); 2. nfrozen_core(depth=False)[source]¶; Number of frozen core for molecule given freezing state.; >>> print H2OH2O.nfrozen_core(); 2. nuclear_repulsion_energy()[source]¶; Computes nuclear repulsion energy.; >>> print H2OH2O.nuclear_repulsion_energy(); 36.6628478528. nuclear_repulsion_energy_deriv1()[source]¶; Computes nuclear repulsion energy derivatives; >>> print H2OH2O.nuclear_repulsion_energy_deriv1(); [[3.9020946901323774, 2.76201566471991, 0.0], [1.3172905807089021, -2.3486366050337293, 0.0], [-1.8107598525022435, -0.32511212499256564, 0.0], [-1.217656141385739, -2.6120090867576717, 0.0], [-1.0954846384766488, 1.2618710760320282, 2.1130743287465603], [-1.0954846384766488, 1.2618710760320282, -2.1130743287465603]]. nuclear_repulsion_energy_deriv2()[source]¶; NYI Computes nuclear repulsion energy second derivatives. nunique()[source]¶; Return the number of unique atoms. orientation_fixed()[source]¶; Get whether or not orientation is fixed.; >>> H2OH2O.orientation_fixed(); True. point_group()[source]¶; Returns the point group (object) if set. print_bond_angles()[source]¶; Print the geometrical parameters (bond_angles) of the molecule.; >>> print H2OH2O.print_bond_angles(); Bond Angles (degrees); Angle 2-1-3: 104.337; Angle 2-1-4: 109.152; Angle 2-1-5: 117.387; ... print_dihedrals()[source]¶; Print",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:85514,energy,energy,85514,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,2,['energy'],['energy']
Energy Efficiency," H2OH2O.print_bond_angles(); Bond Angles (degrees); Angle 2-1-3: 104.337; Angle 2-1-4: 109.152; Angle 2-1-5: 117.387; ... print_dihedrals()[source]¶; Print the geometrical parameters (dihedrals) of the molecule.; >>> print H2OH2O.print_dihedrals(); Dihedral Angles (Degrees); Dihedral 1-2-3-4: 180.000; Dihedral 1-2-3-5: 133.511; Dihedral 1-2-3-6: 133.511; ... print_distances()[source]¶; Print the geometrical parameters (distances) of the molecule.; suspect libmints version actually prints Bohr.; >>> print H2OH2O.print_distances(); Interatomic Distances (Angstroms); Distance 1 to 2 0.957; Distance 1 to 3 0.964; Distance 1 to 4 2.910; ... print_full()[source]¶; Print full atom list. Same as print_out() only displays dummy atoms. print_in_input_format()[source]¶; Print the molecule in the same format that the user provided. print_out()[source]¶; Print the molecule.; (method name in libmints is print); >>> H2OH2O.print_out(); Geometry (in Angstrom), charge = -2, multiplicity = 3:; Center X Y Z; ------------ ----------------- ----------------- -----------------; O -1.551007000000 -0.114520000000 0.000000000000; H -1.934259000000 0.762503000000 0.000000000000; H -0.599677000000 0.040712000000 0.000000000000; O 1.350625000000 0.111469000000 0.000000000000; H 1.680398000000 -0.373741000000 -0.758561000000; H 1.680398000000 -0.373741000000 0.758561000000. print_out_in_angstrom()[source]¶; Print the molecule in Angstroms. Same as print_out() only always in Angstroms.; (method name in libmints is print_in_angstrom). print_out_in_bohr()[source]¶; Print the molecule in Bohr. Same as print_out() only in Bohr.; (method name in libmints is print_in_bohr). print_out_of_planes()[source]¶; Print the geometrical parameters (out_of_planes) of the molecule.; >>> print H2OH2O.print_out_of_planes(); Out-Of-Plane Angles (Degrees); Out-of-plane 1-2-3-4: 0.000; Out-of-plane 1-2-3-5: -7.373; Out-of-plane 1-2-3-6: 7.373; ... reinterpret_coordentries()[source]¶; Reinterpret the fragments for real",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:87301,charge,charge,87301,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,4,['charge'],['charge']
Energy Efficiency," HF(2) ENERGY ABC(HF)¶; The total Hartree–Fock energy [Eh] of the supersystem implemented for F/I-SAPT. SAPT HF(2) ENERGY AC(0)¶; The Hartree–Fock energy [Eh] of subsystems A and C implemented for F/I-SAPT. SAPT HF(2) ENERGY BC(0)¶; The Hartree–Fock energy [Eh] of subsystems B and C implemented for F/I-SAPT. SAPT HF(2) ENERGY A(0)¶; The Hartree–Fock energy [Eh] of subsystem A implemented for F/I-SAPT. SAPT HF(2) ENERGY B(0)¶; The Hartree–Fock energy [Eh] of subsystem B implemented for F/I-SAPT. SAPT HF(2) ENERGY AC(HF)¶; The Hartree–Fock localized energy [Eh] of subsystems A and C implemented for F/I-SAPT. SAPT HF(2) ENERGY BC(HF)¶; The Hartree–Fock localized energy [Eh] of subsystems B and C implemented for F/I-SAPT. SAPT HF(2) ENERGY AB(HF)¶; The Hartree–Fock localized energy [Eh] of subsystems A and B implemented for F/I-SAPT. SAPT HF(2) ENERGY A(HF)¶; The Hartree–Fock localized energy [Eh] of subsystem A implemented for F/I-SAPT. SAPT HF(2) ENERGY B(HF)¶; The Hartree–Fock localized energy [Eh] of subsystem B implemented for F/I-SAPT. SAPT HF(2) ENERGY C¶; The Hartree–Fock energy [Eh] of subsystem C implemented for F/I-SAPT. SAPT HF(2) ENERGY HF¶; The FI-SAPT Hartree–Fock interaction energy [Eh] implemented for F/I-SAPT. SAPT ELST12,R ENERGY¶; An electrostatics-classified SAPT term energy [Eh] implemented for SAPT2. SAPT EXCH11(S^2) ENERGY¶. SAPT EXCH12(S^2) ENERGY¶; An exchange-classified SAPT term energy [Eh] implemented for SAPT2. SAPT IND22 ENERGY¶. SAPT EXCH-IND22 ENERGY¶; An induction-classified SAPT term energy [Eh] implemented for SAPT2. SAPT DISP21 ENERGY¶; A dispersion-classified SAPT term energy [Eh] implemented for SAPT2+. SAPT DISP22(SDQ) ENERGY¶. SAPT DISP22(T) ENERGY¶. SAPT EST.DISP22(T) ENERGY¶; Dispersion-classified MBPT-based SAPT term energy [Eh] implemented for SAPT2+. SAPT DISP2(CCD) ENERGY¶. SAPT DISP22(S)(CCD) ENERGY¶. SAPT DISP22(T)(CCD) ENERGY¶. SAPT EST.DISP22(T)(CCD) ENERGY¶; Dispersion-classified coupled-cluster-based SAPT term energy ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html:37356,energy,energy,37356,psi4manual/1.4.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html,5,['energy'],['energy']
Energy Efficiency," HF(2) ENERGY AC(0)¶; The Hartree–Fock energy [E_h] of subsystems A and C implemented for F/I-SAPT. SAPT HF(2) ENERGY BC(0)¶; The Hartree–Fock energy [E_h] of subsystems B and C implemented for F/I-SAPT. SAPT HF(2) ENERGY A(0)¶; The Hartree–Fock energy [E_h] of subsystem A implemented for F/I-SAPT. SAPT HF(2) ENERGY B(0)¶; The Hartree–Fock energy [E_h] of subsystem B implemented for F/I-SAPT. SAPT HF(2) ENERGY AC(HF)¶; The Hartree–Fock localized energy [E_h] of subsystems A and C implemented for F/I-SAPT. SAPT HF(2) ENERGY BC(HF)¶; The Hartree–Fock localized energy [E_h] of subsystems B and C implemented for F/I-SAPT. SAPT HF(2) ENERGY AB(HF)¶; The Hartree–Fock localized energy [E_h] of subsystems A and B implemented for F/I-SAPT. SAPT HF(2) ENERGY A(HF)¶; The Hartree–Fock localized energy [E_h] of subsystem A implemented for F/I-SAPT. SAPT HF(2) ENERGY B(HF)¶; The Hartree–Fock localized energy [E_h] of subsystem B implemented for F/I-SAPT. SAPT HF(2) ENERGY C¶; The Hartree–Fock energy [E_h] of subsystem C implemented for F/I-SAPT. SAPT HF(2) ENERGY HF¶; The FI-SAPT Hartree–Fock interaction energy [E_h] implemented for F/I-SAPT. SAPT ELST12,R ENERGY¶; An electrostatics-classified SAPT term energy [E_h] implemented for SAPT2. SAPT EXCH11(S^2) ENERGY¶. SAPT EXCH12(S^2) ENERGY¶; An exchange-classified SAPT term energy [E_h] implemented for SAPT2. SAPT IND22 ENERGY¶. SAPT EXCH-IND22 ENERGY¶; An induction-classified SAPT term energy [E_h] implemented for SAPT2. SAPT DISP21 ENERGY¶; A dispersion-classified SAPT term energy [E_h] implemented for SAPT2+. SAPT DISP22(SDQ) ENERGY¶. SAPT DISP22(T) ENERGY¶. SAPT EST.DISP22(T) ENERGY¶; Dispersion-classified MBPT-based SAPT term energy [E_h] implemented for SAPT2+. SAPT DISP2(CCD) ENERGY¶. SAPT DISP22(S)(CCD) ENERGY¶. SAPT DISP22(T)(CCD) ENERGY¶. SAPT EST.DISP22(T)(CCD) ENERGY¶; Dispersion-classified coupled-cluster-based SAPT term energy [E_h] implemented for SAPT2+. SAPT ELST13,R ENERGY¶; An electrostatics-classified SAPT term e",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html:47811,energy,energy,47811,psi4manual/1.7.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html,4,['energy'],['energy']
Energy Efficiency," HOMO > 0:; Na = Na - 1; else:; Nb = Nb - 1; charge = charge + 1; mult = Na - Nb + 1. psi4.set_global_option(""DF_INTS_IO"", ""LOAD""); psi4.set_global_option(""FRAC_START"", frac_start); psi4.set_global_option(""FRAC_RENORMALIZE"", True). # Nuke 'em Rico!; for Nintegral in range(N, Nmin, -1):. # Nuke the current HOMO; for occ in foccs:. psi4.set_global_option(""FRAC_OCC"", [HOMO]); psi4.set_global_option(""FRAC_VAL"", [occ]). E, wfn = energy('scf', return_wfn=True, molecule=molecule, **kwargs); C = 1; if E == 0.0:; E = psi4.get_variable('SCF ITERATION ENERGY'); C = 0. if HOMO > 0:; eps = wfn.epsilon_a(); potentials.append(eps[HOMO - 1]); else:; eps = wfn.epsilon_b(); potentials.append(eps[-HOMO - 1]). Ns.append(Nintegral + occ - 1.0); energies.append(E); convs.append(C). psi4.set_global_option(""FRAC_START"", 2); psi4.set_global_option(""FRAC_LOAD"", True); psi4.set_global_option(""FRAC_DIIS"", frac_diis); psi4.set_global_option(""GUESS"", ""READ""). # Set the next charge/mult; molecule.set_molecular_charge(charge); molecule.set_multiplicity(mult). # Determine HOMO; print('DGAS: What ref should this point to?'); #ref = psi4.legacy_wavefunction(); eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); if Na == Nb:; HOMO = -Nb; elif Nb == 0:; HOMO = Na; else:; E_a = eps_a[int(Na - 1)]; E_b = eps_b[int(Nb - 1)]; if E_a >= E_b:; HOMO = Na; else:; HOMO = -Nb. stats.append(""""""\t%6d %6d %6d %6d %6d %6d\n"""""" % (Nintegral-1, Na, Nb, charge, mult, HOMO)). if HOMO > 0:; Na = Na - 1; else:; Nb = Nb - 1; charge = charge + 1; mult = Na - Nb + 1. psi4.set_global_option(""DF_INTS_IO"", ""NONE""). # => Print the results out <= #; E = {}; psi4.print_out(""""""\n ==> Fractional Occupation Nuke Results <==\n\n""""""); psi4.print_out(""""""\t%-11s %-24s %-24s %11s\n"""""" % ('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(len(Ns)):; psi4.print_out(""""""\t%11.3E %24.16E %24.16E %11d\n"""""" % (Ns[k], energies[k], potentials[k], convs[k])); E[Ns[k]] = energies[k]. psi4.print_out('\n'); psi4.print_out(""""""\t%6s %6s %6s %6s %6",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/frac.html:9769,charge,charge,9769,psi4manual/1.0.0/_modules/frac.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/frac.html,1,['charge'],['charge']
Energy Efficiency," HOOH with cc-pvdz RHF. Cartesian-coordinate constrained optimizations of HOOH in internals. cc9a; ROHF-CCSD(T) cc-pVDZ energy for the \(^2\Sigma^+\) state of the CN radical, with Z-matrix input. mints1; Symmetry tests for a range of molecules. This doesn’t actually compute any energies, but serves as an example of the many ways to specify geometries in Psi4. dfmp2-grad5; Tests DF-MP2 gradient in the presence of a dipole field. pywrap-db3; Test that Python Molecule class processes geometry like psi4 Molecule class. fcidump; test FCIDUMP functionality for rhf/uhf. cc16; ROHF and UHF-B-CCD(T)/cc-pVDZ \(^{3}B_1\) CH2 single-point energy (fzc, MO-basis \(\langle ab|cd \rangle\) ). fci-h2o; 6-31G H2O Test FCI Energy Point. ocepa1; OCEPA cc-pVDZ energy for the H2O molecule. dft-custom-gga; DFT (LDA/GGA) test of custom implementations in: gga_superfuncs.py. opt-multi-dimer-c2h; Multi-fragment opt of C2h methane dimer with user-combined reference points. fd-freq-energy; SCF STO-3G finite-difference frequencies from energies for H2O. cc30; CCSD/sto-3g optical rotation calculation (length gauge only) at two frequencies on methyloxirane. nbody-convergence; Convergence of many-body gradients of different BSSE schemes. numpy-array-interface; Numpy interface testing. ghosts; Density fitted MP2 cc-PVDZ/cc-pVDZ-RI computation of formic acid dimer binding energy using explicit specification of ghost atoms. This is equivalent to the dfmp2_1 sample but uses both (equivalent) specifications of ghost atoms in a manual counterpoise correction. mints-helper; A general test of the MintsHelper function. sapt3; SAPT2+3(CCD) aug-cc-pVDZ+midbond computation of the water dimer interaction energy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. mints4; A demonstration of mixed Cartesian/ZMatrix geometry specification, using variables, for the benzene-hydronium complex. Atoms can be placed using ZMatrix coordinates, whether they belong to the same fragment or not. Note t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html:20115,energy,energy,20115,psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency," Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :raises: psi4.ConvergenceError if |optking__geom_maxiter| exceeded without reaching geometry convergence. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY <CURRENTENERGY>`. :type name: string; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`~driver.energy`. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. For maximum; flexibility, ``return_wfn`` is always on in ``'reap'`` mode. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicate",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html:50302,energy,energy,50302,psi4manual/1.1.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html,1,['energy'],['energy']
Energy Efficiency," Helium complex Size vs cost tradeoff is rough here. cc13d; Tests analytic CC2 gradients. scf5; Test of all different algorithms and reference types for SCF, on singlet and triplet O2, using the cc-pVTZ basis set. omp2-3; OMP2 cc-pVDZ energy for the NO radical. scf2; RI-SCF cc-pVTZ energy of water, with Z-matrix input and cc-pVTZ-RI auxilliary basis. cc36; CC2(RHF)/cc-pVDZ energy of H2O. mints3; Test individual integral objects for correctness. options1; check all variety of options parsing. cc5a; RHF CCSD(T) STO-3G frozen-core energy of C4NH4 Anion. omp2-1; OMP2 cc-pVDZ energy for the H2O molecule. cc19; CCSD/cc-pVDZ dipole polarizability at two frequencies. ocepa-grad1; OCEPA cc-pVDZ gradient for the H2O molecule. dfccsdat1; DF-CCSD(AT) cc-pVDZ energy for the H2O molecule. dcft4; DCFT calculation for the HF+ using DC-06 functional. This performs both two-step and simultaneous update of the orbitals and cumulant using DIIS extrapolation. Four-virtual integrals are first handled in the MO Basis for the first two energy computations. In the next two the ao_basis=disk algorithm is used, where the transformation of integrals for four-virtual case is avoided. The computation is then repeated using the DC-12 functional with the same algorithms. mp2-module; OMP2 cc-pVDZ energy for the H2O molecule. cc28; CCSD/cc-pVDZ optical rotation calculation (length gauge only) on Z-mat H2O2. fnocc1; Test QCISD(T) for H2O/cc-pvdz Energy. dfccd1; DF-CCD cc-pVDZ energy for the H2O molecule. opt2-fd; SCF DZ allene geometry optimzation, with Cartesian input. dfomp2-2; OMP2 cc-pVDZ energy for the NO molecule. dcft6; DCFT calculation for the triplet O2 using DC-06, DC-12 and CEPA0 functionals. Only two-step algorithm is tested. dfep2-2; Compute three IP and 2 EA’s for the PH3 molecule. pywrap-bfs; apply linear fragmentation algorithm to a water cluster. omp3-grad1; OMP3 cc-pVDZ gradient for the H2O molecule. pywrap-freq-g-sowreap; Finite difference of gradients frequency, run in sow/reap mo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html:7023,energy,energy,7023,psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency," Helium complex Size vs cost tradeoff is rough here. cc13d; Tests analytic CC2 gradients. scf5; Test of all different algorithms and reference types for SCF, on singlet and triplet O2, using the cc-pVTZ basis set. omp2-3; OMP2 cc-pVDZ energy for the NO radical. scf2; RI-SCF cc-pVTZ energy of water, with Z-matrix input and cc-pVTZ-RI auxilliary basis. cc36; CC2(RHF)/cc-pVDZ energy of H2O. mints3; Test individual integral objects for correctness. options1; check all variety of options parsing. cc5a; RHF CCSD(T) STO-3G frozen-core energy of C4NH4 Anion. omp2-1; OMP2 cc-pVDZ energy for the H2O molecule. cc19; CCSD/cc-pVDZ dipole polarizability at two frequencies. ocepa-grad1; OCEPA cc-pVDZ gradient for the H2O molecule. dfccsdat1; DF-CCSD(AT) cc-pVDZ energy for the H2O molecule. dcft4; DCFT calculation for the HF+ using DC-06 functional. This performs both two-step and simultaneous update of the orbitals and cumulant using DIIS extrapolation. Four-virtual integrals are first handled in the MO Basis for the first two energy computations. In the next two the ao_basis=disk algorithm is used, where the transformation of integrals for four-virtual case is avoided. The computation is then repeated using the DC-12 functional with the same algorithms. mp2-module; OMP2 cc-pVDZ energy for the H2O molecule. cc28; CCSD/cc-pVDZ optical rotation calculation (length gauge only) on Z-mat H2O2. fnocc1; Test QCISD(T) for H2O/cc-pvdz Energy. dfccd1; DF-CCD cc-pVDZ energy for the H2O molecule. opt2-fd; SCF DZ allene geometry optimzation, with Cartesian input. dfomp2-2; OMP2 cc-pVDZ energy for the NO molecule. dcft6; DCFT calculation for the triplet O2 using DC-06, DC-12 and CEPA0 functionals. Only two-step algorithm is tested. omp3-grad1; OMP3 cc-pVDZ gradient for the H2O molecule. pywrap-freq-g-sowreap; Finite difference of gradients frequency, run in sow/reap mode. cc48; reproduces dipole moments in J.F. Stanton’s “biorthogonal” JCP paper. dfccd-grad1; DF-CCSD cc-pVDZ gradients for the H",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/testsuite-1.html:6437,energy,energy,6437,psi4manual/1.1.0/testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/testsuite-1.html,4,['energy'],['energy']
Energy Efficiency," Helium complex Size vs cost tradeoff is rough here. cc13d; Tests analytic CC2 gradients. scf5; Test of all different algorithms and reference types for SCF, on singlet and triplet O2, using the cc-pVTZ basis set. omp2-3; OMP2 cc-pVDZ energy for the NO radical. scf2; RI-SCF cc-pVTZ energy of water, with Z-matrix input and cc-pVTZ-RI auxilliary basis. cc36; CC2(RHF)/cc-pVDZ energy of H2O. mints3; Test individual integral objects for correctness. options1; check all variety of options parsing. cc5a; RHF CCSD(T) STO-3G frozen-core energy of C4NH4 Anion. omp2-1; OMP2 cc-pVDZ energy for the H2O molecule. cc19; CCSD/cc-pVDZ dipole polarizability at two frequencies. ocepa-grad1; OCEPA cc-pVDZ gradient for the H2O molecule. dfccsdat1; DF-CCSD(AT) cc-pVDZ energy for the H2O molecule. dcft4; DCFT calculation for the HF+ using DC-06 functional. This performs both two-step and simultaneous update of the orbitals and cumulant using DIIS extrapolation. Four-virtual integrals are first handled in the MO Basis for the first two energy computations. In the next two the ao_basis=disk algorithm is used, where the transformation of integrals for four-virtual case is avoided. The computation is then repeated using the DC-12 functional with the same algorithms. mp2-module; OMP2 cc-pVDZ energy for the H2O molecule. cc28; CCSD/cc-pVDZ optical rotation calculation (length gauge only) on Z-mat H2O2. fnocc1; Test QCISD(T) for H2O/cc-pvdz Energy. dft-bench-interaction; functionals + DFTD3 interaction energies vs. other programs. dfccd1; DF-CCD cc-pVDZ energy for the H2O molecule. opt2-fd; SCF DZ allene geometry optimzation, with Cartesian input. dfomp2-2; OMP2 cc-pVDZ energy for the NO molecule. dcft6; DCFT calculation for the triplet O2 using DC-06, DC-12 and CEPA0 functionals. Only two-step algorithm is tested. dfep2-2; Compute three IP and 2 EA’s for the PH3 molecule. pywrap-bfs; apply linear fragmentation algorithm to a water cluster. omp3-grad1; OMP3 cc-pVDZ gradient for the H2O molecule.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html:6398,energy,energy,6398,psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency," Hessian of the Wavefunction. compute_state_transfer(self: psi4.core.CIWavefunction, arg0: psi::detci::CIvect, arg1: int, arg2: psi4.core.Matrix, arg3: psi::detci::CIvect) → None¶; docstring. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. del_array_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) Matrix QC variable. del_scalar_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) double QC variable. del_variable(key)¶. density_fitted(self: psi4.core.Wavefunction) → bool¶; Returns whether this wavefunction was obtained using density fitting or not. diag_h(self: psi4.core.CIWavefunction, arg0: float, arg1: float) → int¶; docstring. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. efzc(self: psi4.core.Wavefunction) → float¶; Returns the frozen-core energy. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunction’s energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Beta Eigenvalues subset. esp_at_nuclei(self: psi4.core.Wavefunction) → psi4.core.Vector¶; returns electrostatic potentials at nuclei. force_doccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use only. Sets the number of doubly occupied oribtals per irrep. Note that this results in inconsistent Wavefunction objects for SCF, so caution is advised. force_soccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use onl",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psi4api-1.html:25760,energy,energy,25760,psi4manual/1.3.2/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psi4api-1.html,2,['energy'],['energy']
Energy Efficiency," If you installed the Psi4conda distribution or installed the PSI4; conda package into the main environment of an Anaconda or Miniconda; distribution and added that to your PATH, as prompted, then; which psi4 likely yields condadist/bin/psi4 and the PATH; setting lines below are redundant.; If you installed into a conda environment p4env and performed; conda activate p4env, then which psi4 likely yields; condadist/envs/p4env/bin/psi4 and the PATH setting lines; below are redundant.; # csh, tcsh: add to shell or ~/.tcshrc file; unsetenv PSIDATADIR; setenv PATH {prefix}/bin:$PATH; setenv PSI_SCRATCH /path/to/existing/writable/local-not-network/directory/for/scratch/files. # sh, bash: add to shell or ~/.bashrc (Linux/Windows) or ~/.bash_profile (Mac) file; unset PSIDATADIR; export PATH={prefix}/bin:$PATH; export PSI_SCRATCH=/path/to/existing/writable/local-not-network/directory/for/scratch/files. Run PSI4 as executable.; 1; 2; 3; 4; 5; 6; 7; 8>>> cat sample.in; molecule {; He; }; energy('hf/cc-pvdz'); compare_values(-2.85518839, get_variable('current energy'), 5, 'SCF E'); >>> psi4 sample.in; SCF E.............................................................PASSED. or Run PSI4 as Python module.; 1; 2; 3; 4; 5; 6; 7; 8; 9>>> cat sample.py; import psi4; mol = psi4.geometry(""""""; He; """"""); psi4.energy('hf/cc-pvdz'); psi4.compare_values(-2.85518839, psi4.core.get_variable('current energy'), 5, 'SCF E'); >>> python sample.py; SCF E.............................................................PASSED. How to run Psi4 as executable after compilation using driver from source¶; When developing python driver code, it can be annoying to keep makeing to test the code. PSI4 can be run “inplace” through the; following procedure. To be clear, this is running compiled C++ from the; build directory and python from the source directory. This is an expert; option for development, and not all functionality will be available.; 1; 2; 3>>> cd {objdir}; >>> ln -s {top-level-psi4-dir}/{objdir}/sta",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/build_planning-1.html:27346,energy,energy,27346,psi4manual/1.3.2/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/build_planning-1.html,2,['energy'],['energy']
Energy Efficiency," In rare cases with systems having a high degree of symmetry,; PSI4 gives (very obviously) wrong answers for SAPT computations; when the specification is in Z-matrix format. Use a Cartesian representation; to avoid this problem. Caution; In early versions (notably PSI4 alpha circa 2011; and before), frozen core was implemented incompletely and for; only selected terms. Comparisons with papers published using early; PSI4 SAPT code may show discrepancies of 0.01-0.10 kcal/mol in; individual terms, particularly \(E_{exch}^{(11)}\) and \(E_{exch}^{(12)}\). Caution; January 28th 2016, the default for all NAT_ORBS options; was changed to true. Hence the code now by default uses natural; orbital truncation to speed up the evaluation of energy terms; wherever possible, according to literature recommendations.; In early July 2016, some total SAPT energy psivars were renamed. Symmetry-adapted perturbation theory (SAPT) provides a means of directly; computing the noncovalent interaction between two molecules, that is, the; interaction energy is determined without computing the total energy of the; monomers or dimer. In addition, SAPT provides a decomposition of the; interaction energy into physically meaningful components: i.e.,; electrostatic, exchange, induction, and dispersion terms. In SAPT, the; Hamiltonian of the dimer is partitioned into contributions from each; monomer and the interaction. \[H=F_A+W_A+F_B+W_B+V\]; Here, the Hamiltonian is written as a sum of the usual monomer Fock; operators, \(F\), the fluctuation potential of each monomer, \(W\), and the; interaction potential, \(V\). The monomer Fock operators, \(F_A+F_B\), are; treated as the zeroth-order Hamiltonian and the interaction energy is; evaluated through a perturbative expansion of \(V\), \(W_A\), and \(W_B\).; Through first-order in \(V\), electrostatic and exchange interactions are; included; induction and dispersion first appear at second-order in \(V\). For; a complete description of SAPT, the reader",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/sapt-1.html:1273,adapt,adapted,1273,psi4manual/1.1.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/sapt-1.html,18,"['adapt', 'energy']","['adapted', 'energy']"
Energy Efficiency," In sow/reap mode, use only global options (e.g., the local option set by set scf scf_type df will not be respected). Note; To access a database that is not embedded in a PSI4 ; distribution, add the path to the directory containing the database ; to the environment variable PYTHONPATH. Parameters:; name (string) – 'scf' || 'sapt0' || 'ccsd(t)' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). db_name (string) – 'BASIC' || 'S22' || 'HTBH' || etc.; Second argument, usually unlabeled. Indicates the requested database; name, matching (case insensitive) the name of a python file in ; psi4/lib/databases or PYTHONPATH. Consult that ; directory for available databases and literature citations. func (function) – energy || optimize || cbs; Indicates the type of calculation to be performed on each database; member. The default performs a single-point energy('name'), while; optimize perfoms a geometry optimization on each reagent, and; cbs performs a compound single-point energy. If a nested series; of python functions is intended (see Function Intercalls), use; keyword db_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; Indicates whether the calculations required to complete the; database are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. cp (boolean) – 'on' || 'off' ; Indicates whether counterpoise correction is employed in computing; interaction energies. Use this option and NOT the cp(); function for BSSE correction in database(). Option available; (See Available Databases) only for databases of bimolecular complexes. rlxd (boolean) – 'on' || 'off' ; Indicates whether correction for deformation energy is; employed in computing interaction energies. Option available; (See Available Databases) onl",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/db-1.html:1916,energy,energy,1916,psi4manual/4.0b3/db-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/db-1.html,8,['energy'],['energy']
Energy Efficiency," Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Introduction¶. Overview¶; PSI4 provides a wide variety of quantum chemical methods using; state-of-the-art numerical methods and algorithms. Several parts of; the code feature shared-memory parallelization to run efficiently on; multi-core machines (see Sec. Threading).; An advanced parser written in Python allows the user; input to have a very simple style for routine computations, but it can also; automate very complex tasks with ease.; PSI4 is, in many ways, a whole new package compared to Psi3.; While some libraries and modules remain the same, the majority of the code has; been rewritten from scratch based on a powerful set of new libraries written; in C++. A totally new Python front-end makes PSI4 incredibly user-friendly; and automates many common tasks such as basis set extrapolation, composite; methods, running the same computation on every molecule in a test set, etc.; Density-functional theory, absent in Psi3, is quite efficient; in PSI4, with many functionals available. Density fitting is ubiquitous in; PSI4, leading to some of the most efficient MP2 and CCSD(T) code available.; PSI4 also introduces extensive,; powerful features for energy component analysis of non-covalent interactions; via symmetry-adapted perturbation theory. Orbital-optimized versions of; perturbation theory and coupled-cluster methods, and their analytic gradients,; have also been added. Through external libraries, PSI4 gains access to implicit; solvent (PCM) capabilities, density-matrix renormalization group CI, effective; fragment potentials, Grimme dispersion corrections, and high-order; coupled-cluster theory.; In this section, we provide an overview of some of the features of; PSI4 along with the prerequisite steps for running calculations.; Sec. Tutorial provides a brief tutorial to help new users; get started. Section Psithon offers further details into the; structure of PSI4 input files and how Python can be mixed with",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/introduction-1.html:1029,efficient,efficient,1029,psi4manual/1.1.0/introduction-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/introduction-1.html,2,['efficient'],['efficient']
Energy Efficiency," Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. delta2_wfn (str) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. delta2_wfn_lesser (str) – \(\Rightarrow\) delta_wfn \(\Leftarrow\) || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. Basis SetsCurrently, the basis set set through set commands have no influence; on a cbs calculation. Parameters:. scf_basis (basis string) – \(\Rightarrow\) corl_basis \(\Leftarrow\) || 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, scf_basis can default; to corl_basis. corl_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the correlation energy. delta_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. delta2_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. SchemesTransformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, 'xtpl_highest_1', which uses the best basis; set available. See Extrapolation Schemes for all available schemes. Parameters:. scf_scheme (str) – \(\Rightarrow\) 'xtpl_highest_1' \(\Leftarrow\) || 'scf_xtpl_helgaker_3' || etc.; Indicates the basis set extrapolation scheme to be applied to the reference energy.; Defaults to scf_xt",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.cbs.html:7051,energy,energy,7051,psi4manual/1.7.x/api/psi4.driver.cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.cbs.html,8,['energy'],['energy']
Energy Efficiency," Interface to MRCC by M. Kállay¶; Code author: Justin M. Turney and Andrew C. Simmonett; Section author: Justin M. Turney; Module: Keywords, PSI Variables, MRCC, Samples; PSI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (http://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; 1; 2; 3; 4; 5; 6; 7; 8; 9molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC.; Perturbative methods (ccsd(t), ccsdtqp(h)_l, etc.); are available with REFERENCE ROHF in versions of MRCC published; at least after July 1, 2014.; When using ROHF-CCSDT(Q), MRCC will compute and report two variants:; CCSDT(Q)/A and CCSDT(Q)/B.[Kallay:2008:144101]_ Psi4 will save both energies but will use; the CCSDT(Q)/B as the CCSDT(Q) energy. CCSDT(Q)/B has been found to be; more robust by Martin.[Martin:2014:785]_. name; cal",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/mrcc-1.html:1102,energy,energy,1102,psi4manual/1.1.0/mrcc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/mrcc-1.html,12,['energy'],['energy']
Energy Efficiency," J. Chem. Phys 124 034108 (2006) paper defining the functional. props3; DF-SCF cc-pVDZ multipole moments of benzene, up to 7th order and electrostatic potentials evaluated at the nuclear coordinates. opt2-fd; SCF DZ allene geometry optimzation, with Cartesian input. dcft6; DCFT calculation for the triplet O2 using DC-06, DC-12 and CEPA0 functionals. Only two-step algorithm is tested. sapt2; SAPT0 aug-cc-pVDZ computation of the benzene-methane interaction energy, using the aug-pVDZ-JKFIT DF basis for SCF, the aug-cc-pVDZ-RI DF basis for SAPT0 induction and dispersion, and the aug-pVDZ-JKFIT DF basis for SAPT0 electrostatics and induction. This example uses frozen core as well as asyncronous I/O while forming the DF integrals and CPHF coefficients. cc19; CCSD/cc-pVDZ dipole polarizability at two frequencies. scf-guess-read; Sample UHF/cc-pVDZ H2O computation on a doublet cation, using RHF/cc-pVDZ orbitals for the closed-shell neutral as a guess. cc4; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. After the computation, the checkpoint file is renamed, using the PSIO handler. cc10; ROHF-CCSD cc-pVDZ energy for the state of the CN radical. castup3; SCF with various combinations of pk/density-fitting, castup/no-castup, and spherical/cartesian settings. Demonstrates that puream setting is getting set by orbital basis for all df/castup parts of calc. Demonstrates that answer doesn’t depend on presence/absence of castup. Demonstrates (by comparison to castup2) that output file doesn’t depend on options (scf_type) being set global or local. This input uses local. cc8c; ROHF-CCSD cc-pVDZ frozen-core energy for the state of the CN radical, with Cartesian input. scf1; RHF cc-pVQZ energy for the BH molecule, with Cartesian input. cisd-h2o+-0; 6-31G** H2O+ Test CISD Energy Point. cc43; RHF-CC2-LR/STO-3G optical rotation of (S)-methyloxirane. gauge = both, omega = (589 355 nm). cc27; Single point gradient of 1-1B2 state of H2O with EOM-CCSD. cisd-s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_testsuite-1.html:8318,energy,energy,8318,psi4manual/4.0b4/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_testsuite-1.html,8,['energy'],['energy']
Energy Efficiency," J. Chem. Theory Comput. 11, 2126-2136 (2015)). dlpnomp2-1; comparison of DF-MP2 and DLPNO-MP2. linK-1; RHF Linear Exchange Algorithm test for water. omp3-5; SOS-OMP3 cc-pVDZ geometry optimization for the H2O molecule. cisd-h2o+-2; 6-31G** H2O+ Test CISD Energy Point. dfomp2-2; OMP2 cc-pVDZ energy for the NO molecule. cc27; Single point gradient of 1-1B2 state of H2O with EOM-CCSD. psithon2; Accesses basis sets, databases, plugins, and executables in non-install locations. mcscf2; TCSCF cc-pVDZ energy of asymmetrically displaced ozone, with Z-matrix input. tdscf-2; td-uhf test on triplet states of methylene (tda), wfn passing. mp2-h; check that methods can act on single atom. linK-2; RKS Linear Exchange Algorithm test for benzene. nbody-intermediates; HF/cc-pVDZ many body energies of an arbitrary noble gas trimer complex Size vs cost tradeoff is rough here. pywrap-checkrun-rohf; This checks that all energy methods can run with a minimal input and set symmetry. fsapt-ext-abc2; FSAPT with external charge on dimer. fd-freq-energy; SCF STO-3G finite-difference frequencies from energies for H2O. dft-grad1; DF-BP86-D2 cc-pVDZ frozen core gradient of S22 HCN update ref gradient due to new BraggSlater radii. opt-full-hess-every; SCF/sto-3g optimization with a hessian every step. fsaptd-terms; F-SAPT0/jun-cc-pvdz procedure for methane dimer. dft-jk; DFT JK on-disk test. fd-freq-gradient; SCF STO-3G finite-differences frequencies from gradients for H2O. cc15; RHF-B-CCD(T)/6-31G** H2O single-point energy (fzc, MO-basis \(\langle ab|cd \rangle\)). cc55; EOM-CCSD/6-31g excited state transition data for water with two excited states per irrep. cc13b; Tests RHF CCSD(T)gradients. freq-isotope2; Vibrational and thermo analysis of several water isotopologs. Demonstrates Hessian reuse for different temperatures, pressures, and isotopologs. cc26; Single-point gradient, analytic and via finite-differences of 2-1A1 state of H2O with EOM-CCSD. dct1; DC-06, DC-12, ODC-06 and ODC-12 calculat",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html:28851,charge,charge,28851,psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,2,['charge'],['charge']
Energy Efficiency," J. Comput. Chem., 27, 1787-1799, 2006\n'). # Add member functionals; X = build_functional('B97_X'); X.set_name('B97-D_X'); X.set_alpha(1.0). X.set_parameter('B97_gamma', 0.004); X.set_parameter('B97_a0', 1.08662); X.set_parameter('B97_a1', -0.52127); X.set_parameter('B97_a2', 3.25429). C = build_functional('B_C'); C.set_name('B97-D_C'). C.set_parameter('B97_os_gamma', 0.006); C.set_parameter('B97_os_a0', 0.69041); C.set_parameter('B97_os_a1', 6.30270); C.set_parameter('B97_os_a2', -14.9712). C.set_parameter('B97_ss_gamma', 0.2); C.set_parameter('B97_ss_a0', 0.22340); C.set_parameter('B97_ss_a1', -1.56208); C.set_parameter('B97_ss_a2', 1.94293). sup.add_x_functional(X); sup.add_c_functional(C). # => -D2 (s = 1.25) <= #; sup.set_dispersion(PsiMod.Dispersion.build(*dash_server('b97-d', 'd2p4'))). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_b97d2gr_superfunctional(name, npoints, deriv):. sup = build_b97d2p4_superfunctional(name, npoints, deriv); sup.set_name('B97-D2GR'). # => -D2 <= #; sup.set_dispersion(PsiMod.Dispersion.build(*dash_server('b97-d', 'd2gr'))). return sup. [docs]def build_b97d3zero_superfunctional(name, npoints, deriv):. sup = build_b97d2p4_superfunctional(name, npoints, deriv); sup.set_name('B97-D3ZERO'). # => -D3 <= #; sup.set_dispersion(PsiMod.Dispersion.build(*dash_server('b97-d', 'd3zero'))). return sup. [docs]def build_b97d3bj_superfunctional(name, npoints, deriv):. sup = build_b97d2p4_superfunctional(name, npoints, deriv); sup.set_name('B97-D3BJ'). # => -D3 <= #; sup.set_dispersion(PsiMod.Dispersion.build(*dash_server('b97-d', 'd3bj'))). return sup. [docs]def build_hcth_superfunctional(name, npoints, deriv):. # Call this first; sup = PsiMod.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/functional.html:35814,allocate,allocate,35814,psi4manual/4.0b4/_modules/functional.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/functional.html,1,['allocate'],['allocate']
Energy Efficiency," JOBS = MODELCHEM[:]; listfmt = """""" {:>12} / {:24} for {}{}\n"""""". # TODO: In the ""naive"" and ""enlightened"" loops below, I had to remove condition `and (job['f_options'] is not False))`; # to get them working, and I feel like they were added to fix the same thing. someday, seek to understand. # Remove duplicate modelchem portion listings; for mc in MODELCHEM:; dups = -1; for indx_job, job in enumerate(JOBS):; if ((job['f_wfn'] == mc['f_wfn']) and (job['f_basis'] == mc['f_basis']); and (job['f_options'] == mc['f_options'])):; dups += 1; if dups >= 1:; del JOBS[indx_job]. instructions += """""" Naive listing of computations required.\n""""""; for mc in JOBS:; instructions += listfmt.format(mc['f_wfn'], mc['f_basis'] + "" + options"" * bool(mc['f_options']),; VARH[mc['f_wfn']][mc['f_wfn']], _addlremark[ptype]). # Remove chemically subsumed modelchem portion listings; if ptype == 'energy':; for mc in MODELCHEM:; for wfn in VARH[mc['f_wfn']]:; for indx_job, job in enumerate(JOBS):; if ((VARH[mc['f_wfn']][wfn] == VARH[job['f_wfn']][job['f_wfn']]); and (mc['f_basis'] == job['f_basis']); and not (mc['f_wfn'] == job['f_wfn']); and (mc['f_options'] == job['f_options'])):; del JOBS[indx_job]. instructions += """"""\n Enlightened listing of computations required.\n""""""; for mc in JOBS:; instructions += listfmt.format(mc['f_wfn'], mc['f_basis'] + "" + options"" * bool(mc['f_options']),; VARH[mc['f_wfn']][mc['f_wfn']], _addlremark[ptype]). # Expand listings to all that will be obtained; TROVE = []; for job in JOBS:; for wfn in VARH[job['f_wfn']]:; TROVE.append(dict(zip(_f_fields, [wfn, job['f_basis'], job['f_zeta'], job['f_options'], 0.0, None, None, None, None]))). instructions += """"""\n Full listing of computations to be obtained (required and bonus).\n""""""; for mc in TROVE:; instructions += listfmt.format(mc['f_wfn'], mc['f_basis'] + "" + options"" * bool(mc['f_options']),; VARH[mc['f_wfn']][mc['f_wfn']], _addlremark[ptype]); if verbose:; core.print_out(instructions); logger.info(instructions). r",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html:45691,energy,energy,45691,psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,5,['energy'],['energy']
Energy Efficiency," Justin M. Turney; Module: Keywords, PSI Variables, MRCC, Samples; PSI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (http://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; 1; 2; 3; 4; 5; 6; 7; 8; 9molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC.; Perturbative methods (ccsd(t), ccsdtqp(h)_l, etc.); are available with REFERENCE ROHF in versions of MRCC published; at least after July 1, 2014.; When using ROHF-CCSDT(Q), MRCC will compute and report two variants:; CCSDT(Q)/A and CCSDT(Q)/B.[Kallay:2008:144101]_ Psi4 will save both energies but will use; the CCSDT(Q)/B as the CCSDT(Q) energy. CCSDT(Q)/B has been found to be; more robust by Martin.[Martin:2014:785]_. name; calls method in Kallay’s MRCC program [manual]. mrccsd; CC through doubles. mrccsdt; CC through triples. mr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/mrcc-1.html:1227,energy,energy,1227,psi4manual/1.1.0/mrcc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/mrcc-1.html,12,['energy'],['energy']
Energy Efficiency," Kinetic) Integrals. PCM_enabled(self); Whether running a PCM calculation. S(self); Returns the One-electron Overlap Matrix. X(). alpha_orbital_space(self, id, basis, subset); Creates OrbitalSpace with information about the requested alpha orbital space. aotoso(self); Returns the Atomic Orbital to Symmetry Orbital transformer. array_variable(self, arg0); Returns copy of the requested (case-insensitive) Matrix QC variable. array_variables(self); Returns the dictionary of all Matrix QC variables. arrays(). Deprecated since version 1.4. atomic_point_charges(self); Returns the set atomic point charges. basis_projection(self, arg0, arg1, arg2, arg3); Projects a orbital matrix from one basis to another. basisset(self); Returns the current orbital basis. beta_orbital_space(self, arg0, arg1, arg2); docstring. build(mol[, basis]). c1_deep_copy(self, basis); Returns a new wavefunction with internal data converted to \(C_1\) symmetry, using pre-c1-constructed basis. compute_energy(self); Computes the energy of the Wavefunction. compute_gradient(self); Computes the gradient of the Wavefunction. compute_hessian(self); Computes the Hessian of the Wavefunction. deep_copy(self, arg0); Deep copies the internal data. del_array_variable(self, arg0); Removes the requested (case-insensitive) Matrix QC variable. del_potential_variable(self, arg0); Removes the requested (case-insensitive) ExternalPotential QC variable. del_scalar_variable(self, arg0); Removes the requested (case-insensitive) double QC variable. del_variable(key); Removes scalar or array QCVariable key from cls if present. density_fitted(self); Returns whether this wavefunction was obtained using density fitting or not. doccpi(self); Returns the number of doubly occupied orbitals per irrep. efzc(self); Returns the frozen-core energy. energy(self); Returns the Wavefunction's energy. epsilon_a(self); Returns the Alpha Eigenvalues. epsilon_a_subset(self, basis, subset); Returns the requested Alpha orbital energies subset. epsi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.ccwavefunction.html:2058,energy,energy,2058,psi4manual/1.5.0/api/psi4.core.ccwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.ccwavefunction.html,2,['energy'],['energy']
Energy Efficiency," Kinetic) Integrals. PCM_enabled(self); Whether running a PCM calculation. S(self); Returns the One-electron Overlap Matrix. X(). alpha_orbital_space(self, id, basis, subset); Creates OrbitalSpace with information about the requested alpha orbital space. aotoso(self); Returns the Atomic Orbital to Symmetry Orbital transformer. array_variable(self, arg0); Returns copy of the requested (case-insensitive) Matrix QC variable. array_variables(self); Returns the dictionary of all Matrix QC variables. arrays(). Deprecated since version 1.4. atomic_point_charges(self); Returns the set atomic point charges. basis_projection(self, arg0, arg1, arg2, arg3); Projects a orbital matrix from one basis to another. basisset(self); Returns the current orbital basis. beta_orbital_space(self, arg0, arg1, arg2); docstring. build(mol[, basis]). c1_deep_copy(self, basis); Returns a new wavefunction with internal data converted to \(C_1\) symmetry, using pre-c1-constructed basis. compute_energy(self); Computes the energy of the Wavefunction. compute_gradient(self); Computes the gradient of the Wavefunction. compute_hessian(self); Computes the Hessian of the Wavefunction. deep_copy(self, arg0); Deep copies the internal data. del_array_variable(self, arg0); Removes the requested (case-insensitive) Matrix QC variable. del_potential_variable(self, arg0); Removes the requested (case-insensitive) ExternalPotential QC variable. del_scalar_variable(self, arg0); Removes the requested (case-insensitive) double QC variable. del_variable(key); Removes scalar or array QCVariable key from cls if present. density_fitted(self); Returns whether this wavefunction was obtained using density fitting or not. doccpi(self); Returns the number of doubly occupied orbitals per irrep. efzc(self); Returns the frozen-core energy. energy(self); Returns the Wavefunction’s energy. epsilon_a(self); Returns the Alpha Eigenvalues. epsilon_a_subset(self, arg0, arg1); Returns the requested Alpha Eigenvalues subset. epsilon_b(se",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ccwavefunction.html:2058,energy,energy,2058,psi4manual/1.4.0/api/psi4.core.ccwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ccwavefunction.html,2,['energy'],['energy']
Energy Efficiency," LCC2 (+LMP2) TOTAL ENERGY¶; The total electronic energy [E_h] for the local CC2 level of theory. LCCSD (+LMP2) TOTAL ENERGY¶; The total electronic energy [E_h] for the local CCSD level of theory. LEFT-RIGHT CC2 EIGENVECTOR OVERLAP¶. LEFT-RIGHT CC3 EIGENVECTOR OVERLAP¶. LEFT-RIGHT CCSD EIGENVECTOR OVERLAP¶. LEFT-RIGHT CCSD(T) EIGENVECTOR OVERLAP¶; The overlap between the right-hand coupled coupled cluster eigenvector and the; left-hand eigenvector from the coupled cluster lambda (response) equations. LOWDIN CHARGES¶; Property of partial atomic charges [e] by the method of Löwdin, (nat,). MAYER INDICES¶; Property of Mayer bond indices, (nat, nat). MBIS CHARGES¶. MBIS DIPOLES¶. MBIS OCTUPOLES¶. MBIS QUADRUPOLES¶; Per-atom charges [e], dipoles [e a0], quadrupoles [e a0^2], and octupoles [e a0^3]; resulting from partitioning the total electron density through the Minimal Basis; Iterative Stockholder (MBIS) Charge Partitioning Scheme. MBIS FREE ATOM n VOLUME¶; Free-atom volume [a0^3] for atom n, computed using the MBIS charge; partitioning scheme. Free atom densities are computed at the same; level of theory as the parent MBIS calculation, with UHF turned on; as needed. MBIS RADIAL MOMENTS <R^3>¶; Per-atom expectation value of r^3 [a0^3], equivalent to the volume; of the MBIS-partitioned density. MBIS VALENCE CHARGES¶; Per-atom valence charges [e] computed from an MBIS partitioned density. MBIS VALENCE WIDTHS¶; Per-atom density width [a0] of the associated valence charge computed; from an MBIS partitioned density. Equivalent to the inverse of the; linear decay rate of the atomic density. MBIS VOLUME RATIOS¶; Per-atom ratio between the atomic volume (<R^3>) and the free-atomic; volume, unitless. MCSCF TOTAL ENERGY¶; Multiconfigurational self-consistent-field energy [E_h] in the course of; a configuration interaction computation. May be single-root or state-averaged. mtd DIPOLE¶; Dipole array [e a0] for the named method, (3,). mtd QUADRUPOLE¶; Redundant quadrupole array [e ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/glossary_psivariables.html:34488,charge,charge,34488,psi4manual/master/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/master/glossary_psivariables.html,1,['charge'],['charge']
Energy Efficiency," LCC2 (+LMP2) TOTAL ENERGY¶; The total electronic energy [E_h] for the local CC2 level of theory. LCCSD (+LMP2) TOTAL ENERGY¶; The total electronic energy [E_h] for the local CCSD level of theory. LEFT-RIGHT CC2 EIGENVECTOR OVERLAP¶. LEFT-RIGHT CC3 EIGENVECTOR OVERLAP¶. LEFT-RIGHT CCSD EIGENVECTOR OVERLAP¶. LEFT-RIGHT CCSD(T) EIGENVECTOR OVERLAP¶; The overlap between the right-hand coupled coupled cluster eigenvector and the; left-hand eigenvector from the coupled cluster lambda (response) equations. LOWDIN CHARGES¶; Property of partial atomic charges [e] by the method of Löwdin, (nat,). MAYER INDICES¶; Property of Mayer bond indices, (nat, nat). MBIS CHARGES¶. MBIS DIPOLES¶. MBIS OCTUPOLES¶. MBIS QUADRUPOLES¶; Per-atom charges [e], dipoles [e a0], quadrupoles [e a0^2], and octupoles [e a0^3]; resulting from partitioning the total electron density through the Minimal Basis; Iterative Stockholder (MBIS) Charge Partitioning Scheme. MBIS FREE ATOM n VOLUME¶; Free-atom volume [a0^3] for atom n, computed using the MBIS charge; partitioning scheme. Free atom densities are computed at the same; level of theory as the parent MBIS calculation, with UHF turned on; as needed. MBIS RADIAL MOMENTS <R^3>¶; Per-atom expectation value of r^3 [a0^3], equivalent to the volume; of the MBIS-partitioned density. MBIS VALENCE WIDTHS¶; Per-atom density width [a0] of the associated valence charge computed; from an MBIS partitioned density. Equivalent to the inverse of the; linear decay rate of the atomic density. MBIS VOLUME RATIOS¶; Per-atom ratio between the atomic volume (<R^3>) and the free-atomic; volume, unitless. MCSCF TOTAL ENERGY¶; Multiconfigurational self-consistent-field energy [E_h] in the course of; a configuration interaction computation. May be single-root or state-averaged. mtd DIPOLE¶; Dipole array [e a0] for the named method, (3,). mtd QUADRUPOLE¶; Redundant quadrupole array [e a0^2] for the named method, (3, 3). mtd OCTUPOLE¶; Redundant octupole array [e a0^3] for the na",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html:34479,charge,charge,34479,psi4manual/1.7.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html,3,['charge'],['charge']
Energy Efficiency," LUMO HOMO+4. dfcasscf-fzc-sp; CASSCF/6-31G** energy point. olccd-grad2; OLCCD cc-pVDZ gradient for the NO radical. scf-property; UFH and B3LYP cc-pVQZ properties for the CH2 molecule. olccd-freq1; OLCCD cc-pVDZ freqs for C2H2. omp3-grad2; OMP3 cc-pVDZ gradient for the NO radical. scf-response3; UHF Dipole Polarizability Test. cc37; CC2(UHF)/cc-pVDZ energy of H2O+. sapt10; usapt example with empty beta due to frozen core. cc8c; ROHF-CCSD cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Cartesian input. extern2; External potential calculation involving a TIP3P water and a QM water for DFMP2. Finite different test of the gradient is performed to validate forces. scf-guess; Test initial SCF guesses on FH and FH+ in cc-pVTZ basis. dct8; DCT calculation for the NH3+ radical using the ODC-12 and ODC-13 functionals. This performs both simultaneous and QC update of the orbitals and cumulant using DIIS extrapolation. Four-virtual integrals are first handled in the MO Basis for the first two energy computations. In the next computation ao_basis=disk algorithm is used, where the transformation of integrals for four-virtual case is avoided. opt1-fd; SCF STO-3G geometry optimzation, with Z-matrix input, by finite-differences. fd-freq-energy; SCF STO-3G finite-difference frequencies from energies for H2O. cc30; CCSD/sto-3g optical rotation calculation (length gauge only) at two frequencies on methyloxirane. dfccsd-grad2; DF-CCSD cc-pVDZ gradient for the NH molecule. dft-pruning; Tests all grid pruning options available and screening of small weights. Check against grid size. cc51; EOM-CC3/cc-pVTZ on H2O. opt7; Various constrained energy minimizations of HOOH with cc-pvdz RHF. For “fixed” coordinates, the final value is provided by the user. cbs-xtpl-gradient; Various gradients for a strained helium dimer and water molecule. sapt9; usapt example with empty beta. cc7; Tests CCENERGY’s CCSD gradient in the presence of a dipole field. mcscf2; TCSCF cc-p",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html:4963,energy,energy,4963,psi4manual/master/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency," Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with functions that interface with Grimme's GCP code.""""""; import os; import re; import uuid; import shutil; import socket; import subprocess. try:; from psi4.driver.p4util.exceptions import *; from psi4 import core; isP4regime = True; except ImportError:; from .exceptions import *; isP4regime = False; from .util import parse_dertype; from .molecule import Molecule. [docs]def run_gcp(self, func=None, dertype=None, verbose=False): # dashlvl=None, dashparam=None; """"""Function to call Grimme's GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to *self* for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, *func*. Returns energy if *dertype* is 0, gradient; if *dertype* is 1, else tuple of energy and gradient if *dertype*; unspecified. The gcp executable must be independently compiled and; found in :envvar:`PATH` or :envvar:`PSIPATH`. *self* may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.Molecule. """"""; # Create (if necessary) and update qcdb.Molecule; if isinstance(self, Molecule):; # called on a qcdb.Molecule; pass; elif isinstance(self, core.Molecule):; # called on a python export of a psi4.core.Molecule (py-side through Psi4's driver); self.create_psi4_string_from_molecule(); elif isinstance(self, str):; # called on a string representation of a psi4.Molecule (c-side through psi4.Dispersion); self = Molecule(self); else:; raise ValidationError(""""""Argument mol must be psi4string or qcdb.Molecule""""""); self.update_geometry(). # # Validate arguments; # dashlvl = dashlvl.lower(); # dashlvl = da",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/qcdb/interface_gcp.html:1828,energy,energy,1828,psi4manual/1.3.2/_modules/qcdb/interface_gcp.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/qcdb/interface_gcp.html,2,['energy'],['energy']
Energy Efficiency," LibXC version and citation string. test_functional(self, arg0, arg1, arg2, ...); Quick testing capabilities. value(self, arg0); Returns a given internal value. values(self); Return all internal values. vv10_b(self); The VV10 b parameter. vv10_c(self); The VV10 c parameter. x_alpha(self); Amount of exact HF exchange. x_beta(self); Amount of exact HF exchange. x_functional(self, arg0); Returns the desired X Functional. x_functionals(self); Returns all X Functionals. x_omega(self); Range-seperated exchange parameter. xclib_description(self); LibXC version and citation string. Methods Documentation. static XC_build(name: str, unpolarized: bool, tweak: Dict[str, float] | None = {}) → psi4.core.SuperFunctional¶; Builds a SuperFunctional from a XC string. add_c_functional(self: psi4.core.SuperFunctional, arg0: psi4.core.Functional) → None¶; Add a correlation Functional. add_x_functional(self: psi4.core.SuperFunctional, arg0: psi4.core.Functional) → None¶; Add a exchange Functional. allocate(self: psi4.core.SuperFunctional) → None¶; Allocates the vectors, should be called after ansatz or npoint changes. ansatz(self: psi4.core.SuperFunctional) → int¶; SuperFunctional rung. static blank() → psi4.core.SuperFunctional¶; Initialize a blank SuperFunctional. c_alpha(self: psi4.core.SuperFunctional) → float¶; Amount of MP2 correlation. c_functional(self: psi4.core.SuperFunctional, arg0: str) → psi4.core.Functional¶; Returns the desired C Functional. c_functionals(self: psi4.core.SuperFunctional) → List[psi4.core.Functional]¶; Returns all C Functionals. c_omega(self: psi4.core.SuperFunctional) → float¶; Range-seperated correlation parameter. c_os_alpha(self: psi4.core.SuperFunctional) → float¶; Amount of SS MP2 correlation. c_ss_alpha(self: psi4.core.SuperFunctional) → float¶; Amount of OS MP2 correlation. citation(self: psi4.core.SuperFunctional) → str¶; SuperFunctional citation. compute_functional(self: psi4.core.SuperFunctional, vals: Dict[str, psi4.core.Vector], npoints: int = -",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/api/psi4.core.SuperFunctional.html:4460,allocate,allocate,4460,psi4manual/1.9.x/api/psi4.core.SuperFunctional.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.SuperFunctional.html,1,['allocate'],['allocate']
Energy Efficiency," LibXC version and citation string. test_functional(self, arg0, arg1, arg2, ...); Quick testing capabilities. value(self, arg0); Returns a given internal value. values(self); Return all internal values. vv10_b(self); The VV10 b parameter. vv10_c(self); The VV10 c parameter. x_alpha(self); Amount of exact HF exchange. x_beta(self); Amount of exact HF exchange. x_functional(self, arg0); Returns the desired X Functional. x_functionals(self); Returns all X Functionals. x_omega(self); Range-seperated exchange parameter. xclib_description(self); LibXC version and citation string. Methods Documentation. static XC_build(name: str, unpolarized: bool, tweak: dict[str, float] | None = {}) → psi4.core.SuperFunctional¶; Builds a SuperFunctional from a XC string. add_c_functional(self: psi4.core.SuperFunctional, arg0: psi4.core.Functional) → None¶; Add a correlation Functional. add_x_functional(self: psi4.core.SuperFunctional, arg0: psi4.core.Functional) → None¶; Add a exchange Functional. allocate(self: psi4.core.SuperFunctional) → None¶; Allocates the vectors, should be called after ansatz or npoint changes. ansatz(self: psi4.core.SuperFunctional) → int¶; SuperFunctional rung. static blank() → psi4.core.SuperFunctional¶; Initialize a blank SuperFunctional. c_alpha(self: psi4.core.SuperFunctional) → float¶; Amount of MP2 correlation. c_functional(self: psi4.core.SuperFunctional, arg0: str) → psi4.core.Functional¶; Returns the desired C Functional. c_functionals(self: psi4.core.SuperFunctional) → list[psi4.core.Functional]¶; Returns all C Functionals. c_omega(self: psi4.core.SuperFunctional) → float¶; Range-seperated correlation parameter. c_os_alpha(self: psi4.core.SuperFunctional) → float¶; Amount of SS MP2 correlation. c_ss_alpha(self: psi4.core.SuperFunctional) → float¶; Amount of OS MP2 correlation. citation(self: psi4.core.SuperFunctional) → str¶; SuperFunctional citation. compute_functional(self: psi4.core.SuperFunctional, vals: dict[str, psi4.core.Vector], npoints: int = -",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/api/psi4.core.SuperFunctional.html:4467,allocate,allocate,4467,psi4manual/master/api/psi4.core.SuperFunctional.html,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.SuperFunctional.html,1,['allocate'],['allocate']
Energy Efficiency," MEAN SIGNED DEVIATION; db_name DATABASE MEAN ABSOLUTE DEVIATION; db_name DATABASE ROOT-MEAN-SQUARE DEVIATION. Note; It is very easy to make a database from a collection of xyz files; using the script psi4/lib/scripts/ixyz2database.pl.; See Creating a Database for details. Caution; Some features are not yet implemented. Buy a developer some coffee. In sow/reap mode, use only global options (e.g., the local option set by set scf scf_type df will not be respected). Parameters:; name (string) – 'scf' || 'sapt0' || 'ccsd(t)' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). db_name (string) – 'BASIC' || 'S22' || 'HTBH' || etc.; Second argument, usually unlabeled. Indicates the requested database; name, matching the name of a python file in psi4/lib/databases.; Consult that directory for available databases and literature citations. func (function) – energy || optimize || cbs; Indicates the type of calculation to be performed on each database; member. The default performs a single-point energy('name'), while; optimize perfoms a geometry optimization on each reagent, and; cbs performs a compound single-point energy. If a nested series; of python functions is intended (see Function Intercalls), use; keyword db_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; Indicates whether the calculations required to complete the; database are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. cp (boolean) – 'on' || 'off' ; Indicates whether counterpoise correction is employed in computing; interaction energies. Use this option and NOT the cp(); function for BSSE correction in database(). Option available; (See Available Databases) only for databases of bimolecular complexes. rlxd (boolean) – 'on' || 'off' ; Ind",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/db-1.html:1492,energy,energy,1492,psi4manual/4.0b2/db-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/db-1.html,2,['energy'],['energy']
Energy Efficiency," MM molecules may be specified by adding; extra calls to addCharge to describe the full MM region.; To run a computation in a constant dipole field, the PERTURB_H,; PERTURB_WITH and PERTURB_DIPOLE keywords can be used. As an; example, to add a dipole field of magnitude 0.05 a.u. in the y direction and; 0.1 a.u. in the z direction, we can use the following keywords:; set perturb_h true; set perturb_with dipole; set perturb_dipole [ 0, 0.05, 0.1 ]. Note that if any specified fields do not fall along a symmetry axis, the; symmetry of the calculation should be reduced accordingly; if in doubt run the; calculation in C1 symmetry. For examples of SCF and MP2 calculations in an; external field, see scf7 and dfmp2-grad5. Convergence and Algorithm Defaults¶. SCF algorithm and convergence criteria defaults by calculation type 1¶. Ab Initio Method; Calculation Type; E_CONVERGENCE; D_CONVERGENCE; SCF_TYPE. SCF of HF or DFT; energy; 6; 6; DF. optimization; 8; 8. frequency 7; 8; 8. SCF of post-HF; energy; 8; 8; PK 3. optimization; 10; 10. frequency 7; 10; 10. CC property 2; 10; 10. Post-SCF convergence criteria defaults by calculation type 4¶. Ab Initio Method; Calculation Type; E_CONVERGENCE 5; R_CONVERGENCE 6. post-HF of post-HF; energy; 6. optimization; 8. frequency 7; 8. CC property 2; 8. Footnotes. 1; Note that this table applies only the SCF module,; not to the final convergence criteria for post-HF methods or to methods; that use an alternate starting point, like MCSCF. SAPT computations, too,; set tighter values. 2(1,2); This applies to properties computed through the properties() function. 3; Post-HF methods that do not rely upon the usual 4-index AO integrals use a; density-fitted SCF reference. That is, for DF-MP2 and SAPT, the default SCF_TYPE is DF. 4; Note that this table applies to the final convergence criteria for; all the post-SCF modules that define a E_CONVERGENCE keyword. 5; The E_CONVERGENCE keyword is implemented for most post-SCF modules.; See a list begin",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/scf-1.html:39829,energy,energy,39829,psi4manual/1.4.0/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/scf-1.html,4,['energy'],['energy']
Energy Efficiency," MO basis to build alpha NO’s from (optional); density_b (Matrix) – density in the MO basis to build beta NO’s from, assumes restricted if not supplied (optional); dovirtual (bool) – do write all the MOs to the MOLDEN file (true) or discard the unoccupied MOs, not valid for NO’s (false) (optional). Examples:. Molden file with the Kohn-Sham orbitals of a DFT calculation.; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> molden(wfn, 'mycalc.molden'). Molden file for CI/MCSCF computation using NO roots.; Any method returning a CIWavefunction object will work: detci,; fci, casscf, etc. The first two arguments of get_opdm can be; set to n, n where n => 0 selects the root to write out, provided; these roots were computed, see NUM_ROOTS. The; third argument controls the spin (""A"", ""B"" or ""SUM"") and the final; boolean option determines whether inactive orbitals are included.; >>> E, wfn = energy('detci', return_wfn=True); >>> molden(wfn, 'no_root1.molden', density_a=wfn.get_opdm(0, 0, ""A"", True)). The following produces an INCORRECT Molden file, because the; molden function needs orbitals in the MO basis (which are internally; converted and written to the Molden file in the AO basis). The correct; usage is given in the next point.; >>> E, wfn = energy('ccsd', return_wfn=True); >>> molden(wfn, 'ccsd_no.molden', density_a=wfn.Da()). Molden file with the natural orbitals of the ground-state 1RDM of a; Post-HF calculation. Note the required transformation of Da (SO->MO).; >>> E, wfn = properties('ccsd', return_wfn=True); >>> Da_so = wfn.Da(); >>> SCa = core.doublet(wfn.S(), wfn.Ca(), False, False); >>> Da_mo = core.triplet(SCa, Da_so, SCa, True, False, False); >>> molden(wfn, 'ccsd_no.molden', density_a=Da_mo). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. PSI4 API: Linking C++ and Python; molden. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.molden.html:2172,energy,energy,2172,psi4manual/1.7.x/api/psi4.driver.molden.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.molden.html,1,['energy'],['energy']
Energy Efficiency," MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2 level of theory. MP2.5 TOTAL ENERGY¶. MP2.5 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2.5 level of theory. MP3 TOTAL ENERGY¶. MP3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP3 level of theory. MPn TOTAL ENERGY¶. MPn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Möller–Plesset perturbation theory level.; n is MP perturbation order. NUCLEAR REPULSION ENERGY¶; The nuclear repulsion energy contribution [H] to the total SCF energy.; Quantity in Eq. (2). ONE-ELECTRON ENERGY¶; The one-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (2). SAPT DISP ENERGY¶. SAPT ELST ENERGY¶. SAPT EXCH ENERGY¶. SAPT IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [H] for the the; requested SAPT level of theory. The sum of these four components yields; SAPT ENERGY. SAPT ENERGY¶; The total electronic interaction energy [H] for the requested SAPT; level of theory. SAPT SAPT0 ENERGY¶. SAPT SAPT2 ENERGY¶. SAPT SAPT2+ ENERGY¶. SAPT SAPT2+(3) ENERGY¶. SAPT SAPT2+3 ENERGY¶; The total electronic interaction energy [H] for the labeled SAPT level; of theory. SCF TOTAL ENERGY¶; The total electronic energy [H] of the SCF stage of the calculation.; The CORRELATION ENERGY variables from subsequent stages of a; calculation are often the corresponding TOTAL ENERGY variables; less this quantity. Constructed from Eq. (2). (2). TWO-ELECTRON ENERGY¶; The two-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (2). UNCP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [H] considering only two-body interactions,; computed without counterpoise correction.; Related variable CP-CORRECTED ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/glossary_psivariables-1.html:7916,energy,energy,7916,psi4manual/4.0b2/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/glossary_psivariables-1.html,2,['energy'],['energy']
Energy Efficiency," MP2 DOUBLES ENERGY; for opposite-spin and same-spin contributions, with; any singles carried along.; Depending on weights, may equal any of MP2, SCS-MP2, SCS(N)-MP2, etc. quantities.; Contrast with SCS-MP2 TOTAL ENERGY. CUSTOM SCS-MP2.5 TOTAL ENERGY¶. CUSTOM SCS-MP2.5 CORRELATION ENERGY¶. CUSTOM SCS-MP3 TOTAL ENERGY¶. CUSTOM SCS-MP3 CORRELATION ENERGY¶. CUSTOM SCS-REMP2 TOTAL ENERGY¶. CUSTOM SCS-REMP2 CORRELATION ENERGY¶. CUSTOM SCS-LCCD TOTAL ENERGY¶. CUSTOM SCS-LCCD CORRELATION ENERGY¶. CUSTOM SCS-OMP2 TOTAL ENERGY¶. CUSTOM SCS-OMP2 CORRELATION ENERGY¶. CUSTOM SCS-OMP2.5 TOTAL ENERGY¶. CUSTOM SCS-OMP2.5 CORRELATION ENERGY¶. CUSTOM SCS-OMP3 TOTAL ENERGY¶. CUSTOM SCS-OMP3 CORRELATION ENERGY¶. CUSTOM SCS-OREMP2 TOTAL ENERGY¶. CUSTOM SCS-OREMP2 CORRELATION ENERGY¶. CUSTOM SCS-OLCCD TOTAL ENERGY¶. CUSTOM SCS-OLCCD CORRELATION ENERGY¶; Changeable quantities based on options.; The total electronic energy [E_h] and correlation energy component [E_h]; for the method formed by any reweighting of the named method DOUBLES ENERGY; for opposite-spin and same-spin contributions, with; any singles carried along.; Contrast with :samp`SCS-{method} TOTAL ENERGY`. db_name DATABASE MEAN ABSOLUTE DEVIATION¶; The mean absolute deviation [kcal mol-1] of the requested method; name from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. \[\frac{1}{n}\sum_{rxn}^{n}{| \textsf{\textsl{name}}_{rxn}-\text{REF}_{rxn} | }\]. db_name DATABASE MEAN SIGNED DEVIATION¶; The mean deviation [kcal mol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. \[\frac{1}{n}\sum_{rxn}^{n}{\textsf{\textsl{name}}_{rxn}-\text{REF}_{rxn}}\]. db_name DATABASE ROOT-MEAN-SQUARE DEVIATION¶; The rms deviation [kcal mol-1] of the requested method name; from the stored reference values ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html:25698,energy,energy,25698,psi4manual/1.7.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html,8,['energy'],['energy']
Energy Efficiency," MP2 theory for the excited state and the relation; to such other response theories as CC2-LR, CIS(D) and CIS(D:math:_n) has; been addressed [Haettig:2002] by Hattig et al. In the ADC theory,; the residue calculus of the propagator is translated into the eigenvalue; problem with respect to the correlated response matrix, also known as the; shifted-Hamiltonian. The σ-vectors (Hamiltonian-vector products); are constructed several times in the simultaneous expansion method (SEM); to solve the eigenvalue problem, and each σ-vector construction; has a computational cost that scales as . In addition,; the tensorial form of the σ-vector resembles to that of the; doubles correction in the CIS(D) energetic equation. As a consequence,; the pre-factor in the polynomial scaling becomes far larger than that; of the CIS(D) even though the quasi-degeneracy of the excited state is; properly accounted for in the ADC(2) model.; In PSI4 the quite efficient and flexible integral-transformation; library named libtrans is newly equipped and utilized in the; production level DCFT code. The ADC code is also based on; libtrans, and it is also based on libdpd, a library to; utilize molecular symmetry in the tensorial manipulations in framework; of the direct-product decomposition algorithm. By this feature, the Ritz; space and intermediate tensors are blocked according to the irreducible; representations of the point group, and the excited states that belong; to different symmetry are sought separately.; In the output of ADC, the ADC(2) results may look as follows:; -> 1 B1 state : 0.2565095 (a.u.), 6.9799824 (eV); Non-iterative: 0.2565636 (a.u.), 6.9814532 (eV); Occ Vir Coefficient; ---------------------------------------------; 3 0 -0.9017047264; 3 2 0.3038332241; 3 1 0.2907567119; 3 5 -0.0790167706; 3 4 -0.0425829926. Converged in 4 iteration.; Squared norm of the S component: 0.9315336; The S vector is rotated up to 8.102 (deg.). in which the ADC(2) excitation energy is indicated with arr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/adc-1.html:1858,efficient,efficient,1858,psi4manual/4.0b2/adc-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/adc-1.html,8,['efficient'],['efficient']
Energy Efficiency, MP2.5 DOUBLES ENERGY¶. MP3 DOUBLES ENERGY¶. CEPA(0) DOUBLES ENERGY¶. CEPA(1) DOUBLES ENERGY¶. CEPA(2) DOUBLES ENERGY¶. CEPA(3) DOUBLES ENERGY¶. ACPF DOUBLES ENERGY¶. AQCC DOUBLES ENERGY¶. CISD DOUBLES ENERGY¶. QCISD DOUBLES ENERGY¶. REMP2 DOUBLES ENERGY¶. LCCD DOUBLES ENERGY¶. CCD DOUBLES ENERGY¶. LCCSD DOUBLES ENERGY¶. CCSD DOUBLES ENERGY¶. OMP2 DOUBLES ENERGY¶. OMP2.5 DOUBLES ENERGY¶. OMP3 DOUBLES ENERGY¶. OREMP2 DOUBLES ENERGY¶. OLCCD DOUBLES ENERGY¶; The doubles portion [E_h] of the named correlation energy; including same-spin and opposite-spin correlations. MP2 SINGLES ENERGY¶. MP2.5 SINGLES ENERGY¶. MP3 SINGLES ENERGY¶. CEPA(0) SINGLES ENERGY¶. CEPA(1) SINGLES ENERGY¶. CEPA(2) SINGLES ENERGY¶. CEPA(3) SINGLES ENERGY¶. ACPF SINGLES ENERGY¶. AQCC SINGLES ENERGY¶. CISD SINGLES ENERGY¶. QCISD SINGLES ENERGY¶. REMP2 SINGLES ENERGY¶. LCCD SINGLES ENERGY¶. CCD SINGLES ENERGY¶. LCCSD SINGLES ENERGY¶. CCSD SINGLES ENERGY¶. OREMP2 SINGLES ENERGY¶. OLCCD SINGLES ENERGY¶; The singles portion [E_h] of the named correlation energy.; Zero except in ROHF. MP2 SAME-SPIN CORRELATION ENERGY¶. MP2.5 SAME-SPIN CORRELATION ENERGY¶. MP3 SAME-SPIN CORRELATION ENERGY¶. CEPA(0) SAME-SPIN CORRELATION ENERGY¶. CEPA(1) SAME-SPIN CORRELATION ENERGY¶. CEPA(2) SAME-SPIN CORRELATION ENERGY¶. CEPA(3) SAME-SPIN CORRELATION ENERGY¶. CISD SAME-SPIN CORRELATION ENERGY¶. QCISD SAME-SPIN CORRELATION ENERGY¶. ACPF SAME-SPIN CORRELATION ENERGY¶. AQCC SAME-SPIN CORRELATION ENERGY¶. REMP2 SAME-SPIN CORRELATION ENERGY¶. LCCD SAME-SPIN CORRELATION ENERGY¶. CCD SAME-SPIN CORRELATION ENERGY¶. LCCSD SAME-SPIN CORRELATION ENERGY¶. CCSD SAME-SPIN CORRELATION ENERGY¶. OMP2 SAME-SPIN CORRELATION ENERGY¶. OMP2.5 SAME-SPIN CORRELATION ENERGY¶. OMP3 SAME-SPIN CORRELATION ENERGY¶. OREMP2 SAME-SPIN CORRELATION ENERGY¶. OLCCD SAME-SPIN CORRELATION ENERGY¶; The unscaled portion [E_h] of the named correlation energy; from same-spin or triplet doubles correlations. MP2 OPPOSITE-SPIN CORRELATION ENERGY¶. MP2.5 OPPOSITE-,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html:38711,energy,energy,38711,psi4manual/1.7.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html,4,['energy'],['energy']
Energy Efficiency," MP4 CORRELATION; ENERGY / MP4(SDTQ) CORRELATION ENERGY is left-hand term in Eq. (2). (2)¶\[E_{\text{MP4}} = E_{\text{MP4(SDQ)}} + E_{\text{MP4(T)}}\]. MPn TOTAL ENERGY¶. MPn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Møller–Plesset perturbation theory level.; n is MP perturbation order. NUCLEAR REPULSION ENERGY¶; The nuclear repulsion energy contribution [H] to the total SCF energy.; Quantity \(E_{NN}\) in Eq. (4). (3)¶\[E_{NN} = \sum_{i, j<i}^{N_{atom}}\frac{Z_i Z_j}{|\mathbf{R}_i - \mathbf{R}_j|}\]. OCEPA(0) TOTAL ENERGY¶. OCEPA(0) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the orbital-optimized CEPA(0) level of theory. OMP2 TOTAL ENERGY¶. OMP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the orbital-optimized MP2 level of theory. OMP3 TOTAL ENERGY¶. OMP3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the orbital-optimized MP3 level of theory. ONE-ELECTRON ENERGY¶; The one-electron energy contribution [H] to the total SCF energy.; Quantity \(E_{1e^-}\) in Eq. (4). QCISD TOTAL ENERGY¶. QCISD CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the quadratic configuration interaction singles and doubles level; of theory. QCISD(T) TOTAL ENERGY¶. QCISD(T) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the quadratic configuration interaction singles and doubles with; perturbative triples correction level of theory. SAPT DISP ENERGY¶. SAPT ELST ENERGY¶. SAPT EXCH ENERGY¶. SAPT IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [H] for the the; requested SAPT level of theory. The sum of these four components yields; SAPT TOTAL ENERGY. SAPT TOTAL ENERGY¶; The total electronic interaction ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/glossary_psivariables-1.html:15031,energy,energy,15031,psi4manual/1.1.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/glossary_psivariables-1.html,4,['energy'],['energy']
Energy Efficiency," MRCC code (see MRCC).; Solvent effects on energies can be taken into account using the polarizable; continuum model (PCM) in the PTE approximation [Cammi:2009:164104], see; PCM. Current coupled cluster capabilities of PSI4¶. Method; Reference; Energy; Gradient; Exc. Energies; LR Props. CC2; RHF; Y; Y; Y; Y. UHF; Y; —; N; —. ROHF; Y; —; N; —. CCSD; RHF; Y; Y; Y; Y. UHF; Y; Y; Y; —. ROHF; Y; Y; Y; —. CCSD(T); RHF; Y; Y; n/a; n/a. UHF; Y; Y; n/a; n/a. ROHF; Y; —; n/a; n/a. CCSD(AT); RHF; Y; —; n/a; n/a. CC3; RHF; Y; —; Y; —. UHF; Y; —; Y; —. ROHF; Y; —; Y; —. CCD; Brueckner; Y; N; N; N. CCD(T); Brueckner; Y; N; n/a; n/a. The following wavefunctions are currently recognized by PSI4 as arguments; to functions like energy(): 'ccsd', 'ccsd(t)', 'ccsd(at)', 'cc2',; 'cc3', 'bccd' (CCD with Brueckner orbitals), 'bccd(t)' (CCD(T) with; Brueckner orbitals), 'eom-ccsd', 'eom-cc2' (CC2 for excited states),; 'eom-cc3' (CC3 for excited states). Response properties can be obtained; by calling the function properties() (instead of, for example, energy(),; e.g., properties('ccsd'). There are many sample; coupled cluster inputs provided in psi4/samples. Basic Keywords¶; A complete list of keywords related to coupled-cluster computations is; provided in the appendices, with the majority of the relevant; keywords appearing in Appendix CCENERGY. For a standard ground-state; CCSD or CCSD(T) computation, the following keywords are common:. REFERENCE¶. Reference wavefunction type. Type: string; Possible Values: RHF, ROHF, UHF; Default: RHF. R_CONVERGENCE¶. Convergence criterion for wavefunction (change) in CC amplitude equations. Type: conv double; Default: 1e-7. MAXITER¶. Maximum number of iterations to solve the CC equations. Type: integer; Default: 50. BRUECKNER_ORBS_R_CONVERGENCE¶. Convergence criterion for Brueckner orbitals. The convergence is determined based on the largest \(T_1\) amplitude. Default adjusts depending on E_CONVERGENCE. Type: conv double; Default: 1e-5. RESTART¶. Do r",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/cc-1.html:4218,energy,energy,4218,psi4manual/1.4.0/cc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/cc-1.html,2,['energy'],['energy']
Energy Efficiency," Make sure the molecule the user provided is the active one; if ('molecule' in kwargs):; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); #PsiMod.set_global_option('BASIS', PsiMod.get_global_option('BASIS')). # Allow specification of methods to arbitrary order; lowername, level = parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. try:; # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); # SCF properties have been set as 6/5 so as to match those ; # run normally through OEProp so subject to change; if not PsiMod.has_option_changed('SCF', 'E_CONVERGENCE'):; if procedures['energy'][lowername] == run_scf or procedures['energy'][lowername] == run_dft:; PsiMod.set_local_option('SCF', 'E_CONVERGENCE', 6); else:; PsiMod.set_local_option('SCF', 'E_CONVERGENCE', 10); if not PsiMod.has_option_changed('SCF', 'D_CONVERGENCE'):; if procedures['energy'][lowername] == run_scf or procedures['energy'][lowername] == run_dft:; PsiMod.set_local_option('SCF', 'D_CONVERGENCE', 6); else:; PsiMod.set_local_option('SCF', 'D_CONVERGENCE', 10). # Set post-scf convergence criteria (global will cover all correlated modules); if not PsiMod.has_global_option_changed('E_CONVERGENCE'):; if not procedures['energy'][lowername] == run_scf and not procedures['energy'][lowername] == run_dft:; PsiMod.set_global_option('E_CONVERGENCE', 8). returnvalue = procedures['property'][lowername](lowername, **kwargs). except KeyError:; raise ValidationError('Property method %s not available.' % (lowername)). optstash.restore(); return returnvalue. ## Aliases ##; prop = property. [docs]def optimize(name, **kwargs):; r""""""Function to perform a geometry optimization. :aliases: opt(). :returns: (*float*) Total electronic energy of optimized structure in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY <CURRENTENERGY>`. .. note:: Analytic gradients ar",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/driver.html:44265,energy,energy,44265,psi4manual/4.0b4/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/driver.html,2,['energy'],['energy']
Energy Efficiency," Mode of operation- whether finite difference opt run in one job or files farmed out; opt_mode = 'continuous'; if ('mode' in kwargs) and (dertype == 0):; opt_mode = kwargs['mode']. if (opt_mode.lower() == 'continuous'):; pass; elif (opt_mode.lower() == 'sow'):; pass; elif (opt_mode.lower() == 'reap'):; if('linkage' in kwargs):; opt_linkage = kwargs['linkage']; else:; raise ValidationError('Optimize execution mode \'reap\' requires a linkage option.'); else:; raise ValidationError('Optimize execution mode \'%s\' not valid.' % (opt_mode)). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); if not PsiMod.has_option_changed('SCF', 'E_CONVERGENCE'):; if procedures['energy'][lowername] == run_scf or procedures['energy'][lowername] == run_dft:; PsiMod.set_local_option('SCF', 'E_CONVERGENCE', 8); else:; PsiMod.set_local_option('SCF', 'E_CONVERGENCE', 10); if not PsiMod.has_option_changed('SCF', 'D_CONVERGENCE'):; if procedures['energy'][lowername] == run_scf or procedures['energy'][lowername] == run_dft:; PsiMod.set_local_option('SCF', 'D_CONVERGENCE', 8); else:; PsiMod.set_local_option('SCF', 'D_CONVERGENCE', 10). # Set post-scf convergence criteria (global will cover all correlated modules); if not PsiMod.has_global_option_changed('E_CONVERGENCE'):; if not procedures['energy'][lowername] == run_scf and not procedures['energy'][lowername] == run_dft:; PsiMod.set_global_option('E_CONVERGENCE', 8). # Does dertype indicate an analytic procedure both exists and is wanted?; if (dertype == 1):; # Nothing to it but to do it. Gradient information is saved; # into the current reference wavefunction; procedures['gradient'][lowername](lowername, **kwargs). if 'mode' in kwargs and kwargs['mode'].lower() == 'sow':; raise ValidationError('Optimize execution mode \'sow\' not valid for analytic gradient calculation.'); PsiMod.wavefunction().energy(). optstash.restore(); return PsiMod.get_variable('CURRENT ENERGY'). else:; # If not, perf",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/driver.html:33440,energy,energy,33440,psi4manual/4.0b4/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/driver.html,2,['energy'],['energy']
Energy Efficiency," Modes — frequency() and hessian(). Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Psithon Functions: Invoking a Calculation; Harmonic Vibrational Analysis and Visualization of Normal Modes — frequency() and hessian(). Harmonic Vibrational Analysis and Visualization of Normal Modes — frequency() and hessian()¶. Psi4 Native Hessian Methods. For further discussion of vibrational and thermochemical analysis,; see Sec. Vibrational and Thermochemical Analysis.; frequency() is the only command most users will ever; need to access directly to perform frequency calculations. Behind; the scenes, frequency() is a light wrapper over; hessian() that computes the Hessian then adds a; thermochemical analysis. psi4.frequency(name[, molecule, return_wfn, func, mode, dertype, irrep])[source]; Function to compute harmonic vibrational frequencies. Aliases:; frequencies(), freq(). Returns:; float – Total electronic energy in Hartrees. Returns:; (float, Wavefunction) – energy and wavefunction when return_wfn specified. Parameters:. name (str) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype) – \(\Rightarrow\) 'hessian' \(\Lef",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/freq.html:1053,energy,energy,1053,psi4manual/master/freq.html,https://psicode.org,https://psicode.org/psi4manual/master/freq.html,1,['energy'],['energy']
Energy Efficiency," Module ». SAPT¶; Performs symmetry adapted perturbation theory (SAPT) analysis to quantitatively analyze noncovalent interactions. General¶. AIO_CPHF¶. Do use asynchronous disk I/O in the solution of the CPHF equations? Use may speed up the computation slightly at the cost of spawning an additional thread. Type: boolean; Default: false. AIO_DF_INTS¶. Do use asynchronous disk I/O in the formation of the DF integrals? Use may speed up the computation slightly at the cost of spawning an additional thread. Type: boolean; Default: false. BASIS¶. Primary basis set, describes the monomer molecular orbitals. Type: string; Possible Values: basis string; Default: No Default. CCD_E_CONVERGENCE¶. E converge value for CCD. Type: conv double; Default: 1e-8. CCD_MAXITER¶. Max CCD iterations. Type: integer; Default: 50. CCD_T_CONVERGENCE¶. Convergence tolerance for CCD amplitudes. Type: conv double; Default: 1e-8. DENOMINATOR_ALGORITHM¶. Denominator algorithm for PT methods. Laplace transformations are slightly more efficient. Type: string; Possible Values: LAPLACE, CHOLESKY; Default: LAPLACE. DENOMINATOR_DELTA¶. Maximum error allowed (Max error norm in Delta tensor) in the approximate energy denominators employed for most of the and evaluation. Type: double; Default: 1.0e-6. DF_BASIS_ELST¶. Auxiliary basis set for SAPT Elst10 and Exch10 density fitting computations, may be important if heavier elements are involved. Defaults to DF_BASIS_SAPT. Type: string; Possible Values: basis string; Default: No Default. DF_BASIS_SAPT¶. Auxiliary basis set for SAPT density fitting computations. Defaults to a RI basis. Type: string; Possible Values: basis string; Default: No Default. D_CONVERGENCE¶. Convergence criterion for residual of the CPHF coefficients in the SAPT term. Type: conv double; Default: 1e-8. EXCH_SCALE_ALPHA¶. Whether or not to perform exchange scaling for SAPT exchange components. Default is false, i.e. no scaling. If set to true, performs scaling with . If set to a value , pe",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__sapt-1.html:1169,efficient,efficient,1169,psi4manual/1.0.0/autodir_options_c/module__sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__sapt-1.html,2,['efficient'],['efficient']
Energy Efficiency," Module ». SAPT¶; Performs symmetry adapted perturbation theory (SAPT) analysis to quantitatively analyze noncovalent interactions. General¶. AIO_CPHF¶. Do use asynchronous disk I/O in the solution of the CPHF equations? Use may speed up the computation slightly at the cost of spawning an additional thread. Type: boolean; Default: false. AIO_DF_INTS¶. Do use asynchronous disk I/O in the formation of the DF integrals? Use may speed up the computation slightly at the cost of spawning an additional thread. Type: boolean; Default: false. BASIS¶. Primary basis set, describes the monomer molecular orbitals. Type: string; Possible Values: basis string; Default: No Default. CCD_E_CONVERGENCE¶. E converge value for CCD. Type: conv double; Default: 1e-8. CCD_MAXITER¶. Max CCD iterations. Type: integer; Default: 50. CCD_T_CONVERGENCE¶. Convergence tolerance for CCD amplitudes. Type: conv double; Default: 1e-8. DENOMINATOR_ALGORITHM¶. Denominator algorithm for PT methods. Laplace transformations are slightly more efficient. Type: string; Possible Values: LAPLACE, CHOLESKY; Default: LAPLACE. DENOMINATOR_DELTA¶. Maximum error allowed (Max error norm in Delta tensor) in the approximate energy denominators employed for most of the and evaluation. Type: double; Default: 1.0e-6. DF_BASIS_ELST¶. Auxiliary basis set for SAPT Elst10 and Exch10 density fitting computations, may be important if heavier elements are involved. Defaults to DF_BASIS_SAPT. Type: string; Possible Values: basis string; Default: No Default. DF_BASIS_SAPT¶. Auxiliary basis set for SAPT density fitting computations. Defaults to a RI basis. Type: string; Possible Values: basis string; Default: No Default. D_CONVERGENCE¶. Convergence criterion for residual of the CPHF coefficients in the SAPT term. Type: conv double; Default: 1e-8. E_CONVERGENCE¶. Convergence criterion for energy (change) in the SAPT term during solution of the CPHF equations. Type: conv double; Default: 1e-10. FREEZE_CORE¶. The scope of core orbitals",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodir_options_c/module__sapt-1.html:1162,efficient,efficient,1162,psi4manual/4.0b4/autodir_options_c/module__sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodir_options_c/module__sapt-1.html,4,['efficient'],['efficient']
Energy Efficiency," Module. SAPT¶; Performs symmetry adapted perturbation theory (SAPT) analysis to quantitatively analyze non-covalent interactions. SAPT(HF)¶. AIO_CPHF¶. Do use asynchronous disk I/O in the solution of the CPHF equations? Use may speed up the computation slightly at the cost of spawning an additional thread. Type: boolean; Default: false. AIO_DF_INTS¶. Do use asynchronous disk I/O in the formation of the DF integrals? Use may speed up the computation slightly at the cost of spawning an additional thread. Type: boolean; Default: false. BASIS¶. Primary basis set, describes the monomer molecular orbitals. Type: string; Possible Values: basis string; Default: No Default. CCD_E_CONVERGENCE¶. E converge value for CCD. Type: conv double; Default: 1e-8. CCD_MAXITER¶. Max CCD iterations. Type: integer; Default: 50. CCD_T_CONVERGENCE¶. Convergence tolerance for CCD amplitudes. Type: conv double; Default: 1e-8. DENOMINATOR_ALGORITHM¶. Denominator algorithm for PT methods. Laplace transformations are slightly more efficient. Type: string; Possible Values: LAPLACE, CHOLESKY; Default: LAPLACE. DENOMINATOR_DELTA¶. Maximum error allowed (Max error norm in Delta tensor) in the approximate energy denominators employed for most of the \(E_{disp}^{(20)}\) and \(E_{exch-disp}^{(20)}\) evaluation. Type: double; Default: 1.0e-6. DF_BASIS_ELST¶. Auxiliary basis set for SAPT Elst10 and Exch10 density fitting computations, may be important if heavier elements are involved. Defaults to DF_BASIS_SAPT. Type: string; Possible Values: basis string; Default: No Default. DF_BASIS_SAPT¶. Auxiliary basis set for SAPT density fitting computations. Defaults to a RI basis. Type: string; Possible Values: basis string; Default: No Default. D_CONVERGENCE¶. Convergence criterion for residual of the CPHF coefficients in the SAPT \(E_{ind,resp}^{(20)}\) term. Type: conv double; Default: 1e-8. EXCH_SCALE_ALPHA¶. Whether or not to perform exchange scaling for SAPT exchange components. Default is false, i.e. no sc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__sapt-1.html:1119,efficient,efficient,1119,psi4manual/1.3.2/autodir_options_c/module__sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__sapt-1.html,4,['efficient'],['efficient']
Energy Efficiency," Molden file is; also used to pass information between Psi4 and WebMO, if Psi4; computations are invoked using the WebMO GUI. The filename of the; Molden file ends in ”.molden”, and the prefix is determined by; WRITER_FILE_LABEL (if set), or else by the name of the output; file plus the name of the current molecule. molden(wfn, filename)[source]¶; Function to write wavefunction information in wfn to filename in; molden format. Will write natural orbitals from density (MO basis) if supplied. New in version 0.5: wfn parameter passed explicitly. Returns:None. Parameters:; wfn (Wavefunction) – set of molecule, basis, orbitals from which to generate cube files; filename (string) – destination file name for MOLDEN file; density_a (psi4.Matrix) – density in the MO basis to build alpha NO’s from (optional); density_b (psi4.Matrix) – density in the MO basis to build beta NO’s from, assumes restricted if not supplied (optional). Examples:. >>> # [1] Molden file for DFT calculation; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> molden(wfn, 'mycalc.molden'). >>> # [2] Molden file for CI/MCSCF computation using NO roots; >>> E, wfn = energy('ci', return_wfn=True); >>> molden(wfn, 'no_root1.molden', density_a=wfn.opdm(0, 0, ""A"", True)). Options¶. MOLDEN_WRITE¶. Do write a MOLDEN output file? If so, the filename will end in .molden, and the prefix is determined by WRITER_FILE_LABEL (if set), or else by the name of the output file plus the name of the current molecule. Type: boolean; Default: false. WRITER_FILE_LABEL¶. Base filename for text files written by PSI, such as the MOLDEN output file, the Hessian file, the internal coordinate file, etc. Use the add_str_i function to make this string case sensitive. Type: string; Default: No Default. Table Of Contents. Interface to Molden, molden(); Options; MOLDEN_WRITE; WRITER_FILE_LABEL. Previous topic; Interface to PCMSolver; Next topic; Interface to MRCC by M. Kállay. This Page. Show Source. Quick search. Enter search terms or a m",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/molden-1.html:1859,energy,energy,1859,psi4manual/1.0.0/molden-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/molden-1.html,2,['energy'],['energy']
Energy Efficiency," Molecule on which to run dispersion calculation. Both qcdb and; 	 psi4.core Molecule classes have been extended by this method, so; 	 either allowed. Alternately, a string that can be instantiated; 	 into a qcdb.Molecule.; func : str or None; 	 Density functional (Psi4, not Turbomole, names) for which to; 	 load parameters from dashcoeff[dashlvl][func]. This is not; 	 passed to DFTD3 and thus may be a dummy or `None`. Any or all; 	 parameters initialized can be overwritten via `dashparam`.; dashlvl : {'d2p4', 'd2gr', 'd3zero', 'd3bj', 'd3mzero', d3mbj', 'd', 'd2', 'd3', 'd3m'}; 	 Flavor of a posteriori dispersion correction for which to load; 	 parameters and call procedure in DFTD3. Must be a keys in; 	 dashcoeff dict (or a key in dashalias that resolves to one).; dashparam : dict, optional; 	 Dictionary of the same keys as dashcoeff[dashlvl] used to; 	 override any or all values initialized by; 	 dashcoeff[dashlvl][func].; dertype : {None, 0, 'none', 'energy', 1, 'first', 'gradient'}, optional; 	 Maximum derivative level at which to run DFTD3. For large; 	 `mol`, energy-only calculations can be significantly more; 	 efficient. Also controls return values, see below.; verbose : bool, optional; When `True`, additionally include DFTD3 output in output. Returns; -------; energy : float, optional; When `dertype` is 0, energy [Eh].; gradient : list of lists of floats or psi4.core.Matrix, optional; When `dertype` is 1, (nat, 3) gradient [Eh/a0].; (energy, gradient) : float and list of lists of floats or psi4.core.Matrix, optional; When `dertype` is unspecified, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; -----; research site: https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/dft-d3; Psi4 mode: When `psi4` the python module is importable at `import qcdb`; time, Psi4 mode is activated, with the following alterations:; * output goes to output file; * gradient returned as psi4.core.Matrix, not list o'lists; * scratch is written to randomly named subdir",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/qcdb/interface_dftd3.html:3107,energy,energy,3107,psi4manual/1.2.1/_modules/qcdb/interface_dftd3.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/qcdb/interface_dftd3.html,1,['energy'],['energy']
Energy Efficiency," NIRREP is the number of irreducible representations in the computational point group. If there are no orbitals of a particular symmetry type a zero must be entered. For more information and an example see CFOUR_OCCUPATION . Type: array; Default: No Default. CFOUR_ANHARMONIC¶. Specifies treatment of anharmonic effects by calculating cubic and/or quartic force fields. VIBROT (=3) requests calculation of only those cubic constants of the form \(\phi_{nij}\), where n is a totally symmetric coordinate. These are sufficient to determine the vibration-rotation interaction constants needed to calculate vibrational corrections to rotational constants, but are not sufficient to generate the corresponding cubic constants of isotopologs that have a lower point-group symmetry (i.e. HOD isotopolog of water). VPT2 (=1, note that the old value CUBIC can be still used and is equivalent to VPT2) generates all cubic constants and all quartic constants apart from those of the form \(\phi_{ijkl}\), which is enough for: 1) generation of cubic constants of isotopologs (see manual entries associated with anharmonic calculations for an example); 2) calculation of vibrational energy levels with VPT2. This keyword also directs the program to analyze resonances and calculate intensities of one- and two-quantum transitions. FULLQUARTIC (=2) (not part of the public release) is largely self-explanatory; it directs the program to calculate all quartic constants. This is sufficient (but this has not been implemented) to generate the full quartic force field of all isotopologs. Type: string; Possible Values: CUBIC, VPT2, FULLQUARTIC, VIBROT, OFF; Default: OFF. CFOUR_ANH_ALGORITHM¶. Specifies which algorithm is used for CFOUR_ANHARMONIC =VIBROT, VPT2, and FULLQUARTIC calculations. If STANDARD (=0) is chosen, then simply invoking xcfour will cause a complete job to be run with all second-derivative calculations being done in series. If PARALLEL (=1), then the job stops after the second-derivative cal",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__cfour-1.html:2663,energy,energy,2663,psi4manual/1.3.2/autodir_options_c/module__cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__cfour-1.html,15,['energy'],['energy']
Energy Efficiency," NL_DISPERSION_PARAMETERS tuple updated ‘bench’ reference values for new BraggSlater radii. dfmp2-grad5; Tests DF-MP2 gradient in the presence of a dipole field. opt6; Various constrained energy minimizations of HOOH with cc-pvdz RHF Internal-coordinate constraints in internal-coordinate optimizations. molden2; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. dfccsd-t-grad1; DF-CCSD(T) cc-pVDZ gradients for the H2O molecule. dfmp2-grad2; DF-MP2 cc-pVDZ gradient for the NO molecule. casscf-semi; CASSCF/6-31G** energy point. Check energy with frozen core/virtual orbs. after semicanonicalization. dlpnomp2-1; comparison of DF-MP2 and DLPNO-MP2. scf4; RHF cc-pVDZ energy for water, automatically scanning the symmetric stretch and bending coordinates using Python’s built-in loop mechanisms. The geometry is specified using a Z-matrix with variables that are updated during the potential energy surface scan, and then the same procedure is performed using polar coordinates, converted to Cartesian coordinates. dfmp2-grad1; DF-MP2 cc-pVDZ gradients for the H2O molecule. pywrap-cbs1; Various basis set extrapolation tests. dfmp2-ecp; Ne-Xe dimer MP2 energies with ECP, with electrons correlated then frozen. scf3; File retention, docc, socc, and bond distances specified explicitly. mbis-2; MBIS calculation on OH- (Expanded Arrays). opt13; B3LYP cc-pVDZ geometry optimzation of phenylacetylene, starting from not quite linear structure updated reference due to new BraggSlater radii. cisd-h2o-clpse; 6-31G** H2O Test CISD Energy Point with subspace collapse. mbis-3; MBIS calculation on OH radical. props1; RHF STO-3G dipole moment computation, performed by applying a finite electric field and numerical differentiat",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html:7331,energy,energy,7331,psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency," NO radical. dcft5; DC-06 calculation for the O2 molecule (triplet ground state). This performs geometry optimization using two-step and simultaneous solution of the response equations for the analytic gradient. opt-irc-1; Compute the IRC for HOOH torsional rotation at the RHF/DZP level of theory. sapt-ecp; sapt0 of charged system in ECP basis set. mints10; H2 with tiny basis set, to test basis set parser’s handling of integers. dcft2; DC-06 calculation for the He dimer. This performs a two-step update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the MO Basis. fci-tdm-2; BH-H2+ FCI/cc-pVDZ Transition Dipole Moment. dfcasscf-fzc-sp; CASSCF/6-31G** energy point. cepa2; cc-pvdz H2O Test ACPF Energy/Properties. cc24; Single point gradient of 1-2B1 state of H2O+ with EOM-CCSD. castup1; Test of SAD/Cast-up (mainly not dying due to file weirdness). dfomp3-grad1; DF-OMP3 cc-pVDZ gradients for the H2O molecule. pywrap-alias; Test parsed and exotic calls to energy() like zapt4, mp2.5, and cisd are working. fci-dipole; 6-31G H2O Test FCI Energy Point. sapt-dft1; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. cc2; 6-31G** H2O CCSD optimization by energies, with Z-Matrix input. dft1; DFT Functional Test. nbody-intermediates; HF/cc-pVDZ many body energies of an arbitrary noble gas trimer complex Size vs cost tradeoff is rough here. cc11; Frozen-core CCSD(ROHF)/cc-pVDZ on CN radical with disk-based AO algorithm. pywrap-cbs1; Various basis set extrapolation tests. x2c3; Test of SFX2C-1e on Water uncontracted cc-pVDZ The reference numbers are from Lan Cheng’s implementation in Cfour. cubeprop-esp; RHF orbitals and density for water. cc49; EOM-CC3(UHF) on CH radical with user-specified basis and properties for particular root. opt-multi-dimer-c1; Multi-fragment opt of C2h methane dimer with user-combined reference points. pywrap-checkrun-uhf; This checks that all energy methods can run with a minimal input and set sy",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html:12637,energy,energy,12637,psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency," Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Psithon Functions: Invoking a Calculation. Spectroscopic Constants for Diatomics¶; Code author: Andrew C. Simmonett. psi4.driver.diatomic.anharmonicity(rvals, energies, plot_fit)[source]¶; Generates spectroscopic constants for a diatomic molecules.; Fits a diatomic potential energy curve using a weighted least squares approach; (c.f. http://dx.doi.org/10.1063/1.4862157, particularly eqn. 7), locates the minimum; energy point, and then applies second order vibrational perturbation theory to obtain spectroscopic; constants. Any number of points greater than 4 may be provided, and they should bracket the minimum.; The data need not be evenly spaced, and can be provided in any order. The data are weighted such that; those closest to the minimum have highest impact.; A dictionary with the following keys, which correspond to spectroscopic constants, is returned:. Parameters:; rvals (list) – The bond lengths (in Angstrom) for which energies are; provided, of length at least 5 and equal to the length of the energies array; energies (list) – The energies (Eh) computed at the bond lengths in the rvals list; plot_fit (string) – A string describing where to save a plot of the harmonic and anharmonic fits, the; inputted data points, re, r0 and the first few energy levels, if matplotlib; is available. Set to ‘screen’ to generate an interactive plot on the screen instead. If a filename is; provided, the image type is determined by the extension; see matplotlib for supported file types. Returns:(dict) Keys: “re”, “r0”, “we”, “wexe”, “nu”, “ZPVE(harmonic)”, “ZPVE(anharmonic)”, “Be”, “B0”, “ae”, “De”; corresponding to the spectroscopic constants in cm-1. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Psithon Functions: Invoking a Calculation. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/diatomic-1.html:1377,energy,energy,1377,psi4manual/1.3.2/diatomic-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/diatomic-1.html,2,['energy'],['energy']
Energy Efficiency," Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». Function Intercalls¶; For many of the PSI4 Python functions described above, it makes scientific; sense that they could be called in combination. For instance, one could; optimize all the reagents in a database or compute a; counterpoise-corrected interaction energy with an extrapolated method. The; table below outlines permitted intercalls between functions, showing that; db(opt(cbs(energy()))) is allowed, while db(cp(energy())) is not. This; table is not yet validated for calls with cp(). Permitted nesting of Psithon functions. Caller; Callee.  ; cp; db; opt; cbs; energy. Counterpoise Correct;  ; —; Y; Y; Y. Database; —;  ; Y; Y; Y. Optimize; —; —;  ; Y; Y. Complete Basis Set; —; —; —;  ; Y. Energy; —; —; —; —;  . The command db(opt(cbs(energy()))) is actually expressed as db(...,; db_func=opt, opt_func=cbs). The perhaps expected final argument of; cbs_func=energy is not necessary since energy() is always the function; called by default. Also, the outermost internal function call (db_func; above can be called as just func. Several examples of intercalls; between Python functions can be found in sample input pywrap_all.; All keyword arguments are passed along to each function traversed in the; Python driver, so there should be no concern for separating them, grouping; them, or designating them for a particular function when undertaking a; nested calculation. Where the same keyword is used by multiple functions,; prefixes are added, e.g., db_mode and opt_mode.; Function intercalls should not be used in sow/reap mode. Previous topic; <no title>; Next topic; Embarrassing Parallelism; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Create",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/intercalls-1.html:1037,energy,energy,1037,psi4manual/4.0b2/intercalls-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/intercalls-1.html,4,['energy'],['energy']
Energy Efficiency," Ne; Ne 1 2.0; }. nene.update_geometry(). >>> E, G = nene.run_gcp('hf3c'). >>> E, G = nene.run_gcp(func='HF3c', verbose=True). qcdb.Molecule.run_gcp(self, func=None, dertype=None, verbose=1)¶; Compute geometrical BSSE correction via Grimme’s GCP program.; Function to call Grimme’s GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to self for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, func. Returns energy if dertype is 0, gradient; if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The gcp executable must be independently compiled and; found in PATH or PSIPATH. self may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.Molecule. Parameters. func (str, optional) – Name of method/basis combination or composite method for which to compute the correction; (e.g., HF/cc-pVDZ, DFT/def2-SVP, HF3c, PBEh3c).; dertype (int or str, optional) – Maximum derivative level at which to run GCP. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int, optional) – Amount of printing. Unused at present. Returns. energy (float) – When dertype=0, energy [Eh].; gradient (ndarray) – When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray) – When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. table of contents. Interface to gCP by S. Grimme; Installation; Running gCP. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to gCP by S. Grimme. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/gcp-1.html:3910,energy,energy-only,3910,psi4manual/1.4.0/gcp-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/gcp-1.html,12,"['efficient', 'energy']","['efficient', 'energy', 'energy-only']"
Energy Efficiency," Ne; Ne 1 2.0; }. nene.update_geometry(). >>> E, G = nene.run_gcp('hf3c'). >>> E, G = nene.run_gcp(func='HF3c', verbose=True). qcdb.Molecule.run_gcp(self, func=None, dertype=None, verbose=1)¶; Compute geometrical BSSE correction via Grimme’s GCP program.; Function to call Grimme’s GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to self for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, func. Returns energy if dertype is 0, gradient; if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The gcp executable must be independently compiled and; found in PATH or PSIPATH. self may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.Molecule. Parameters. func (str, optional) – Name of method/basis combination or composite method for which to compute the correction; (e.g., HF/cc-pVDZ, DFT/def2-SVP, HF3c, PBEh3c).; dertype (int or str, optional) – Maximum derivative level at which to run GCP. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int, optional) – Amount of printing. Unused at present. Returns. energy (float) – When dertype=0, energy [Eh].; gradient (ndarray) – When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray) – When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. table of contents. Interface to gCP by S. Grimme; Installation; Running gCP. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to gCP by S. Grimme. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/gcp-1.html:3910,energy,energy-only,3910,psi4manual/1.5.0/gcp-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/gcp-1.html,12,"['efficient', 'energy']","['efficient', 'energy', 'energy-only']"
Energy Efficiency," Nmin = 0;; if (kwargs.has_key('nmax')):; Nmin = N - int(kwargs['nmax']). # By default, DIIS in FRAC (1.0 occupation is always DIIS'd); frac_diis = True; if kwargs.has_key('frac_diis'):; frac_diis = kwargs['frac_diis']. # By default, drop the files to the molecule's name; root = mol.name(); if kwargs.has_key('filename'):; root = kwargs['filename']; traverse_filename = root + '.traverse.dat'; stats_filename = root + '.stats.dat' . # => Traverse <= #; PsiMod.set_global_option(""DF_INTS_IO"", ""SAVE""). Ns = []; energies = []; potentials = []; convs = []; stats = []. # Run one SCF to burn things in; energy('scf'). # Determine HOMO; ref = PsiMod.wavefunction(); eps_a = ref.epsilon_a(); eps_b = ref.epsilon_b(); if (Na == Nb):; HOMO = -Nb; elif (Nb == 0):; HOMO = Na; else:; E_a = eps_a[int(Na - 1)] ; E_b = eps_b[int(Nb - 1)] ; if (E_a >= E_b):; HOMO = Na; else: ; HOMO = -Nb. stats.append('\t%6d %6d %6d %6d %6d %6d\n' %(N, Na, Nb, charge, mult, HOMO)). if (HOMO > 0):; Na = Na - 1; else:; Nb = Nb - 1; charge = charge + 1; mult = Na - Nb + 1. PsiMod.set_global_option(""DF_INTS_IO"", ""LOAD""); PsiMod.set_global_option(""FRAC_START"", frac_start); PsiMod.set_global_option(""FRAC_RENORMALIZE"", True). # Nuke 'em Rico! ; for Nintegral in range(N,Nmin,-1):. # Nuke the current HOMO; for occ in foccs:. PsiMod.set_global_option(""FRAC_OCC"", [HOMO]); PsiMod.set_global_option(""FRAC_VAL"", [occ]) . E = energy('scf'); C = 1; if (E == 0.0):; E = PsiMod.get_variable('SCF ITERATION ENERGY'); C = 0. if (HOMO > 0):; ref = PsiMod.wavefunction(); eps = ref.epsilon_a(); potentials.append(eps[HOMO-1]); else:; ref = PsiMod.wavefunction(); eps = ref.epsilon_b(); potentials.append(eps[-HOMO-1]). Ns.append(Nintegral + occ - 1.0); energies.append(E); convs.append(C). PsiMod.set_global_option(""FRAC_START"", 2); PsiMod.set_global_option(""FRAC_LOAD"", True); PsiMod.set_global_option(""FRAC_DIIS"", frac_diis); PsiMod.set_global_option(""GUESS"", ""READ""). # Set the next charge/mult; mol.set_molecular_charge(charge) ; mol.se",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/frac.html:8240,charge,charge,8240,psi4manual/4.0b4/_modules/frac.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/frac.html,2,['charge'],['charge']
Energy Efficiency," No Default. DOCC (MCSCF); MCSCF — The number of doubly occupied orbitals, per irrep. Type: array; Default: No Default. DYNAMIC_LEVEL (OPTKING); OPTKING — Starting level for dynamic optimization (0=nondynamic, higher=>more conservative). Type: integer; Default: 0. E3_SCALE (DFOCC); DFOCC — CEPA opposite-spin scaling value from SCS-CCSD. Type: double; Default: 0.25. E3_SCALE (OCC); OCC — Scaling value for 3rd order energy correction (S. Grimme, Vol. 24, pp. 1529, J. Comput. Chem.). Type: double; Default: 0.25. E_CONVERGENCE (CCENERGY); CCENERGY — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. E_CONVERGENCE (CCEOM); CCEOM — Convergence criterion for excitation energy (change) in the Davidson algorithm for CC-EOM. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. E_CONVERGENCE (DCFT); DCFT — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-10. E_CONVERGENCE (DETCI); DETCI — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. E_CONVERGENCE (DFOCC); DFOCC — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. E_CONVERGENCE (FNOCC); FNOCC — Convergence criterion for CC energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Note that convergence is met only when E_CONVERGENCE and R_CONVERGENCE are satisfied. Type: conv double; Default: 1.0e-6. E_CONVERGENCE (MCSCF); MCSCF — Convergence criterion for energy. Type: conv double; Default: 1e-6. E_CONVERGENCE (MRCC); MRCC — Convergence criterion for ene",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:113438,energy,energy,113438,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,8,['energy'],['energy']
Energy Efficiency," No way to tell function to boost fitting basis size for all calculations. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in several; sequential stages (scf, corl, delta1, delta2, ... ) covering treatment; of the reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction, etc.. Each is activated by its; stage_wfn keyword, or as a field in the ```cbs_metadata``` list, and is only; allowed if all preceding stages are active. .. include:: ../cbs_eqn.rst. * Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy. The cbs() function requires, at a minimum, ``name='scf'`` and ``scf_basis``; keywords to be specified for reference-step only jobs and ``name`` and; ``corl_basis`` keywords for correlated jobs. The following energy methods have been set up for cbs(). .. hlist::; :columns: 5. * scf; * hf; * mp2; * mp2.5; * mp3; * mp4(sdq); * mp4; * mp\ *n*; * omp2; * omp2.5; * omp3; * olccd; * lccd; * lccsd; * cepa(0); * cepa(1); * cepa(3); * acpf; * aqcc; * qcisd; * cc2; * ccsd; * fno-ccsd; * bccd; * cc3; * qcisd(t); * ccsd(t); * fno-ccsd(t); * bccd(t); * cisd; * cisdt; * cisdtq; * ci\ *n*; * fci; * mrccsd; * mrccsd(t); * mrccsdt; * mrccsdt(q). :type name: str; :param name: ``'scf'`` || ``'ccsd'`` || etc. First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be ``'scf'``. Overruled if stage_wfn keywords supplied. :type scf_wfn: str; :param scf_wfn: |dl| ``'scf'`` |dr| || ``'c4-scf'`` || etc. Indicates the energy method for which the reference energy is to be; obtained. Generally unnecessary, as 'scf' is *the* scf in |PSIfour| but; can be used to direct lone scf components to run in |PSIfour| or Cfour; in a mixe",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html:35401,energy,energy,35401,psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,1,['energy'],['energy']
Energy Efficiency," None; Sets the specified list arg2 of fragments to be Real. set_basis_all_atoms(self: psi4.core.Molecule, arg0: str, arg1: str) → None; Sets basis set arg2 to all atoms. set_basis_by_label(self: psi4.core.Molecule, arg0: str, arg1: str, arg2: str) → None; Sets basis set arg3 to all atoms with label (e.g., H4) arg2. set_basis_by_symbol(self: psi4.core.Molecule, arg0: str, arg1: str, arg2: str) → None; Sets basis set arg3 to all atoms with symbol (e.g., H) arg2. set_geometry(self: psi4.core.Molecule, arg0: psi4.core.Matrix) → None; Sets the geometry, given a (Natom X 3) matrix arg2 of coordinates (in Bohr). set_ghost_fragment(self: psi4.core.Molecule, arg0: int) → None; Sets the specified fragment arg2 to be Ghost. set_ghost_fragments(self: psi4.core.Molecule, arg0: list) → None; Sets the specified list arg2 of fragments to be Ghost. set_mass(self: psi4.core.Molecule, arg0: int, arg1: float) → None; Gets mass of atom arg1. set_molecular_charge(self: psi4.core.Molecule, arg0: int) → None; Sets the molecular charge. set_multiplicity(self: psi4.core.Molecule, arg0: int) → None; Sets the multiplicity (defined as 2Ms + 1). set_name(self: psi4.core.Molecule, arg0: str) → None; Sets molecule name. set_point_group(self: psi4.core.Molecule, arg0: psi4.core.PointGroup) → None; Sets the molecular point group to the point group object arg2. set_variable(self: psi4.core.Molecule, arg0: str, arg1: float) → None; Assigns the value arg3 to the variable arg2 in the list of geometry variables, then calls update_geometry(). symbol(self: psi4.core.Molecule, arg0: int) → str; Gets the cleaned up label of atom arg1 (C2 => C, H4 = H) (0-indexed). symmetrize(self: psi4.core.Molecule, arg0: float) → None; Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry. translate(self: psi4.core.Molecule, arg0: psi4.core.Vector3) → None; Translates molecule by arg1. units; Units (Angstrom or Bohr) used to define the geometry. update_geo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html:31181,charge,charge,31181,psi4manual/1.1.0/api/psi4.core.molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html,1,['charge'],['charge']
Energy Efficiency," Normal Modes — frequency() and hessian(). Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Psithon Functions: Invoking a Calculation; Harmonic Vibrational Analysis and Visualization of Normal Modes — frequency() and hessian(). Harmonic Vibrational Analysis and Visualization of Normal Modes — frequency() and hessian()¶. Psi4 Native Hessian Methods. For further discussion of vibrational and thermochemical analysis,; see Sec. Vibrational and Thermochemical Analysis.; frequency() is the only command most users will ever; need to access directly to perform frequency calculations. Behind; the scenes, frequency() is a light wrapper over; hessian() that computes the Hessian then adds a; thermochemical analysis. psi4.frequency(name[, molecule, return_wfn, func, mode, dertype, irrep])[source]; Function to compute harmonic vibrational frequencies. Aliases:; frequencies(), freq(). Returns:; float – Total electronic energy in Hartrees. Returns:; (float, Wavefunction) – energy and wavefunction when return_wfn specified. Parameters:. name (str) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype) – \(\Rightarrow\) 'hessian' \(\Lef",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/freq.html:1046,energy,energy,1046,psi4manual/1.8.x/freq.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/freq.html,1,['energy'],['energy']
Energy Efficiency," Normal Modes — frequency() and hessian(). Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Psithon Functions: Invoking a Calculation; Harmonic Vibrational Analysis and Visualization of Normal Modes — frequency() and hessian(). Harmonic Vibrational Analysis and Visualization of Normal Modes — frequency() and hessian()¶. Psi4 Native Hessian Methods. For further discussion of vibrational and thermochemical analysis,; see Sec. Vibrational and Thermochemical Analysis.; frequency() is the only command most users will ever; need to access directly to perform frequency calculations. Behind; the scenes, frequency() is a light wrapper over; hessian() that computes the Hessian then adds a; thermochemical analysis. psi4.frequency(name[, molecule, return_wfn, func, mode, dertype, irrep])[source]; Function to compute harmonic vibrational frequencies. Aliases:; frequencies(), freq(). Returns:; float – Total electronic energy in Hartrees. Returns:; (float, Wavefunction) – energy and wavefunction when return_wfn specified. Parameters:. name (str) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype) – \(\Rightarrow\) 'hessian' \(\Lef",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/freq.html:1046,energy,energy,1046,psi4manual/1.9.x/freq.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/freq.html,1,['energy'],['energy']
Energy Efficiency," Note that this option is enabled automatically if the memory requirements of the conventional algorithm would exceed the available resources. The low memory algorithm is faster in general and has been turned on by default starting September 2020. Type: boolean; Default: true. Expert¶. CEPA_LEVEL¶. Which coupled-pair method is called? This parameter is used internally by the python driver. Changing its value won’t have any effect on the procedure. Type: string; Default: CEPA(0). COMPUTE_MP4_TRIPLES¶. Do compute MP4 triples contribution?. Type: boolean; Default: false. COMPUTE_TRIPLES¶. Do compute triples contribution?. Type: boolean; Default: true. RUN_CCSD¶. do ccsd rather than qcisd?. Type: boolean; Default: false. RUN_CEPA¶. Is this a CEPA job? This parameter is used internally by the pythond driver. Changing its value won’t have any effect on the procedure. Type: boolean; Default: false. RUN_MP2¶. do only evaluate mp2 energy?. Type: boolean; Default: false. RUN_MP3¶. do only evaluate mp3 energy?. Type: boolean; Default: false. RUN_MP4¶. do only evaluate mp4 energy?. Type: boolean; Default: false. USE_DF_INTS¶. Use 3-index integrals to generate 4-index ERI’s? This keyword is used for testing purposes only. Changing its value will have no effect on the computation. Type: boolean; Default: false. table of contents. FNOCC; General; ACTIVE_NAT_ORBS; BRUECKNER_MAXITER; CC_SCALE_OS; CC_SCALE_SS; CC_TIMINGS; CEPA_NO_SINGLES; CHOLESKY_TOLERANCE; DFCC; DF_BASIS_CC; DIIS_MAX_VECS; DIPMOM; E_CONVERGENCE; MAXITER; MP2_SCALE_OS; MP2_SCALE_SS; NAT_ORBS; OCC_PERCENTAGE; OCC_TOLERANCE; R_CONVERGENCE; SCS_CCSD; SCS_CEPA; SCS_MP2; TRIPLES_LOW_MEMORY. Expert; CEPA_LEVEL; COMPUTE_MP4_TRIPLES; COMPUTE_TRIPLES; RUN_CCSD; RUN_CEPA; RUN_MP2; RUN_MP3; RUN_MP4; USE_DF_INTS. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; FNOCC. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodir_options_c/module__fnocc.html:4300,energy,energy,4300,psi4manual/master/autodir_options_c/module__fnocc.html,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/module__fnocc.html,1,['energy'],['energy']
Energy Efficiency," Note that this option is enabled automatically if the memory requirements of the conventional algorithm would exceed the available resources. The low memory algorithm is faster in general and has been turned on by default starting September 2020. Type: boolean; Default: true. Expert¶. CEPA_LEVEL¶. Which coupled-pair method is called? This parameter is used internally by the python driver. Changing its value won’t have any effect on the procedure. Type: string; Default: CEPA(0). COMPUTE_MP4_TRIPLES¶. Do compute MP4 triples contribution?. Type: boolean; Default: false. COMPUTE_TRIPLES¶. Do compute triples contribution?. Type: boolean; Default: true. RUN_CCSD¶. do ccsd rather than qcisd?. Type: boolean; Default: false. RUN_CEPA¶. Is this a CEPA job? This parameter is used internally by the pythond driver. Changing its value won’t have any effect on the procedure. Type: boolean; Default: false. RUN_MP2¶. do only evaluate mp2 energy?. Type: boolean; Default: false. RUN_MP3¶. do only evaluate mp3 energy?. Type: boolean; Default: false. RUN_MP4¶. do only evaluate mp4 energy?. Type: boolean; Default: false. USE_DF_INTS¶. Use 3-index integrals to generate 4-index ERI’s? This keyword is used for testing purposes only. Changing its value will have no effect on the computation. Type: boolean; Default: false. table of contents. FNOCC; General; ACTIVE_NAT_ORBS; BRUECKNER_MAXITER; CC_SCALE_OS; CC_SCALE_SS; CC_TIMINGS; CEPA_NO_SINGLES; CHOLESKY_TOLERANCE; DFCC; DF_BASIS_CC; DIIS_MAX_VECS; DIPMOM; E_CONVERGENCE; MAXITER; MP2_SCALE_OS; MP2_SCALE_SS; NAT_ORBS; OCC_PERCENTAGE; OCC_TOLERANCE; R_CONVERGENCE; SCS_CCSD; SCS_CEPA; SCS_MP2; TRIPLES_LOW_MEMORY. Expert; CEPA_LEVEL; COMPUTE_MP4_TRIPLES; COMPUTE_TRIPLES; RUN_CCSD; RUN_CEPA; RUN_MP2; RUN_MP3; RUN_MP4; USE_DF_INTS. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; FNOCC. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodir_options_c/module__fnocc-1.html:4291,energy,energy,4291,psi4manual/1.4.0/autodir_options_c/module__fnocc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/module__fnocc-1.html,2,['energy'],['energy']
Energy Efficiency," Note that this option is enabled automatically if the memory requirements of the conventional algorithm would exceed the available resources. The low memory algorithm is faster in general and has been turned on by default starting September 2020. Type: boolean; Default: true. Expert¶. CEPA_LEVEL¶. Which coupled-pair method is called? This parameter is used internally by the python driver. Changing its value won’t have any effect on the procedure. Type: string; Default: CEPA(0). COMPUTE_MP4_TRIPLES¶. Do compute MP4 triples contribution?. Type: boolean; Default: false. COMPUTE_TRIPLES¶. Do compute triples contribution?. Type: boolean; Default: true. RUN_CCSD¶. do ccsd rather than qcisd?. Type: boolean; Default: false. RUN_CEPA¶. Is this a CEPA job? This parameter is used internally by the pythond driver. Changing its value won’t have any effect on the procedure. Type: boolean; Default: false. RUN_MP2¶. do only evaluate mp2 energy?. Type: boolean; Default: false. RUN_MP3¶. do only evaluate mp3 energy?. Type: boolean; Default: false. RUN_MP4¶. do only evaluate mp4 energy?. Type: boolean; Default: false. USE_DF_INTS¶. Use 3-index integrals to generate 4-index ERI’s? This keyword is used for testing purposes only. Changing its value will have no effect on the computation. Type: boolean; Default: false. table of contents. FNOCC; General; ACTIVE_NAT_ORBS; BRUECKNER_MAXITER; CC_SCALE_OS; CC_SCALE_SS; CC_TIMINGS; CEPA_NO_SINGLES; CHOLESKY_TOLERANCE; DFCC; DF_BASIS_CC; DIIS_MAX_VECS; DIPMOM; E_CONVERGENCE; MAXITER; MP2_SCALE_OS; MP2_SCALE_SS; NAT_ORBS; OCC_PERCENTAGE; OCC_TOLERANCE; R_CONVERGENCE; SCS_CCSD; SCS_CEPA; SCS_MP2; TRIPLES_LOW_MEMORY. Expert; CEPA_LEVEL; COMPUTE_MP4_TRIPLES; COMPUTE_TRIPLES; RUN_CCSD; RUN_CEPA; RUN_MP2; RUN_MP3; RUN_MP4; USE_DF_INTS. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Appendices; Keywords by Module; FNOCC. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodir_options_c/module__fnocc-1.html:4291,energy,energy,4291,psi4manual/1.5.0/autodir_options_c/module__fnocc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodir_options_c/module__fnocc-1.html,2,['energy'],['energy']
Energy Efficiency," Note that this option is enabled automatically if the memory requirements of the conventional algorithm would exceed the available resources. The low memory algorithm is faster in general and has been turned on by default starting September 2020. Type: boolean; Default: true. Expert¶. CEPA_LEVEL¶. Which coupled-pair method is called? This parameter is used internally by the python driver. Changing its value won’t have any effect on the procedure. Type: string; Default: CEPA(0). COMPUTE_MP4_TRIPLES¶. Do compute MP4 triples contribution?. Type: boolean; Default: false. COMPUTE_TRIPLES¶. Do compute triples contribution?. Type: boolean; Default: true. RUN_CCSD¶. do ccsd rather than qcisd?. Type: boolean; Default: false. RUN_CEPA¶. Is this a CEPA job? This parameter is used internally by the pythond driver. Changing its value won’t have any effect on the procedure. Type: boolean; Default: false. RUN_MP2¶. do only evaluate mp2 energy?. Type: boolean; Default: false. RUN_MP3¶. do only evaluate mp3 energy?. Type: boolean; Default: false. RUN_MP4¶. do only evaluate mp4 energy?. Type: boolean; Default: false. USE_DF_INTS¶. Use 3-index integrals to generate 4-index ERI’s? This keyword is used for testing purposes only. Changing its value will have no effect on the computation. Type: boolean; Default: false. table of contents. FNOCC; General; ACTIVE_NAT_ORBS; BRUECKNER_MAXITER; CC_SCALE_OS; CC_SCALE_SS; CC_TIMINGS; CEPA_NO_SINGLES; CHOLESKY_TOLERANCE; DFCC; DF_BASIS_CC; DIIS_MAX_VECS; DIPMOM; E_CONVERGENCE; MAXITER; MP2_SCALE_OS; MP2_SCALE_SS; NAT_ORBS; OCC_PERCENTAGE; OCC_TOLERANCE; R_CONVERGENCE; SCS_CCSD; SCS_CEPA; SCS_MP2; TRIPLES_LOW_MEMORY. Expert; CEPA_LEVEL; COMPUTE_MP4_TRIPLES; COMPUTE_TRIPLES; RUN_CCSD; RUN_CEPA; RUN_MP2; RUN_MP3; RUN_MP4; USE_DF_INTS. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Appendices; Keywords by Module; FNOCC. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodir_options_c/module__fnocc.html:4291,energy,energy,4291,psi4manual/1.6.x/autodir_options_c/module__fnocc.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodir_options_c/module__fnocc.html,1,['energy'],['energy']
Energy Efficiency," Note that this option is enabled automatically if the memory requirements of the conventional algorithm would exceed the available resources. The low memory algorithm is faster in general and has been turned on by default starting September 2020. Type: boolean; Default: true. Expert¶. CEPA_LEVEL¶. Which coupled-pair method is called? This parameter is used internally by the python driver. Changing its value won’t have any effect on the procedure. Type: string; Default: CEPA(0). COMPUTE_MP4_TRIPLES¶. Do compute MP4 triples contribution?. Type: boolean; Default: false. COMPUTE_TRIPLES¶. Do compute triples contribution?. Type: boolean; Default: true. RUN_CCSD¶. do ccsd rather than qcisd?. Type: boolean; Default: false. RUN_CEPA¶. Is this a CEPA job? This parameter is used internally by the pythond driver. Changing its value won’t have any effect on the procedure. Type: boolean; Default: false. RUN_MP2¶. do only evaluate mp2 energy?. Type: boolean; Default: false. RUN_MP3¶. do only evaluate mp3 energy?. Type: boolean; Default: false. RUN_MP4¶. do only evaluate mp4 energy?. Type: boolean; Default: false. USE_DF_INTS¶. Use 3-index integrals to generate 4-index ERI’s? This keyword is used for testing purposes only. Changing its value will have no effect on the computation. Type: boolean; Default: false. table of contents. FNOCC; General; ACTIVE_NAT_ORBS; BRUECKNER_MAXITER; CC_SCALE_OS; CC_SCALE_SS; CC_TIMINGS; CEPA_NO_SINGLES; CHOLESKY_TOLERANCE; DFCC; DF_BASIS_CC; DIIS_MAX_VECS; DIPMOM; E_CONVERGENCE; MAXITER; MP2_SCALE_OS; MP2_SCALE_SS; NAT_ORBS; OCC_PERCENTAGE; OCC_TOLERANCE; R_CONVERGENCE; SCS_CCSD; SCS_CEPA; SCS_MP2; TRIPLES_LOW_MEMORY. Expert; CEPA_LEVEL; COMPUTE_MP4_TRIPLES; COMPUTE_TRIPLES; RUN_CCSD; RUN_CEPA; RUN_MP2; RUN_MP3; RUN_MP4; USE_DF_INTS. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Appendices; Keywords by Module; FNOCC. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 Decembe",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodir_options_c/module__fnocc.html:4291,energy,energy,4291,psi4manual/1.7.x/autodir_options_c/module__fnocc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodir_options_c/module__fnocc.html,1,['energy'],['energy']
Energy Efficiency," Note that this option is enabled automatically if the memory requirements of the conventional algorithm would exceed the available resources. The low memory algorithm is faster in general and has been turned on by default starting September 2020. Type: boolean; Default: true. Expert¶. CEPA_LEVEL¶. Which coupled-pair method is called? This parameter is used internally by the python driver. Changing its value won’t have any effect on the procedure. Type: string; Default: CEPA(0). COMPUTE_MP4_TRIPLES¶. Do compute MP4 triples contribution?. Type: boolean; Default: false. COMPUTE_TRIPLES¶. Do compute triples contribution?. Type: boolean; Default: true. RUN_CCSD¶. do ccsd rather than qcisd?. Type: boolean; Default: false. RUN_CEPA¶. Is this a CEPA job? This parameter is used internally by the pythond driver. Changing its value won’t have any effect on the procedure. Type: boolean; Default: false. RUN_MP2¶. do only evaluate mp2 energy?. Type: boolean; Default: false. RUN_MP3¶. do only evaluate mp3 energy?. Type: boolean; Default: false. RUN_MP4¶. do only evaluate mp4 energy?. Type: boolean; Default: false. USE_DF_INTS¶. Use 3-index integrals to generate 4-index ERI’s? This keyword is used for testing purposes only. Changing its value will have no effect on the computation. Type: boolean; Default: false. table of contents. FNOCC; General; ACTIVE_NAT_ORBS; BRUECKNER_MAXITER; CC_SCALE_OS; CC_SCALE_SS; CC_TIMINGS; CEPA_NO_SINGLES; CHOLESKY_TOLERANCE; DFCC; DF_BASIS_CC; DIIS_MAX_VECS; DIPMOM; E_CONVERGENCE; MAXITER; MP2_SCALE_OS; MP2_SCALE_SS; NAT_ORBS; OCC_PERCENTAGE; OCC_TOLERANCE; R_CONVERGENCE; SCS_CCSD; SCS_CEPA; SCS_MP2; TRIPLES_LOW_MEMORY. Expert; CEPA_LEVEL; COMPUTE_MP4_TRIPLES; COMPUTE_TRIPLES; RUN_CCSD; RUN_CEPA; RUN_MP2; RUN_MP3; RUN_MP4; USE_DF_INTS. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Appendices; Keywords by Module; FNOCC. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 Oct",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodir_options_c/module__fnocc.html:4293,energy,energy,4293,psi4manual/1.8.x/autodir_options_c/module__fnocc.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodir_options_c/module__fnocc.html,1,['energy'],['energy']
Energy Efficiency," Note that this option is enabled automatically if the memory requirements of the conventional algorithm would exceed the available resources. The low memory algorithm is faster in general and has been turned on by default starting September 2020. Type: boolean; Default: true. Expert¶. CEPA_LEVEL¶. Which coupled-pair method is called? This parameter is used internally by the python driver. Changing its value won’t have any effect on the procedure. Type: string; Default: CEPA(0). COMPUTE_MP4_TRIPLES¶. Do compute MP4 triples contribution?. Type: boolean; Default: false. COMPUTE_TRIPLES¶. Do compute triples contribution?. Type: boolean; Default: true. RUN_CCSD¶. do ccsd rather than qcisd?. Type: boolean; Default: false. RUN_CEPA¶. Is this a CEPA job? This parameter is used internally by the pythond driver. Changing its value won’t have any effect on the procedure. Type: boolean; Default: false. RUN_MP2¶. do only evaluate mp2 energy?. Type: boolean; Default: false. RUN_MP3¶. do only evaluate mp3 energy?. Type: boolean; Default: false. RUN_MP4¶. do only evaluate mp4 energy?. Type: boolean; Default: false. USE_DF_INTS¶. Use 3-index integrals to generate 4-index ERI’s? This keyword is used for testing purposes only. Changing its value will have no effect on the computation. Type: boolean; Default: false. table of contents. FNOCC; General; ACTIVE_NAT_ORBS; BRUECKNER_MAXITER; CC_SCALE_OS; CC_SCALE_SS; CC_TIMINGS; CEPA_NO_SINGLES; CHOLESKY_TOLERANCE; DFCC; DF_BASIS_CC; DIIS_MAX_VECS; DIPMOM; E_CONVERGENCE; MAXITER; MP2_SCALE_OS; MP2_SCALE_SS; NAT_ORBS; OCC_PERCENTAGE; OCC_TOLERANCE; R_CONVERGENCE; SCS_CCSD; SCS_CEPA; SCS_MP2; TRIPLES_LOW_MEMORY. Expert; CEPA_LEVEL; COMPUTE_MP4_TRIPLES; COMPUTE_TRIPLES; RUN_CCSD; RUN_CEPA; RUN_MP2; RUN_MP3; RUN_MP4; USE_DF_INTS. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Appendices; Keywords by Module; FNOCC. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 Febr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodir_options_c/module__fnocc.html:4293,energy,energy,4293,psi4manual/1.9.x/autodir_options_c/module__fnocc.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodir_options_c/module__fnocc.html,1,['energy'],['energy']
Energy Efficiency," Number of atoms; >>> print H2OH2O.natom(); 6. nequivalent(iuniq)[source]¶; Returns the number of atoms equivalent to iuniq. nfragments()[source]¶; The number of fragments in the molecule.; >>> print H2OH2O.nfragments(); 2. nfrozen_core(depth=False)[source]¶; Number of frozen core for molecule given freezing state.; >>> print H2OH2O.nfrozen_core(); 2. nuclear_repulsion_energy()[source]¶; Computes nuclear repulsion energy.; >>> print H2OH2O.nuclear_repulsion_energy(); 36.6628478528. nuclear_repulsion_energy_deriv1()[source]¶; Computes nuclear repulsion energy derivatives; >>> print H2OH2O.nuclear_repulsion_energy_deriv1(); [[3.9020946901323774, 2.76201566471991, 0.0], [1.3172905807089021, -2.3486366050337293, 0.0], [-1.8107598525022435, -0.32511212499256564, 0.0], [-1.217656141385739, -2.6120090867576717, 0.0], [-1.0954846384766488, 1.2618710760320282, 2.1130743287465603], [-1.0954846384766488, 1.2618710760320282, -2.1130743287465603]]. nuclear_repulsion_energy_deriv2()[source]¶; NYI Computes nuclear repulsion energy second derivatives. nunique()[source]¶; Return the number of unique atoms. orientation_fixed()[source]¶; Get whether or not orientation is fixed.; >>> H2OH2O.orientation_fixed(); True. point_group()[source]¶; Returns the point group (object) if set. print_bond_angles()[source]¶; Print the geometrical parameters (bond_angles) of the molecule.; >>> print H2OH2O.print_bond_angles(); Bond Angles (degrees); Angle 2-1-3: 104.337; Angle 2-1-4: 109.152; Angle 2-1-5: 117.387; ... print_dihedrals()[source]¶; Print the geometrical parameters (dihedrals) of the molecule.; >>> print H2OH2O.print_dihedrals(); Dihedral Angles (Degrees); Dihedral 1-2-3-4: 180.000; Dihedral 1-2-3-5: 133.511; Dihedral 1-2-3-6: 133.511; ... print_distances()[source]¶; Print the geometrical parameters (distances) of the molecule.; suspect libmints version actually prints Bohr.; >>> print H2OH2O.print_distances(); Interatomic Distances (Angstroms); Distance 1 to 2 0.957; Distance 1 to 3 0.96",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:85981,energy,energy,85981,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,2,['energy'],['energy']
Energy Efficiency," OFF otherwise). Type: boolean; Default: true. CFOUR_DBOC (CFOUR); CFOUR — Specifies whether the diagonal Born-Oppenheimer correction (DBOC) to the energy is evaluated (ON =1) or not (OFF =0). DBOC calculations are currently only available for HF-SCF and CCSD using RHF or UHF reference functions. Type: boolean; Default: false. CFOUR_DCT (CFOUR); CFOUR — Specifies whether the Dipole Coupling Tensor (DCT) is calculated (ON =1) or not (OFF =0). Type: boolean; Default: false. CFOUR_DERIV_LEVEL (CFOUR); CFOUR — Specifies whether or not energy derivatives are to be calculated and if so whether first or second derivatives are computed. ZERO (= 0) derivatives are not calculated, FIRST (=1) first derivatives are calculated, SECOND (=2) second derivatives are calculated. Note that this keyword usually needs not be set in any calculation since it is automatically set if the appropriate other options in the CFOUR namelist are turned on. Psi4 Interface: Keyword set from type of computation command: ZERO if energy(), FIRST if gradient() or optimization(), etc. Type: string; Possible Values: ZERO, FIRST, SECOND; Default: ZERO. CFOUR_DIFF_TYPE (CFOUR); CFOUR — Specifies whether orbital-relaxed (RELAXED =0) or orbital-unrelaxed (UNRELAXED =1) derivatives are computed in the CC calculation. Type: string; Possible Values: RELAXED, UNRELAXED; Default: RELAXED. CFOUR_DROPMO (CFOUR); CFOUR — Specifies which molecular orbitals will be dropped from the post-SCF calculation. The orbitals are numbered in ascending order from the most stable (negative energy) to the most unstable (largest positive energy). Individual orbitals must be separated with a dash, while x>y means orbitals x through y inclusive. For example, the string 1>10-55-58>64, would result in orbitals 1,2,3,4,5,6,7,8,9,10,55,58,59,60,61,62,63 and 64 being dropped. For UHF calculations, the appropriate orbitals are deleted for both spin cases. No dropped virtual MOs are currently allowed for gradient or property calculations. Ps",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html:32346,energy,energy,32346,psi4manual/1.2.1/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html,4,['energy'],['energy']
Energy Efficiency," OFF otherwise). Type: boolean; Default: true. CFOUR_DBOC (CFOUR); CFOUR — Specifies whether the diagonal Born-Oppenheimer correction (DBOC) to the energy is evaluated (ON =1) or not (OFF =0). DBOC calculations are currently only available for HF-SCF and CCSD using RHF or UHF reference functions. Type: boolean; Default: false. CFOUR_DCT (CFOUR); CFOUR — Specifies whether the Dipole Coupling Tensor (DCT) is calculated (ON =1) or not (OFF =0). Type: boolean; Default: false. CFOUR_DERIV_LEVEL (CFOUR); CFOUR — Specifies whether or not energy derivatives are to be calculated and if so whether first or second derivatives are computed. ZERO (= 0) derivatives are not calculated, FIRST (=1) first derivatives are calculated, SECOND (=2) second derivatives are calculated. Note that this keyword usually needs not be set in any calculation since it is automatically set if the appropriate other options in the CFOUR namelist are turned on. Psi4 Interface: Keyword set from type of computation command: ZERO if energy(), FIRST if gradient() or optimization(), etc. Type: string; Possible Values: ZERO, FIRST, SECOND; Default: ZERO. CFOUR_DIFF_TYPE (CFOUR); CFOUR — Specifies whether orbital-relaxed (RELAXED =0) or orbital-unrelaxed (UNRELAXED =1) derivatives are computed in the CC calculation. Type: string; Possible Values: RELAXED, UNRELAXED; Default: RELAXED. CFOUR_DROPMO (CFOUR); CFOUR — Specifies which molecular orbitals will be dropped from the post-SCF calculation. The orbitals are numbered in ascending order from the most stable (negative energy) to the most unstable (largest positive energy). Individual orbitals must be separated with a dash, while x>y means orbitals x through y inclusive. For example, the string 1>10-55-58>64, would result in orbitals 1,2,3,4,5,6,7,8,9,10,55,58,59,60,61,62,63 and 64 being dropped. For UHF calculations, the appropriate orbitals are deleted for both spin cases. No dropped virtual MOs are currently allowed for gradient or property calculations. Ty",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:32559,energy,energy,32559,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,4,['energy'],['energy']
Energy Efficiency," OPT_COORDINATES specifies delocalized coordinates, then the combinations; will be more complex.; Since the multiple-fragment coordinates are still under; development, they are not documented here. However, if desired, one can change the value; of FRAG_MODE, generate the internal coordinates, and see how multiple; fragment systems are defined.; Coordinates may be frozen by adding an asterisk after the letter of the coordinate. The; asterisk results in that internal coordinate being frozen at its initial value. The; “intco” file below for water specifies an optimization with both O-H bonds frozen.:; F 1 3; R* 1 2; R* 1 3; B 2 1 3. If one instead wishes to optimize toward (“fix”) a value that is not satisfied by the; initial structure, then the value is added to the end of the line. The following; corresponds to an optimization that will add additional forces to move the O-H bonds; to 1.70 au.; F 1 3; R 1 2 1.70; R 1 3 1.70; B 2 1 3. Convergence Criteria¶; Optking monitors five quantities to evaluate the progress of a geometry; optimization. These are (with their keywords) the change in energy; (MAX_ENERGY_G_CONVERGENCE), the maximum element of; the gradient (MAX_FORCE_G_CONVERGENCE), the root-mean-square; of the gradient (RMS_FORCE_G_CONVERGENCE), the maximum element; of displacement (MAX_DISP_G_CONVERGENCE), and the; root-mean-square of displacement (RMS_DISP_G_CONVERGENCE),; all in internal coordinates and atomic units. Usually, these options will not; be set directly. Primary control for geometry convergence lies with the keyword; G_CONVERGENCE which sets the aforementioned in accordance; with Table Geometry Convergence. Summary of sets of geometry optimization criteria available in PSI4¶. G_CONVERGENCE; Max Energy; Max Force; RMS Force; Max Disp; RMS Disp. NWCHEM_LOOSE 4. \(4.5 \times 10^{-3}\); \(3.0 \times 10^{-3}\); \(5.4 \times 10^{-3}\); \(3.6 \times 10^{-3}\). GAU_LOOSE 6. \(2.5 \times 10^{-3}\); \(1.7 \times 10^{-3}\); \(1.0 \times 10^{-2}\); \(6.7 \times ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/optking-1.html:10823,monitor,monitors,10823,psi4manual/1.4.0/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/optking-1.html,5,['monitor'],['monitors']
Energy Efficiency," OPT_COORDINATES specifies delocalized coordinates, then the combinations; will be more complex.; Since the multiple-fragment coordinates are still under; development, they are not documented here. However, if desired, one can change the value; of FRAG_MODE, generate the internal coordinates, and see how multiple; fragment systems are defined.; Coordinates may be frozen by adding an asterisk after the letter of the coordinate. The; asterisk results in that internal coordinate being frozen at its initial value. The; “intco” file below for water specifies an optimization with both O-H bonds frozen.:; F 1 3; R* 1 2; R* 1 3; B 2 1 3. If one instead wishes to optimize toward (“fix”) a value that is not satisfied by the; initial structure, then the value is added to the end of the line. The following; corresponds to an optimization that will add additional forces to move the O-H bonds; to 1.70 au.; F 1 3; R 1 2 1.70; R 1 3 1.70; B 2 1 3. Convergence Criteria¶; Optking monitors five quantities to evaluate the progress of a geometry; optimization. These are (with their keywords) the change in energy; (MAX_ENERGY_G_CONVERGENCE), the maximum element of; the gradient (MAX_FORCE_G_CONVERGENCE), the root-mean-square; of the gradient (RMS_FORCE_G_CONVERGENCE), the maximum element; of displacement (MAX_DISP_G_CONVERGENCE), and the; root-mean-square of displacement (RMS_DISP_G_CONVERGENCE),; all in internal coordinates and atomic units. Usually, these options will not; be set directly. Primary control for geometry convergence lies with the keyword; G_CONVERGENCE which sets the aforementioned in accordance; with Table Geometry Convergence. Summary of sets of geometry optimization criteria available in Psi4¶. G_CONVERGENCE; Max Energy; Max Force; RMS Force; Max Disp; RMS Disp. NWCHEM_LOOSE [4];  . GAU_LOOSE [6];  . TURBOMOLE [4]. GAU [3] [6];  . CFOUR [4];  ;  .  ;  . QCHEM [1] [5].  .  . MOLPRO [2] [5].  .  . GAU_TIGHT [3] [6];  . GAU_VERYTIGHT [6];  . Footnotes. [1]Default. [2]Bake",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/optking-1.html:10836,monitor,monitors,10836,psi4manual/1.0.0/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/optking-1.html,2,['monitor'],['monitors']
Energy Efficiency," Obtaining and Installing PSI4).; This very simple input is sufficient to run the requested information.; Notice that we didn’t tell the program some otherwise useful information; like the charge on the molecule (0, it’s neutral), the spin multiplicity; (1 for a closed-shell molecule with all electrons paired), or the reference; wavefunction to use (restricted Hartree–Fock, or RHF, is usually; appropriate for a closed-shell molecule). The program correctly guessed; all of these options for us. We can change the default behavior through; additional keywords.; Let’s consider what we would do for an open-shell molecule, where; not all electrons are paired. For example, let’s run a computation; on methylene (CH2), whose ground electronic state has two unpaired; electrons (triplet electronic state, or a spin multiplicity ).; In this case, the default spin multiplicity (1) is not correct, so we; need to tell the program the true value (3). Like many programs, PSI4; can get the charge and multiplicity as the first two integers in the; Z-matrix. Note the line with 0 3 at the beginning of the molecule; specification below. In this example we will also specify the bond length; and bond angle as variables ( and ), whose values are given; at the end of the Z-matrix specification.; #! Sample UHF/6-31G** CH2 computation. memory 250 mb. molecule ch2 {; 0 3; C ; H 1 R; H 1 R 2 A. R = 1.075; A = 133.93; }. set basis 6-31G**; set reference uhf; energy ('scf'). This sample input can be found in; tu2-ch2-energy and as; before it can be run through the command psi4 input.dat output.dat; (actually, because psi4 by default looks for an input file named; input.dat and writes by default to a file called output.dat, in this; case one could also just type psi4). If it works, it should print; the final energy as; @UHF Final Energy: -38.92534160932308. Notice we added a new keyword, set reference uhf, to the input. For; open-shell molecules, we have a choice of unrestricted orbitals; (unrestric",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/tutorial-1.html:2740,charge,charge,2740,psi4manual/4.0b2/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/tutorial-1.html,2,['charge'],['charge']
Energy Efficiency," Other gap; fitting techniques involving the electron affinity or band gap are sometimes; also used. IP-fitting is found to be particularly critical for the qualitative; determination of excited state ordering in many low band-gap systems.; For dispersion-bound complexes, a very simple additive empirical dispersion; potential, based on a damped Lennard-Jones potential can often produce; remarkably accurate results with KS-DFT. This approach was championed by Grimme,; whose “-D2” and more modern “-D3” approaches are a de facto industry standards. Minimal Input¶; Minimal input for a KS-DFT computation is a molecule block, basis set; option, and a call to energy('b3lyp') (or other valid functional name):; 1; 2; 3; 4; 5; 6; 7molecule {; He; }. set basis sto-3g. energy('b3lyp'). This will run a B3LYP Restricted Kohn–Sham (RKS) on neutral singlet Helium in; \(D_{2h}\) spatial symmetry with a minimal STO-3G basis, 1.0E-6 energy; and density convergence criteria, a DF ERI algorithm, symmetric; orthogonalization, DIIS, and a core Hamiltonian guess (because single atom). For more information on; any of these options, see the relevant section below, or in the preceding; Hartree–Fock section. Spin/Symmetry Treatment¶; PSI4 implements the most popular spin specializations of KS-DFT, including:. Restricted Kohn–Sham (RKS) [Default]; Appropriate only for closed-shell singlet systems, but twice as efficient; as the other flavors, as the alpha and beta densities are constrained to be; identical.; Unrestricted Kohn–Sham (UKS); Appropriate for most open-shell systems and fairly easy to converge.; The spatial parts of the alpha and beta orbitals are fully independent of each; other, which allows a considerable amount of flexibility in the wavefunction.; However, this flexibility comes at the cost of spin symmetry; the resultant; wavefunction may not be an eigenfunction of the \(\hat S^2\) operator.; However, spin contamination is usually less of a problem with UKS than with; UHF, as th",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/dft-1.html:12703,energy,energy,12703,psi4manual/1.2.1/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/dft-1.html,6,['energy'],['energy']
Energy Efficiency," Other supported parameters are:. `wfn_lo`: the lower method from which the delta correction is to be calculated. By default, it is set to `wfn` from the previous field in the `cbs_metadata` array.; `basis_lo`: basis set to be used for the delta correction. By default, it is the same as the `basis` specified above. Others. Parameters; molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> energy(cbs, corl_wfn='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> energy('cbs', scf_wfn='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme='scf_xtpl_helgaker_3'). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> energy('cbs', corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme='corl_xtpl_helgaker_2'). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme='corl_xtpl_helgaker_2', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme='corl_xtpl_helgaker_2'). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme='corl_xtpl_helgaker_2', delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] a Q5-zeta MP2 calcul",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.driver.cbs.html:12969,energy,energy,12969,psi4manual/1.6.x/api/psi4.driver.cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.driver.cbs.html,4,['energy'],['energy']
Energy Efficiency," Others. Parameters; molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> energy(cbs, corl_wfn='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> energy('cbs', scf_wfn='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme='scf_xtpl_helgaker_3'). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> energy('cbs', corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme='corl_xtpl_helgaker_2'). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme='corl_xtpl_helgaker_2', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme='corl_xtpl_helgaker_2'). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme='corl_xtpl_helgaker_2', delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] a Q5-zeta MP2 calculation, corrected by CCSD(T) at the TQ-zeta extrapolated level, and all-electron CCSD(T) correlation at T-zeta level; >>> energy(cbs, cbs_metadata=[{""wfn"": ""hf"", ""basis"": ""cc-pv5z""}, {""wfn"": ""mp2"", ""basis"": ""cc-pv[q5]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pv[tq]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pvtz"", ""options"": {""",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.driver.cbs.html:13201,energy,energy,13201,psi4manual/1.6.x/api/psi4.driver.cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.driver.cbs.html,6,['energy'],['energy']
Energy Efficiency," PARTICULAR PURPOSE. See the; # GNU General Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; #@END LICENSE; #. """"""Module with classes to integrate MM charges into; a QM calculation. """"""; import psi4; import re; import os; import math; import p4const; from molutil import *; from driver import *. [docs]class Diffuse(object):. def __init__(self, molecule, basisname, ribasisname):. self.molecule = molecule; self.basisname = basisname; self.ribasisname = ribasisname; self.basis = None; self.ribasis = None; self.da = None; self.Da = None; self.wfn = None. def __str__(self):. s = ' => Diffuse <=\n\n'; s = s + ' ' + str(self.molecule) + '\n'; s = s + ' ' + self.basisname + '\n'; s = s + ' ' + self.ribasisname + '\n'; s = s + '\n'. return s. [docs] def fitScf(self):; """"""Function to run scf and fit a system of diffuse charges to; resulting density. """"""; basisChanged = psi4.has_option_changed(""BASIS""); ribasisChanged = psi4.has_option_changed(""DF_BASIS_SCF""); scftypeChanged = psi4.has_option_changed(""SCF_TYPE""). basis = psi4.get_option(""BASIS""); ribasis = psi4.get_option(""DF_BASIS_SCF""); scftype = psi4.get_option(""SCF_TYPE""). psi4.print_out("" => Diffuse SCF (Determines Da) <=\n\n""); activate(self.molecule). psi4.set_global_option(""BASIS"", self.basisname); psi4.set_global_option(""DF_BASIS_SCF"", self.ribasisname); psi4.set_global_option(""SCF_TYPE"", ""DF""); energy('scf'); psi4.print_out(""\n""). self.fitGeneral(). psi4.clean(). psi4.set_global_option(""BASIS"", basis); psi4.set_global_option(""DF_BASIS_SCF"", ribasis); psi4.set_global_option(""SCF_TYPE"", scftype). if not basisChanged:; psi4.revoke_option_changed(""BASIS""); if not ribasisChanged:; psi4.revoke_option_changed(""DF_BASIS_SCF""); if not scftypeChanged:; psi4.revoke_option_changed(""SCF_TYPE""). [docs] def fitGeneral(self):; """"""Fun",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/qmmm.html:1662,charge,charges,1662,psi4manual/4.0b5/_modules/qmmm.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qmmm.html,1,['charge'],['charges']
Energy Efficiency," PBEsol SR-XC Functional (HJS Model). wpbesol0; PBEsol0 SR-XC Functional (HJS Model). wpbesol_x; PBEsol Short-Range GGA Exchange (HJS Model). wsvwn; LSDA SR-XC Functional. ws_x; Slater Short-Range LSDA Exchange. Warning; For the present, file intco.dat is lodged in the submission; directory and defines the internal coordinates for an optimization.; Thus, it is unsafe to run multiple optimizations from a single; directory. Also, intco.dat can linger, so, unless you’ve; deliberately constructed it, be sure to clear it out before starting a; new optimization. Warning; Optimizations where the molecule is specified in Z-matrix format ; with dummy atoms will result in the geometry being converted to a Cartesian representation. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finit",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/opt-1.html:7280,energy,energy,7280,psi4manual/4.0b3/opt-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/opt-1.html,2,['energy'],['energy']
Energy Efficiency," PSI Variables by Alpha — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Appendices ». PSI Variables by Alpha¶. Note; Lowercase letters in PSI variable names represent portions of; the variable name that vary by root number, calculation order, etc.; See text for fuller description. (T) CORRECTION ENERGY¶; The coupled-cluster perturbative triples correction [H]. AAA (T) CORRECTION ENERGY¶. AAB (T) CORRECTION ENERGY¶. ABB (T) CORRECTION ENERGY¶. BBB (T) CORRECTION ENERGY¶; Components of the coupled-cluster perturbative triples correction [H]. BRUECKNER CONVERGED¶; Value 1 (0) when the Brueckner orbitals have (have not) converged. CBS TOTAL ENERGY¶. CBS CORRELATION ENERGY¶. CBS REFERENCE ENERGY¶; The total electronic energy [H] and its breakdown into reference total; energy [H] and correlation correction components [H] for the compound; method requested through cbs(). CC ROOT n TOTAL ENERGY¶; The total electronic energy [H]; for the requested coupled cluster level of theory and root; n (numbering starts at GS = 0). CC TOTAL ENERGY¶. CC CORRELATION ENERGY¶. CC2 TOTAL ENERGY¶. CC2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the CC2 level of theory. CC3 TOTAL ENERGY¶. CC3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the CC3 level of theory. CCSD TOTAL ENERGY¶. CCSD CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the CCSD level of theory. CCSD(T) TOTAL ENERGY¶. CCSD(T) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the CCSD(T) level of theory. CI DIPOLE X¶. CI DIPOLE Y¶. CI DIPOLE Z¶; The three components of the dipole [Debye] for the requested; configuration interaction level of theory and root. CI QUADRUPOLE XX¶. CI QUADRUPOLE XY¶. CI QUADRUPOLE XZ¶. CI QUADRUPOLE YY¶. CI QUADRUPOLE YZ¶. CI QUADRUPOLE ZZ¶; The six components of the",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/glossary_psivariables-1.html:974,energy,energy,974,psi4manual/4.0b2/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/glossary_psivariables-1.html,2,['energy'],['energy']
Energy Efficiency," PSI4 Capabilities. Interface to programs through FCHK files — fchk()¶; Code author: Andrew C. Simmonett; Section author: Andrew C. Simmonett; Many post-processing tools can read information from Gaussian’s formatted; checkpoint (FCHK) files.; To allow interoperability with such tools, PSI4 includes a utility to; generate FCHK files. Wavefunction information, such as orbitals, densities,; orbital energies and basis set information is currently supported, but geometry; optimization and vibrational frequency information are not supported at this; time. To generate a FCHK file, simply store the wavefunction from the energy; calculation, and use it to create an FCHK writer:; 1; 2; 3energy, wfn = energy('scf', return_wfn=True); fchk_writer = psi4.core.FCHKWriter(wfn); fchk_writer.write('output.fchk'). The file will be written to the name passed to the FCHK writer’s write(); method. Note that for MP2 and CCSD methods, the energy can be computed without; the expensive steps required to compute the density, so energy calls for these; methods will return a wavefunction that has the Hartree–Fock density. If a; density is required for these methods, the user should instead request a; gradient computation, to ensure that the density is updated appropriately:; 1; 2; 3grad, wfn = gradient('mp2', return_wfn=True); fchk_writer = psi4.core.FCHKWriter(wfn); fchk_writer.write('output.fchk'). psi4.fchk(wfn, filename)[source]¶; Function to write wavefunction information in wfn to filename in; Gaussian FCHK format. New in version 0.6. Returns:None. Parameters:; filename (string) – destination file name for FCHK file; wfn (Wavefunction) – set of molecule, basis, orbitals from which to generate fchk file. Examples:. 1; 2; 3>>> # [1] FCHK file for DFT calculation; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> fchk(wfn, 'mycalc.fchk'). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. © Copyri",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/fchk-1.html:1075,energy,energy,1075,psi4manual/1.2.1/fchk-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/fchk-1.html,4,['energy'],['energy']
Energy Efficiency," PSI4 Capabilities. Interface to programs through FCHK files — fchk()¶; Code author: Andrew C. Simmonett; Section author: Andrew C. Simmonett; Many post-processing tools can read information from Gaussian’s formatted; checkpoint (FCHK) files.; To allow interoperability with such tools, PSI4 includes a utility to; generate FCHK files. Wavefunction information, such as orbitals, densities,; orbital energies and basis set information is currently supported, but geometry; optimization and vibrational frequency information are not supported at this; time. To generate a FCHK file, simply store the wavefunction from the energy; calculation, and use it to create an FCHK writer:; 1; 2; 3energy, wfn = energy('scf', return_wfn=True); fchk_writer = psi4.core.FCHKWriter(wfn); fchk_writer.write('output.fchk'). The file will be written to the name passed to the FCHK writer’s write(); method. Note that for MP2 and CCSD methods, the energy can be computed without; the expensive steps required to compute the density, so energy calls for these; methods will return a wavefunction that has the Hartree–Fock density. If a; density is required for these methods, the user should instead request a; gradient computation, to ensure that the density is updated appropriately:; 1; 2; 3grad, wfn = gradient('mp2', return_wfn=True); fchk_writer = psi4.core.FCHKWriter(wfn); fchk_writer.write('output.fchk'). psi4.fchk(wfn, filename)[source]¶; Function to write wavefunction information in wfn to filename in; Gaussian FCHK format. New in version 0.6. Returns:None. Parameters:; filename (string) – destination file name for FCHK file; wfn (Wavefunction) – set of molecule, basis, orbitals from which to generate fchk file. Notes. A description of the FCHK format is http://wild.life.nctu.edu.tw/~jsyu/compchem/g09/g09ur/f_formchk.htm; The allowed headers for methods are general and limited, i.e., “Total SCF|MP2|CI|CC Density”,; so “CC” is always used for the post-HF case. Examples:. >>> # [1] FCHK file for DF",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/fchk-1.html:1075,energy,energy,1075,psi4manual/1.3.2/fchk-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/fchk-1.html,4,['energy'],['energy']
Energy Efficiency," PSI4. Customization: Adding Simple Extensions; Defining a Method Alias. Defining a Method Alias¶. Note; No recompile of the PSI4 program is necessary for changes made to; files in $PSIDATADIR aka psi4/psi4/share/psi4, including those described below. Caution; As of 1.0, the below, while essentially still correct, is so aged; as to be difficult to follow. Since quantum chemical methods in PSI4 are accessed through Python functions, and; most important quantities are available as PSI variables, it is straightforward; to create aliases to commonly run calculations or to define hybrid methods. The; psi4/psi4/driver/aliases.py file is intended for editing by the user for; this purpose.; As an example, the MP2.5 method; (which admittedly is already built in to PSI4); is the average of MP2 and MP3. The latter is; available through the arbitrary order MPn code and returns all lower energies; along with it in PSI variables. The following is basic code that will compute; and return the MP2.5 energy.; def run_mp2_5(name, **kwargs):. energy('mp3', **kwargs); e_scf = psi4.get_variable('SCF TOTAL ENERGY'); ce_mp2 = psi4.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = psi4.get_variable('MP3 CORRELATION ENERGY'). ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25. print """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); print """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25). return e_mp25. Compare the above to the method that resides in psi4/psi4/driver/aliases.py.; The rationale for the changes is indicated in the comments below.; def run_mp2_5(name, **kwargs):; lowername = name.lower() # handy variable with name keyword in lowercase; kwargs = kwargs_lower(kwargs) # removes case sensitivity in keyword names. # Run detci calculation and collect conventional quantities; energy('mp3', **kwargs); e_scf = psi4.get_variable('SCF TOTAL ENERGY'); ce_mp2 = psi4.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = psi4.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 #",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/quickaddalias-1.html:1087,energy,energy,1087,psi4manual/1.4.0/quickaddalias-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/quickaddalias-1.html,9,['energy'],['energy']
Energy Efficiency," PSI4; makes these computations easier than ever.; For a SAPT computation, the input needs to provide information on two; distinct molecules. This is very easy, we just give a Z-matrix or set of; Cartesian coordinates for each molecule, and separate the two with two; dashes, like this:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20# Example SAPT computation for ethene*ethine (*i.e.*, ethylene*acetylene),; # test case 16 from the S22 database. molecule dimer {; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; units angstrom. }. Here’s the second half of the input, where we specify the computation; options:; 1; 2; 3; 4; 5; 6; 7set {; basis jun-cc-pVDZ; scf_type DF; freeze_core True; }. energy('sapt0'). Before, we have been setting keywords individually with commands like; set basis cc-pVDZ. Because we have a few more options now, it’s; convenient to place them together into the set; block, bounded by {...}. This; will set all of these options as “global” options (meaning that they are; visible to all parts of the program). Most common PSI4 options can be; set in a globals section like this. If an option needs to be visible; only to one part of the program (e.g., we only want to increase the; energy convergence in the SCF code, but not the rest of the; code), it can be placed in a section of input visible to that part of the; program (e.g., set scf e_convergence 1.0E-8).; Back to our SAPT example, we have found that for basic-level SAPT; computations (i.e., SAPT0), a good error cancellation is found; [Hohenstein:2012:WIREs] with the jun-cc-pVDZ basis (this is the; usual aug-cc-pVDZ basis, but without diffuse functions on hydrogen and; without diffuse \(d\) functions on heavy ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/tutorial-1.html:11445,energy,energy,11445,psi4manual/1.1.0/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/tutorial-1.html,6,['energy'],['energy']
Energy Efficiency," Parameters:; scf_scheme (function) – highest_1 || scf_xtpl_helgaker_3 || etc.; Indicates the basis set extrapolation scheme to be applied to the reference energy. corl_scheme (function) – highest_1 || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the correlation energy. delta_scheme (function) – highest_1 || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the delta correction; to the correlation energy. delta2_scheme (function) – highest_1 || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the second delta correction; to the correlation energy. delta3_scheme (function) – highest_1 || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the third delta correction; to the correlation energy. delta4_scheme (function) – highest_1 || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the fourth delta correction; to the correlation energy. delta5_scheme (function) – highest_1 || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the fifth delta correction; to the correlation energy. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> cbs('scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> cbs('mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> cbs('scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> cbs('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zet",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/cbs-1.html:8099,energy,energy,8099,psi4manual/4.0b5/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/cbs-1.html,2,['energy'],['energy']
Energy Efficiency," Phys. Chem. Lett., 1, 550-555 (2010). dft-grad-meta; meta-GGA gradients of water and ssh molecules reference gradients updated due to new BraggSlater radii. dfomp3-1; DF-OMP3 cc-pVDZ energy for the H2O molecule. omp2-3; OMP2 cc-pVDZ energy for the NO radical. isapt-siao1; This test case shows an example of running the I-SAPT0/jun-cc-pVDZ computation for 2,4-pentanediol (targeting the intramolecular hydrogen bond between the two hydroxyl groups) The SIAO1 link partitioning algorithm is used. isapt2; This is a shorter version if isapt1 - does not do cube plots. See isapt1 for full details. sapt5; SAPT0 aug-cc-pVTZ computation of the charge transfer energy of the water dimer. omp2p5-grad2; OMP2.5 cc-pVDZ gradient for the NO radical. cc9; UHF-CCSD(T) cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Z-matrix input. mcscf1; ROHF 6-31G** energy of the \(^{3}B_1\) state of CH2, with Z-matrix input. The occupations are specified explicitly. dfcasscf-fzc-sp; CASSCF/6-31G** energy point. mp2p5-grad2; MP2.5 cc-pVDZ gradient for the NO radical. pywrap-basis; SAPT calculation on bimolecular complex where monomers are unspecified so driver auto-fragments it. Basis set and auxiliary basis sets are assigned by atom type. cepa1; cc-pvdz H2O Test CEPA(1) Energy. dft-psivar; HF and DFT variants single-points on zmat methane, mostly to test that PSI variables are set and computed correctly. Now also testing that CSX harvesting PSI variables correctly update ref_dft_2e/xc due to new BraggSlater radii. ghosts; Density fitted MP2 cc-PVDZ/cc-pVDZ-RI computation of formic acid dimer binding energy using explicit specification of ghost atoms. This is equivalent to the dfmp2_1 sample but uses both (equivalent) specifications of ghost atoms in a manual counterpoise correction. nbody-hessian; Computation of VMFC-corrected HF dimer Hessian. castup3; SCF with various combinations of pk/density-fitting, castup/no-castup, and spherical/cartesian settings. Demonstrates",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html:47459,energy,energy,47459,psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency," Phys. Lett. 286 (1998) 243-252,; DOI: 10.1016/S0009-2614(99)00179-7. \[E_{corl}^X = E_{corl}^{\infty} + \beta X^{-alpha}\]. Aliases¶; When a particular composite method or its functional form is going to be; reused often, it is convenient to define an alias to it. A convenient; place for such Python code to reside is in psi4/psi4/driver/aliases.py; (source location) or psi4/lib/psi4/driver/aliases.py (installed; location). No recompilation is necessary after defining an alias. Some; existing examples are below. psi4.driver.aliases.sherrill_gold_standard(func, label, **kwargs)[source]¶; Function to call the quantum chemical method known as ‘Gold Standard’; in the Sherrill group. Uses complete_basis_set() to evaluate; the following expression. Two-point extrapolation of the correlation energy; performed according to corl_xtpl_helgaker_2(). \[E_{total}^{\text{Au\_std}} = E_{total,\; \text{SCF}}^{\text{aug-cc-pVQZ}} \; + E_{corl,\; \text{MP2}}^{\text{aug-cc-pV[TQ]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD(T)}}\big\vert_{\text{aug-cc-pVTZ}}\]; 1; 2>>> # [1] single-point energy by this composite method; >>> energy('sherrill_gold_standard'). 1; 2>>> # [2] finite-difference geometry optimization; >>> optimize('sherrill_gold_standard'). 1; 2>>> # [3] finite-difference geometry optimization, overwriting some pre-defined sherrill_gold_standard options; >>> optimize('sherrill_gold_standard', corl_basis='cc-pV[DT]Z', delta_basis='3-21g'). psi4.driver.aliases.allen_focal_point(func, label, **kwargs)[source]¶; Function to call Wes Allen-style Focal; Point Analysis. JCP 127 014306. Uses; complete_basis_set() to evaluate the following; expression. SCF employs a three-point extrapolation according; to scf_xtpl_helgaker_3(). MP2, CCSD, and; CCSD(T) employ two-point extrapolation performed according to; corl_xtpl_helgaker_2(). CCSDT and CCSDT(Q); are plain deltas. This wrapper requires Kallay’s MRCC code. \[E_{total}^{\text{FPA}} = E_{total,\; \text{SCF}}^{\text{cc-pV[Q56]Z}} \; + E_{cor",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/cbs-1.html:19108,energy,energy,19108,psi4manual/1.2.1/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/cbs-1.html,4,['energy'],['energy']
Energy Efficiency," Point. scf-response1; Compute the dipole, quadrupole, and traceless quadrupoles for water. opt8; Various constrained energy minimizations of HOOH with cc-pvdz RHF. Cartesian-coordinate constrained optimizations of HOOH in Cartesians. extern1; External potential calculation involving a TIP3P water and a QM water. Finite different test of the gradient is performed to validate forces. nbody-vmfc-gradient; Computation of VMFC-corrected water trimer gradient (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). dft-custom-mgga; updated dldf reference to new BraggSlater radii Dispersionless density functional (dlDF+D) internal match to Psi4 Extensive testing has been done to match supplemental info of Szalewicz et. al., Phys. Rev. Lett., 103, 263201 (2009) and Szalewicz et. al., J. Phys. Chem. Lett., 1, 550-555 (2010). psimrcc-fd-freq2; Mk-MRCCSD frequencies. \(^1A_1\) O$_3` state described using the Ms = 0 component of the singlet. Uses TCSCF orbitals. dct9; UHF-ODC-12 and RHF-ODC-12 single-point energy for H2O. This performs a simultaneous update of orbitals and cumulants, using DIIS extrapolation. Four-virtual integrals are handled in the AO basis, where integral transformation is avoided. In the next RHF-ODC-12 computation, AO_BASIS=NONE is used, where four-virtual integrals are transformed into MO basis. freq-masses; check nonphysical masses possible. castup3; SCF with various combinations of pk/density-fitting, castup/no-castup, and spherical/cartesian settings. Demonstrates that puream setting is getting set by orbital basis for all df/castup parts of calc. Demonstrates that answer doesn’t depend on presence/absence of castup. Demonstrates (by comparison to castup2) that output file doesn’t depend on options (scf_type) being set global or local. This input uses local. dfomp2p5-grad2; DF-OMP2.5 cc-pVDZ gradients for the H2O+ cation. decontract; RHF/cc-pvdz-decontract HCl single-point energy Testing the in line -decontract option for basis sets. mp3-grad1; MP",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html:11836,energy,energy,11836,psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency," Psi4 [1.0.0 6a9a71b] Docs. Navigation. index. modules    . toc    . next    . previous    ; Psi4 [1.0.0 6a9a71b] » ; Appendices »; Keywords by Module ». CFOUR¶; Interface to CFOUR program written by Stanton and Gauss. Keyword descriptions taken from the CFOUR Website and extended by interface comments. Psi4 Control of CFOUR¶. TRANSLATE_PSI4¶. Do translate set Psi4 options to their cfour counterparts. Type: boolean; Default: true. CFOUR Internal¶. CFOUR_ABCDTYPE¶. Specifies the way the molecular orbital integrals are handled in post-MP2 calculations. STANDARD (= 0) uses directly the corresponding MO integrals and thus results in an algorithm which in particular for large-scale calculations results in excessive use of disk space (storage of all integrals. AOBASIS (=2) uses an AO-based algorithm to evaluate all terms involving the integrals and significantly reduces the amount of disk storage. The use of ABCDTYPE=AOBASIS is strongly recommended for all CC calculations up to CCSD(T) and has been implemented for energy, gradient, second-derivative, and excitation energy calculations. Type: string; Possible Values: STANDARD, AOBASIS; Default: STANDARD. CFOUR_ACTIVE_ORBI¶. Specifies the active orbitals used in a TCSCF calculation and has to be used in combination with the keyword CFOUR_CORE_ORBITALS The active orbitals are specified by either NIRREP or 2*NIRREP integers specifying the number of active orbitals of each symmetry type, where NIRREP is the number of irreducible representations in the computational point group. If there are no orbitals of a particular symmetry type a zero must be entered. For more information and an example see CFOUR_OCCUPATION . Type: array; Default: No Default. CFOUR_ANHARMONIC¶. Specifies treatment of anharmonc effects by calculating cubic and/or quartic force fields. VIBROT (=3) requests calculation of only those cubic constants of the form , where n is a totally symmetric coordinate. These are sufficient to determine the vibration-rotatio",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__cfour-1.html:1034,energy,energy,1034,psi4manual/1.0.0/autodir_options_c/module__cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__cfour-1.html,4,['energy'],['energy']
Energy Efficiency," Psi4 contains code to interface to the PCMSolver library developed; by R. Di Remigio and L. Frediani.; The version 1.1.0 of the PCMSolver library is distributed with Psi4; and requires no additional licence, downloads, or configuration.; The library is documented at http://pcmsolver.readthedocs.org/, while the source code is hosted at; https://github.com/PCMSolver/pcmsolver/; The library allows for calculations in solution with the polarizable continuum model (PCM),; a continuum solvation model.; Compilation of the library and its interface to Psi4 can be disabled by passing the; --pcmsolver=off to the setup script or -DENABLE_PCMSOLVER=OFF directly to CMake. Using the polarizable continuum model¶; The inclusion of a PCM description of the solvent into your calculation; is achieved by setting pcm true in your input file.; Psi4 understands the additional option pcm_scf_type with possible values total; (the default) or separate.; The latter forces the separate handling of nuclear and electronic electrostatic potentials and; polarization charges. It is mainly useful for debugging. Note; At present PCM can only be used for energy calculations with SCF wavefunctions.; Moreover, the PCMSolver library cannot exploit molecular point group symmetry. The PCM model and molecular cavity are specified in a pcm section that has; to be explicitly typed in by the user. This additional section follows a syntax; that is slightly different from that of Psi4 and is fully documented; here; A typical input for a Hartree-Fock calculation with PCM would look like the following:; molecule NH3 {; symmetry c1; N -0.0000000001 -0.1040380466 0.0000000000; H -0.9015844116 0.4818470201 -1.5615900098; H -0.9015844116 0.4818470201 1.5615900098; H 1.8031688251 0.4818470204 0.0000000000; units bohr; no_reorient; no_com; }. set {; basis STO-3G; scf_type pk; pcm true; pcm_scf_type total; }. pcm = {; Units = Angstrom; Medium {; SolverType = IEFPCM; Solvent = Water; }. Cavity {; RadiiSet = UFF; Type = Ge",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/pcmsolver-1.html:1418,charge,charges,1418,psi4manual/1.0.0/pcmsolver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/pcmsolver-1.html,2,['charge'],['charges']
Energy Efficiency," PsiMod.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; PsiMod.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; PsiMod.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; PsiMod.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); PsiMod.set_variable('CURRENT ENERGY', e_mp25) # geometry optimizer tracks this variable, permits; # MP2.5 finite difference optimizations; # build string of title banner and print results; banners = ''; banners += """"""PsiMod.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""PsiMod.print_out('\\n')\n\n""""""; exec banners. tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); PsiMod.print_out(tables) # prints nice header and table of all involved quantities to output file. return e_mp25. One final step is necessary. At the end of the aliases.py file, add; the following line.; procedures['energy']['mp2.5'] = run_mp2_5. This permits the newly defined MP2.5 method to be called in the input file; with the following command.; energy('mp2.5'). Previous topic; User-Defined Basis Sets; Next topic; Creating a Database; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Customization: Adding Simple Extensions ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/quickaddalias-1.html:2898,energy,energy,2898,psi4manual/4.0b2/quickaddalias-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/quickaddalias-1.html,12,['energy'],['energy']
Energy Efficiency," PsiMod.has_option_changed('SCF', 'D_CONVERGENCE'):; if procedures['energy'][lowername] == run_scf or procedures['energy'][lowername] == run_dft:; PsiMod.set_local_option('SCF', 'D_CONVERGENCE', 8); else:; PsiMod.set_local_option('SCF', 'D_CONVERGENCE', 10). # Set post-scf convergence criteria (global will cover all correlated modules); if not PsiMod.has_global_option_changed('E_CONVERGENCE'):; if not procedures['energy'][lowername] == run_scf and not procedures['energy'][lowername] == run_dft:; PsiMod.set_global_option('E_CONVERGENCE', 8). # Select certain irreps; if 'irrep' in kwargs:; irrep = parse_cotton_irreps(kwargs['irrep']) - 1 # externally, A1 irrep is 1, internally 0; else:; irrep = -1 # -1 implies do all irreps. # Does an analytic procedure exist for the requested method?; if (dertype == 2):; # We have the desired method. Do it.; procedures['hessian'][lowername](lowername, **kwargs); optstash.restore(). # call thermo module; PsiMod.thermo(). return PsiMod.wavefunction().energy(). elif (dertype == 1):; # Ok, we're doing frequencies by gradients; info = 'Performing finite difference by gradient calculations'; print(info). func = procedures['gradient'][lowername]. # Obtain list of displacements; displacements = PsiMod.fd_geoms_freq_1(irrep). molecule.reinterpret_coordentry(False); molecule.fix_orientation(True); # Make a note of the undisplaced molecule's symmetry; PsiMod.set_parent_symmetry(molecule.schoenflies_symbol()). ndisp = len(displacements); print(' %d displacements needed.' % ndisp). #print displacements to output.dat; #for n, displacement in enumerate(displacements):; # displacement.print_out();. gradients = []; for n, displacement in enumerate(displacements):; # Print information to output.dat; PsiMod.print_out('\n'); banner('Loading displacement %d of %d' % (n + 1, ndisp)). # Print information to the screen; print(' %d' % (n + 1), end=""""); if (n + 1) == ndisp:; print('\n', end=""""); sys.stdout.flush(). # Load in displacement into the active molecu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/driver.html:62983,energy,energy,62983,psi4manual/4.0b4/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/driver.html,1,['energy'],['energy']
Energy Efficiency," PubChemA line reading pubchem:mol fetches the geometry for molecule; mol from the PubChem database, where mol is either; the IUPAC molecule name or the CID number. See PubChem Database for; details. SymmetryThe symmetry can be specified by a line reading symmetry; symbol, where symbol is the Schönflies symbol; of the (Abelian) point group to use for the computation, one of one of; c1, c2, ci, cs, d2, c2h, c2v, or d2h.; This need not be specified, as the molecular symmetry is automatically; detected by PSI4. See Symmetry for details. FragmentsA line reading -- is interpreted as the separator between two non-covalently; bound molecular fragments. See Non-Covalently Bonded Molecule Fragments for details. Multiple Molecules¶; To facilitate more elaborate computations, it is possible to provide a name for; each molecule and tell PSI4 which one should be used in a given; calculation. For example, consider the following input file:; molecule h2 {; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; energy('scf') # on H2. clean(). molecule h {; H; }. set basis cc-pvdz; set reference uhf; energy('scf') # on H. Here, two separate jobs are performed on two different molecules; the first is; performed on H2, while the second is for H atom. The last molecule to be; specified is the “active” molecule by default. To explicitly activate a named; molecule, the activate command is provided. With it, the above input file can be; equivalently written as follows. Alternatively, the molecule can be specified; directly to the computing function. Below, the third calculation is the same as; the first.; molecule h2 {; H; H 1 0.9; }. molecule h {; H; }. activate(h2); set basis cc-pvdz; set reference rhf; energy('scf') # on H2. clean(). activate(h); set basis cc-pvdz; set reference uhf; energy('scf') # on H. # --------------------------------------; # equivalent to previous input ends here. clean(). set reference rhf; energy('scf', molecule=h2) # on H2. Job Control Keywords provides more det",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/psithonmol-1.html:4779,energy,energy,4779,psi4manual/1.4.0/psithonmol-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/psithonmol-1.html,9,['energy'],['energy']
Energy Efficiency," Python. freq¶. psi4.driver.freq(name, **kwargs)¶; Function to compute harmonic vibrational frequencies. Aliases:frequencies(), freq(). Returns:float – Total electronic energy in Hartrees. Returns:(float, Wavefunction) – energy and wavefunction when return_wfn specified. Parameters:; name (string) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype) – \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- they’re not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or string) – \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. name; calls method. scf; Hartree–Fock (HF) [manual]. Examples:. >>> # [1] Frequency cal",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.driver.freq-1.html:1090,energy,energy,1090,psi4manual/1.3.2/api/psi4.driver.freq-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.driver.freq-1.html,2,['energy'],['energy']
Energy Efficiency," Python. freq¶. psi4.driver.freq(name, **kwargs)¶; Function to compute harmonic vibrational frequencies. Aliases:frequencies(), freq(). Returns:float – Total electronic energy in Hartrees. Returns:(float, Wavefunction) – energy and wavefunction when return_wfn specified. Parameters:; name (string) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. mode (string) – \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies or gradients frequency, indicates; whether the calculations required to complete the frequency are to be run; in one file ('continuous') or are to be farmed out in an; embarrassingly parallel fashion ('sow'/'reap')/ For the latter,; run an initial job with 'sow' and follow instructions in its output file.; For maximum flexibility, return_wfn is always on in 'reap' mode. dertype (dertype) – \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- they’re not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or string) – \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/api/psi4.driver.freq-1.html:1090,energy,energy,1090,psi4manual/1.2.1/api/psi4.driver.freq-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/api/psi4.driver.freq-1.html,2,['energy'],['energy']
Energy Efficiency," QCISD CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the quadratic configuration interaction singles and doubles level; of theory. QCISD(T) TOTAL ENERGY¶. QCISD(T) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the quadratic configuration interaction singles and doubles with; perturbative triples correction level of theory. SAPT DISP ENERGY¶. SAPT ELST ENERGY¶. SAPT EXCH ENERGY¶. SAPT IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [H] for the the; requested SAPT level of theory. The sum of these four components yields; SAPT TOTAL ENERGY. SAPT TOTAL ENERGY¶; The total electronic interaction energy [H] for the requested SAPT; level of theory. SAPT0 TOTAL ENERGY¶. SSAPT0 TOTAL ENERGY¶. SAPT2 TOTAL ENERGY¶. SAPT2+ TOTAL ENERGY¶. SAPT2+(3) TOTAL ENERGY¶. SAPT2+3 TOTAL ENERGY¶; The total electronic interaction energy [H] for the labeled SAPT level; of theory. SAPT2+(CCD) TOTAL ENERGY¶. SAPT2+(3)(CCD) TOTAL ENERGY¶. SAPT2+3(CCD) TOTAL ENERGY¶; The total electronic interaction energy [H] for the labeled SAPT level; of theory that incorporates coupled-cluster dispersion. SAPT2+DMP2 TOTAL ENERGY¶. SAPT2+(3)DMP2 TOTAL ENERGY¶. SAPT2+3DMP2 TOTAL ENERGY¶. SAPT2+(CCD)DMP2 TOTAL ENERGY¶. SAPT2+(3)(CCD)DMP2 TOTAL ENERGY¶. SAPT2+3(CCD)DMP2 TOTAL ENERGY¶; The total electronic interaction energy [H] for the labeled SAPT level; of theory that incorporates MP2 induction correction. SCF DIPOLE X¶. SCF DIPOLE Y¶. SCF DIPOLE Z¶; The three components of the SCF dipole [Debye]. SCF QUADRUPOLE XX¶. SCF QUADRUPOLE XY¶. SCF QUADRUPOLE XZ¶. SCF QUADRUPOLE YY¶. SCF QUADRUPOLE YZ¶. SCF QUADRUPOLE ZZ¶; The six components of the SCF quadrupole [Debye Ang]. SCF TOTAL ENERGY¶; The total electronic energy [H] of the SCF stage of the calculation.; The CORRELATION ENERGY variables from subsequent stages of a; calculatio",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/glossary_psivariables-1.html:16274,energy,energy,16274,psi4manual/1.1.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/glossary_psivariables-1.html,8,['energy'],['energy']
Energy Efficiency," QC_TYPE (DCFT); DCFT — Controls the type of the quadratically-convergent algorithm (effective for ALGORITHM = QC). If set to TWOSTEP the Newton-Raphson equations are only solved for the orbital updates, the cumulant is updated using the standard Jacobi algorithm. If set to SIMULTANEOUS both cumulant and orbitals are updated in a single Newton-Raphson step. Type: string; Possible Values: TWOSTEP, SIMULTANEOUS; Default: SIMULTANEOUS. QCHF (DFOCC); DFOCC — Do perform a QCHF computation?. Type: boolean; Default: false. QCHF (SCF); SCF — Do perform a QCHF computation?. Type: boolean; Default: false. QMEFP (EFP); EFP (Expert) — Do turn on QM/EFP terms?. Type: boolean; Default: false. QMEFP_ELST (EFP); EFP — Do include electrostatics energy term in QM/EFP computation?. Type: boolean; Default: true. QMEFP_POL (EFP); EFP — Do include polarization energy term in EFP computation?. Type: boolean; Default: true. R4S (DETCI); DETCI (Expert) — Do restrict strings with in RAS IV? Useful to reduce the number of strings required if MIXED4=true, as in a split-virutal CISD[TQ] computation. If more than one electron is in RAS IV, then the holes in RAS I cannot exceed the number of particles in RAS III + RAS IV (i.e., EX_LEVEL), or else the string is discarded. Type: boolean; Default: false. R_CONVERGENCE (CCENERGY); CCENERGY — Convergence criterion for wavefunction (change) in CC amplitude equations. Type: conv double; Default: 1e-7. R_CONVERGENCE (CCEOM); CCEOM — Convergence criterion for norm of the residual vector in the Davidson algorithm for CC-EOM. Type: conv double; Default: 1e-6. R_CONVERGENCE (CCLAMBDA); CCLAMBDA — Convergence criterion for wavefunction (change) in CC lambda-amplitude equations. Type: conv double; Default: 1e-7. R_CONVERGENCE (CCRESPONSE); CCRESPONSE — Convergence criterion for wavefunction (change) in perturbed CC equations. Type: conv double; Default: 1e-7. R_CONVERGENCE (DCFT); DCFT — Convergence criterion for the RMS of the residual vector in density cumul",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:188598,reduce,reduce,188598,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,2,['reduce'],['reduce']
Energy Efficiency," RASSCF; RHF/ROHF; CONV/DF; E. SAPT0, SF-SAPT0; RHF/UHF/ROHF; CONV/DF; E. SAPT(DFT); RKS; DF; E. SAPT2, 2+, 2+(3), 2+3; RHF; DF; E. F/I-SAPT0; RHF; DF; E. TDDFT; RKS/UKS; CONV/DF; E. EP2; RHF; DF; E. EOM-CC2; RHF; CONV; E. EOM-CCSD; RHF/UHF/ROHF; CONV; E/G. EOM-CC3; RHF/UHF/ROHF; CONV; E. ❖ with LibEFP. EFP/EFP; RHF. E/G. QM/EFP; RHF. E. ❖ with DFTD3, DFTD4, and gCP. HF-3c, PBEh-3c; R/U/ROHF, R/UKS. E/G. DFT-D3, DFT-D4; RKS/UKS. E/G. ❖ with ADCC. ADC(1), CVS-ADC(1); RHF/UHF; CONV; E. ADC(2), CVS-ADC(2); RHF/UHF; CONV; E. ADC(2)-x, CVS-ADC(2)-x; RHF/UHF; CONV; E. ADC(3), CVS-ADC(3); RHF/UHF; CONV; E. ❖ with CheMPS2. DMRG-CI; RHF; CONV; E. DMRG-SCF; RHF; CONV; E. DMRG-CASPT2; RHF; CONV; E. [1]; Many methods have a more detailed breakdown of capabilities here. [2]; (1,2); Not all combinations of reference and algorithm type may be available for any variant and derivative. See detailed capabilities tables. [3]; Shown are analytic implementations for energy (E), gradient, (G), and Hessian (H); finite difference derivatives are invoked automatically if analytic not available. [4]; Frozen natural orbital variant available. In particular, RHF available as CONV. [5]; (1,2); Frozen natural orbital variant available. In particular, RHF available as CONV/DF. Summary capabilities of PSI4. “✓” runs analytically. “∷” runs derivative with internal finite difference. Double underline “✓̳” or “∷̳” is default algorithm type when type selector (e.g., CC_TYPE) unspecified.¶. ◻; name ↓ →; ◻; ◻. REFERENCE →; ◻; type[6] ↓ →; FREEZE_CORE[7]→. Restricted (RHF); Unrestricted (UHF); Restricted Open (ROHF). energy(); gradient()[8]; energy(); gradient()[8]; energy(); gradient()[8]. CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD. A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F. hf. SCF_TYPE; ✓. ✓̳. ✓. ✓. ✓̳. ∷. ✓. ✓̳. ✓. ✓. ✓̳. ∷. ✓. ✓̳. ✓. ✓. ✓̳. ∷. mp2. MP2_TYPE; ✓; ✓; ✓̳; ✓̳; ✓; ✓; ✓; ∷; ✓̳; ✓̳; ∷; ∷; ✓; ✓; ✓̳; ✓",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/introduction.html:26413,energy,energy,26413,psi4manual/1.7.x/introduction.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/introduction.html,2,['energy'],['energy']
Energy Efficiency," RHF Density Matrix based-Integral Screening Test for water. omp2-5; SOS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. fd-freq-energy-large; SCF DZ finite difference frequencies by energies for C4NH4. scf5; Test of all different algorithms and reference types for SCF, on singlet and triplet O2, using the cc-pVTZ basis set. dfmp2-2; Density fitted MP2 energy of H2, using density fitted reference and automatic looping over cc-pVDZ and cc-pVTZ basis sets. Results are tabulated using the built in table functions by using the default options and by specifiying the format. cbs-xtpl-freq; Various gradients for a strained helium dimer and water molecule. mp3-grad2; MP3 cc-pVDZ gradient for the NO radical. dlpnomp2-1; comparison of DF-MP2 and DLPNO-MP2. scf-level-shift-rohf; SCF level shift on an ROHF computation. opt-irc-2; Compute the IRC for HCN <-> NCH interconversion at the RHF/DZP level of theory. sapt3; SAPT2+3(CCD) aug-cc-pVDZ+midbond computation of the water dimer interaction energy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. dft-grad-lr2; Tests CAM gradients with and without XC pieces to narrow grid error. cc13; UHF-CCSD/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. dct11; Restricted DF-DCT ODC-12 energies with linearly dependent basis functions. cdoremp-energy1; Cholesky decomposed OO-REMP/cc-pVDZ energy for the H2O molecule. dfcasscf-sp; CASSCF/6-31G** energy point. dforemp-grad1; density fitted OO-REMP/cc-pVDZ engrad single points for the H2O molecule. cc56; EOM-CCSD/6-31g excited state transition data for water cation. fsapt-ext-abc2; FSAPT with external charge on dimer. stability1; UHF->UHF stability analysis test for BH with cc-pVDZ Test direct SCF with and without symmetry, test PK without symmetry. tu6-cp-ne2; Example potential energy surface scan and CP-correction for Ne2. ci-multi; BH single points, checking that program can run multiple instances of DETCI in a single input, without an inter",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html:17157,energy,energy,17157,psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency," RHF; CONV; —; —; threaded 3. E. CI(n); RHF/ROHF; CONV; —; —; partially threaded. FCI; RHF/ROHF; CONV; —; —; partially threaded. Mk-MRPT2; RHF/ROHF/TCSCF; CONV; —; —; threaded 3. Mk-MRCCSD; RHF/ROHF/TCSCF; CONV; —; —; threaded 3. Mk-MRCCSD(T); RHF/ROHF/TCSCF; CONV; —; —; threaded 3. RAS-CI; RHF/ROHF; CONV; —; —; partially threaded. CASSCF, RASSCF; RHF/ROHF; CONV/DF; —; —; partially threaded. SAPT; RHF; CONV; —; —; threaded. ADC(1); RHF/UHF; CONV; —; —; threaded. ADC(2); RHF/UHF; CONV; —; —; threaded. ADC(2)-x; RHF/UHF; CONV; —; —; threaded. ADC(3); RHF/UHF; CONV; —; —; threaded. CVS-ADC(1); RHF/UHF; CONV; —; —; threaded. CVS-ADC(2); RHF/UHF; CONV; —; —; threaded. CVS-ADC(2)-x; RHF/UHF; CONV; —; —; threaded. CVS-ADC(3); RHF/UHF; CONV; —; —; threaded. EOM-CC2; RHF; CONV; —; —; threaded 3. EOM-CCSD; RHF/UHF/ROHF; CONV; RHF/UHF/ROHF; CONV; threaded 3. EOM-CC3; RHF/UHF/ROHF; CONV; —; —; threaded 3. DMRG-CI; Y; CONV; —; —. DMRG-SCF; Y; CONV; —; —. Geometry optimization can be performed using either analytic gradients; or energy points. Likewise, vibrational frequencies can be; computed by analytic second derivatives, by finite; differences of analytic gradients, or by finite differences of energies.; PSI4 can also compute an extensive list of one-electron properties. Technical Support¶; The PSI4 package is distributed for free and without any guarantee of; reliability, accuracy, or suitability for any particular purpose. No; obligation to provide technical support is expressed or implied. As time; allows, the developers will attempt to answer inquiries on the forum or GitHub. For bug reports,; specific and detailed information, with example inputs, would be; appreciated.; Where-to-post summary:6. How do I? – ask the forum; I got this error, why? – ask the forum; I got this error and I’m sure it’s a bug – file a GitHub issue; Can I open a discussion on this bit of code? – file a GitHub issue; I have an idea/request and a plan – file a GitHub issue; I have an idea/request –",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/introduction-1.html:26096,energy,energy,26096,psi4manual/1.4.0/introduction-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/introduction-1.html,5,['energy'],['energy']
Energy Efficiency," ROHF triplet orbitals. castup2; SCF with various combinations of pk/density-fitting, castup/no-castup, and spherical/cartesian settings. Demonstrates that puream setting is getting set by orbital basis for all df/castup parts of calc. Demonstrates that answer doesn’t depend on presence/absence of castup. Demonstrates (by comparison to castup3) that output file doesn’t depend on options (scf_type) being set global or local. This input uses global. cc10; ROHF-CCSD cc-pVDZ energy for the \(^2\Sigma^+\) state of the CN radical. opt-freeze-coords; SCF/cc-pVDZ optimization example with frozen cartesian. cc27; Single point gradient of 1-1B2 state of H2O with EOM-CCSD. nbody-cp-gradient; Computation of CP-corrected water trimer gradient (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). mpn-bh; MP(n)/aug-cc-pVDZ BH Energy Point, with n=2-19. Compare against M. L. Leininger et al., J. Chem. Phys. 112, 9213 (2000). sapt-sf1; Tests the Psi4 SF-SAPT code. cbs-delta-energy; Extrapolated energies with delta correction. omp2-5; SOS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. scf-freq1; Analytic vs. finite difference DF-SCF frequency test for water. cc22; ROHF-EOM-CCSD/DZ on the lowest two states of each irrep in \(^{3}B_1\) CH2. cc14; ROHF-CCSD/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. mp2-1; All-electron MP2 6-31G** geometry optimization of water. cepa1; cc-pvdz H2O Test CEPA(1) Energy. casscf-fzc-sp; CASSCF/6-31G** energy point. extern2; External potential calculation involving a TIP3P water and a QM water for DFMP2. Finite different test of the gradient is performed to validate forces. opt9; Various constrained energy minimizations of HOOH with cc-pvdz RHF. Cartesian-coordinate constrained optimizations of HOOH in internals. cc9a; ROHF-CCSD(T) cc-pVDZ energy for the \(^2\Sigma^+\) state of the CN radical, with Z-matrix input. mints1; Symmetry tests for a range of molecules. This doesn’t actually compute any energies, but serve",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html:18423,energy,energy,18423,psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency," ROOT 0 -> ROOT m CORRELATION ENERGY - h SYMMETRY¶; The correlation energy of given method from ground state reference energy to root m in h symmetry. TD-fctl ROOT 0 -> ROOT m OSCILLATOR STRENGTH (LEN) - h SYMMETRY¶. TD-fctl ROOT 0 -> ROOT m OSCILLATOR STRENGTH (VEL) - h SYMMETRY¶; The oscillator strength in length or velocity gauge of named method; from ground state to root m in h symmetry (if available). DFT; functional labeled if canonical. TD-fctl ROOT 0 -> ROOT m ROTATORY STRENGTH (LEN) - h SYMMETRY¶. TD-fctl ROOT 0 -> ROOT m ROTATORY STRENGTH (VEL) - h SYMMETRY¶; The rotatory strength in length or velocity gauge of named method; from ground state to root m in h symmetry (if available). DFT; functional labeled if canonical. THERMAL ENERGY¶; Total thermal energy E [Eh] at given temperature. THERMAL ENERGY CORRECTION¶; Sum of electronic, translational, rotational, and vibrational corrections [Eh] to the thermal energy at given temperature. TWO-ELECTRON ENERGY¶; The two-electron energy contribution [Eh] to the total SCF energy.; Quantity \(E_{2e^-}\) in Eq. (4). UNCP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [Eh] considering only two-body interactions,; computed without counterpoise correction.; Related variable CP-CORRECTED 2-BODY INTERACTION ENERGY. \[E_{\text{IE}} = E_{dimer} - \sum_{monomer}^{n}{E_{monomer}^{\text{unCP}}}\]. WIBERG LOWDIN INDICES¶; Property of Wiberg bond indices using orthogonal Löwdin orbitals, (nat, nat). ZAPTn TOTAL ENERGY¶. ZAPTn CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the labeled Z-averaged perturbation theory level.; n is ZAPT perturbation order. ZERO K ENTHALPY¶; Total electronic and zero-point energy [Eh] at 0 [K]. ZPVE¶; Vibrational zero-point energy [Eh] at 0 [K]. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Alpha. © Copyright 2021, The Psi4 Project.; Last updated on Thursda",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html:49150,energy,energy,49150,psi4manual/1.4.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html,4,['energy'],['energy']
Energy Efficiency," ROOT 0 -> ROOT m CORRELATION ENERGY - h SYMMETRY¶; The correlation energy of given method from ground state reference energy to root m in h symmetry. TD-fctl ROOT 0 -> ROOT m OSCILLATOR STRENGTH (LEN) - h SYMMETRY¶. TD-fctl ROOT 0 -> ROOT m OSCILLATOR STRENGTH (VEL) - h SYMMETRY¶; The oscillator strength in length or velocity gauge of named method; from ground state to root m in h symmetry (if available). DFT; functional labeled if canonical. TD-fctl ROOT 0 -> ROOT m ROTATORY STRENGTH (LEN) - h SYMMETRY¶. TD-fctl ROOT 0 -> ROOT m ROTATORY STRENGTH (VEL) - h SYMMETRY¶; The rotatory strength in length or velocity gauge of named method; from ground state to root m in h symmetry (if available). DFT; functional labeled if canonical. THERMAL ENERGY¶; Total thermal energy E [Eh] at given temperature. THERMAL ENERGY CORRECTION¶; Sum of electronic, translational, rotational, and vibrational corrections [Eh] to the thermal energy at given temperature. TWO-ELECTRON ENERGY¶; The two-electron energy contribution [Eh] to the total SCF energy.; Quantity \(E_{2e^-}\) in Eq. (4). UNCP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [Eh] considering only two-body interactions,; computed without counterpoise correction.; Related variable CP-CORRECTED 2-BODY INTERACTION ENERGY. \[E_{\text{IE}} = E_{dimer} - \sum_{monomer}^{n}{E_{monomer}^{\text{unCP}}}\]. WIBERG LOWDIN INDICES¶; Property of Wiberg bond indices using orthogonal Löwdin orbitals, (nat, nat). ZAPTn TOTAL ENERGY¶. ZAPTn CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the labeled Z-averaged perturbation theory level.; n is ZAPT perturbation order. ZERO K ENTHALPY¶; Total electronic and zero-point energy [Eh] at 0 [K]. ZPVE¶; Vibrational zero-point energy [Eh] at 0 [K]. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Appendices; PSI Variables by Alpha. © Copyright 2021, The Psi4 Project.; Last updated on Sunday,",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/glossary_psivariables-1.html:49218,energy,energy,49218,psi4manual/1.5.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/glossary_psivariables-1.html,4,['energy'],['energy']
Energy Efficiency," ROTATION (MVG) @ xNM¶; The specific rotation [deg/(dm (g/cm^3))] calculated at the CC2 level in the; modified velocity gauge for a given (x) wavelength, (x) rounded to nearest integer. CC QUADRUPOLE XX¶. CC QUADRUPOLE XY¶. CC QUADRUPOLE XZ¶. CC QUADRUPOLE YY¶. CC QUADRUPOLE YZ¶. CC QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; coupled cluster level of theory and root. CCD TOTAL ENERGY¶. CCD CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the coupled-cluster doubles level of theory. CCSD PAIR ENERGIES¶; The restricted-reference pair energies for coupled-cluster singles and doubles; level of theory. Size number of active doubly occupied orbitals, square. CCSD TOTAL ENERGY¶. CCSD CORRELATION ENERGY¶. CCSDT TOTAL ENERGY¶. CCSDT CORRELATION ENERGY¶. CCSDTQ TOTAL ENERGY¶. CCSDTQ CORRELATION ENERGY¶. CCn TOTAL ENERGY¶. CCn CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the requested full coupled-cluster (CCSD, CCSDT, up to CCn); level of theory. CCSD(T) TOTAL ENERGY¶. CCSD(T) CORRELATION ENERGY¶. CCSD(AT) TOTAL ENERGY¶. CCSD(AT) CORRELATION ENERGY¶. A-CCSD(T) TOTAL ENERGY¶. A-CCSD(T) CORRELATION ENERGY¶. CCSDT(Q) TOTAL ENERGY¶. CCSDT(Q) CORRELATION ENERGY¶. CC(n-1)(n) TOTAL ENERGY¶. CC(n-1)(n) CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the perturbatively corrected coupled-cluster (CCSD(T), A-CCSD(T) = CCSD(AT), CCSDT(Q),; up to CC(n-1)(n) level of theory. CCSDT-1a TOTAL ENERGY¶. CCSDT-1a CORRELATION ENERGY¶. CCSDTQ-1a TOTAL ENERGY¶. CCSDTQ-1a CORRELATION ENERGY¶. CCn-1a TOTAL ENERGY¶. CCn-1a CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the approximate coupled-cluster (CCSD(T)-1a, CCSDT(Q)-1a,; up to CCn-1a) level of theory. CCSDT-1b TOTAL ENERGY¶. CCSDT-1b CORRELATION ENERGY¶. CCSDTQ-1b TOTAL ENERGY¶. CCSDTQ-1b CORRELATION ENERGY¶. CC",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/glossary_psivariables-1.html:6240,energy,energy,6240,psi4manual/1.5.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/glossary_psivariables-1.html,4,['energy'],['energy']
Energy Efficiency," ROTATION (MVG) @ xNM¶; The specific rotation [deg/(dm (g/cm^3))] calculated at the CC2 level in the; modified velocity gauge for a given (x) wavelength, (x) rounded to nearest integer. CC QUADRUPOLE XX¶. CC QUADRUPOLE XY¶. CC QUADRUPOLE XZ¶. CC QUADRUPOLE YY¶. CC QUADRUPOLE YZ¶. CC QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; coupled cluster level of theory and root. CCD TOTAL ENERGY¶. CCD CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the coupled-cluster doubles level of theory. CCSD PAIR ENERGIES¶; The restricted-reference pair energies for coupled-cluster singles and doubles; level of theory. Size number of active doubly occupied orbitals, square. CCSD TOTAL ENERGY¶. CCSD CORRELATION ENERGY¶. CCSDT TOTAL ENERGY¶. CCSDT CORRELATION ENERGY¶. CCSDTQ TOTAL ENERGY¶. CCSDTQ CORRELATION ENERGY¶. CCn TOTAL ENERGY¶. CCn CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the requested full coupled-cluster (CCSD, CCSDT, up to CCn); level of theory. CCSD(T) TOTAL ENERGY¶. CCSD(T) CORRELATION ENERGY¶. CCSD(AT) TOTAL ENERGY¶. CCSD(AT) CORRELATION ENERGY¶. CCSDT(Q) TOTAL ENERGY¶. CCSDT(Q) CORRELATION ENERGY¶. CC(n-1)(n) TOTAL ENERGY¶. CC(n-1)(n) CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the perturbatively corrected coupled-cluster (CCSD(T), CCSD(AT), CCSDT(Q),; up to CC(n-1)(n) level of theory. CCSDT-1a TOTAL ENERGY¶. CCSDT-1a CORRELATION ENERGY¶. CCSDTQ-1a TOTAL ENERGY¶. CCSDTQ-1a CORRELATION ENERGY¶. CCn-1a TOTAL ENERGY¶. CCn-1a CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the approximate coupled-cluster (CCSD(T)-1a, CCSDT(Q)-1a,; up to CCn-1a) level of theory. CCSDT-1b TOTAL ENERGY¶. CCSDT-1b CORRELATION ENERGY¶. CCSDTQ-1b TOTAL ENERGY¶. CCSDTQ-1b CORRELATION ENERGY¶. CCn-1b TOTAL ENERGY¶. CCn-1b CORRELATION ENERGY¶; The total electronic",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html:6240,energy,energy,6240,psi4manual/1.4.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html,4,['energy'],['energy']
Energy Efficiency," RS-RFO. Type: double; Default: 1e8. STEP_TYPE¶. Geometry optimization step type, either Newton-Raphson or Rational Function Optimization. Type: string; Possible Values: RFO, NR, SD, LINESEARCH_STATIC; Default: RFO. Convergence Control¶. FLEXIBLE_G_CONVERGENCE¶. Even if a user-defined threshold is set, allow for normal, flexible convergence criteria. Type: boolean; Default: false. G_CONVERGENCE¶. Set of optimization criteria. Specification of any MAX_*_G_CONVERGENCE or RMS_*_G_CONVERGENCE options will append to overwrite the criteria set here unless FLEXIBLE_G_CONVERGENCE is also on. See Table Geometry Convergence for details. Type: string; Possible Values: QCHEM, MOLPRO, GAU, GAU_LOOSE, GAU_TIGHT, GAU_VERYTIGHT, TURBOMOLE, CFOUR, NWCHEM_LOOSE; Default: QCHEM. MAX_DISP_G_CONVERGENCE¶. Convergence criterion for geometry optmization: maximum displacement (internal coordinates, atomic units). Type: conv double; Default: 1.2e-3. MAX_ENERGY_G_CONVERGENCE¶. Convergence criterion for geometry optmization: maximum energy change. Type: conv double; Default: 1.0e-6. MAX_FORCE_G_CONVERGENCE¶. Convergence criterion for geometry optmization: maximum force (internal coordinates, atomic units). Type: conv double; Default: 3.0e-4. RMS_DISP_G_CONVERGENCE¶. Convergence criterion for geometry optmization: rms displacement (internal coordinates, atomic units). Type: conv double; Default: 1.2e-3. RMS_FORCE_G_CONVERGENCE¶. Convergence criterion for geometry optmization: rms force (internal coordinates, atomic units). Type: conv double; Default: 3.0e-4. Hessian Update¶. CART_HESS_READ¶. Do read Cartesian Hessian? Only for experts - use FULL_HESS_EVERY instead. Type: boolean; Default: false. FULL_HESS_EVERY¶. Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__optking-1.html:4536,energy,energy,4536,psi4manual/1.0.0/autodir_options_c/module__optking-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__optking-1.html,2,['energy'],['energy']
Energy Efficiency," Restartfile is always converted to a single-element list if; # it contains a single string; if 'restart_file' in kwargs:; restartfile = kwargs['restart_file'] # Option still available for procedure-specific action; if restartfile != list(restartfile):; restartfile = [restartfile]; # Rename the files to be read to be consistent with psi4's file system; for item in restartfile:; name_split = re.split(r'\.', item); filenum = name_split[len(name_split) - 1]; try:; filenum = int(filenum); except ValueError:; filenum = 32 # Default file number is the checkpoint one; psioh = core.IOManager.shared_object(); psio = core.IO.shared_object(); filepath = psioh.get_file_path(filenum); namespace = psio.get_default_namespace(); pid = str(os.getpid()); prefix = 'psi'; targetfile = filepath + prefix + '.' + pid + '.' + namespace + '.' + str(filenum); shutil.copy(item, targetfile). wfn = procedures['energy'][lowername](lowername, molecule=molecule, **kwargs). for postcallback in hooks['energy']['post']:; postcallback(lowername, wfn=wfn, **kwargs). optstash.restore(); if return_wfn: # TODO current energy safer than wfn.energy() for now, but should be revisited. # TODO place this with the associated call, very awkward to call this in other areas at the moment; if lowername in ['efp', 'mrcc', 'dmrg', 'psimrcc']:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the incoming reference wavefunction.\n\n""); elif 'sapt' in lowername:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the dimer SCF wavefunction.\n\n""). return (core.get_variable('CURRENT ENERGY'), wfn); else:; return core.get_variable('CURRENT ENERGY'). [docs]def gradient(name, **kwargs):; r""""""Function complementary to :py:func:~driver.optimize(). Carries out one gradient pass,; deciding analytic or finite difference. :returns: :py:class:`~psi4.core.Matr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html:32037,energy,energy,32037,psi4manual/1.1.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html,1,['energy'],['energy']
Energy Efficiency," Restartfile is always converted to a single-element list if; # it contains a single string; if 'restart_file' in kwargs:; restartfile = kwargs['restart_file'] # Option still available for procedure-specific action; if restartfile != list(restartfile):; restartfile = [restartfile]; # Rename the files to be read to be consistent with psi4's file system; for item in restartfile:; name_split = re.split(r'\.', item); filenum = name_split[len(name_split) - 1]; try:; filenum = int(filenum); except ValueError:; filenum = 32 # Default file number is the checkpoint one; psioh = psi4.IOManager.shared_object(); psio = psi4.IO.shared_object(); filepath = psioh.get_file_path(filenum); namespace = psio.get_default_namespace(); pid = str(os.getpid()); prefix = 'psi'; targetfile = filepath + prefix + '.' + pid + '.' + namespace + '.' + str(filenum); shutil.copy(item, targetfile). wfn = procedures['energy'][lowername](lowername, molecule=molecule, **kwargs). for postcallback in hooks['energy']['post']:; postcallback(lowername, wfn=wfn, **kwargs). optstash.restore(); if return_wfn: # TODO current energy safer than wfn.energy() for now, but should be revisited. # TODO place this with the associated call, very awkward to call this in other areas at the moment; if lowername in ['efp', 'mrcc', 'dmrg', 'psimrcc']:; psi4.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); psi4.print_out(""The returned wavefunction is the incoming reference wavefunction.\n\n""); elif 'sapt' in lowername:; psi4.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); psi4.print_out(""The returned wavefunction is the dimer SCF wavefunction.\n\n""). return (psi4.get_variable('CURRENT ENERGY'), wfn); else:; return psi4.get_variable('CURRENT ENERGY'). [docs]def gradient(name, **kwargs):; r""""""Function complementary to :py:func:~driver.optimize(). Carries out one gradient pass,; deciding analytic or finite difference. :returns: :ref:`Matrix<sec:psimod_Ma",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver.html:30791,energy,energy,30791,psi4manual/1.0.0/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver.html,1,['energy'],['energy']
Energy Efficiency," Returns the Atomic Orbital to Symmetry Orbital transformer. arrays(self: psi4.core.Wavefunction) → Dict[str, psi4.core.Matrix]¶; Returns the map of all internal arrays. atomic_point_charges(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. build(mol, basis=None)¶. ci_nat_orbs(self: psi4.core.CIWavefunction) → None¶; docstring. cleanup_ci(self: psi4.core.CIWavefunction) → None¶; docstring. cleanup_dpd(self: psi4.core.CIWavefunction) → None¶; docstring. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. compute_state_transfer(self: psi4.core.CIWavefunction, arg0: psi::detci::CIvect, arg1: int, arg2: psi4.core.Matrix, arg3: psi::detci::CIvect) → None¶; docstring. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. diag_h(self: psi4.core.CIWavefunction, arg0: float, arg1: float) → int¶; docstring. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psi4api-1.html:8924,energy,energy,8924,psi4manual/1.1.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psi4api-1.html,2,['energy'],['energy']
Energy Efficiency," Returns the One-electron Overlap Matrix. V_potential(self: psi4.core.HF) → psi4.core.VBase; Returns the internal DFT V object. Va(self: psi4.core.HF) → psi4.core.Matrix; Returns the Alpha Kohn-Sham Potential Matrix. Vb(self: psi4.core.HF) → psi4.core.Matrix; Returns the Beta Kohn-Sham Potential Matrix. X(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Lagrangian Matrix. alpha_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. aotoso(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Atomic Orbital to Symmetry Orbital transformer. array_variable(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Returns copy of the requested (case-insensitive) Matrix QC variable. array_variables(self: psi4.core.Wavefunction) → Dict[str, psi4.core.Matrix]¶; Returns the dictionary of all Matrix QC variables. arrays()¶. atomic_point_charges(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the set atomic point charges. attempt_number_; Current macroiteration (1-indexed) for stability analysis. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.Wavefunction, basis: psi4.core.BasisSet) → psi4.core.Wavefunction¶; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet basis. check_phases(self: psi4.core.HF) → None; docstring. clear_external_potentials(self: psi4.core.HF) → None; Clear private external_potentials list. compute_E(self: psi4.core.HF) → float; docstring. compute_energy(); Ba",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.hf.html:12320,charge,charges,12320,psi4manual/1.3.2/api/psi4.core.hf.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.hf.html,1,['charge'],['charges']
Energy Efficiency," S. Grimme’s -D correction¶. Extension [1]; Variant and Computing Program; DFT_DISPERSION_PARAMETERS. -D; alias to -D2P4;  . -D1; -D1 [2] within Psi4;  . -D2; alias to -D2P4;  . -D2P4; -D2 [3] within Psi4; []. -D2GR; -D2 [3] through dftd3; [, ]. -D3; alias to -D3ZERO;  . -D3ZERO; -D3 [4] w/ original zero-damping through dftd3; [, , , ]. -D3BJ; -D3 [5] w/ newer Becke-Johnson rational damping through dftd3; [, , , ]. -D3M; alias to -D3MZERO;  . -D3MZERO; -D3 [6] w/ reparameterized and more flexible original zero-damping through dftd3; [, , , ]. -D3MBJ; -D3 [6] w/ reparameterized newer Becke-Johnson rational damping through dftd3; [, , , ]. Footnotes. [1]Note that there are functionals with these extensions (e.g., wB97X-D) that,; not being Grimme corrections, have nothing to do with this table. [2][Grimme:2004:1463]. [3](1, 2) [Grimme:2006:1787]. [4][Grimme:2010:154104]. [5][Grimme:2011:1456]. [6](1, 2) [Smith:2016:2197]. A few practical examples:. DFT-D2 single point with default parameters (dftd3 not called); energy('bp86-d'). DFT-D3BJ optimization with default parameters; optimize('pbe-d3bj'). DFT-D2 optimization with custom s6 parameter; set dft_dispersion_parameters [1.20]; optimize('b3lyp-d2'). DFT-D3ZERO single point (b3lyp) with custom s8 parameter (reset all four values); set dft_dispersion_parameters [1.0, 2.0, 1.261, 14.0]; energy('b3lyp-d3'). If only dispersion corrections (rather than total energies) are of; interest, the dftd3 program can be run independently of the scf; through the python function run_dftd3(). (This function; is the same Psi4/dftd3 interface that is called during an scf job.); This route is much faster than running a DFT-D energy. Some set-up:; molecule nene {; Ne; Ne 1 2.0; }. nene.update_geometry(). The same four dispersion corrections/gradients as the section above:; >>> print nene.run_dftd3('bp86', 'd', dertype=0); -7.735e-05. >>> E, G = nene.run_dftd3('pbe', 'd3bj'); >>> print G; [[0.0, 0.0, -1.1809087569358e-05], [0.0, 0.0, 1.18090",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/dftd3-1.html:6217,energy,energy,6217,psi4manual/1.0.0/dftd3-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/dftd3-1.html,2,['energy'],['energy']
Energy Efficiency," S/R: Read energy from each displaced geometry output file and save in energies array; elif (opt_mode.lower() == 'reap'):; E = 0.0; exec banners. try:; freagent = open('%s.out' % (rfile), 'r'); except IOError:; ValidationError('Aborting upon output file \'%s.out\' not found.\n' % (rfile)); return 0.0; else:; while 1:; line = freagent.readline(); if not line:; if E == 0.0:; ValidationError('Aborting upon output file \'%s.out\' has no %s RESULT line.\n' % (rfile, 'GRADIENT')); break; s = line.split(); if (len(s) != 0) and (s[0:3] == ['GRADIENT', 'RESULT:', 'computation']):; if int(s[3]) != opt_linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (rfile, str(s[3]), str(opt_linkage))); if s[6] != str(n + 1):; raise ValidationError('Output file \'%s.out\' has nominal affiliation %s incompatible with item %s.'; % (rfile, s[6], str(n + 1))); if (s[8:10] == ['electronic', 'energy']):; E = float(s[10]); PsiMod.print_out('%s RESULT: electronic energy = %20.12f\n' % ('GRADIENT', E)); freagent.close(); energies.append(E). # S/R: Quit sow after writing files; if (opt_mode.lower() == 'sow'):; return 0.0. if (opt_mode.lower() == 'reap'):; PsiMod.set_variable('CURRENT ENERGY', energies[-1]). # Obtain the gradient; PsiMod.fd_1_0(energies). # The last item in the list is the reference energy, return it; return energies[-1]. [docs]def property(name, **kwargs):; r""""""Function to compute various properties. :aliases: prop(). :returns: (*float*) Total electronic energy in Hartrees. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - This function at present handles property functions only for CC methods.; Consult the keywords sections for other modules for further property capabilities. - Check that energy is actually being returned. - Check if some PSI variables ought to be set. +-------------------------+---------------------------------------------------------------------------------------+; | nam",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/driver.html:29556,energy,energy,29556,psi4manual/4.0b2/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/driver.html,1,['energy'],['energy']
Energy Efficiency," S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('mp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). """"""; lowername = name #TODO; kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name #.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish function to call; func = kwargs.pop('db_func', kwargs.pop('func', energy)); kwargs['db_func'] = func; # Bounce to CP if bsse kwarg (someday); if kwargs.get('bsse_type', None) is not None:; raise ValidationError(""""""Database: Cannot specify bsse_type for database. Use the cp keyword withing database instead.""""""). allowoptexceeded = kwargs.get('allowoptexceeded', False); optstash = p4util.OptionsState(; ['WRITER_FILE_LABEL'],; ['SCF', 'REFERENCE']). # Wrapper wholly defines molecule. discard any passed-in; kwargs.pop('molecule', None). # Paths to search for database files: here + PSIPATH + library + PYTHONPATH; db_paths = []; db_paths.append(os.getcwd()); db_paths.extend(os.environ.get('PSIPATH', '').split(os.path.pathsep)); db_paths.append(os.path.join(core.get_datadir(), 'databases')); db_paths.append(os.path.dirname(__file__)); db_paths = list(map(os.path.abspath, db_paths)); sys.path[1:1] = db_paths; # TODO this should be modernized a la interface_cfour. # Define path and load module for requested database; database = p4util.import_ignorecase(db_name); if database is None:; core.print_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html:8515,energy,energy,8515,psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html,8,['energy'],['energy']
Energy Efficiency," S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('mp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). """"""; lowername = name #TODO; kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name #.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish function to call; func = kwargs.pop('db_func', kwargs.pop('func', energy)); kwargs['db_func'] = func; # Bounce to CP if bsse kwarg (someday); if kwargs.get('bsse_type', None) is not None:; raise ValidationError(""""""Database: Cannot specify bsse_type for database. Use the cp keyword withing database instead.""""""). allowoptexceeded = kwargs.get('allowoptexceeded', False); optstash = p4util.OptionsState(; ['WRITER_FILE_LABEL'],; ['SCF', 'REFERENCE']). # Wrapper wholly defines molecule. discard any passed-in; kwargs.pop('molecule', None). # Paths to search for database files: here + PSIPATH + library + PYTHONPATH; psidatadir = core.get_datadir(); #nolongerpredictable psidatadir = __file__ + '/../..' if psidatadir is None else psidatadir; libraryPath = ':' + os.path.abspath(psidatadir) + '/databases'; driver_loc = os.path.dirname(os.path.abspath(__file__)); dbPath = os.path.abspath('.') + \; ':' + ':'.join([os.path.abspath(x) for x in os.environ.get('PSIPATH', '').split(':')]) + \; libraryPath + \; ':' + driver_loc # so the databases can ""import qcdb"". sys.path = [sys.path[0]] + dbPath.split('",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/wrapper_database.html:8594,energy,energy,8594,psi4manual/1.2.1/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/wrapper_database.html,1,['energy'],['energy']
Energy Efficiency," S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('mp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). """"""; lowername = name #TODO; kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name #.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish function to call; func = kwargs.pop('db_func', kwargs.pop('func', energy)); kwargs['db_func'] = func; # Bounce to CP if bsse kwarg (someday); if kwargs.get('bsse_type', None) is not None:; raise ValidationError(""""""Database: Cannot specify bsse_type for database. Use the cp keyword withing database instead.""""""). optstash = p4util.OptionsState(; ['WRITER_FILE_LABEL'],; ['SCF', 'REFERENCE']). # Wrapper wholly defines molecule. discard any passed-in; kwargs.pop('molecule', None). # Paths to search for database files: here + PSIPATH + library + PYTHONPATH; psidatadir = os.environ.get('PSIDATADIR', None); #nolongerpredictable psidatadir = __file__ + '/../..' if psidatadir is None else psidatadir; libraryPath = ':' + os.path.abspath(psidatadir) + '/databases'; driver_loc = os.path.dirname(os.path.abspath(__file__)); dbPath = os.path.abspath('.') + \; ':' + ':'.join([os.path.abspath(x) for x in os.environ.get('PSIPATH', '').split(':')]) + \; libraryPath + \; ':' + driver_loc # so the databases can ""import qcdb"". sys.path = [sys.path[0]] + dbPath.split(':') + sys.path[1:]; # TODO this should be ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/wrapper_database.html:8583,energy,energy,8583,psi4manual/1.1.0/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/wrapper_database.html,1,['energy'],['energy']
Energy Efficiency," S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('mp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). """"""; lowername = name #TODO; kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name #.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish function to call; func = kwargs.pop('db_func', kwargs.pop('func', energy)); kwargs['db_func'] = func; # Bounce to CP if bsse kwarg (someday); if kwargs.get('bsse_type', None) is not None:; raise ValidationError(""""""Database: Cannot specify bsse_type for database. Use the cp keyword withing database instead.""""""). optstash = p4util.OptionsState(; ['WRITER_FILE_LABEL'],; ['SCF', 'REFERENCE']). # Wrapper wholly defines molecule. discard any passed-in; kwargs.pop('molecule', None). # Paths to search for database files: here + PSIPATH + library + PYTHONPATH; psidatadir = os.environ.get('PSIDATADIR', None); psidatadir = __file__ + '/../..' if psidatadir is None else psidatadir; libraryPath = ':' + os.path.abspath(psidatadir) + '/databases'; dbPath = os.path.abspath('.') + \; ':' + ':'.join([os.path.abspath(x) for x in os.environ.get('PSIPATH', '').split(':')]) + \; libraryPath; sys.path = [sys.path[0]] + dbPath.split(':') + sys.path[1:]; # TODO this should be modernized a la interface_cfour. # Define path and load module for requested database; database = p4util.import_ignorecase(db_name); if d",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:8600,energy,energy,8600,psi4manual/1.0.0/_modules/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html,1,['energy'],['energy']
Energy Efficiency," SAPT0, SF-SAPT0; RHF/UHF/ROHF; CONV/DF; E. SAPT(DFT); RKS; DF; E. SAPT2, 2+, 2+(3), 2+3; RHF; DF; E. F/I-SAPT0; RHF; DF; E. TDDFT; RKS/UKS; CONV/DF; E. EP2; RHF; DF; E. EOM-CC2; RHF; CONV; E. EOM-CCSD; RHF/UHF/ROHF; CONV; E/G. EOM-CC3; RHF/UHF/ROHF; CONV; E. ❖ with LibEFP. EFP/EFP; RHF. E/G. QM/EFP; RHF. E. ❖ with DFTD3, DFTD4, and gCP. HF-3c, PBEh-3c, B97-3C,; r2SCAN-3c, wB97X-3c; R/U/ROHF, R/UKS. E/G. DFT-D3, DFT-D4; RKS/UKS. E/G. ❖ with ADCC. ADC(1), CVS-ADC(1); RHF/UHF; CONV; E. ADC(2), CVS-ADC(2); RHF/UHF; CONV; E. ADC(2)-x, CVS-ADC(2)-x; RHF/UHF; CONV; E. ADC(3), CVS-ADC(3); RHF/UHF; CONV; E. ❖ with CheMPS2. DMRG-CI; RHF; CONV; E. DMRG-SCF; RHF; CONV; E. DMRG-CASPT2; RHF; CONV; E. [1]; Many methods have a more detailed breakdown of capabilities here. [2]; (1,2); Not all combinations of reference and algorithm type may be available for any variant and derivative. See detailed capabilities tables. [3]; Shown are analytic implementations for energy (E), gradient, (G), and Hessian (H); finite difference derivatives are invoked automatically if analytic not available. [4]; Frozen natural orbital variant available. In particular, RHF available as CONV. [5]; (1,2); Frozen natural orbital variant available. In particular, RHF available as CONV/DF. Summary capabilities of PSI4. “✓” runs analytically. “∷” runs derivative with internal finite difference. Double underline “✓̳” or “∷̳” is default algorithm type when type selector (e.g., CC_TYPE) unspecified.¶. ◻; name ↓ →; ◻; ◻. REFERENCE →; ◻; type[6] ↓ →; FREEZE_CORE[7]→. Restricted (RHF); Unrestricted (UHF); Restricted Open (ROHF). energy(); gradient()[8]; energy(); gradient()[8]; energy(); gradient()[8]. CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD. A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F. hf. SCF_TYPE; ✓. ✓̳. ✓. ✓. ✓̳. ∷. ✓. ✓̳. ✓. ✓. ✓̳. ∷. ✓. ✓̳. ✓. ✓. ✓̳. ∷. mp2. MP2_TYPE; ✓; ✓; ✓̳; ✓̳; ✓; ✓; ✓; ∷; ✓̳; ✓̳; ∷; ∷; ✓; ✓; ✓̳; ✓",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/introduction.html:27056,energy,energy,27056,psi4manual/1.9.x/introduction.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/introduction.html,2,['energy'],['energy']
Energy Efficiency," SCF guesses on FH and FH+ in cc-pVTZ basis. cubeprop-esp; RHF orbitals and density for water. fd-freq-energy; SCF STO-3G finite-difference frequencies from energies for H2O. linK-2; RKS Linear Exchange Algorithm test for benzene. opt15; 6-31G(d) optimization of SF4 starting from linear bond angle that is not linear in the optimized structure but is in a symmetry plane of the molecule. freq-isotope1; Vibrational and thermo analysis of several water isotopologs. Demonstrates Hessian reuse for different temperatures and pressures but not for different isotopologs. tdscf-1; td-uhf test on triplet states of methylene (rpa). dct6; DCT calculation for the triplet O2 using DC-06 and DC-12. Only two-step algorithm is tested. sapt8; SAPT0(ROHF) open-shell computation of CN - Ne interaction energy First with jun-cc-pVDZ and density fitted integrals with ROHF Then with cc-pVDZ and direct integrals, except for dispersion that is computed with cc-pVDZ-ri density fitting with ROHF. fnocc4; Test FNO-DF-CCSD(T) energy. cdremp-1; Cholesky decomposed REMP/cc-pVDZ energies for the CO2 molecule. opt13; B3LYP cc-pVDZ geometry optimzation of phenylacetylene, starting from not quite linear structure updated reference due to new BraggSlater radii. olccd2; OLCCD cc-pVDZ energy with B3LYP initial guess for the NO radical. scf-uhf-grad-nobeta; UHF gradient for a one-electron system (no beta electrons). dfccsdt1; DF-CCSD(T) cc-pVDZ energy for the H2O molecule. pywrap-align-chiral; testing aligner on enantiomers based on Table 1 of 10.1021/ci100219f aka J Chem Inf Model 2010 50(12) 2129-2140. dft-grad-disk; A range-seperated gradient for SO2 to test disk algorithms by explicitly setting low memory. cc5; RHF CCSD(T) cc-pVDZ frozen-core energy of C4NH4 Anion. cc35; CC3(ROHF)/cc-pVDZ H2O \(R_e\) geom from Olsen et al., JCP 104, 8007 (1996). omp3-4; SCS-OMP3 cc-pVDZ geometry optimization for the H2O molecule. scf-ecp2; Water-Argon complex with ECP present; check of RHF Hessian. cbs-xtpl-gradient; V",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html:31784,energy,energy,31784,psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency," SCF to FCI. SAPT: Symmetry-Adapted Perturbation Theory¶; Code author: Edward G. Hohenstein, Rob M. Parrish, Jérôme F. Gonthier, and Daniel. G. A. Smith; Section author: Edward G. Hohenstein and Jérôme F. Gonthier; Module: Keywords, PSI Variables, LIBSAPT_SOLVER. Warning; In rare cases with systems having a high degree of symmetry,; PSI4 gives (very obviously) wrong answers for SAPT computations; when the specification is in Z-matrix format. Use a Cartesian representation; to avoid this problem. Caution; In early versions (notably PSI4 alpha circa 2011; and before), frozen core was implemented incompletely and for; only selected terms. Comparisons with papers published using early; PSI4 SAPT code may show discrepancies of 0.01-0.10 kcal/mol in; individual terms, particularly \(E_{exch}^{(11)}\) and \(E_{exch}^{(12)}\). Caution; January 28th 2016, the default for all NAT_ORBS options; was changed to true. Hence the code now by default uses natural; orbital truncation to speed up the evaluation of energy terms; wherever possible, according to literature recommendations.; In early July 2016, some total SAPT energy psivars were renamed. Symmetry-adapted perturbation theory (SAPT) provides a means of directly; computing the noncovalent interaction between two molecules, that is, the; interaction energy is determined without computing the total energy of the; monomers or dimer. In addition, SAPT provides a decomposition of the; interaction energy into physically meaningful components: i.e.,; electrostatic, exchange, induction, and dispersion terms. In SAPT, the; Hamiltonian of the dimer is partitioned into contributions from each; monomer and the interaction. \[H=F_A+W_A+F_B+W_B+V\]; Here, the Hamiltonian is written as a sum of the usual monomer Fock; operators, \(F\), the fluctuation potential of each monomer, \(W\), and the; interaction potential, \(V\). The monomer Fock operators, \(F_A+F_B\), are; treated as the zeroth-order Hamiltonian and the interaction energy is; e",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/sapt-1.html:1148,energy,energy,1148,psi4manual/1.2.1/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/sapt-1.html,4,['energy'],['energy']
Energy Efficiency," SOS method. Type: string; Possible Values: SOS, SOSPI; Default: SOS. SOSCF (SCF)¶SCF — Do use second-order SCF convergence methods?. Type: boolean; Default: false. SOSCF_CONV (SCF)¶SCF — Second order convergence threshold. Cease microiterating at this value. Type: conv double; Default: 5.0e-3. SOSCF_MAX_ITER (SCF)¶SCF — Maximum number of second-order microiterations to perform. Type: integer; Default: 5. SOSCF_MIN_ITER (SCF)¶SCF — Minimum number of second-order microiterations to perform. Type: integer; Default: 1. SOSCF_PRINT (SCF)¶SCF — Do we print the SOSCF microiterations?. Type: boolean; Default: false. SOSCF_START_CONVERGENCE (SCF)¶SCF — When to start second-order SCF iterations based on gradient RMS. Type: conv double; Default: 1.0e-2. SPIN_SCALE_TYPE (OCC)¶OCC (Expert) — Controls the spin scaling set to current energy. This is set by Psi internally. Type: string; Possible Values: NONE, CUSTOM, SCS, SCSN, SCSVDW, SOS, SOSPI; Default: NONE. SPINADAPT_ENERGIES (CCENERGY)¶CCENERGY — Do print spin-adapted pair energies?. Type: boolean; Default: false. SS_E_CONVERGENCE (CCEOM)¶CCEOM — Convergence criterion for excitation energy (change) in the Davidson algorithm for the CIS guess to CC-EOM. Type: conv double; Default: 1e-6. SS_R_CONVERGENCE (CCEOM)¶CCEOM — Convergence criterion for norm of the residual vector in the Davidson algorithm for the CIS guess to CC-EOM. Type: conv double; Default: 1e-6. SS_SCALE (OCC)¶OCC — A custom scaling parameter for same-spin terms in OCC. The result goes to a CUSTOM SCS variable, exact name method-dependent. Type: double; Default: 1. SS_SKIP_DIAG (CCEOM)¶CCEOM — Do skip diagonalization of Hbar SS block?. Type: boolean; Default: false. SS_VECS_PER_ROOT (CCEOM)¶CCEOM — SS vectors stored per root. Type: integer; Default: 5. SSAPT0_SCALE (FISAPT)¶FISAPT — Do sSAPT0 exchange-scaling with F-SAPT. Type: boolean; Default: false. STABILITY_ADD_VECTORS (DCT)¶DCT (Expert) — The number of vectors that can be added simultaneously into the subsp",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:219018,adapt,adapted,219018,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,4,['adapt'],['adapted']
Energy Efficiency," STO-3G geometry optimzation, with Z-matrix input, by finite-differences. castup1; Test of SAD/Cast-up (mainly not dying due to file weirdness). adc1; ADC/6-31G** on H2O. cc9; UHF-CCSD(T) cc-pVDZ frozen-core energy for the state of the CN radical, with Z-matrix input. pubchem1; Benzene vertical singlet-triplet energy difference computation, using the PubChem database to obtain the initial geometry, at the UHF an ROHF levels of theory. cc44; Test case for some of the PSI4 out-of-core codes. The code is given only 2.0 MB of memory, which is insufficient to hold either the A1 or B2 blocks of an ovvv quantity in-core, but is sufficient to hold at least two copies of an oovv quantity in-core. cc35; CC3(ROHF)/cc-pVDZ H2O geom from Olsen et al., JCP 104, 8007 (1996). cc9a; ROHF-CCSD(T) cc-pVDZ energy for the state of the CN radical, with Z-matrix input. cc1; RHF-CCSD 6-31G** all-electron optimization of the H2O molecule. scf4; RHF cc-pVDZ energy for water, automatically scanning the symmetric stretch and bending coordinates using Python’s built-in loop mechanisms. The geometry is apecified using a Z-matrix with variables that are updated during the potential energy surface scan, and then the same procedure is performed using polar coordinates, converted to Cartesian coordinates. cisd-h2o-clpse; 6-31G** H2O Test CISD Energy Point with subspace collapse. dfmp2_2; Density fitted MP2 energy of H2, using density fitted reference and automatic looping over cc-pVDZ and cc-pVTZ basis sets. Results are tabulated using the built in table functions by using the default options and by specifiying the format. cc24; Single point gradient of 1-2B1 state of H2O+ with EOM-CCSD. cc14; ROHF-CCSD/cc-pVDZ CH2 geometry optimization via analytic gradients. cc29; CCSD/cc-pVDZ optical rotation calculation (both gauges) on Cartesian H2O2. dfscf-bz2; Benzene Dimer DF-HF/cc-pVDZ. matrix1; An example of using BLAS and LAPACK calls directly from the Psi input file, demonstrating matrix multiplication, ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodoc_testsuite-1.html:14329,energy,energy,14329,psi4manual/4.0b2/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodoc_testsuite-1.html,4,['energy'],['energy']
Energy Efficiency," STO-3G; basis set to just the carbon atoms labelled C1. This bizarre example was; constructed to demonstrate the syntax, but the flexibility of the basis set; specification is advantageous, for example, when selectively omitting diffuse; functions to make computations more tractable.; In the above example the basis sets have been assigned asymmetrically, reducing; the effective symmetry from \(D_{6h}\) to \(C_{2v}\); PSI4 will detect this; automatically and run in the appropriate point group.; Basis blocks can also be named, e.g., basis; optional_basis_name {...} and the basis defined by it later; applied to another molecule.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32# sets basis keyword; basis mybas {; assign aug-cc-pvtz; assign f cc-pvtz; }. # re-sets basis keyword; set basis aug-cc-pvtz. molecule hf {; H; F 1 1.0; }. molecule h2o {; O; H 1 1.0; H 1 1.0 2 90.0; }. # runs HF and H2O with aug-cc-pvtz; energy('hf', molecule=hf); energy('hf', molecule=h2o). # re-re-sets basis keyword; set basis mybas. # runs HF with cc-pvtz on F and aug-cc-pvtz on H; energy('hf', molecule=hf). # runs H2O with aug-cc-pvtz, effectively; energy('hf', molecule=h2o). Finally, we note that the basis {...} block may also be used; for defining basis sets, as detailed in User-Defined Basis Sets.; Calculations requesting density fitting (on by default for many methods); require auxiliary fitting basis set(s) in addition to the primary; orbital one associated with the BASIS keyword.; When most popular basis sets are being used, including Dunning and; Pople-style, the SCF, DF-MP2, and SAPT codes will chose the appropriate; auxiliary basis set automatically according to Auxiliary Basis Sets,; unless instructed otherwise by setting the auxiliary basis set in the; input.; Should needed elements be missing from the best; auxiliary basis or should the orbital basis be unknown to PSI4,; the auxiliary basis will fall back on def",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/basissets-1.html:4406,energy,energy,4406,psi4manual/1.2.1/basissets-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/basissets-1.html,12,['energy'],['energy']
Energy Efficiency," Sec. Compiling and Installing).; This very simple input is sufficient to run the requested information.; Notice that we didn’t tell the program some otherwise useful information; like the charge on the molecule (0, it’s neutral), the spin multiplicity; (1 for a closed-shell molecule with all electrons paired), or the reference; wavefunction to use (restricted Hartree–Fock, or RHF, is usually; appropriate for a closed-shell molecule). The program correctly guessed; all of these options for us. We can change the default behavior through; additional keywords.; Let’s consider what we would do for an open-shell molecule, where; not all electrons are paired. For example, let’s run a computation; on methylene (CH2), whose ground electronic state has two unpaired; electrons (triplet electronic state, or a spin multiplicity ).; In this case, the default spin multiplicity (1) is not correct, so we; need to tell the program the true value (3). Like many programs, PSI4; can get the charge and multiplicity as the first two integers in the; Z-matrix. Note the line with 0 3 at the beginning of the molecule; specification below. In this example we will also specify the bond length; and bond angle as variables ( and ), whose values are given; at the end of the Z-matrix specification.; #! Sample UHF/6-31G** CH2 computation. memory 250 mb. molecule ch2 {; 0 3; C ; H 1 R; H 1 R 2 A. R = 1.075; A = 133.93; }. set basis 6-31G**; set reference uhf; energy ('scf'). This sample input can be found in; tu2-ch2-energy and as; before it can be run through the command psi4 input.dat output.dat; (actually, because psi4 by default looks for an input file named; input.dat and writes by default to a file called output.dat, in this; case one could also just type psi4). If it works, it should print; the final energy as; @UHF Final Energy: -38.92533462456894. Notice we added a new keyword, set reference uhf, to the input. For; open-shell molecules, we have a choice of unrestricted orbitals; (unrestric",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/tutorial-1.html:2918,charge,charge,2918,psi4manual/4.0b4/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/tutorial-1.html,4,['charge'],['charge']
Energy Efficiency," Sec. Compiling and Installing).; This very simple input is sufficient to run the requested information.; Notice that we didn’t tell the program some otherwise useful information; like the charge on the molecule (0, it’s neutral), the spin multiplicity; (1 for a closed-shell molecule with all electrons paired), or the reference; wavefunction to use (restricted Hartree–Fock, or RHF, is usually; appropriate for a closed-shell molecule). The program correctly guessed; all of these options for us. We can change the default behavior through; additional keywords.; Let’s consider what we would do for an open-shell molecule, where; not all electrons are paired. For example, let’s run a computation; on methylene (CH2), whose ground electronic state has two unpaired; electrons (triplet electronic state, or a spin multiplicity ).; In this case, the default spin multiplicity (1) is not correct, so we; need to tell the program the true value (3). Like many programs, PSI4; can get the charge and multiplicity as the first two integers in the; Z-matrix. Note the line with 0 3 at the beginning of the molecule; specification below. In this example we will also specify the bond length; and bond angle as variables ( and ), whose values are given; at the end of the Z-matrix specification.; #! Sample UHF/6-31G** CH2 computation. memory 250 mb. molecule ch2 {; 0 3; C ; H 1 R; H 1 R 2 A. R = 1.075; A = 133.93; }. set basis 6-31G**; set reference uhf; energy ('scf'). This sample input can be found in; tu2-ch2-energy and as; before it can be run through the command psi4 input.dat output.dat; (actually, because psi4 by default looks for an input file named; input.dat and writes by default to a file called output.dat, in this; case one could also just type psi4). If it works, it should print; the final energy as; @UHF Final Energy: -38.92534160932308. Notice we added a new keyword, set reference uhf, to the input. For; open-shell molecules, we have a choice of unrestricted orbitals; (unrestric",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/tutorial-1.html:2750,charge,charge,2750,psi4manual/4.0b3/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/tutorial-1.html,2,['charge'],['charge']
Energy Efficiency," Second Order GGA Exchange-Correlation Functional. sogga_x; Second Order GGA Exchange Hole (Parameter Free). svwn; SVWN3 (RPA) LSDA Functional. s_x; Slater LSDA Exchange. vwn3rpa_c; VWN3 (RPA) LSDA Correlation. vwn3_c; VWN3 LSDA Correlation. vwn5rpa_c; VWN5 (RPA) LSDA Correlation. vwn5_c; VWN5 LSDA Correlation. dldf; Dispersionless Hybrid Meta-GGA XC Functional. dldf+d; Dispersionless Hybrid Meta-GGA XC Functional w/ Podeszwa and Szalewicz Dispersion Correction. dldf+d09; Dispersionless Hybrid Meta-GGA XC Functional w/ Podeszwa and Szalewicz Dispersion Correction. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite d",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/opt-1.html:6659,energy,energy,6659,psi4manual/4.0b5/opt-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/opt-1.html,2,['energy'],['energy']
Energy Efficiency," See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> energy(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). """"""; kwargs = p4util.kwargs_lower(kwargs). # Bounce to MDI if mdi kwarg; use_mdi = kwargs.pop('mdi', False); if use_mdi:; return mdi_run(name, **kwargs). core.print_out(""\nScratch directory: %s\n"" % core.IOManager.shared_object().get_default_path()). # Bounce to CP if bsse kwarg; if kwargs.get('bsse_type', None) is not None:; return driver_nbody.nbody_gufunc(energy, name, ptype='energy', **kwargs). # Bounce if name is function; if hasattr(name, '__call__'):; return name(energy, kwargs.pop('label', 'custom function'), ptype='energy', **kwargs). # Allow specification of methods to arbitrary order; lowername = name.lower(); lowername, level = driver_util.parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. # Bounce to CBS if ""method/basis"" name; if ""/"" in lowername:; return driver_cbs._cbs_gufunc(energy, name, ptype='energy', **kwargs). _filter_renamed_methods(""energy"", lowername). # Commit to procedures['energy'] call hereafter; return_wfn = kwargs.pop('return_wfn', False); core.clean_variables(). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). #for precallback in hooks['energy']['pre']:; # precallback(lowername, **kwargs). optstash = driver_util._set_convergence_criterion('energy', lowername, 6, 8, 6, 8, 6); optstash2 = p4util.OptionsState(['SCF', 'GUESS']). # Before invoking the procedure, we rename any file that should be read.; # This is a workaround to do restarts with the current PSI4 capabilities; # before actual, clean restarts are put in there; # Restartfile is always converted to a single-element list if; # it contains a single string; # DGAS Note: This is hacked together at this point and should be revamped.; if 'restart_file' in kwargs:; restartfile = kwargs['restart_file'] #",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:34691,energy,energy,34691,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,4,['energy'],['energy']
Energy Efficiency," Set ##; ###################################. [docs]def cbs(func, label, **kwargs):; r""""""Function to define a multistage energy method from combinations of; basis set extrapolations and delta corrections and condense the; components into a minimum number of calculations. :aliases: complete_basis_set(). :returns: (*float*) -- Total electronic energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CBS TOTAL ENERGY <CBSTOTALENERGY>`; * :psivar:`CBS REFERENCE ENERGY <CBSREFERENCEENERGY>`; * :psivar:`CBS CORRELATION ENERGY <CBSCORRELATIONENERGY>`; * :psivar:`CURRENT ENERGY <CURRENTENERGY>`; * :psivar:`CURRENT REFERENCE ENERGY <CURRENTREFERENCEENERGY>`; * :psivar:`CURRENT CORRELATION ENERGY <CURRENTCORRELATIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - No way to tell function to boost fitting basis size for all calculations. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in several; sequential stages (scf, corl, delta1, delta2, ... ) covering treatment; of the reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction, etc.. Each is activated by its; stage_wfn keyword, or as a field in the ```cbs_metadata``` list, and is only; allowed if all preceding stages are active. .. include:: ../cbs_eqn.rst. * Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy. The cbs() function requires, at a minimum, ``name='scf'`` and ``scf_basis``; keywords to be specified for reference-step only jobs and ``name`` and; ``corl_basis`` keywords for correlated jobs. The following energy methods have been set up for cbs(). .. hlist::; :columns: 5. * scf; * hf; * mp2; * mp2.5; * mp3; * mp4(sdq); * mp4; * mp\ *n*; * omp2; * omp2.5; * omp3; * olccd; * lccd; * lccsd; * cepa(0",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html:34575,energy,energy,34575,psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,1,['energy'],['energy']
Energy Efficiency," Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.56) # Hartree-Fock exact exchange; sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_primitive_superfunctional(name, npoints, deriv):. # Call this first; sup = PsiMod.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. key = name.upper(); fun = build_functional(key). # No spaces, keep it short and according to convention; sup.set_name(key); # Tab in, trailing newlines; sup.set_description(fun.description()); # Tab in, trailing newlines; sup.set_citation(fun.citation()). # Add member functionals. if (key[-1] == 'X'):; sup.add_x_functional(fun); else:; sup.add_c_functional(fun). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. # Superfunctional lookup table; superfunctionals = {; 's_x' : build_primitive_superfunctional,; 'b88_x' : build_primitive_superfunctional,; 'b3_x' : build_primitive_superfunctional,; 'pbe_x' : build_primitive_superfunctional,; 'pbesol_x' : build_primitive_superfunctional,; 'pw91_x' : build_primitive_superfunctional,; 'ws_x' : build_ws_x_superfunctional,; 'wpbe_x' : build_wpbe_x_superfunctional,; 'wpbesol_x' : build_wpbesol_x_superfunctional,; 'wb88_x' : build_wb88_x_superfunctional,; 'lyp_c' : build_primitive_superfunctional,; 'ft97b_x' : build_primitive_superfunctional,; 'pz81_c' : build_primitive_superfunctional,; 'p86_c' : build_primitive_superfunctional,; 'pw91_c' : build_primitive_superfunctional,; 'pw92_c' : build_primitive_superfunctional,; 'pbe_c' : build_primitive_superfunctional,; 'ft97_c' : build_primitive_superfunctional,; 'vwn5rpa_c' : build_primitive_superfunctional,; 'vwn5_c' : build_primitive_superfunctional,; 'vwn3rpa_c' : build_primitive_superfunctional,; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/functional.html:55808,allocate,allocate,55808,psi4manual/4.0b2/_modules/functional.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/functional.html,1,['allocate'],['allocate']
Energy Efficiency," Sets the options module up to return options pertaining to the named argument (e.g. print_global_options(); Prints the currently set global (all modules) options to the output file. print_options(); Prints the currently set options (to the output file) for the current module. print_out(arg0); Prints a string (using sprintf-like notation) to the output file. print_variables(); Prints all PSI variables that have been set internally. psi_top_srcdir(); Returns the location of the source code. psimrcc(arg0); Runs the multireference coupled cluster code. reopen_outfile(); Reopens the output file. revoke_global_option_changed(arg0); Given a string of a keyword name arg1, sets the has_changed attribute in the global options scope to false. revoke_local_option_changed(arg0, arg1); Given a string of a keyword name arg2 and a particular module arg1, sets the has_changed attribute in the module options scope to false. run_gdma(arg0, arg1); Runs the GDMA code. sapt(arg0, arg1, arg2); Runs the symmetry adapted perturbation theory code. scalar_variable(arg0); Returns the requested (case-insensitive) double QC variable. scalar_variables(); Returns dictionary of all double QC variables. scatter(arg0, arg1, arg2, arg3, arg4); New Scatter function. scfgrad(arg0); Run scfgrad, which is a specialized DF-SCF gradient program. scfhess(arg0); Run scfhess, which is a specialized DF-SCF hessian program. set_active_molecule(arg0); Activates a previously defined (in the input) molecule, by name. set_array_variable(arg0, arg1); Sets the requested (case-insensitive) Matrix QC variable. set_datadir(arg0); Returns the amount of memory available to Psi (in bytes). set_global_option(*args, **kwargs); Overloaded function. set_global_option_python(key, EXTERN); This is a fairly hacky way to get around EXTERN issues. set_gradient(val). set_legacy_gradient(arg0); Assigns the global gradient to the values in the (nat, 3) Matrix argument. set_legacy_molecule(arg0); Activates a previously defined (in the ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psi4api-1.html:298739,adapt,adapted,298739,psi4manual/1.3.2/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psi4api-1.html,2,['adapt'],['adapted']
Energy Efficiency," Sets the options module up to return options pertaining to the named argument (e.g. print_global_options(); Prints the currently set global (all modules) options to the output file. print_options(); Prints the currently set options (to the output file) for the current module. print_out(arg0); Prints a string (using sprintf-like notation) to the output file. print_variables(); Prints all PSI variables that have been set internally. psi_top_srcdir(); Returns the location of the source code. psimrcc(arg0); Runs the multireference coupled cluster code. reopen_outfile(); Reopens the output file. revoke_global_option_changed(arg0); Given a string of a keyword name arg1, sets the has_changed attribute in the global options scope to false. revoke_local_option_changed(arg0, arg1); Given a string of a keyword name arg2 and a particular module arg1, sets the has_changed attribute in the module options scope to false. run_gdma(arg0, arg1); Runs the GDMA code. sapt(arg0, arg1, arg2); Runs the symmetry adapted perturbation theory code. scatter(arg0, arg1, arg2, arg3, arg4); New Scatter function. scfgrad(arg0); Run scfgrad, which is a specialized DF-SCF gradient program. scfhess(arg0); Run scfhess, which is a specialized DF-SCF hessian program. set_active_molecule(arg0); Activates a previously defined (in the input) molecule, by name. set_array_variable(arg0, arg1); Sets a PSI variable, by name. set_datadir(arg0); Returns the amount of memory available to Psi (in bytes). set_efp_torque(arg0); Assigns the global EFP gradient to the values stored in the Nefp by 6 Matrix argument. set_frequencies(arg0); Assigns the global frequencies to the values stored in the 3N-6 Vector argument. set_global_option(*args, **kwargs); Overloaded function. set_global_option_python(key, EXTERN); This is a fairly hacky way to get around EXTERN issues. set_gradient(arg0); Assigns the global gradient to the values stored in the N by 3 Matrix argument. set_legacy_molecule(arg0); Activates a previously def",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psi4api-1.html:248320,adapt,adapted,248320,psi4manual/1.2.1/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html,2,['adapt'],['adapted']
Energy Efficiency," So that you can give your; files meaningful names, these defaults can be changed by specifying; the input file name and output file name on the the command line.; The syntax is:; >>> psi4 input-name output-name. Running a Basic Hartree–Fock Calculation¶; In our first example, we will consider a Hartree–Fock SCF computation; for the water molecule using a cc-pVDZ basis set. We will specify the; geometry of our water molecule using a standard Z-matrix.; # Any line starting with the # character is a comment line; #! Sample HF/cc-pVDZ H2O computation. memory 250 mb. molecule h2o {; O ; H 1 0.96; H 1 0.96 2 104.5; }. set basis cc-pVDZ; energy('scf'). For your convenience, this example can be found in; tu1-h2o-energy.; You can run it if you wish.; Once PSI4 is in your path (see the User Configuration section of; the installation instructions), you can run this computation by typing; >>> psi4 input.dat output.dat. If everything goes well, the computation should complete and should report; a final restricted Hartree–Fock energy in a section like this:; Energy converged. @RHF Final Energy: -76.02665366589162. By default, the energy should be converged to about , so agreement; is only expected for about the first 8 digits after the decimal. If the; computation does not complete, there is probably a problem with the; compilation or installation of the program (see the installation; instructions in Sec. Obtaining and Installing PSI4).; This very simple input is sufficient to run the requested information.; Notice that we didn’t tell the program some otherwise useful information; like the charge on the molecule (0, it’s neutral), the spin multiplicity; (1 for a closed-shell molecule with all electrons paired), or the reference; wavefunction to use (restricted Hartree–Fock, or RHF, is usually; appropriate for a closed-shell molecule). The program correctly guessed; all of these options for us. We can change the default behavior through; additional keywords.; Let’s consider what ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/tutorial-1.html:1369,energy,energy,1369,psi4manual/4.0b2/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/tutorial-1.html,2,['energy'],['energy']
Energy Efficiency," So that you can give your; files meaningful names, these defaults can be changed by specifying; the input file name and output file name on the the command line.; The syntax is:; >>> psi4 input-name output-name. Running a Basic Hartree–Fock Calculation¶; In our first example, we will consider a Hartree–Fock SCF computation; for the water molecule using a cc-pVDZ basis set. We will specify the; geometry of our water molecule using a standard Z-matrix.; # Any line starting with the # character is a comment line; #! Sample HF/cc-pVDZ H2O computation. memory 250 mb. molecule h2o {; O ; H 1 0.96; H 1 0.96 2 104.5; }. set basis cc-pVDZ; energy('scf'). For your convenience, this example can be found in; tu1-h2o-energy.; You can run it if you wish.; Once PSI4 is in your path (see the User Configuration; section of the installation instructions), you can run this computation by typing; >>> psi4 input.dat output.dat. If everything goes well, the computation should complete and should report; a final restricted Hartree–Fock energy in a section like this:; Energy converged. @RHF Final Energy: -76.02663273410671. By default, the energy should be converged to about , so agreement; is only expected for about the first 6 digits after the decimal. If the; computation does not complete, there is probably a problem with the; compilation or installation of the program (see the installation; instructions in Sec. Compiling and Installing).; This very simple input is sufficient to run the requested information.; Notice that we didn’t tell the program some otherwise useful information; like the charge on the molecule (0, it’s neutral), the spin multiplicity; (1 for a closed-shell molecule with all electrons paired), or the reference; wavefunction to use (restricted Hartree–Fock, or RHF, is usually; appropriate for a closed-shell molecule). The program correctly guessed; all of these options for us. We can change the default behavior through; additional keywords.; Let’s consider what we wo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/tutorial-1.html:1384,energy,energy,1384,psi4manual/4.0b3/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/tutorial-1.html,2,['energy'],['energy']
Energy Efficiency," Specifying keywords that control geometry optimization is; straightforward. Unless the optimization is invoked in sandwich mode,; all Cfour optimization keywords (e.g., CFOUR_GEO_MAXCYC) are; ineffective, as the Cfour optimizer is never invoked. Psi4; optimization keywords (e.g., GEOM_MAXITER) instead fill; these roles. Specifying the computational method (through, for instance,; energy('c4-ccsd') instead of energy('cfour')) often; sets additional keywords consistent with best practices (e.g.,; CFOUR_CC_PROGRAM). Since those settings are implicit, any; explicit setting of those those keywords, whether contradicting or; concurring, takes priority (halts never generated). The following are; some concrete examples. For the moment, click the source button at; qcdb.cfour.muster_modelchem() for details of what keywords; get set. runs in vcc since that’s Cfour’s default for cc_program; set cfour_calc_level ccsd; energy('cfour'). runs in ecc since Cfour’s default overwritten by keyword; set cfour_calc_level ccsd; set cfour_cc_program ecc; energy('cfour'). runs in ecc since that’s best practice for the requested ccsd; energy('c4-ccsd'). runs in vcc since hidden default overwritten by keyword; set cfour_cc_program vcc; energy('c4-ccsd'). Specifying certain keywords that are nominally applicable for pure-Psi4 modules directs them to fulfil analogous roles; in the Cfour program (e.g., MAXITER is used to set; CFOUR_SCF_MAXCYC). This keyword translation only takes place; if the keywords are explicitly set in the input file (part of that; contract that you mean it), meaning that Psi4‘s defaults don’t; get imposed on Cfour. Also, in the case where a translatable pure-Psi4 keyword and its translation Cfour keyword are both set,; the value attached to the latter is always used. Below are a few; clarifying examples. uses SCF conv crit since that’s Cfour’s default; for CFOUR_SCF_CONV; energy('c4-scf'). uses SCF conv crit since default overwritten by; keyword; set cfour_scf_conv 6; ene",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/cfour-1.html:32321,energy,energy,32321,psi4manual/1.0.0/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/cfour-1.html,2,['energy'],['energy']
Energy Efficiency," Start of cp ##; ###################. [docs]def cp(name, **kwargs):; r""""""The cp function computes counterpoise-corrected two-body interaction energies; for complexes composed of arbitrary numbers of monomers. :aliases: counterpoise_correct(), counterpoise_correction(). :returns: (*float*) Counterpoise-corrected interaction energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CP-CORRECTED 2-BODY INTERACTION ENERGY <CP-CORRECTED2-BODYINTERACTIONENERGY>`; * :psivar:`UNCP-CORRECTED 2-BODY INTERACTION ENERGY <UNCP-CORRECTED2-BODYINTERACTIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - No values of func besides energy have been tested. - Table print-out needs improving. Add some PSI variables. :type name: string; :param name: ``'scf'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the molecule. May be any valid argument to; :py:func:`~driver.energy`; however, SAPT is not appropriate. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on the molecule; and each of its monomers. The default performs a single-point; ``energy('name')``, while ``optimize`` perfoms a geometry optimization; on each system, and ``cbs`` performs a compound single-point energy.; If a nested series of python functions is intended; (see :ref:`sec:intercalls`), use keyword ``cp_func`` instead of ``func``. :type check_bsse: :ref:`boolean <op_py_boolean>`; :param check_bsse: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether to additionally compute un-counterpoise corrected; monomers and thus obtain an estimate for the basis set superposition error. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] counterpoise-corrected mp2 interaction energy; >>> cp('df-mp2'). ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html:17216,energy,energy,17216,psi4manual/4.0b3/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html,3,['energy'],['energy']
Energy Efficiency," Start of cp ##; ###################. [docs]def cp(name, **kwargs):; r""""""The cp function computes counterpoise-corrected two-body interaction energies; for complexes composed of arbitrary numbers of monomers. :aliases: counterpoise_correct(), counterpoise_correction(). :returns: (*float*) Counterpoise-corrected interaction energy in kcal/mol. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CP-CORRECTED 2-BODY INTERACTION ENERGY <CP-CORRECTED2-BODYINTERACTIONENERGY>`; * :psivar:`UNCP-CORRECTED 2-BODY INTERACTION ENERGY <UNCP-CORRECTED2-BODYINTERACTIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - No values of func besides energy have been tested. - Table print-out needs improving. Add some PSI variables. :type name: string; :param name: ``'scf'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the molecule. May be any valid argument to; :py:func:`~driver.energy`; however, SAPT is not appropriate. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on the molecule; and each of its monomers. The default performs a single-point; ``energy('name')``, while ``optimize`` perfoms a geometry optimization; on each system, and ``cbs`` performs a compound single-point energy.; If a nested series of python functions is intended; (see :ref:`sec:intercalls`), use keyword ``cp_func`` instead of ``func``. :type check_bsse: :ref:`boolean <op_py_boolean>`; :param check_bsse: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether to additionally compute un-counterpoise corrected; monomers and thus obtain an estimate for the basis set superposition error. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] counterpoise-corrected mp2 interaction energy; >>> cp('dfmp2'). """,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:17209,energy,energy,17209,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,1,['energy'],['energy']
Energy Efficiency," Substitution of the DF factorization into the MP2 equations results in; a formal scaling and prefactor reduction of MP2, and further speed gains are; possible due to heavy utilization of matrix-multiplication kernels and minimal; storage requirements in a DF approach. The method has been found to be quite; robust and accurate, and it should be preferred unless extreme accuracy is required; or a fitting basis is not defined for the primary basis and atom type; encountered. In particular, we have found excellent efficiency and tractability; gains when using DF-MP2 in concert with a DF-SCF reference. An efficient,; threaded, disk-based DF-MP2 code is available in PSI4 for all single; reference types available in the SCF module.; An example utilization of the code is:; molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set basis cc-pvdz; set scf_type df; set freeze_core True. energy('df-mp2'). The energy('df-mp2') call to energy() executes; the predefined DF-MP2 procedure, first calling; the SCF module with a default RHF reference and DF algorithm for the; two-electron integrals. When the orbitals are converged, the DF-MP2 module is; launched, which forms the density-fitted integrals and then builds the; full tensor in blocks, evaluating the contributions to the MP2 energy; as it goes. A RHF-MP2 wavefunction is selected automatically due to the RHF; reference. In this example, we freeze the core, both for efficiency and; because split-valence bases like cc-pVDZ do not contain core correlation; functions. The result looks something like:; ----------------------------------------------------------; ====================> MP2 Energies <====================; ----------------------------------------------------------; Reference Energy = -76.0213974789664633 [H]; Singles Energy = -0.0000000000000001 [H]; Same-Spin Energy = -0.0512503261762665 [H]; Opposite-Spin Energy = -0.1534098129352447 [H]; Correlation Energy = -0.2046601391115113 [H]; Total Energy = -76.226057618077973",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/dfmp2-1.html:1859,energy,energy,1859,psi4manual/4.0b2/dfmp2-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/dfmp2-1.html,16,['energy'],['energy']
Energy Efficiency," Szalewicz Dispersion Correction. name; calls method in Stanton and Gauss’s CFOUR program [manual]. c4-scf; Hartree–Fock (HF). c4-mp2; 2nd-order Moller-Plesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order Moller-Plesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Forced finite difference hf optimization run in; >>> # embarrassingly parallel fashion; >>> optimize('hf', dertype='energy', mode='sow'). gradient(name[, molecule, return_wfn, func, dertype])[source]¶; Function complementary to :py:func:~driver.optimize(). Carries out one gradient pass,; deciding analytic or finite difference. Returns:Matrix – Total electronic gradient in Hartrees/Bohr. Returns:(Matrix, Wavefunction) – gradient and wavefunction when return_wfn specified. Examples:. >>> # [1] Single-point dft gradient getting the gradient; >>> # in file, psi4.Matrix, and np.array forms; >>> set gradient_write on; >>> G, wfn = gradient('b3lyp-d', return_wfn=True); >>> wfn.gradient().print_out(); >>> np.array(G). Previous topic; Counterpoise Correct; Next topic; Harmonic Vibrational Analysis, frequency() and hessian(). This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; Psi4 [1.0.0 6a9a71b] » ; Psithon Functions: Invoking a Calculation ». © C",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/opt-1.html:12371,energy,energy,12371,psi4manual/1.0.0/opt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/opt-1.html,2,['energy'],['energy']
Energy Efficiency," TOTAL ENERGY¶. QCISD(T) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the quadratic configuration interaction singles and doubles with; perturbative triples correction level of theory. SAPT DISP ENERGY¶. SAPT ELST ENERGY¶. SAPT EXCH ENERGY¶. SAPT IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [H] for the the; requested SAPT level of theory. The sum of these four components yields; SAPT TOTAL ENERGY. SAPT TOTAL ENERGY¶; The total electronic interaction energy [H] for the requested SAPT; level of theory. SAPT0 TOTAL ENERGY¶. SSAPT0 TOTAL ENERGY¶. SAPT2 TOTAL ENERGY¶. SAPT2+ TOTAL ENERGY¶. SAPT2+(3) TOTAL ENERGY¶. SAPT2+3 TOTAL ENERGY¶; The total electronic interaction energy [H] for the labeled SAPT level; of theory. SAPT2+(CCD) TOTAL ENERGY¶. SAPT2+(3)(CCD) TOTAL ENERGY¶. SAPT2+3(CCD) TOTAL ENERGY¶; The total electronic interaction energy [H] for the labeled SAPT level; of theory that incorporates coupled-cluster dispersion. SAPT2+DMP2 TOTAL ENERGY¶. SAPT2+(3)DMP2 TOTAL ENERGY¶. SAPT2+3DMP2 TOTAL ENERGY¶. SAPT2+(CCD)DMP2 TOTAL ENERGY¶. SAPT2+(3)(CCD)DMP2 TOTAL ENERGY¶. SAPT2+3(CCD)DMP2 TOTAL ENERGY¶; The total electronic interaction energy [H] for the labeled SAPT level; of theory that incorporates MP2 induction correction. SCF DIPOLE X¶. SCF DIPOLE Y¶. SCF DIPOLE Z¶; The three components of the SCF dipole [Debye]. SCF QUADRUPOLE XX¶. SCF QUADRUPOLE XY¶. SCF QUADRUPOLE XZ¶. SCF QUADRUPOLE YY¶. SCF QUADRUPOLE YZ¶. SCF QUADRUPOLE ZZ¶; The six components of the SCF quadrupole [Debye Ang]. SCF TOTAL ENERGY¶; The total electronic energy [H] of the SCF stage of the calculation.; The CORRELATION ENERGY variables from subsequent stages of a; calculation are often the corresponding TOTAL ENERGY; variables less this quantity. Constructed from Eq. (4),; where this quantity is . (4); Unless the method includes a dispersion correction, this ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/glossary_psivariables-1.html:15115,energy,energy,15115,psi4manual/1.0.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/glossary_psivariables-1.html,2,['energy'],['energy']
Energy Efficiency," TOTAL ENERGY¶. QCISD(T) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the quadratic configuration interaction singles and doubles with; perturbative triples correction level of theory. SAPT DISP ENERGY¶. SAPT ELST ENERGY¶. SAPT EXCH ENERGY¶. SAPT IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [H] for the the; requested SAPT level of theory. The sum of these four components yields; SAPT TOTAL ENERGY. SAPT TOTAL ENERGY¶; The total electronic interaction energy [H] for the requested SAPT; level of theory. SAPT0 TOTAL ENERGY¶. SSAPT0 TOTAL ENERGY¶. SAPT2 TOTAL ENERGY¶. SAPT2+ TOTAL ENERGY¶. SAPT2+(3) TOTAL ENERGY¶. SAPT2+3 TOTAL ENERGY¶; The total electronic interaction energy [H] for the labeled SAPT level; of theory. SAPT2+(CCD) TOTAL ENERGY¶. SAPT2+(3)(CCD) TOTAL ENERGY¶. SAPT2+3(CCD) TOTAL ENERGY¶; The total electronic interaction energy [H] for the labeled SAPT level; of theory that incorporates coupled-cluster dispersion. SAPT2+DMP2 TOTAL ENERGY¶. SAPT2+(3)DMP2 TOTAL ENERGY¶. SAPT2+3DMP2 TOTAL ENERGY¶. SAPT2+(CCD)DMP2 TOTAL ENERGY¶. SAPT2+(3)(CCD)DMP2 TOTAL ENERGY¶. SAPT2+3(CCD)DMP2 TOTAL ENERGY¶; The total electronic interaction energy [H] for the labeled SAPT level; of theory that incorporates MP2 induction correction. SCF DIPOLE X¶. SCF DIPOLE Y¶. SCF DIPOLE Z¶; The three components of the SCF dipole [Debye]. SCF QUADRUPOLE XX¶. SCF QUADRUPOLE XY¶. SCF QUADRUPOLE XZ¶. SCF QUADRUPOLE YY¶. SCF QUADRUPOLE YZ¶. SCF QUADRUPOLE ZZ¶; The six components of the SCF quadrupole [Debye Ang]. SCF TOTAL ENERGY¶; The total electronic energy [H] of the SCF stage of the calculation.; The CORRELATION ENERGY variables from subsequent stages of a; calculation are often the corresponding TOTAL ENERGY; variables less this quantity. Constructed from Eq. (4),; where this quantity is \(E_{\text{SCF}}\). \begin{align*}; E_{\text{SCF}} & = E_{NN} + ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/glossary_psivariables-1.html:16442,energy,energy,16442,psi4manual/1.1.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/glossary_psivariables-1.html,6,['energy'],['energy']
Energy Efficiency," TOTAL ENERGY¶. SCS-OMP2 CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the OMP2-like method formed by reweighting OMP2 DOUBLES ENERGY; by 6/5 opposite-spin and 1/3 same-spin contributions, with; any singles carried along. SCS-MP3 TOTAL ENERGY¶. SCS-MP3 CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the MP3-like method formed by reweighting the difference between; MP3 DOUBLES ENERGY and MP2 DOUBLES ENERGY; by 0.25, atop the SCS-MP2 energy, with any singles carried along. SCS-OMP3 TOTAL ENERGY¶. SCS-OMP3 CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the OMP3-like method formed by reweighting the difference between; OMP3 DOUBLES ENERGY and OMP2 DOUBLES ENERGY; by 0.25, atop the SCS-OMP2 energy, with any singles carried along. SOS-MP2 TOTAL ENERGY¶. SOS-MP2 CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the MP2-like method formed by reweighting MP2 DOUBLES ENERGY; by 1.3 opposite-spin and 0 same-spin contributions, with; any singles carried along. SOS-OMP2 TOTAL ENERGY¶. SOS-OMP2 CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the OMP2-like method formed by reweighting OMP2 DOUBLES ENERGY; by 1.2 opposite-spin and 0 same-spin contributions, with; any singles carried along. SOS-OMP3 TOTAL ENERGY¶. SOS-OMP3 CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the OMP3-like method formed by reweighting the difference between; OMP3 DOUBLES ENERGY and OMP2 DOUBLES ENERGY; by 0.25, atop the SOS-OMP2; energy using non-canonical weighting, with any singles carried along. SOS-PI-MP2 TOTAL ENERGY¶. SOS-PI-MP2 CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the MP2-like method formed by reweighting MP2 DOUBLES ENERGY; by 1.4 oppos",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html:56646,energy,energy,56646,psi4manual/1.7.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html,8,['energy'],['energy']
Energy Efficiency," TOTAL ENERGY¶. SOS-MP2 CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the MP2-like method formed by reweighting MP2 DOUBLES ENERGY; by 1.3 opposite-spin and 0 same-spin contributions, with; any singles carried along. SOS-OMP2 TOTAL ENERGY¶. SOS-OMP2 CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the OMP2-like method formed by reweighting OMP2 DOUBLES ENERGY; by 1.2 opposite-spin and 0 same-spin contributions, with; any singles carried along. SOS-OMP3 TOTAL ENERGY¶. SOS-OMP3 CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the OMP3-like method formed by reweighting the difference between; OMP3 DOUBLES ENERGY and OMP2 DOUBLES ENERGY; by 0.25, atop the SOS-OMP2; energy using non-canonical weighting, with any singles carried along. SOS-PI-MP2 TOTAL ENERGY¶. SOS-PI-MP2 CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the MP2-like method formed by reweighting MP2 DOUBLES ENERGY; by 1.4 opposite-spin and 0 same-spin contributions, with; any singles carried along. TD-fctl ROOT 0 -> ROOT n ELECTRIC TRANSITION DIPOLE MOMENT (VEL)¶; The electric transition dipole moment [e a0] in velocity gauge, for the transition; from the ground state to root m.; DFT functional labeled if canonical. TD-fctl ROOT 0 (IN h) -> ROOT n (IN i) ELECTRIC TRANSITION DIPOLE MOMENT (VEL)¶; The electric transition dipole moment [e a0] in velocity gauge, for the transition; from the ground state, which is of irrep h, to root n within irrep i.; DFT functional labeled if canonical. TD-fctl ROOT 0 (h) -> ROOT n (i) ELECTRIC TRANSITION DIPOLE MOMENT (VEL)¶; The electric transition dipole moment [e a0] in velocity gauge, for the transition; from the ground state, which is of irrep h, to root n, which is of irrep i.; DFT functional labeled if canonical. TD-fctl ROOT 0 -> ROOT n ELECTRIC TRANSITION DIPOLE MOMENT (VEL)",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/glossary_psivariables.html:54460,energy,energy,54460,psi4manual/1.6.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/glossary_psivariables.html,2,['energy'],['energy']
Energy Efficiency," TOTAL ENERGY¶. SOS-MP2 CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the MP2-like method formed by reweighting MP2 DOUBLES ENERGY; by 1.3 opposite-spin and 0 same-spin contributions, with; any singles carried along. SOS-OMP2 TOTAL ENERGY¶. SOS-OMP2 CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the OMP2-like method formed by reweighting OMP2 DOUBLES ENERGY; by 1.2 opposite-spin and 0 same-spin contributions, with; any singles carried along. SOS-OMP3 TOTAL ENERGY¶. SOS-OMP3 CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the OMP3-like method formed by reweighting the difference between; OMP3 DOUBLES ENERGY and OMP2 DOUBLES ENERGY; by 0.25, atop the SOS-OMP2; energy using non-canonical weighting, with any singles carried along. SOS-PI-MP2 TOTAL ENERGY¶. SOS-PI-MP2 CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the MP2-like method formed by reweighting MP2 DOUBLES ENERGY; by 1.4 opposite-spin and 0 same-spin contributions, with; any singles carried along. TDDFT ROOT 0 -> ROOT m EXCITATION ENERGY - h SYMMETRY¶. TD-fctl ROOT 0 -> ROOT m EXCITATION ENERGY - h SYMMETRY¶. ADC ROOT 0 -> ROOT m EXCITATION ENERGY - h SYMMETRY¶. EOM-CCSD ROOT 0 -> ROOT m EXCITATION ENERGY - h SYMMETRY¶; The excitation energy of given method from ground state to root m; in h symmetry (if available). DFT functional labeled if canonical. TDDFT ROOT n TOTAL ENERGY - h SYMMETRY¶. TD-fctl ROOT n TOTAL ENERGY - h SYMMETRY¶. ADC ROOT n TOTAL ENERGY - h SYMMETRY¶. EOM-CCSD ROOT n TOTAL ENERGY - h SYMMETRY¶; The total energy of given method from ground state to root m in h symmetry. ADC ROOT 0 -> ROOT m CORRELATION ENERGY - h SYMMETRY¶. EOM-CCSD ROOT 0 -> ROOT m CORRELATION ENERGY - h SYMMETRY¶; The correlation energy of given method from ground state reference energy to root m in h symmetry. TD-fctl ROOT 0",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html:47285,energy,energy,47285,psi4manual/1.4.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html,8,['energy'],['energy']
Energy Efficiency," TOTAL HESSIAN¶; The total electronic second derivative [Eh/a0/a0] for the Hartree-Fock method, (3 * {nat}, 3 * {nat}). LCCD TOTAL ENERGY¶. LCCD CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the linearized coupled cluster doubles level of theory. LCCSD TOTAL ENERGY¶. LCCSD CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the linearized coupled cluster singles and doubles level of theory. LCC2 (+LMP2) TOTAL ENERGY¶; The total electronic energy [Eh] for the local CC2 level of theory. LCCSD (+LMP2) TOTAL ENERGY¶; The total electronic energy [Eh] for the local CCSD level of theory. LOWDIN CHARGES¶; Property of partial atomic charges [e] by the method of Löwdin, (nat,). MAYER INDICES¶; Property of Mayer bond indices, (nat, nat). MBIS CHARGES¶. MBIS DIPOLES¶. MBIS OCTUPOLES¶. MBIS QUADRUPOLES¶; Per-atom charges [e], dipoles [e a0], quadrupoles [e a0^2], and octupoles [e a0^3]; resulting from partitioning the total electron density through the Minimal Basis; Iterative Stockholder (MBIS) Charge Partitioning Scheme. MBIS FREE ATOM n VOLUME¶; Free-atom volume [a0^3] for atom n, computed using the MBIS charge; partitioning scheme. Free atom densities are computed at the same; level of theory as the parent MBIS calculation, with UHF turned on; as needed. MBIS RADIAL MOMENTS <R^3>¶; Per-atom expectation value of r^3 [a0^3], equivalent to the volume; of the MBIS-partitioned density. MBIS VALENCE WIDTHS¶; Per-atom density width [a0] of the associated valence charge computed; from an MBIS partitioned density. Equivalent to the inverse of the; linear decay rate of the atomic density. MBIS VOLUME RATIOS¶; Per-atom ratio between the atomic volume (<R^3>) and the free-atomic; volume, unitless. MCSCF TOTAL ENERGY¶; Multiconfigurational self-consistent-field energy [Eh] in the course of; a configuration interaction computation. May be single-root or state-averaged. mtd DIPOLE¶; Dipole array",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html:24629,charge,charges,24629,psi4manual/1.4.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html,4,['charge'],['charges']
Energy Efficiency," Test SAD SCF guesses on noble gas atom. scf-response1; Compute the dipole, quadrupole, and traceless quadrupoles for water. cc19; CCSD/cc-pVDZ dipole polarizability at two frequencies. omp3-1; OMP3 cc-pVDZ energy for the H2O molecule. cubeprop-frontier; ROHF frontier orbitals of CH2(s) and CH2(t). cbs-xtpl-wrapper; RHF aug-cc-pVQZ energy for the BH molecule, with Cartesian input. Various gradients for a strained helium dimer and water molecule. x2c1; Test of SFX2C-1e on water uncontracted cc-pVDZ-DK The reference numbers are from Lan Cheng’s implementation in Cfour. cbs-xtpl-nbody; RHF interaction energies using nbody and cbs parts of the driver Ne dimer with mp2/v[dt]z + d:ccsd(t)/vdz. sapt1; SAPT0 cc-pVDZ computation of the ethene-ethyne interaction energy, using the cc-pVDZ-JKFIT RI basis for SCF and cc-pVDZ-RI for SAPT. Monomer geometries are specified using Cartesian coordinates. cisd-h2o-clpse; 6-31G** H2O Test CISD Energy Point with subspace collapse. dfomp3-2; DF-OMP3 cc-pVDZ energy for the H2O+ cation. dft-custom-gga; DFT (LDA/GGA) test of custom implementations in: gga_superfuncs.py. omp2p5-2; OMP2.5 cc-pVDZ energy for the H2O molecule. mbis-6; MBIS calculation on H2O. sapt-exch-ind-inf; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. sapt11; sapt example with orbital freezing with alkali metal and dMP2. dfomp3-grad1; DF-OMP3 cc-pVDZ gradients for the H2O molecule. cbs-xtpl-energy-conv; Extrapolated water energies - conventional integrals version. dfomp2-grad2; OMP2 cc-pVDZ energy for the NO molecule. dlpnomp2-2; comparison of DF-MP2 and DLPNO-MP2 with a CBS extrapolation. ci-multi; BH single points, checking that program can run multiple instances of DETCI in a single input, without an intervening clean() call. dfmp2-fc; Kr–Kr nocp energies with all-electron basis set to check frozen core. olccd1; OLCCD cc-pVDZ energy for the H2O molecule. nbody-he-4b; MP2/aug-cc-pvDZ many body energies of an arbitrary Helium complex, addressing 4-body ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html:14935,energy,energy,14935,psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency," Test if the the guess read in the same basis converges. scf-level-shift-uhf; SCF level shift on a UHF computation. nbody-convergence; Convergence of many-body gradients of different BSSE schemes. omp3-1; OMP3 cc-pVDZ energy for the H2O molecule. dfccsd-grad1; DF-CCSD cc-pVDZ gradients for the H2O molecule. soscf-ref; Triple and Singlet Oxygen energy SOSCF, also tests non-symmetric density matrices. cbs-xtpl-nbody; RHF interaction energies using nbody and cbs parts of the driver Ne dimer with mp2/v[dt]z + d:ccsd(t)/vdz. freq-masses; check nonphysical masses possible. scf-level-shift-cuhf; SCF level shift on a CUHF computation. dft-freq-analytic1; Analytic SVWN frequencies, compared to finite difference values. density-screen-1; RHF Density Matrix based-Integral Screening Test for water. frac-ip-fitting; Omega optimization for LRC functional wB97 on water. mbis-2; MBIS calculation on OH- (Expanded Arrays). sapt-sf1; Tests the Psi4 SF-SAPT code. cc4; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. After the computation, the checkpoint file is renamed, using the PSIO handler. cc50; EOM-CC3(ROHF) on CH radical with user-specified basis and properties for particular root. dfccd1; DF-CCD cc-pVDZ energy for the H2O molecule. cc13d; Tests analytic CC2 gradients. dfomp3-2; DF-OMP3 cc-pVDZ energy for the H2O+ cation. mp2p5-grad2; MP2.5 cc-pVDZ gradient for the NO radical. olccd1; OLCCD cc-pVDZ energy for the H2O molecule. fsapt-ext-abc2; FSAPT with external charge on dimer. pywrap-basis; SAPT calculation on bimolecular complex where monomers are unspecified so driver auto-fragments it. Basis set and auxiliary basis sets are assigned by atom type. ci-property; CI/MCSCF cc-pvDZ properties for Potassium nitrate (rocket fuel!). dfomp2p5-grad2; DF-OMP2.5 cc-pVDZ gradients for the H2O+ cation. cbs-xtpl-energy; Extrapolated water energies - density-fitted version. dforemp-grad2; density fitted OO-REMP/cc-pVDZ engrad single points for the H2O+ molecul",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html:14834,energy,energy,14834,psi4manual/master/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency," The total electronic energy [H] of the reference stage corresponding to; the CURRENT ENERGY variable. db_name DATABASE MEAN ABSOLUTE DEVIATION¶; The mean absolute deviation [kcal mol-1] of the requested method; name from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. db_name DATABASE MEAN SIGNED DEVIATION¶; The mean deviation [kcal mol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. db_name DATABASE ROOT-MEAN-SQUARE SIGNED DEVIATION¶; The rms deviation [kcal mol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. DF-MP2 TOTAL ENERGY¶. DF-MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the density-fitted MP2 level of theory. DFT FUNCTIONAL ENERGY¶; The functional energy contribution [H] to the total SCF energy (DFT only).; Quantity in Eq. (2). DFT FUNCTIONAL TOTAL ENERGY¶; The total electronic energy [H] for the underlying functional; of the requested DFT method, without any dispersion correction,; the first four terms in Eq. (2).; When the requested method includes a dispersion correction, this; quantity is in Eq. (1).; Otherwise, quantity equal to DFT TOTAL ENERGY; and SCF TOTAL ENERGY. DFT TOTAL ENERGY¶; The total electronic energy [H] for the requested DFT method,; in Eq. (2).; When the method includes a dispersion correction, this quantity; is in Eq. (1). DISPERSION CORRECTION ENERGY¶; The dispersion correction [H] appended to an underlying functional; when a DFT-D method is requested. Quantity ; in Eqs. (1) and (2). (1). FCI TOTAL ENERGY¶. FCI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/glossary_psivariables-1.html:5584,energy,energy,5584,psi4manual/4.0b2/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/glossary_psivariables-1.html,4,['energy'],['energy']
Energy Efficiency," The total electronic energy [H] of the reference stage corresponding to; the CURRENT ENERGY variable. db_name DATABASE MEAN ABSOLUTE DEVIATION¶; The mean absolute deviation [kcal mol-1] of the requested method; name from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. db_name DATABASE MEAN SIGNED DEVIATION¶; The mean deviation [kcal mol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. db_name DATABASE ROOT-MEAN-SQUARE SIGNED DEVIATION¶; The rms deviation [kcal mol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. DF-MP2 TOTAL ENERGY¶. DF-MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the density-fitted MP2 level of theory. DFT FUNCTIONAL TOTAL ENERGY¶; The total electronic energy [H] for the underlying functional of the; requested DFT method, without any dispersion correction; the first four; terms in Eq. (3) or (1). Quantity; in Eqs. (3) and (1).; Unless the method includes a dispersion correction, this quantity is; equal to SCF TOTAL ENERGY. DFT TOTAL ENERGY¶; The total electronic energy [H] for the requested DFT method,; in Eq. (1). (1); Unless the method is a DFT double-hybrid, this quantity is equal to; SCF TOTAL ENERGY. If the method is neither a; double-hybrid, nor dispersion corrected, this quantity is equal to; DFT FUNCTIONAL TOTAL ENERGY. DFT XC ENERGY¶; The functional energy contribution [H] to the total SCF energy (DFT only).; Quantity in Eqs. (3) and (1). DISPERSION CORRECTION ENERGY¶; The dispersion correction [H] appended to an underlying functional; when a DFT-D method is requested. Quantity ; in Eqs. (3) and (1). DOU",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:10047,energy,energy,10047,psi4manual/4.0b3/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html,4,['energy'],['energy']
Energy Efficiency," The total electronic energy [H] of the reference stage corresponding to; the CURRENT ENERGY variable. db_name DATABASE MEAN ABSOLUTE DEVIATION¶; The mean absolute deviation [kcal mol-1] of the requested method; name from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. db_name DATABASE MEAN SIGNED DEVIATION¶; The mean deviation [kcal mol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. db_name DATABASE ROOT-MEAN-SQUARE SIGNED DEVIATION¶; The rms deviation [kcal mol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. DFT FUNCTIONAL TOTAL ENERGY¶; The total electronic energy [H] for the underlying functional of the; requested DFT method, without any dispersion correction; the first four; terms in Eq. (4) or (1). Quantity; in Eqs. (4) and (1).; Unless the method includes a dispersion correction, this quantity is; equal to SCF TOTAL ENERGY. DFT TOTAL ENERGY¶; The total electronic energy [H] for the requested DFT method,; in Eq. (1). (1); Unless the method is a DFT double-hybrid, this quantity is equal to; SCF TOTAL ENERGY. If the method is neither a; double-hybrid, nor dispersion corrected, this quantity is equal to; DFT FUNCTIONAL TOTAL ENERGY. DFT XC ENERGY¶; The functional energy contribution [H] to the total SCF energy (DFT only).; Quantity in Eqs. (4) and (1). DISPERSION CORRECTION ENERGY¶; The dispersion correction [H] appended to an underlying functional; when a DFT-D method is requested. Quantity ; in Eqs. (4) and (1). DOUBLE-HYBRID CORRECTION ENERGY¶; The scaled MP2 correlation energy correction [H] appended to an; underlying functional when a DH-DFT method is requested.; Quantity i",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/glossary_psivariables-1.html:10385,energy,energy,10385,psi4manual/1.0.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/glossary_psivariables-1.html,6,['energy'],['energy']
Energy Efficiency," True). # By default, re-guess at each N; continuous_guess = kwargs.get('continuous_guess', False). # By default, drop the files to the molecule's name; root = kwargs.get('filename', molecule.name()); traverse_filename = root + '.traverse.dat'; # => Traverse <= #; occs = []; energies = []; potentials = []; convs = []. # => Run the neutral for its orbitals, if requested <= #. core.set_local_option(""SCF"", ""DF_INTS_IO"", ""SAVE""). old_guess = core.get_local_option(""SCF"", ""GUESS""); if (neutral_guess):; if (hf_guess):; core.set_local_option(""SCF"", ""REFERENCE"", ""UHF""); driver.energy('scf', dft_functional=name, molecule=molecule, **kwargs); core.set_local_option(""SCF"", ""GUESS"", ""READ""); core.set_local_option(""SCF"", ""DF_INTS_IO"", ""LOAD""). # => Run the anion first <= #. molecule.set_molecular_charge(chargem); molecule.set_multiplicity(multm). # => Burn the anion in with hf, if requested <= #; if hf_guess:; core.set_local_option(""SCF"", ""REFERENCE"",""UHF""); driver.energy('scf', dft_functional=name, molecule=molecule, **kwargs); core.set_local_option(""SCF"", ""REFERENCE"", ""UKS""); core.set_local_option(""SCF"", ""GUESS"", ""READ""); core.set_local_option(""SCF"", ""DF_INTS_IO"", ""SAVE""). core.set_local_option(""SCF"", ""FRAC_START"", frac_start); core.set_local_option(""SCF"", ""FRAC_RENORMALIZE"", True); # NYI core.set_local_option(""SCF"", ""FRAC_LOAD"", False). for occ in LUMO_occs:. core.set_local_option(""SCF"", ""FRAC_OCC"", [LUMO]); core.set_local_option(""SCF"", ""FRAC_VAL"", [occ]). E, wfn = driver.energy('scf', dft_functional=name, return_wfn=True, molecule=molecule, **kwargs); C = 1; if E == 0.0:; E = core.variable('SCF ITERATION ENERGY'); C = 0. if LUMO > 0:; eps = wfn.epsilon_a(); potentials.append(eps.get(int(LUMO) - 1)); else:; eps = wfn.epsilon_b(); potentials.append(eps.get(-int(LUMO) - 1)). occs.append(occ); energies.append(E); convs.append(C). core.set_local_option(""SCF"", ""FRAC_START"", 2); #core.set_local_option(""SCF"", ""FRAC_LOAD"", True); core.set_local_option(""SCF"", ""GUESS"", ""READ""); core.set_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/frac.html:5798,energy,energy,5798,psi4manual/1.7.x/_modules/psi4/driver/frac.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/frac.html,4,['energy'],['energy']
Energy Efficiency," True, ""dfcc"": False, ""run_cepa"": False, ""compute_triples"": True, ""run_mp4"": True, ""compute_mp4_triples"": True, },. ""qcisd"": { ""dfcc"": False, ""run_cepa"": False, ""run_ccsd"": False, ""compute_triples"": False, },; ""fno-qcisd"": {""nat_orbs"": True, ""dfcc"": False, ""run_cepa"": False, ""run_ccsd"": False, ""compute_triples"": False, },. ""qcisd(t)"": { ""dfcc"": False, ""run_cepa"": False, ""run_ccsd"": False, ""compute_triples"": True, },; ""fno-qcisd(t)"": {""nat_orbs"": True, ""dfcc"": False, ""run_cepa"": False, ""run_ccsd"": False, ""compute_triples"": True, },. ""ccsd"": { ""dfcc"": False, ""run_cepa"": False, ""run_ccsd"": True, ""compute_triples"": False, },; ""fno-ccsd"": {""nat_orbs"": True, ""dfcc"": False, ""run_cepa"": False, ""run_ccsd"": True, ""compute_triples"": False, },. ""ccsd(t)"": { ""dfcc"": False, ""run_cepa"": False, ""run_ccsd"": True, ""compute_triples"": True, },; ""fno-ccsd(t)"": {""nat_orbs"": True, ""dfcc"": False, ""run_cepa"": False, ""run_ccsd"": True, ""compute_triples"": True, },; }. if name not in director:; raise ValidationError(f""Invalid method {name} for FNOCC energy""). # throw exception for open-shells; if (ref := core.get_option(""SCF"", ""REFERENCE"")) != ""RHF"":; raise ValidationError(f""Invalid reference type {ref} != RHF for FNOCC energy. See Capabilities Table at {dtl}""). # throw exception for DF/CD. most of these pre-trapped by select_* functions but some escape, incl. mp4(sdq) and qcisd variants; if (corl_type := method_algorithm_type(name).now) != ""CONV"":; raise ValidationError(f""Invalid type {corl_type} for FNOCC energy through `run_fnocc`. See Capabilities Table at {dtl}""). for k, v in director[name].items():; core.set_local_option(""FNOCC"", k.upper(), v). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if not core.get_option('FNOCC', 'USE_DF_INTS'):; # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn); else:",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:172828,energy,energy,172828,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,4,['energy'],['energy']
Energy Efficiency," True``; may carry out more computations than ``return_total_data = False``.; For gradients and Hessians, ``return_total_data = False`` is rarely useful. :type levels: dict; :param levels: ``{1: 'ccsd(t)', 2: 'mp2', 'supersystem': 'scf'}`` || ``{1: 2, 2: 'ccsd(t)', 3: 'mp2'}`` || etc. Dictionary of different levels of theory for different levels of expansion; Note that method_string is not used in this case. ``supersystem`` computes; all higher order n-body effects up to the number of fragments. :type embedding_charges: dict; :param embedding_charges: ``{1: [-0.834, 0.417, 0.417], ..}``. Dictionary of atom-centered point charges. keys: 1-based index of fragment, values: list of charges for each fragment.; Add atom-centered point charges for fragments whose basis sets are not included in the computation. """"""; pass. [docs]; class BsseEnum(str, Enum):; """"""Available basis-set superposition error (BSSE) treatments."""""". nocp = ""nocp"" # plain supramolecular interaction energy; cp = ""cp"" # counterpoise correction; vmfc = ""vmfc"" # Valiron-Mayer function counterpoise. def _sum_cluster_ptype_data(; ptype: DriverEnum,; ptype_dict: Dict,; compute_list: Set[FragBasIndex],; fragment_slice_dict: Dict[int, Sequence],; fragment_size_dict: Dict[int, int],; mc_level_lbl: int,; vmfc: bool = False,; nb: int = 0,; ) -> Union[float, np.ndarray]:; """"""; Sum arrays from n-body computations to obtain the BSSE corrected or uncorrected scalar or array. Parameters; ----------; ptype; Hint to shape of array data to sum.; ptype_dict; Dictionary containing computed energy, gradient, or Hessian obtained from each subsystem computation; compute_list; A list of (frag, bas) tuples notating all the required computations.; fragment_slice_dict; Dictionary containing slices that index the gradient or Hessian matrix for each of the 1-indexed fragments.; For He--HOOH--Me cluster, `{1: slice(0, 1, None), 2: slice(1, 5, None), 3: slice(5, 10, None)}`.; fragment_size_dict; Dictionary containing the number of atom",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:11064,energy,energy,11064,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,1,['energy'],['energy']
Energy Efficiency," Type: boolean; Default: false. CC_MAXITER¶. Maximum number of iterations to determine the amplitudes. Type: integer; Default: 50. CHOLESKY¶. Do Cholesky decomposition of the ERI tensor. Type: boolean; Default: false. CHOLESKY_TOLERANCE¶. tolerance for Cholesky decomposition of the ERI tensor. Type: conv double; Default: 1.0e-4. COMPUT_S2¶. Do compute \(\langle \hat{S}^2 \rangle\) for DF-OMP2/DF-MP2?. Type: boolean; Default: false. CUTOFF¶. Cutoff value for numerical procedures. Type: integer; Default: 8. DO_DIIS¶. Do apply DIIS extrapolation?. Type: boolean; Default: true. DO_LEVEL_SHIFT¶. Do apply level shifting?. Type: boolean; Default: true. DO_SCS¶. Do perform spin-component-scaled OMP2 (SCS-OMP2)? In all computation, SCS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SCS-OMP2, one needs to set ‘DO_SCS’ to true. Type: boolean; Default: false. DO_SOS¶. Do perform spin-opposite-scaled OMP2 (SOS-OMP2)? In all computation, SOS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SOS-OMP2, one needs to set ‘DO_SOS’ to true. Type: boolean; Default: false. E3_SCALE¶. CEPA opposite-spin scaling value from SCS-CCSD. Type: double; Default: 0.25. EKT_IP¶. Do compute ionization potentials based on the extended Koopmans’ theorem?. Type: boolean; Default: false. E_CONVERGENCE¶. Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. HESS_TYPE¶. Type of the MO Hessian matrix. Type: string; Possible Values: APPROX_DIAG, APPROX_DIAG_EKT, APPROX_DIAG_HF, HF; Default: HF. INTEGRAL_CUTOFF¶. Cutoff value for DF integrals. Type: integer; Default: 9. LEVEL_SHIFT¶. Level shift to aid convergence. Type: double; Default: 0.02. LINEQ_SOLVER¶. The solver will be used for simultaneous linear equations. Type: string; Possible Values: CDGESV",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__dfocc-1.html:1495,energy,energy,1495,psi4manual/1.3.2/autodir_options_c/module__dfocc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__dfocc-1.html,15,['energy'],['energy']
Energy Efficiency," Type: double; Default: 1.13. DF_BASIS_MP2¶. Auxiliary basis set for MP2 density fitting calculations. Type: string; Possible Values: basis string; Default: No Default. DF_LMP2¶. Do use density fitting? Turned on with specification of fitting basis. Type: boolean; Default: true. DIAG_METHOD¶. Diagonalization method for the CI matrix. Type: string; Possible Values: DAVIDSON, FULL; Default: DAVIDSON. DIIS¶. Do use DIIS extrapolation to accelerate convergence?. Type: boolean; Default: true. DIIS_MAX_VECS¶. Maximum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 5. DIIS_START_ITER¶. Iteration at which to start DIIS extrapolation. Type: integer; Default: 3. DISTANT_PAIR_CUTOFF¶. Distant pair cutoff. Type: double; Default: 8.0. DOMAINS¶. Type: array; Default: No Default. DOMAIN_PRINT¶. Do print the domains?. Type: boolean; Default: false. DOMAIN_PRINT_EXIT¶. Do exit after printing the domains?. Type: boolean; Default: false. E_CONVERGENCE¶. Convergence criterion for energy (change). See Table// Post-SCF Convergence for default convergence// criteria for different calculation types. Type: conv double; Default: 1e-6. FOCK_TOLERANCE¶. Minimum absolute value below which parts of the Fock matrix are skipped. Type: conv double; Default: 1e-2. INTS_TOLERANCE¶. Minimum absolute value below which integrals are neglected. Type: conv double; Default: 1e-7. LOCAL¶. Do simulate the effects of local correlation techniques?. Type: boolean; Default: false. LOCAL_AMPS_PRINT_CUTOFF¶. Cutoff value for printing local amplitudes. Type: double; Default: 0.60. LOCAL_CPHF_CUTOFF¶. Cutoff value for local-coupled-perturbed-Hartree-Fock. Type: double; Default: 0.10. LOCAL_CUTOFF¶. Localization cutoff. Type: double; Default: 0.02. LOCAL_GHOST¶. Type: integer; Default: -1. LOCAL_METHOD¶. Type of local-CIS scheme to be simulated. WERNER selects the method// developed by H.-J. Werner and co-workers, and AOBASIS selects the method// developed by G.E. Scuseria and co-workers",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodir_options_c/module__ccenergy-1.html:2754,energy,energy,2754,psi4manual/4.0b5/autodir_options_c/module__ccenergy-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/module__ccenergy-1.html,2,['energy'],['energy']
Energy Efficiency," Type: double; Default: 6.0. MP2_SS_SCALE¶. Removed in 1.4. Will raise an error in 1.5. Type: double; Default: 1.0. MP2_SOS_SCALE¶. Removed in 1.4. Will raise an error in 1.5. Type: double; Default: 1.3. MP2_SOS_SCALE2¶. Removed in 1.4. Will raise an error in 1.5. Type: double; Default: 1.2. NAT_ORBS¶. Do compute natural orbitals?. Type: boolean; Default: false. OCC_ORBS_PRINT¶. Do print OCC orbital energies?. Type: boolean; Default: false. TPDM_ABCD_TYPE¶. How to take care of the TPDM VVVV-block. The COMPUTE option means it will be computed via an IC/OOC algorithm. The DIRECT option (default) means it will not be computed and stored, instead its contribution will be directly added to Generalized-Fock Matrix. Type: string; Possible Values: DIRECT, COMPUTE; Default: DIRECT. DO_DIIS¶. Do apply DIIS extrapolation?. Type: boolean; Default: true. DO_LEVEL_SHIFT¶. Removed in 1.4. Will raise an error in 1.5. Type: boolean; Default: true. Basic DFOCC Keywords¶. E_CONVERGENCE¶. Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. R_CONVERGENCE¶. Convergence criterion for amplitudes (residuals). Type: conv double; Default: 1e-5. RMS_MOGRAD_CONVERGENCE¶. Convergence criterion for RMS orbital gradient. If this keyword is not set by the user, DFOCC will estimate and use a value required to achieve the desired E_CONVERGENCE The listed default will be used for the default value of E_CONVERGENCE. Type: conv double; Default: 1e-4. MAX_MOGRAD_CONVERGENCE¶. Convergence criterion for maximum orbital gradient. If this keyword is not set by the user, DFOCC will estimate and use a value required to achieve the desired E_CONVERGENCE The listed default will be used for the default value of E_CONVERGENCE. Type: conv double; Default: 1e-4. MO_MAXITER¶. Maximum number of iterations to determine the orbitals. Type: integer; Default: 100. ORB_OPT¶. Do optimize the orbitals?. Type: bool",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/occ.html:16135,energy,energy,16135,psi4manual/1.7.x/occ.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/occ.html,4,['energy'],['energy']
Energy Efficiency," Type: double; Default: 6.0. MP2_SS_SCALE¶. Removed in 1.4. Will raise an error in 1.5. Type: double; Default: 1.0. MP2_SOS_SCALE¶. Removed in 1.4. Will raise an error in 1.5. Type: double; Default: 1.3. MP2_SOS_SCALE2¶. Removed in 1.4. Will raise an error in 1.5. Type: double; Default: 1.2. NAT_ORBS¶. Do compute natural orbitals?. Type: boolean; Default: false. OCC_ORBS_PRINT¶. Do print OCC orbital energies?. Type: boolean; Default: false. TPDM_ABCD_TYPE¶. How to take care of the TPDM VVVV-block. The COMPUTE option means it will be computed via an IC/OOC algorithm. The DIRECT option (default) means it will not be computed and stored, instead its contribution will be directly added to Generalized-Fock Matrix. Type: string; Possible Values: DIRECT, COMPUTE; Default: DIRECT. DO_DIIS¶. Do apply DIIS extrapolation?. Type: boolean; Default: true. DO_LEVEL_SHIFT¶. Removed in 1.4. Will raise an error in 1.5. Type: boolean; Default: true. Basic DFOCC Keywords¶. E_CONVERGENCE¶. Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. R_CONVERGENCE¶. Convergence criterion for amplitudes (residuals). Type: conv double; Default: 1e-5. RMS_MOGRAD_CONVERGENCE¶. Convergence criterion for RMS orbital gradient. If this keyword is not set by the user, DFOCC will estimate and use a value required to achieve the desired E_CONVERGENCE The listed default will be used for the default value of E_CONVERGENCE. Type: conv double; Default: 1e-4. MAX_MOGRAD_CONVERGENCE¶. Convergence criterion for maximum orbital gradient. If this keyword is not set by the user, DFOCC will estimate and use a value required to achieve the desired E_CONVERGENCE The listed default will be used for the default value of E_CONVERGENCE. Type: conv double; Default: 1e-4. MO_MAXITER¶. Maximum number of iterations to determine the orbitals. Type: integer; Default: 50. ORB_OPT¶. Do optimize the orbitals?. Type: boole",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/occ-1.html:14795,energy,energy,14795,psi4manual/1.4.0/occ-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/occ-1.html,5,['energy'],['energy']
Energy Efficiency," Type: integer; Default: 0. DF_METRIC¶. FastDF Fitting Metric. Type: string; Possible Values: COULOMB, EWALD, OVERLAP; Default: COULOMB. DF_THETA¶. FastDF SR Ewald metric range separation parameter. Type: double; Default: 1.0. COSX Algorithm¶. COSX_INTS_TOLERANCE¶. Screening criteria for integrals and intermediates in COSX. Type: conv double; Default: 1.0e-11. COSX_RADIAL_POINTS_FINAL¶. Number of radial points in final COSX grid. Type: integer; Default: 35. COSX_RADIAL_POINTS_INITIAL¶. Number of radial points in initial COSX grid. Type: integer; Default: 25. COSX_SPHERICAL_POINTS_FINAL¶. Number of spherical points in final COSX grid. Type: integer; Default: 110. COSX_SPHERICAL_POINTS_INITIAL¶. Number of spherical points in initial COSX grid. Type: integer; Default: 50. SAD Guess Algorithm¶. SAD_D_CONVERGENCE¶. Convergence criterion for SCF density in the SAD guess, analogous to D_CONVERGENCE. Type: conv double; Default: 1e-5. SAD_E_CONVERGENCE¶. Convergence criterion for SCF energy in the SAD guess, analogous to E_CONVERGENCE. Type: conv double; Default: 1e-5. DFT¶. DFT_ALPHA¶. The DFT Exact-exchange parameter. Type: double; Default: 0.0. DFT_ALPHA_C¶. The DFT Correlation hybrid parameter. Type: double; Default: 0.0. DFT_BASIS_TOLERANCE¶. DFT basis cutoff. Type: conv double; Default: 1.0e-12. DFT_BS_RADIUS_ALPHA¶. Factor for effective BS radius in radial grid. Type: double; Default: 1.0. DFT_DISPERSION_PARAMETERS¶. Parameters defining the dispersion correction. See Table -D Functionals for default values and Table Dispersion Corrections for the order in which parameters are to be specified in this array option. Unused for functionals constructed by user. Type: array; Default: No Default. DFT_GRAC_ALPHA¶. The gradient regularized asymptotic correction alpha value. Type: double; Default: 0.5. DFT_GRAC_BETA¶. The gradient regularized asymptotic correction beta value. Type: double; Default: 40.0. DFT_GRAC_SHIFT¶. The gradient regularized asymptotic correction shift value",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodir_options_c/module__scf.html:12691,energy,energy,12691,psi4manual/1.6.x/autodir_options_c/module__scf.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodir_options_c/module__scf.html,3,['energy'],['energy']
Energy Efficiency," Type: integer; Default: 50. MAX_CCD_DIISVECS¶. Maximum number of vectors used in CCD-DIIS. Type: integer; Default: 10. MIN_CCD_DIISVECS¶. Minimumnumber of vectors used in CCD-DIIS. Type: integer; Default: 4. NAT_ORBS_T2¶. Do use MP2 natural orbital approximations for the block of two-electron integrals in the evaluation of second-order T2 amplitudes? Recommended true for all SAPT computations. Type: boolean; Default: false. NAT_ORBS_T3¶. Do natural orbitals to speed up evaluation of the triples contribution to dispersion by truncating the virtual orbital space? Recommended true for all SAPT computations. Type: boolean; Default: false. NAT_ORBS_V4¶. Do use MP2 natural orbital approximations for the block of two-electron integrals in the evaluation of CCD T2 amplitudes? Recommended true for all SAPT computations. Type: boolean; Default: false. NO_RESPONSE¶. Don’t solve the CPHF equations? Evaluate and instead of their response-including coupterparts. Only turn on this option if the induction energy is not going to be used. Type: boolean; Default: false. OCC_TOLERANCE¶. Minimum occupation (eigenvalues of the MP2 OPDM) below which virtual natural orbitals are discarded for in each of the above three truncations. Type: conv double; Default: 1.0e-6. PRINT¶. The amount of information to print to the output file for the sapt module. For 0, only the header and final results are printed. For 1, (recommended for large calculations) some intermediate quantities are also printed. Type: integer; Default: 1. SAPT_LEVEL¶. The level of theory for SAPT. Type: string; Possible Values: SAPT0, SAPT2, SAPT2+, SAPT2+3; Default: SAPT0. SAPT_MEM_CHECK¶. Do force SAPT2 and higher to die if it thinks there isn’t enough memory? Turning this off is ill-advised. Type: boolean; Default: true. SAPT_MEM_SAFETY¶. Memory safety. Type: double; Default: 0.9. SAPT_OS_SCALE¶. The scale factor used for opposite-spin pairs in SCS computations. SS/OS decomposition performed for and terms. Type: double; Def",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodir_options_c/module__sapt-1.html:3639,energy,energy,3639,psi4manual/4.0b5/autodir_options_c/module__sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/module__sapt-1.html,2,['energy'],['energy']
Energy Efficiency," Type: string; Possible Values: QCHEM, MOLPRO, GAU, GAU_LOOSE, GAU_TIGHT, INTERFRAG_TIGHT, GAU_VERYTIGHT, TURBOMOLE, CFOUR, NWCHEM_LOOSE; Default: QCHEM. FULL_HESS_EVERY¶. Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. INTCOS_GENERATE_EXIT¶. Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. Optimizing Minima¶; First, define the molecule and basis in the input.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 105.0; }. set basis dz. Then the following are examples of various types of calculations that can be completed. Optimize a geometry using default methods (RFO step):; optimize('scf'). Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:. set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:. set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed dur",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/optking-1.html:4391,energy,energy,4391,psi4manual/1.4.0/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/optking-1.html,10,['energy'],['energy']
Energy Efficiency," Type: string; Possible Values: RHF, ROHF, UHF; Default: RHF. RESTART¶. Do restart the coupled-cluster iterations from old and amplitudes? For geometry optimizations, Brueckner calculations, etc. the iterative solution of the CC amplitude equations may benefit considerably by reusing old vectors as initial guesses. Assuming that the MO phases remain the same between updates, the CC codes will, by default, re-use old vectors, unless the user sets RESTART = false. Type: boolean; Default: true. R_CONVERGENCE¶. Convergence criterion for wavefunction (change) in CC amplitude equations. Type: conv double; Default: 1e-7. SCSN_MP2¶. Do SCS-MP2 with parameters optimized for nucleic acids?. Type: boolean; Default: false. SCS_CCSD¶. Do spin-component-scaled CCSD. Type: boolean; Default: false. SCS_MP2¶. Do spin-component-scaled MP2 (SCS-MP2)?. Type: boolean; Default: false. SEMICANONICAL¶. Convert ROHF MOs to semicanonical MOs. Type: boolean; Default: true. SPINADAPT_ENERGIES¶. Do print spin-adapted pair energies?. Type: boolean; Default: false. T2_COUPLED¶. Type: boolean; Default: false. T3_WS_INCORE¶. Do build W intermediates required for cc3 in core memory?. Type: boolean; Default: false. Expert¶. AO_BASIS¶. The algorithm to use for the terms If AO_BASIS is NONE, the MO-basis integrals will be used; if AO_BASIS is DISK, the AO-basis integrals stored on disk will be used; if AO_BASIS is DIRECT, the AO-basis integrals will be computed on the fly as necessary. NB: The DIRECT option is not fully implemented and should only be used by experts. Default is NONE. Note: The developers recommend use of this keyword only as a last resort because it significantly slows the calculation. The current algorithms for handling the MO-basis four-virtual-index integrals have been significantly improved and are preferable to the AO-based approach. Type: string; Possible Values: NONE, DISK, DIRECT; Default: NONE. FORCE_RESTART¶. Do restart the coupled-cluster iterations even if MO phases are scr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodir_options_c/module__ccenergy-1.html:5190,adapt,adapted,5190,psi4manual/4.0b3/autodir_options_c/module__ccenergy-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/module__ccenergy-1.html,6,['adapt'],['adapted']
Energy Efficiency," UHF energy for molecular hydrogen. dft-grad-lr3; wB97X-D test for a large UKS molecule update ref gradient due to new BraggSlater radii. dft-grad1; DF-BP86-D2 cc-pVDZ frozen core gradient of S22 HCN update ref gradient due to new BraggSlater radii. mbis-5; MBIS calculation on ZnO. lccd-grad1; LCCD cc-pVDZ gradient for the H2O molecule. omp2-2; OMP2 cc-pVDZ energy with ROHF initial guess orbitals for the NO radical. dfomp2-grad2; OMP2 cc-pVDZ energy for the NO molecule. ci-property; CI/MCSCF cc-pvDZ properties for Potassium nitrate (rocket fuel!). fd-freq-gradient-large; SCF DZ finite difference frequencies by gradients for C4NH4. pywrap-db2; Database calculation, run in sow/reap mode. psimrcc-pt2; Mk-MRPT2 single point. \(^1A_1\) F2 state described using the Ms = 0 component of the singlet. Uses TCSCF singlet orbitals. x2c-perturb-h; Test SFX2C-1e with a static electric field on He aug-cc-pVTZ. cepa-module; routing check on lccd, lccsd, cepa(0). cc34; RHF-CCSD/cc-pVDZ energy of H2O partitioned into pair energy contributions. mints15; check SP basis Fortran exponent parsing. cc19; CCSD/cc-pVDZ dipole polarizability at two frequencies. opt10; 6-31G MP2 transition-state optimization with initial, computed Hessian. mp2-grad2; MP2 cc-pVDZ gradient for the NO radical. cubeprop-frontier; ROHF frontier orbitals of CH2(s) and CH2(t). sapt6; checks that all SAPT physical components (elst, exch, indc, disp) and total IE are being computed correctly for SAPT2+3(CCD)dMP2/aug-cc-pvdz and all lesser methods thereof. pywrap-alias; Test parsed and exotic calls to energy() like zapt4, mp2.5, and cisd are working. opt2-fd; SCF DZ allene geometry optimzation, with Cartesian input. psimrcc-ccsd_t-3; Mk-MRCCSD(T) single point. \(^1A_1\) CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. fsapt-allterms; This test case shows an example of running and analyzing a standard F-SAPT0/jun-cc-pvdz procedure for HSG-18-dimer from the HSG database. fci-h2o-fzc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html:33393,energy,energy,33393,psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,8,['energy'],['energy']
Energy Efficiency," UHF. DC-06; SIMULTANEOUS, QC, TWOSTEP; Y; Y; UHF. DC-12; SIMULTANEOUS, QC, TWOSTEP; Y; N; UHF. Note that for ODC-06 and ODC-12 REFERENCE = RHF is only available for; ALGORITHM = SIMULTANEOUS. To compute correction,; the THREE_PARTICLE option needs to be set to PERTURBATIVE. Minimal Input¶; Minimal input for the DCFT single-point computation looks like this:; molecule {; H; H 1 1.0; }. set basis cc-pvdz. energy('dcft'). The energy('dcft') call to energy() executes the DCFT; module, which will first call the SCF module and perform the SCF computation; with RHF reference to obtain a guess for the DCFT orbitals. After SCF is; converged, the program will perform the energy computation using the ODC-12; method. By default, simultaneous algorithm will be used for the solution of; the equations. One can also request to perform geometry; optimization following example below:; molecule {; H; H 1 1.0; }. set basis cc-pvdz. optimize('dcft'). The optimize('dcft') call will first perform all of the procedures; described above to obtain the ODC-12 energy. After that, the ODC-12 analytic; gradients code will be executed and geometry optimization will be performed. Recommendations¶; Here is a list of recommendations for the DCFT module:. Generally, the use of the simultaneous algorithm together with the; AO_BASIS = DISK option is recommended (set by default).; In cases when available memory is insufficient, the use of the AO_BASIS = DISK option; is recommended. This will significantly reduce the memory requirements. However, when; used together with the two-step algorithm, this option can significantly; increase the cost of the energy computation.; In cases when the oscillatory convergence is observed before the DIIS; extrapolation is initialized, it is recommended to increase the threshold for; the RMS of the density cumulant or orbital update residual, below which the; DIIS extrapolation starts. This can be done by setting the; DIIS_START_CONVERGENCE option to the value greater th",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/dcft-1.html:13314,energy,energy,13314,psi4manual/1.0.0/dcft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/dcft-1.html,2,['energy'],['energy']
Energy Efficiency," Values: basis string; Default: No Default. DENOMINATOR_ALGORITHM¶. Denominator algorithm for PT methods. Laplace transformations are slightly more efficient. Type: string; Possible Values: LAPLACE, CHOLESKY; Default: LAPLACE. DENOMINATOR_DELTA¶. Maximum error allowed (Max error norm in Delta tensor) in the approximate energy denominators employed for most of the and evaluation. Type: double; Default: 1.0e-6. DF_BASIS_ELST¶. Auxiliary basis set for SAPT Elst10 and Exch10 density fitting computations, may be important if heavier elements are involved. Defaults to BASIS-RI. Type: string; Possible Values: basis string; Default: No Default. DF_BASIS_SAPT¶. Auxiliary basis set for SAPT density fitting computations. Defaults to BASIS-RI. Type: string; Possible Values: basis string; Default: No Default. D_CONVERGENCE¶. Convergence criterion for residual of the CPHF coefficients in the SAPT term. Type: conv double; Default: 1e-8. E_CONVERGENCE¶. Convergence criterion for energy (change) in the SAPT term during solution of the CPHF equations. Type: conv double; Default: 1e-10. FREEZE_CORE¶. The scope of core orbitals to freeze in evaluation of SAPT and terms. Recommended true for all SAPT computations. Type: string; Possible Values: FALSE, TRUE, SMALL, LARGE; Default: FALSE. INTS_TOLERANCE¶. Minimum absolute value below which all three-index DF integrals and those contributing to four-index integrals are neglected. The default is conservative, but there isn’t much to be gained from loosening it, especially for higher-order SAPT. Type: conv double; Default: 1.0e-12. MAXITER¶. Maxmum number of CPHF iterations. Type: integer; Default: 50. NAT_ORBS¶. Do natural orbitals to speed up evaluation of the triples contribution to dispersion by truncating the virtual orbital space? Recommended true for all SAPT computations. Type: boolean; Default: false. NAT_ORBS_T2¶. Do use MP2 natural orbital approximations for the block of two-electron integrals in the evaluation of second-order T2 ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodir_options_c/module__sapt-1.html:1739,energy,energy,1739,psi4manual/4.0b2/autodir_options_c/module__sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodir_options_c/module__sapt-1.html,2,['energy'],['energy']
Energy Efficiency," When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. qcdb.Molecule.run_dftd4(self, func=None, dashlvl=None, dashparam=None, dertype=None, verbose=1)¶; Compute dispersion correction via Grimme’s DFTD4 program. Parameters:. func (Optional[str]) – Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Unlike run_dftd3, func overwrites any; parameter initialized via dashparam.; dashlvl (Optional[str]) – Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or “alias” or; “formal” to run.; dashparam (Optional[Dict]) – Values for the same keys as dashcoeff[dashlvl][‘default’]; used to provide custom values. Unlike run_dftd3, will not have; effect if func given. Must provide all parameters.; Extra parameters will error.; dertype (Union[int, str, None]) – Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int) – Amount of printing. Returns:. energy (float) – When dertype=0, energy [Eh].; gradient (ndarray) – When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray) – When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; This function wraps the QCEngine dftd4 harness which wraps the internal DFTD4 Python API.; As such, the upstream convention of func trumping dashparam holds, rather than the; run_dftd3() behavior of dashparam extending or overriding func. class psi4.driver.procrouting.empirical_dispersion.EmpiricalDispersion(*, name_hint=None, level_hint=None, param_tweaks=None, engine=None, gcp_engine=None, save_pairwise_disp=False)[source]¶; Lightweight unification of empirical dispersion calculation modes. dashlevel¶; {“d1”, “d2”, “chg”, “das2009”, “das2010”, “nl”, “dmp2”, “d3zero2b”, “d3bj2b”, “d3mzero2b”, “d3mbj2b”, “d3zeroatm”, “d3bjatm”, “",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/dftd3.html:15649,energy,energy-only,15649,psi4manual/1.7.x/dftd3.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/dftd3.html,8,"['efficient', 'energy']","['efficient', 'energy-only']"
Energy Efficiency," You can run it if you wish.; Once PSI4 is in your path (see the; User Configuration; section of the installation instructions), you can run this computation by typing; >>> psi4 input.dat output.dat. If everything goes well, the computation should complete and should report; a final restricted Hartree–Fock energy in a section like this:; 1; 2; 3Energy converged. @RHF Final Energy: -76.02663273410671. By default, the energy should be converged to about \(1.0 \times 10^{-6}\), so agreement; is only expected for about the first 6 digits after the decimal. If the; computation does not complete, there is probably a problem with the; compilation or installation of the program (see the installation; instructions in Sec. Compiling and Installing from Source).; This very simple input is sufficient to run the requested information.; Notice that we didn’t tell the program some otherwise useful information; like the charge on the molecule (0, it’s neutral), the spin multiplicity; (1 for a closed-shell molecule with all electrons paired), or the reference; wavefunction to use (restricted Hartree–Fock, or RHF, is usually; appropriate for a closed-shell molecule). The program correctly guessed; all of these options for us. We can change the default behavior through; additional keywords.; Let’s consider what we would do for an open-shell molecule, where; not all electrons are paired. For example, let’s run a computation; on methylene (CH2), whose ground electronic state has two unpaired; electrons (triplet electronic state, or a spin multiplicity \(2S+1 = 3\)).; In this case, the default spin multiplicity (1) is not correct, so we; need to tell the program the true value (3). Like many programs, PSI4; can get the charge and multiplicity as the first two integers in the; Z-matrix. Note the line with 0 3 at the beginning of the molecule; specification below. In this example we will also specify the bond length; and bond angle as variables (\(R\) and \(A\)), whose values are given; at",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/tutorial-1.html:3370,charge,charge,3370,psi4manual/1.3.2/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/tutorial-1.html,2,['charge'],['charge']
Energy Efficiency," ZMAT passed to Cfour, but when questions; arise, here are the specifics, the governing laws. Specifying a piece of input in PSI4 format is entering into; a contract that you mean it. In particular this applies to; molecule (including charge/multiplicity through molecule; optional_molecule_name {...}), memory (through memory; value unit), computational method (through . If Cfour keywords; are specified with values that contradict the PSI4 input,; execution is halted.; As an example, the input below is set up to fail in four ways:; contradictory specification of memory, multiplicity, computational; method, and derivative level. Note, though, that the cfour_units; angstrom setting is permissible, since it concurs with the value; implied in the molecule block.; memory 300 mb. molecule {; H; H 1 0.7; }. set basis 6-31g; set cfour_multiplicity 3 # clash with implicit singlet in molecule {} above; set cfour_units angstrom # no problem, consistent with molecule {} above; set cfour_memory_size 100000000 # clash with 300 mb above; set cfour_calc_level ccsd # clash with 'c4-scf' below; set cfour_deriv_level first # clash with energy() below (use gradient('c4-scf') to achieve this). energy('c4-scf'). Specifying anything in PSI4 format (molecule, basis, options,; method call) starts building a *CFOUR(...) directive for the; ZMAT file. Since the contents of the cfour {...} block are; blindly appended to any input interpreted from PSI4 format, mixing; of PSI4 and Cfour input formats likely will give rise to multiple; *CFOUR(...) directives in the prospective ZMAT, execution of; which will be trapped and halted. Proper uses for the cfour {...}; block are for the sandwich mode, where the entire ZMAT is enclosed,; or for extra directives like %excite*, which presently have no other; specification route.; Specifying the basis is perhaps the regulated piece of input. Since; basis set names differ between PSI4 and Cfour and it’s not; practical to compare exponent-to-exponent, any input",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/cfour-1.html:30151,energy,energy,30151,psi4manual/1.4.0/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/cfour-1.html,9,['energy'],['energy']
Energy Efficiency," ZMAT passed to Cfour, but when questions; arise, here are the specifics, the governing laws. Specifying a piece of input in Psi4 format is entering into; a contract that you mean it. In particular this applies to; molecule (including charge/multiplicity through molecule; optional_molecule_name {...}), memory (through memory; value unit), computational method (through . If Cfour keywords; are specified with values that contradict the Psi4 input,; execution is halted.; As an example, the input below is set up to fail in four ways:; contradictory specification of memory, multiplicity, computational; method, and derivative level. Note, though, that the cfour_units; angstrom setting is permissible, since it concurs with the value; implied in the molecule block.; memory 300 mb. molecule {; H; H 1 0.7; }. set basis 6-31g; set cfour_multiplicity 3 # clash with implicit singlet in molecule {} above; set cfour_units angstrom # no problem, consistent with molecule {} above; set cfour_memory_size 100000000 # clash with 300 mb above; set cfour_calc_level ccsd # clash with 'c4-scf' below; set cfour_deriv_level first # clash with energy() below (use gradient('c4-scf') to achieve this). energy('c4-scf'). Specifying anything in Psi4 format (molecule, basis, options,; method call) starts building a *CFOUR(...) directive for the; ZMAT file. Since the contents of the cfour {...} block are; blindly appended to any input interpreted from Psi4 format, mixing; of Psi4 and Cfour input formats likely will give rise to multiple; *CFOUR(...) directives in the prospective ZMAT, execution of; which will be trapped and halted. Proper uses for the cfour {...}; block are for the sandwich mode, where the entire ZMAT is enclosed,; or for extra directives like %excite*, which presently have no other; specification route. Specifying the basis is perhaps the regulated piece of input. Since; basis set names differ between Psi4 and Cfour and it’s not; practical to compare exponent-to-exponent, any input ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/cfour-1.html:30176,energy,energy,30176,psi4manual/1.0.0/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/cfour-1.html,2,['energy'],['energy']
Energy Efficiency," Zeta number of the larger basis set in 2-point extrapolation.; Must be zLO + 1.; valueHI (Union[float, Matrix, Vector]) – Energy, gradient, or Hessian value at the larger basis set in 2-point; extrapolation.; verbose (int) – Controls volume of printing.; alpha (Optional[float]) – Fitted 2-point parameter. Overrides the default \(\alpha = 1.63\). Returns; Eponymous function applied to input zetas and values; type from valueLO. Return type; float or ndarray. Notes; The extrapolation is calculated according to 1:; \(E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}, \alpha = 1.63\); References. 1; Halkier, Helgaker, Jorgensen, Klopper, & Olsen, Chem. Phys. Lett. 302 (1999) 437-446,; DOI: 10.1016/S0009-2614(99)00179-7. Examples; >>> # [1] Hartree-Fock extrapolation; >>> psi4.energy('cbs', scf_wfn='hf', scf_basis='cc-pV[DT]Z', scf_scheme='scf_xtpl_helgaker_2'). psi4.driver.driver_cbs_helper.scf_xtpl_truhlar_2(functionname, zLO, valueLO, zHI, valueHI, verbose=1, alpha=None)[source]¶; Extrapolation scheme using power form for reference energies with two adjacent; zeta-level bases. Used by cbs(). Parameters. functionname (str) – Name of the CBS component (e.g., ‘HF’) used in summary printing.; zLO (int) – Zeta number of the smaller basis set in 2-point extrapolation.; valueLO (Union[float, Matrix, Vector]) – Energy, gradient, or Hessian value at the smaller basis set in 2-point; extrapolation.; zHI (int) – Zeta number of the larger basis set in 2-point extrapolation; Must be zLO + 1.; valueHI (Union[float, Matrix, Vector]) – Energy, gradient, or Hessian value at the larger basis set in 2-point; extrapolation.; verbose (int) – Controls volume of printing.; alpha (Optional[float]) – Overrides the default \(\alpha = 3.4\). Returns; Eponymous function applied to input zetas and values; type from valueLO. Return type; float or ndarray. Notes; The extrapolation is calculated according to 2:; \(E_{total}^X = E_{total}^{\infty} + \beta X^{-\alpha}, \alpha = 3.4\); References. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/cbs.html:23698,power,power,23698,psi4manual/1.6.x/cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/cbs.html,1,['power'],['power']
Energy Efficiency," Zeta number of the medium basis set in 3-point extrapolation.; Must be zLO + 1.; valueMD (Union[float, Matrix, Vector]) – Energy, gradient, or Hessian value at the medium basis set in 3-point; extrapolation.; zHI (int) – Zeta number of the larger basis set in 3-point extrapolation.; Must be zLO + 2.; valueHI (Union[float, Matrix, Vector]) – Energy, gradient, or Hessian value at the larger basis set in 3-point; extrapolation.; verbose (int) – Controls volume of printing.; alpha (Optional[float]) – Not used. Returns:; Eponymous function applied to input zetas and values; type from valueLO. Return type:; float or ndarray. Notes; The extrapolation is calculated according to [4]:; \(E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}, \alpha = 3.0\); References. [4]; Halkier, Helgaker, Jorgensen, Klopper, & Olsen, Chem. Phys. Lett. 302 (1999) 437-446,; DOI: 10.1016/S0009-2614(99)00179-7. Examples; >>> # [1] Hartree-Fock extrapolation; >>> psi4.energy('cbs', scf_wfn='hf', scf_basis='cc-pV[DTQ]Z', scf_scheme='scf_xtpl_helgaker_3'). psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2(functionname, zLO, valueLO, zHI, valueHI, verbose=1, alpha=None)[source]¶; Extrapolation scheme for correlation energies with two adjacent zeta-level bases.; Used by cbs(). Parameters:. functionname (str) – Name of the CBS component (e.g., ‘MP2’) used in summary printing.; zLO (int) – Zeta number of the smaller basis set in 2-point extrapolation.; valueLO (Union[float, Matrix, Vector]) – Energy, gradient, or Hessian value at the smaller basis set in 2-point; extrapolation.; zHI (int) – Zeta number of the larger basis set in 2-point extrapolation.; Must be zLO + 1.; valueHI (Union[float, Matrix, Vector]) – Energy, gradient, or Hessian value at the larger basis set in 2-point; extrapolation.; verbose (int) – Controls volume of printing.; alpha (Optional[float]) – Overrides the default \(\alpha = 3.0\). Returns:; Eponymous function applied to input zetas and values; type from valueLO. Return typ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/cbs.html:27545,energy,energy,27545,psi4manual/1.7.x/cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/cbs.html,4,['energy'],['energy']
Energy Efficiency, Z¶; The three components of the dipole [Debye] for the; averaged coupled-pair functional level of theory. ACPF QUADRUPOLE XX¶. ACPF QUADRUPOLE XY¶. ACPF QUADRUPOLE XZ¶. ACPF QUADRUPOLE YY¶. ACPF QUADRUPOLE YZ¶. ACPF QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; averaged coupled-pair functional level of theory. ACPF TOTAL ENERGY¶. ACPF CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the averaged coupled-pair functional level of theory. AQCC DIPOLE X¶. AQCC DIPOLE Y¶. AQCC DIPOLE Z¶; The three components of the dipole [Debye] for the; averaged quadratic coupled-cluster level of theory. AQCC QUADRUPOLE XX¶. AQCC QUADRUPOLE XY¶. AQCC QUADRUPOLE XZ¶. AQCC QUADRUPOLE YY¶. AQCC QUADRUPOLE YZ¶. AQCC QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; averaged quadratic coupled-cluster level of theory. AQCC TOTAL ENERGY¶. AQCC CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the averaged quadratic coupled-cluster level of theory. BRUECKNER CONVERGED¶; Value 1 (0) when the Brueckner orbitals have (have not) converged. CBS TOTAL ENERGY¶. CBS CORRELATION ENERGY¶. CBS REFERENCE ENERGY¶; The total electronic energy [H] and its breakdown into reference total; energy [H] and correlation correction components [H] for the compound; method requested through cbs(). CC ROOT n DIPOLE X¶. CC ROOT n DIPOLE Y¶. CC ROOT n DIPOLE Z¶; The three components of the dipole [Debye] for the requested; coupled cluster level of theory and root n (number starts at GS = 0). CC ROOT n QUADRUPOLE XX¶. CC ROOT n QUADRUPOLE XY¶. CC ROOT n QUADRUPOLE XZ¶. CC ROOT n QUADRUPOLE YY¶. CC ROOT n QUADRUPOLE YZ¶. CC ROOT n QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; coupled cluster level of theory and root n (numbering starts at GS = 0). CC ROOT n TOTAL ENERGY¶. CC ROOT n CORRELATION ENERGY¶; The total electronic energy [H] and correl,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/glossary_psivariables-1.html:1795,energy,energy,1795,psi4manual/1.1.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/glossary_psivariables-1.html,12,['energy'],['energy']
Energy Efficiency," Z¶; The three components of the dipole [Debye] for the; averaged coupled-pair functional level of theory. ACPF QUADRUPOLE XX¶. ACPF QUADRUPOLE XY¶. ACPF QUADRUPOLE XZ¶. ACPF QUADRUPOLE YY¶. ACPF QUADRUPOLE YZ¶. ACPF QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; averaged coupled-pair functional level of theory. ACPF TOTAL ENERGY¶. ACPF CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the averaged coupled-pair functional level of theory. AQCC DIPOLE X¶. AQCC DIPOLE Y¶. AQCC DIPOLE Z¶; The three components of the dipole [Debye] for the; averaged quadratic coupled-cluster level of theory. AQCC QUADRUPOLE XX¶. AQCC QUADRUPOLE XY¶. AQCC QUADRUPOLE XZ¶. AQCC QUADRUPOLE YY¶. AQCC QUADRUPOLE YZ¶. AQCC QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; averaged quadratic coupled-cluster level of theory. AQCC TOTAL ENERGY¶. AQCC CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the averaged quadratic coupled-cluster level of theory. BRUECKNER CONVERGED¶; Value 1 (0) when the Brueckner orbitals have (have not) converged. CBS TOTAL ENERGY¶. CBS CORRELATION ENERGY¶. CBS REFERENCE ENERGY¶; The total electronic energy [H] and its breakdown into reference total; energy [H] and correlation correction components [H] for the compound; method requested through cbs(). CC ROOT n TOTAL ENERGY¶; The total electronic energy [H]; for the requested coupled cluster level of theory and root; n (numbering starts at GS = 0). CC TOTAL ENERGY¶. CC CORRELATION ENERGY¶. CC2 TOTAL ENERGY¶. CC2 CORRELATION ENERGY¶. CC3 TOTAL ENERGY¶. CC3 CORRELATION ENERGY¶. CC4 TOTAL ENERGY¶. CC4 CORRELATION ENERGY¶. CCnn TOTAL ENERGY¶. CCnn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested approximate coupled-cluster (CC2, CC3, up to CCnn); level of theory. CC DIPOLE X¶. CC DIPOLE Y¶. CC DIPOLE Z¶; The three components ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/glossary_psivariables-1.html:1847,energy,energy,1847,psi4manual/1.0.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/glossary_psivariables-1.html,16,['energy'],['energy']
Energy Efficiency," ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['DETCI']:; func = run_detci. if func is None:; raise ManagedMethodError(['select_mp3', name, 'MP_TYPE', mtd_type, reference, module]). return func(name, **kwargs). Naturally, in the run function, you must either use the type keyword for; type switching or translate it into whatever DO_CD-like keywords your; module uses. At run time with a closed-shell molecule,; energy('mp3'). will run OCC, while; set qc_module fnocc; energy('mp3'). will run FNOCC mp3.; A special case is DETCI that can run mp3, but oughtn’t to be used for such. So above, ROHF CONV mp3 has no default, but can still access the detci code with; set reference rohf; set qc_module detci; energy('mp3'). While the below gives an error; set reference rohf; energy('mp3'). Again, whenever a single method name needs to call multiple proc.py run; functions, it should be managed. In Capabilities of , including details of overlapping modules. “✓” runs analytically. “∷” runs derivative with internal finite difference. Single underline “✓̲” or “∷̲” is default module when QC_MODULE unspecified. Double underline “✓̳” or “∷̳” is default algorithm type when type selector (e.g., CC_TYPE) unspecified. “Y” means method available in; module, “D” means module is default for that method, “” mean method not; available. table of contents. Adding Methods to Driver; proc.py; Managed Methods. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Adding New Code to PSI4; Adding Methods to Driver. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/proc_py.html:7709,energy,energy,7709,psi4manual/master/proc_py.html,https://psicode.org,https://psicode.org/psi4manual/master/proc_py.html,1,['energy'],['energy']
Energy Efficiency," ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['DETCI']:; func = run_detci. if func is None:; raise ManagedMethodError(['select_mp3', name, 'MP_TYPE', mtd_type, reference, module]). return func(name, **kwargs). Naturally, in the run function, you must either use the type keyword for; type switching or translate it into whatever DO_CD-like keywords your; module uses. At run time with a closed-shell molecule,; energy('mp3'). will run OCC, while; set qc_module fnocc; energy('mp3'). will run FNOCC mp3.; A special case is DETCI that can run mp3, but oughtn’t to be used for such. So above, ROHF CONV mp3 has no default, but can still access the detci code with; set reference rohf; set qc_module detci; energy('mp3'). While the below gives an error; set reference rohf; energy('mp3'). Again, whenever a single method name needs to call multiple proc.py run; functions, it should be managed. In Capabilities of , including details of overlapping modules. “✓” runs analytically. “∷” runs derivative with internal finite difference. Single underline “✓̲” or “∷̲” is default module when QC_MODULE unspecified. Double underline “✓̳” or “∷̳” is default algorithm type when type selector (e.g., CC_TYPE) unspecified. “Y” means method available in; module, “D” means module is default for that method, “” mean method not; available. table of contents. Adding Methods to Driver; proc.py; Managed Methods. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Adding New Code to PSI4; Adding Methods to Driver. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Creat",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/proc_py.html:7700,energy,energy,7700,psi4manual/1.7.x/proc_py.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/proc_py.html,1,['energy'],['energy']
Energy Efficiency," ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['DETCI']:; func = run_detci. if func is None:; raise ManagedMethodError(['select_mp3', name, 'MP_TYPE', mtd_type, reference, module]). return func(name, **kwargs). Naturally, in the run function, you must either use the type keyword for; type switching or translate it into whatever DO_CD-like keywords your; module uses. At run time with a closed-shell molecule,; energy('mp3'). will run OCC, while; set qc_module fnocc; energy('mp3'). will run FNOCC mp3.; A special case is DETCI that can run mp3, but oughtn’t to be used for such. So above, ROHF CONV mp3 has no default, but can still access the detci code with; set reference rohf; set qc_module detci; energy('mp3'). While the below gives an error; set reference rohf; energy('mp3'). Again, whenever a single method name needs to call multiple proc.py run; functions, it should be managed. In Capabilities of , including details of overlapping modules. “✓” runs analytically. “∷” runs derivative with internal finite difference. Single underline “✓̲” or “∷̲” is default module when QC_MODULE unspecified. Double underline “✓̳” or “∷̳” is default algorithm type when type selector (e.g., CC_TYPE) unspecified. “Y” means method available in; module, “D” means module is default for that method, “” mean method not; available. table of contents. Adding Methods to Driver; proc.py; Managed Methods. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Adding New Code to PSI4; Adding Methods to Driver. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Cr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/proc_py.html:7702,energy,energy,7702,psi4manual/1.8.x/proc_py.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/proc_py.html,1,['energy'],['energy']
Energy Efficiency," ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['DETCI']:; func = run_detci. if func is None:; raise ManagedMethodError(['select_mp3', name, 'MP_TYPE', mtd_type, reference, module]). return func(name, **kwargs). Naturally, in the run function, you must either use the type keyword for; type switching or translate it into whatever DO_CD-like keywords your; module uses. At run time with a closed-shell molecule,; energy('mp3'). will run OCC, while; set qc_module fnocc; energy('mp3'). will run FNOCC mp3.; A special case is DETCI that can run mp3, but oughtn’t to be used for such. So above, ROHF CONV mp3 has no default, but can still access the detci code with; set reference rohf; set qc_module detci; energy('mp3'). While the below gives an error; set reference rohf; energy('mp3'). Again, whenever a single method name needs to call multiple proc.py run; functions, it should be managed. In Capabilities of , including details of overlapping modules. “✓” runs analytically. “∷” runs derivative with internal finite difference. Single underline “✓̲” or “∷̲” is default module when QC_MODULE unspecified. Double underline “✓̳” or “∷̳” is default algorithm type when type selector (e.g., CC_TYPE) unspecified. “Y” means method available in; module, “D” means module is default for that method, “” mean method not; available. table of contents. Adding Methods to Driver; proc.py; Managed Methods. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Adding New Code to PSI4; Adding Methods to Driver. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Cr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/proc_py.html:7702,energy,energy,7702,psi4manual/1.9.x/proc_py.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/proc_py.html,1,['energy'],['energy']
Energy Efficiency," [1] Moments with specific label; >>> E, wfn = energy('hf', return_wfn=True); >>> oeprop(wfn, 'DIPOLE', 'QUADRUPOLE', title='H3O+ SCF'). PSI4 is capable of computing a number of one-electron properties; summarized in the table below. Current one-electron property capabilities of PSI4¶. Feature; Keyword; Notes. Electric dipole moment; DIPOLE. Electric quadrupole moment; QUADRUPOLE; Raw (traced) moments and traceless multipoles. All moments up order N; MULTIPOLE(N); Only raw (traced) moments. Sets global variables e.g. “DIPOLE”, “32-POLE”. Electrostatic potential, at nuclei; ESP_AT_NUCLEI; Sets global variables “ESP AT CENTER n”, n = 1 to natoms. Electrostatic potential, on grid; GRID_ESP; Generates V at each point in grid_esp.dat. See Properties evaluated on a grid. Electric field, on grid; GRID_FIELD; Generates {Ex,Ey,Ez} at each point grid_field.dat. See Properties evaluated on a grid. Molecular orbital extents; MO_EXTENTS. Mulliken atomic charges; MULLIKEN_CHARGES. Löwdin atomic charges; LOWDIN_CHARGES. Wiberg bond indices; WIBERG_LOWDIN_INDICES; Uses (Löwdin) symmetrically orthogonalized orbitals. Mayer bond indices; MAYER_INDICES. Natural orbital occupations; NO_OCCUPATIONS. Stockholder Atomic Multipoles; MBIS_CHARGES; Generates atomic charges, dipoles, etc. See Minimal Basis Iterative Stockholder. Free-atom volumes; MBIS_VOLUME_RATIOS. There are two ways the computation of one-electron properties can be requested.; Firstly, the properties can be evaluated from the last; computed one-particle density, using the following syntax:; oeprop(""MO_EXTENTS"", ""MULTIPOLE(4)"", title = ""hello!""). Note that it is the user’s responsibility to ensure that the relaxed density; matrix is computed using the method of interest, which may require setting; additional keywords (see the method’s manual section for details). The named; argument, title, is completely optional and is prepended to any; globals variables set during the computation. The unnamed arguments are the; properties ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/oeprop.html:1725,charge,charges,1725,psi4manual/1.7.x/oeprop.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/oeprop.html,2,['charge'],['charges']
Energy Efficiency," [1] Moments with specific label; >>> E, wfn = energy('hf', return_wfn=True); >>> oeprop(wfn, 'DIPOLE', 'QUADRUPOLE', title='H3O+ SCF'). PSI4 is capable of computing a number of one-electron properties; summarized in the table below. Current one-electron property capabilities of PSI4¶. Feature; Keyword; Notes. Electric dipole moment; DIPOLE. Electric quadrupole moment; QUADRUPOLE; Raw (traced) moments and traceless multipoles. All moments up order N; MULTIPOLE(N); Only raw (traced) moments. Sets global variables e.g. “DIPOLE”, “32-POLE”. Electrostatic potential, at nuclei; ESP_AT_NUCLEI; Sets global variables “ESP AT CENTER n”, n = 1 to natoms. Electrostatic potential, on grid; GRID_ESP; Generates V at each point in grid_esp.dat. See Properties evaluated on a grid. Electric field, on grid; GRID_FIELD; Generates {Ex,Ey,Ez} at each point grid_field.dat. See Properties evaluated on a grid. Molecular orbital extents; MO_EXTENTS. Mulliken atomic charges; MULLIKEN_CHARGES. Löwdin atomic charges; LOWDIN_CHARGES. Wiberg bond indices; WIBERG_LOWDIN_INDICES; Uses (Löwdin) symmetrically orthogonalized orbitals. Mayer bond indices; MAYER_INDICES. Natural orbital occupations; NO_OCCUPATIONS. Stockholder Atomic Multipoles; MBIS_CHARGES; Generates atomic charges, dipoles, etc. See Minimal Basis Iterative Stockholder. Hirshfeld volume ratios; MBIS_VOLUME_RATIOS; Generate the AIM to free atom volume ratios. There are two ways the computation of one-electron properties can be requested.; Firstly, the properties can be evaluated from the last; computed one-particle density, using the following syntax:; oeprop(""MO_EXTENTS"", ""MULTIPOLE(4)"", title = ""hello!""). Note that it is the user’s responsibility to ensure that the relaxed density; matrix is computed using the method of interest, which may require setting; additional keywords (see the method’s manual section for details). The named; argument, title, is completely optional and is prepended to any; globals variables set during the comp",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/oeprop.html:1727,charge,charges,1727,psi4manual/1.9.x/oeprop.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/oeprop.html,2,['charge'],['charges']
Energy Efficiency," [1] Moments with specific label; >>> E, wfn = energy('hf', return_wfn=True); >>> oeprop(wfn, 'DIPOLE', 'QUADRUPOLE', title='H3O+ SCF'). PSI4 is capable of computing a number of one-electron properties; summarized in the table below. Current one-electron property capabilities of PSI4¶. Feature; Keyword; Notes. Electric dipole moment; DIPOLE. Electric quadrupole moment; QUADRUPOLE; Raw (traced) moments and traceless multipoles. All moments up order N; MULTIPOLE(N); Only raw (traced) moments. Sets global variables e.g. “DIPOLE”, “32-POLE”. Electrostatic potential, at nuclei; ESP_AT_NUCLEI; Sets global variables “ESP AT CENTER n”, n = 1 to natoms. Electrostatic potential, on grid; GRID_ESP; Generates V at each point in grid_esp.dat. See Properties evaluated on a grid. Electric field, on grid; GRID_FIELD; Generates {Ex,Ey,Ez} at each point grid_field.dat. See Properties evaluated on a grid. Molecular orbital extents; MO_EXTENTS. Mulliken atomic charges; MULLIKEN_CHARGES. Löwdin atomic charges; LOWDIN_CHARGES. Wiberg bond indices; WIBERG_LOWDIN_INDICES; Uses (Löwdin) symmetrically orthogonalized orbitals. Mayer bond indices; MAYER_INDICES. Natural orbital occupations; NO_OCCUPATIONS. Stockholder Atomic Multipoles; MBIS_CHARGES; Generates atomic charges, dipoles, etc. See Minimal Basis Iterative Stockholder. There are two ways the computation of one-electron properties can be requested.; Firstly, the properties can be evaluated from the last; computed one-particle density, using the following syntax:; oeprop(""MO_EXTENTS"", ""MULTIPOLE(4)"", title = ""hello!""). Note that it is the user’s responsibility to ensure that the relaxed density; matrix is computed using the method of interest, which may require setting; additional keywords (see the method’s manual section for details). The named; argument, title, is completely optional and is prepended to any; globals variables set during the computation. The unnamed arguments are the; properties to be computed. These can appear in any",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/oeprop.html:1711,charge,charges,1711,psi4manual/1.6.x/oeprop.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/oeprop.html,1,['charge'],['charges']
Energy Efficiency," [Cheng:084114].; X2C calculations require the use of special (alternatively fully uncontracted) basis sets designed for relativistic; calculations. Common choices include the Dunning Douglass–Kroll basis sets; (cc-pVXZ-DK, cc-pCVXZ-DK, cc-pwCVXZ-DK) and Roos’ ANO basis sets. Note; See also Interface to DKH by A. Wolf, M. Reiher, and B. A. Hess for another relativistic Hamiltonian. A First Example¶; The following is a simple input that will perform a Hartree–Fock calculation; using the X2C Hamiltonian.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12molecule {; H; F 1 0.92; }. set {; scf_type pk; basis cc-pvdz; relativistic x2c; }. energy('hf'). This computation yields the following result:; 1; 2; 3; 4; 5; 6; 7; 8@RHF Final Energy: -100.10007984692388. => Energetics <=. Nuclear Repulsion Energy = 5.1767335622934780; One-Electron Energy = -150.7611816259664579; Two-Electron Energy = 45.4843682167491039; Total Energy = -100.1000798469238902. while a non-relativistic calculation yields the following energy:; 1; 2; 3; 4; 5; 6; 7; 8@RHF Final Energy: -100.01928891411315. => Energetics <=. Nuclear Repulsion Energy = 5.1767335622934780; One-Electron Energy = -150.6645256529074572; Two-Electron Energy = 45.4685031765008461; Total Energy = -100.0192889141131474. Basis sets options¶; The X2C module in PSI4 supports different combinations of basis set.; By default, if the input file specifies only BASIS, then the X2C; module will solve the modified Dirac equation in an uncontracted basis and then; recontract the X2C Hamiltonian in the original basis.; Alternatively, the user can use BASIS_RELATIVISTIC to specify a different; basis set to solve the modified Dirac equation.; 1; 2; 3; 4; 5set {; basis cc-pvdz-dk; basis_relativistic cc-pvtz-dk; relativistic x2c; }. It is recommended that when employing the X2C relativistic Hamiltonian, that you use a fully; decontracted basis set. This can be done simply in the input by adding “-decon” to the; name of the primary basis you want to use for t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/relativistic-1.html:1806,energy,energy,1806,psi4manual/1.1.0/relativistic-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/relativistic-1.html,6,['energy'],['energy']
Energy Efficiency," [Eh a0/u] or [(e a0/a0)^2/u]; project_trans (bool) – Idealized translations projected out of final vibrational analysis.; project_rot (bool) – Idealized rotations projected out of final vibrational analysis. Returns:; Returns dictionary of vibration Datum objects (fields: label units data comment).; Also returns text suitable for printing. Return type:; dict, str. Notes. key; description (label & comment); units; data (real/imaginary modes). omega; frequency; cm^-1; ndarray(ndof) complex (real/imag). q; normal mode, normalized mass-weighted; a0 u^1/2; ndarray(ndof, ndof) float. w; normal mode, un-mass-weighted; a0; ndarray(ndof, ndof) float. x; normal mode, normalized un-mass-weighted; a0; ndarray(ndof, ndof) float. degeneracy; degree of degeneracy. ndarray(ndof) int. TRV; translation/rotation/vibration. ndarray(ndof) str ‘TR’ or ‘V’ or ‘-’ for partial. gamma; irreducible representation. ndarray(ndof) str irrep or None if unclassifiable. mu; reduced mass; u; ndarray(ndof) float (+/+). k; force constant; mDyne/A; ndarray(ndof) float (+/-). DQ0; RMS deviation v=0; a0 u^1/2; ndarray(ndof) float (+/0). Qtp0; Turning point v=0; a0 u^1/2; ndarray(ndof) float (+/0). Xtp0; Turning point v=0; a0; ndarray(ndof) float (+/0). theta_vib; char temp; K; ndarray(ndof) float (+/0). IR_intensity; infrared intensity; km/mol; ndarray(ndof) float (+/+). Examples; >>> # displacement of first atom in highest energy mode; >>> vibinfo['x'].data[:, -1].reshape(nat, 3)[0]. >>> # remove translations & rotations; >>> vibonly = filter_nonvib(vibinfo). table of contents. harmonic_analysis; harmonic_analysis(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Psithon Functions: Invoking a Calculation; Harmonic Vibrational Analysis and Visualization of Normal Modes — frequency() and hessian(); harmonic_analysis. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/api/psi4.driver.qcdb.vib.harmonic_analysis.html:2397,energy,energy,2397,psi4manual/master/api/psi4.driver.qcdb.vib.harmonic_analysis.html,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.driver.qcdb.vib.harmonic_analysis.html,1,['energy'],['energy']
Energy Efficiency," [H] to the total SCF energy.; Quantity in Eq. (4). (3). OCEPA(0) TOTAL ENERGY¶. OCEPA(0) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the orbital-optimized CEPA(0) level of theory. OMP2 TOTAL ENERGY¶. OMP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the orbital-optimized MP2 level of theory. OMP3 TOTAL ENERGY¶. OMP3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the orbital-optimized MP3 level of theory. ONE-ELECTRON ENERGY¶; The one-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (4). QCISD TOTAL ENERGY¶. QCISD CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the quadratic configuration interaction singles and doubles level; of theory. QCISD(T) TOTAL ENERGY¶. QCISD(T) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the quadratic configuration interaction singles and doubles with; perturbative triples correction level of theory. SAPT DISP ENERGY¶. SAPT ELST ENERGY¶. SAPT EXCH ENERGY¶. SAPT IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [H] for the the; requested SAPT level of theory. The sum of these four components yields; SAPT ENERGY. SAPT ENERGY¶; The total electronic interaction energy [H] for the requested SAPT; level of theory. SAPT SAPT0 ENERGY¶. SAPT SAPT2 ENERGY¶. SAPT SAPT2+ ENERGY¶. SAPT SAPT2+(3) ENERGY¶. SAPT SAPT2+3 ENERGY¶; The total electronic interaction energy [H] for the labeled SAPT level; of theory. SAPT SAPT2+(CCD) ENERGY¶. SAPT SAPT2+(3)(CCD) ENERGY¶. SAPT SAPT2+3(CCD) ENERGY¶; The total electronic interaction energy [H] for the labeled SAPT level; of theory that incorporates coupled-cluster dispersion. SCF DIPOLE X¶. SCF DIPOLE Y¶. SCF DIPOLE Z¶; The three components of the SCF dipole [Deb",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/glossary_psivariables-1.html:13946,energy,energy,13946,psi4manual/4.0b4/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/glossary_psivariables-1.html,8,['energy'],['energy']
Energy Efficiency," [H] to the total SCF energy.; Quantity in Eq. (4). (3). OCEPA(0) TOTAL ENERGY¶. OCEPA(0) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the orbital-optimized CEPA(0) level of theory. OMP2 TOTAL ENERGY¶. OMP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the orbital-optimized MP2 level of theory. OMP3 TOTAL ENERGY¶. OMP3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the orbital-optimized MP3 level of theory. ONE-ELECTRON ENERGY¶; The one-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (4). QCISD TOTAL ENERGY¶. QCISD CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the quadratic configuration interaction singles and doubles level; of theory. QCISD(T) TOTAL ENERGY¶. QCISD(T) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the quadratic configuration interaction singles and doubles with; perturbative triples correction level of theory. SAPT DISP ENERGY¶. SAPT ELST ENERGY¶. SAPT EXCH ENERGY¶. SAPT IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [H] for the the; requested SAPT level of theory. The sum of these four components yields; SAPT TOTAL ENERGY. SAPT TOTAL ENERGY¶; The total electronic interaction energy [H] for the requested SAPT; level of theory. SAPT0 TOTAL ENERGY¶. SSAPT0 TOTAL ENERGY¶. SAPT2 TOTAL ENERGY¶. SAPT2+ TOTAL ENERGY¶. SAPT2+(3) TOTAL ENERGY¶. SAPT2+3 TOTAL ENERGY¶; The total electronic interaction energy [H] for the labeled SAPT level; of theory. SAPT2+(CCD) TOTAL ENERGY¶. SAPT2+(3)(CCD) TOTAL ENERGY¶. SAPT2+3(CCD) TOTAL ENERGY¶; The total electronic interaction energy [H] for the labeled SAPT level; of theory that incorporates coupled-cluster dispersion. SAPT2+DMP2 TOTAL ENERGY¶. SAPT2+(3)DMP2 TOTAL ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/glossary_psivariables-1.html:14198,energy,energy,14198,psi4manual/1.0.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/glossary_psivariables-1.html,4,['energy'],['energy']
Energy Efficiency," [Neese:2009:98]; F. Neese, F. Wennmohs, and A. Hansen; Chem. Phys. 356, 98-109 (2009). [Izsak:2011:144105]; R. Izsák and F. Neese; J. Chem. Phys. 135, 144105 (2011). [Smith:2018:3504]; 10.1021/acs.jctc.8b00286,; “PSI4NUMPY: An Interactive Quantum Chemistry Programming Environment for Reference Implementations and Rapid Development”,; D. G. A. Smith, L. A. Burns, D. A. Sirianni, D. R. Nascimento, A. Kumar, A. M. James, J. B. Schriber, T. Zhang, B. Zhang, A. S. Abbott, E. J. Berquist, M. H. Lechner, L. A. Cunha, A. G. Heide, J. M. Waldrop, T. Y. Takeshita, A. Alenaizan, D. Neuhauser, R. A. King, A. C. Simmonett, J. M. Turney, H. F. Schaefer III, F. A. Evangelista, A. E. DePrince, T. D. Crawford, K. Patkowski, and C. D. Sherrill; J. Chem. Theory Comput. 14, 3504-3511 (2018). [Schriber:2021:234107]; J. B. Schriber, D. A. Sirianni, D. G. A. Smith, L. A. Burns, D. Sitkoff, D. L. Cheney, C. D. Sherrill; J. Chem. Phys. 154, 234107 (2021). [Caldeweyher:2019:154122]; “A generally applicable atomic-charge dependent London dispersion correction”,; E. Caldeweyher, S. Ehlert, A. Hansen, H. Neugebauer, S. Spicher, C. Bannwarth, and S. Grimme,; J. Chem. Phys. 150, 154122 (2019).; https://doi.org/10.1063/1.5090222. [Haser:1989:104]; M. Haser and R. Ahlrichs,; J. Comp. Chem. 10(1), 104 (1989).; https://doi.org/10.1002/jcc.540100111. [Thompson:2017:144101]; T. H. Thompson and C. Ochsenfeld; J. Chem. Phys. 147, 144101 (2017).; https://doi.org/10.1063/1.4994190. [Smith:2020:184108]; “PSI4 1.4: Open-source software for high-throughput quantum chemistry”,; D. G. A. Smith, L. A. Burns, A. C. Simmonett, R. M. Parrish, M. C. Schieber, R. Galvelis, P. Kraus, H. Kruse, R. Di Remigio, A. Alenaizan, A. M. James, S. Lehtola, J. P. Misiewicz, M. Scheurer, R. A. Shaw, J. B. Schriber, Y. Xie, Z. L. Glick, D. A. Sirianni, J. S. O’Brien, J. M. Waldrop, A. Kumar, E. G. Hohenstein, B. P. Pritchard, B. R. Brooks, H. F. Schaefer III, A. Yu. Sokolov, K. Patkowski, A. E. DePrince III, U. Bozkaya, R. King, ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/bibliography.html:14268,charge,charge,14268,psi4manual/1.7.x/bibliography.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/bibliography.html,4,['charge'],['charge']
Energy Efficiency," []; E1s = []; kIPs = []; IPs = []; types = []. # Right endpoint; psi4.set_global_option('DFT_OMEGA', omega_r). # Neutral; if read:; psi4.set_global_option(""GUESS"", ""READ""); p4util.copy_file_to_scratch(read180, 'psi', 'ot', 180). molecule.set_molecular_charge(charge0); molecule.set_multiplicity(mult0); psi4.print_out(""""""\n\t==> IP Fitting SCF: Neutral, Right Endpoint <==\n""""""); E0r, wfn = energy('scf', return_wfn=True, molecule=molecule, **kwargs); eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); E_HOMO = 0.0;; if Nb == 0:; E_HOMO = eps_a[int(Na - 1)]; else:; E_a = eps_a[int(Na - 1)]; E_b = eps_b[int(Nb - 1)]; if E_a >= E_b:; E_HOMO = E_a; else:; E_HOMO = E_b; E_HOMOr = E_HOMO; psi4.IO.change_file_namespace(180, ""ot"", ""neutral""). # Cation; if read:; psi4.set_global_option(""GUESS"", ""READ""); p4util.copy_file_to_scratch(read180, 'psi', 'ot', 180). molecule.set_molecular_charge(charge1); molecule.set_multiplicity(mult1); psi4.print_out(""""""\n\t==> IP Fitting SCF: Cation, Right Endpoint <==\n""""""); E1r = energy('scf', molecule=molecule, **kwargs); psi4.IO.change_file_namespace(180, ""ot"", ""cation""). IPr = E1r - E0r;; kIPr = -E_HOMOr;; delta_r = IPr - kIPr;. if IPr > kIPr:; message = (""""""\n***IP Fitting Error: Right Omega limit should have kIP > IP""""""); raise ValidationError(message). omegas.append(omega_r); types.append('Right Limit'); E0s.append(E0r); E1s.append(E1r); IPs.append(IPr); kIPs.append(kIPr). # Use previous orbitals from here out; psi4.set_global_option(""GUESS"", ""READ""). # Left endpoint; psi4.set_global_option('DFT_OMEGA', omega_l). # Neutral; psi4.IO.change_file_namespace(180, ""neutral"", ""ot""); molecule.set_molecular_charge(charge0); molecule.set_multiplicity(mult0); psi4.print_out(""""""\n\t==> IP Fitting SCF: Neutral, Left Endpoint <==\n""""""); E0l, wfn = energy('scf', return_wfn=True, molecule=molecule, **kwargs); eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); E_HOMO = 0.0; if Nb == 0:; E_HOMO = eps_a[int(Na - 1)]; else:; E_a = eps_a[int(Na - 1)]; E_b = eps_b",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/frac.html:14263,energy,energy,14263,psi4manual/1.0.0/_modules/frac.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/frac.html,1,['energy'],['energy']
Energy Efficiency," [beta3] » ; Appendices »; Keywords by Module ». OMP2¶; Performs orbital-optimized MP2 computations. General¶. CACHELEVEL¶. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CC_MAXITER¶. Maximum number of iterations to determine the amplitudes. Type: integer; Default: 50. CUTOFF¶. Cutoff value for numerical procedures. Type: integer; Default: 14. DIIS_MAX_VECS¶. Number of vectors used in DIIS. Type: integer; Default: 4. DO_LEVEL_SHIFT¶. Do apply level shifting?. Type: boolean; Default: false. DO_SCS¶. Do perform spin-component-scaled OMP2 (SCS-OMP2)? In all computation, SCS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SCS-OMP2, one needs to set ‘DO_SCS’ to true. Type: boolean; Default: false. DO_SOS¶. Do perform spin-opposite-scaled OMP2 (SOS-OMP2)? In all computation, SOS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SOS-OMP2, one needs to set ‘DO_SOS’ to true. Type: boolean; Default: false. E_CONVERGENCE¶. Convergence criterion for energy. Type: conv double; Default: 1e-8. HESS_TYPE¶. Type Hessian matrix will be used in orbital optimization procedure. Type: string; Possible Values: NONE; Default: NONE. LEVEL_SHIFT¶. Level shift to aid convergence. Type: double; Default: 0.02. LINEQ_SOLVER¶. The solver will be used for simultaneous linear equations. Type: string; Possible Values: CDGESV, FLIN, POPLE; Default: CDGESV. MAX_MOGRAD_CONVERGENCE¶. Convergence criterion for maximum orbital g",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodir_options_c/module__omp2-1.html:1131,energy,energy,1131,psi4manual/4.0b3/autodir_options_c/module__omp2-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/module__omp2-1.html,2,['energy'],['energy']
Energy Efficiency," [deg/(dm (g/cm^3))] calculated at the CC2 level in the; modified velocity gauge for a given (x) wavelength, (x) rounded to nearest integer. CC QUADRUPOLE XX¶. CC QUADRUPOLE XY¶. CC QUADRUPOLE XZ¶. CC QUADRUPOLE YY¶. CC QUADRUPOLE YZ¶. CC QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; coupled cluster level of theory and root. CCSD TOTAL ENERGY¶. CCSD CORRELATION ENERGY¶. CCSDT TOTAL ENERGY¶. CCSDT CORRELATION ENERGY¶. CCSDTQ TOTAL ENERGY¶. CCSDTQ CORRELATION ENERGY¶. CCn TOTAL ENERGY¶. CCn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested full coupled-cluster (CCSD, CCSDT, up to CCn); level of theory. CCSD(T) TOTAL ENERGY¶. CCSD(T) CORRELATION ENERGY¶. A-CCSD(T) TOTAL ENERGY¶. A-CCSD(T) CORRELATION ENERGY¶. CCSDT(Q) TOTAL ENERGY¶. CCSDT(Q) CORRELATION ENERGY¶. CC(n-1)(n) TOTAL ENERGY¶. CC(n-1)(n) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the perturbatively corrected coupled-cluster (CCSD(T), a-CCSD(T), CCSDT(Q),; up to CC(n-1)(n) level of theory. CCSDT-1a TOTAL ENERGY¶. CCSDT-1a CORRELATION ENERGY¶. CCSDTQ-1a TOTAL ENERGY¶. CCSDTQ-1a CORRELATION ENERGY¶. CCn-1a TOTAL ENERGY¶. CCn-1a CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the approximate coupled-cluster (CCSD(T)-1a, CCSDT(Q)-1a,; up to CCn-1a) level of theory. CCSDT-1b TOTAL ENERGY¶. CCSDT-1b CORRELATION ENERGY¶. CCSDTQ-1b TOTAL ENERGY¶. CCSDTQ-1b CORRELATION ENERGY¶. CCn-1b TOTAL ENERGY¶. CCn-1b CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the approximate coupled-cluster (CCSD(T)-1b, CCSDT(Q)-1b,; up to CCn-1b) level of theory. CCSDT-3 TOTAL ENERGY¶. CCSDT-3 CORRELATION ENERGY¶. CCSDTQ-3 TOTAL ENERGY¶. CCSDTQ-3 CORRELATION ENERGY¶. CCn-3 TOTAL ENERGY¶. CCn-3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the approximate",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/glossary_psivariables-1.html:5123,energy,energy,5123,psi4manual/1.2.1/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/glossary_psivariables-1.html,8,['energy'],['energy']
Energy Efficiency," [docs] def compute(self, client: Optional[""qcportal.FractalClient""] = None):; """"""Run each job in task list.""""""; instructions = ""\n"" + p4util.banner(f"" FiniteDifference Computations"", strNotOutfile=True) + ""\n""; logger.debug(instructions); core.print_out(instructions). with p4util.hold_options_state():; for t in self.task_list.values():; t.compute(client=client). def _prepare_results(self, client: Optional[""qcportal.FractalClient""] = None):; results_list = {k: v.get_results(client=client) for k, v in self.task_list.items()}. # load AtomicComputer results into findifrec[reference]; reference = self.findifrec[""reference""]; task = results_list[""reference""]; response = task.return_result; reference[""module""] = getattr(task.provenance, ""module"", None). if task.driver == 'energy':; reference['energy'] = response. elif task.driver == 'gradient':; reference['gradient'] = response; reference['energy'] = task.extras['qcvars']['CURRENT ENERGY']. elif task.driver == 'hessian':; reference['hessian'] = response; reference['energy'] = task.extras['qcvars']['CURRENT ENERGY']; if 'CURRENT GRADIENT' in task.extras['qcvars']:; reference['gradient'] = task.extras['qcvars']['CURRENT GRADIENT']. dipole_available = False; if 'CURRENT DIPOLE' in task.extras['qcvars']:; reference['dipole'] = task.extras['qcvars']['CURRENT DIPOLE']; dipole_available = True. # load AtomicComputer results into findifrec[displacements]; for label, displacement in self.findifrec[""displacements""].items():; task = results_list[label]; response = task.return_result. if task.driver == 'energy':; displacement['energy'] = response. elif task.driver == 'gradient':; displacement['gradient'] = response; displacement['energy'] = task.extras['qcvars']['CURRENT ENERGY']. elif task.driver == 'hessian':; displacement['hessian'] = response; displacement['energy'] = task.extras['qcvars']['CURRENT ENERGY']; if 'CURRENT GRADIENT' in task.extras['qcvars']:; displacement['gradient'] = task.extras['qcvars']['CURRENT GRADIENT']. if '",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html:47106,energy,energy,47106,psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html,1,['energy'],['energy']
Energy Efficiency," [docs]def allen_focal_point(func, label, **kwargs):; r""""""Function to call Wes Allen-style Focal; Point Analysis. JCP 127 014306. Uses; :py:func:`~psi4.driver.cbs` to evaluate the following; expression. SCF employs a three-point extrapolation according; to :py:func:`~psi4.driver.driver_cbs.scf_xtpl_helgaker_3`. MP2, CCSD, and; CCSD(T) employ two-point extrapolation performed according to; :py:func:`~psi4.driver.driver_cbs.corl_xtpl_helgaker_2`. CCSDT and CCSDT(Q); are plain deltas. This wrapper requires :ref:`Kallay's MRCC code <sec:mrcc>`. .. math:: E_{total}^{\text{FPA}} = E_{total,\; \text{SCF}}^{\text{cc-pV[Q56]Z}} \; + E_{corl,\; \text{MP2}}^{\text{cc-pV[56]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CCSD}}^{\text{CCSD(T)}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CCSD(T)}}^{\text{CCSDT}}\big\vert_{\text{cc-pVTZ}} \; + \delta_{\text{CCSDT}}^{\text{CCSDT(Q)}}\big\vert_{\text{cc-pVDZ}}. >>> # [1] single-point energy by this composite method; >>> energy('allen_focal_point'). >>> # [2] finite-difference geometry optimization embarrasingly parallel; >>> optimize('allen_focal_point', mode='sow'). """""". # SCF; kwargs['scf_basis'] = kwargs.get('scf_basis', 'cc-pV[Q56]Z'); kwargs['scf_scheme'] = kwargs.get('scf_scheme', driver_cbs.scf_xtpl_helgaker_3). # delta MP2 - SCF; kwargs['corl_wfn'] = kwargs.get('corl_wfn', 'mp2'); kwargs['corl_basis'] = kwargs.get('corl_basis', 'cc-pV[56]Z'); kwargs['corl_scheme'] = kwargs.get('corl_scheme', driver_cbs.corl_xtpl_helgaker_2). # delta CCSD - MP2; kwargs['delta_wfn'] = kwargs.get('delta_wfn', 'mrccsd'); kwargs['delta_wfn_lesser'] = kwargs.get('delta_wfn_lesser', 'mp2'); kwargs['delta_basis'] = kwargs.get('delta_basis', 'cc-pV[56]Z'); kwargs['delta_scheme'] = kwargs.get('delta_scheme', driver_cbs.corl_xtpl_helgaker_2). # delta CCSD(T) - CCSD; kwargs['delta2_wfn'] = kwargs.get('delta2_wfn', 'mrccsd(t)'); kwargs['delta2_wfn_lesser'] = kwargs.get('delta2_wfn_lesser', 'mrccsd'); kwargs",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/aliases.html:5313,energy,energy,5313,psi4manual/1.4.0/_modules/psi4/driver/aliases.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/aliases.html,4,['energy'],['energy']
Energy Efficiency," [docs]def oeprop(wfn, *args, **kwargs):; """"""Evaluate one-electron properties. :returns: None. :type wfn: :py:class:`~psi4.core.Wavefunction`; :param wfn: set of molecule, basis, orbitals from which to compute properties. How to specify args, which are actually the most important. :type title: string; :param title: label prepended to all psivars computed. :examples:. >>> # [1] Moments with specific label; >>> E, wfn = energy('hf', return_wfn=True); >>> oeprop(wfn, 'DIPOLE', 'QUADRUPOLE', title='H3O+ SCF'). """"""; oe = core.OEProp(wfn); if 'title' in kwargs:; oe.set_title(kwargs['title']); for prop in args:; oe.add(prop); oe.compute(). [docs]def cubeprop(wfn, **kwargs):; """"""Evaluate properties on a grid and generate cube files. .. versionadded:: 0.5; *wfn* parameter passed explicitly. :returns: None. :type wfn: :py:class:`~psi4.core.Wavefunction`; :param wfn: set of molecule, basis, orbitals from which to generate cube files. :examples:. >>> # [1] Cube files for all orbitals; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> cubeprop(wfn). >>> # [2] Cube files for density (alpha, beta, total, spin) and four orbitals; >>> # (two alpha, two beta); >>> set cubeprop_tasks ['orbitals', 'density']; >>> set cubeprop_orbitals [5, 6, -5, -6]; >>> E, wfn = energy('scf', return_wfn=True); >>> cubeprop(wfn). """"""; # By default compute the orbitals; if not core.has_global_option_changed('CUBEPROP_TASKS'):; core.set_global_option('CUBEPROP_TASKS', ['ORBITALS']). if ((core.get_global_option('INTEGRAL_PACKAGE') == 'ERD') and ('ESP' in core.get_global_option('CUBEPROP_TASKS'))):; raise ValidationError('INTEGRAL_PACKAGE ERD does not play nicely with electrostatic potential, so stopping.'). cp = core.CubeProperties(wfn); cp.compute_properties(). [docs]def set_memory(inputval, execute=True):; """"""Function to reset the total memory allocation. Takes memory value; *inputval* as type int, float, or str; int and float are taken literally; as bytes to be set, string taken as a unit-containing va",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/util.html:2311,energy,energy,2311,psi4manual/1.3.2/_modules/psi4/driver/p4util/util.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/util.html,2,['energy'],['energy']
Energy Efficiency," [docs]def oeprop(wfn, *args, **kwargs):; """"""Evaluate one-electron properties. :returns: None. :type wfn: :py:class:`~psi4.core.Wavefunction`; :param wfn: set of molecule, basis, orbitals from which to compute properties. How to specify args, which are actually the most important. :type title: string; :param title: label prepended to all psivars computed. :examples:. >>> # [1] Moments with specific label; >>> E, wfn = energy('hf', return_wfn=True); >>> oeprop(wfn, 'DIPOLE', 'QUADRUPOLE', title='H3O+ SCF'). """"""; oe = core.OEProp(wfn); if 'title' in kwargs:; oe.set_title(kwargs['title']); for prop in args:; oe.add(prop); oe.compute(). [docs]def cubeprop(wfn, **kwargs):; """"""Evaluate properties on a grid and generate cube files. .. versionadded:: 0.5; *wfn* parameter passed explicitly. :returns: None. :type wfn: :py:class:`~psi4.core.Wavefunction`; :param wfn: set of molecule, basis, orbitals from which to generate cube files. :examples:. >>> # [1] Cube files for all orbitals; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> cubeprop(wfn). >>> # [2] Cube files for density (alpha, beta, total, spin) and four orbitals; >>> # (two alpha, two beta); >>> set cubeprop_tasks ['orbitals', 'density']; >>> set cubeprop_orbitals [5, 6, -5, -6]; >>> E, wfn = energy('scf', return_wfn=True); >>> cubeprop(wfn). """"""; # By default compute the orbitals; if not core.has_global_option_changed('CUBEPROP_TASKS'):; core.set_global_option('CUBEPROP_TASKS',['ORBITALS']). if ((core.get_global_option('INTEGRAL_PACKAGE') == 'ERD') and; ('ESP' in core.get_global_option('CUBEPROP_TASKS'))):; raise ValidationError('INTEGRAL_PACKAGE ERD does not play nicely with electrostatic potential, so stopping.'). cp = core.CubeProperties(wfn); cp.compute_properties(). [docs]def set_memory(inputval, execute=True):; """"""Function to reset the total memory allocation. Takes memory value; *inputval* as type int, float, or str; int and float are taken literally; as bytes to be set, string taken as a unit-containing va",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/p4util/util.html:2267,energy,energy,2267,psi4manual/1.1.0/_modules/psi4/driver/p4util/util.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/p4util/util.html,1,['energy'],['energy']
Energy Efficiency," [kcal/mol] Delta [kcal/mol]\n""""""); previous_e = energy_body_dict[1]; nbody_range = list(energy_body_dict); nbody_range.sort(); for n in nbody_range:; delta_e = (energy_body_dict[n] - previous_e); delta_e_kcal = delta_e * constants.hartree2kcalmol; int_e_kcal = (; energy_body_dict[n] - energy_body_dict[1]) * constants.hartree2kcalmol if not embedding else np.nan; core.print_out(; """""" %4s %20.12f %20.12f %20.12f\n"""""" % (n, energy_body_dict[n], int_e_kcal, delta_e_kcal)); previous_e = energy_body_dict[n]; core.print_out(""\n""). [docs]def nbody_gufunc(func, method_string, **kwargs):; """"""; Computes the nbody interaction energy, gradient, or Hessian depending on input.; This is a generalized univeral function for computing interaction and total quantities. :returns: *return type of func* |w--w| The data. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| data and wavefunction with energy/gradient/hessian set appropriately when **return_wfn** specified. :type func: function; :param func: ``energy`` || etc. Python function that accepts method_string and a molecule. Returns a; energy, gradient, or Hessian as requested. :type method_string: string; :param method_string: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, lowercase and usually unlabeled. Indicates the computational; method to be passed to func. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element of a tuple. :type bsse_type: string or list; :param bsse_type: ``'cp'`` || ``['nocp', 'vmfc']`` || |dl| ``None`` |dr| || etc. Type of BSSE correction to compute: CP, NoCP, or VMFC. The first in this; list is returned by this function. By default, this function is not called. :type max_nbody: int; :para",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_nbody.html:4001,energy,energy,4001,psi4manual/1.3.2/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_nbody.html,1,['energy'],['energy']
Energy Efficiency," \(E^{(30)}_{ind}\) was added, causing; possible discrepancies with prior versions of the code on the order of; 0.01 kcal/mol. See https://github.com/psi4/psi4/issues/1677. Symmetry-adapted perturbation theory (SAPT) provides a means of directly; computing the noncovalent interaction between two molecules, that is, the; interaction energy is determined without computing the total energy of the; monomers or dimer. In addition, SAPT provides a decomposition of the; interaction energy into physically meaningful components: i.e.,; electrostatic, exchange, induction, and dispersion terms. In SAPT, the; Hamiltonian of the dimer is partitioned into contributions from each; monomer and the interaction. \[H=F_A+W_A+F_B+W_B+V\]; Here, the Hamiltonian is written as a sum of the usual monomer Fock; operators, \(F\), the fluctuation potential of each monomer, \(W\), and the; interaction potential, \(V\). The monomer Fock operators, \(F_A+F_B\), are; treated as the zeroth-order Hamiltonian and the interaction energy is; evaluated through a perturbative expansion of \(V\), \(W_A\), and \(W_B\).; Through first-order in \(V\), electrostatic and exchange interactions are; included; induction and dispersion first appear at second-order in \(V\). For; a complete description of SAPT, the reader is referred to the excellent; review by Jeziorski, Moszynski, and Szalewicz [Jeziorski:1994:1887].; Several truncations of the closed-shell SAPT expansion are available in the SAPT; module of PSI4. The simplest truncation of SAPT is denoted SAPT0; and defined in Eq. (1). (1)¶\[E_{SAPT0} = E_{elst}^{(10)} + E_{exch}^{(10)} + E_{ind,resp}^{(20)} +; E_{exch-ind,resp}^{(20)} + E_{disp}^{(20)} + E_{exch-disp}^{(20)} + \delta_{HF}^{(2)}\]; In this notation, \(E^{(vw)}\) defines the order in \(V\) and in \(W_A+W_B\); the; subscript, \(resp\), indicates that orbital relaxation effects are included. (2)¶\[E_{SAPT2} = E_{SAPT0} + E_{elst,resp}^{(12)} + E_{exch}^{(11)} +; E_{exch}^{(12)} + \; ^{t}\!E_{ind}^",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/sapt-1.html:2385,energy,energy,2385,psi4manual/1.4.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/sapt-1.html,2,['energy'],['energy']
Energy Efficiency," \times 10^{-5}\). GAU_VERYTIGHT 6. \(2.0 \times 10^{-6}\); \(1.0 \times 10^{-6}\); \(6.0 \times 10^{-6}\); \(4.0 \times 10^{-6}\). Footnotes. 1; Default. 2; Baker convergence criteria are the same. 3(1,2); Counterpart NWCHEM convergence criteria are the same. 4(1,2,3); Convergence achieved when all active criteria are fulfilled. 5(1,2,3); Convergence achieved when Max Force and one of Max Energy or Max Disp are fulfilled. 6(1,2,3,4,5); Normal convergence achieved when all four criteria (Max Force, RMS Force,; Max Disp, and RMS Disp) are fulfilled. To help with flat; potential surfaces, alternate convergence achieved when 100\(\times\)rms force is less; than RMS Force criterion. 7; Compensates for difficulties in converging geometry optmizations of supermolecular complexes; tightly, where large rms disp and max disp may result from flat potential surfaces even when; max force and/or rms force are small. For ultimate control, specifying a value for any of the five monitored options activates that; criterium and overwrites/appends it to the criteria set by G_CONVERGENCE.; Note that this revokes the special convergence arrangements detailed in notes 5 and 6; and instead requires all active criteria to be fulfilled to; achieve convergence. To avoid this revokation, turn on keyword FLEXIBLE_G_CONVERGENCE. Interface to GeomeTRIC¶; The GeomeTRIC optimizer developed by Wang and Song [Wang:2016:214108] may be used in place of; Psi4’s native Optking optimizer. GeomeTRIC uses a translation-rotation-internal coordinate (TRIC); system that works well for optimizing geometries of systems containing noncovalent interactions.; Use of the GeomeTRIC optimizer is specified with the engine argument to; optimize(). The optimization will respect the keywords G_CONVERGENCE; and GEOM_MAXITER. Any other GeomeTRIC-specific options (including constraints); may be specified with the optimizer_keywords argument to optimize().; Constraints may be placed on cartesian coordinates, bonds, angles, an",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/optking-1.html:13504,monitor,monitored,13504,psi4manual/1.4.0/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/optking-1.html,5,['monitor'],['monitored']
Energy Efficiency," _process_displacement(; energy, lowername, molecule, displacement, n, ndisp, write_orbitals=False, **kwargs). # Reset variables; for key, val in var_dict.items():; core.set_variable(key, val). # Assemble Hessian from energies; H = driver_findif.assemble_hessian_from_energies(findif_meta_dict, irrep); wfn.set_hessian(core.Matrix.from_array(H)); wfn.set_gradient(G0). # Explicitly set the current energy..; if isinstance(lowername, str) and lowername in procedures['energy']:; # this correctly filters out cbs fn and ""hf/cc-pvtz""; # it probably incorrectly filters out mp5, but reconsider in DDD; core.set_variable(f""CURRENT HESSIAN"", H); core.set_variable(f""{lowername.upper()} TOTAL HESSIAN"", H); core.set_variable(f""{lowername.upper()} TOTAL GRADIENT"", G0); wfn.set_variable(f""{lowername.upper()} TOTAL HESSIAN"", H); wfn.set_variable(f""{lowername.upper()} TOTAL GRADIENT"", G0); core.set_variable('CURRENT ENERGY', findif_meta_dict[""reference""][""energy""]); wfn.set_variable('CURRENT ENERGY', findif_meta_dict[""reference""][""energy""]). core.set_global_option(""PARENT_SYMMETRY"", """"); optstash.restore(); optstash_conv.restore(). _hessian_write(wfn). if return_wfn:; return (wfn.hessian(), wfn); else:; return wfn.hessian(). [docs]def frequency(name, **kwargs):; r""""""Function to compute harmonic vibrational frequencies. :aliases: frequencies(), freq(). :returns: *float* |w--w| Total electronic energy in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/driver.html:82846,energy,energy,82846,psi4manual/1.5.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/driver.html,1,['energy'],['energy']
Energy Efficiency," ``""blyp/sto-3g""``) are; bounced out of CBS. More complex calls (e.g. ``""mp2/cc-pv[tq]z""`` or; ``""mp2/cc-pv[tq]z+D:ccsd(t)/cc-pvtz""``) are expanded by `_parse_cbs_gufunc_string()`; and pushed through :py:func:`~psi4.cbs`. Returns; -------; dict of updated CBS keyword arguments; """""". ptype = kwargs.pop('ptype', None). # Sanitize total_method_name; total_method_name = total_method_name.lower(); total_method_name = total_method_name.replace(' ', ''). # Split into components; method_list, basis_list = _parse_cbs_gufunc_string(total_method_name). # Single energy call?; single_call = len(method_list) == 1; single_call &= '[' not in basis_list[0]; single_call &= ']' not in basis_list[0]. if single_call:; method_name = method_list[0]; basis = basis_list[0]. return {'method': method_name, 'basis': basis}. # Drop out for unsupported calls; if ptype is None:; raise ValidationError(""A CBS call was detected, but no ptype was passed in. Please alert a dev.""); elif ptype not in [""energy"", ""gradient"", ""hessian""]:; raise ValidationError(f""{ptype.title()}: Cannot extrapolate or delta correct {ptype} yet.""). # Catch kwarg issues for CBS methods only; user_dertype = kwargs.pop('dertype', None); cbs_verbose = kwargs.pop('cbs_verbose', False). # If we are not a single call, let CBS wrapper handle it!; cbs_kwargs = {}; cbs_kwargs['ptype'] = ptype; cbs_kwargs['verbose'] = cbs_verbose. if user_dertype is not None:; cbs_kwargs['dertype'] = user_dertype. # Find method and basis; metadata = []; if method_list[0] in ['scf', 'hf', 'c4-scf', 'c4-hf']:; stage = {}; stage['wfn'] = method_list[0]; stage['basis'] = basis_list[0]; if 'scf_scheme' in kwargs:; stage['scheme'] = kwargs.pop('scf_scheme'); stage['stage'] = ""scf""; stage['treatment'] = ""scf""; else:; # _validate_cbs_inputs will produce scf stage automatically; stage = {}; stage['wfn'] = method_list[0]; stage['basis'] = basis_list[0]; if 'corl_scheme' in kwargs:; stage['scheme'] = kwargs.pop('corl_scheme'); stage['stage'] = ""corl""; stage['treat",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html:41033,energy,energy,41033,psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,1,['energy'],['energy']
Energy Efficiency," ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: str; :param delta2_wfn_lesser: |dl| ``delta_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set set through ``set`` commands have no influence; on a cbs calculation. :type scf_basis: :ref:`basis string <apdx:basisElement>`; :param scf_basis: |dl| ``corl_basis`` |dr| || ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, ``scf_basis`` can default; to ``corl_basis``. :type corl_basis: :ref:`basis string <apdx:basisElement>`; :param corl_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the correlation energy. :type delta_basis: :ref:`basis string <apdx:basisElement>`; :param delta_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. :type delta2_basis: :ref:`basis string <apdx:basisElement>`; :param delta2_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. * Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, ``'xtpl_highest_1'``, which uses the best basis; set available. See :ref:`sec:cbs_xtpl` for all available schemes. :type scf_scheme: Callable; :param scf_scheme: |dl| ``xtpl_highest_1`` |dr| || ``scf_x",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:38412,energy,energy,38412,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,2,['energy'],['energy']
Energy Efficiency," ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: str; :param delta2_wfn_lesser: |dl| ``delta_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set set through ``set`` commands have no influence; on a cbs calculation. :type scf_basis: :ref:`basis string <apdx:basisElement>`; :param scf_basis: |dl| ``corl_basis`` |dr| || ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, ``scf_basis`` can default; to ``corl_basis``. :type corl_basis: :ref:`basis string <apdx:basisElement>`; :param corl_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the correlation energy. :type delta_basis: :ref:`basis string <apdx:basisElement>`; :param delta_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. :type delta2_basis: :ref:`basis string <apdx:basisElement>`; :param delta2_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. * Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, ``'xtpl_highest_1'``, which uses the best basis; set available. See :ref:`sec:cbs_xtpl` for all available schemes. :type scf_scheme: function; :param scf_scheme: |dl| ``xtpl_highest_1`` |dr| || ``scf_x",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html:38157,energy,energy,38157,psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,1,['energy'],['energy']
Energy Efficiency," ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: str; :param delta2_wfn_lesser: |dl| ``delta_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set set through ``set`` commands have no influence; on a cbs calculation. :type scf_basis: :ref:`basis string <apdx:basisElement>`; :param scf_basis: |dl| ``corl_basis`` |dr| || ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, ``scf_basis`` can default; to ``corl_basis``. :type corl_basis: :ref:`basis string <apdx:basisElement>`; :param corl_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the correlation energy. :type delta_basis: :ref:`basis string <apdx:basisElement>`; :param delta_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. :type delta2_basis: :ref:`basis string <apdx:basisElement>`; :param delta2_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. * Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, ``'xtpl_highest_1'``, which uses the best basis; set available. See :ref:`sec:cbs_xtpl` for all available schemes. :type scf_scheme: str; :param scf_scheme: |dl| ``'xtpl_highest_1'`` |dr| || ``'scf_xtp",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_cbs.html:26196,energy,energy,26196,psi4manual/1.7.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_cbs.html,4,['energy'],['energy']
Energy Efficiency," ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: str; :param delta2_wfn_lesser: |dl| ``delta_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set set through ``set`` commands have no influence; on a cbs calculation. :type scf_basis: :ref:`basis string <apdx:basisElement>`; :param scf_basis: |dl| ``corl_basis`` |dr| || ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, ``scf_basis`` can default; to ``corl_basis``. :type corl_basis: :ref:`basis string <apdx:basisElement>`; :param corl_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the correlation energy. :type delta_basis: :ref:`basis string <apdx:basisElement>`; :param delta_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. :type delta2_basis: :ref:`basis string <apdx:basisElement>`; :param delta2_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. * Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, ``'xtpl_highest_1'``, which uses the best basis; set available. See :ref:`sec:cbs_xtpl` for all available schemes. :type scf_scheme: string; :param scf_scheme: |dl| ``'xtpl_highest_1'`` |dr| || ``'scf_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html:26195,energy,energy,26195,psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,1,['energy'],['energy']
Energy Efficiency," a given irrep. fd_geoms_1_0(arg0); Gets list of displacements needed for a finite difference gradient computation, from energy points. fd_geoms_freq_0(arg0, arg1); Gets list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep. fd_geoms_freq_1(arg0, arg1); Gets list of displacements needed fof a finite difference frequency computation, from gradients, for a given irrep. finalize(). flush_outfile(); Flushes the output file. fnocc(arg0); Runs the fno-ccsd(t)/qcisd(t)/mp4/cepa energy code. get_active_efp(); Returns the currently active EFP object. get_active_molecule(); Returns the currently active molecule object. get_array_variable(arg0); Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available). get_array_variables(); Returns dictionary of the PSI variables set internally by the modules or python driver. get_atomic_point_charges(); Returns the most recently computed atomic point charges, as a double * object. get_datadir(); Sets the path to shared text resources, PSIDATADIR. get_efp_torque(); Returns the most recently computed gradient for the EFP portion, as a Nefp by 6 Matrix object. get_frequencies(); Returns the most recently computed frequencies, as a 3N-6 Vector object. get_global_option(arg0); Given a string of a keyword name arg1, returns the value associated with the keyword from the global options. get_global_option_list(); Returns a list of all global options. get_gradient(); Returns the most recently computed gradient, as a N by 3 Matrix object. get_legacy_molecule(); Returns the currently active molecule object. get_local_option(arg0, arg1); Given a string of a keyword name arg2 and a particular module arg1, returns the value associated with the keyword in the module options scope. get_memory(); Returns the amount of memory available to Psi (in bytes). get_num_threads(); Returns the number of threads to use in SMP parallel c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psi4api-1.html:244094,charge,charges,244094,psi4manual/1.2.1/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html,2,['charge'],['charges']
Energy Efficiency," a more expensive orbital update step; needed for the full orbital optimization. In the ODC-13 method, the third- and; fourth-order N-representability conditions are used for the density cumulant; and the correlated contribution \(\boldsymbol{\tau}\), respectively,; and the orbitals are variationally optimized.; For most of the applications, it is recommended to use the ODC-12 method, which; provides an optimal balance between accuracy and efficiency, especially for; molecules with open-shell character. If highly accurate results are desired, a; combination of the ODC-13 method with a three-particle energy correction; [\(\mbox{ODC-13$(\lambda_3)$}\)] can be used (see below).; For the detailed comparison of the quality of these methods, we refer; users to our publications.; The DCT functional can be specified by the DCT_FUNCTIONAL option. The; default choice is the ODC-12 functional. The DCT code can also be used to; compute the \((\lambda_3)\) energy correction that perturbatively accounts; for three-particle correlation effects, similarly to the (T) correction in coupled; cluster theory. Computation of the \((\lambda_3)\) correction can be; requested by setting the THREE_PARTICLE option to PERTURBATIVE. A; combination of the ODC-13 functional with the \((\lambda_3)\) correction; [denoted as \(\mbox{ODC-13$(\lambda_3)$}\)] has been shown to provide highly; accurate results for open-shell molecules near equilibrium geometries.; At the present moment, all of the DCT methods support unrestricted reference; orbitals (REFERENCE UHF), which can be used to perform energy and; gradient computations for both closed- and open-shell molecules. In addition,; the ODC-06 and ODC-12 methods support restricted reference orbitals; (REFERENCE RHF) for the energy and gradient computations of; closed-shell molecules. Note that in this case restricted reference orbitals; are only available for ALGORITHM SIMULTANEOUS. Iterative Algorithms¶; As explained in the Theory section, in order to",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/dct-1.html:6715,energy,energy,6715,psi4manual/1.4.0/dct-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/dct-1.html,9,['energy'],['energy']
Energy Efficiency," a summary of the; charge-transfer results:; SAPT Charge Transfer Analysis; ------------------------------------------------------------------------------------------------; SAPT Induction (Dimer Basis) -2.0970 [mEh] -1.3159 [kcal/mol] -5.5057 [kJ/mol]; SAPT Induction (Monomer Basis) -1.1396 [mEh] -0.7151 [kcal/mol] -2.9920 [kJ/mol]; SAPT Charge Transfer -0.9574 [mEh] -0.6008 [kcal/mol] -2.5137 [kJ/mol]. These results are for the water dimer geometry shown above computed with; SAPT0/aug-cc-pVDZ. Monomer-Centered Basis Computations¶; The charge-transfer analysis above is carried out by taking the; difference between SAPT induction as calculated in the dimer-centered; basis (i.e., each monomer sees the basis functions on both monomers); vs. the monomer-centered basis (i.e., each monomer utilizes only its; own basis set). It is also possible to run a closed-shell SAPT computation at any; level using only the monomer-centered basis. To do this, simply add; sapt_basis='monomer' to the energy function, such as; energy('sapt2',sapt_basis='monomer'). This procedure leads to faster compuations, but it converges more slowly; towards the complete basis set limit than the default procedure, which uses; the dimer-centered basis set. Hence, monomer-centered basis SAPT; computations are not recommended. The open-shell SAPT0 code is not; compatible yet with monomer-centered computations. Computations with Mid-bonds¶; SAPT computations with midbonds can be accomplished by adding a third ghost; monomer to the computation. For example; molecule dimer {; 0 1; He 0 0 5; --; 0 1; He 0 0 -5; --; 0 1; @He 0 0 0; }. Here the functions of the third monomer will be added to the virtual space of; the entire computation. Note that an error will be thrown if each atom in the; third monomer is not a ghost to prevent confusion with three-body SAPT which is; not currently supported by Psi4. Interpreting SAPT Results¶; We will examine the results of a SAPT2+3/aug-cc-pVDZ computation on the; water di",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/sapt-1.html:32228,energy,energy,32228,psi4manual/1.4.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/sapt-1.html,18,['energy'],['energy']
Energy Efficiency," a “tertiary” virtual space consisting of the remaining virtuals. First, an initial CISD computation is run to get the natural orbitals; this allows a meaningful partitioning of the virtual orbitals into groups of different importance. Next, the RASCI is run. The split-virtual CISD[TQ] takes all singles and doubles, and all triples and quadruples with no more than 2 electrons in the secondary virtual subspace (RAS 3). If any electrons are present in the tertiary virtual subspace (RAS 4), then that excitation is only allowed if it is a single or double. dft-grad-lr2; Tests CAM gradients with and without XC pieces to narrow grid error. dfccd1; DF-CCD cc-pVDZ energy for the H2O molecule. fsaptd-terms; F-SAPT0/jun-cc-pvdz procedure for methane dimer. cc8; UHF-CCSD(T) cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Z-matrix input. fnocc3; Test FNO-QCISD(T) computation. cc39; RHF-CC2-LR/cc-pVDZ dynamic polarizabilities of HOF molecule. dfomp2-2; OMP2 cc-pVDZ energy for the NO molecule. cc40; RHF-CC2-LR/cc-pVDZ optical rotation of H2O2. gauge = length, omega= (589 355 nm). dfcasscf-sa-sp; Example of state-averaged CASSCF for the C2 molecule. opt-irc-2; Compute the IRC for HCN <-> NCH interconversion at the RHF/DZP level of theory. cisd-h2o+-1; 6-31G** H2O+ Test CISD Energy Point. aediis-1; ADIIS test case, from 10.1063/1.3304922. scf-response2; Compute the dipole polarizability for water with custom basis set. cbs-xtpl-wrapper; RHF aug-cc-pVQZ energy for the BH molecule, with Cartesian input. Various gradients for a strained helium dimer and water molecule. scf-coverage; Lithium test for coverage. pywrap-checkrun-rhf; This checks that all energy methods can run with a minimal input and set symmetry. cisd-sp; 6-31G** H2O Test CISD Energy Point. tdscf-7; TD-HF test variable access. mbis-2; MBIS calculation on OH- (Expanded Arrays). sapt-dft1; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. fci-h2o-fzcv; 6-31G H2O Test FCI Ener",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html:4716,energy,energy,4716,psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency," a; reasonably large amount of BLAS3/BLAS2 work to form the densities and potentials; in each block). For each block, a united set of significant basis functions is; determined by the cutoff radius of each shell of basis functions. The size of; this cutoff radius (and thereby the accuracy of the density/potential; evaluation) can be varied by setting the DFT_BASIS_TOLERANCE, which; defaults to 1E-12. We are still exploring optimizations of the octree algorithm; and the basis cutoffs, but it is likely that significant speed gains may be; realized by relaxing the basis cutoff tolerance, with negligible decrease in; accuracy.; An example of a fully specified grid is as follows:; molecule {; H; H 1 0.7; }. set {; basis cc-pvdz; scf_type df; dft_spherical_points 590 # Often needed; dft_radial_points 99 # Often needed; dft_radial_scheme treutler # Rarely needed; dft_nuclear_scheme treutler # Rarely needed; dft_basis_tolerance 1.0E-11 # Can speed things up, but benchmark the error; }. energy('b3lyp'). ERI Algorithms¶; The ERI algorithms for the Coulomb and hybrid exchange are identical to those; listed above for Hartree-Fock. However, for LRC functionals, the long-range; exchange contributions to the Kohn-Sham matrix have only been implemented in the; DF and DIRECT algorithms. The use of DF is highly recommended for KS-DFT, as the; errors incurred by the density fitting approximation (in a proper -JKFIT; auxiliary basis) are orders of magnitude smaller than the accuracy of any known; functional. IP Fitting¶; In collaboration with the Bredas group, we have developed an automatic procedure; for IP fitting of LRC functionals, based on a modified Regula-Falsi method. To; perform IP fitting, one simply calls the ip_fitting() Python macro, after; setting up a standard LRC UKS computation. A representative example is:; memory 512 MB. molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; symmetry c1 # IP fitting must be run in C1 symmetry; }. set {; reference uks # UKS, as we need to d",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/dft-1.html:17838,energy,energy,17838,psi4manual/4.0b2/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/dft-1.html,4,['energy'],['energy']
Energy Efficiency," a; reasonably large amount of BLAS3/BLAS2 work to form the densities and potentials; in each block). For each block, a united set of significant basis functions is; determined by the cutoff radius of each shell of basis functions. The size of; this cutoff radius (and thereby the accuracy of the density/potential; evaluation) can be varied by setting the DFT_BASIS_TOLERANCE, which; defaults to 1E-12. We are still exploring optimizations of the octree algorithm; and the basis cutoffs, but it is likely that significant speed gains may be; realized by relaxing the basis cutoff tolerance, with negligible decrease in; accuracy.; An example of a fully specified grid is as follows:; molecule {; H; H 1 0.7; }. set {; basis cc-pvdz; scf_type df; dft_spherical_points 590 # Often needed; dft_radial_points 99 # Often needed; dft_radial_scheme treutler # Rarely needed; dft_nuclear_scheme treutler # Rarely needed; dft_basis_tolerance 1.0E-11 # Can speed things up, but benchmark the error; }. energy('b3lyp'). ERI Algorithms¶; The ERI algorithms for the Coulomb and hybrid exchange are identical to those; listed above for Hartree-Fock. However, for LRC functionals, the long-range; exchange contributions to the Kohn-Sham matrix have only been implemented in the; DF and DIRECT algorithms. The use of DF is highly recommended for KS-DFT, as the; errors incurred by the density fitting approximation (in a proper -JKFIT; auxiliary basis) are orders of magnitude smaller than the accuracy of any known; functional.; Note: gradients with LRC functionals and DF integrals technology are not; currently enabled. We hope to have a patch for this deficit soon. Please let us; know if you have a strong need for this capability, and we will move the; priority up. IP Fitting¶; In collaboration with the Bredas group, we have developed an automatic procedure; for IP fitting of LRC functionals, based on a modified Regula-Falsi method. To; perform IP fitting, one simply calls the ip_fitting() Python macro, a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/dft-1.html:18206,energy,energy,18206,psi4manual/1.0.0/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/dft-1.html,6,['energy'],['energy']
Energy Efficiency," above examples were simple single-point energy computations; (as specified by the energy() function). Of course there are other; kinds of computations to perform, such as geometry optimizations and; vibrational frequency computations. These can be specified by replacing; energy() with optimize() or frequency(), respectively.; Here’s an example of optimizing the H2O molecule using Hartree–Fock with; a cc-pVDZ basis set (located in; tu3-h2o-opt.; #! Optimize H2O HF/cc-pVDZ. memory 250 mb. molecule h2o {; O ; H 1 0.96; H 1 0.96 2 104.5; }. set basis cc-pVDZ; optimize('scf'). This should perform a series of gradient computations. The gradient points; which way is downhill in energy, and the optimizer then modifies the; geometry to follow the gradient. After about 4 cycles, the geometry should; converge with a message like Optimization is complete!. As indicated; in the following table (printed by the optimizer at the end of the; computation), the energy decreases with each step,; and the maximum force on each atom also decreases with each step (in; principle these numbers could increase in some iterations, but here they do; not).; ----------------------------------------------------------------------; Step Energy Delta(E) MAX force MAX Delta(q); ----------------------------------------------------------------------; 1 -76.026653665892 -76.026653665892 1.52e-02 1.52e-02; 2 -76.026907793199 -0.000254127307 9.55e-03 9.55e-03; 3 -76.027052927171 -0.000145133972 4.47e-04 4.47e-04; 4 -76.027053472137 -0.000000544965 1.16e-04 1.16e-04; ----------------------------------------------------------------------. To get harmonic vibrational frequencies, first we must set up an input; using the OPTIMIZED GEOMETRY. We can easily get the optimized geometry; from the previous computation. Looking at the output from running the; previous example, we see that the OH bond length is about 0.9463 Ångstroms,; and the bond angle is about 104.575 degrees. It’s good to give this many; digits (or ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/tutorial-1.html:4989,energy,energy,4989,psi4manual/4.0b2/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/tutorial-1.html,4,['energy'],['energy']
Energy Efficiency," accessed through the first item below more; conveniently than the equivalent second and third items. optimize('mp2/cc-pv[tq]z + D:ccsd(t)/cc-pvdz'); optimize(""cbs"", corl_wfn='mp2', corl_basis='cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='cc-pvdz'); optimize(""cbs"", cbs_metadata=[{""wfn"": ""hf"", ""basis"": ""cc-pvqz""}, {""wfn"": ""mp2"", ""basis"": ""cc-pv[tq]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pvdz""}]). Many examples can be found at cbs-xtpl-energy,; cbs-xtpl-gradient, cbs-xtpl-opt,; cbs-xtpl-freq, cbs-xtpl-func,; cbs-xtpl-wrapper, cbs-xtpl-dict. psi4.cbs(name[, scf_basis, scf_scheme, corl_wfn, corl_basis, corl_scheme, delta_wfn, delta_wfn_lesser, delta_basis, delta_scheme, delta2_wfn, delta2_wfn_lesser, delta2_basis, delta2_scheme, cbs_metadata])[source]; Function to define a multistage energy method from combinations of; basis set extrapolations and delta corrections and condense the; components into a minimum number of calculations. Aliases:; complete_basis_set(). Returns:; (float) – Total electronic energy in Hartrees. PSI variables:. CBS TOTAL ENERGY; CBS REFERENCE ENERGY; CBS CORRELATION ENERGY; CURRENT ENERGY; CURRENT REFERENCE ENERGY; CURRENT CORRELATION ENERGY. Caution; Some features are not yet implemented. Buy a developer a coffee. No way to tell function to boost fitting basis size for all calculations.; Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in several; sequential stages (scf, corl, delta1, delta2, … ) covering treatment; of the reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction, etc.. Each is activated by its; stage_wfn keyword, or as a field in the `cbs_metadata` list, and is only; allowed if all preceding stages are active. \[E_{\text{total}}^{\text{CBS}} = \mathcal{F}_{\textbf{scf_scheme}} \left(E_{\text{total},\; \text{SCF}}^{\textbf{scf_basis}}\right) \; + \mathcal{F}_{\textbf{corl_scheme}} \left(E_{\text{corl},\; \",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/cbs.html:2735,energy,energy,2735,psi4manual/1.7.x/cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/cbs.html,4,['energy'],['energy']
Energy Efficiency," account using the polarizable; continuum model (PCM) in the PTE approximation [Cammi:2009:164104], see; PCM. Current coupled cluster capabilities of PSI4¶. Method; Reference; Energy; Gradient; Exc. Energies; LR Props. CC2; RHF; Y; Y; Y; Y. UHF; Y; —; N; —. ROHF; Y; —; N; —. CCSD; RHF; Y; Y; Y; Y. UHF; Y; Y; Y; —. ROHF; Y; Y; Y; —. CCSD(T); RHF; Y; Y; n/a; n/a. UHF; Y; Y; n/a; n/a. ROHF; Y; —; n/a; n/a. A-CCSD(T) 1; RHF; Y; —; n/a; n/a. CC3; RHF; Y; —; Y; —. UHF; Y; —; Y; —. ROHF; Y; —; Y; —. CCD; Brueckner; Y; N; N; N. CCD(T); Brueckner; Y; N; n/a; n/a. Footnotes. 1; Also known as CCSD(AT), Lambda-CCSD(T), CCSD(T)_L. The following wavefunctions are currently recognized by PSI4 as arguments; to functions like energy(): 'ccsd', 'ccsd(t)', 'a-ccsd(t)', 'cc2',; 'cc3', 'bccd' (CCD with Brueckner orbitals), 'bccd(t)' (CCD(T) with; Brueckner orbitals), 'eom-ccsd', 'eom-cc2' (CC2 for excited states),; 'eom-cc3' (CC3 for excited states). Response properties can be obtained; by calling the function properties() (instead of, for example, energy(),; e.g., properties('ccsd'). There are many sample; coupled cluster inputs provided in psi4/samples. Basic Keywords¶; A complete list of keywords related to coupled-cluster computations is; provided in the appendices, with the majority of the relevant; keywords appearing in Appendix CCENERGY. For a standard ground-state; CCSD or CCSD(T) computation, the following keywords are common:. REFERENCE¶. Reference wavefunction type. Type: string; Possible Values: RHF, ROHF, UHF; Default: RHF. R_CONVERGENCE¶. Convergence criterion for wavefunction (change) in CC amplitude equations. Type: conv double; Default: 1e-7. MAXITER¶. Maximum number of iterations to solve the CC equations. Type: integer; Default: 50. BRUECKNER_ORBS_R_CONVERGENCE¶. Convergence criterion for Brueckner orbitals. The convergence is determined based on the largest \(T_1\) amplitude. Default adjusts depending on E_CONVERGENCE. Type: conv double; Default: 1e-5. RESTART¶. Do r",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/cc-1.html:4287,energy,energy,4287,psi4manual/1.5.0/cc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/cc-1.html,3,['energy'],['energy']
Energy Efficiency," accurate, and it should be preferred unless extreme accuracy is required; or a fitting basis is not defined for the primary basis and atom type; encountered. In particular, we have found excellent efficiency and tractability; gains when using DF-MP2 in concert with a DF-SCF reference. An efficient,; threaded, disk-based DF-MP2 code is available in PSI4 for all single; reference types available in the SCF module.; MP2 defaults in PSI4 to the density-fitted code. See; MP2_TYPE for performing a MP2 with conventional integrals.; An example utilization of the code is:; molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set basis cc-pvdz; set scf_type df; set freeze_core True. energy('mp2'). The energy('mp2') call to energy() executes; the predefined DF-MP2 procedure, first calling; the SCF module with a default RHF reference and DF algorithm for the; two-electron integrals. When the orbitals are converged, the DF-MP2 module is; launched, which forms the density-fitted \((Q|ov)\) integrals and then builds the; full \((ov|ov)\) tensor in blocks, evaluating the contributions to the MP2 energy; as it goes. A RHF-MP2 wavefunction is selected automatically due to the RHF; reference. In this example, we freeze the core, both for efficiency and; because split-valence bases like cc-pVDZ do not contain core correlation; functions. The result looks something like:; -----------------------------------------------------------; ==================> DF-MP2 Energies <====================; -----------------------------------------------------------; Reference Energy = -76.0213974638823942 [Eh]; Singles Energy = -0.0000000000000001 [Eh]; Same-Spin Energy = -0.0512503270216563 [Eh]; Opposite-Spin Energy = -0.1534098175176923 [Eh]; Correlation Energy = -0.2046601445393486 [Eh]; Total Energy = -76.2260576084217405 [Eh]; -----------------------------------------------------------; ================> DF-SCS-MP2 Energies <==================; -----------------------------------------------------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/dfmp2-1.html:2451,energy,energy,2451,psi4manual/1.4.0/dfmp2-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/dfmp2-1.html,5,['energy'],['energy']
Energy Efficiency," add_atom(...); | add_atom( (Molecule)arg1, (int)arg2, (float)arg3, (float)arg4, (float)arg5, (str)arg6, (float)arg7, (float)arg8, (int)arg9) -> None :; | Adds to Molecule arg1 an atom with atomic number arg2, Cartesian coordinates in Bohr (arg3, arg4, arg5), atomic symbol arg6, mass arg7, charge arg8 (optional), and lineno arg9 (optional); | ; | C++ signature :; | void add_atom(N3psi8MoleculeE {lvalue},i,d,d,d,PKc,d,d,i); | ; | atom_at_position(...); | atom_at_position( (Molecule)arg1, (float)arg2, (float)arg3) -> int :; | Tests to see if an atom is at the position arg2 with a given tolerance arg3; | ; | C++ signature :; | i atom_at_position(N3psi8MoleculeE {lvalue},Pd,d); | ; | center_of_mass(...); | center_of_mass( (Molecule)arg1) -> Vector3 :; | Computes center of mass of molecule (does not translate molecule); | ; | C++ signature :; | N3psi7Vector3E center_of_mass(N3psi8MoleculeE {lvalue}); | ; | charge(...); | charge( (Molecule)arg1, (int)arg2) -> float :; | Gets charge of atom; | ; | C++ signature :; | d charge(N3psi8MoleculeE {lvalue},i); | ; | clone(...); | clone( (Molecule)arg1) -> Molecule :; | Returns a new Molecule identical to arg1; | ; | C++ signature :; | N3psi8MoleculeE clone(N3psi8MoleculeE {lvalue}); | ; | create_psi4_string_from_molecule(...); | create_psi4_string_from_molecule( (Molecule)arg1) -> str :; | Gets a string reexpressing in input format the current states of the molecule; | ; | C++ signature :; | Ss create_psi4_string_from_molecule(N3psi8MoleculeE {lvalue}); | ; | deactivate_all_fragments(...); | deactivate_all_fragments( (Molecule)arg1) -> None :; | Sets all fragments in the molecule to be inactive; | ; | C++ signature :; | void deactivate_all_fragments(N3psi8MoleculeE {lvalue}); | ; | extract_subsets(...); | extract_subsets( (Molecule)arg1, (list)arg2, (list)arg3) -> Molecule :; | Returns copy of arg1 with arg2 fragments Real and arg3 fragments Ghost; | ; | C++ signature :; | N5boost10shared_ptrIN3psi8MoleculeEEE extract_subsets(N3ps",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:544734,charge,charge,544734,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,6,['charge'],['charge']
Energy Efficiency," adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_ft97_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('FT97'); # Tab in, trailing newlines; sup.set_description(' FT97 GGA Exchange-Correlation Functional\n'); # Tab in, trailing newlines; sup.set_citation(' M. Filatov and W. Theil, Int. J. Quant. Chem., 62, 603-616, 1997\n'). # Add member functionals; sup.add_x_functional(build_functional('FT97B_X')); sup.add_c_functional(build_functional('FT97_C')). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_pbe_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('PBE'); # Tab in, trailing newlines; sup.set_description(' PBE GGA Exchange-Correlation Functional\n'); # Tab in, trailing newlines; sup.set_citation(' J.P. Perdew et. al., Phys. Rev. Lett., 77(18), 3865-3868, 1996\n'). # Add member functionals; sup.add_x_functional(build_functional('PBE_X')); sup.add_c_functional(build_functional('PBE_C')). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_pbe0_superfunctional(name, npoints, deriv):. sup = build_pbe_superfunctional(name, npoints, deriv); sup.set_name('PBE0'); sup.set_description(' PBE0 Hybrid ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/functional.html:27046,allocate,allocate,27046,psi4manual/4.0b5/_modules/functional.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/functional.html,2,['allocate'],['allocate']
Energy Efficiency," adds a; thermochemical analysis. frequency(name[, molecule, return_wfn, func, mode, dertype, irrep])[source]¶; Function to compute harmonic vibrational frequencies. Aliases:frequencies(), freq(). Returns:float – Total electronic energy in Hartrees. Returns:(float, Wavefunction) – energy and wavefunction when return_wfn specified. Parameters:; name (string) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || 'off' ; Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies or gradients frequency, indicates; whether the calculations required to complete the frequency are to be run; in one file ('continuous') or are to be farmed out in an; embarrassingly parallel fashion ('sow'/'reap')/ For the latter,; run an initial job with 'sow' and follow instructions in its output file.; For maximum flexibility, return_wfn is always on in 'reap' mode. dertype (dertype) – 'hessian' || 'gradient' || 'energy'; Indicates whether analytic (if available- they’re not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or string) – -1 || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be compute",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/freq-1.html:1627,energy,energy,1627,psi4manual/1.0.0/freq-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/freq-1.html,2,['energy'],['energy']
Energy Efficiency," after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_pbe_superfunctional(name, npoints, deriv):. # Call this first; sup = PsiMod.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('PBE'); # Tab in, trailing newlines; sup.set_description(' PBE GGA Exchange-Correlation Functional\n'); # Tab in, trailing newlines; sup.set_citation(' J.P. Perdew et. al., Phys. Rev. Lett., 77(18), 3865-3868, 1996\n'). # Add member functionals; sup.add_x_functional(build_functional('PBE_X')); sup.add_c_functional(build_functional('PBE_C')). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_pbe0_superfunctional(name, npoints, deriv):. sup = build_pbe_superfunctional(name, npoints, deriv); sup.set_name('PBE0'); sup.set_description(' PBE0 Hybrid GGA Exchange-Correlation Functional\n'); sup.set_citation(' Adamo et. al., J. Chem. Phys., 110(13), 6158, 1999\n'); sup.set_x_alpha(0.25); return sup. [docs]def build_sogga_superfunctional(name, npoints, deriv):. # Call this first; sup = PsiMod.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('SOGGA'); # Tab in, trailing newlines; sup.set_description(' Second Order GGA Exchange-Correlation Functional\n'); # Tab in, trailing newlines; sup.set_citation(' Zhao et. al., J. Chem. Phys., 128(18), 184109, 2008\n'). # Add member functionals; sup.add_x_functional(build_functional('SOGGA_X')). C = build_functional('PBE_C'); C.set_parameter('bet', 0.037526); sup.add_c_functional(C). # Set GKS",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/functional.html:27049,allocate,allocate,27049,psi4manual/4.0b3/_modules/functional.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/functional.html,2,['allocate'],['allocate']
Energy Efficiency," after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_pbe_superfunctional(name, npoints, deriv):. # Call this first; sup = PsiMod.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('PBE'); # Tab in, trailing newlines; sup.set_description(' PBE GGA Exchange-Correlation Functional\n'); # Tab in, trailing newlines; sup.set_citation(' J.P. Perdew et. al., Phys. Rev. Lett., 77(18), 3865-3868, 1996\n'). # Add member functionals; sup.add_x_functional(build_functional('PBE_X')); sup.add_c_functional(build_functional('PBE_C')). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_pbe0_superfunctional(name, npoints, deriv):. sup = build_pbe_superfunctional(name, npoints, deriv); sup.set_name('PBE0'); sup.set_description(' PBE0 Hybrid GGA Exchange-Correlation Functional\n'); sup.set_x_alpha(0.25); return sup. [docs]def build_b3lyp_superfunctional(name, npoints, deriv):. # Call this first; sup = PsiMod.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('B3LYP'); # Tab in, trailing newlines; sup.set_description(' B3LYP Hybrid-GGA Exchange-Correlation Functional\n'); # Tab in, trailing newlines; sup.set_citation(' P.J. Stephens et. al., J. Phys. Chem., 98, 11623-11627, 1994\n'). # Add member functionals; b3 = build_functional('B3_X'); b3.set_alpha(1.0); sup.add_x_functional(b3); lyp = build_functional('LYP_C'); lyp.set_alpha(0.81); vwn = build_functional('VWN3RPA_C'); vwn.set_alpha(0.19); sup.add_c_functional(vwn); s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/functional.html:24738,allocate,allocate,24738,psi4manual/4.0b2/_modules/functional.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/functional.html,1,['allocate'],['allocate']
Energy Efficiency," after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_pw91_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('PW91'); # Tab in, trailing newlines; sup.set_description(' PW91 GGA Exchange-Correlation Functional\n'); # Tab in, trailing newlines; sup.set_citation(' J.P. Perdew et. al., Phys. Rev. B., 46(11), 6671-6687, 1992\n'). # Add member functionals; sup.add_x_functional(build_functional('PW91_X')); sup.add_c_functional(build_functional('PW91_C')). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_bp86_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('BP86'); # Tab in, trailing newlines; sup.set_description(' BP86 GGA Exchange-Correlation Functional\n'); # Tab in, trailing newlines; sup.set_citation(' Null\n'). # Add member functionals; sup.add_x_functional(build_functional('B88_X')); sup.add_c_functional(build_functional('P86_C')). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_ft97_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/functional.html:25461,allocate,allocate,25461,psi4manual/4.0b5/_modules/functional.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/functional.html,2,['allocate'],['allocate']
Energy Efficiency," algorithm is highly optimized, and is threaded with a mixture of; parallel BLAS and OpenMP. Note that this algorithm should use the -JKFIT series; of auxiliary bases, not the -RI or -MP2FIT bases. The default guess for; auxiliary basis set should work for all Dunning bases, otherwise the; DF_BASIS_SCF keyword can be used to manually specify the auxiliary basis.; This algorithm is preferred unless either absolute accuracy is required; [CCSD(T)] or a -JKFIT auxiliary basis is unavailable for the; primary basis/atoms involved. For some of these algorithms, Schwarz and/or density sieving can be used to; identify negligible integral contributions in extended systems. To activate; sieving, set the INTS_TOLERANCE keyword to your desired cutoff; (1.0E-12 is recommended for most applications). Convergence and Algorithm Defaults¶. SCF algorithm and convergence criteria defaults by calculation type [1]. Ab Initio Method; Calculation Type; E_CONVERGENCE; D_CONVERGENCE; SCF_TYPE. SCF of HF or DFT; energy; 6; 5; DF. optimization; 8; 6. frequency; 8; 6. SCF of post-HF; energy; 8; 6; PK [3]. optimization; 10; 7. frequency; 10; 7. CC property [2]; 10; 7. Footnotes. [1]Note that this table applies only the SCF module,; not to the final convergence criteria for post-HF methods or to methods; that use an alternate starting point, like MCSCF. [2]This applies to properties computed through the property() function. [3]Post-HF methods that do not rely upon the usual 4-index AO integrals use a density-; fitted SCF reference. That is, for DF-MP2 and SAPT, the default SCF_TYPE is DF. Recommendations¶; The SCF code is already quite flexible and powerful, with new features being; added weekly. We have tried as much as possible to keep the number of options to; a minimum, and to allow all options to be used in the presence of all other; options. Below are some rough words of advice about using the SCF code for; practical calculations:. For GUESS, the SAD guess is usually your; friend, even for ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/scf-1.html:19655,energy,energy,19655,psi4manual/4.0b3/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/scf-1.html,2,['energy'],['energy']
Energy Efficiency," algorithms will perform better if; more is available. To specify memory, the memory keyword should be used. The following; lines are all equivalent methods for specifying that 2 Gb of RAM is available; to PSI4:; memory 2 Gb. or. memory 2000 Mb. or. memory 2000000 Kb. One convenient way to override the PSI4 default memory is to place a memory; command in the ~/.psi4rc file, as detailed in Sec. Scratch Files and the ~/.psi4rc File. Return Values and PSI Variables¶; To harness the power of Python, PSI4 makes the most pertinent results of; each computation are made available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of H2; and H atom:; molecule h2{; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol*(2*h_energy - h2_energy); print""De=%f""%D_e. The energy() function returns the final result of the computation, which we; assign to a Python variable. The two energies are then converted to a; dissociation energy and printed to the output file using standard Python; notation. Sometimes there are multiple quantities of interest; these can be; accessed through the get_variable() function. For example, after performing a; density fitted MP2 computation, both the spin component scaled energy and the; unscaled MP2 energy are made available:; e_mp2=get_variable('DF-MP2 TOTAL ENERGY'); e_scs_mp2=get_variable('SCS-DF-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of; a calculation. The values for all can be printed in the output file; with the input file command print_variables(). Note that; PSI variables accumulate over a PSI4 instance and are not cleared by; clean(). So if you run in a single input file a STO-3G FCI; followed by a aug-cc-pVQZ SCF followed by a print_variables(); command, the last will include both SCF TOTAL ENERGY and; FCI TOTAL ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:19895,energy,energy,19895,psi4manual/4.0b2/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html,4,['energy'],['energy']
Energy Efficiency," alias to -D2P4;  . -D1; -D1 [2] within PSI4;  . -D2; alias to -D2P4;  . -D2P4; -D2 [3] within PSI4; []. -D2GR; -D2 [3] through dftd3; [, ]. -D3; alias to -D3ZERO;  . -D3ZERO; -D3 [4] w/ original zero-damping through dftd3; [, , , ]. -D3BJ; -D3 [5] w/ newer Becke-Johnson rational damping through dftd3; [, , , ]. Footnotes. [1]Note that there are functionals with these extensions (e.g., wB97X-D) that,; not being Grimme corrections, have nothing to do with this table. [2][Grimme:2004:1463]. [3](1, 2) [Grimme:2006:1787]. [4][Grimme:2010:154104]. [5][Grimme:2011:1456]. A few practical examples:. DFT-D2 single point with default parameters (dftd3 not called); energy('bp86-d'). DFT-D3BJ optimization with default parameters; optimize('pbe-d3bj'). DFT-D2 optimization with custom s6 parameter; set dft_dispersion_parameters [1.20]; optimize('b3lyp-d2'). DFT-D3ZERO single point (b3lyp) with custom s8 parameter (reset all four values); set dft_dispersion_parameters [1.0, 2.0, 1.261, 14.0]; energy('b3lyp-d3'). If only dispersion corrections (rather than total energies) are of; interest, the dftd3 program can be run independently of the scf; through the python function run_dftd3(). (This function; is the same PSI4/dftd3 interface that is called during an scf job.); This route is much faster than running a DFT-D energy. Some set-up:; molecule nene {; Ne; Ne 1 2.0; }. nene.update_geometry(). The same four dispersion corrections/gradients as the section above:; >>> print nene.run_dftd3('bp86', 'd', dertype=0); -7.735e-05. >>> E, G = nene.run_dftd3('pbe', 'd3bj'); >>> print G; [[0.0, 0.0, -1.1809087569358e-05], [0.0, 0.0, 1.1809087569358e-05]]. >>> E, G = nene.run_dftd3('b3lyp', 'd2', {'s6': 1.20}); >>> print E; -8.84e-05. >>> E, G = nene.run_dftd3(dashlvl='d3', dashparam={'s8': 2.0, 'alpha6': 14.0, 'sr6': 1.261, 's6': 1.0}); >>> print E; -0.00024762. run_dftd3(self, func=None, dashlvl=None, dashparam=None, dertype=None)[source]¶; Function to call Grimme’s dftd3 program (http://toc.un",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/dftd3-1.html:5643,energy,energy,5643,psi4manual/4.0b4/dftd3-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/dftd3-1.html,4,['energy'],['energy']
Energy Efficiency," alias to -D2P4;  . -D1; -D1 [2] within PSI4;  . -D2; alias to -D2P4;  . -D2P4; -D2 [3] within PSI4; []. -D2GR; -D2 [3] through dftd3; [, ]. -D3; alias to -D3ZERO;  . -D3ZERO; -D3 [4] w/ original zero-damping through dftd3; [, , , ]. -D3BJ; -D3 [5] w/ newer Becke-Johnson rational damping through dftd3; [, , , ]. Footnotes. [1]Note that there are functionals with these extensions (e.g., wB97X-D) that,; not being Grimme corrections, have nothing to do with this table. [2][Grimme:2004:1463]. [3](1, 2) [Grimme:2006:1787]. [4][Grimme:2010:154104]. [5][Grimme:2011:1456]. A few practical examples:. DFT-D2 single point with default parameters (dftd3 not called); energy('bp86-d'). DFT-D3BJ optimization with default parameters; optimize('pbe-d3bj'). DFT-D2 optimization with custom s6 parameter; set dft_dispersion_parameters [1.20]; optimize('b3lyp-d2'). DFT-D3ZERO single point (b3lyp) with custom s8 parameter (reset all four values); set dft_dispersion_parameters [1.0, 2.0, 1.261, 14.0]; energy('b3lyp-d3'). If only dispersion corrections (rather than total energies) are of; interest, the dftd3 program can be run independently of the scf; through the python function run_dftd3(). (This function; is the same PSI4/dftd3 interface that is called during an scf job.); This route is much faster than running a DFT-D energy. Some set-up:; molecule nene {; Ne; Ne 1 2.0; }. nene.update_geometry(). The same four dispersion corrections/gradients as the section above:; >>> print nene.run_dftd3('bp86', 'd', dertype=0); -7.735e-05. >>> E, G = nene.run_dftd3('pbe', 'd3bj'); >>> print G; [[0.0, 0.0, -1.1809087569358e-05], [0.0, 0.0, 1.1809087569358e-05]]. >>> E, G = nene.run_dftd3('b3lyp', 'd2', {'s6': 1.20}); >>> print E; -8.84e-05. >>> E, G = nene.run_dftd3(dashlvl='d3', dashparam={'s8': 2.0, 'alpha6': 14.0, 'sr6': 1.261, 's6': 1.0}); >>> print E; -0.00024762. run_dftd3(self, func=None, dashlvl=None, dashparam=None, dertype=None)¶; Function to call Grimme’s dftd3 program (http://toc.uni-muenst",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/dftd3.html:5576,energy,energy,5576,psi4manual/4.0b3/dftd3.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/dftd3.html,1,['energy'],['energy']
Energy Efficiency," all but two terms that; are nonlinear in \(T_1\) and \(T_2\):. (2)¶\[\begin{split}\langle \Psi_0 | (H - E) (1 + T_1 + T_2)|\Psi_0\rangle = 0, \\; \langle \Psi_i^a | (H - E) (1 + T_1 + T_2 + T_1T_2)|\Psi_0\rangle = 0, \\; \langle \Psi_{ij}^{ab} | (H - E) (1 + T_1 + T_2 + \frac{1}{2}T_2^2)|\Psi_0\rangle = 0. \\\end{split}\]; QCISD is slightly cheaper that CCSD computationally, but it retains the; \({\cal{O}}(o^2v^4)\) complexity of the original equations. Just as in; the familiar CCSD(T) method, the effects of connected triple excitations; may be included noniteratively to yield the QCISD(T) method. Both the; QCISD(T) and CCSD(T) methods are implemented for closed-shell references; in the FNOCC module. Many-body perturbation theory¶; QCI and CC methods are closely related to perturbation theory, and the; MP2, MP3, and MP4(SDQ) correlation energies can be obtained as a free; by-product of a CCSD or QCISD computation. The following is an; example of the results for a computation run with the call; energy('fno-qcisd') to energy():; QCISD iterations converged!. OS MP2 FNO correction: -0.000819116338; SS MP2 FNO correction: -0.000092278158; MP2 FNO correction: -0.000911394496. OS MP2 correlation energy: -0.166478414245; SS MP2 correlation energy: -0.056669079827; MP2 correlation energy: -0.223147494072; * MP2 total energy: -76.258836941658. OS MP2.5 correlation energy: -0.171225850256; SS MP2.5 correlation energy: -0.054028401038; MP2.5 correlation energy: -0.225254251294; * MP2.5 total energy: -76.260943698880. OS MP3 correlation energy: -0.175973286267; SS MP3 correlation energy: -0.051387722248; MP3 correlation energy: -0.227361008515; * MP3 total energy: -76.263050456101. OS MP4(SDQ) correlation energy: -0.180324322304; SS MP4(SDQ) correlation energy: -0.048798468084; MP4(SDQ) correlation energy: -0.230995119324; * MP4(SDQ) total energy: -76.266684566910. OS QCISD correlation energy: -0.181578117924; SS QCISD correlation energy: -0.049853548145; QCISD correlation ener",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/fnocc-1.html:5247,energy,energy,5247,psi4manual/1.4.0/fnocc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/fnocc-1.html,18,['energy'],['energy']
Energy Efficiency," all calculations.; No way to extrapolate def2 family basis sets; Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in four; sequential stages (scf, corl, delta, delta2) covering treatment of the; reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction. Each is activated by its; stage_wfn keyword and is only allowed if all preceding stages are active. Here, is an energy or energy extrapolation scheme, and the following also hold. A translation of this ungainly equation to example [5] below is as; follows. In words, this is a double- and triple-zeta 2-point; Helgaker-extrapolated CCSD(T) coupled-cluster correlation correction; appended to a triple- and quadruple-zeta 2-point; Helgaker-extrapolated MP2 correlation energy appended to a SCF/aug-cc-pVQZ; reference energy. Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy.; The cbs() function requires, at a minimum, name='scf' and scf_basis; keywords to be specified for reference-step only jobs and name and; corl_basis keywords for correlated jobs.; The following energy methods have been set up for cbs(). scf; df-scf. mp2; df-mp2. cc2; ccsd. bccd; cc3. ccsd(t); fci. Parameters:; name (string) – 'scf' || 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be 'scf'. Overruled if stage_wfn keywords supplied. corl_wfn (string) – 'mp2' || 'ccsd(t)' || etc.; Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with name or as the unlabeled; first argument to the function. delta_wfn (string) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a delta correction; t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/cbs-1.html:2280,energy,energy,2280,psi4manual/4.0b2/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/cbs-1.html,2,['energy'],['energy']
Energy Efficiency," all calculations.; No way to extrapolate def2 family basis sets; Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in four; sequential stages (scf, corl, delta, delta2) covering treatment of the; reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction. Each is activated by its; stage_wfn keyword and is only allowed if all preceding stages are active. Here, is an energy or energy extrapolation scheme, and the following also hold. A translation of this ungainly equation to example [5] below is as; follows. In words, this is a double- and triple-zeta 2-point; Helgaker-extrapolated CCSD(T) coupled-cluster correlation correction; appended to a triple- and quadruple-zeta 2-point; Helgaker-extrapolated MP2 correlation energy appended to a SCF/aug-cc-pVQZ; reference energy. Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy.; The cbs() function requires, at a minimum, name='scf' and scf_basis; keywords to be specified for reference-step only jobs and name and; corl_basis keywords for correlated jobs.; The following energy methods have been set up for cbs(). scf; mp2; mp2.5; mp3; mp4(sdq); mp4. omp2; omp3; ocepa; cepa0; cepa(0); cepa(1). cepa(3); acpf; aqcc; qcisd; cc2; ccsd. fno-df-ccsd; bccd; cc3; qcisd(t); ccsd(t); fno-df-ccsd(t). bccd(t); cisd; cisdt; cisdtq; cin; fci. Parameters:; name (string) – 'scf' || 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be 'scf'. Overruled if stage_wfn keywords supplied. corl_wfn (string) – 'mp2' || 'ccsd(t)' || etc.; Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with name or as the unlabe",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/cbs-1.html:2295,energy,energy,2295,psi4manual/4.0b4/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/cbs-1.html,2,['energy'],['energy']
Energy Efficiency," all elements of the matrix. zero_diagonal(self: psi4.core.Matrix) → None¶; Zero the diagonal of the matrix. zero_lower(self: psi4.core.Matrix) → None¶; Zero the lower triangle. zero_upper(self: psi4.core.Matrix) → None¶; Zero the upper triangle. table of contents. Matrix; Matrix; Matrix.name; Matrix.np; Matrix.nph; Matrix.shape; Matrix.absmax(); Matrix.accumulate_product(); Matrix.add(); Matrix.add_and_orthogonalize_row(); Matrix.apply_denominator(); Matrix.array_interface(); Matrix.axpy(); Matrix.back_transform(); Matrix.chain_dot(); Matrix.cholesky_factorize(); Matrix.clone(); Matrix.coldim(); Matrix.cols(); Matrix.copy(); Matrix.copy_lower_to_upper(); Matrix.copy_upper_to_lower(); Matrix.diagonalize(); Matrix.doublet(); Matrix.from_array(); Matrix.from_list(); Matrix.from_serial(); Matrix.gemm(); Matrix.general_invert(); Matrix.get(); Matrix.get_block(); Matrix.hermitivitize(); Matrix.hermitize(); Matrix.identity(); Matrix.invert(); Matrix.load(); Matrix.load_mpqc(); Matrix.nirrep(); Matrix.np_read(); Matrix.np_write(); Matrix.partial_cholesky_factorize(); Matrix.power(); Matrix.print_atom_vector(); Matrix.print_out(); Matrix.pseudoinverse(); Matrix.remove_symmetry(); Matrix.rms(); Matrix.rotate_columns(); Matrix.rowdim(); Matrix.rows(); Matrix.save(); Matrix.scale(); Matrix.scale_column(); Matrix.scale_row(); Matrix.schmidt(); Matrix.set(); Matrix.set_block(); Matrix.subtract(); Matrix.sum_of_squares(); Matrix.symmetrize_gradient(); Matrix.symmetry(); Matrix.to_array(); Matrix.to_serial(); Matrix.trace(); Matrix.transform(); Matrix.transpose(); Matrix.transpose_this(); Matrix.triplet(); Matrix.vector_dot(); Matrix.zero(); Matrix.zero_diagonal(); Matrix.zero_lower(); Matrix.zero_upper(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. PSI4 API: Linking C++ and Python; Matrix. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/api/psi4.core.Matrix.html:18899,power,power,18899,psi4manual/master/api/psi4.core.Matrix.html,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.Matrix.html,1,['power'],['power']
Energy Efficiency," all) tests have failed, look in your; build directory for file; objdir/tests/Testing/Temporary/LastTest.log. It may have a; .tmp extension, depending on whether the last test was interrupted and; a few other factors. Either way, this file should contain CMake’s testing; output, as well as everything that was printed to the screen. How to test a Psi4 installation¶; ctest requires a connection to source files and cmake; machinery and so can only be performed from objdir; (staged installation). To test an installed PSI4 (full or staged; installation), a limited number of “smoke” tests are available to be; run via pytest. From the executable:; psi4 –test. From the library (PSI4 must be detectable as a Python; module. See setup at How to configure paths for PsiAPI; if needed.):; python -c “import psi4; psi4.test()”. Output looks something like the below. PASSED in green is good; (means test ran correctly); SKIPPED in yellow is good (means that; not all software required for test is available); XPASS or XFAIL; in yellow is fine (unexpected pass or expected fail happens when we; include tests that need particular conditions (e.g., multiple cores); to run correctly); FAILED in red is bad.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19test_addons.py::test_gdma PASSED; test_addons.py::test_mrcc SKIPPED; test_addons.py::test_chemps2 PASSED; test_addons.py::test_dftd3 PASSED; test_addons.py::test_libefp PASSED; test_addons.py::test_pcmsolver PASSED; test_addons.py::test_erd PASSED; test_addons.py::test_simint PASSED; test_addons.py::test_json PASSED; test_addons.py::test_cfour SKIPPED; test_addons.py::test_v2rdm_casscf PASSED; test_addons.py::test_grimme_3c PASSED; test_addons.py::test_dkh PASSED; test_psi4.py::test_psi4_basic PASSED; test_psi4.py::test_psi4_cc PASSED; test_psi4.py::test_psi4_cas PASSED; test_psi4.py::test_psi4_dfmp2 PASSED; test_psi4.py::test_psi4_sapt PASSED; test_psi4.py::test_psi4_scfproperty PASSED. How to refer to Psi4¶; Ways to refer ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/build_planning-1.html:47770,green,green,47770,psi4manual/1.2.1/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/build_planning-1.html,2,['green'],['green']
Energy Efficiency," allen_focal_point(**kwargs) -> CBSMetadata:; r""""""Function to call Wes Allen-style Focal; Point Analysis. JCP 127 014306. Uses; the composite wrapper to evaluate the following; expression. SCF employs a three-point extrapolation according; to :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_helgaker_3`. MP2, CCSD, and; CCSD(T) employ two-point extrapolation performed according to; :py:func:`~psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2`. CCSDT and CCSDT(Q); are plain deltas. This wrapper requires :ref:`Kallay's MRCC code <sec:mrcc>`. .. math:: E_{total}^{\text{FPA}} = E_{total,\; \text{SCF}}^{\text{cc-pV[Q56]Z}} \; + E_{corl,\; \text{MP2}}^{\text{cc-pV[56]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CCSD}}^{\text{CCSD(T)}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CCSD(T)}}^{\text{CCSDT}}\big\vert_{\text{cc-pVTZ}} \; + \delta_{\text{CCSDT}}^{\text{CCSDT(Q)}}\big\vert_{\text{cc-pVDZ}}. >>> # [1] single-point energy by this composite method; >>> energy('allen_focal_point'). >>> # [2] single-point energy reducing the Hartree-Fock basis sets size; >>> energy('allen_focal_point', scf_basis='cc-pV[TQ5]Z'). """""". if not psi4.addons(""mrcc""):; raise ImportError(""Install MRCC (executable 'dmrcc') to use the allen_focal_point function.""). scf = { # HF; 'wfn': 'hf',; 'basis': kwargs.pop('scf_basis', 'cc-pV[Q56]Z'),; 'scheme': kwargs.pop('scf_scheme', 'scf_xtpl_helgaker_3'),; }; corl = { # MP2 - HF; 'wfn': kwargs.pop('corl_wfn', 'mp2'),; 'basis': kwargs.pop('corl_basis', 'cc-pV[56]Z'),; 'scheme': kwargs.pop('corl_scheme', 'corl_xtpl_helgaker_2'),; }; delta = { # CCSD - MP2; 'wfn': kwargs.pop('delta_wfn', 'mrccsd'),; 'wfn_lesser': kwargs.pop('delta_wfn_lesser', 'mp2'),; 'basis': kwargs.pop('delta_basis', 'cc-pV[56]Z'),; 'scheme': kwargs.pop('delta_scheme', 'corl_xtpl_helgaker_2'),; }; delta2 = { # CCSD(T) - CCSD; 'wfn': kwargs.pop('delta2_wfn', 'mrccsd(t)'),; 'wfn_lesser': kwargs.pop('delta2_wfn_lesser', 'mrccsd'),; 'basis'",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/aliases.html:5175,energy,energy,5175,psi4manual/1.6.x/_modules/psi4/driver/aliases.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/aliases.html,2,['energy'],['energy']
Energy Efficiency," an antisymmetric N-electron wavefunction. Unfortunately, no; simple set of necessary and sufficient N-representability conditions are known,; and some of the known conditions are not easily imposed. In addition, the lack; of separability of the density matrices may result in the loss of; size-consistency and size-extensivity. In DCFT, one takes a different route and; replaces \(\boldsymbol{\gamma_2}\) in favor of its two-particle density cumulant:. \[\lambda_{pq}^{rs} = \gamma_{pq}^{rs} - \gamma_p^r \gamma_q^s + \gamma_p^s \gamma_q^r\]; The one-particle density matrix is separated into its idempotent part; \(\boldsymbol{\kappa}\) and a correction \(\boldsymbol{\tau}\):. \[\gamma_p^q = \kappa_p^q + \tau_p^q\]; The idempotent part of \(\boldsymbol{\gamma_1}\) corresponds to a mean-field Hartree–Fock-like density,; while the non-idempotent correction \(\boldsymbol{\tau}\); depends on the density cumulant and describes the electron correlation effects.; Inserting the above two equations into the energy expression, we obtain:. \[E_{DCFT} = \frac{1}{2} \left( h_p^q + f_p^q \right) \gamma_q^p + \frac{1}{4} \bar{g}_{pq}^{rs} \lambda_{rs}^{pq}\]; where the antisymmetrized two-electron integrals and the generalized Fock operator; matrix elements were defined as follows:. \[\bar{g}_{pq}^{rs} = g_{pq}^{rs} - g_{pq}^{sr}\]. \[f_p^q = h_p^q + \bar{g}_{pr}^{qs} \gamma_{s}^{r}\]; Energy functional \(E_{DCFT}\) has several important properties. First,; the energy is now a function of two sets of independent parameters, the; idempotent part of \(\boldsymbol{\gamma_1}\) (\(\boldsymbol{\kappa}\)) and the density cumulant; (\(\boldsymbol{\lambda_2}\)). As a result, the energy functional is Hermitian,; which is important for the evaluation of the molecular properties. The additive; separability of the density cumulant guarantees that all of the DCFT methods; are size-extensive and size-consistent. Furthermore, the N-representability; problem is now greatly simplified, because the idempot",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/dcft-1.html:2429,energy,energy,2429,psi4manual/1.2.1/dcft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/dcft-1.html,6,['energy'],['energy']
Energy Efficiency," an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; To indicate MRCC as the target software, set QC_MODULE=MRCC.; This is a change as of October 2022; previously, one prefixed the method by “mr”; to indicate MRCC (e.g., energy('mrccsdt')).; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; qc_module mrcc; }; energy('ccsdt'). 'ccsdt' in the call to energy() plus qc_module=mrcc instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; Here the qc_module=mrcc is optional since PSI4 has no builtin module; that can perform CCSDT. For a method like CCSD, no specification of QC_MODULE; will default to the CCENERGY module, and specification with value mrcc is; required to route the computation to the MRCC program.; For a CCSDT(Q) energy, simply use 'ccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you can call it directly; For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC.; Perturbative methods (ccsd(t), ccsdtqp(h)_l, etc.); are available with REFERENCE ROHF in versions of MRCC published; at least after July 1, 2014.; When using ROHF-CCSDT(Q), MRCC will compute and report two variants:; CCSDT(Q)/A and CCSDT(Q)/B. [Kallay:2008:144101] PSI4 will save both energies but will use; the CCSDT(Q)/B as the CCSDT(Q) energy. CCSDT(Q)/B has been found to be; more robust by Martin. [Martin:2014:785]. QC_MODULE=MRCC. name; calls method in Kallay’s MRCC program [manual]. ccsd; CC through doubles [details]. ccsdt; CC through triple",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/mrcc.html:1736,energy,energy,1736,psi4manual/1.7.x/mrcc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/mrcc.html,8,['energy'],['energy']
Energy Efficiency," and CC computations and conventional MPn computations. General¶. CC_DIIS_MAX_VECS¶. Maximum number of vectors used in amplitude DIIS. Type: integer; Default: 6. CC_DIIS_MIN_VECS¶. Minimum number of vectors used in amplitude DIIS. Type: integer; Default: 2. CC_LAMBDA¶. Do solve lambda amplitute equations?. Type: boolean; Default: false. CC_MAXITER¶. Maximum number of iterations to determine the amplitudes. Type: integer; Default: 50. CHOLESKY¶. Do Cholesky decomposition of the ERI tensor. Type: boolean; Default: false. CHOLESKY_TOLERANCE¶. tolerance for Cholesky decomposition of the ERI tensor. Type: conv double; Default: 1.0e-4. COMPUT_S2¶. Do compute <S2> for DF-OMP2/DF-MP2?. Type: boolean; Default: false. CUTOFF¶. Cutoff value for numerical procedures. Type: integer; Default: 8. DO_DIIS¶. Do apply DIIS extrapolation?. Type: boolean; Default: true. DO_LEVEL_SHIFT¶. Do apply level shifting?. Type: boolean; Default: true. DO_SCS¶. Do perform spin-component-scaled OMP2 (SCS-OMP2)? In all computation, SCS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SCS-OMP2, one needs to set ‘DO_SCS’ to true. Type: boolean; Default: false. DO_SOS¶. Do perform spin-opposite-scaled OMP2 (SOS-OMP2)? In all computation, SOS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SOS-OMP2, one needs to set ‘DO_SOS’ to true. Type: boolean; Default: false. E3_SCALE¶. CEPA opposite-spin scaling value from SCS-CCSD. Type: double; Default: 0.25. EKT_IP¶. Do compute ionization potentials based on the extended Koopmans’ theorem?. Type: boolean; Default: false. E_CONVERGENCE¶. Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. HESS_TYPE¶. Type of the MO Hessian matrix. Type: string; Possible Values: APPROX_DIAG, APPROX_DIAG_EKT, APPROX_DIAG_HF",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__dfocc-1.html:1241,energy,energy,1241,psi4manual/1.0.0/autodir_options_c/module__dfocc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__dfocc-1.html,2,['energy'],['energy']
Energy Efficiency," and a second delta correction, etc.. Each is activated by its; stage_wfn keyword and is only allowed if all preceding stages are active. Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy.; The cbs() function requires, at a minimum, name='scf' and scf_basis; keywords to be specified for reference-step only jobs and name and; corl_basis keywords for correlated jobs.; The following energy methods have been set up for cbs(). scf; hf; mp2; mp2.5; mp3; mp4(sdq); mp4; mpn. omp2; omp2.5; omp3; olccd; lccd; lccsd; cepa(0); cepa(1). cepa(3); acpf; aqcc; qcisd; cc2; ccsd; fno-ccsd; bccd. cc3; qcisd(t); ccsd(t); fno-ccsd(t); bccd(t); cisd; cisdt. cisdtq; cin; fci; mrccsd; mrccsd(t); mrccsdt; mrccsdt(q). Parameters:; name (string) – 'scf' || 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be 'scf'. Overruled if stage_wfn keywords supplied. scf_wfn (string) – \(\Rightarrow\) 'scf' \(\Leftarrow\) || 'c4-scf' || etc.; Indicates the energy method for which the reference energy is to be; obtained. Generally unnecessary, as ‘scf’ is the scf in PSI4 but; can be used to direct lone scf components to run in PSI4 or Cfour; in a mixed-program composite method. corl_wfn (string) – 'mp2' || 'ccsd(t)' || etc.; Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with name or as the unlabeled; first argument to the function. delta_wfn (string) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. delta_wfn_lesser (string) – \(\Rightarrow\) corl_wfn \(\Leftarrow\) || 'mp2' || etc.; Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtai",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/cbs-1.html:3432,energy,energy,3432,psi4manual/1.2.1/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/cbs-1.html,4,['energy'],['energy']
Energy Efficiency," and are described in MCSCF: Multi-Configurational Self-Consistent-Field.; As mentioned above, the DETCI module is designed for challenging; chemical systems for which simple CISD is not suitable. Because; CI wavefunctions which go beyond CISD (such as RAS CI) are fairly complex,; typically the DETCI code will be used in cases where the; tradeoffs between computational expense and completeness of the; model space are nontrivial. Hence, the user is advised to develop; a good working knowledge of multi-reference and RAS CI methods before; attempting to use the program for a production-level project. This user’s; manual will provide only an elementary introduction to the most; important keywords. Additional information is available in the complete; list of keywords for DETCI provided in Appendix DETCI.; For single-reference CI computations, the easiest way to invoke a CI; computation with DETCI is simply to call energy(), optimize(), etc.,; with the common name for that CI wavefunction, like energy('cisd'); for a CISD single-point energy. The Python driver; recognizes cisd, cisdt, and cisdtq. As mentioned above, codes; written specifically for CISD will be more efficient than DETCI for a; CISD computation, and energy('cisd') by default will call other,; more efficient modules. To force a CISD computation with DETCI,; set QC_MODULE = DETCI.; Higher order single-reference CI wavefunctions, like those including singles through; 6-fold excitations, can be invoked using numbers, like ci6. A full; CI can be specified by fci. More complicated CI computations, like; RASCI, can be performed by setting the appropriate keywords and calling the; module generically like energy('detci'). The latter approach; will also work for any of the previously-mentioned CI wavefunctions for; which the driver has built-in shortcuts, so long as the relevant options; (especially EX_LEVEL) are set appropriately. Some; examples of single-refence CI, RASCI, and full CI computations are provided; in p",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/detci-1.html:4793,energy,energy,4793,psi4manual/1.4.0/detci-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/detci-1.html,18,['energy'],['energy']
Energy Efficiency," and bohr. :returns: *unit_conv* Conversion factor between the geometry specification units and bohr; """"""; unit_name = self.molecule.units(); if unit_name == ""Angstrom"":; unit_conv = qcel.constants.bohr2angstroms; elif unit_name == ""Bohr"":; unit_conv = 1.0; else:; raise Exception('Unrecognized unit type: ' + str(unit_name)). return unit_conv. # Respond to the <NATOMS command; def send_natoms(self):; """""" Send the number of atoms through MDI; """"""; natom = self.molecule.natom(); MDI_Send(natom, 1, MDI_INT, self.comm); return natom. # Respond to the <COORDS command; def send_coords(self):; """""" Send the nuclear coordinates through MDI; """"""; coords = self.molecule.geometry().np.ravel(); MDI_Send(coords, len(coords), MDI_DOUBLE, self.comm); return coords. # Respond to the <CHARGES command; def send_charges(self):; """""" Send the nuclear charges through MDI. :returns: *charges* Atomic charges; """"""; natom = self.molecule.natom(); charges = [self.molecule.charge(iatom) for iatom in range(natom)]; MDI_Send(charges, natom, MDI_DOUBLE, self.comm); return charges. # Respond to the <MASSES command; def send_masses(self):; """""" Send the nuclear masses through MDI. :returns: *masses* Atomic masses; """"""; natom = self.molecule.natom(); molecule_dict = self.molecule.to_dict(); masses = molecule_dict['mass']; MDI_Send(masses, natom, MDI_DOUBLE, self.comm); return masses. # Respond to the <ELEMENTS command; def send_elements(self):; """""" Send the atomic number of each nucleus through MDI. :returns: *elements* Element of each atom; """"""; natom = self.molecule.natom(); elements = [self.molecule.true_atomic_number(iatom) for iatom in range(natom)]; MDI_Send(elements, natom, MDI_INT, self.comm); return elements. # Respond to the <ENERGY command; def send_energy(self):; """""" Send the total energy through MDI. :returns: *energy* Energy of the system; """"""; self.run_scf(); MDI_Send(self.energy, 1, MDI_DOUBLE, self.comm); return self.energy. # Respond to the <FORCES command; def send_forces(self):; """"""",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html:5212,charge,charge,5212,psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html,10,['charge'],"['charge', 'charges']"
Energy Efficiency," and checks that symmetry of the Molecule observes the basis assignment to atoms. dfscf-bz2; Benzene Dimer DF-HF/cc-pVDZ. mp3-grad1; MP3 cc-pVDZ gradient for the H2O molecule. dfcasscf-fzc-sp; CASSCF/6-31G** energy point. cc38; RHF-CC2-LR/cc-pVDZ static polarizabilities of HOF molecule. mints6; Patch of a glycine with a methyl group, to make alanine, then DF-SCF energy calculation with the cc-pVDZ basis set. mp2-def2; Test case for Binding Energy of C4H5N (Pyrrole) with CO2 using MP2/def2-TZVPP. sapt-dft2; SAPT(DFT) aug-cc-pVDZ computation for the water dimer interaction energy. rasscf-sp; 6-31G** H2O Test RASSCF Energy Point will default to only singles and doubles in the active space. dft-grad-meta; meta-GGA gradients of water and ssh molecules reference gradients updated due to new BraggSlater radii. dfomp2-grad3; Tests OMP2 gradient in the presence of a dipole field. opt-irc-1; Compute the IRC for HOOH torsional rotation at the RHF/DZP level of theory. dct9; UHF-ODC-12 and RHF-ODC-12 single-point energy for H2O. This performs a simultaneous update of orbitals and cumulants, using DIIS extrapolation. Four-virtual integrals are handled in the AO basis, where integral transformation is avoided. In the next RHF-ODC-12 computation, AO_BASIS=NONE is used, where four-virtual integrals are transformed into MO basis. cc47; EOM-CCSD/cc-pVDZ on H2O2 with two excited states in each irrep. omp3-2; OMP3 cc-pCVDZ energy with ROHF initial guess for the NO radical. cc12; Single point energies of multiple excited states with EOM-CCSD. cc30; CCSD/sto-3g optical rotation calculation (length gauge only) at two frequencies on methyloxirane. nbody-intermediates; HF/cc-pVDZ many body energies of an arbitrary noble gas trimer complex Size vs cost tradeoff is rough here. sapt4; SAPT2+(3) aug-cc-pVDZ computation of the formamide dimer interaction energy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. This example uses frozen core as well as MP2 natural orbital ap",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html:30979,energy,energy,30979,psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency," and cisd are working. dcft4; DCFT calculation for the HF+ using DC-06 functional. This performs both two-step and simultaneous update of the orbitals and cumulant using DIIS extrapolation. Four-virtual integrals are first handled in the MO Basis for the first two energy computations. In the next two the ao_basis=disk algorithm is used, where the transformation of integrals for four-virtual case is avoided. The computation is then repeated using the DC-12 functional with the same algorithms. dfrasscf-sp; 6-31G** H2O Test RASSCF Energy Point will default to only singles and doubles in the active space. opt6; Various constrained energy minimizations of HOOH with cc-pvdz RHF Internal-coordinate constraints in internal-coordinate optimizations. cdomp2-1; OMP2 cc-pVDZ energy for the H2O molecule. freq-isotope; Vibrational and thermo analysis of several water isotopologs. Demonstrates Hessian reuse for different temperatures and pressures but not for different isotopologs. cc36; CC2(RHF)/cc-pVDZ energy of H2O. cbs-delta-energy; Extrapolated energies with delta correction. dfccd1; DF-CCD cc-pVDZ energy for the H2O molecule. psimrcc-ccsd_t-1; Mk-MRCCSD(T) single point. CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. omp3-2; OMP3 cc-pVDZ energy with ROHF initial guess for the NO radical. dfomp3-2; DF-OMP3 cc-pVDZ energy for the H2O+ cation. ghosts; Density fitted MP2 cc-PVDZ/cc-pVDZ-RI computation of formic acid dimer binding energy using explicit specification of ghost atoms. This is equivalent to the dfmp2_1 sample but uses both (equivalent) specifications of ghost atoms in a manual counterpoise correction. cc26; Single-point gradient, analytic and via finite-differences of 2-1A1 state of H2O with EOM-CCSD. cbs-xtpl-freq; Various gradients for a strained helium dimer and water molecule. dft1-alt; DFT Functional Test. cc14; ROHF-CCSD/cc-pVDZ CH2 geometry optimization via analytic gradients. tu6-cp-ne2; Example potential energy surfa",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html:12250,energy,energy,12250,psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency," and correlation energy component [H]; for the MP2.5 level of theory. MP3 TOTAL ENERGY¶. MP3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP3 level of theory. MPn TOTAL ENERGY¶. MPn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Möller–Plesset perturbation theory level.; n is MP perturbation order. NUCLEAR REPULSION ENERGY¶; The nuclear repulsion energy contribution [H] to the total SCF energy.; Quantity in Eq. (3). (2). ONE-ELECTRON ENERGY¶; The one-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (3). SAPT DISP ENERGY¶. SAPT ELST ENERGY¶. SAPT EXCH ENERGY¶. SAPT IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [H] for the the; requested SAPT level of theory. The sum of these four components yields; SAPT ENERGY. SAPT ENERGY¶; The total electronic interaction energy [H] for the requested SAPT; level of theory. SAPT SAPT0 ENERGY¶. SAPT SAPT2 ENERGY¶. SAPT SAPT2+ ENERGY¶. SAPT SAPT2+(3) ENERGY¶. SAPT SAPT2+3 ENERGY¶; The total electronic interaction energy [H] for the labeled SAPT level; of theory. SCF DIPOLE X¶. SCF DIPOLE Y¶. SCF DIPOLE Z¶; The three components of the SCF dipole [Debye]. SCF QUADRUPOLE XX¶. SCF QUADRUPOLE XY¶. SCF QUADRUPOLE XZ¶. SCF QUADRUPOLE YY¶. SCF QUADRUPOLE YZ¶. SCF QUADRUPOLE ZZ¶; The six components of the SCF quadrupole [Debye Ang]. SCF TOTAL ENERGY¶; The total electronic energy [H] of the SCF stage of the calculation.; The CORRELATION ENERGY variables from subsequent stages of a; calculation are often the corresponding TOTAL ENERGY; variables less this quantity. Constructed from Eq. (3),; where this quantity is . (3); Unless the method includes a dispersion correction, this quantity is; equal to HF TOTAL ENERGY (for HF) or; DFT FUNCTIONAL TOTAL ENERGY (for; DFT). Unless the method is a DFT double-hybrid, this quanti",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:13017,energy,energy,13017,psi4manual/4.0b3/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html,2,['energy'],['energy']
Energy Efficiency," and lineno arg9 (optional); C++ signature :. void add_atom(N3psi8MoleculeE {lvalue},i,d,d,d,PKc,d,d,i). psi4.Molecule.atom_at_position()¶; Python Library Documentation: method atom_at_position; atom_at_position(...) unbound psi4.Molecule method. atom_at_position( (Molecule)arg1, (float)arg2, (float)arg3) -> int :. Tests to see if an atom is at the position arg2 with a given tolerance arg3; C++ signature :. i atom_at_position(N3psi8MoleculeE {lvalue},Pd,d). psi4.Molecule.center_of_mass()¶; Python Library Documentation: method center_of_mass; center_of_mass(...) unbound psi4.Molecule method. center_of_mass( (Molecule)arg1) -> Vector3 :. Computes center of mass of molecule (does not translate molecule); C++ signature :. N3psi7Vector3E center_of_mass(N3psi8MoleculeE {lvalue}). psi4.Molecule.charge()¶; Python Library Documentation: method charge; charge(...) unbound psi4.Molecule method. charge( (Molecule)arg1, (int)arg2) -> float :. Gets charge of atom; C++ signature :. d charge(N3psi8MoleculeE {lvalue},i). psi4.Molecule.clone()¶; Python Library Documentation: method clone; clone(...) unbound psi4.Molecule method. clone( (Molecule)arg1) -> Molecule :. Returns a new Molecule identical to arg1; C++ signature :. N3psi8MoleculeE clone(N3psi8MoleculeE {lvalue}). psi4.Molecule.create_molecule_from_string()¶; Python Library Documentation: built-in function create_molecule_from_string; create_molecule_from_string(...). create_molecule_from_string( (str)arg1) -> Molecule :. Returns a new Molecule with member data from the geometry string arg1 in psi4 format; C++ signature :. N5boost10shared_ptrIN3psi8MoleculeEEE create_molecule_from_string(Ss). psi4.Molecule.create_psi4_string_from_molecule()¶; Python Library Documentation: method create_psi4_string_from_molecule; create_psi4_string_from_molecule(...) unbound psi4.Molecule method. create_psi4_string_from_molecule( (Molecule)arg1) -> str :. Gets a string reexpressing in input format the current states of the molecule; C++ signat",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:238146,charge,charge,238146,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['charge'],['charge']
Energy Efficiency," and numerical differentiation. cc42; RHF-CC2-LR/STO-3G optical rotation of (S)-methyloxirane. gauge = length, omega = (589 355 nm). fci-dipole; 6-31G H2O Test FCI Energy Point. docs_psimod; This test is used to construct the documentation; it is not suitable for emulation by users. tu4-h2o-freq; Frequencies for H2O HF/cc-pVDZ at optimized geometry. dfmp2_1; Density fitted MP2 cc-PVDZ/cc-pVDZ-RI computation of formic acid dimer binding energy using automatic counterpoise correction. Monomers are specified using Cartesian coordinates. dcft3; DCFT-06 calculation for the He dimer. This performs a simultaneous update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the AO Basis, using integrals stored on disk. cc4a; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. This version tests the FROZEN_DOCC option explicitly. cisd-h2o+-1; 6-31G** H2O+ Test CISD Energy Point. cc8b; ROHF-CCSD cc-pVDZ frozen-core energy for the state of the CN radical, with Cartesian input. mints3; Test individual integral objects for correctness. cc2; 6-31G** H2O CCSD optimization by energies, with Z-Matrix input. cc45; RHF-EOM-CC2/cc-pVDZ lowest two states of each symmetry of H2O. fci-tdm-2; BH-H2+ FCI/cc-pVDZ Transition Dipole Moment. psimrcc-ccsd_t-2; Mk-MRCCSD(T) single point. CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. sad1; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. rasci-h2o; RASCI/6-31G** H2O Energy Point. cc17; Single point energies of multiple excited states with EOM-CCSD. tu3-h2o-opt; Optimize H2O HF/cc-pVDZ. mrcc2; CCSDT(Q) cc-pVDZ energy for the H2O molecule using MRCC. This example b",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodoc_testsuite-1.html:10096,energy,energy,10096,psi4manual/4.0b2/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodoc_testsuite-1.html,4,['energy'],['energy']
Energy Efficiency," and open-shell monomers.; Higher-order SAPT and SAPT(DFT) are currently available only; for computation of interactions between; closed-shell singlets. The SAPT codes in PSI4 have been written; to utilize density fitting, which is much faster than using conventional; 4-index electron repulsion integrals. This happens automatically and; does not require any additional keywords to be specified (both the; SAPT computations and the underlying Hartree-Fock computations will; utilize density fitting).; For SAPT(DFT), the user will need to manually specify the GRAC shift of; both monomers, defined by the difference of ionization potential (IP) and; Kohn-Sham HOMO energy. The ionization potential data for many common molecules; is available in NIST Chemistry Webbook. Alternatively, one can estimate the; ionization potential of molecule by computing the energy difference between; the molecule as given, and the molecule after one electron has been removed; (e.g., the energy difference between a neutral molecule and its cation).; The values of GRAC shifts should be given in Hartree. For the example above,; the GRAC shift value of both molecules are calculated to be 0.1307 (using experimental; IP from CCCBDB), and the user would specify them using the following keywords:; set globals {; sapt_dft_grac_shift_a 0.1307; sapt_dft_grac_shift_b 0.1307; }. A complete, minimal example of a SAPT(DFT) computation is given below.; molecule {; 0 1; O -1.551007 -0.114520 0.000000; H -1.934259 0.762503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.680398 -0.373741 -0.758561; H 1.680398 -0.373741 0.758561. units angstrom; }. set {; basis aug-cc-pVDZ; sapt_dft_grac_shift_a 0.1307; sapt_dft_grac_shift_b 0.1307; }. energy('sapt(dft)'). As already mentioned above, the SAPT0 module for open-shell cases can also; use exact integrals for all terms except for dispersion. In practice,; density fitting is considerably faster and introduces negligible errors, thus; i",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/sapt.html:13396,energy,energy,13396,psi4manual/1.7.x/sapt.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/sapt.html,4,['energy'],['energy']
Energy Efficiency," and open-shell monomers.; Higher-order SAPT and SAPT(DFT) are currently available only; for computation of interactions between; closed-shell singlets. The SAPT codes in PSI4 have been written; to utilize density fitting, which is much faster than using conventional; 4-index electron repulsion integrals. This happens automatically and; does not require any additional keywords to be specified (both the; SAPT computations and the underlying Hartree-Fock computations will; utilize density fitting).; For SAPT(DFT), the user will need to manually specify the GRAC shift of; both monomers, defined by the difference of ionization potential (IP) and; Kohn-Sham HOMO energy. The ionization potential data for many common molecules; is available in NIST Chemistry Webbook. Alternatively, one can estimate the; ionization potential of molecule by computing the energy difference between; the molecule as given, and the molecule after one electron has been removed; (e.g., the energy difference between a neutral molecule and its cation).; The values of GRAC shifts should be given in Hartree. For the example above,; the GRAC shift value of both molecules are calculated to be 0.1307, and the; user would specify them using the following keywords:; set globals {; sapt_dft_grac_shift_a 0.1307; sapt_dft_grac_shift_b 0.1307; }. A complete, minimal example of a SAPT(DFT) computation is given below.; molecule {; 0 1; O -1.551007 -0.114520 0.000000; H -1.934259 0.762503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.680398 -0.373741 -0.758561; H 1.680398 -0.373741 0.758561. units angstrom; }. set {; basis aug-cc-pVDZ; sapt_dft_grac_shift_a 0.1307; sapt_dft_grac_shift_b 0.1307; }. energy('sapt(dft)'). As already mentioned above, the SAPT0 module for open-shell cases can also; use exact integrals for all terms except for dispersion. In practice,; density fitting is considerably faster and introduces negligible errors, thus; it is the preferred method for open-s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/sapt-1.html:11941,energy,energy,11941,psi4manual/1.4.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/sapt-1.html,5,['energy'],['energy']
Energy Efficiency," and psi4. cfour/sp-rhf-mp2; single-point MP2/qz2p on water. cfour/kw-3; Basis set spherical/Cartesian with cfour_basis and cfour_spherical. cfour/sp-rhf-scf; single-point HF/qz2p on water. cfour/sp-uhf-scf; single-point HF/qz2p on NH2. cfour/sp-uhf-ccsd_t_-ao; single-point CCSD(T)/qz2p on NH2 with aobasis. cfour/sp-rohf-ccsd_t_-ao; single-point CCSD(T)/qz2p on NH2 with aobasis. cfour/kw-4; Basis set spherical/Cartesian with basis and puream. cfour/opt-rhf-mp2; optimization MP2/cc-pvtz on water. cfour/opt-rhf-ccsd_t_; optimization CCSD(T)/dzp on water. cfour/pywrap-db1; Database calculation, so no molecule section in input file. Portions of the full databases, restricted by subset keyword, are computed by sapt0 and dfmp2 methods. cfour/sp-rhf-ccsdt; single-point CCSDT/qz2p on water. cfour/sp-uhf-ccsd; single-point CCSD/qz2p on NH2. cfour/pywrap-cbs1; Various basis set extrapolation tests only in Cfour instead of Psi4. cfour/sp-uhf-cc3; single-point CC3/qz2p on NH2. cfour/psi-rhf-mp3; MP3 energy components. Checks that computed identically between cfour and psi4. cfour/psi-ghost-grad; MP2 optimization of dimers with one momomer ghosted. Gradients after three opt cycles are compared with those from psi4. cfour/kw-7; Translating psi4 options to cfour, part i. cfour/sp-rhf-ccsd_t_-ecc; single-point CCSD(T)/qz2p on water with ecc module. cfour/sp-rohf-ccsd_t_-fc; single-point CCSD(T)/qz2p on NH2 with ecc, aobasis, frozen-core. cfour/mints5; geometries from a variety of input formats. references from psi4, testing whether geometry strings read identically for psi4/cfour. cfour/sp-uhf-ccsd_t_-ecc; single-point CCSD(T)/qz2p on NH2 with ecc. cfour/sp-rhf-ccsd_t_-ao-ecc; single-point CCSD(T)/qc2p on water with ecc, aobasis. cfour/sp-rohf-ccsd_t_; single-point CCSD(T)/qz2p on NH2. cfour/sp-rhf-ccsd_t_-ao; single-point CCSD(T)/qz2p on water with aobasis. cfour/psi-uhf-mp3; UHF MP3 energy components. Checks that converted identically between cfour and psi4. cfour/sp-rohf-ccsd; s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_cfour.html:1812,energy,energy,1812,psi4manual/1.8.x/autodoc_testsuite_cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_cfour.html,1,['energy'],['energy']
Energy Efficiency," and so faulty for close; (esp. hydrogen-bonded) fragments. Original code from; Michael S. Marshall. psi4.Molecule.Z()¶; Python Library Documentation: method Z; Z(...) unbound psi4.Molecule method. Z( (Molecule)arg1, (int)arg2) -> float :. Nuclear charge of atom; C++ signature :. d Z(N3psi8MoleculeE {lvalue},i). psi4.Molecule.activate_all_fragments()¶; Python Library Documentation: method activate_all_fragments; activate_all_fragments(...) unbound psi4.Molecule method. activate_all_fragments( (Molecule)arg1) -> None :. Sets all fragments in the molecule to be active; C++ signature :. void activate_all_fragments(N3psi8MoleculeE {lvalue}). psi4.Molecule.add_atom()¶; Python Library Documentation: method add_atom; add_atom(...) unbound psi4.Molecule method. add_atom( (Molecule)arg1, (int)arg2, (float)arg3, (float)arg4, (float)arg5, (str)arg6, (float)arg7, (float)arg8, (int)arg9) -> None :. Adds to Molecule arg1 an atom with atomic number arg2, Cartesian coordinates in Bohr (arg3, arg4, arg5), atomic symbol arg6, mass arg7, charge arg8 (optional), and lineno arg9 (optional); C++ signature :. void add_atom(N3psi8MoleculeE {lvalue},i,d,d,d,PKc,d,d,i). psi4.Molecule.atom_at_position()¶; Python Library Documentation: method atom_at_position; atom_at_position(...) unbound psi4.Molecule method. atom_at_position( (Molecule)arg1, (float)arg2, (float)arg3) -> int :. Tests to see if an atom is at the position arg2 with a given tolerance arg3; C++ signature :. i atom_at_position(N3psi8MoleculeE {lvalue},Pd,d). psi4.Molecule.center_of_mass()¶; Python Library Documentation: method center_of_mass; center_of_mass(...) unbound psi4.Molecule method. center_of_mass( (Molecule)arg1) -> Vector3 :. Computes center of mass of molecule (does not translate molecule); C++ signature :. N3psi7Vector3E center_of_mass(N3psi8MoleculeE {lvalue}). psi4.Molecule.charge()¶; Python Library Documentation: method charge; charge(...) unbound psi4.Molecule method. charge( (Molecule)arg1, (int)arg2) -> float :.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:237139,charge,charge,237139,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['charge'],['charge']
Energy Efficiency," and testing purposes. cc23; ROHF-EOM-CCSD/DZ analytic gradient lowest state of H2O+ (A1 excitation). cc54; CCSD dipole with user-specified basis set. ocepa-freq1; OCEPA cc-pVDZ freqs for C2H2. cc26; Single-point gradient, analytic and via finite-differences of 2-1A1 state of H2O with EOM-CCSD. fci-tdm; He2+ FCI/cc-pVDZ Transition Dipole Moment. rasci-c2-active; 6-31G* C2 Test RASCI Energy Point, testing two different ways of specifying the active space, either with the ACTIVE keyword, or with RAS1, RAS2, RESTRICTED_DOCC, and RESTRICTED_UOCC. ocepa-grad1; OCEPA cc-pVDZ gradient for the H2O molecule. dft3; DFT integral algorithms test, performing w-B97 RKS and UKS computations on water and its cation, using all of the different integral algorithms. This tests both the ERI and ERF integrals. tu2-ch2-energy; Sample UHF/6-31G** CH2 computation. cc16; UHF-B-CCD(T)/cc-pVDZ CH2 single-point energy (fzc, MO-basis ). sapt4; SAPT2+(3) aug-cc-pVDZ computation of the formamide dimer interaction energy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. This example uses frozen core as well as MP2 natural orbital approximations. cc47; EOM-CCSD/cc-pVDZ on H2O2 with two excited states in each irrep. dft-freq; Frequencies for H2O B3LYP/6-31G* at optimized geometry. mp2-grad1; MP2 cc-pVDZ gradient for the H2O molecule. scf3; are specified explicitly. ocepa-grad2; OCEPA cc-pVDZ gradient for the NO radical. dftd3-energy; Exercises the various DFT-D corrections, both through python directly and through c++. pywrap-db1; Database calculation, so no molecule section in input file. Portions of the full databases, restricted by subset keyword, are computed by sapt0 and dfmp2 methods. cc52; CCSD Response for H2O2. pywrap-db2; Database calculation, run in sow/reap mode. cc50; EOM-CC3(ROHF) on CH radical with user-specified basis and properties for particular root. omp2-2; OMP2 cc-pVDZ energy with ROHF initial guess orbitals for the NO radical. cc12; Single point energie",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_testsuite-1.html:11685,energy,energy,11685,psi4manual/4.0b4/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_testsuite-1.html,8,['energy'],['energy']
Energy Efficiency," and the basis cutoffs, but it is likely that significant speed gains may be; realized by relaxing the basis cutoff tolerance, with negligible decrease in; accuracy.; Small density values can introduce numerical instabilities with some functionals that; can result in trailing SCF convergence issues or even numerical failures (NaNs).; If the default settings of the LibXC library are insufficient, a custom value can be; request by setting DFT_DENSITY_TOLERANCE. For notorious cases a value of 1E-10; is sensible.; An example of a fully specified grid is as follows:; molecule {; H; H 1 0.7; }. set {; basis cc-pvdz; scf_type df; dft_spherical_points 590 # Often needed; dft_radial_points 99 # Often needed; dft_radial_scheme treutler # Rarely needed; dft_nuclear_scheme treutler # Rarely needed; dft_density_tolerance 1.0E-10 # Rarely needed; dft_basis_tolerance 1.0E-11 # Can speed things up, but benchmark the error; dft_pruning_scheme robust # Generally safe and will speed things up; }. energy('b3lyp'). ERI Algorithms¶; The ERI algorithms for the Coulomb and hybrid exchange are identical to; those for Hartree–Fock. However, for LRC functionals, the long-range; exchange contributions to the Kohn–Sham matrix have only been implemented in the; DF and DIRECT algorithms. The use of DF is highly recommended for KS-DFT, as the; errors incurred by the density fitting approximation (in a proper -JKFIT; auxiliary basis) are orders of magnitude smaller than the accuracy of any known; functional. IP Fitting¶; In collaboration with the Bredas group, we have developed an automatic procedure; for IP fitting of LRC functionals, based on a modified Regula-Falsi method. To; perform IP fitting, one simply calls the ip_fitting() Python macro, after; setting up a standard LRC UKS computation. A representative example is:; memory 512 MB. molecule h2o {; 0 1 # must be neutral; O; H 1 1.0; H 1 1.0 2 104.5; # IP fitting runs in C1 symmetry; }. set {; reference uks # UKS, as we need to do neutral/cati",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/dft-1.html:23687,energy,energy,23687,psi4manual/1.4.0/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/dft-1.html,5,['energy'],['energy']
Energy Efficiency," and the basis cutoffs, but it is likely that significant speed gains may be; realized by relaxing the basis cutoff tolerance, with negligible decrease in; accuracy.; Small density values can introduce numerical instabilities with some functionals that; can result in trailing SCF convergence issues or even numerical failures (NaNs).; If the default settings of the LibXC library are insufficient, a custom value can be; request by setting DFT_DENSITY_TOLERANCE. For notorious cases a value of 1E-10; is sensible.; An example of a fully specified grid is as follows:; molecule {; H; H 1 0.7; }. set {; basis cc-pvdz; scf_type df; dft_spherical_points 590 # Often needed; dft_radial_points 99 # Often needed; dft_radial_scheme treutler # Rarely needed; dft_nuclear_scheme treutler # Rarely needed; dft_density_tolerance 1.0E-10 # Rarely needed; dft_basis_tolerance 1.0E-11 # Can speed things up, but benchmark the error; dft_pruning_scheme robust # Generally safe and will speed things up; }. energy('b3lyp'). ERI Algorithms¶; The ERI algorithms for the Coulomb and hybrid exchange are identical to; those for Hartree–Fock. However, for LRC functionals, the long-range; exchange contributions to the Kohn–Sham matrix have only been implemented in the; DF and DIRECT algorithms. The use of DF is highly recommended for KS-DFT, as the; errors incurred by the density fitting approximation (in a proper -JKFIT; auxiliary basis) are orders of magnitude smaller than the accuracy of any known; functional.; Key representative methods supported by the SCF module in PSI4 are; detailed in Table SCF Capabilities. Note; from SCF algorithm and convergence criteria defaults by calculation type 1 that these SCF-level methods default to; density-fitted reference; use SCF_TYPE to select an alternate; algorithm. SCF-level methods have no alternate implementations. Detailed capabilities of the SCF module. “✓” runs analytically. Single underline “✓̲” is default module when QC_MODULE unspecified. Double underli",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/dft.html:23760,energy,energy,23760,psi4manual/1.7.x/dft.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/dft.html,4,['energy'],['energy']
Energy Efficiency," and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. psimrcc-fd-freq1; Mk-MRCCSD single point. O2 state described using the Ms = 0 component of the triplet. Uses ROHF triplet orbitals. rasci-h2o; RASCI/6-31G** H2O Energy Point. cc17; Single point energies of multiple excited states with EOM-CCSD. tu3-h2o-opt; Optimize H2O HF/cc-pVDZ. mrcc2; CCSDT(Q) cc-pVDZ energy for the H2O molecule using MRCC. This example builds up from CCSD. First CCSD, then CCSDT, finally CCSDT(Q). cc21; ROHF-EOM-CCSD/DZ analytic gradient lowest excited state of H2O+ (B1 excitation). opt4; SCF cc-pVTZ geometry optimzation, with Z-matrix input. cc13a; UHF-CCSD(T)/cc-pVDZ CH2 geometry optimization via analytic gradients. mpn-bh; MP(n)/aug-cc-pVDZ BH Energy Point, with n=2-19. Compare against M. L. Leininger et al., J. Chem. Phys. 112, 9213 (2000). pywrap-checkrun-uhf; This checks that all energy methods can run with a minimal input and set symmetry. omp2_5-grad2; OMP2.5 cc-pVDZ gradient for the NO radical. cc38; RHF-CC2-LR/cc-pVDZ static polarizabilities of HOF molecule. mrcc3; CCSD(T) cc-pVDZ geometry optimization for the H2O molecule using MRCC. opt3; SCF cc-pVDZ geometry optimzation, with Z-matrix input. omp2_5-2; OMP2 cc-pVDZ energy for the H2O molecule. cc3; cc3: RHF-CCSD/6-31G** H2O geometry optimization and vibrational frequency analysis by finite-differences of gradients. scf-bz2; Benzene Dimer Out-of-Core HF/cc-pVDZ. cc51; EOM-CC3/cc-pVTZ on H2O. fci-h2o-2; 6-31G H2O Test FCI Energy Point. mp2-grad2; MP2 cc-pVDZ gradient for the NO radical. cc31; CCSD/sto-3g optical rotation calculation (both gauges) at two frequencies on methyloxirane. psimrcc-ccsd_t-1; Mk-MRCCSD(T) single point. CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. cc11; Frozen-core CCSD(ROHF)/cc-pVDZ on CN radical with disk-based AO algorithm. pywrap-checkrun-rhf; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_testsuite-1.html:16058,energy,energy,16058,psi4manual/4.0b4/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_testsuite-1.html,4,['energy'],['energy']
Energy Efficiency," any correlation method is specified, ``scf_basis`` can default; to ``corl_basis``. :type corl_basis: :ref:`basis string <apdx:basisElement>`; :param corl_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the correlation energy. :type delta_basis: :ref:`basis string <apdx:basisElement>`; :param delta_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. :type delta2_basis: :ref:`basis string <apdx:basisElement>`; :param delta2_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. :type delta3_basis: :ref:`basis string <apdx:basisElement>`; :param delta3_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the third delta correction; to the correlation energy. :type delta4_basis: :ref:`basis string <apdx:basisElement>`; :param delta4_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the fourth delta correction; to the correlation energy. :type delta5_basis: :ref:`basis string <apdx:basisElement>`; :param delta5_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the fifth delta correction; to the correlation energy. * Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, ``'highest_1'``, which uses the best basis; set available. See `Extrapolation Schemes`_ for all available schemes. :type scf_scheme: function; :param scf_scheme: |dl| ``highest_1",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:59253,energy,energy,59253,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,1,['energy'],['energy']
Energy Efficiency," any correlation method is specified, ``scf_basis`` can default; to ``corl_basis``. :type corl_basis: :ref:`basis string <apdx:basisElement>`; :param corl_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the correlation energy. :type delta_basis: :ref:`basis string <apdx:basisElement>`; :param delta_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. :type delta2_basis: :ref:`basis string <apdx:basisElement>`; :param delta2_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. :type delta3_basis: :ref:`basis string <apdx:basisElement>`; :param delta3_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the third delta correction; to the correlation energy. :type delta4_basis: :ref:`basis string <apdx:basisElement>`; :param delta4_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the fourth delta correction; to the correlation energy. :type delta5_basis: :ref:`basis string <apdx:basisElement>`; :param delta5_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the fifth delta correction; to the correlation energy. * Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, ``'xtpl_highest_1'``, which uses the best basis; set available. See :ref:`sec:cbs_xtpl` for all available schemes. :type scf_scheme: function; :param scf_scheme: |dl| ``xtpl_high",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver_cbs.html:24561,energy,energy,24561,psi4manual/1.1.0/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver_cbs.html,2,['energy'],['energy']
Energy Efficiency," any correlation method is specified, ``scf_basis`` can default; to ``corl_basis``. :type corl_basis: :ref:`basis string <apdx:basisElement>`; :param corl_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the correlation energy. :type delta_basis: :ref:`basis string <apdx:basisElement>`; :param delta_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. :type delta2_basis: :ref:`basis string <apdx:basisElement>`; :param delta2_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. :type delta3_basis: :ref:`basis string <apdx:basisElement>`; :param delta3_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the third delta correction; to the correlation energy. :type delta4_basis: :ref:`basis string <apdx:basisElement>`; :param delta4_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the fourth delta correction; to the correlation energy. :type delta5_basis: :ref:`basis string <apdx:basisElement>`; :param delta5_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the fifth delta correction; to the correlation energy. * Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, ``'xtpl_highest_1'``, which uses the best basis; set available. See `Extrapolation Schemes`_ for all available schemes. :type scf_scheme: function; :param scf_scheme: |dl| ``xtpl",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:24203,energy,energy,24203,psi4manual/1.0.0/_modules/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html,1,['energy'],['energy']
Energy Efficiency," any; GPL dependencies. Capabilities¶; PSI4 can perform ab initio computations employing basis; sets of contracted Gaussian-type functions of virtually arbitrary; orbital quantum number. Many parts of PSI4 can recognize and; exploit the largest Abelian subgroup of the molecular point group.; Table Methods displays the range of theoretical methods; available in PSI4.; Geometry optimization can be performed using either analytic gradients; or energy points. Likewise, vibrational frequencies can be; computed by analytic second derivatives, by finite; differences of analytic gradients, or by finite differences of energies.; PSI4 can also compute an extensive list of one-electron properties.; For more tables with capabilities details:. Full Capabilities (first below) lists all methods; Capabilities Breakdown (second below) lists selected methods by reference, etc.; Module Capabilities lists selected methods by implementation; Energy, Energy (DFT), Energy (MRCC), Energy (CFOUR) fully list energy target methods; Gradient, Gradient (CFOUR) fully list gradient target methods; Frequency fully lists Hessian target methods. Summary of theoretical methods available in PSI4¶. Method [1]; Reference[2]; Type[2]; Variants[3]. Canonical; OO; FNO [4]; DLPNO. HF; RHF/UHF/ROHF/CUHF; CONV/DF/CD; E/G/H. DFT; RKS/UKS; CONV/DF/CD; E/G. DFT-D2, DFT-NL; RKS/UKS; CONV/DF/CD; E/G. DCT; RHF/UHF; CONV/DF; E/G. MP2; RHF/UHF/ROHF; CONV/DF/CD; E/G; E/G. E. MP3; RHF/UHF; CONV/DF/CD; E/G; E/G; E. MP2.5; RHF/UHF; CONV/DF/CD; E/G; E/G. MP4, MP4(SDQ); RHF; CONV; E. E. MPn; RHF; CONV; E. ZAPTn; ROHF; CONV; E. REMP2; RHF/UHF; CONV/DF/CD; E; E/G. LCCD; RHF/UHF; CONV/DF/CD; E/G; E/G; E. LCCSD, CEPA(0); RHF; CONV; E. E. CEPA(n), n=0,1,3; RHF; CONV; E. E. CCD; RHF; DF/CD; E/G. BCCD; RHF/UHF/ROHF; CONV; E. CC2; RHF/UHF/ROHF; CONV; E/G. CCSD; RHF/UHF/ROHF; CONV/DF/CD; E/G. E [5]. CCSD(T); RHF/UHF/ROHF; CONV/DF/CD; E/G. E [5]. A-CCSD(T); RHF; CONV/DF/CD; E. BCCD(T); RHF/UHF/ROHF; CONV; E. CC3; RHF/UHF/ROHF; CONV;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/introduction.html:24142,energy,energy,24142,psi4manual/1.7.x/introduction.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/introduction.html,1,['energy'],['energy']
Energy Efficiency," ao_basis=disk algorithm is used, where the transformation of integrals for four-virtual case is avoided. The computation is then repeated using the DC-12 functional with the same algorithms. dfrasscf-sp; 6-31G** H2O Test RASSCF Energy Point will default to only singles and doubles in the active space. opt6; Various constrained energy minimizations of HOOH with cc-pvdz RHF Internal-coordinate constraints in internal-coordinate optimizations. cdomp2-1; OMP2 cc-pVDZ energy for the H2O molecule. freq-isotope; Vibrational and thermo analysis of several water isotopologs. Demonstrates Hessian reuse for different temperatures and pressures but not for different isotopologs. cc36; CC2(RHF)/cc-pVDZ energy of H2O. cbs-delta-energy; Extrapolated energies with delta correction. dfccd1; DF-CCD cc-pVDZ energy for the H2O molecule. psimrcc-ccsd_t-1; Mk-MRCCSD(T) single point. CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. omp3-2; OMP3 cc-pVDZ energy with ROHF initial guess for the NO radical. dfomp3-2; DF-OMP3 cc-pVDZ energy for the H2O+ cation. ghosts; Density fitted MP2 cc-PVDZ/cc-pVDZ-RI computation of formic acid dimer binding energy using explicit specification of ghost atoms. This is equivalent to the dfmp2_1 sample but uses both (equivalent) specifications of ghost atoms in a manual counterpoise correction. cc26; Single-point gradient, analytic and via finite-differences of 2-1A1 state of H2O with EOM-CCSD. cbs-xtpl-freq; Various gradients for a strained helium dimer and water molecule. dft1-alt; DFT Functional Test. cc14; ROHF-CCSD/cc-pVDZ CH2 geometry optimization via analytic gradients. tu6-cp-ne2; Example potential energy surface scan and CP-correction for Ne2. mints2; A test of the basis specification. A benzene atom is defined using a ZMatrix containing dummy atoms and various basis sets are assigned to different atoms. The symmetry of the molecule is automatically lowered to account for the different basis sets. scf1; RHF c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html:12536,energy,energy,12536,psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency," appear in; the input file, so if the last four commands in the above example were to read; set basis cc-pVDZ; energy('ccsd'); set ccenergy print 3; set scf print 1. the commands that set the print level would be ineffective, as they would be; processed after the CCSD computation completes.; In PsiAPI mode, one can use the command set_options(); like below for general and module-specific options. Note that these values; should be of correct type, strings for strings, floats for floats like; convergences. The function ~psi4.core.clean_options that reinitializes; all options may also be useful to separate calculations in a PsiAPI; session.; psi4.set_options({; 'scf_type': 'pk',; 'e_convergence': 1.e-5,; 'soscf': True,; 'optking__geom_maxiter': 50; }). Basis Sets¶. Basis Sets; Built-In Basis Sets; Mixing Basis Sets; Decontracted Basis Sets; User-Defined Basis Sets; Inputting effective core potentials (ECPs). PSI Variables¶; To harness the power of Python, PSI4 makes the most pertinent results; of each computation available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of; H2 and H atom:; molecule h2 {; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h {; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol * (2*h_energy - h2_energy); print ""De=%f"" % D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module, and PSI Variables by Alpha defines them. These can be; accessed through the get_variable() function. For example, after; performing a density fitted MP2 computation, both the sp",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/psithoninput-1.html:7232,power,power,7232,psi4manual/1.4.0/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/psithoninput-1.html,8,['power'],['power']
Energy Efficiency," applicable for pure-PSI4 modules directs them to fulfil analogous roles; in the Cfour program (e.g., MAXITER is used to set; CFOUR_SCF_MAXCYC). This keyword translation only takes place; if the keywords are explicitly set in the input file (part of that; contract that you mean it), meaning that PSI4‘s defaults don’t; get imposed on Cfour. Also, in the case where a translatable pure-PSI4 keyword and its translation Cfour keyword are both set,; the value attached to the latter is always used. Below are a few; clarifying examples. uses \(10^{-7}\) SCF conv crit since that’s Cfour’s default; for CFOUR_SCF_CONV; 1energy('c4-scf'). uses \(10^{-6}\) SCF conv crit since default overwritten by; keyword; 1; 2set cfour_scf_conv 6; energy('c4-scf'). uses \(10^{-5}\) SCF conv crit since default overwritten by; SCF module keyword; 1; 2set d_convergence 5; energy('c4-scf'). uses \(10^{-6}\) SCF conv crit since default overwritten by; SCF module keyword (local scope works, too) where; the PSI4‘s more flexible float input has been rounded down to; the integer required by Cfour; 1; 2set scf d_convergence 5e-6; energy('c4-scf'). uses \(10^{-6}\) SCF conv crit since default overwritten; and Cfour module keyword trumps PSI4 SCF module keyword; 1; 2; 3set cfour_scf_conv 6; set d_convergence 8; energy('c4-scf'). The keyword translation feature is still in the proof-of-principle; stage, so only a handful (found here) of keywords participate. Note; Longtime Cfour users who may consider this keyword; translation a flaw rather than a feature can avoid it entirely by; confining keywords to the Cfour module along with; BASIS and PUREAM (opt, too?). Misc. Running¶; Naturally, in PSI4 multiple jobs can be run in succession from the input file.; Control optimizations with optking keywords HERE. Cfour GRD file is; written to PSI4 output file. Gradient transformed back into the frame; in which it was shipped off to Cfour is also written to the PSI4; output file and is available from input as get_gr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/cfour-1.html:32671,energy,energy,32671,psi4manual/1.1.0/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/cfour-1.html,2,['energy'],['energy']
Energy Efficiency," applicable for pure-PSI4 modules directs them to fulfil analogous roles; in the Cfour program (e.g., MAXITER is used to set; CFOUR_SCF_MAXCYC). This keyword translation only takes place; if the keywords are explicitly set in the input file (part of that; contract that you mean it), meaning that PSI4’s defaults don’t; get imposed on Cfour. Also, in the case where a translatable pure-PSI4 keyword and its translation Cfour keyword are both set,; the value attached to the latter is always used. Below are a few; clarifying examples. uses \(10^{-7}\) SCF conv crit since that’s Cfour’s default; for CFOUR_SCF_CONV; 1energy('c4-scf'). uses \(10^{-6}\) SCF conv crit since default overwritten by; keyword; 1; 2set cfour_scf_conv 6; energy('c4-scf'). uses \(10^{-5}\) SCF conv crit since default overwritten by; SCF module keyword; 1; 2set d_convergence 5; energy('c4-scf'). uses \(10^{-6}\) SCF conv crit since default overwritten by; SCF module keyword (local scope works, too) where; the PSI4’s more flexible float input has been rounded down to; the integer required by Cfour; 1; 2set scf d_convergence 5e-6; energy('c4-scf'). uses \(10^{-6}\) SCF conv crit since default overwritten; and Cfour module keyword trumps PSI4 SCF module keyword; 1; 2; 3set cfour_scf_conv 6; set d_convergence 8; energy('c4-scf'). The keyword translation feature is still in the proof-of-principle; stage, so only a handful (found here) of keywords participate. Note; Longtime Cfour users who may consider this keyword; translation a flaw rather than a feature can avoid it entirely by; confining keywords to the Cfour module along with; BASIS and PUREAM (opt, too?). Misc. Running¶; Naturally, in PSI4 multiple jobs can be run in succession from the input file.; Control optimizations with optking keywords HERE. Cfour GRD file is; written to PSI4 output file. Gradient transformed back into the frame; in which it was shipped off to Cfour is also written to the PSI4; output file and is available from input as get_gr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/cfour-1.html:32673,energy,energy,32673,psi4manual/1.2.1/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/cfour-1.html,4,['energy'],['energy']
Energy Efficiency," approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples. >>> # [1] Coupled-cluster singles and doubles calculation with psi code; >>> energy('ccsd'). >>> # [2] Charge-transfer SAPT calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). >>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). >>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). >>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy('fci', ref_wfn=cisd_wfn). >>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""CCSD/cc-pV[DT]Z""). >>> # [7] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> energy(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Psithon Functions: Invoking a Calculation; Single-Point Energy — energy(). © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/energy-1.html:22180,energy,energy,22180,psi4manual/1.4.0/energy-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/energy-1.html,12,['energy'],['energy']
Energy Efficiency," approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples. >>> # [1] Coupled-cluster singles and doubles calculation with psi code; >>> energy('ccsd'). >>> # [2] Charge-transfer SAPT calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). >>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). >>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). >>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy('fci', ref_wfn=cisd_wfn). >>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""CCSD/cc-pV[DT]Z""). >>> # [7] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> energy(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Psithon Functions: Invoking a Calculation; Single-Point Energy — energy(). © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/energy-1.html:22245,energy,energy,22245,psi4manual/1.5.0/energy-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/energy-1.html,12,['energy'],['energy']
Energy Efficiency," approximation when computing LS-THC factorization?. Type: boolean; Default: true. LS_THC_PRUNING_SCHEME (GLOBALS)¶GLOBALS (Expert) — Pruning scheme for LS-THC grids. Type: string; Default: ROBUST. LS_THC_RADIAL_POINTS (GLOBALS)¶GLOBALS — Number of radial points in LS-THC grid. Type: integer; Default: 10. LS_THC_S_EPSILON (GLOBALS)¶GLOBALS (Expert) — Tolerance for pseudoinversion of grid point overlap matrix (Parrish 2012 eq. 30). Type: double; Default: 1.0e-10. LS_THC_SPHERICAL_POINTS (GLOBALS)¶GLOBALS — Number of spherical points in LS-THC grid. Type: integer; Default: 50. LS_THC_WEIGHTS_TOLERANCE (GLOBALS)¶GLOBALS (Expert) — Grid weights cutoff for LS-THC grids. Type: conv double; Default: 1.0e-12. LSE (DETCI)¶DETCI — Do use least-squares extrapolation in iterative solution of CI vector?. Type: boolean; Default: false. LSE_COLLAPSE (DETCI)¶DETCI — Number of iterations between least-squares extrapolations. Type: integer; Default: 3. LSE_TOLERANCE (DETCI)¶DETCI — Minimum converged energy for least-squares extrapolation to be performed. Type: conv double; Default: 3. MADMP2_SLEEP (DFMP2)¶DFMP2 (Expert) — A helpful option, used only in debugging the MADNESS version. Type: integer; Default: 0. MAT_NUM_COLUMN_PRINT (GLOBALS)¶GLOBALS (Expert) — Number of columns to print in calls to Matrix::print_mat. Type: integer; Default: 5. MAX_ATTEMPTS (SCF)¶SCF (Expert) — When using STABILITY_ANALYSIS FOLLOW, maximum number of orbital optimization attempts to make the wavefunction stable. Type: integer; Default: 1. MAX_CCD_DIISVECS (SAPT)¶SAPT — Maximum number of vectors used in CCD-DIIS. Type: integer; Default: 10. MAX_DISP_G_CONVERGENCE (OPTKING)¶OPTKING — Convergence criterion for geometry optmization: maximum displacement (internal coordinates, atomic units). Type: conv double; Default: 1.2e-3. MAX_ENERGY_G_CONVERGENCE (OPTKING)¶OPTKING — Convergence criterion for geometry optmization: maximum energy change. Type: conv double; Default: 1.0e-6. MAX_FORCE_G_CONVERGENCE (OPTKING)",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_glossary_options_c.html:167643,energy,energy,167643,psi4manual/master/autodoc_glossary_options_c.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_glossary_options_c.html,1,['energy'],['energy']
Energy Efficiency," are active ""; ""symmetrize was about to be called. Please check symmetry dependent input ""; "", such as DOCC, is correct or turn off symmetry""). # Try to resymmetrize molecule if slightly broken.; molecule.symmetrize(core.get_option(""OPTKING"", ""CARTESIAN_SYM_TOLERANCE"")). if molecule.schoenflies_symbol() != initial_sym:; raise ValidationError(""Point group changed! (%s <-- %s) You should restart ""; ""using the last geometry in the output, after ""; ""carefully making sure all symmetry-dependent ""; ""input, such as DOCC, is correct."" % (current_sym, initial_sym)). kwargs['opt_iter'] = n; core.set_variable('GEOMETRY ITERATIONS', n). # Use orbitals from previous iteration as a guess; # set within loop so that can be influenced by fns to optimize (e.g., cbs); if (n > 1) and (not core.get_option('SCF', 'GUESS_PERSIST')):; core.set_local_option('SCF', 'GUESS', 'READ'). # We'll currently ignore the possibility that the gradient isn't needed; opt_calcs = opt_object.calculations_needed() # tuple of strings ('energy', 'gradient', etc). # Compute the gradient - no longer need to worry about opt_data being wiped; G, wfn = gradient(lowername, return_wfn=True, molecule=molecule, **kwargs); thisenergy = core.variable('CURRENT ENERGY'); opt_object.E = thisenergy; opt_object.gX = G.np. if core.get_option('OPTKING', 'CART_HESS_READ') and (n == 1):; opt_object.params.cart_hess_read = True; opt_object.params.hessian_file = f""{core.get_writer_file_prefix(molecule.name())}.hess""; # compute Hessian as requested; frequency wipes out gradient so stash it; elif 'hessian' in opt_calcs:; # compute hessian as requested. # procedures proctable analytic hessians; _, hess_wfn = frequencies(hessian_with_method,; molecule=molecule,; ref_gradient=G,; return_wfn=True,; **kwargs); opt_object.HX = hess_wfn.hessian().np. # force optking to update its molecule to psi4's.; # This allows for psi4 to rotate as desired. If optimizing in cartesians. rotation is not allowed; # Process gradient / hessian. Take step. Pr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html:73582,energy,energy,73582,psi4manual/1.7.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html,4,['energy'],['energy']
Energy Efficiency," are below. Input File; Description. cc24; Single point gradient of 1-2B1 state of H2O+ with EOM-CCSD. cc53; Matches Table II a-CCSD(T)/cc-pVDZ H2O @ 2.5 * Re value from Crawford and Stanton, IJQC 98, 601-611 (1998). soscf2; Triple and Singlet Oxygen energy SOSCF, also tests non-symmetric density matrices. cbs-xtpl-gradient; Various gradients for a strained helium dimer and water molecule. mints5; Tests to determine full point group symmetry. Currently, these only matter for the rotational symmetry number in thermodynamic computations. dcft-grad1; DCFT DC-06 gradient for the O2 molecule with cc-pVDZ basis set. pubchem2; Superficial test of PubChem interface. cepa-module; routing check on lccd, lccsd, cepa(0). cc4a; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. This version tests the FROZEN_DOCC option explicitly. decontract; RHF/cc-pvdz-decontract HCl single-point energy Testing the in line -decontract option for basis sets. dfomp2-grad2; OMP2 cc-pVDZ energy for the NO molecule. pywrap-all; Intercalls among python wrappers- database, cbs, optimize, energy, etc. Though each call below functions individually, running them all in sequence or mixing up the sequence is aspirational at present. Also aspirational is using the intended types of gradients. omp3-4; SCS-OMP3 cc-pVDZ geometry optimization for the H2O molecule. adc2; ADC/aug-cc-pVDZ on two water molecules that are distant from 1000 angstroms from each other. pywrap-db1; Database calculation, so no molecule section in input file. Portions of the full databases, restricted by subset keyword, are computed by sapt0 and dfmp2 methods. opt8; Various constrained energy minimizations of HOOH with cc-pvdz RHF. Cartesian-coordinate constrained optimizations of HOOH in Cartesians. pubchem1; Benzene vertical singlet-triplet energy difference computation, using the PubChem database to obtain the initial geometry, which is optimized at the HF/STO-3G level, before computing single point energi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/testsuite-1.html:1766,energy,energy,1766,psi4manual/1.0.0/testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/testsuite-1.html,2,['energy'],['energy']
Energy Efficiency," are explicitly set in the input file (part of that; contract that you mean it), meaning that PSI4‘s defaults don’t; get imposed on Cfour. Also, in the case where a translatable pure-PSI4 keyword and its translation Cfour keyword are both set,; the value attached to the latter is always used. Below are a few; clarifying examples. uses \(10^{-7}\) SCF conv crit since that’s Cfour’s default; for CFOUR_SCF_CONV; energy('c4-scf'). uses \(10^{-6}\) SCF conv crit since default overwritten by; keyword; set cfour_scf_conv 6; energy('c4-scf'). uses \(10^{-5}\) SCF conv crit since default overwritten by; SCF module keyword; set d_convergence 5; energy('c4-scf'). uses \(10^{-6}\) SCF conv crit since default overwritten by; SCF module keyword (local scope works, too) where; the PSI4‘s more flexible float input has been rounded down to; the integer required by Cfour; set scf d_convergence 5e-6; energy('c4-scf'). uses \(10^{-6}\) SCF conv crit since default overwritten; and Cfour module keyword trumps PSI4 SCF module keyword; set cfour_scf_conv 6; set d_convergence 8; energy('c4-scf'). The keyword translation feature is still in the proof-of-principle; stage, so only a handful (found here) of keywords participate. Note; Longtime Cfour users who may consider this keyword; translation a flaw rather than a feature can avoid it entirely by; confining keywords to the Cfour module along with; BASIS and PUREAM (opt, too?). Misc. Running¶; Naturally, in PSI4 multiple jobs can be run in succession from the input file.; Control optimizations with optking keywords HERE. Cfour GRD file is; written to PSI4 output file. Gradient transformed back into the frame; in which it was shipped off to Cfour is also written to the PSI4; output file and is available from input as get_gradient().; sandwich mode := molecule and cfour list within; Naturally, additional jobs can follow in the input file.; Depending on the nature of preceding or following jobs, it is prudent to; separate them with the followin",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/cfour-1.html:33807,energy,energy,33807,psi4manual/1.4.0/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/cfour-1.html,5,['energy'],['energy']
Energy Efficiency," are explicitly set in the input file (part of that; contract that you mean it), meaning that PSI4‘s defaults don’t; get imposed on Cfour. Also, in the case where a translatable pure-PSI4 keyword and its translation Cfour keyword are both set,; the value attached to the latter is always used. Below are a few; clarifying examples. uses \(10^{-7}\) SCF conv crit since that’s Cfour’s default; for CFOUR_SCF_CONV; energy('c4-scf'). uses \(10^{-6}\) SCF conv crit since default overwritten by; keyword; set cfour_scf_conv 6; energy('c4-scf'). uses \(10^{-5}\) SCF conv crit since default overwritten by; SCF module keyword; set d_convergence 5; energy('c4-scf'). uses \(10^{-6}\) SCF conv crit since default overwritten by; SCF module keyword (local scope works, too) where; the PSI4‘s more flexible float input has been rounded down to; the integer required by Cfour; set scf d_convergence 5e-6; energy('c4-scf'). uses \(10^{-6}\) SCF conv crit since default overwritten; and Cfour module keyword trumps PSI4 SCF module keyword; set cfour_scf_conv 6; set d_convergence 8; energy('c4-scf'). The keyword translation feature is still in the proof-of-principle; stage, so only a handful (found here) of keywords participate. Note; Longtime Cfour users who may consider this keyword; translation a flaw rather than a feature can avoid it entirely by; confining keywords to the Cfour module along with; BASIS and PUREAM (opt, too?). Misc. Running¶; Naturally, in PSI4 multiple jobs can be run in succession from the input file.; Control optimizations with optking keywords HERE. Cfour GRD file is; written to PSI4 output file. Gradient transformed back into the frame; in which it was shipped off to Cfour is also written to the PSI4; output file and is available from input as gradient().; sandwich mode := molecule and cfour list within; Naturally, additional jobs can follow in the input file.; Depending on the nature of preceding or following jobs, it is prudent to; separate them with the following:; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/cfour.html:33923,energy,energy,33923,psi4manual/1.7.x/cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/cfour.html,4,['energy'],['energy']
Energy Efficiency," are from Lan Cheng’s implementation in Cfour. cbs-xtpl-nbody; RHF interaction energies using nbody and cbs parts of the driver Ne dimer with mp2/v[dt]z + d:ccsd(t)/vdz. sapt1; SAPT0 cc-pVDZ computation of the ethene-ethyne interaction energy, using the cc-pVDZ-JKFIT RI basis for SCF and cc-pVDZ-RI for SAPT. Monomer geometries are specified using Cartesian coordinates. cisd-h2o-clpse; 6-31G** H2O Test CISD Energy Point with subspace collapse. dfomp3-2; DF-OMP3 cc-pVDZ energy for the H2O+ cation. dft-custom-gga; DFT (LDA/GGA) test of custom implementations in: gga_superfuncs.py. omp2p5-2; OMP2.5 cc-pVDZ energy for the H2O molecule. mbis-6; MBIS calculation on H2O. sapt-exch-ind-inf; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. sapt11; sapt example with orbital freezing with alkali metal and dMP2. dfomp3-grad1; DF-OMP3 cc-pVDZ gradients for the H2O molecule. cbs-xtpl-energy-conv; Extrapolated water energies - conventional integrals version. dfomp2-grad2; OMP2 cc-pVDZ energy for the NO molecule. dlpnomp2-2; comparison of DF-MP2 and DLPNO-MP2 with a CBS extrapolation. ci-multi; BH single points, checking that program can run multiple instances of DETCI in a single input, without an intervening clean() call. dfmp2-fc; Kr–Kr nocp energies with all-electron basis set to check frozen core. olccd1; OLCCD cc-pVDZ energy for the H2O molecule. nbody-he-4b; MP2/aug-cc-pvDZ many body energies of an arbitrary Helium complex, addressing 4-body formulas. x2c2; Test of SFX2C-1e on Water cc-pVDZ-DK. In this test the Dirac equation is solved in the uncontracted cc-pVDZ-DK basis. The reference numbers are from Lan Cheng’s implementation in Cfour. opt-freeze-coords; SCF/cc-pVDZ optimization example with frozen cartesian. dfmp2-grad2; DF-MP2 cc-pVDZ gradient for the NO molecule. scf-guess-read3; Test if the the guess read in the same basis converges. dfmp2-1; Density fitted MP2 cc-PVDZ/cc-pVDZ-RI computation of formic acid dimer binding energy using automatic counterpo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html:15463,energy,energy,15463,psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency," are performed. See scf4 for analogous Z-matrix; and Cartiesian scans. Tables of Results¶; The results of computations can be compactly tabulated with the Table() Psithon; function. For example, in the following potential energy surface scan for water; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27molecule h2o {; O; H 1 R; H 1 R 2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(100,102,2). table=Table(rows=[""R"",""A""], cols=[""E(SCF)"",""E(SCS)"",""E(DFMP2)""]). set basis cc-pvdz. for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('mp2'); escf = get_variable('SCF TOTAL ENERGY'); edfmp2 = get_variable('MP2 TOTAL ENERGY'); escsmp2 = get_variable('SCS-MP2 TOTAL ENERGY'); table[R][A] = [escf, escsmp2, edfmp2]. print table; relative=table.copy(); relative.absolute_to_relative(); print relative. we first define a table (on line 10) with two row indices and three column; indices. As the potential energy scan is performed, the results are stored; (line 22) and the final table is printed to the output file (line 24). The; table is converted from absolute energies to relative energies (in kcal mol-1); on line 26, before being printed again. The relative energies are reported with; respect to the lowest value in each column. More examples of how to control the; formatting of the tables can be found in the sample input files provided; see; Appendix Test Suite and Sample Inputs for a complete listing. Python Wrappers¶; The Python foundations of the PSI4 driver and Psithon syntax permit; many commonly performed post-processing procedures to be integrated into; the PSI4 suite.; As seen in the neon dimer example from the tutorial section,; the nbody_gufunc() wrapper provides automatic computation of; counterpoise-corrected interaction energies between two molecules. For; example,; 1energy('mp2', bsse_type='cp'). will compute the counterpoise-corrected density-fitted MP2 interaction energy; between two molecules.; PSI4 also provides the ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psithoninput-1.html:14210,energy,energy,14210,psi4manual/1.1.0/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psithoninput-1.html,6,['energy'],['energy']
Energy Efficiency," are redundant.; If you installed into a conda environment p4env and performed; conda activate p4env, then which psi4 likely yields; condadist/envs/p4env/bin/psi4 and the PATH setting lines; below are redundant.; # csh, tcsh: add to shell or ~/.tcshrc file; unsetenv PSIDATADIR; setenv PATH {prefix}/bin:$PATH; setenv PSI_SCRATCH /path/to/existing/writable/local-not-network/directory/for/scratch/files. # sh, bash: add to shell or ~/.bashrc (Linux/Windows) or ~/.bash_profile (Mac) file; unset PSIDATADIR; export PATH={prefix}/bin:$PATH; export PSI_SCRATCH=/path/to/existing/writable/local-not-network/directory/for/scratch/files. Run PSI4 as executable.; >>> cat sample.in; molecule {; He; }; energy('hf/cc-pvdz'); compare_values(-2.85518839, get_variable('current energy'), 5, 'SCF E'); >>> psi4 sample.in; SCF E.............................................................PASSED. or Run PSI4 as Python module.; >>> cat sample.py; import psi4; mol = psi4.geometry(""""""; He; """"""); psi4.energy('hf/cc-pvdz'); psi4.compare_values(-2.85518839, psi4.core.get_variable('current energy'), 5, 'SCF E'); >>> python sample.py; SCF E.............................................................PASSED. How to run Psi4 as executable after compilation using driver from source¶; When developing python driver code, it can be annoying to keep makeing to test the code. PSI4 can be run “inplace” through the; following procedure. To be clear, this is running compiled C++ from the; build directory and python from the source directory. This is an expert; option for development, and not all functionality will be available.; >>> cd {objdir}; >>> ln -s {top-level-psi4-dir}/{objdir}/stage/lib/psi4/core.cpython-{ext_will_vary}.so ../psi4/core.cpython-{ext_will_vary}.so; >>> python ../psi4/run_psi4.py --inplace input.dat. Why not to set PSIDATADIR¶; PSIDATADIR is an environment variable containing the location of the; text resource parts of the PSI4 codebase (e.g., basis sets,; databases, EFP fragments). It is ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/build_planning-1.html:30588,energy,energy,30588,psi4manual/1.4.0/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/build_planning-1.html,9,['energy'],['energy']
Energy Efficiency," are relative. cc4; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. After the computation, the checkpoint file is renamed, using the PSIO handler. cc30; CCSD/sto-3g optical rotation calculation (length gauge only) at two frequencies on methyloxirane. cisd-h2o+-2; 6-31G** H2O+ Test CISD Energy Point. mp3-grad2; MP3 cc-pVDZ gradient for the NO radical. dcft6; DCFT calculation for the triplet O2 using DC-06, DC-12 and CEPA0 functionals. Only two-step algorithm is tested. cc3; cc3: RHF-CCSD/6-31G** H2O geometry optimization and vibrational frequency analysis by finite-differences of gradients. sapt1; SAPT0 cc-pVDZ computation of the ethene-ethyne interaction energy, using the cc-pVDZ-JKFIT RI basis for SCF and cc-pVDZ-RI for SAPT. Monomer geometries are specified using Cartesian coordinates. castup1; Test of SAD/Cast-up (mainly not dying due to file weirdness). cc51; EOM-CC3/cc-pVTZ on H2O. dfmp2-1; Density fitted MP2 cc-PVDZ/cc-pVDZ-RI computation of formic acid dimer binding energy using automatic counterpoise correction. Monomers are specified using Cartesian coordinates. psimrcc-fd-freq1; Mk-MRCCSD single point. O2 state described using the Ms = 0 component of the triplet. Uses ROHF triplet orbitals. opt7; Various constrained energy minimizations of HOOH with cc-pvdz RHF. For “fixed” coordinates, the final value is provided by the user. fci-tdm-2; BH-H2+ FCI/cc-pVDZ Transition Dipole Moment. dft-pbe0-2; Internal match to psi4, test to match to literature values in litref.in/litref.out. opt3; SCF cc-pVDZ geometry optimzation, with Z-matrix input. pywrap-checkrun-convcrit; Advanced python example sets different sets of scf/post-scf conv crit and check to be sure computation has actually converged to the expected accuracy. cc13a; UHF-CCSD(T)/cc-pVDZ CH2 geometry optimization via analytic gradients. mints9; A test of the basis specification. Various basis sets are specified outright and in blocks, both orbital and auxiliary. Constructs l",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html:6593,energy,energy,6593,psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency," are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; float or ndarray or Matrix. Raises:; KeyError – If key not set on self. Example; >>> g, wfn = psi4.gradient(""hf/cc-pvdz"", return_wfn=True); >>> wfn.variable(""CURRENT ENERGY""); -100.00985995185668; >>> wfn.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> wfn.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> wfn.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). variables(include_deprecated_keys=False)¶; Return all scalar or array QCVariables; from self. Parameters:. self – Wavefunction instance.; include_deprecated_keys (bool) – Also return duplicate entries with keys that have been deprecated. Returns:; Map of all QCVariables that have been set on self. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; Dict[str, Union[float, ndarray, Matrix]. write_molden(filename=None, do_virtual=None, use_natural=False)¶; Writes wavefunction information in wfn to filename in; molden format. Will write natural orbitals from density (MO basis) if supplied.; Warning! most post-SCF wavefunctions do not build the density as this is often; much more costly than the energy. In addition, the wavefunction density attributes; (Da and Db) return the SO density and must be transformed to the MO basis; to use with this function. Added in version 0.5: wfn parameter passed explicitly. Returns:; None. Parameters:. filename (Optional[str]) – Destination file name for MOLDEN file. If unspecified (None), a file; name will be generated from the molecule name.; do_virtual (Optional[bool]) – Do write all the MOs to the MOLDEN file (True) or",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/api/psi4.core.Wavefunction.html:26942,charge,charges,26942,psi4manual/master/api/psi4.core.Wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.Wavefunction.html,1,['charge'],['charges']
Energy Efficiency," are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; float or ndarray or Matrix. Raises:; KeyError – If key not set on self. Example; >>> g, wfn = psi4.gradient(""hf/cc-pvdz"", return_wfn=True); >>> wfn.variable(""CURRENT ENERGY""); -100.00985995185668; >>> wfn.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> wfn.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> wfn.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). variables(include_deprecated_keys=False)¶; Return all scalar or array QCVariables; from self. Parameters:. self – Wavefunction instance.; include_deprecated_keys (bool) – Also return duplicate entries with keys that have been deprecated. Returns:; Map of all QCVariables that have been set on self. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; Dict[str, Union[float, ndarray, Matrix]. write_molden(filename=None, do_virtual=None, use_natural=False)¶; Writes wavefunction information in wfn to filename in; molden format. Will write natural orbitals from density (MO basis) if supplied.; Warning! most post-SCF wavefunctions do not build the density as this is often; much more costly than the energy. In addition, the wavefunction density attributes; (Da and Db) return the SO density and must be transformed to the MO basis; to use with this function. New in version 0.5: wfn parameter passed explicitly. Returns:; None. Parameters:. filename (Optional[str]) – Destination file name for MOLDEN file. If unspecified (None), a file; name will be generated from the molecule name.; do_virtual (Optional[bool]) – Do write all the MOs to the MOLDEN file (True) or d",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Wavefunction.html:26790,charge,charges,26790,psi4manual/1.7.x/api/psi4.core.Wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Wavefunction.html,3,['charge'],['charges']
Energy Efficiency," arg0: str) → int¶; Removes the requested (case-insensitive) Matrix QC variable. del_potential_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) ExternalPotential QC variable. (This function is provisional and might be removed in the future.). del_scalar_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) double QC variable. del_variable(key)¶; Removes scalar or array QCVariable key from cls if present. Return type; None. Parameters. cls (psi4.core.Wavefunction) – ; key (str) – . density_fitted(self: psi4.core.Wavefunction) → bool¶; Returns whether this wavefunction was obtained using density fitting or not. diag_h(self: psi4.core.CIWavefunction, arg0: float, arg1: float) → int¶; docstring. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. efzc(self: psi4.core.Wavefunction) → float¶; Returns the frozen-core energy. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunction’s energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Beta Eigenvalues subset. esp_at_nuclei(self: psi4.core.Wavefunction) → psi4.core.Vector¶; returns electrostatic potentials at nuclei. external_pot(self: psi4.core.Wavefunction) → psi4.core.ExternalPotential¶; Gets the requested external potential. force_doccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use only. Sets the number of doubly occupied oribtals per irrep. Note that this results in inconsistent Wavefunction objects for SCF, so caution is ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ciwavefunction.html:15694,energy,energy,15694,psi4manual/1.4.0/api/psi4.core.ciwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ciwavefunction.html,1,['energy'],['energy']
Energy Efficiency," arg0: str) → int¶; Removes the requested (case-insensitive) Matrix QC variable. del_potential_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) ExternalPotential QC variable. (This function is provisional and might be removed in the future.). del_scalar_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) double QC variable. del_variable(key)¶; Removes scalar or array QCVariable key from cls if present. Return type; None. Parameters. cls (psi4.core.Wavefunction) – ; key (str) – . density_fitted(self: psi4.core.Wavefunction) → bool¶; Returns whether this wavefunction was obtained using density fitting or not. diag_h(self: psi4.core.CIWavefunction, arg0: float, arg1: float) → int¶; docstring. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. efzc(self: psi4.core.Wavefunction) → float¶; Returns the frozen-core energy. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunction’s energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, basis: str, subset: str) → psi4.core.Vector¶; Returns the requested Alpha orbital energies subset. Parameters. basis – {‘AO’, ‘SO’, ‘MO’}; MO or SO select for Pitzer-ordering the return vector in the full computational point group symmetry.; AO selects for Pitzer-ordering the return vector without point group symmetry.; subset – {‘ALL’, ‘ACTIVE’, ‘FROZEN’, ‘OCC’, ‘VIR’, ‘FROZEN_OCC’, ‘ACTIVE_OCC’, ‘ACTIVE_VIR’, ‘FROZEN_VIR’}; Which subspace of orbital energies should be returned?. Returns; A Pitzer-ordered vector of the orbitals. Return type; Vector. epsilon_b(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, basis: str, subset: str) → psi4.core.Vector¶; Returns the requested Beta orbital energies sub",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.ciwavefunction.html:15805,energy,energy,15805,psi4manual/1.5.0/api/psi4.core.ciwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.ciwavefunction.html,2,['energy'],['energy']
Energy Efficiency," arg2: int) → psi::Matrix¶; Performs a finite difference frequency computation, from energy points, for a given irrep. psi4.core.fd_freq_1(arg0: psi::Molecule, arg1: list, arg2: int) → psi::Matrix¶; Performs a finite difference frequency computation, from gradients, for a given irrep. psi4.core.fd_geoms_1_0(arg0: psi::Molecule) → List[psi::Matrix]¶; Gets list of displacements needed for a finite difference gradient computation, from energy points. psi4.core.fd_geoms_freq_0(arg0: psi::Molecule, arg1: int) → List[psi::Matrix]¶; Gets list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep. psi4.core.fd_geoms_freq_1(arg0: psi::Molecule, arg1: int) → List[psi::Matrix]¶; Gets list of displacements needed fof a finite difference frequency computation, from gradients, for a given irrep. psi4.core.finalize() → None¶. psi4.core.flush_outfile() → None¶; Flushes the output file. psi4.core.fnocc(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the fno-ccsd(t)/qcisd(t)/mp4/cepa energy code. psi4.core.get_active_efp() → psi4.core.EFP¶; Returns the currently active EFP object. psi4.core.get_active_molecule() → psi::Molecule¶; Returns the currently active molecule object. psi4.core.get_array_variable(arg0: str) → psi::Matrix¶; Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available). psi4.core.get_array_variables() → Dict[str, psi::Matrix]¶; Returns dictionary of the PSI variables set internally by the modules or python driver. psi4.core.get_atomic_point_charges() → psi::Vector¶; Returns the most recently computed atomic point charges, as a double * object. psi4.core.get_datadir() → str¶; Sets the path to shared text resources, PSIDATADIR. psi4.core.get_efp_torque() → psi::Matrix¶; Returns the most recently computed gradient for the EFP portion, as a Nefp by 6 Matrix object. psi4.core.get_frequencies() → psi::Vector¶; Returns the most recently comp",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psi4api-1.html:228077,energy,energy,228077,psi4manual/1.2.1/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html,2,['energy'],['energy']
Energy Efficiency," argument to the function. delta_wfn (string) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. delta_wfn_lesser (string) – corl_wfn || 'mp2' || etc.; Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. delta2_wfn (string) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. delta2_wfn_lesser (string) – delta_wfn || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. delta3_wfn (string) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a third delta correction; to the correlation energy is to be obtained. delta3_wfn_lesser (string) – delta2_wfn || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a third delta correction; to the correlation energy is to be obtained. delta4_wfn (string) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a fourth delta correction; to the correlation energy is to be obtained. delta4_wfn_lesser (string) – delta3_wfn || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a fourth delta correction; to the correlation energy is to be obtained. delta5_wfn (string) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a fifth delta correction; to the correlation energy is to be obtained. delta5_wfn_lesser (string) – delta4_wfn || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a fifth delta correction; to the correlation energy is to be obtained. Basis Sets; Currently, the basis set set through set commands have no influence; on a cbs calculation. Parameters:; scf_basis (basis string) – corl_basis || 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence o",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/cbs-1.html:4537,energy,energy,4537,psi4manual/1.0.0/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/cbs-1.html,4,['energy'],['energy']
Energy Efficiency," array [e a0^2] for the requested configuration interaction level of theory, (3, 3). CI ROOT n -> ROOT m DIPOLE¶; Transition dipole array [e a0] between roots n and m for the requested configuration interaction level of theory, (3,). CI ROOT n -> ROOT m QUADRUPOLE¶; Redundant transition quadrupole array [e a0^2] between roots n and m for the requested configuration interaction level of theory, (3, 3). CI ROOT n DIPOLE¶; Dipole array [e a0] for the requested configuration interaction level of theory and root n, (3,). CI ROOT n QUADRUPOLE¶; Redundant quadrupole array [e a0^2] for the requested configuration interaction level of theory and root n, (3, 3). CI ROOT n TOTAL ENERGY¶. CI ROOT n CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the requested configuration interaction level of theory and root; n (numbering starts at 0). CI STATE-AVERAGED TOTAL ENERGY¶. CI STATE-AVERAGED CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for state-averaged CI/CASSCF levels of theory. CI TOTAL ENERGY¶. CI CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the requested configuration interaction level of theory and root. CISD DIPOLE¶; Dipole array [e a0] for the configuration interaction singles and doubles level of theory, (3,). CISD QUADRUPOLE¶; Redundant quadrupole array [e a0^2] for the configuration interaction singles and doubles level of theory, (3, 3). CISD TOTAL ENERGY¶. CISD CORRELATION ENERGY¶. CISDT TOTAL ENERGY¶. CISDT CORRELATION ENERGY¶. CISDTQ CORRELATION ENERGY¶. CISDTQ TOTAL ENERGY¶. CIn CORRELATION ENERGY¶. CIn TOTAL ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the labeled configuration interaction level of theory and root.; n is CI order for n > 4. CP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [E_h] considering only two-body interactions,; computed with counterp",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html:22346,energy,energy,22346,psi4manual/1.7.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html,8,['energy'],['energy']
Energy Efficiency," array; Default: No Default. CFOUR_CPHF_CONVER (CFOUR)¶CFOUR — Specifies the convergence criterion for the iterative solution of the CPHF and Z-vector equations. The solutions are considered to be converged when the residual norm of the error vector falls below \(10^N\). Type: integer; Default: 12. CFOUR_CPHF_MAXCYC (CFOUR)¶CFOUR — Specifies the maximum number of cycles allowed for the solution of the CPHF- and/or Z-vector equations. Type: integer; Default: 64. CFOUR_CURVILINEAR (CFOUR)¶CFOUR — Specifies whether or not Hessian matrix is transformed (nonlinearly) to curvilinear internal coordinates. A value of 0 (or OFF) turns the transformation off if the analytic force constants are not available, while it is always performed if CURVILINEAR=1 (or ON). Values higher than 1 (or NO) unconditionally turn the transformation off.(Default: ON if analytic Hessian is available, OFF otherwise). Type: boolean; Default: true. CFOUR_DBOC (CFOUR)¶CFOUR — Specifies whether the diagonal Born-Oppenheimer correction (DBOC) to the energy is evaluated (ON =1) or not (OFF =0). DBOC calculations are currently only available for HF-SCF and CCSD using RHF or UHF reference functions. Type: boolean; Default: false. CFOUR_DCT (CFOUR)¶CFOUR — Specifies whether the Dipole Coupling Tensor (DCT) is calculated (ON =1) or not (OFF =0). Type: boolean; Default: false. CFOUR_DERIV_LEVEL (CFOUR)¶CFOUR — Specifies whether or not energy derivatives are to be calculated and if so whether first or second derivatives are computed. ZERO (= 0) derivatives are not calculated, FIRST (=1) first derivatives are calculated, SECOND (=2) second derivatives are calculated. Note that this keyword usually needs not be set in any calculation since it is automatically set if the appropriate other options in the CFOUR namelist are turned on. Psi4 Interface: Keyword set from type of computation command: ZERO if energy(), FIRST if gradient() or optimize(), etc. Type: string; Possible Values: ZERO, FIRST, SECOND; Default: ZE",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:31852,energy,energy,31852,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,9,['energy'],['energy']
Energy Efficiency," as 1, z as 2. class psi4.core.SaveType¶; Bases: pybind11_builtins.pybind11_object; The layout of the matrix for saving. Full = SaveType.Full¶. LowerTriangle = SaveType.LowerTriangle¶. SubBlocks = SaveType.SubBlocks¶. class psi4.core.ShellInfo¶; Bases: pybind11_builtins.pybind11_object. class psi4.core.Slice¶; Bases: pybind11_builtins.pybind11_object; Slicing for Matrix and Vector objects. begin(self: psi4.core.Slice) → psi4.core.Dimension¶; Get the first element of this slice. end(self: psi4.core.Slice) → psi4.core.Dimension¶; Get the past-the-end element of this slice. class psi4.core.SuperFunctional¶; Bases: pybind11_builtins.pybind11_object; docstring. XC_build(arg0: str, arg1: bool) → psi4.core.SuperFunctional¶; Builds a SuperFunctional from a XC string. add_c_functional(self: psi4.core.SuperFunctional, arg0: psi::Functional) → None¶; Add a correlation Functional. add_x_functional(self: psi4.core.SuperFunctional, arg0: psi::Functional) → None¶; Add a exchange Functional. allocate(self: psi4.core.SuperFunctional) → None¶; Allocates the vectors, should be called after ansatz or npoint changes. ansatz(self: psi4.core.SuperFunctional) → int¶; SuperFunctional rung. blank() → psi4.core.SuperFunctional¶; Initialize a blank SuperFunctional. c_alpha(self: psi4.core.SuperFunctional) → float¶; Amount of MP2 correlation. c_functional(self: psi4.core.SuperFunctional, arg0: str) → psi::Functional¶; Returns the desired C Functional. c_functionals(self: psi4.core.SuperFunctional) → List[psi::Functional]¶; Returns all C Functionals. c_omega(self: psi4.core.SuperFunctional) → float¶; Range-seperated correlation parameter. c_os_alpha(self: psi4.core.SuperFunctional) → float¶; Amount of SS MP2 correlation. c_ss_alpha(self: psi4.core.SuperFunctional) → float¶; Amount of OS MP2 correlation. citation(self: psi4.core.SuperFunctional) → str¶; SuperFunctional citation. compute_functional(self: psi4.core.SuperFunctional, arg0: Dict[str, psi4.core.Vector], arg1: int) → Dict[str, psi4.core.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psi4api-1.html:231996,allocate,allocate,231996,psi4manual/1.3.2/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psi4api-1.html,2,['allocate'],['allocate']
Energy Efficiency," as distributed are below. Input File; Description. psithon2; Accesses basis sets, databases, plugins, and executables in non-install locations. cc14; ROHF-CCSD/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. ci-multi; BH single points, checking that program can run multiple instances of DETCI in a single input, without an intervening clean() call. omp3-2; OMP3 cc-pCVDZ energy with ROHF initial guess for the NO radical. fd-gradient; SCF STO-3G finite-difference tests. cc36; CC2(RHF)/cc-pVDZ energy of H2O. molden2; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. fd-freq-gradient; SCF STO-3G finite-differences frequencies from gradients for H2O. soscf-dft; Triple and Singlet Oxygen energy SOSCF, also tests non-symmetric density matrices. mp2p5-grad1; MP2.5 cc-pVDZ gradient for the H2O molecule. cc5; RHF CCSD(T) cc-pVDZ frozen-core energy of C4NH4 Anion. tdscf-3; td-wb97x excitation energies of singlet states of h2o, wfn passing. psimrcc-ccsd_t-4; Mk-MRCCSD(T) single point. \(^1A_1\) O$_3` state described using the Ms = 0 component of the singlet. Uses TCSCF orbitals. castup2; SCF with various combinations of pk/density-fitting, castup/no-castup, and spherical/cartesian settings. Demonstrates that puream setting is getting set by orbital basis for all df/castup parts of calc. Demonstrates that answer doesn’t depend on presence/absence of castup. Demonstrates (by comparison to castup3) that output file doesn’t depend on options (scf_type) being set global or local. This input uses global. cc32; CC3/cc-pVDZ H2O \(R_e\) geom from Olsen et al., JCP 104, 8007 (1996). scf-response2; Compute the dipole polarizability for water with custom basis set. dct5; DC-06 calculation for th",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/testsuite.html:1825,energy,energy,1825,psi4manual/1.9.x/testsuite.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/testsuite.html,1,['energy'],['energy']
Energy Efficiency," atomic number arg1, Cartesian coordinates in Bohr (arg2, arg3, arg4), atomic symbol arg5, mass arg6, charge arg7 (optional), and lineno arg8 (optional). atom_at_position((self: psi4.core.Molecule, ...); Tests to see if an atom is at the position arg2 with a given tolerance arg3. center_of_mass(...); Computes center of mass of molecule (does not translate molecule). charge((self: psi4.core.Molecule, ...); Gets charge of atom arg1 (0-indexed). clone(...); Returns a new Molecule identical to arg0. create_molecule_from_string(...); Returns a new Molecule with member data from the geometry string arg0 in Psi4 format. create_psi4_string_from_molecule(...); Gets a string reexpressing in input format the current states of the molecule. deactivate_all_fragments(...); Sets all fragments in the molecule to be inactive. distance_matrix(...); Returns Matrix of interatom distances. extract_subsets(*args, **kwargs); Overloaded function. fZ((self: psi4.core.Molecule, ...); Nuclear charge of atom arg1 (0-indexed including dummies). fcharge((self: psi4.core.Molecule, ...); Gets charge of atom arg1 (0-indexed including dummies). find_point_group((self: psi4.core.Molecule, ...); Finds computational molecular point group, user can override this with the symmetry keyword. fix_com((self: psi4.core.Molecule, ...); Whether to fix the Cartesian position, or to translate to the C.O.M. fix_orientation((self: psi4.core.Molecule, ...); Fix the orientation at its current frame. flabel((self: psi4.core.Molecule, ...); Gets the original label of the atom arg1 as given in the input file (C2, H4) (0-indexed including dummies). fmass((self: psi4.core.Molecule, ...); Gets mass of atom arg1 (0-indexed including dummies). form_symmetry_information(...); Uses the point group object obtain by calling point_group(). fsymbol((self: psi4.core.Molecule, ...); Gets the cleaned up label of atom arg1 (C2 => C, H4 = H) (0-indexed including dummies). fx((self: psi4.core.Molecule, ...); x position of atom arg1 (0-in",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html:1713,charge,charge,1713,psi4manual/1.1.0/api/psi4.core.molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html,1,['charge'],['charge']
Energy Efficiency," atoms in this molecule.\n""; print(text); # TODO outfile. [docs] def print_in_input_format(self):; """"""Print the molecule in the same format that the user provided.; """"""; text = """"; if self.nallatom():; text += "" Geometry (in %s), charge = %d, multiplicity = %d:\n\n"" % \; (""Angstrom"" if self.units() == 'Angstrom' else ""Bohr"",; self.molecular_charge(), self.multiplicity()); for i in range(self.nallatom()):; if self.fZ(i) or self.fsymbol(i) == ""X"":; text += "" %-8s"" % (self.fsymbol(i)); else:; text += "" %-8s"" % (""Gh("" + self.fsymbol(i) + "")""); text += self.full_atoms[i].print_in_input_format(); text += ""\n""; if len(self.geometry_variables):; for vb, val in self.geometry_variables.items():; text += """""" %-10s=%16.10f\n"""""" % (vb, val); text += ""\n"". print(text); # TODO outfile. [docs] def everything(self):; """"""Quick print of class data""""""; text = """""" ==> qcdb Molecule %s <==\n\n"""""" % (self.name()); text += """""" Natom %d\t\tNallatom %d\n"""""" % (self.natom(), self.nallatom()); text += """""" charge %d\t\tspecified? %s\n"""""" % (self.molecular_charge(), self.charge_specified()); text += """""" multiplicity %d\t\tspecified? %s\n"""""" % (self.multiplicity(), self.multiplicity_specified()); text += """""" units %s\tconversion %f\n"""""" % (self.units(), self.input_units_to_au); text += """""" DOcom? %s\t\tDONTreorient? %s\n"""""" % (self.PYmove_to_com, self.orientation_fixed()); text += """""" reinterpret? %s\t\tlock_frame? %s\n"""""" % (self.PYreinterpret_coordentries, self.lock_frame); text += """""" input symm %s\n"""""" % (self.symmetry_from_input()); text += """""" Nfragments %d\t\tNactive %d\n"""""" % (self.nfragments(), self.nactive_fragments()); text += """""" zmat? %s\n"""""" % (self.has_zmatrix()); print(text). [docs] def create_psi4_string_from_molecule(self):; """"""Regenerates a input file molecule specification string from the; current state of the Molecule. Contains geometry info,; fragmentation, charges and multiplicities, and any frame; restriction.; """"""; text = """"; if self.nallatom():. # append units and any oth",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:30800,charge,charge,30800,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,1,['charge'],['charge']
Energy Efficiency," attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CC_MAXITER¶. Maximum number of iterations to determine the amplitudes. Type: integer; Default: 50. CUTOFF¶. Cutoff value for numerical procedures. Type: integer; Default: 14. DIIS_MAX_VECS¶. Number of vectors used in DIIS. Type: integer; Default: 4. DO_LEVEL_SHIFT¶. Do apply level shifting to aid convergence. Type: boolean; Default: false. DO_SCS¶. Do perform spin-component-scaled OMP3 (SCS-OMP3)? In all computation, SCS-OMP3 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SCS-OMP3, one needs to set ‘DO_SCS’ to true. Type: boolean; Default: false. DO_SOS¶. Do perform spin-opposite-scaled OMP3 (SOS-OMP3)? In all computation, SOS-OMP3 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SOS-OMP3, one needs to set ‘DO_SOS’ to true. Type: boolean; Default: false. E3_SCALE¶. Scaling value for 3rd order energy correction (S. Grimme, Vol. 24, pp. 1529, J. Comput. Chem.). Type: double; Default: 0.25. E_CONVERGENCE¶. Convergence criterion for energy. Type: conv double; Default: 1e-8. HESS_TYPE¶. Type Hessian matrix will be used in orbital optimization procedure. Type: string; Possible Values: NONE; Default: NONE. LEVEL_SHIFT¶. Level shift parameter. Type: double; Default: 0.02. LINEQ_SOLVER¶. The solver will be used for simultaneous linear equations. Type: string; Possible Values: CDGESV, FLIN, POPLE; Default: CDGESV. MAX_MOGRAD_CONVERGENCE¶. Convergence criterion for maximum orbital gradient. Type: conv double; Default: 1e-4. MO_MAXITER¶. Maximum number of iterations to determine the orbitals. Type: integer; Default: 50. MO_READ¶. Do r",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodir_options_c/module__omp3-1.html:1430,energy,energy,1430,psi4manual/4.0b3/autodir_options_c/module__omp3-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/module__omp3-1.html,2,['energy'],['energy']
Energy Efficiency," attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class SuperFunctional(Boost.Python.instance); | docstring; | ; | Method resolution order:; | SuperFunctional; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | add_c_functional(...); | add_c_functional( (SuperFunctional)arg1, (Functional)arg2) -> None :; | docstring; | ; | C++ signature :; | void add_c_functional(N3psi15SuperFunctionalE {lvalue},N5boost10shared_ptrIN3psi10FunctionalEEE); | ; | add_x_functional(...); | add_x_functional( (SuperFunctional)arg1, (Functional)arg2) -> None :; | docstring; | ; | C++ signature :; | void add_x_functional(N3psi15SuperFunctionalE {lvalue},N5boost10shared_ptrIN3psi10FunctionalEEE); | ; | allocate(...); | allocate( (SuperFunctional)arg1) -> None :; | docstring; | ; | C++ signature :; | void allocate(N3psi15SuperFunctionalE {lvalue}); | ; | ansatz(...); | ansatz( (SuperFunctional)arg1) -> int :; | docstring; | ; | C++ signature :; | i ansatz(N3psi15SuperFunctionalE {lvalue}); | ; | c_alpha(...); | c_alpha( (SuperFunctional)arg1) -> float :; | docstring; | ; | C++ signature :; | d c_alpha(N3psi15SuperFunctionalE {lvalue}); | ; | c_functional(...); | c_functional( (SuperFunctional)arg1, (str)arg2) -> Functional :; | docstring; | ; | C++ signature :; | N5boost10shared_ptrIN3psi10FunctionalEEE c_functional(N3psi15SuperFunctionalE {lvalue},Ss); | ; | c_omega(...); | c_omega( (SuperFunctional)arg1) -> float :; | docstring; | ; | C++ signature :; | d c_omega(N3psi15SuperFunctionalE {lvalue}); | ; | c_os_alpha(...); | c_os_alpha( (SuperFunctional)arg1) -> float :; | docstring; | ; | C++ signature :; | d c_os_alpha(N3psi15SuperFunctionalE {lvalue}); | ; | c_ss_alpha(...); | c_ss_alpha( (SuperFunctional)arg1) -> float :; | docstring; | ; | C++ signature :; | d c_ss_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:619372,allocate,allocate,619372,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,4,['allocate'],['allocate']
Energy Efficiency," augment domains with polarized orbitals?. Type: boolean; Default: false. LOCAL_DOMAIN_SEP (CCSORT); CCSORT —. Type: boolean; Default: false. LOCAL_FILTER_SINGLES (CCEOM); CCEOM — Do apply local filtering to singles amplitudes?. Type: boolean; Default: true. LOCAL_FILTER_SINGLES (CCLAMBDA); CCLAMBDA — Do apply local filtering to single de-excitation ( amplitudes?. Type: boolean; Default: true. LOCAL_FILTER_SINGLES (CCRESPONSE); CCRESPONSE — Do apply local filtering to single excitation amplitudes?. Type: boolean; Default: false. LOCAL_FILTER_SINGLES (CCSORT); CCSORT — Do apply local filtering to single excitation amplitudes?. Type: boolean; Default: false. LOCAL_GHOST (CCEOM); CCEOM — Permit ghost atoms to hold projected atomic orbitals to include in the virtual space in local-EOM-CCSD calculations. Type: integer; Default: -1. LOCAL_IBO_CONDITION (FISAPT); FISAPT (Expert) — Condition number to use in IBO metric inversions. Type: double; Default: 1.0e-7. LOCAL_IBO_POWER (FISAPT); FISAPT — IBO localization metric power. Type: integer; Default: 4. LOCAL_IBO_STARS (FISAPT); FISAPT — IBO Centers for Pi Degeneracy. Type: array; Default: No Default. LOCAL_IBO_STARS_COMPLETENESS (FISAPT); FISAPT — IBO Charge metric for classification as Pi. Type: double; Default: 0.90. LOCAL_IBO_USE_STARS (FISAPT); FISAPT — IBO Stars procedure. Type: boolean; Default: false. LOCAL_MAXITER (FISAPT); FISAPT — Maximum iterations in localization. Type: integer; Default: 1000. LOCAL_MAXITER (SCF); SCF — The maxiter on the orbital localization procedure. Type: integer; Default: 200. LOCAL_METHOD (CCENERGY); CCENERGY — Type of local-CCSD scheme to be simulated. WERNER selects the method developed by H.-J. Werner and co-workers, and AOBASIS selects the method developed by G.E. Scuseria and co-workers (currently inoperative). Type: string; Possible Values: WERNER, AOBASIS; Default: WERNER. LOCAL_METHOD (CCEOM); CCEOM — Type of local-CCSD scheme to be simulated. WERNER selects the method developed by",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:150474,power,power,150474,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,2,['power'],['power']
Energy Efficiency, basis sets; present in ``corl_basis`` and :py:func:`~xtpl_highest_1` otherwise. :type delta_scheme: function; :param delta_scheme: |dl| ``xtpl_highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the delta correction; to the correlation energy.; Defaults to :py:func:`~corl_xtpl_helgaker_2` if two valid basis sets; present in ``delta_basis`` and :py:func:`~xtpl_highest_1` otherwise. :type delta2_scheme: function; :param delta2_scheme: |dl| ``xtpl_highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the second delta correction; to the correlation energy.; Defaults to :py:func:`~corl_xtpl_helgaker_2` if two valid basis sets; present in ``delta2_basis`` and :py:func:`~xtpl_highest_1` otherwise. :type delta3_scheme: function; :param delta3_scheme: |dl| ``xtpl_highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the third delta correction; to the correlation energy.; Defaults to :py:func:`~corl_xtpl_helgaker_2` if two valid basis sets; present in ``delta3_basis`` and :py:func:`~xtpl_highest_1` otherwise. :type delta4_scheme: function; :param delta4_scheme: |dl| ``xtpl_highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the fourth delta correction; to the correlation energy.; Defaults to :py:func:`~corl_xtpl_helgaker_2` if two valid basis sets; present in ``delta4_basis`` and :py:func:`~xtpl_highest_1` otherwise. :type delta5_scheme: function; :param delta5_scheme: |dl| ``xtpl_highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the fifth delta correction; to the correlation energy.; Defaults to :py:func:`~corl_xtpl_helgaker_2` if two valid basis sets; present in ``delta5_basis`` and :py:func:`~xtpl_highest_1` otherwise. :type molecule: :ref:`molecule <op_py_molecule>,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:26828,energy,energy,26828,psi4manual/1.0.0/_modules/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html,2,['energy'],['energy']
Energy Efficiency," basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None, *, quiet=False)¶; Build a wavefunction from minimal inputs, molecule and basis set. Parameters:. mol (Molecule) – Molecule for which to build the wavefunction instance.; basis (Union[None, str, BasisSet]) – Basis set for which to build the wavefunction instance. If a; BasisSet, taken as-is. If a string, taken as a name for the; primary basis. If None, name taken from BASIS.; quiet (bool) – When True, do not print to the output file. Return type:; Wavefunction. c1_deep_copy(self: psi4.core.Wavefunction, basis: psi4.core.BasisSet) → psi4.core.Wavefunction¶; Returns a new wavefunction with internal data converted to \(C_1\) symmetry, using pre-c1-constructed basis. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. del_array_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) Matrix QC variable. Prefer del_variable(). del_potential_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) ExternalPotential QC variable. (This function is provisional and might be removed in the future.). del_scalar_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) double QC variable. Prefer del_variable(). del_variable(key)¶; Removes scalar or array QCVariable key from self if present. Parameters:. self (Wavefunction) – Wave",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/api/psi4.core.Wavefunction.html:12822,energy,energy,12822,psi4manual/master/api/psi4.core.Wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.Wavefunction.html,1,['energy'],['energy']
Energy Efficiency," basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None, *, quiet=False)¶; Build a wavefunction from minimal inputs, molecule and basis set. Parameters:. mol (Molecule) – Molecule for which to build the wavefunction instance.; basis (Union[None, str, BasisSet]) – Basis set for which to build the wavefunction instance. If a; BasisSet, taken as-is. If a string, taken as a name for the; primary basis. If None, name taken from BASIS.; quiet (bool) – When True, do not print to the output file. Return type:; Wavefunction. c1_deep_copy(self: psi4.core.Wavefunction, basis: psi4.core.BasisSet) → psi4.core.Wavefunction¶; Returns a new wavefunction with internal data converted to \(C_1\) symmetry, using pre-c1-constructed basis. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. del_array_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) Matrix QC variable. Prefer del_variable(). del_potential_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) ExternalPotential QC variable. (This function is provisional and might be removed in the future.). del_scalar_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) double QC variable. Prefer del_variable(). del_variable(key)¶; Removes scalar or array QCVariable key; from self if present. Parameters:. self (Wavefunction) – Wav",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Wavefunction.html:12872,energy,energy,12872,psi4manual/1.7.x/api/psi4.core.Wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Wavefunction.html,2,['energy'],['energy']
Energy Efficiency," basis, where integral transformation is avoided. In the next RHF-ODC-12 computation, AO_BASIS=NONE is used, where four-virtual integrals are transformed into MO basis. scf-occ; force occupations in scf. scf7; Tests SCF gradient in the presence of a dipole field. omp2-4; SCS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. pywrap-all; Intercalls among python wrappers- database, cbs, optimize, energy, etc. Though each call below functions individually, running them all in sequence or mixing up the sequence is aspirational at present. Also aspirational is using the intended types of gradients. rasci-c2-active; 6-31G* C2 Test RASCI Energy Point, testing two different ways of specifying the active space, either with the ACTIVE keyword, or with RAS1, RAS2, RESTRICTED_DOCC, and RESTRICTED_UOCC. cc21; ROHF-EOM-CCSD/DZ analytic gradient lowest \(^{2}A_1\) excited state of H2O+ (B1 excitation). omp3-4; SCS-OMP3 cc-pVDZ geometry optimization for the H2O molecule. dfomp2-4; OMP2 cc-pVDZ energy for the NO molecule. mcscf2; TCSCF cc-pVDZ energy of asymmetrically displaced ozone, with Z-matrix input. omp2-2; OMP2 cc-pVDZ energy with ROHF initial guess orbitals for the NO radical. cc33; CC3(UHF)/cc-pVDZ H2O \(R_e\) geom from Olsen et al., JCP 104, 8007 (1996). pywrap-freq-e-sowreap; Finite difference of energies frequency, run in sow/reap mode. cc51; EOM-CC3/cc-pVTZ on H2O. opt12; SCF cc-pVDZ geometry optimzation of ketene, starting from bent structure. molden1; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. psimrcc-ccsd_t-3; Mk-MRCCSD(T) single point. \(^1A_1\) CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. cc5; RHF CCSD(T) aug-cc-pvtz frozen-core energy ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/testsuite-1.html:33934,energy,energy,33934,psi4manual/1.1.0/testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/testsuite-1.html,4,['energy'],['energy']
Energy Efficiency," basis=None)¶. ci_nat_orbs(self: psi4.core.CIWavefunction) → None; docstring. cleanup_ci(self: psi4.core.CIWavefunction) → None; docstring. cleanup_dpd(self: psi4.core.CIWavefunction) → None; docstring. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. compute_state_transfer(self: psi4.core.CIWavefunction, arg0: psi::detci::CIvect, arg1: int, arg2: psi4.core.Matrix, arg3: psi::detci::CIvect) → None; docstring. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. diag_h(self: psi4.core.CIWavefunction, arg0: float, arg1: float) → int; docstring. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Beta Eigenvalues subset. form_opdm(self: psi4.core.CIWavefunction) → None; docstring. form_tpdm(self: psi4.core.CIWavefunction) → None; docstring. frequencies(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the frequencies of the Hessian. frzcpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of frozen core orbitals per irrep. frzvpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of frozen virtual orbitals per irrep. get_array(se",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/api/psi4.core.ciwavefunction.html:7662,energy,energy,7662,psi4manual/1.1.0/api/psi4.core.ciwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.ciwavefunction.html,1,['energy'],['energy']
Energy Efficiency," be integrated into; the Psi4 suite.; As seen in the neon dimer example from the A Psi4 Tutorial section,; the _nbody_gufunc() wrapper provides automatic computation of; counterpoise-corrected interaction energies between two molecules. For; example,:; cp('mp2'). will compute the counterpoise-corrected density-fitted MP2 interaction energy; between two molecules.; Psi4 also provides the complete_basis_set() wrapper,; which automatically computes a complete-basis-set extrapolation (and; automatically sets up the computations with different basis sets required to; do the extrapolation). For example,:; cbs('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). will compute a 2-point Helgaker extrapolation of the correlation energy; using the cc-pVDZ and cc-pVTZ basis sets (with method MP2), and add this; extrapolated correlation energy to the Hartree–Fock energy in the; largest basis (cc-pVTZ).; Another very useful and powerful feature of Psi4 is the ability; to compute results on entire databases of molecules at a time,; as provided by the database() wrapper. For example,:; database('mp2','S22',cp=1,benchmark='S22B'). will perform DF-MP2 counterpoise-corrected interaction energies; (cp=1) on all members of Hobza’s S22 database set of van der Waals; dimers, and then compare the results against the S22B benchmark energies.; Built-in databases include S22, A24, HTBH, HBC6, HSG, S22by5, S66, JSCH,; NCB31, S66by8, and NBC10, among others.; These wrapper functions are discussed separately in; Psithon Functions: Invoking a Calculation. Note that the options documented for Python; functions are placed as arguments in the command that calls the function,; not in the set {...} block or with any other set command. Table Of Contents. Psithon: Structuring an Input File; Physical Constants; Memory Specification; Molecule and Geometry Specification; Job Control Keywords; Basis Sets; PSI Variables; Return Values; Loops; Tables of Results; Python Wrappers. Previous topic; A",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/psithoninput-1.html:14838,power,powerful,14838,psi4manual/1.0.0/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/psithoninput-1.html,2,['power'],['powerful']
Energy Efficiency," be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; Psi4 code is not necessary.; input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file.; This is usually done by manipulating PSIPATH. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection.; pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of Psi4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main Psi4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file.; __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the Psi4; documentation, along with any docs",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/plugins-1.html:6627,energy,energy,6627,psi4manual/1.0.0/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/plugins-1.html,4,['energy'],['energy']
Energy Efficiency," be scalable to; 3000 basis functions. Like higher-order SAPT, SAPT(DFT) requires; sufficient memory to hold \(2ovN_aux\) doubles.; SAPT(DFT) requires a few special treatments to obtain accurate; result. The DFT functionals used in SAPT(DFT) need to be asymptotically; corrected with Gradient Regulated Asymptotic Correction scheme (GRAC),; in order to recover the correct long-range asymptotic behavior; (approaching \(-1/r\) as \(r\) approaches infinity). The program; requires manual input of GRAC shift parameter for each monomer through; keywords SAPT_DFT_GRAC_SHIFT_A and SAPT_DFT_GRAC_SHIFT_B,; which should be equal to the difference of the actual ionization; potential and the corresponding Kohn-Sham HOMO energy. The dispersion; term needs to be computed with orbital response for good accuracy,; and it is recommended to enable SAPT_DFT_DO_HYBRID (set to; True by default). The coupled exchange-dispersion energy is usually; estimated by scaling from the uncoupled value either by a fitted fixed; value as suggested by [Hesselmann:2014:094107], or by the ratio of; coupled and uncoupled dispersion energy. This can be controlled by; keyword SAPT_DFT_EXCH_DISP_SCALE_SCHEME, with FIXED being; the former approach, DISP being the latter and NONE for not; scaling and use the uncoupled exchange-dispersion energy directly. Basic Keywords for SAPT(DFT)¶. SAPT_DFT_GRAC_SHIFT_A¶. Monomer A GRAC shift in Hartree. Type: double; Default: 0.0. SAPT_DFT_GRAC_SHIFT_B¶. Monomer B GRAC shift in Hartree. Type: double; Default: 0.0. SAPT_DFT_DO_DHF¶. Compute the Delta-HF correction?. Type: boolean; Default: true. SAPT_DFT_EXCH_DISP_SCALE_SCHEME¶. Scheme for approximating exchange-dispersion for SAPT-DFT. NONE Use unscaled Exch-Disp2,u . FIXED Use a fixed factor SAPT_DFT_EXCH_DISP_FIXED_SCALE to scale Exch-Disp2,u . DISP Use the ratio of Disp2,r and Disp2,u to scale Exch-Disp2,u . Type: string; Possible Values: NONE, FIXED, DISP; Default: DISP. Advanced Keywords for SAPT(DFT)¶. SAPT_DFT_FUNCTI",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/sapt-1.html:22391,energy,energy,22391,psi4manual/1.4.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/sapt-1.html,10,['energy'],['energy']
Energy Efficiency," be set as c-side keywords; options = collections.defaultdict(lambda: collections.defaultdict(dict)); #options['QCHEM'['QCHEM_CHARGE']['value'] = self.molecular_charge(); #options['QCHEM'['QCHEM_MULTIPLICITY']['value'] = self.multiplicity(); options['QCHEM']['QCHEM_INPUT_BOHR']['value'] = False; #options['QCHEM']['QCHEM_COORDINATES']['value'] = 'CARTESIAN'; #SYM_IGNORE equiv to no_reorient, no_com, symmetry c1. options['QCHEM']['QCHEM_INPUT_BOHR']['clobber'] = True. return text, options. def format_molecule_for_psi4_xyz(self):; """"""not much examined. """"""; text = """"; if self.nallatom():. factor = 1.0 if self.PYunits == 'Angstrom' else qcel.constants.bohr2angstroms; # append units and any other non-default molecule keywords; text += ""units Angstrom\n""; #text += "" units %-s\n"" % (""Angstrom"" if self.units() == 'Angstrom' else ""Bohr""); if not self.PYmove_to_com:; text += ""no_com\n""; if self.PYfix_orientation:; text += ""no_reorient\n"". # append atoms and coordentries and fragment separators with charge and multiplicity; Pfr = 0; for fr in range(self.nfragments()):; if self.fragment_types[fr] == 'Absent' and not self.has_zmatrix():; continue; text += ""%s%s%d %d\n"" % ("""" if Pfr == 0 else ""--\n"", ""#"" if self.fragment_types[fr] == 'Ghost'; or self.fragment_types[fr] == 'Absent' else """", self.fragment_charges[fr],; self.fragment_multiplicities[fr]); Pfr += 1; for at in range(self.fragments[fr][0], self.fragments[fr][1] + 1):; if self.fragment_types[fr] == 'Absent' or self.fsymbol(at) == ""X"":; pass; else:; if self.fZ(at):; text += ""%-8s"" % (self.flabel(at)); else:; text += ""%-8s"" % (""Gh("" + self.flabel(at) + "")""); [x, y, z] = self.full_atoms[at].compute(); text += '%17.12f %17.12f %17.12f\n' % \; (x * factor, y * factor, z * factor); text += ""\n"". wtext = 'molecule mol {\n'; for line in text.splitlines():; wtext += ' ' + line + '\n'; wtext += '}\n'; return wtext. def format_molecule_for_molpro(self):; """""". """"""; factor = 1.0 if self.PYunits == 'Angstrom' else qcel.constants.bohr2a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/qcdb/molecule.html:13615,charge,charge,13615,psi4manual/1.3.2/_modules/psi4/driver/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/qcdb/molecule.html,6,['charge'],['charge']
Energy Efficiency," be specified for reference-step only jobs and name and; corl_basis keywords for correlated jobs.; The following energy methods have been set up for cbs(). scf; df-scf; mp2. df-mp2; cc2; ccsd. bccd; cc3; ccsd(t). cisd; cisdt; cisdtq. cin; fci. Parameters:; name (string) – 'scf' || 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be 'scf'. Overruled if stage_wfn keywords supplied. corl_wfn (string) – 'mp2' || 'ccsd(t)' || etc.; Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with name or as the unlabeled; first argument to the function. delta_wfn (string) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. delta_wfn_lesser (string) – 'mp2' || 'ccsd' || etc.; Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. delta2_wfn (string) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. delta2_wfn_lesser (string) – 'mp2' || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. Basis Sets; Currently, the basis set set through set commands have no influence; on a cbs calculation. Parameters:; scf_basis (basis string) – corl_basis || 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, scf_basis can default; to corl_basis. corl_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the correlation energy. delta_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/cbs-1.html:3477,energy,energy,3477,psi4manual/4.0b3/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/cbs-1.html,4,['energy'],['energy']
Energy Efficiency," be specified with name or as the unlabeled; first argument to the function. delta_wfn (string) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. delta_wfn_lesser (string) – 'mp2' || 'ccsd' || etc.; Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. delta2_wfn (string) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. delta2_wfn_lesser (string) – 'mp2' || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. Basis Sets; Currently, the basis set set through set commands have no influence; on a cbs calculation. Parameters:; scf_basis (basis string) – corl_basis || 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, scf_basis can default; to corl_basis. corl_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the correlation energy. delta_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. delta2_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, 'highest_1', which uses the best basis; set available. See Extrapolation Schemes for all avai",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/cbs-1.html:4025,energy,energy,4025,psi4manual/4.0b2/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/cbs-1.html,6,['energy'],['energy']
Energy Efficiency," be zero otherwise. This becomes nsing (option #2) in fort.56. Type: integer; Default: 1. MRCC_NUM_TRIPLET_ROOTS (MRCC); MRCC — Number of triplet roots. (Strictly speaking number of of roots with and S is odd.) See notes at option MRCC_NUM_SINGLET_ROOTS. This becomes ntrip (option #3) in fort.56. Type: integer; Default: 0. MRCC_OMP_NUM_THREADS (MRCC); MRCC (Expert) — Sets the OMP_NUM_THREADS environment variable before calling MRCC. If the environment variable OMP_NUM_THREADS is set prior to calling PSI4 then that value is used. When set, this option overrides everything. Be aware the -n command-line option described in section Threading does not affect MRCC. Type: integer; Default: 1. MRCC_RESTART (MRCC); MRCC (Expert) — The program restarts from the previously calculated parameters if it is 1. In case it is 2, the program executes automatically the lower-level calculations of the same type consecutively (e.g., CCSD, CCSDT, and CCSDTQ if CCSDTQ is requested) and restarts each calculation from the previous one (rest=2 is available only for energy calculations). Currently, only a value of 0 and 2 are supported. This becomes rest (option #4) in fort.56. Type: integer; Default: 0. MS0 (DETCI); DETCI — Do use the component of the state? Defaults to TRUE if closed-shell and FALSE otherwise. Related to the S option. Type: boolean; Default: false. NAT_ORBS (FNOCC); FNOCC — Do use MP2 NOs to truncate virtual space for QCISD/CCSD and (T)?. Type: boolean; Default: false. NAT_ORBS (OCC); OCC — Do compute natural orbitals?. Type: boolean; Default: false. NAT_ORBS (SAPT); SAPT — Do natural orbitals to speed up evaluation of the triples contribution to dispersion by truncating the virtual orbital space? Recommended true for all SAPT computations. Type: boolean; Default: false. NAT_ORBS_T2 (SAPT); SAPT — Do use MP2 natural orbital approximations for the block of two-electron integrals in the evaluation of second-order T2 amplitudes? This approximation is promising for accuracy and ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_glossary_options_c-1.html:85036,energy,energy,85036,psi4manual/4.0b4/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_glossary_options_c-1.html,2,['energy'],['energy']
Energy Efficiency," be zero otherwise. This becomes nsing (option #2) in fort.56. Type: integer; Default: 1. MRCC_NUM_TRIPLET_ROOTS (MRCC); MRCC — Number of triplet roots. (Strictly speaking number of of roots with and S is odd.) See notes at option MRCC_NUM_SINGLET_ROOTS. This becomes ntrip (option #3) in fort.56. Type: integer; Default: 0. MRCC_OMP_NUM_THREADS (MRCC); MRCC (Expert) — Sets the OMP_NUM_THREADS environment variable before calling MRCC. If the environment variable OMP_NUM_THREADS is set prior to calling PSI4 then that value is used. When set, this option overrides everything. Be aware the -n command-line option described in section Threading does not affect MRCC. Type: integer; Default: 1. MRCC_RESTART (MRCC); MRCC (Expert) — The program restarts from the previously calculated parameters if it is 1. In case it is 2, the program executes automatically the lower-level calculations of the same type consecutively (e.g., CCSD, CCSDT, and CCSDTQ if CCSDTQ is requested) and restarts each calculation from the previous one (rest=2 is available only for energy calculations). Currently, only a value of 0 and 2 are supported. This becomes rest (option #4) in fort.56. Type: integer; Default: 0. MS0 (DETCI); DETCI — Do use the component of the state? Defaults to TRUE if closed-shell and FALSE otherwise. Related to the S option. Type: boolean; Default: false. NAT_ORBS (FNOCC); FNOCC — Do use MP2 NOs to truncate virtual space for QCISD/CCSD and (T)?. Type: boolean; Default: false. NAT_ORBS (OCC); OCC — Do compute natural orbitals?. Type: boolean; Default: false. NAT_ORBS_T2 (SAPT); SAPT — Do use MP2 natural orbital approximations for the block of two-electron integrals in the evaluation of second-order T2 amplitudes? Recommended true for all SAPT computations. Type: boolean; Default: false. NAT_ORBS_T3 (SAPT); SAPT — Do natural orbitals to speed up evaluation of the triples contribution to dispersion by truncating the virtual orbital space? Recommended true for all SAPT computations. Ty",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodoc_glossary_options_c-1.html:83790,energy,energy,83790,psi4manual/4.0b5/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodoc_glossary_options_c-1.html,2,['energy'],['energy']
Energy Efficiency," be zero otherwise. This becomes nsing (option #2) in fort.56. Type: integer; Default: 1. MRCC_NUM_TRIPLET_ROOTS (MRCC); MRCC — Number of triplet roots. (Strictly speaking number of of roots with and S is odd.) See notes at option MRCC_NUM_SINGLET_ROOTS. This becomes ntrip (option #3) in fort.56. Type: integer; Default: 0. MRCC_OMP_NUM_THREADS (MRCC); MRCC (Expert) — Sets the OMP_NUM_THREADS environment variable before calling MRCC. If the environment variable OMP_NUM_THREADS is set prior to calling PSI4 then that value is used. When set, this option overrides everything. Be aware the -n command-line option described in section Threading does not affect MRCC. Type: integer; Default: 1. MRCC_RESTART (MRCC); MRCC (Expert) — The program restarts from the previously calculated parameters if it is 1. In case it is 2, the program executes automatically the lower-level calculations of the same type consecutively (e.g., CCSD, CCSDT, and CCSDTQ if CCSDTQ is requested) and restarts each calculation from the previous one (rest=2 is available only for energy calculations). Currently, only a value of 0 and 2 are supported. This becomes rest (option #4) in fort.56. Type: integer; Default: 0. MS0 (DETCI); DETCI — Do use the component of the state? Defaults to TRUE if closed-shell and FALSE otherwise. Related to the S option. Type: boolean; Default: false. NAT_ORBS (OMP2); OMP2 — Do ?. Type: boolean; Default: false. NAT_ORBS (SAPT); SAPT — Do natural orbitals to speed up evaluation of the triples contribution to dispersion by truncating the virtual orbital space? Recommended true for all SAPT computations. Type: boolean; Default: false. NAT_ORBS_T2 (SAPT); SAPT — Do use MP2 natural orbital approximations for the block of two-electron integrals in the evaluation of second-order T2 amplitudes? This approximation is promising for accuracy and computational savings, but it has not been rigorously tested. Type: boolean; Default: false. NAT_ORBS_WRITE (DETCI); DETCI — Do write the natural",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodoc_glossary_options_c-1.html:64047,energy,energy,64047,psi4manual/4.0b2/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodoc_glossary_options_c-1.html,2,['energy'],['energy']
Energy Efficiency," be zero otherwise. This becomes nsing (option #2) in fort.56. Type: integer; Default: 1. MRCC_NUM_TRIPLET_ROOTS (MRCC); MRCC — Number of triplet roots. (Strictly speaking number of of roots with and S is odd.) See notes at option MRCC_NUM_SINGLET_ROOTS. This becomes ntrip (option #3) in fort.56. Type: integer; Default: 0. MRCC_OMP_NUM_THREADS (MRCC); MRCC (Expert) — Sets the OMP_NUM_THREADS environment variable before calling MRCC. If the environment variable OMP_NUM_THREADS is set prior to calling PSI4 then that value is used. When set, this option overrides everything. Be aware the -n command-line option described in section Threading does not affect MRCC. Type: integer; Default: 1. MRCC_RESTART (MRCC); MRCC (Expert) — The program restarts from the previously calculated parameters if it is 1. In case it is 2, the program executes automatically the lower-level calculations of the same type consecutively (e.g., CCSD, CCSDT, and CCSDTQ if CCSDTQ is requested) and restarts each calculation from the previous one (rest=2 is available only for energy calculations). Currently, only a value of 0 and 2 are supported. This becomes rest (option #4) in fort.56. Type: integer; Default: 0. MS0 (DETCI); DETCI — Do use the component of the state? Defaults to TRUE if closed-shell and FALSE otherwise. Related to the S option. Type: boolean; Default: false. NAT_ORBS (OMP2); OMP2 — Do compute natural orbitals?. Type: boolean; Default: false. NAT_ORBS (OMP3); OMP3 — Do compute natural orbitals?. Type: boolean; Default: false. NAT_ORBS (SAPT); SAPT — Do natural orbitals to speed up evaluation of the triples contribution to dispersion by truncating the virtual orbital space? Recommended true for all SAPT computations. Type: boolean; Default: false. NAT_ORBS_T2 (SAPT); SAPT — Do use MP2 natural orbital approximations for the block of two-electron integrals in the evaluation of second-order T2 amplitudes? This approximation is promising for accuracy and computational savings, but it has no",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html:80665,energy,energy,80665,psi4manual/4.0b3/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html,2,['energy'],['energy']
Energy Efficiency," be zero otherwise. This becomes nsing (option #2) in fort.56. Type: integer; Default: 1. MRCC_NUM_TRIPLET_ROOTS (MRCC); MRCC — Number of triplet roots. (Strictly speaking number of of roots with and S is odd.) See notes at option MRCC_NUM_SINGLET_ROOTS. This becomes ntrip (option #3) in fort.56. Type: integer; Default: 0. MRCC_OMP_NUM_THREADS (MRCC); MRCC (Expert) — Sets the OMP_NUM_THREADS environment variable before calling MRCC. If the environment variable OMP_NUM_THREADS is set prior to calling Psi4 then that value is used. When set, this option overrides everything. Be aware the -n command-line option described in section Threading does not affect MRCC. Type: integer; Default: 1. MRCC_RESTART (MRCC); MRCC (Expert) — The program restarts from the previously calculated parameters if it is 1. In case it is 2, the program executes automatically the lower-level calculations of the same type consecutively (e.g., CCSD, CCSDT, and CCSDTQ if CCSDTQ is requested) and restarts each calculation from the previous one (rest=2 is available only for energy calculations). Currently, only a value of 0 and 2 are supported. This becomes rest (option #4) in fort.56. Type: integer; Default: 0. MS0 (DETCI); DETCI — Do use the component of the state? Defaults to TRUE if closed-shell and FALSE otherwise. Related to the S option. Type: boolean; Default: false. NAT_ORBS (DETCI); DETCI — Build natural orbitals? The orbtials will be reordered by occuption number. Type: boolean; Default: false. NAT_ORBS (DFOCC); DFOCC — Do compute natural orbitals?. Type: boolean; Default: false. NAT_ORBS (FNOCC); FNOCC — Do use MP2 NOs to truncate virtual space for QCISD/CCSD and (T)?. Type: boolean; Default: false. NAT_ORBS (OCC); OCC — Do compute natural orbitals?. Type: boolean; Default: false. NAT_ORBS_T2 (SAPT); SAPT — Do use MP2 natural orbital approximations for the block of two-electron integrals in the evaluation of second-order T2 amplitudes? Recommended true for all SAPT computations. Type: bool",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:168414,energy,energy,168414,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,2,['energy'],['energy']
Energy Efficiency," below for monomer-centered basis; computations). They are defined by:. (6). (7); Additionally, high-order coupling between induction and dispersion can be; extracted from the supermolecular MP2 interaction energy:. where is the correlation part of the supermolecular MP2; interaction energy. and also improve the; description of electrostatically dominated complexes. ; can be applied to SAPT2+ or SAPT2+(3) energies whereas ; should be applied to SAPT2+3 energies.; A thorough analysis of the performance of these truncations of SAPT can be; found in a review by Hohenstein and Sherrill [Hohenstein:2012:WIREs],; and a systematic study of the accuracy of these truncations (with and; without an improved CCD treatment of dispersion) using different basis sets; is reported in [Parker:2014:094106].; The SAPT module relies entirely on the density-fitting approximation; of the two-electron integrals. The factorization of the SAPT energy; expressions, as implemented in Psi4, assumes the use of density-fitted; two-electron integrals, therefore, the SAPT module cannot be run with; exact integrals. In practice, we have found that the density-fitting; approximation introduces negligible errors into the SAPT energy; (often less than 0.01 kcal/mol for small dimers) and greatly; improves efficiency. The S2 approximation and scaling¶; All exchange terms in SAPT arise from the antisymmetrization; of the wavefunctions of monomers A and B. Taking into account exchange of all possible; electron pairs between the two monomers yields to complicated formulae.; For this reason, exchange terms are often evaluated in the ; approximation, that can be interpreted as the exchange of a single electron; pair between monomers.; The approximation is usually pretty good, but may; break down for short intermolecular distance, particularly in high-order; terms. To compensate these deviations, Parker et al. [Parker:2014:094106]; recommend to scale all approximated exchange terms by the ratio:. where the rec",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/sapt-1.html:3896,energy,energy,3896,psi4manual/1.0.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/sapt-1.html,2,['energy'],['energy']
Energy Efficiency," below. Input File; Description. scf5; Test of all different algorithms and reference types for SCF, on singlet and triplet O2, using the cc-pVTZ basis set. cc13; UHF-CCSD/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. mints9; A test of the basis specification. Various basis sets are specified outright and in blocks, both orbital and auxiliary. Constructs libmints BasisSet objects through the constructor that calls qcdb.BasisSet infrastructure. Checks that the resulting bases are of the right size and checks that symmetry of the Molecule observes the basis assignment to atoms. fci-h2o-2; 6-31G H2O Test FCI Energy Point. fd-gradient; SCF STO-3G finite-difference tests. omp2-grad2; OMP2 cc-pVDZ gradient for the NO radical. dfep2-2; Compute three IP and 2 EA’s for the PH3 molecule. phi-ao; Test computing values of basis functions (puream and non-puream) at points. dfcasscf-sp; CASSCF/6-31G** energy point. mints6; Patch of a glycine with a methyl group, to make alanine, then DF-SCF energy calculation with the cc-pVDZ basis set. dfmp2-grad1; DF-MP2 cc-pVDZ gradients for the H2O molecule. sapt-dft2; SAPT(DFT) aug-cc-pVDZ computation for the water dimer interaction energy. dfomp2p5-1; DF-OMP2.5 cc-pVDZ energy for the H2O molecule. freq-masses; check nonphysical masses possible. cc17; Single point energies of multiple excited states with EOM-CCSD. fci-coverage; 6-31G H2O Test for coverage. cdoremp-energy1; Cholesky decomposed OO-REMP/cc-pVDZ energy for the H2O molecule. sapt2; SAPT0 aug-cc-pVDZ computation of the benzene-methane interaction energy, using the aug-pVDZ-JKFIT DF basis for SCF, the aug-cc-pVDZ-RI DF basis for SAPT0 induction and dispersion, and the aug-pVDZ-JKFIT DF basis for SAPT0 electrostatics and induction. This example uses frozen core as well as asyncronous I/O while forming the DF integrals and CPHF coefficients. zaptn-nh2; ZAPT(n)/6-31G NH2 Energy Point, with n=2-25. dfomp2-grad2; OMP2 cc-pVDZ energy for the NO molecule. dct2; DC-",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/testsuite.html:1869,energy,energy,1869,psi4manual/1.8.x/testsuite.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/testsuite.html,1,['energy'],['energy']
Energy Efficiency," benchmark traverse of BLAS 2 routines. benchmark_blas3(max_dim, min_time, nthread); Perform benchmark traverse of BLAS 3 routines. benchmark_disk(max_dim, min_time); Perform benchmark of PSIO disk performance. benchmark_integrals(max_am, min_time); Perform benchmark of psi integrals (of libmints type). benchmark_math(min_time); Perform benchmark of common double floating point operations including most of cmath. ccdensity(ref_wfn); Runs the code to compute coupled cluster density matrices. ccenergy(ref_wfn); Runs the coupled cluster energy code. cceom(ref_wfn); Runs the equation of motion coupled cluster code for excited states. cchbar(ref_wfn); Runs the code to generate the similarity transformed Hamiltonian. cclambda(ref_wfn); Runs the coupled cluster lambda equations code. ccresponse(ref_wfn); Runs the coupled cluster response theory code. cctransort(ref_wfn); Runs cctransort that transforms and reorders integrals for use in the coupled cluster codes. cctriples(ref_wfn); Runs the coupled cluster (T) energy code. clean(); Remove scratch files. clean_options(); Reset options to clean state. clean_timers(); Reinitialize timers for independent timer.dat entries. clean_variables(); Empties all double and Matrix QCVariables that have been set in global memory. close_outfile(); Closes the output file. dct(ref_wfn); Runs the density cumulant (functional) theory code. del_array_variable(key); Removes the Matrix QCVariable key (case-insensitive); prefer del_variable(). del_scalar_variable(key); Removes the double QCVariable key (case-insensitive); prefer del_variable(). del_variable(key); Removes scalar or array QCVariable key from global memory if present. detci(ref_wfn); Runs the determinant-based configuration interaction code. dfmp2(ref_wfn); Runs the DF-MP2 code. dfocc(ref_wfn); Runs the density-fitted orbital optimized CC codes. dmrg(ref_wfn); Runs the CheMPS2 interface DMRG code. doublet(A, B, transA, transB); Returns the multiplication of two matrices A and B, wit",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/psi4api-1.html:3617,energy,energy,3617,psi4manual/1.4.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/psi4api-1.html,2,['energy'],['energy']
Energy Efficiency," benchmark. 'S220' Jurecka et al. PCCP 8 1985 (2006).; 'S22A' Takatani et al. JCP 132 144104 (2010).; \(\Rightarrow\) 'S22B' \(\Leftarrow\) Marshall et al. JCP 135 194102 (2011). subset. 'small' water dimer, methane dimer, ethene-ethine; 'large' adenine-thymine; 'HB' hydrogen-bonded systems; 'MX' mixed-influence systems; 'DD' dispersion-dominated systems; 'S11' smaller systems in S22; 'WATER' water dimer. NCB31¶. Database (Truhlar) of several classes of noncovalent interactions.; Geometries from Truhlar and coworkers at site http://comp.chem.umn.edu/database_noncov/noncovalent.htm; Reference energies from Truhlar and coworkers at site http://comp.chem.umn.edu/database_noncov/noncovalent.htm; First comprehensive citation JPCA 109 5656 (2005). cp 'off' || 'on'; rlxd 'off' || 'on'; benchmark. '<benchmark_name>' <Reference>.; \(\Rightarrow\) '<default_benchmark_name>' \(\Leftarrow\) <Reference>. subset. 'small' 3: HF-HF, He-Ne, HCCH-HCCH; 'large' 1: BzBz_PD; 'HB6' hydrogen-bonded; 'CT7' charge-transfer; 'DI6' dipole-interacting; 'WI7' weakly interacting; 'PPS5' pi-pi stacking. A24¶. Database (Hobza) of interaction energies for bimolecular complexes.; Geometries from <Reference>.; Reference interaction energies from Rezac and Hobza, JCTC (in press). cp 'off' <erase this comment and after unless on is a valid option> || 'on'; rlxd 'off' <erase this comment and after unless on is valid option> || 'on'; benchmark. '<benchmark_name>' <Reference>.; \(\Rightarrow\) '<default_benchmark_name>' \(\Leftarrow\) <Reference>. subset. 'small' <members_description>; 'large' <members_description>; '<subset>' <members_description>. RSE42¶. Database of radical stabilization energies.; Geometries from [E. Soydas and U. Bozkaya, JCTC, 9, 1452-1460 (2013)].; Reference radical stabilization energies from [E. Soydas and U. Bozkaya, JCTC, 9, 1452-1460 (2013)] at CCSD(T)/cc-pCVTZ level. benchmark. 'RSE42' [E. Soydas and U. Bozkaya, JCTC, 9, 1452-1460 (2013)].; \(\Rightarrow\) 'RSE42' \(\Leftarrow",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodoc_available_databases.html:4133,charge,charge-transfer,4133,psi4manual/1.6.x/autodoc_available_databases.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodoc_available_databases.html,2,['charge'],['charge-transfer']
Energy Efficiency," benzene-methane interaction energy, using the aug-pVDZ-JKFIT DF basis for SCF, the aug-cc-pVDZ-RI DF basis for SAPT0 induction and dispersion, and the aug-pVDZ-JKFIT DF basis for SAPT0 electrostatics and induction. This example uses frozen core as well as asyncronous I/O while forming the DF integrals and CPHF coefficients. zaptn-nh2; ZAPT(n)/6-31G NH2 Energy Point, with n=2-25. dfomp2-grad2; OMP2 cc-pVDZ energy for the NO molecule. dct2; DC-06 calculation for the He dimer. This performs a two-step update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the MO Basis. dft1-alt; DFT Functional Test. pywrap-bfs; apply linear fragmentation algorithm to a water cluster. dft-b2plyp; Double-hybrid density functional B2PYLP. Reproduces portion of Table I in S. Grimme’s J. Chem. Phys 124 034108 (2006) paper defining the functional. mp2-1; All-electron MP2 6-31G** geometry optimization of water. cc8c; ROHF-CCSD cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Cartesian input. mbis-6; MBIS calculation on H2O. scf-freq1; Analytic vs. finite difference DF-SCF frequency test for water. cc13c; Tests RHF CCSD(T)gradients. cubeprop-frontier; ROHF frontier orbitals of CH2(s) and CH2(t). mp3-grad1; MP3 cc-pVDZ gradient for the H2O molecule. sad-scf-type; Test SAD SCF guesses on noble gas atom. x2c1; Test of SFX2C-1e on water uncontracted cc-pVDZ-DK The reference numbers are from Lan Cheng’s implementation in Cfour. cc38; RHF-CC2-LR/cc-pVDZ static polarizabilities of HOF molecule. freq-isotope2; Vibrational and thermo analysis of several water isotopologs. Demonstrates Hessian reuse for different temperatures, pressures, and isotopologs. mp2-grad2; MP2 cc-pVDZ gradient for the NO radical. casscf-fzc-sp; CASSCF/6-31G** energy point. rasci-ne; Ne atom RASCI/cc-pVQZ Example of split-virtual CISD[TQ] from Sherrill and Schaefer, J. Phys. Chem. XXX This uses a “primary” virtual space 3s3p (RAS 2), a “secondary” virtu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html:2665,energy,energy,2665,psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency," between the two hydroxyl groups). dfmp2-2; Density fitted MP2 energy of H2, using density fitted reference and automatic looping over cc-pVDZ and cc-pVTZ basis sets. Results are tabulated using the built in table functions by using the default options and by specifiying the format. cc8a; ROHF-CCSD(T) cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Cartesian input. cbs-xtpl-gradient; Various gradients for a strained helium dimer and water molecule. dft-jk; DFT JK on-disk test. cbs-xtpl-opt; Various extrapolated optimization methods for the H2 molecule. ci-multi; BH single points, checking that program can run multiple instances of DETCI in a single input, without an intervening clean() call. fd-freq-gradient-large; SCF DZ finite difference frequencies by energies for C4NH4. soscf-ref; Triple and Singlet Oxygen energy SOSCF, also tests non-symmetric density matrices. cisd-h2o+-0; 6-31G** H2O+ Test CISD Energy Point. sapt-dft-lrc; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. psimrcc-ccsd_t-4; Mk-MRCCSD(T) single point. \(^1A_1\) O$_3` state described using the Ms = 0 component of the singlet. Uses TCSCF orbitals. casscf-semi; CASSCF/6-31G** energy point. Check energy with frozen core/virtual orbs. after semicanonicalization. mp2-grad1; MP2 cc-pVDZ gradient for the H2O molecule. omp3-grad2; OMP3 cc-pVDZ gradient for the NO radical. fsapt1; This test case shows an example of running and analyzing a standard F-SAPT0/jun-cc-pvdz procedure for phenol dimer from the S22 database. extern1; External potential calculation involving a TIP3P water and a QM water. Finite different test of the gradient is performed to validate forces. cisd-h2o+-2; 6-31G** H2O+ Test CISD Energy Point. sapt1; SAPT0 cc-pVDZ computation of the ethene-ethyne interaction energy, using the cc-pVDZ-JKFIT RI basis for SCF and cc-pVDZ-RI for SAPT. Monomer geometries are specified using Cartesian coordinates. scf-upcast-custom-basis; test scf castup with c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html:2493,energy,energy,2493,psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency," between two molecules.; PSI4 also provides the cbs() wrapper,; which automatically computes a complete-basis-set extrapolation (and; automatically sets up the computations with different basis sets required to; do the extrapolation). For example,. PSIthonPsiAPI# all equivalent. energy('mp2', corl_basis='cc-pv[dt]z', corl_scheme='corl_xtpl_helgaker_2'). energy('mp2/cc-pv[dt]z'). # all equivalent. psi4.energy('mp2', corl_basis='cc-pv[dt]z', corl_scheme='corl_xtpl_helgaker_2'). psi4.energy('mp2/cc-pv[dt]z'). will compute a 2-point Helgaker extrapolation of the correlation energy; using the cc-pVDZ and cc-pVTZ basis sets (with method MP2) and add this; extrapolated correlation energy to the Hartree–Fock energy in the; largest basis (cc-pVTZ). cbs() can; be configured behind-the-scenes with explicit arguments, as in the; first example, or the convenience syntax of the equivalent second; example can be used.; Another very useful and powerful feature of PSI4 is the ability; to compute results on entire databases of molecules at a time,; as provided by the database() wrapper. For example,. PSIthonPsiAPIdatabase('mp2', 'S22', cp=1, benchmark='S22B'). psi4.wrapper_database.database('mp2', 'S22', cp=1, benchmark='S22B'). will perform DF-MP2 counterpoise-corrected interaction energies; (cp=1) on all members of Hobza’s S22 database set of van der Waals; dimers, and then compare the results against the S22B benchmark energies.; Built-in databases include S22, A24, HTBH, HBC6, HSG, S22by5, S66, JSCH,; NCB31, S66by8, and NBC10, among others.; These wrapper functions are discussed separately in; Psithon Functions: Invoking a Calculation. Note that the options documented for Python; functions are placed as arguments in the command that calls the function,; not in the set {...} block or with any other set command. table of contents. Psithon: Structuring an Input File; Physical Constants; Memory Specification; Molecule and Geometry Specification; Job Control Keywords; Basis Sets; PSI V",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/psithoninput.html:17415,power,powerful,17415,psi4manual/master/psithoninput.html,https://psicode.org,https://psicode.org/psi4manual/master/psithoninput.html,1,['power'],['powerful']
Energy Efficiency," bimolecular complex where monomers are unspecified so driver auto-fragments it. Basis set and auxiliary basis sets are assigned by atom type. cbs-xtpl-energy; Extrapolated water energies - density-fitted version. pywrap-db1; Database calculation, so no molecule section in input file. Portions of the full databases, restricted by subset keyword, are computed by sapt0 and dfmp2 methods. dfmp2-grad1; DF-MP2 cc-pVDZ gradients for the H2O molecule. dct6; DCT calculation for the triplet O2 using DC-06 and DC-12. Only two-step algorithm is tested. explicit-am-basis; Check that basis sets can be input with explicit angular momentum format. cc29; CCSD/cc-pVDZ optical rotation calculation (both gauges) on Cartesian H2O2. dft-grac; Gradient regularized asymptotic correction (GRAC) test. dct4; DCT calculation for the HF+ using DC-06 functional. This performs both two-step and simultaneous update of the orbitals and cumulant using DIIS extrapolation. Four-virtual integrals are first handled in the MO Basis for the first two energy computations. In the next two the ao_basis=disk algorithm is used, where the transformation of integrals for four-virtual case is avoided. The computation is then repeated using the DC-12 functional with the same algorithms. pywrap-db3; Test that Python Molecule class processes geometry like psi4 Molecule class. psimrcc-ccsd_t-1; Mk-MRCCSD(T) single point. \(^1A_1\) CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. scf-cholesky-basis; incremental Cholesky filtered SCF. cc9; UHF-CCSD(T) cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Z-matrix input. opt4; SCF cc-pVTZ geometry optimzation, with Z-matrix input. dfep2-1; Compute three IP and 2 EA’s for the PH3 molecule. cc8c; ROHF-CCSD cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Cartesian input. dfmp2-4; conventional and density-fitting mp2 test of mp2 itself and setting scs-mp2. soscf-large; Second",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html:31172,energy,energy,31172,psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency," bohr. :returns: *unit_conv* Conversion factor between the geometry specification units and bohr; """"""; unit_name = self.molecule.units(); if unit_name == ""Angstrom"":; # beware if MDI and psi4 choose different sets of constants; unit_conv = psi4.driver.constants.bohr2angstroms; elif unit_name == ""Bohr"":; unit_conv = 1.0; else:; raise Exception('Unrecognized unit type: ' + str(unit_name)). return unit_conv. # Respond to the <NATOMS command; def send_natoms(self):; """""" Send the number of atoms through MDI; """"""; natom = self.molecule.natom(); MDI_Send(natom, 1, MDI_INT, self.comm); return natom. # Respond to the <COORDS command; def send_coords(self):; """""" Send the nuclear coordinates through MDI; """"""; coords = self.molecule.geometry().np.ravel(); MDI_Send(coords, len(coords), MDI_DOUBLE, self.comm); return coords. # Respond to the <CHARGES command; def send_charges(self):; """""" Send the nuclear charges through MDI. :returns: *charges* Atomic charges; """"""; natom = self.molecule.natom(); charges = [self.molecule.charge(iatom) for iatom in range(natom)]; MDI_Send(charges, natom, MDI_DOUBLE, self.comm); return charges. # Respond to the <MASSES command; def send_masses(self):; """""" Send the nuclear masses through MDI. :returns: *masses* Atomic masses; """"""; natom = self.molecule.natom(); molecule_dict = self.molecule.to_dict(); masses = molecule_dict['mass']; MDI_Send(masses, natom, MDI_DOUBLE, self.comm); return masses. # Respond to the <ELEMENTS command; def send_elements(self):; """""" Send the atomic number of each nucleus through MDI. :returns: *elements* Element of each atom; """"""; natom = self.molecule.natom(); elements = [self.molecule.true_atomic_number(iatom) for iatom in range(natom)]; MDI_Send(elements, natom, MDI_INT, self.comm); return elements. # Respond to the <ENERGY command; def send_energy(self):; """""" Send the total energy through MDI. :returns: *energy* Energy of the system; """"""; self.run_scf(); MDI_Send(self.energy, 1, MDI_DOUBLE, self.comm); return self.energy",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/mdi_engine.html:5697,charge,charges,5697,psi4manual/1.9.x/_modules/psi4/driver/mdi_engine.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/mdi_engine.html,2,['charge'],['charges']
Energy Efficiency," bool :; | Checks if variable arg2 is in the list, returns true if it is, and returns false if not; | ; | label(...); | label( (Molecule)arg1, (int)arg2) -> str :; | Gets the original label of the atom as given in the input file (C2, H4); | ; | mass(...); | mass( (Molecule)arg1, (int)arg2) -> float :; | Gets mass of atom arg2; | ; | molecular_charge(...); | molecular_charge( (Molecule)arg1) -> int :; | Gets the molecular charge; | ; | move_to_com(...); | move_to_com( (Molecule)arg1) -> None :; | Moves molecule to center of mass; | ; | multiplicity(...); | multiplicity( (Molecule)arg1) -> int :; | Gets the multiplicity (defined as 2Ms + 1); | ; | name(...); | name( (Molecule)arg1) -> str :; | Gets molecule name; | ; | natom(...); | natom( (Molecule)arg1) -> int :; | Number of real atoms; | ; | nfragments(...); | nfragments( (Molecule)arg1) -> int :; | Gets the number of fragments in the molecule; | ; | nuclear_repulsion_energy(...); | nuclear_repulsion_energy( (Molecule)arg1) -> float :; | Computes nuclear repulsion energy; | ; | point_group(...); | point_group( (Molecule)arg1) -> PointGroup :; | Returns the current point group object; | ; | print_in_input_format(...); | print_in_input_format( (Molecule)arg1) -> None :; | Prints the molecule as Cartesian or ZMatrix entries, just as inputted.; | ; | print_out(...); | print_out( (Molecule)arg1) -> None :; | Prints the molecule in Cartesians in input units; | ; | print_out_in_angstrom(...); | print_out_in_angstrom( (Molecule)arg1) -> None :; | Prints the molecule in Cartesians in Angstroms; | ; | print_out_in_bohr(...); | print_out_in_bohr( (Molecule)arg1) -> None :; | Prints the molecule in Cartesians in Bohr; | ; | reinterpret_coordentry(...); | reinterpret_coordentry( (Molecule)arg1, (bool)arg2) -> None :; | Do reinterpret coordinate entries during update_geometry().; | ; | reset_point_group(...); | reset_point_group( (Molecule)arg1, (str)arg2) -> None :; | Overrides symmetry from outside the molecule string; | ; | ru",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/psimod-1.html:56646,energy,energy,56646,psi4manual/4.0b3/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html,6,['energy'],['energy']
Energy Efficiency," boolean; Default: false. T_AMPS (CCHBAR); CCHBAR — Do compute the T amplitude equation matrix elements?. Type: boolean; Default: false. TDHF_MEM_SAFETY_FACTOR (CPHF); CPHF — Memory safety factor for allocating JK. Type: double; Default: 0.75. TDM (DETCI); DETCI — Do compute the transition density? Note: only transition densities between roots of the same symmetry will be evaluated. DETCI does not compute states of different irreps within the same computation; to do this, lower the symmetry of the computation. Type: boolean; Default: false. TEST_B (OPTKING); OPTKING — Do test B matrix?. Type: boolean; Default: false. TEST_DERIVATIVE_B (OPTKING); OPTKING — Do test derivative B matrix?. Type: boolean; Default: false. THETA_POINTS (SCF); SCF — Number of colatitude grid points for spherical potential integration. Type: integer; Default: 360. THICKNESS (SCF); SCF — Thickness (bohr) of a hard-sphere external potential. Type: double; Default: 20.0. THREE_PARTICLE (DCFT); DCFT — Whether to compute three-particle energy correction or not. Type: string; Possible Values: NONE, PERTURBATIVE; Default: NONE. TIKHONOW_MAX (PSIMRCC); PSIMRCC — The cycle after which Tikhonow regularization is stopped. Set to zero to allow regularization in all iterations. Type: integer; Default: 5. TIKHONOW_OMEGA (DCFT); DCFT (Expert) — The shift applied to the denominator in the density cumulant update iterations. Type: double; Default: 0.0. TIKHONOW_OMEGA (PSIMRCC); PSIMRCC — The shift to apply to the denominators, {it c.f.} Taube and Bartlett, JCP, 130, 144112 (2009). Type: double; Default: 0.0. TIKHONOW_TRIPLES (PSIMRCC); PSIMRCC (Expert) — Do use Tikhonow regularization in (T) computations?. Type: boolean; Default: false. TILE_SZ (SCF); SCF (Expert) — The tile size for the distributed matrices. Type: integer; Default: 512. TPDM (DETCI); DETCI (Expert) — Do compute two-particle density matrix if not otherwise required? Warning: This will hold 4 dense active TPDM’s in memory. Type: boolean; Defau",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html:216778,energy,energy,216778,psi4manual/1.2.1/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html,4,['energy'],['energy']
Energy Efficiency," boolean; Default: true. FRAC_START (SCF); SCF — The iteration to start fractionally occupying orbitals (or 0 for no fractional occupation). Type: integer; Default: 0. FRAC_VAL (SCF); SCF — The occupations of the orbital indices specified above (). Type: array; Default: No Default. FRAG_MODE (OPTKING); OPTKING — For multi-fragment molecules, treat as single bonded molecule or via interfragment coordinates. A primary difference is that in MULTI mode, the interfragment coordinates are not redundant. Type: string; Possible Values: SINGLE, MULTI; Default: SINGLE. FREEZE_CORE (GLOBALS); GLOBALS — Specifies how many core orbitals to freeze in correlated computations. TRUE will default to freezing the standard default number of core orbitals. For PSI, the standard number of core orbitals is the number of orbitals in the nearest previous noble gas atom. More precise control over the number of frozen orbitals can be attained by using the keywords NUM_FROZEN_DOCC (gives the total number of orbitals to freeze, program picks the lowest-energy orbitals) or FROZEN_DOCC (gives the number of orbitals to freeze per irreducible representation). Type: string; Possible Values: FALSE, TRUE; Default: FALSE. FREEZE_CORE (SAPT); SAPT — The scope of core orbitals to freeze in evaluation of SAPT and terms. Recommended true for all SAPT computations. Type: string; Possible Values: FALSE, TRUE; Default: FALSE. FREEZE_INTERFRAG (OPTKING); OPTKING — Do freeze all interfragment modes?. Type: boolean; Default: false. FREEZE_INTRAFRAG (OPTKING); OPTKING — Do freeze all fragments rigid?. Type: boolean; Default: false. FROZEN_BEND (OPTKING); OPTKING — Specify angles between atoms to be frozen (unchanged). Type: string; Default: No Default. FROZEN_CARTESIAN (OPTKING); OPTKING — Specify atom and X, XY, XYZ, ... to be frozen (unchanged). Type: string; Default: No Default. FROZEN_DIHEDRAL (OPTKING); OPTKING — Specify dihedral angles between atoms to be frozen (unchanged). Type: string; Default: No Default",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:128800,energy,energy,128800,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,2,['energy'],['energy']
Energy Efficiency," boolean; Default: true. FRAC_START (SCF); SCF — The iteration to start fractionally occupying orbitals (or 0 for no fractional occupation). Type: integer; Default: 0. FRAC_VAL (SCF); SCF — The occupations of the orbital indices specified above (). Type: array; Default: No Default. FRAG_MODE (OPTKING); OPTKING — For multi-fragment molecules, treat as single bonded molecule or via interfragment coordinates. A primary difference is that in MULTI mode, the interfragment coordinates are not redundant. Type: string; Possible Values: SINGLE, MULTI; Default: SINGLE. FREEZE_CORE (GLOBALS); GLOBALS — Specifies how many core orbitals to freeze in correlated computations. TRUE will default to freezing the standard default number of core orbitals. For PSI, the standard number of core orbitals is the number of orbitals in the nearest previous noble gas atom. More precise control over the number of frozen orbitals can be attained by using the keywords NUM_FROZEN_DOCC (gives the total number of orbitals to freeze, program picks the lowest-energy orbitals) or FROZEN_DOCC (gives the number of orbitals to freeze per irreducible representation). Type: string; Possible Values: FALSE, TRUE; Default: FALSE. FREEZE_CORE (SAPT); SAPT — The scope of core orbitals to freeze in evaluation of SAPT and terms. Recommended true for all SAPT computations. Type: string; Possible Values: FALSE, TRUE; Default: FALSE. FREEZE_INTERFRAG (OPTKING); OPTKING — Do freeze all interfragment modes?. Type: boolean; Default: false. FREEZE_INTRAFRAG (OPTKING); OPTKING — Do freeze all fragments rigid?. Type: boolean; Default: false. FROZEN_BEND (OPTKING); OPTKING — Specify angles between atoms to be frozen (unchanged). Type: string; Default: No Default. FROZEN_DIHEDRAL (OPTKING); OPTKING — Specify dihedral angles between atoms to be frozen (unchanged). Type: string; Default: No Default. FROZEN_DISTANCE (OPTKING); OPTKING — Specify distances between atoms to be frozen (unchanged). Type: string; Default: No Default. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodoc_glossary_options_c-1.html:48858,energy,energy,48858,psi4manual/4.0b5/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodoc_glossary_options_c-1.html,2,['energy'],['energy']
Energy Efficiency," boolean; Default: true. FRAC_START (SCF); SCF — The iteration to start fractionally occupying orbitals (or 0 for no fractional occupation). Type: integer; Default: 0. FRAC_VAL (SCF); SCF — The occupations of the orbital indices specified above (). Type: array; Default: No Default. FRAG_MODE (OPTKING); OPTKING — For multi-fragment molecules, treat as single bonded molecule or via interfragment coordinates. A primary difference is that in MULTI mode, the interfragment coordinates are not redundant. Type: string; Possible Values: SINGLE, MULTI; Default: SINGLE. FREEZE_CORE (GLOBALS); GLOBALS — Specifies how many core orbitals to freeze in correlated computations. TRUE will default to freezing the standard default number of core orbitals. For PSI, the standard number of core orbitals is the number of orbitals in the nearest previous noble gas atom. More precise control over the number of frozen orbitals can be attained by using the keywords NUM_FROZEN_DOCC (gives the total number of orbitals to freeze, program picks the lowest-energy orbitals) or FROZEN_DOCC (gives the number of orbitals to freeze per irreducible representation). Type: string; Possible Values: FALSE, TRUE; Default: FALSE. FREEZE_CORE (SAPT); SAPT — The scope of core orbitals to freeze in evaluation of SAPT and terms. Recommended true for all SAPT computations. Type: string; Possible Values: FALSE, TRUE; Default: FALSE. FREEZE_INTERFRAG (OPTKING); OPTKING — Do freeze all interfragment modes?. Type: boolean; Default: false. FREEZE_INTRAFRAG (OPTKING); OPTKING — Do freeze all fragments rigid?. Type: boolean; Default: false. FROZEN_BEND (OPTKING); OPTKING — Specify angles between atoms to be frozen. Type: string; Default: No Default. FROZEN_DIHEDRAL (OPTKING); OPTKING — Specify dihedral angles between atoms to be frozen. Type: string; Default: No Default. FROZEN_DISTANCE (OPTKING); OPTKING — Specify distances between atoms to be frozen. Type: string; Default: No Default. FROZEN_DOCC (GLOBALS); GLOBALS — An ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_glossary_options_c-1.html:48304,energy,energy,48304,psi4manual/4.0b4/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_glossary_options_c-1.html,2,['energy'],['energy']
Energy Efficiency," both the spin component scaled energy and the; unscaled MP2 energy are made available:; e_mp2=get_variable('DF-MP2 TOTAL ENERGY'); e_scs_mp2=get_variable('SCS-DF-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of; a calculation. The values for all can be printed in the output file; with the input file command print_variables(). Note that; PSI variables accumulate over a PSI4 instance and are not cleared by; clean(). So if you run in a single input file a STO-3G FCI; followed by a aug-cc-pVQZ SCF followed by a print_variables(); command, the last will include both SCF TOTAL ENERGY and; FCI TOTAL ENERGY. Don’t get excited that you got a high-quality calculation; cheaply. Refer to Appendix PSI Variables by Module for a listing of the; variables set by each module. Loops¶; Python provides many control structures, which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:; basis_sets=[""cc-pVDZ"",""cc-pVTZ"",""cc-pVQZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of basis_set is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that basis_set is a; Python variable, not a string, by prefixing it with a dollar sign. The geometry; specification supports delayed initialization of variable, which permits; potential energy scans. As an example, we can scan both the angle and bond; length in water:; molecule h2o{; O; H1 R; H1 R2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(102,106,2). set basis cc-pvdz; set scf e_convergence=11; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('scf'). The declarations of Rvals and Avals are both completely standard Python syntax.; Having named our molecule h2o we can then set the values of R and A within; the loops. Note that we do not need the dollar sign to access the Pyth",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:21382,energy,energy,21382,psi4manual/4.0b2/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html,4,['energy'],['energy']
Energy Efficiency," built-in shortcuts, so long as the relevant options; (especially EX_LEVEL) are set appropriately. Some; examples of single-refence CI, RASCI, and full CI computations are provided; in psi4/samples. Orbital spaces for CI computations¶. CI (e.g., CISD, FCI); RASCI; CASCI. FROZEN_UOCC; FROZEN_UOCC; FROZEN_UOCC [1]. (all orbitals not in; FROZEN_UOCC; or FROZEN_DOCC; are included in CI); RAS4; ACTIVE. RAS3. RAS2. RAS1. FROZEN_DOCC; FROZEN_DOCC; FROZEN_DOCC. [1]FROZEN_UOCC is not required and will be inferred if; ACTIVE is provided. However, if it is easier to specify; FROZEN_UOCC, then this may be provided and ACTIVE can; be inferred. The table above shows the relevant orbitals spaces for CI computations (an; analogous table for MCSCF is also available).; The third column of the; table refers to CASCI, in which a full CI is performed in some smaller; set of active orbitals; it is equivalent to CASSCF except without; any orbital optimization. It can be invoked via energy('fci'); with appropriate values selected for FROZEN_DOCC and; ACTIVE. For CI computations, there is no difference between; FROZEN_DOCC and RESTRICTED_DOCC, or between; FROZEN_UOCC and RESTRICTED_UOCC. There are; differences between these keywords for sec:mcscf. Basic DETCI Keywords¶. REFERENCE¶. Reference wavefunction type. Type: string; Possible Values: RHF, ROHF; Default: RHF. R_CONVERGENCE¶. Convergence criterion for CI residual vector in the Davidson algorithm (RMS error). The default is 1e-4 for energies and 1e-7 for gradients. Type: conv double; Default: 1e-4. EX_LEVEL¶. The CI excitation level. Type: integer; Default: 2. FCI¶. Do a full CI (FCI)? If TRUE, overrides the value of EX_LEVEL. Type: boolean; Default: false. FROZEN_DOCC¶. An array containing the number of frozen doubly-occupied orbitals per irrep (these are not excited in a correlated wavefunction, nor can they be optimized in MCSCF. This trumps NUM_FROZEN_DOCC and FREEZE_CORE. Type: array; Default: No Default. RESTRICTED_DOCC¶. An array ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/detci-1.html:6094,energy,energy,6094,psi4manual/1.2.1/detci-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/detci-1.html,6,['energy'],['energy']
Energy Efficiency," but is in a symmetry plane of the molecule. dcft-grad1; DCFT DC-06 gradient for the O2 molecule with cc-pVDZ basis set. pywrap-checkrun-rhf; This checks that all energy methods can run with a minimal input and set symmetry. opt5; 6-31G** UHF CH2 3B1 optimization. Uses a Z-Matrix with dummy atoms, just for demo and testing purposes. cc53; Matches Table II a-CCSD(T)/cc-pVDZ H2O @ 2.5 * Re value from Crawford and Stanton, IJQC 98, 601-611 (1998). dfomp3-1; DF-OMP3 cc-pVDZ energy for the H2O molecule. psithon1; Spectroscopic constants of H2, and the full ci cc-pVTZ level of theory. tu5-sapt; Example SAPT computation for ethene*ethine (i.e., ethylene*acetylene), test case 16 from the S22 database. cc39; RHF-CC2-LR/cc-pVDZ dynamic polarizabilities of HOF molecule. cc18; RHF-CCSD-LR/cc-pVDZ static polarizability of HOF. dfomp2-1; OMP2 cc-pVDZ energy for the H2O molecule. cc35; CC3(ROHF)/cc-pVDZ H2O \(R_e\) geom from Olsen et al., JCP 104, 8007 (1996). fd-freq-energy-large; SCF DZ finite difference frequencies by energies for C4NH4. dfomp2-grad2; OMP2 cc-pVDZ energy for the NO molecule. cc1; RHF-CCSD 6-31G** all-electron optimization of the H2O molecule. psimrcc-sp1; Mk-MRCCSD single point. \(^3 \Sigma ^-\) O2 state described using the Ms = 0 component of the triplet. Uses ROHF triplet orbitals. castup2; SCF with various combinations of pk/density-fitting, castup/no-castup, and spherical/cartesian settings. Demonstrates that puream setting is getting set by orbital basis for all df/castup parts of calc. Demonstrates that answer doesn’t depend on presence/absence of castup. Demonstrates (by comparison to castup3) that output file doesn’t depend on options (scf_type) being set global or local. This input uses global. cc10; ROHF-CCSD cc-pVDZ energy for the \(^2\Sigma^+\) state of the CN radical. opt-freeze-coords; SCF/cc-pVDZ optimization example with frozen cartesian. cc27; Single point gradient of 1-1B2 state of H2O with EOM-CCSD. mpn-bh; MP(n)/aug-cc-pVDZ BH Energy Point, ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/testsuite-1.html:14937,energy,energy-large,14937,psi4manual/1.1.0/testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/testsuite-1.html,4,['energy'],['energy-large']
Energy Efficiency," by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{corl}^X = E_{corl}^{\infty} + \beta X^{-3}. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 2):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'corl', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'corl', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; zHI = NEED['HI']['f_zeta']; eLO = NEED['LO']['f_energy']; zLO = NEED['LO']['f_zeta']. # Compute extrapolated energy; energypiece = (eHI * zHI ** 3 - eLO * zLO ** 3) / (zHI ** 3 - zLO ** 3); beta = (eHI - eLO) / (zHI ** (-3) - zLO ** (-3)). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); PsiMod.print_out(cbsscheme). return energypiece. [docs]def scf_xtpl_helgaker_3(**largs):; r""""""Extrapolation scheme for reference energies with three adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionna",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:79931,energy,energy,79931,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,6,['energy'],"['energy', 'energypiece']"
Energy Efficiency," by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{corl}^X = E_{corl}^{\infty} + \beta X^{-3}. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 2):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'corl', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'corl', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; zHI = NEED['HI']['f_zeta']; eLO = NEED['LO']['f_energy']; zLO = NEED['LO']['f_zeta']. # Compute extrapolated energy; energypiece = (eHI * zHI ** 3 - eLO * zLO ** 3) / (zHI ** 3 - zLO ** 3); beta = (eHI - eLO) / (zHI ** (-3) - zLO ** (-3)). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); psi4.print_out(cbsscheme). return energypiece. [docs]def scf_xtpl_helgaker_3(**largs):; r""""""Extrapolation scheme for reference energies with three adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:95712,energy,energy,95712,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,2,['energy'],"['energy', 'energypiece']"
Energy Efficiency," by H.-J. Werner and co-workers. Type: string; Default: WERNER. LOCAL_PAIRDEF (CCENERGY); CCENERGY — Definition of local pair domains, default is BP, Boughton-Pulay. Type: string; Possible Values: BP, RESPONSE; Default: BP. LOCAL_PAIRDEF (CCLAMBDA); CCLAMBDA — Definition of local pair domains. Type: string; Default: No Default. LOCAL_PAIRDEF (CCRESPONSE); CCRESPONSE — Definition of local pair domains. Type: string; Default: NONE. LOCAL_PAIRDEF (CCSORT); CCSORT — Definition of local pair domains, unique avaliable option is BP, Boughton-Pulay. Type: string; Default: BP. LOCAL_PRECONDITIONER (CCEOM); CCEOM — Preconditioner will be used in local CC computations. Type: string; Possible Values: HBAR, FOCK; Default: HBAR. LOCAL_WEAKP (CCENERGY); CCENERGY — Desired treatment of “weak pairs” in the local-CIS method. A value of// NEGLECT ignores weak pairs entirely. A value of NONE treats weak pairs in// the same manner as strong pairs. A value of MP2 uses second-order perturbation// theory to correct the local-CIS energy computed with weak pairs ignored. Type: string; Possible Values: MP2, NEGLECT, NONE; Default: MP2. LOCAL_WEAKP (CCEOM); CCEOM — Desired treatment of “weak pairs” in the local-CCSD method. A value of NEGLECT ignores weak pairs entirely. A value of NONE treats weak pairs in the same manner as strong pairs. A value of MP2 uses second-order perturbation theory to correct the local-CCSD energy computed with weak pairs ignored. Type: string; Possible Values: NONE, MP2, NEGLECT; Default: NONE. LOCAL_WEAKP (CCLAMBDA); CCLAMBDA — Desired treatment of “weak pairs” in the local-CCSD method. The value of NONE (unique avaliable option) treats weak pairs in the same manner as strong pairs. Type: string; Default: NONE. LOCAL_WEAKP (CCRESPONSE); CCRESPONSE — Desired treatment of “weak pairs” in the local-CCSD method. The value of NONE (unique avaliable option) treats weak pairs in the same manner as strong pairs. Type: string; Default: NONE. LOCAL_WEAKP (CCSORT); CCSORT — De",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodoc_glossary_options_c-1.html:70433,energy,energy,70433,psi4manual/4.0b5/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodoc_glossary_options_c-1.html,2,['energy'],['energy']
Energy Efficiency," by atom type. psimrcc-sp1; Mk-MRCCSD single point. O2 state described using the Ms = 0 component of the triplet. Uses ROHF triplet orbitals. fd-freq-gradient; STO-3G frequencies for H2O by finite-differences of gradients. dfmp2-1; Density fitted MP2 cc-PVDZ/cc-pVDZ-RI computation of formic acid dimer binding energy using automatic counterpoise correction. Monomers are specified using Cartesian coordinates. cc13; UHF-CCSD/cc-pVDZ CH2 geometry optimization via analytic gradients. cc34; RHF-CCSD/cc-pVDZ energy of H2O partitioned into pair energy contributions. cepa3; cc-pvdz H2O Test coupled-pair CISD against DETCI CISD. cisd-opt-fd; H2O CISD/6-31G** Optimize Geometry by Energies. mrcc1; CCSDT cc-pVDZ energy for the H2O molecule using MRCC. cc49; EOM-CC3(UHF) on CH radical with user-specified basis and properties for particular root. cc41; RHF-CC2-LR/cc-pVDZ optical rotation of H2O2. gauge = both, omega = (589 355 nm). sapt1; SAPT0 cc-pVDZ computation of the ethene-ethyne interaction energy, using the cc-pVDZ-JKFIT RI basis for SCF and cc-pVDZ-RI for SAPT. Monomer geometries are specified using Cartesian coordinates. cc39; RHF-CC2-LR/cc-pVDZ dynamic polarizabilities of HOF molecule. cisd-h2o+-2; 6-31G** H2O+ Test CISD Energy Point. mints2; A test of the basis specification. A benzene atom is defined using a ZMatrix containing dummy atoms and various basis sets are assigned to different atoms. The symmetry of the molecule is automatically lowered to account for the different basis sets. dft-b2plyp; Double-hybrid density functional B2PYLP. Reproduces portion of Table I in S. Grimme’s J. Chem. Phys 124 034108 (2006) paper defining the functional. props3; DF-SCF cc-pVDZ multipole moments of benzene, up to 7th order and electrostatic potentials evaluated at the nuclear coordinates. opt2-fd; SCF DZ allene geometry optimzation, with Cartesian input. sapt2; SAPT0 aug-cc-pVDZ computation of the benzene-methane interaction energy, using the aug-pVDZ-JKFIT DF basis for SCF, the ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_testsuite-1.html:5934,energy,energy,5934,psi4manual/4.0b3/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_testsuite-1.html,4,['energy'],['energy']
Energy Efficiency," by energies, with Z-Matrix input. dfep2-2; Compute three IP and 2 EA’s for the PH3 molecule. omp2p5-2; OMP2.5 cc-pVDZ energy for the H2O molecule. sad-scf-type; Test SAD SCF guesses on noble gas atom. dfmp2-1; Density fitted MP2 cc-PVDZ/cc-pVDZ-RI computation of formic acid dimer binding energy using automatic counterpoise correction. Monomers are specified using Cartesian coordinates. fsapt2; A very quick correctness test of F-SAPT (see fsapt1 for a real example). cepa3; cc-pvdz H2O Test coupled-pair CISD against DETCI CISD. dfomp2-3; OMP2 cc-pVDZ energy for the H2O molecule. cc19; CCSD/cc-pVDZ dipole polarizability at two frequencies. opt12; SCF cc-pVDZ geometry optimzation of ketene, starting from bent structure. cc17; Single point energies of multiple excited states with EOM-CCSD. props2; DF-SCF cc-pVDZ of benzene-hydronium ion, scanning the dissociation coordinate with Python’s built-in loop mechanism. The geometry is specified by a Z-matrix with dummy atoms, fixed parameters, updated parameters, and separate charge/multiplicity specifiers for each monomer. One-electron properties computed for dimer and one monomer. opt2; SCF DZ allene geometry optimization, with Cartesian input, first in c2v symmetry, then in Cs symmetry from a starting point with a non-linear central bond angle. dft1; DFT Functional Test all values update for new BraggSlater radii. fd-freq-energy; SCF STO-3G finite-difference frequencies from energies for H2O. cc-module; check that CC is returning the same values btwn CC*, FNOCC, and DFOCC modules. omp3-grad2; OMP3 cc-pVDZ gradient for the NO radical. scf2; RI-SCF cc-pVTZ energy of water, with Z-matrix input and cc-pVTZ-RI auxilliary basis. sapt9; usapt example with empty beta. nbody-multi-level; Multilevel computation of water trimer energy (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). pubchem1; Benzene vertical singlet-triplet energy difference computation, using the PubChem database to obtain the initial geometry, which is",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html:25454,charge,charge,25454,psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,4,['charge'],['charge']
Energy Efficiency," by wrapper counterpoise_correct.' % (func.__name__)); if (func is db):; raise ValidationError('Wrapper counterpoise_correct is unhappy to be calling function \'%s\'.' % (func.__name__)). if 'check_bsse' in kwargs and yes.match(str(kwargs['check_bsse'])):; check_bsse = True; else:; check_bsse = False. # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = psi4.get_active_molecule(); molecule.update_geometry(); psi4.set_global_option(""BASIS"", psi4.get_global_option(""BASIS"")). df_ints_io = psi4.get_global_option('DF_INTS_IO'); # inquire if above at all applies to dfmp2 or just scf; psi4.set_global_option('DF_INTS_IO', 'SAVE'); psioh = psi4.IOManager.shared_object(); psioh.set_specific_retention(97, True). activate(molecule); molecule.update_geometry(). psi4.print_out(""\n""); p4util.banner(""CP Computation: Complex.\nFull Basis Set.""); psi4.print_out(""\n""); e_dimer = call_function_in_1st_argument(func, **kwargs); #e_dimer = energy(name, **kwargs). psi4.clean(); psi4.set_global_option('DF_INTS_IO', 'LOAD'). # All monomers with ghosts; monomers = extract_clusters(molecule, True, 1); e_monomer_full = []. cluster_n = 0; for cluster in monomers:; activate(cluster); psi4.print_out(""\n""); p4util.banner((""CP Computation: Monomer %d.\n Full Basis Set."" % (cluster_n + 1))); psi4.print_out(""\n""); e_monomer_full.append(call_function_in_1st_argument(func, **kwargs)); #e_monomer_full.append(energy(name,**kwargs)); cluster_n = cluster_n + 1; psi4.clean(). psi4.set_global_option('DF_INTS_IO', 'NONE'); if (check_bsse):; # All monomers without ghosts; monomers = extract_clusters(molecule, False, 1); e_monomer_bsse = []. cluster_n = 0; for cluster in monomers:; activate(cluster); psi4.print_out(""\n""); #cluster.print_to_output(); p4util.banner((""CP Computation: Monomer %d.\n Monomer Set."" % (cluster_n + 1))); psi4.print_out(""\n""); e_monomer_bsse.append(call_function_in_1st_argument(func, **kwar",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:20389,energy,energy,20389,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,1,['energy'],['energy']
Energy Efficiency," c) TOTAL ENERGY¶; The total energy [E_h] of a component of the requested N-Body energy.; The first parenthetical list over i, j, …, k enumerates; molecular fragments included in the computation in 1-indexed,; input-file order, while the second enumerates list over a, b,; …, c enumerates which fragments contribute basis functions to the; computation. For example, (1, 2)@(1, 2, 3, 4) indicates that the; fragments 1 and 2 are explicitly included in the energy computation,; with basis functions from each of fragments 1, 2, 3, & 4 included in; the basis set. Therefore, the basis functions from fragments 3 and 4; are included as ghost functions within the energy computation. NUCLEAR REPULSION ENERGY¶; The nuclear repulsion energy contribution [E_h] to the total SCF energy.; Quantity \(E_{NN}\) in Eq. (4). (3)¶\[E_{NN} = \sum_{i, j<i}^{N_{atom}}\frac{Z_i Z_j}{|\mathbf{R}_i - \mathbf{R}_j|}\]. OCEPA(0) TOTAL ENERGY¶. OCEPA(0) CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the orbital-optimized CEPA(0) level of theory. OLCCD TOTAL ENERGY¶. OLCCD CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the orbital-optimized linearized coupled cluster doubles level of theory. OLCCD REFERENCE CORRECTION ENERGY¶; The difference [E_h] between the single-determinant energy of the final and; initial orbitals for the orbital-optimized linearized coupled cluster; doubles level of theory. OMP2 TOTAL ENERGY¶. OMP2 CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the orbital-optimized MP2 level of theory. OMP2 REFERENCE CORRECTION ENERGY¶; The difference [E_h] between the single-determinant energy of the final and; initial orbitals for the orbital-optimized MP2 level of theory. OMP2.5 TOTAL ENERGY¶. OMP2.5 CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the orbital-optimized MP2.5 level of theor",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html:41949,energy,energy,41949,psi4manual/1.7.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html,8,['energy'],['energy']
Energy Efficiency," calculation for the He dimer. This performs a simultaneous update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the AO Basis, using integrals stored on disk. dfccsdt1; DF-CCSD(T) cc-pVDZ energy for the H2O molecule. cc16; ROHF and UHF-B-CCD(T)/cc-pVDZ \(^{3}B_1\) CH2 single-point energy (fzc, MO-basis \(\langle ab|cd \rangle\) ). frac-sym; Fractional occupation with symmetry. scf-ecp2; Water-Argon complex with ECP present; check of RHF Hessian. cc8a; ROHF-CCSD(T) cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Cartesian input. scf2; RI-SCF cc-pVTZ energy of water, with Z-matrix input and cc-pVTZ-RI auxilliary basis. pywrap-checkrun-convcrit; Advanced python example sets different sets of scf/post-scf conv crit and check to be sure computation has actually converged to the expected accuracy. dfomp3-grad2; DF-OMP3 cc-pVDZ gradients for the H2O+ cation. mbis-6; MBIS calculation on H2O. omp2-3; OMP2 cc-pVDZ energy for the NO radical. castup1; Test of SAD/Cast-up (mainly not dying due to file weirdness). mp2p5-grad2; MP2.5 cc-pVDZ gradient for the NO radical. cbs-xtpl-gradient; Various gradients for a strained helium dimer and water molecule. psithon1; Spectroscopic constants of H2, and the full ci cc-pVTZ level of theory. cdoremp-energy1; Cholesky decomposed OO-REMP/cc-pVDZ energy for the H2O molecule. density-screen-1; RHF Density Matrix based-Integral Screening Test for water. numpy-array-interface; Numpy interface testing. mints1; Symmetry tests for a range of molecules. This doesn’t actually compute any energies, but serves as an example of the many ways to specify geometries in Psi4. dfomp2-grad2; OMP2 cc-pVDZ energy for the NO molecule. linK-3; UHF and ROHF Linear Exchange Algorithm test for benzyl cation. cc13d; Tests analytic CC2 gradients. cc49; EOM-CC3(UHF) on CH radical with user-specified basis and properties for particular root. cc13a; UHF-CCSD(T)/cc-pVDZ \(^{3}B_1\) CH2 geomet",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html:40811,energy,energy,40811,psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency," calculation on H2O. cc14; ROHF-CCSD/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. sapt-dft-lrc; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. dft-ghost; DFT Functional Test for Range-Seperated Hybrids and Ghost atoms. scf-hess1; RHF STO-3G (Cartesian) and cc-pVDZ (spherical) water Hessian test, against Psi3 reference values. cbs-delta-energy; Extrapolated energies with delta correction. frac-ip-fitting; Omega optimization for LRC functional wB97 on water. frac-sym; Fractional occupation with symmetry. cc23; ROHF-EOM-CCSD/DZ analytic gradient lowest \(^{2}B_1\) state of H2O+ (A1 excitation). cc32; CC3/cc-pVDZ H2O \(R_e\) geom from Olsen et al., JCP 104, 8007 (1996). cc25; Single point gradient of 1-2B2 state of H2O+ with EOM-CCSD. freq-isotope1; Vibrational and thermo analysis of several water isotopologs. Demonstrates Hessian reuse for different temperatures and pressures but not for different isotopologs. opt7; Various constrained energy minimizations of HOOH with cc-pvdz RHF. For “fixed” coordinates, the final value is provided by the user. sapt-ecp; sapt0 of charged system in ECP basis set. tdscf-4; td-wb97x singlet excitation energies of methylene (tda). soscf-dft; Triple and Singlet Oxygen energy SOSCF, also tests non-symmetric density matrices. cc34; RHF-CCSD/cc-pVDZ energy of H2O partitioned into pair energy contributions. opt5; 6-31G** UHF CH2 3B1 optimization. Uses a Z-Matrix with dummy atoms, just for demo and testing purposes. fci-tdm-2; BH-H2+ FCI/cc-pVDZ Transition Dipole Moment. cc4a; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. This version tests the FROZEN_DOCC option explicitly. cc8; UHF-CCSD(T) cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Z-matrix input. dfremp-1; density fitted REMP/cc-pVDZ energies for the CO2 molecule. fsapt-diff1; This test case shows an example of running and analyzing a difference F-SAPT0/jun-cc-pvdz procedure fo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html:33440,energy,energy,33440,psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency," calculation on ZnO. mbis-2; MBIS calculation on OH- (Expanded Arrays). nbody-he-cluster; MP2/aug-cc-pv[DT]Z many body energies of an arbitrary Helium complex Size vs cost tradeoff is rough here. pywrap-basis; SAPT calculation on bimolecular complex where monomers are unspecified so driver auto-fragments it. Basis set and auxiliary basis sets are assigned by atom type. mp2-property; MP2 cc-pvDZ properties for Nitrogen oxide. dft-freq-analytic; Analytic SVWN frequencies, compared to finite difference values. cc10; ROHF-CCSD cc-pVDZ energy for the \(^2\Sigma^+\) state of the CN radical. casscf-sp; CASSCF/6-31G** energy point. extern3; External potential calculation with one Ghost atom and one point charge at the same position. mints10; H2 with tiny basis set, to test basis set parser’s handling of integers. omp2-5; SOS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. pywrap-db3; Test that Python Molecule class processes geometry like psi4 Molecule class. tu2-ch2-energy; Sample UHF/6-31G** CH2 computation. dft-ghost; DFT Functional Test for Range-Seperated Hybrids and Ghost atoms. tu6-cp-ne2; Example potential energy surface scan and CP-correction for Ne2. dft-omega; Test omega is setable updated wb97x_20,wb97x_03 to account for new BraggSlater radii. fd-freq-gradient-large; SCF DZ finite difference frequencies by gradients for C4NH4. mints12; test roundtrip-ness of dict repr for psi4.core.Molecule and qcdb.Molecule. cc49; EOM-CC3(UHF) on CH radical with user-specified basis and properties for particular root. dct-grad1; Various DCT analytic gradients for the O2 molecule with 6-31G basis set. cbs-xtpl-dict; Extrapolated water energies. molden2; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then i",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html:7885,energy,energy,7885,psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency," calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). >>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). >>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). >>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy('fci', ref_wfn=cisd_wfn). >>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""CCSD/cc-pV[DT]Z""). >>> # [7] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> energy(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). """"""; kwargs = p4util.kwargs_lower(kwargs). # Bounce if name is function; if hasattr(name, '__call__'):; return name(energy, kwargs.pop('label', 'custom function'), ptype='energy', **kwargs). # Allow specification of methods to arbitrary order; lowername = name.lower(); lowername, level = driver_util.parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. # Bounce to CP if bsse kwarg; if kwargs.get('bsse_type', None) is not None:; return driver_nbody.nbody_gufunc(energy, name, ptype='energy', **kwargs). # Bounce to CBS if ""method/basis"" name; if ""/"" in lowername:; return driver_cbs._cbs_gufunc(energy, name, ptype='energy', **kw",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html:29433,energy,energy,29433,psi4manual/1.1.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html,2,['energy'],['energy']
Energy Efficiency," calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). >>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). >>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). >>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy('fci', ref_wfn=cisd_wfn). >>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""CCSD/cc-pV[DT]Z""). >>> # [7] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> energy(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). """"""; kwargs = p4util.kwargs_lower(kwargs). # Bounce to CP if bsse kwarg; if kwargs.get('bsse_type', None) is not None:; return driver_nbody.nbody_gufunc(energy, name, ptype='energy', **kwargs). # Bounce if name is function; if hasattr(name, '__call__'):; return name(energy, kwargs.pop('label', 'custom function'), ptype='energy', **kwargs). # Allow specification of methods to arbitrary order; lowername = name.lower(); lowername, level = driver_util.parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. # Bounce to CBS if ""method/basis"" name; if ""/"" in lowername:; return driver_cbs._cbs_gufunc(energy, name, ptype='energy', **kw",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html:32484,energy,energy,32484,psi4manual/1.3.2/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html,1,['energy'],['energy']
Energy Efficiency," calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). >>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). >>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). >>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy('fci', ref_wfn=cisd_wfn). >>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""CCSD/cc-pV[DT]Z""). >>> # [7] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> energy(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). """"""; kwargs = p4util.kwargs_lower(kwargs). # Bounce to MDI (MolSSI driver interface) if mdi kwarg; use_mdi = kwargs.pop('mdi', False); if use_mdi:; return mdi_run(name, **kwargs). core.print_out(""\nScratch directory: %s\n"" % core.IOManager.shared_object().get_default_path()). basisstash = p4util.OptionsState(['BASIS']); return_wfn = kwargs.pop('return_wfn', False). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). ## Pre-planning interventions. # * Trip on function or alias as name; lowername = driver_util.upgrade_interventions(name). _fil",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html:36260,energy,energy,36260,psi4manual/1.7.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html,4,['energy'],['energy']
Energy Efficiency," calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). >>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). >>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). >>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy('fci', ref_wfn=cisd_wfn). >>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""CCSD/cc-pV[DT]Z""). >>> # [7] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> energy(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). """"""; kwargs = p4util.kwargs_lower(kwargs). # Bounce to MDI if mdi kwarg; use_mdi = kwargs.pop('mdi', False); if use_mdi:; return mdi_run(name, **kwargs). core.print_out(""\nScratch directory: %s\n"" % core.IOManager.shared_object().get_default_path()). # Bounce to CP if bsse kwarg; if kwargs.get('bsse_type', None) is not None:; return driver_nbody.nbody_gufunc(energy, name, ptype='energy', **kwargs). # Bounce if name is function; if hasattr(name, '__call__'):; return name(energy, kwargs.pop('label', 'custom function'), ptype='energy', **kwargs). # Allow specification of methods to arbitrary order; lowername = name.lower(); lowername, level = ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:33542,energy,energy,33542,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,2,['energy'],['energy']
Energy Efficiency," calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). >>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). >>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). >>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy('fci', ref_wfn=cisd_wfn). >>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""CCSD/cc-pV[DT]Z""). >>> # [7] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> energy(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). """"""; kwargs = p4util.kwargs_lower(kwargs). # Bounce to MDI if mdi kwarg; use_mdi = kwargs.pop('mdi', False); if use_mdi:; return mdi_run(name, **kwargs). core.print_out(""\nScratch directory: %s\n"" % core.IOManager.shared_object().get_default_path()). basisstash = p4util.OptionsState(['BASIS']); return_wfn = kwargs.pop('return_wfn', False). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). ## Pre-planning interventions. # * Trip on function or alias as name; lowername = driver_util.upgrade_interventions(name). # * Allow specification of met",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html:29300,energy,energy,29300,psi4manual/1.6.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html,1,['energy'],['energy']
Energy Efficiency," call will first perform all of the procedures; described above to obtain the DC-06 energy. After that the DC-06 analytic; gradients code will be executed to perform the solution of the DCFT response; equations, compute the analytic gradients of the DCFT energy and perform the; geometry optimization. Recommendations¶; Here is the list of the recommendations for the DCFT module:. For the computations of small systems (less than 150 basis; functions and high symmetry) the use of the default parameters is recommended,; including the choice of the two-step algorithm.; For large systems (more than 150 basis functions) the simultaneous algorithm; is preferred and can be significantly faster than two-step, as the result of; smaller number of the expensive steps. In addition,; significant savings can be achieved if one sets AO_BASIS option to; DISK together with simultaneous algorithm.; In the case when insufficient memory is available, set AO_BASIS option; to DISK. This will significantly reduce the memory requirements. However, when; used together with the two-step algorithm, this option can significantly; increase the cost of the energy computation.; In the case when the oscillatory convergence is observed before the DIIS; extrapolation is initialized, it is recommended to increase the threshold for; the RMS of the density cumulant or orbital update residual, below which the; DIIS extrapolation starts. This can be done by setting; DIIS_START_CONVERGENCE option to the value greater than; by one or two orders of magnitude (e.g. or; ).; If the oscillatory convergence is observed for atoms or molecules with high; symmetry, it is recommended to use quadratically-convergent algorithm.; When using quadratically-convergent algorithm for closed-shell molecules, it; is recommended to set QC_COUPLING option to FALSE for efficiency; reasons. Table Of Contents. DCFT: Density Cumulant Functional Theory; Theory; Methods; Iterative Algorithms; Analytic Gradients; Minimal Input; Recommen",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/dcft-1.html:11721,reduce,reduce,11721,psi4manual/4.0b5/dcft-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/dcft-1.html,2,['reduce'],['reduce']
Energy Efficiency," can be placed using ZMatrix coordinates, whether they belong to the same fragment or not. Note that the Cartesian specification must come before the ZMatrix entries because the former define absolute positions, while the latter are relative. dfomp3-grad1; DF-OMP3 cc-pVDZ gradients for the H2O molecule. sapt2; SAPT0 aug-cc-pVDZ computation of the benzene-methane interaction energy, using the aug-pVDZ-JKFIT DF basis for SCF, the aug-cc-pVDZ-RI DF basis for SAPT0 induction and dispersion, and the aug-pVDZ-JKFIT DF basis for SAPT0 electrostatics and induction. This example uses frozen core as well as asyncronous I/O while forming the DF integrals and CPHF coefficients. nbo; Generation of NBO file. frac-traverse; Scan fractional occupation of electrons updated values due to new BraggSlater radii. sapt-dft-lrc; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. dfcasscf-sa-sp; Example of state-averaged CASSCF for the C2 molecule. soscf-dft; Triple and Singlet Oxygen energy SOSCF, also tests non-symmetric density matrices. sapt-compare; SAPT0 cc-pVDZ computation of the ethene-ethyne interaction energy, using the cc-pVDZ-JKFIT RI basis for SCF and cc-pVDZ-RI for SAPT. Monomer geometries are specified using Cartesian coordinates. dfomp3-2; DF-OMP3 cc-pVDZ energy for the H2O+ cation. cc7; Tests CCENERGY’s CCSD gradient in the presence of a dipole field. ghosts; Density fitted MP2 cc-PVDZ/cc-pVDZ-RI computation of formic acid dimer binding energy using explicit specification of ghost atoms. This is equivalent to the dfmp2_1 sample but uses both (equivalent) specifications of ghost atoms in a manual counterpoise correction. dfomp2-2; OMP2 cc-pVDZ energy for the NO molecule. olccd-freq1; OLCCD cc-pVDZ freqs for C2H2. opt5; 6-31G** UHF CH2 3B1 optimization. Uses a Z-Matrix with dummy atoms, just for demo and testing purposes. dft-custom-mgga; updated dldf reference to new BraggSlater radii Dispersionless density functional (dlDF+D) internal match to Psi4 Extensive",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html:22666,energy,energy,22666,psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency," can use commands set_options() and; set_module_options() like below. Note that these values; should be of correct type, strings for strings, floats for floats like; convergences. The function ~psi4.core.clean_options that reinitializes; all options may also be useful to separate calculations in a PsiAPI; session.; 1; 2; 3; 4; 5; 6; 7; 8; 9psi4.set_options({; 'scf_type': 'pk',; 'e_convergence': 1.e-5,; 'soscf': True; }). psi4.set_module_options({; 'geom_maxiter': 50; }). Basis Sets¶. Basis Sets; Built-In Basis Sets; Mixing Basis Sets; Decontracted Basis Sets; User-Defined Basis Sets; Inputting effective core potentials (ECPs). PSI Variables¶; To harness the power of Python, PSI4 makes the most pertinent results; of each computation available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of; H2 and H atom:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19molecule h2 {; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h {; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol * (2*h_energy - h2_energy); print ""De=%f"" % D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module, and PSI Variables by Alpha defines them. These can be; accessed through the get_variable() function. For example, after; performing a density fitted MP2 computation, both the spin component; scaled energy and the unscaled MP2 energy are made available:; 1; 2e_mp2 = get_variable('MP2 TOTAL ENERGY'); e_scs_mp2 = get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI vari",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:9653,energy,energy,9653,psi4manual/1.2.1/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html,4,['energy'],['energy']
Energy Efficiency," canonical. TD-fctl ROOT 0 -> ROOT n RIGHT EIGENVECTOR BETA¶; The right beta spin eigenvectors of the named method; from ground state to root n. DFT; functional labeled if canonical. TD-fctl ROOT 0 (IN h) -> ROOT n (IN i) RIGHT EIGENVECTOR BETA¶; The right beta spin eigenvectors of the named method; from ground state, which is in irrep h, to root n within irrep i. DFT; functional labeled if canonical. TD-fctl ROOT 0 (h) -> ROOT n (i) RIGHT EIGENVECTOR BETA¶; The right beta spin eigenvectors of the named method; from ground state, which is in irrep h, to root n, which is in irrep i. DFT; functional labeled if canonical. TD-fctl ROOT 0 -> ROOT n RIGHT EIGENVECTOR BETA - h TRANSITION¶; The right alpha and beta spin eigenvectors of the named method; from ground state to root n, and the transition is of irrep h. DFT; functional labeled if canonical. THERMAL ENERGY¶; Total thermal energy E [E_h] at given temperature. THERMAL ENERGY CORRECTION¶; Sum of electronic, translational, rotational, and vibrational corrections [E_h] to the thermal energy at given temperature. TWO-ELECTRON ENERGY¶; The two-electron energy contribution [E_h] to the total SCF energy.; Quantity \(E_{2e^-}\) in Eq. (4). UNCP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [E_h] considering only two-body interactions,; computed without counterpoise correction.; Related variable CP-CORRECTED 2-BODY INTERACTION ENERGY. \[E_{\text{IE}} = E_{dimer} - \sum_{monomer}^{n}{E_{monomer}^{\text{unCP}}}\]. WIBERG LOWDIN INDICES¶; Property of Wiberg bond indices using orthogonal Löwdin orbitals, (nat, nat). ZAPTn TOTAL ENERGY¶. ZAPTn CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the labeled Z-averaged perturbation theory level.; n is ZAPT perturbation order. ZERO K ENTHALPY¶; Total electronic and zero-point energy [E_h] at 0 [K]. ZPVE¶; Vibrational zero-point energy [E_h] at 0 [K]. 2-BODY PAIRWISE DISPERSION CORRECTION ANALYSIS¶; The interatomic contri",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html:63257,energy,energy,63257,psi4manual/1.7.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html,4,['energy'],['energy']
Energy Efficiency," capabilities of OCC/DFOCC modules¶. name; calls method; Energy; Gradient. scs-omp3; Spin-Component Scaled Orbital-Optimized MP3; RHF/UHF/ROHF/RKS/UKS; —. sos-omp3; Spin-Opposite Scaled Orbital-Optimized MP3; RHF/UHF/ROHF/RKS/UKS; —. scs(n)-omp3; A special version of SCS-OMP3 for nucleobase interactions; RHF/UHF/ROHF/RKS/UKS; —. scs-omp3-vdw; A special version of SCS-OMP3 (from ethene dimers); RHF/UHF/ROHF/RKS/UKS; —. sos-pi-omp3; A special version of SOS-OMP3 for \(\pi\)-systems; RHF/UHF/ROHF/RKS/UKS; —. scs-omp2; Spin-Component Scaled Orbital-Optimized MP2; RHF/UHF/ROHF/RKS/UKS; —. sos-omp2; Spin-Opposite Scaled Orbital-Optimized MP2; RHF/UHF/ROHF/RKS/UKS; —. scs(n)-omp2; A special version of SCS-OMP2 for nucleobase interactions; RHF/UHF/ROHF/RKS/UKS; —. scs-omp2-vdw; A special version of SCS-OMP2 (from ethene dimers); RHF/UHF/ROHF/RKS/UKS; —. sos-pi-omp2; A special version of SOS-OMP2 for \(\pi\)-systems; RHF/UHF/ROHF/RKS/UKS; —. Basic OCC Keywords¶. E_CONVERGENCE¶. Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. R_CONVERGENCE¶. Convergence criterion for amplitudes (residuals). Type: conv double; Default: 1e-5. RMS_MOGRAD_CONVERGENCE¶. Convergence criterion for RMS orbital gradient. Default adjusts depending on E_CONVERGENCE. Type: conv double; Default: 1e-6. MAX_MOGRAD_CONVERGENCE¶. Convergence criterion for maximum orbital gradient. Type: conv double; Default: 1e-3. MO_MAXITER¶. Maximum number of iterations to determine the orbitals. Type: integer; Default: 50. WFN_TYPE¶. Type of the wavefunction. Type: string; Possible Values: OMP2, OMP3, OCEPA, OMP2.5; Default: OMP2. ORB_OPT¶. Do optimize the orbitals?. Type: boolean; Default: true. Advanced OCC Keywords¶. OPT_METHOD¶. The optimization algorithm. Modified Steepest-Descent (MSD) takes a Newton-Raphson (NR) step with a crude approximation to diagonal elements of the MO Hessian. The ORB_RESP optio",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/occ-1.html:11707,energy,energy,11707,psi4manual/1.1.0/occ-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/occ-1.html,6,['energy'],['energy']
Energy Efficiency," capabilities of OCC/DFOCC modules¶. name; calls method; Energy; Gradient. scs-omp3; Spin-Component Scaled Orbital-Optimized MP3; RHF/UHF/ROHF/RKS/UKS; —. sos-omp3; Spin-Opposite Scaled Orbital-Optimized MP3; RHF/UHF/ROHF/RKS/UKS; —. scs(n)-omp3; A special version of SCS-OMP3 for nucleobase interactions; RHF/UHF/ROHF/RKS/UKS; —. scs-omp3-vdw; A special version of SCS-OMP3 (from ethene dimers); RHF/UHF/ROHF/RKS/UKS; —. sos-pi-omp3; A special version of SOS-OMP3 for \(\pi\)-systems; RHF/UHF/ROHF/RKS/UKS; —. scs-omp2; Spin-Component Scaled Orbital-Optimized MP2; RHF/UHF/ROHF/RKS/UKS; —. sos-omp2; Spin-Opposite Scaled Orbital-Optimized MP2; RHF/UHF/ROHF/RKS/UKS; —. scs(n)-omp2; A special version of SCS-OMP2 for nucleobase interactions; RHF/UHF/ROHF/RKS/UKS; —. scs-omp2-vdw; A special version of SCS-OMP2 (from ethene dimers); RHF/UHF/ROHF/RKS/UKS; —. sos-pi-omp2; A special version of SOS-OMP2 for \(\pi\)-systems; RHF/UHF/ROHF/RKS/UKS; —. Basic OCC Keywords¶. E_CONVERGENCE¶. Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. R_CONVERGENCE¶. Convergence criterion for amplitudes (residuals). Type: conv double; Default: 1e-5. RMS_MOGRAD_CONVERGENCE¶. Convergence criterion for RMS orbital gradient. If this keyword is not set by the user, OCC will estimate and use a value required to achieve the desired E_CONVERGENCE The listed default will be used for the default value of E_CONVERGENCE. Type: conv double; Default: 1e-4. MAX_MOGRAD_CONVERGENCE¶. Convergence criterion for maximum orbital gradient. If this keyword is not set by the user, OCC will estimate and use a value required to achieve the desired E_CONVERGENCE The listed default will be used for the default value of E_CONVERGENCE. Type: conv double; Default: 1e-4. MO_MAXITER¶. Maximum number of iterations to determine the orbitals. Type: integer; Default: 50. WFN_TYPE¶. Type of the wavefunction. Type: string; P",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/occ-1.html:11788,energy,energy,11788,psi4manual/1.4.0/occ-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/occ-1.html,9,['energy'],['energy']
Energy Efficiency," carried along. DOI: 10.1080/00268970802641242. SCS(N)-MP2 TOTAL ENERGY¶. SCS(N)-MP2 CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the MP2-like method formed by reweighting MP2 DOUBLES ENERGY; by 0 opposite-spin and 1.76 same-spin contributions, with; any singles carried along. doi: 10.1021/ct6002737. SCS(N)-OMP2 CORRELATION ENERGY¶. SCS(N)-OMP2 TOTAL ENERGY¶. SCSN-OMP2 CORRELATION ENERGY¶. SCSN-OMP2 TOTAL ENERGY¶; Two spellings of a discontinued QCVariable that may still appear; because the code is frozen pending an update. SCS-OMP2 TOTAL ENERGY¶. SCS-OMP2 CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the OMP2-like method formed by reweighting OMP2 DOUBLES ENERGY; by 6/5 opposite-spin and 1/3 same-spin contributions, with; any singles carried along. SCS-MP3 TOTAL ENERGY¶. SCS-MP3 CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the MP3-like method formed by reweighting the difference between; MP3 DOUBLES ENERGY and MP2 DOUBLES ENERGY; by 0.25, atop the SCS-MP2 energy, with any singles carried along. SCS-OMP3 TOTAL ENERGY¶. SCS-OMP3 CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the OMP3-like method formed by reweighting the difference between; OMP3 DOUBLES ENERGY and OMP2 DOUBLES ENERGY; by 0.25, atop the SCS-OMP2 energy, with any singles carried along. SOS-MP2 TOTAL ENERGY¶. SOS-MP2 CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the MP2-like method formed by reweighting MP2 DOUBLES ENERGY; by 1.3 opposite-spin and 0 same-spin contributions, with; any singles carried along. SOS-OMP2 TOTAL ENERGY¶. SOS-OMP2 CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the OMP2-like method formed by reweighting OMP2 DOUBLES ENERGY; by 1.2 opposite-spin and 0 same-spin contrib",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html:56030,energy,energy,56030,psi4manual/1.7.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html,8,['energy'],['energy']
Energy Efficiency," case of RHF/UHF the usual canonical HF orbitals and in the case of ROHF calculations the standard ROHF-orbitals with equal spatial parts for both the \(\alpha\) and the \(\beta\) spin orbitals. SEMICANONICAL (=1) forces in ROHF type calculations a transformation to so-called semicanonical orbitals which diagonalize the occupied-occupied and virtual-virtual blocks of the usual Fock-matrices. The use of semicanonical orbitals is, for example, required for ROHF-CCSD(T) calculations and for those calculations also automatically set. LOCAL requests a localization of the HF orbitals and this is currently done according to the Pipek-Mezey localization criterion. Note that it is strongly recommended not to use this keyword unless you know what are you doing. Default: STANDARD except for ROHF-CCSD(T) and ROHF-MP4 calculations for which SEMICANONICAL is the default. Type: string; Possible Values: STANDARD, SEMICANONICAL; Default: STANDARD. CFOUR_PERT_ORB (CFOUR); CFOUR — Specifies the type of perturbed orbitals used in energy derivative calculations. STANDARD means that the gradient formulation assumes that the perturbed orbitals are not those in which the (perturbed) Fock matrix is diagonal. CANONICAL means that the perturbed orbitals are assumed to be canonical. This keyword is set automatically to CANONICAL in derivative calculations with methods which include triple excitations (MBPT[4]/MP4, CCSD+T[CCSD], CCSD[T], QCISD[T] and all iterative schemes like CCSDT-n and CC3) apart from CCSDT. IJ_CANONICAL requests a canonical perturbed-orbital treatment only for the occupied-occupied block of the unperturbed density matrix in analytic derivative calculations. For testing purposes, it is possible to force the use standard perturbed orbitals even in case of iterative triple excitations via the option FORCE_STANDA (dne?). Note also that in case of unrelaxed derivatives standard orbitals must be used. Default : STANDARD for all methods without triples (except CCSDT), CANONICAL for",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html:63601,energy,energy,63601,psi4manual/1.2.1/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html,6,['energy'],['energy']
Energy Efficiency," case of RHF/UHF the usual canonical HF orbitals and in the case of ROHF calculations the standard ROHF-orbitals with equal spatial parts for both the \(\alpha\) and the \(\beta\) spin orbitals. SEMICANONICAL (=1) forces in ROHF type calculations a transformation to so-called semicanonical orbitals which diagonalize the occupied-occupied and virtual-virtual blocks of the usual Fock-matrices. The use of semicanonical orbitals is, for example, required for ROHF-CCSD(T) calculations and for those calculations also automatically set. LOCAL requests a localization of the HF orbitals and this is currently done according to the Pipek-Mezey localization criterion. Note that it is strongly recommended not to use this keyword unless you know what are you doing. Default: STANDARD except for ROHF-CCSD(T) and ROHF-MP4 calculations for which SEMICANONICAL is the default. Type: string; Possible Values: STANDARD, SEMICANONICAL; Default: STANDARD. CFOUR_PERT_ORB (CFOUR)¶CFOUR — Specifies the type of perturbed orbitals used in energy derivative calculations. STANDARD means that the gradient formulation assumes that the perturbed orbitals are not those in which the (perturbed) Fock matrix is diagonal. CANONICAL means that the perturbed orbitals are assumed to be canonical. This keyword is set automatically to CANONICAL in derivative calculations with methods which include triple excitations (MBPT[4]/MP4, CCSD+T[CCSD], CCSD[T], QCISD[T] and all iterative schemes like CCSDT-n and CC3) apart from CCSDT. IJ_CANONICAL requests a canonical perturbed-orbital treatment only for the occupied-occupied block of the unperturbed density matrix in analytic derivative calculations. For testing purposes, it is possible to force the use standard perturbed orbitals even in case of iterative triple excitations via the option FORCE_STANDA (dne?). Note also that in case of unrelaxed derivatives standard orbitals must be used. Default : STANDARD for all methods without triples (except CCSDT), CANONICAL for",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:63896,energy,energy,63896,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,9,['energy'],['energy']
Energy Efficiency," case sensitive. Type: string; Default: No Default. Expert¶. CUBIC_BASIS_TOLERANCE¶. CubicScalarGrid basis cutoff. Type: conv double; Default: 1.0e-12. CUBIC_BLOCK_MAX_POINTS¶. CubicScalarGrid maximum number of grid points per evaluation block. Type: integer; Default: 1000. DEBUG¶. The amount of information to print to the output file. Type: integer; Default: 0. DERTYPE¶. Derivative level. Type: string; Possible Values: NONE, FIRST, SECOND, RESPONSE; Default: NONE. DIE_IF_NOT_CONVERGED¶. Psi4 dies if energy does not converge. Type: boolean; Default: true. DKH_ORDER¶. Order of Douglas-Kroll-Hess. Type: integer; Default: 2. EXTERNAL_POTENTIAL_SYMMETRY¶. Assume external fields are arranged so that they have symmetry. It is up to the user to know what to do here. The code does NOT help you out in any way!. Type: boolean; Default: false. MAT_NUM_COLUMN_PRINT¶. Number of columns to print in calls to Matrix::print_mat. Type: integer; Default: 5. PCM_SCF_TYPE¶. Use total or separate potentials and charges in the PCM-SCF step. Type: string; Possible Values: TOTAL, SEPARATE; Default: TOTAL. RAS1¶. An array giving the number of orbitals per irrep for RAS1. Type: array; Default: No Default. RAS2¶. An array giving the number of orbitals per irrep for RAS2. Type: array; Default: No Default. RAS3¶. An array giving the number of orbitals per irrep for RAS3. Type: array; Default: No Default. RAS4¶. An array giving the number of orbitals per irrep for RAS4. Type: array; Default: No Default. RELATIVISTIC¶. Relativistic Hamiltonian type. Type: string; Possible Values: NO, X2C; Default: NO. WFN¶. Wavefunction type. Type: string; Default: SCF. Table Of Contents. GLOBALS; General; ACTIVE; BENCH; CC_TYPE; CI_TYPE; CUBEPROP_BASIS_FUNCTIONS; CUBEPROP_FILEPATH; CUBEPROP_ORBITALS; CUBEPROP_TASKS; CUBIC_GRID_OVERAGE; CUBIC_GRID_SPACING; DF_BASIS_CC; DOCC; FREEZE_CORE; FROZEN_DOCC; FROZEN_UOCC; INTEGRAL_PACKAGE; LITERAL_CFOUR; MP2_TYPE; MP_TYPE; NUM_FROZEN_DOCC; NUM_FROZEN_UOCC; PCM; PRINT; PROP",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__globals-1.html:7229,charge,charges,7229,psi4manual/1.0.0/autodir_options_c/module__globals-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__globals-1.html,2,['charge'],['charges']
Energy Efficiency," case sensitive. Type: string; Default: No Default. Expert¶. CUBIC_BASIS_TOLERANCE¶. CubicScalarGrid basis cutoff. Type: conv double; Default: 1.0e-12. CUBIC_BLOCK_MAX_POINTS¶. CubicScalarGrid maximum number of grid points per evaluation block. Type: integer; Default: 1000. DEBUG¶. The amount of information to print to the output file. Type: integer; Default: 0. DERTYPE¶. Derivative level. Type: string; Possible Values: NONE, FIRST, SECOND, RESPONSE; Default: NONE. DIE_IF_NOT_CONVERGED¶. Psi4 dies if energy does not converge. Type: boolean; Default: true. DKH_ORDER¶. Order of Douglas-Kroll-Hess. Type: integer; Default: 2. EXTERNAL_POTENTIAL_SYMMETRY¶. Assume external fields are arranged so that they have symmetry. It is up to the user to know what to do here. The code does NOT help you out in any way!. Type: boolean; Default: false. MAT_NUM_COLUMN_PRINT¶. Number of columns to print in calls to Matrix::print_mat. Type: integer; Default: 5. PCM_SCF_TYPE¶. Use total or separate potentials and charges in the PCM-SCF step. Type: string; Possible Values: TOTAL, SEPARATE; Default: TOTAL. RAS1¶. An array giving the number of orbitals per irrep for RAS1. Type: array; Default: No Default. RAS2¶. An array giving the number of orbitals per irrep for RAS2. Type: array; Default: No Default. RAS3¶. An array giving the number of orbitals per irrep for RAS3. Type: array; Default: No Default. RAS4¶. An array giving the number of orbitals per irrep for RAS4. Type: array; Default: No Default. RELATIVISTIC¶. Relativistic Hamiltonian type. Type: string; Possible Values: NO, X2C; Default: NO. WFN¶. Wavefunction type. Type: string; Default: SCF. table of contents. GLOBALS; General; ACTIVE; BASIS_RELATIVISTIC; BENCH; CC_TYPE; CI_TYPE; CUBEPROP_BASIS_FUNCTIONS; CUBEPROP_FILEPATH; CUBEPROP_ORBITALS; CUBEPROP_TASKS; CUBIC_GRID_OVERAGE; CUBIC_GRID_SPACING; DF_BASIS_CC; DOCC; FREEZE_CORE; FROZEN_DOCC; FROZEN_UOCC; INTEGRAL_PACKAGE; LITERAL_CFOUR; MOLDEN_WITH_VIRTUAL; MP2_TYPE; MP_TYPE; NUM_FROZE",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/module__globals-1.html:7504,charge,charges,7504,psi4manual/1.1.0/autodir_options_c/module__globals-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/module__globals-1.html,2,['charge'],['charges']
Energy Efficiency," cation, using all of the different integral algorithms. This tests both the ERI and ERF integrals. mbis-5; MBIS calculation on ZnO. cc2; 6-31G** H2O CCSD optimization by energies, with Z-Matrix input. fd-gradient; SCF STO-3G finite-difference tests. opt15; 6-31G(d) optimization of SF4 starting from linear bond angle that is not linear in the optimized structure but is in a symmetry plane of the molecule. nbody-vmfc-gradient; Computation of VMFC-corrected water trimer gradient (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). mp2-property; MP2 cc-pvDZ properties for Nitrogen oxide. x2c3; Test of SFX2C-1e on Water uncontracted cc-pVDZ The reference numbers are from Lan Cheng’s implementation in Cfour. scf3; File retention, docc, socc, and bond distances specified explicitly. dfomp2-grad1; DF-OMP2 cc-pVDZ gradients for the H2O molecule. fci-tdm; He2+ FCI/cc-pVDZ Transition Dipole Moment. options1; check all variety of options parsing. cbs-xtpl-energy-conv; Extrapolated water energies - conventional integrals version. rasci-c2-active; 6-31G* C2 Test RASCI Energy Point, testing two different ways of specifying the active space, either with the ACTIVE keyword, or with RAS1, RAS2, RESTRICTED_DOCC, and RESTRICTED_UOCC. isapt-charged; This test case shows an example of running the I-SAPT0/aug-cc-pVDZ computation for a positively charged system, illustrating the cation-pi interaction. The SIAO1 link partitioning algorithm is used. The system is taken from http://dx.doi.org/10.1016/j.comptc.2014.02.008. fnocc7; Test fnocc with linear dependencies. fnocc6; Test method/basis with disk_df. tdscf-2; td-uhf test on triplet states of methylene (tda), wfn passing. cc26; Single-point gradient, analytic and via finite-differences of 2-1A1 state of H2O with EOM-CCSD. cc55; EOM-CCSD/6-31g excited state transition data for water with two excited states per irrep. dfmp2-1; Density fitted MP2 cc-PVDZ/cc-pVDZ-RI computation of formic acid dimer binding energy using automatic cou",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html:38604,energy,energy-conv,38604,psi4manual/master/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html,2,['energy'],['energy-conv']
Energy Efficiency," cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Z-matrix input. mcscf3; RHF 6-31G** energy of water, using the MCSCF module and Z-matrix input. mints2; A test of the basis specification. A benzene atom is defined using a ZMatrix containing dummy atoms and various basis sets are assigned to different atoms. The symmetry of the molecule is automatically lowered to account for the different basis sets. dcft8; DCFT calculation for the NH3+ radical using the ODC-12 and ODC-13 functionals. This performs both simultaneous and QC update of the orbitals and cumulant using DIIS extrapolation. Four-virtual integrals are first handled in the MO Basis for the first two energy computations. In the next computation ao_basis=disk algorithm is used, where the transformation of integrals for four-virtual case is avoided. cc12; Single point energies of multiple excited states with EOM-CCSD. dft2; DFT Functional Test. cc8b; ROHF-CCSD cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Cartesian input. pywrap-molecule; Check that C++ Molecule class and qcdb molecule class are reading molecule input strings identically. opt1-fd; SCF STO-3G geometry optimzation, with Z-matrix input, by finite-differences. x2c2; Test of SFX2C-1e on Water cc-pVDZ-DK. In this test the Dirac equation is solved in the uncontracted cc-pVDZ-DK basis. The reference numbers are from Lan Cheng’s implementation in Cfour. cbs-xtpl-func; optimization with method defined via cbs. cubeprop; RHF orbitals and density for water. omp3-1; OMP3 cc-pVDZ energy for the H2O molecule. fd-gradient; SCF STO-3G finite-difference tests. mints5; Tests to determine full point group symmetry. Currently, these only matter for the rotational symmetry number in thermodynamic computations. sapt6; checks that all SAPT physical components (elst, exch, indc, disp) and total IE are being computed correctly for SAPT2+3(CCD)dMP2/aug-cc-pvdz and all lesser methods thereof. cc4a; RHF-CCSD(",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/testsuite-1.html:28618,energy,energy,28618,psi4manual/1.1.0/testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/testsuite-1.html,12,['energy'],['energy']
Energy Efficiency," cc-pVDZ gradient for the NO radical. scf6; Tests RHF/ROHF/UHF SCF gradients. cc4; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. After the computation, the checkpoint file is renamed, using the PSIO handler. pywrap-opt-sowreap; Finite difference optimization, run in sow/reap mode. cc47; EOM-CCSD/cc-pVDZ on H2O2 with two excited states in each irrep. dcft-grad2; RHF-ODC-12 analytic gradient computations for H2O use AO_BASIS=DISK and AO_BASIS=NONE, respectively. RHF-ODC-06 analytic gradient computations for H2O use AO_BASIS=DISK and AO_BASIS=NONE, respectively. fsapt2; A very quick correctness test of F-SAPT (see fsapt1 for a real example). cepa3; cc-pvdz H2O Test coupled-pair CISD against DETCI CISD. cc32; CC3/cc-pVDZ H2O \(R_e\) geom from Olsen et al., JCP 104, 8007 (1996). scf-hess1; RHF STO-3G (Cartesian) and cc-pVDZ (spherical) water Hessian test, against Psi3 reference values. ocepa-freq1; OCEPA cc-pVDZ freqs for C2H2. dfccsdt1; DF-CCSD(T) cc-pVDZ energy for the H2O molecule. pywrap-db2; Database calculation, run in sow/reap mode. sad1; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. dft-psivar; HF and DFT variants single-points on zmat methane, mostly to test that PSI variables are set and computed correctly. Now also testing that CSX harvesting PSI variables correctly. ocepa2; OCEPA cc-pVDZ energy with B3LYP initial guess for the NO radical. dcft5; DC-06 calculation for the O2 molecule (triplet ground state). This performs geometry optimization using two-step and simultaneous solution of the response equations for the analytic gradient. opt-irc-1; Compute the IRC for HOOH torsional rotation at the RHF/DZP level of theory. dcft2; DC-06 calculation for ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/testsuite-1.html:9454,energy,energy,9454,psi4manual/1.1.0/testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/testsuite-1.html,4,['energy'],['energy']
Energy Efficiency," cc-pVDZ gradients for the H2O molecule. cc8; UHF-CCSD(T) cc-pVDZ frozen-core energy for the state of the CN radical, with Z-matrix input. cc17; Single point energies of multiple excited states with EOM-CCSD. dfmp2-grad4; DF-MP2 cc-pVDZ gradient for the NO molecule. cc15; RHF-B-CCD(T)/6-31G** H2O single-point energy (fzc, MO-basis ). fci-dipole; 6-31G H2O Test FCI Energy Point. pywrap-basis; SAPT calculation on bimolecular complex where monomers are unspecified so driver auto-fragments it. Basis set and auxiliary basis sets are assigned by atom type. fd-freq-energy-large; SCF DZ finite difference frequencies by energies for C4NH4. matrix1; An example of using BLAS and LAPACK calls directly from the Psi input file, demonstrating matrix multiplication, eigendecomposition, Cholesky decomposition and LU decomposition. These operations are performed on vectors and matrices provided from the Psi library. cc25; Single point gradient of 1-2B2 state of H2O+ with EOM-CCSD. dfcasscf-fzc-sp; CASSCF/6-31G** energy point. fd-freq-energy; SCF STO-3G finite-difference frequencies from energies. cc29; CCSD/cc-pVDZ optical rotation calculation (both gauges) on Cartesian H2O2. dfmp2-grad3; DF-MP2 cc-pVDZ gradients for the H2O molecule. opt12; SCF cc-pVDZ geometry optimzation of ketene, starting from bent structure. psimrcc-ccsd_t-2; Mk-MRCCSD(T) single point. CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. cc8c; ROHF-CCSD cc-pVDZ frozen-core energy for the state of the CN radical, with Cartesian input. gdma1; Water RHF/cc-pVTZ distributed multipole analysis. cc47; EOM-CCSD/cc-pVDZ on H2O2 with two excited states in each irrep. props2; DF-SCF cc-pVDZ of benzene-hydronium ion, scanning the dissociation coordinate with Python’s built-in loop mechanism. The geometry is specified by a Z-matrix with dummy atoms, fixed parameters, updated parameters, and separate charge/multiplicity specifiers for each monomer. One-electron properties computed for di",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html:21297,energy,energy,21297,psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency," cc-pVDZ gradients for the H2O molecule. cc8b; ROHF-CCSD cc-pVDZ frozen-core energy for the state of the CN radical, with Cartesian input. cbs-xtpl-energy; Extrapolated water energies. mp2p5-grad2; MP2.5 cc-pVDZ gradient for the NO radical. props3; DF-SCF cc-pVDZ multipole moments of benzene, up to 7th order and electrostatic potentials evaluated at the nuclear coordinates. omp2p5-2; OMP2 cc-pVDZ energy for the H2O molecule. opt14; 6-31G(d) optimization of SF4 starting from linear bond angle that is not linear in the optimized structure but is in a symmetry plane of the molecule. scf-bz2; Benzene Dimer Out-of-Core HF/cc-pVDZ. frac; Carbon/UHF Fractionally-Occupied SCF Test Case. ocepa2; OCEPA cc-pVDZ energy with B3LYP initial guess for the NO radical. soscf1; Second-order SCF convergnece: Benzene. omp2-4; SCS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. cc13; UHF-CCSD/cc-pVDZ CH2 geometry optimization via analytic gradients. cc8a; ROHF-CCSD(T) cc-pVDZ frozen-core energy for the state of the CN radical, with Cartesian input. molden1; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. mom; Maximum Overlap Method (MOM) Test. MOM is designed to stabilize SCF convergence and to target excited Slater determinants directly. pywrap-freq-e-sowreap; Finite difference of energies frequency, run in sow/reap mode. cubeprop; RHF orbitals and density for water. fd-freq-gradient; STO-3G frequencies for H2O by finite-differences of gradients. cc45; RHF-EOM-CC2/cc-pVDZ lowest two states of each symmetry of H2O. dcft1; DC-06, DC-12, ODC-06 and ODC-12 calculation for the He dimer. This performs a simultaneous update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handl",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html:16127,energy,energy,16127,psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency," cc-pVDZ gradients for the H2O molecule. mints9; A test of the basis specification. Various basis sets are specified outright and in blocks, both orbital and auxiliary. Constructs libmints BasisSet objects through the constructor that calls qcdb.BasisSet infrastructure. Checks that the resulting bases are of the right size and checks that symmetry of the Molecule observes the basis assignment to atoms. cc31; CCSD/sto-3g optical rotation calculation (both gauges) at two frequencies on methyloxirane. cisd-sp-2; 6-31G** H2O Test CISD Energy Point. opt1; SCF STO-3G geometry optimzation, with Z-matrix input. adc1; ADC/6-31G** on H2O. mp2-grad2; MP2 cc-pVDZ gradient for the NO radical. dfccsd-grad1; DF-CCSD cc-pVDZ gradients for the H2O molecule. dft3; DFT integral algorithms test, performing w-B97 RKS and UKS computations on water and its cation, using all of the different integral algorithms. This tests both the ERI and ERF integrals. cc8; UHF-CCSD(T) cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Z-matrix input. mp3-grad2; MP3 cc-pVDZ gradient for the NO radical. scf6; Tests RHF/ROHF/UHF SCF gradients. cc4; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. After the computation, the checkpoint file is renamed, using the PSIO handler. pywrap-opt-sowreap; Finite difference optimization, run in sow/reap mode. cc47; EOM-CCSD/cc-pVDZ on H2O2 with two excited states in each irrep. dcft-grad2; RHF-ODC-12 analytic gradient computations for H2O use AO_BASIS=DISK and AO_BASIS=NONE, respectively. RHF-ODC-06 analytic gradient computations for H2O use AO_BASIS=DISK and AO_BASIS=NONE, respectively. fsapt2; A very quick correctness test of F-SAPT (see fsapt1 for a real example). cepa3; cc-pvdz H2O Test coupled-pair CISD against DETCI CISD. cc32; CC3/cc-pVDZ H2O \(R_e\) geom from Olsen et al., JCP 104, 8007 (1996). scf-hess1; RHF STO-3G (Cartesian) and cc-pVDZ (spherical) water Hessian test, against Psi3 reference values. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/testsuite-1.html:8363,energy,energy,8363,psi4manual/1.1.0/testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/testsuite-1.html,4,['energy'],['energy']
Energy Efficiency," cc-pVDZ-DK. In this test the Dirac equation is solved in the uncontracted cc-pVDZ-DK basis. The reference numbers are from Lan Cheng’s implementation in Cfour. dft-grac; Gradient regularized asymptotic correction (GRAC) test. scf1; RHF cc-pVQZ energy for the BH molecule, with Cartesian input. dct2; DC-06 calculation for the He dimer. This performs a two-step update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the MO Basis. dft-custom-hybrid; DFT (hybrids) test of implementations in: hybrid_superfuncs.py. scf-hess4; DF SCF 6-31G UHFl vs RHF test Tests DF UHF hessian code for Ca = Cb. scf-auto-cholesky; Cholesky filter a complete basis. mom; Maximum Overlap Method (MOM) Test. MOM is designed to stabilize SCF convergence and to target excited Slater determinants directly. psithon1; Spectroscopic constants of H2, and the full ci cc-pVTZ level of theory. cisd-h2o+-2; 6-31G** H2O+ Test CISD Energy Point. cc10; ROHF-CCSD cc-pVDZ energy for the \(^2\Sigma^+\) state of the CN radical. tdscf-2; td-uhf test on triplet states of methylene (tda), wfn passing. dft-pruning; Tests all grid pruning options available and screening of small weights. Check against grid size. dfccd1; DF-CCD cc-pVDZ energy for the H2O molecule. cc15; RHF-B-CCD(T)/6-31G** H2O single-point energy (fzc, MO-basis \(\langle ab|cd \rangle\)). omp2p5-grad2; OMP2.5 cc-pVDZ gradient for the NO radical. sapt5; SAPT0 aug-cc-pVTZ computation of the charge transfer energy of the water dimer. dfccsdt1; DF-CCSD(T) cc-pVDZ energy for the H2O molecule. pywrap-checkrun-uhf; This checks that all energy methods can run with a minimal input and set symmetry. scf2; RI-SCF cc-pVTZ energy of water, with Z-matrix input and cc-pVTZ-RI auxilliary basis. mcscf3; RHF 6-31G** energy of water, using the MCSCF module and Z-matrix input. pywrap-checkrun-rohf; This checks that all energy methods can run with a minimal input and set symmetry. cc41; RHF-CC2-LR/cc-pVDZ optical rotation of H2O",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html:4621,energy,energy,4621,psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency," cc31; CCSD/sto-3g optical rotation calculation (both gauges) at two frequencies on methyloxirane. psimrcc-ccsd_t-1; Mk-MRCCSD(T) single point. CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. cc11; Frozen-core CCSD(ROHF)/cc-pVDZ on CN radical with disk-based AO algorithm. fd-freq-energy-large; SCF DZ finite difference frequencies by energies for C4NH4. cc33; CC3(UHF)/cc-pVDZ H2O geom from Olsen et al., JCP 104, 8007 (1996). tu6-cp-ne2; Example potential energy surface scan and CP-correction for Ne2. pywrap_all; Intercalls among python wrappers- database, cbs, optimize, energy, etc. Though each call below functions individually, running them all in sequence or mixing up the sequence is aspirational at present. Also aspirational is using the intended types of gradients. cc30; CCSD/sto-3g optical rotation calculation (length gauge only) at two frequencies on methyloxirane. sapt3; SAPT2+3 aug-cc-pVDZ computation of the water dimer interaction energy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. scf5; Test of all different algorithms and reference types for SCF, on singlet and triplet O2, using the cc-pVTZ basis set. cc8a; ROHF-CCSD(T) cc-pVDZ frozen-core energy for the state of the CN radical, with Cartesian input. opt1-fd; SCF STO-3G geometry optimzation, with Z-matrix input, by finite-differences. castup1; Test of SAD/Cast-up (mainly not dying due to file weirdness). adc1; ADC/6-31G** on H2O. cc9; UHF-CCSD(T) cc-pVDZ frozen-core energy for the state of the CN radical, with Z-matrix input. pubchem1; Benzene vertical singlet-triplet energy difference computation, using the PubChem database to obtain the initial geometry, at the UHF an ROHF levels of theory. cc44; Test case for some of the PSI4 out-of-core codes. The code is given only 2.0 MB of memory, which is insufficient to hold either the A1 or B2 blocks of an ovvv quantity in-core, but is sufficient to hold at least two copies of an oovv quantit",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodoc_testsuite-1.html:13064,energy,energy,13064,psi4manual/4.0b2/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodoc_testsuite-1.html,4,['energy'],['energy']
Energy Efficiency," cc3; cc3: RHF-CCSD/6-31G** H2O geometry optimization and vibrational frequency analysis by finite-differences of gradients. fsapt-ext-abc-au; analog of fsapt-ext-abc with molecule and external potentials in Bohr. sapt-exch-ind30-inf; SAPT2+3 with S^inf exch-ind30 Geometries taken from the S66x10 database, the shortest-range point (R = 0.7 R_e). dlpnomp2-2; comparison of DF-MP2 and DLPNO-MP2 with a CBS extrapolation. stability3; Test LDA stability analysis against QChem. dfmp2-grad3; DF-MP2 cc-pVDZ gradients for the H2O molecule. options1; check all variety of options parsing. scf4; RHF cc-pVDZ energy for water, automatically scanning the symmetric stretch and bending coordinates using Python’s built-in loop mechanisms. The geometry is specified using a Z-matrix with variables that are updated during the potential energy surface scan, and then the same procedure is performed using polar coordinates, converted to Cartesian coordinates. pywrap-checkrun-rohf; This checks that all energy methods can run with a minimal input and set symmetry. cbs-xtpl-opt; Various extrapolated optimization methods for the H2 molecule. dfomp2-1; OMP2 cc-pVDZ energy for the H2O molecule. dfccsd1; DF-CCSD cc-pVDZ energy for the H2O molecule. omp2p5-1; OMP2.5 cc-pVDZ energy for the H2O molecule. cc-module; check that CC is returning the same values btwn CC*, FNOCC, and DFOCC modules. opt-full-hess-every; SCF/sto-3g optimization with a hessian every step. cbs-xtpl-freq; Various gradients for a strained helium dimer and water molecule. dft-grac; Gradient regularized asymptotic correction (GRAC) test. cc13b; Tests RHF CCSD(T)gradients. sapt-sf1; Tests the Psi4 SF-SAPT code. tdscf-2; td-uhf test on triplet states of methylene (tda), wfn passing. x2c3; Test of SFX2C-1e on Water uncontracted cc-pVDZ The reference numbers are from Lan Cheng’s implementation in Cfour. ci-multi; BH single points, checking that program can run multiple instances of DETCI in a single input, without an intervening clean(",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html:42044,energy,energy,42044,psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency," cfour/sp-rhf-ccsdt; single-point CCSDT/qz2p on water. cfour/puream; Basis set spherical/Cartesian behavior in cfour. cfour/sp-rohf-mp2-sc; single-point MP2/qz2p on NH2. cfour/opt-rhf-mp2; optimization MP2/cc-pvtz on water. cfour/psi-rhf-scsmp2; MP2 energy components. Checks that computed identically between cfour and psi4. cfour/sp-uhf-mp2; single-point MP2/qz2p on NH2. cfour/sp-uhf-ccsdt; single-point CCSDT/qz2p on NH2. cfour/kw-5; Basis set spherical/Cartesian with basis and cfour_spherical. cfour/sp-uhf-ccsd_t_; single-point CCSD(T)/qz2p. cfour/sp-rhf-mp2; single-point MP2/qz2p on water. cfour/sp-uhf-ccsd; single-point CCSD/qz2p on NH2. cfour/psi-a24-grad; geometry after three optimization cycles on A24 database, cfour matches psi4. cfour/psi-uhf-scsmp2; UHF MP2 energy components. Checks that computed identically between cfour and psi4. cfour/mp2-1; All-electron MP2 6-31G** geometry optimization of water. cfour/kw-7; Translating psi4 options to cfour, part i. cfour/psi-uhf-mp3; UHF MP3 energy components. Checks that converted identically between cfour and psi4. cfour/kw-2; testing best practices options, part ii. cfour/sp-rhf-scf; single-point HF/qz2p on water. cfour/opt-rhf-scf; optimization HF/svp on water. cfour/opt-rhf-ccsd_t_-ecc; optimization CCSD(T)/dzp on water with ecc, aobasis. cfour/sp-rhf-ccsd; single point CCSD/qz2p on water. cfour/sp-rohf-ccsd_t_; single-point CCSD(T)/qz2p on NH2. cfour/kw-3; Basis set spherical/Cartesian with cfour_basis and cfour_spherical. cfour/psi-rhf-mp3; MP3 energy components. Checks that computed identically between cfour and psi4. cfour/kw-1; testing best practices options, part i. cfour/kw-6; Basis set spherical/Cartesian with cfour_basis and puream. cfour/psi-rohf-scsmp2; ROHF MP2 energy components. Checks that computed identically between cfour and psi4. cfour/sp-uhf-ccsd_t_-ao-ecc; single-point CCSD(T)/qz2p on NH2 with ecc, aobasis. cfour/sp-uhf-cc3; single-point CC3/qz2p on NH2. cfour/sp-rohf-ccsd_t_-ao; single-point ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_cfour-1.html:3129,energy,energy,3129,psi4manual/1.5.0/autodoc_testsuite_cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_cfour-1.html,2,['energy'],['energy']
Energy Efficiency," charge += 1; mult = Na - Nb + 1. core.set_local_option(""SCF"", ""DF_INTS_IO"", ""LOAD""); core.set_local_option(""SCF"", ""FRAC_START"", frac_start); core.set_local_option(""SCF"", ""FRAC_RENORMALIZE"", True). # Nuke 'em Rico!; for Nintegral in range(N, Nmin, -1):. # Nuke the current HOMO; for occ in foccs:. core.set_local_option(""SCF"", ""FRAC_OCC"", [HOMO]); core.set_local_option(""SCF"", ""FRAC_VAL"", [occ]). E, wfn = driver.energy('scf', dft_functional=name, return_wfn=True, molecule=molecule, **kwargs); C = 1; if E == 0.0:; E = core.variable('SCF ITERATION ENERGY'); C = 0. if HOMO > 0:; eps = wfn.epsilon_a(); potentials.append(eps.np[HOMO - 1]); else:; eps = wfn.epsilon_b(); potentials.append(eps.np[-HOMO - 1]). Ns.append(Nintegral + occ - 1.0); energies.append(E); convs.append(C). core.set_local_option(""SCF"", ""FRAC_START"", 2); # NYI core.set_local_option(""SCF"", ""FRAC_LOAD"", True); core.set_local_option(""SCF"", ""FRAC_DIIS"", frac_diis); core.set_local_option(""SCF"", ""GUESS"", ""READ""). # Set the next charge/mult; molecule.set_molecular_charge(charge); molecule.set_multiplicity(mult). # Determine HOMO; print('DGAS: What ref should this point to?'); eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); if Na == Nb:; HOMO = -Nb; elif Nb == 0:; HOMO = Na; else:; E_a = eps_a.np[int(Na - 1)]; E_b = eps_b.np[int(Nb - 1)]; if E_a >= E_b:; HOMO = Na; else:; HOMO = -Nb. stats.append("""""" %6d %6d %6d %6d %6d %6d\n"""""" % (Nintegral-1, Na, Nb, charge, mult, HOMO)). if HOMO > 0:; Na -= 1; else:; Nb -= 1; charge += 1; mult = Na - Nb + 1. core.set_local_option(""SCF"", ""DF_INTS_IO"", ""NONE""). # => Print the results out <= #; E = {}; core.print_out(""""""\n ==> Fractional Occupation Nuke Results <==\n\n""""""); core.print_out("""""" %-11s %-24s %-24s %11s\n"""""" % ('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(len(Ns)):; core.print_out("""""" %11.3E %24.16E %24.16E %11d\n"""""" % (Ns[k], energies[k], potentials[k], convs[k])); E[Ns[k]] = energies[k]. core.print_out('\n'); core.print_out("""""" %6s %6s %6s %6s %6s %6",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/frac.html:12715,charge,charge,12715,psi4manual/1.7.x/_modules/psi4/driver/frac.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/frac.html,4,['charge'],['charge']
Energy Efficiency," ci_nat_orbs(self); docstring. cleanup_ci(self); docstring. cleanup_dpd(self); docstring. compute_energy(self); Computes the energy of the Wavefunction. compute_gradient(self); Computes the gradient of the Wavefunction. compute_hessian(self); Computes the Hessian of the Wavefunction. compute_state_transfer(self, arg0, arg1, ...); docstring. deep_copy(self, arg0); Deep copies the internal data. del_array_variable(self, arg0); Removes the requested (case-insensitive) Matrix QC variable. del_potential_variable(self, arg0); Removes the requested (case-insensitive) ExternalPotential QC variable. del_scalar_variable(self, arg0); Removes the requested (case-insensitive) double QC variable. del_variable(key); Removes scalar or array QCVariable key from cls if present. density_fitted(self); Returns whether this wavefunction was obtained using density fitting or not. diag_h(self, arg0, arg1); docstring. doccpi(self); Returns the number of doubly occupied orbitals per irrep. efzc(self); Returns the frozen-core energy. energy(self); Returns the Wavefunction's energy. epsilon_a(self); Returns the Alpha Eigenvalues. epsilon_a_subset(self, basis, subset); Returns the requested Alpha orbital energies subset. epsilon_b(self); Returns the Beta Eigenvalues. epsilon_b_subset(self, basis, subset); Returns the requested Beta orbital energies subset. esp_at_nuclei(self); returns electrostatic potentials at nuclei. external_pot(self); Gets the requested external potential. force_doccpi(self, arg0); Specialized expert use only. force_soccpi(self, arg0); Specialized expert use only. form_opdm(self); docstring. form_tpdm(self); docstring. frequencies(). from_file(wfn_data); Build Wavefunction from data. frzcpi(self); Returns the number of frozen core orbitals per irrep. frzvpi(self); Returns the number of frozen virtual orbitals per irrep. get_array(key). Deprecated since version 1.4. get_basisset(self, arg0); Returns the requested auxiliary basis. get_density(self, arg0); Experimental!. get_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CIWavefunction.html:3035,energy,energy,3035,psi4manual/1.6.x/api/psi4.core.CIWavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CIWavefunction.html,1,['energy'],['energy']
Energy Efficiency," ci_nat_orbs(self); docstring. cleanup_ci(self); docstring. cleanup_dpd(self); docstring. compute_energy(self); Computes the energy of the Wavefunction. compute_gradient(self); Computes the gradient of the Wavefunction. compute_hessian(self); Computes the Hessian of the Wavefunction. compute_state_transfer(self, arg0, arg1, ...); docstring. deep_copy(self, arg0); Deep copies the internal data. del_array_variable(self, arg0); Removes the requested (case-insensitive) Matrix QC variable. del_potential_variable(self, arg0); Removes the requested (case-insensitive) ExternalPotential QC variable. del_scalar_variable(self, arg0); Removes the requested (case-insensitive) double QC variable. del_variable(key); Removes scalar or array QCVariable key from cls if present. density_fitted(self); Returns whether this wavefunction was obtained using density fitting or not. diag_h(self, arg0, arg1); docstring. doccpi(self); Returns the number of doubly occupied orbitals per irrep. efzc(self); Returns the frozen-core energy. energy(self); Returns the Wavefunction's energy. epsilon_a(self); Returns the Alpha Eigenvalues. epsilon_a_subset(self, basis, subset); Returns the requested Alpha orbital energies subset. epsilon_b(self); Returns the Beta Eigenvalues. epsilon_b_subset(self, basis, subset); Returns the requested Beta orbital energies subset. esp_at_nuclei(self); returns electrostatic potentials at nuclei. external_pot(self); Gets the requested external potential. force_doccpi(self, arg0); Specialized expert use only. force_soccpi(self, arg0); Specialized expert use only. form_opdm(self); docstring. form_tpdm(self); docstring. frequencies(). from_file(wfn_data); Build Wavefunction from data. frzcpi(self); Returns the number of frozen core orbitals per irrep. frzvpi(self); Returns the number of frozen virtual orbitals per irrep. get_array(key). Deprecated since version 1.4. get_basisset(self, arg0); Returns the requested auxiliary basis. get_dimension(self, arg0); Returns the dimen",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.ciwavefunction.html:3028,energy,energy,3028,psi4manual/1.5.0/api/psi4.core.ciwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.ciwavefunction.html,1,['energy'],['energy']
Energy Efficiency," class Psi4NativeEngine(geometric.engine.Engine):; """"""; Internally run an energy and gradient calculation for geometric ; """"""; def __init__(self, p4_name, p4_mol, p4_return_wfn, **p4_kwargs):; ; self.p4_name = p4_name; self.p4_mol = p4_mol; self.p4_return_wfn = p4_return_wfn; self.p4_kwargs = p4_kwargs; ; molecule = geometric.molecule.Molecule(); molecule.elem = [p4_mol.symbol(i).capitalize() for i in range(p4_mol.natom())]; molecule.xyzs = [p4_mol.geometry().np * qcel.constants.bohr2angstroms] ; molecule.build_bonds(); ; super(Psi4NativeEngine, self).__init__(molecule); ; def calc(self, coords, dirname, read_data=False):; self.p4_mol.set_geometry(core.Matrix.from_array(coords.reshape(-1,3))); self.p4_mol.update_geometry(); if self.p4_return_wfn:; g, wfn = gradient(self.p4_name, return_wfn=True, molecule=self.p4_mol, **self.p4_kwargs); self.p4_wfn = wfn; else:; g = gradient(self.p4_name, return_wfn=False, molecule=self.p4_mol, **self.p4_kwargs); e = core.variable('CURRENT ENERGY'); return {'energy': e, 'gradient': g.np.ravel()}. return_wfn = kwargs.pop('return_wfn', False); return_history = kwargs.pop('return_history', False). if return_history:; step_energies = []; step_gradients = []; step_coordinates = []. # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()). # Do not change orientation or COM; molecule.fix_orientation(True); molecule.fix_com(True); molecule.update_geometry(). # Get geometric-specific options; optimizer_keywords = {k.lower(): v for k, v in kwargs.get(""optimizer_keywords"", {}).items()}. core.print_out('\n'); core.print_out(""\n ==> GeomeTRIC Optimizer <== ~\n""); ; # Default to Psi4 maxiter unless overridden; if 'maxiter' not in optimizer_keywords:; optimizer_keywords['maxiter'] = core.get_global_option('GEOM_MAXITER'). # Default to Psi4 geometry convergence criteria unless overridden ; if 'convergence_set' not in optimizer_keywords:; optimizer_keywords['convergence_set'] = core.g",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:54802,energy,energy,54802,psi4manual/1.8.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html,1,['energy'],['energy']
Energy Efficiency," cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples. >>> # [1] Coupled-cluster singles and doubles calculation with psi code; >>> energy('ccsd'). >>> # [2] Charge-transfer SAPT calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). >>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). >>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). >>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy('fci', ref_wfn=cisd_wfn). >>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""CCSD/cc-pV[DT]Z""). >>> # [7] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> energy(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. PSI4 API: Linking C++ and Python; energy. © Copyright 2021, The Psi4 Project.; Last updated on Thu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.energy-1.html:21836,energy,energy,21836,psi4manual/1.4.0/api/psi4.driver.energy-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.energy-1.html,2,['energy'],['energy']
Energy Efficiency," cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples. >>> # [1] Coupled-cluster singles and doubles calculation with psi code; >>> energy('ccsd'). >>> # [2] Charge-transfer SAPT calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). >>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). >>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). >>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy('fci', ref_wfn=cisd_wfn). >>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""CCSD/cc-pV[DT]Z""). >>> # [7] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> energy(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Psithon Functions: Invoking a Calculation; Single-Point Energy — energy(). © Copyright 2021, The P",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/energy-1.html:22062,energy,energy,22062,psi4manual/1.4.0/energy-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/energy-1.html,2,['energy'],['energy']
Energy Efficiency," cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples. >>> # [1] Coupled-cluster singles and doubles calculation with psi code; >>> energy('ccsd'). >>> # [2] Charge-transfer SAPT calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). >>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). >>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). >>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy('fci', ref_wfn=cisd_wfn). >>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""CCSD/cc-pV[DT]Z""). >>> # [7] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> energy(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. PSI4 API: Linking C++ and Python; energy. © Copyright 2021, The Psi4 Project.; Last updated on Sun",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.driver.energy-1.html:21901,energy,energy,21901,psi4manual/1.5.0/api/psi4.driver.energy-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.driver.energy-1.html,2,['energy'],['energy']
Energy Efficiency," cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples. >>> # [1] Coupled-cluster singles and doubles calculation with psi code; >>> energy('ccsd'). >>> # [2] Charge-transfer SAPT calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). >>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). >>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). >>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy('fci', ref_wfn=cisd_wfn). >>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""CCSD/cc-pV[DT]Z""). >>> # [7] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> energy(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Psithon Functions: Invoking a Calculation; Single-Point Energy — energy(). © Copyright 2021, The P",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/energy-1.html:22127,energy,energy,22127,psi4manual/1.5.0/energy-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/energy-1.html,2,['energy'],['energy']
Energy Efficiency," cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples. >>> # [1] Coupled-cluster singles and doubles calculation with psi code; >>> energy('ccsd'). >>> # [2] Charge-transfer SAPT calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). >>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). >>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). >>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy('fci', ref_wfn=cisd_wfn). >>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""CCSD/cc-pV[DT]Z""). >>> # [7] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> energy(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. PSI4 API: Linking C++ and Python; energy. © Copyright 2022, The Psi4 Project.; Last updated on Thu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.driver.energy.html:21901,energy,energy,21901,psi4manual/1.6.x/api/psi4.driver.energy.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.driver.energy.html,1,['energy'],['energy']
Energy Efficiency," cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples. >>> # [1] Coupled-cluster singles and doubles calculation with psi code; >>> energy('ccsd'). >>> # [2] Charge-transfer SAPT calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). >>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). >>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). >>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy('fci', ref_wfn=cisd_wfn). >>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""CCSD/cc-pV[DT]Z""). >>> # [7] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> energy(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Psithon Functions: Invoking a Calculation; Single-Point Energy — energy(). © Copyright 2022, The P",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/energy.html:22127,energy,energy,22127,psi4manual/1.6.x/energy.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/energy.html,1,['energy'],['energy']
Energy Efficiency," cluster_size=0)[source]¶; Function to returns a LIST of all subclusters of the molecule mol of; real size cluster_size. If cluster_size = 0, returns all possible; combinations of cluster size. extract_clusters(mol, ghost=True, cluster_size=0)[source]¶; Function to return all subclusters of the molecule mol of; real size cluster_size and all other atoms ghosted if ghost; equals true, all other atoms discarded if ghost is false. If; cluster_size = 0, returns all possible combinations of cluster size. geometry(geom, name='default')[source]¶; Function to create a molecule object of name name; from the geometry in string geom. new_get_attr(self, name)[source]¶; Function to redefine get_attr method of molecule class. new_set_attr(self, name, value)[source]¶; Function to redefine set_attr method of molecule class. proc¶. run_adc(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; an algebraic diagrammatic construction calculation. Caution; Get rid of active molecule lines- should be handled in energy. run_bccd(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a Brueckner CCD calculation. run_bccd_t(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a Brueckner CCD(T) calculation. run_cc_gradient(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a CCSD and CCSD(T) gradient calculation. run_cc_property(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; all CC property calculations. run_ccenergy(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a CCSD, CC2, and CC3 calculation. run_cepa(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a cepa-like calculation.; >>> energy('cepa(1)'). run_cepa0(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a CEPA (LCCD) computation. run_cepa0_gradient(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_driver-1.html:7731,energy,energy,7731,psi4manual/4.0b4/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_driver-1.html,2,['energy'],['energy']
Energy Efficiency," cluster_size=0)[source]¶; Function to returns a LIST of all subclusters of the molecule mol of; real size cluster_size. If cluster_size = 0, returns all possible; combinations of cluster size. extract_clusters(mol, ghost=True, cluster_size=0)[source]¶; Function to return all subclusters of the molecule mol of; real size cluster_size and all other atoms ghosted if ghost; equals true, all other atoms discarded if ghost is false. If; cluster_size = 0, returns all possible combinations of cluster size. geometry(geom, name='default')[source]¶; Function to create a molecule object of name name; from the geometry in string geom. new_get_attr(self, name)[source]¶; Function to redefine get_attr method of molecule class. new_set_attr(self, name, value)[source]¶; Function to redefine set_attr method of molecule class. proc¶. run_adc(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; an algebraic diagrammatic construction calculation. Caution; Get rid of active molecule lines- should be handled in energy. run_bccd(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a Brueckner CCD calculation. run_bccd_t(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a Brueckner CCD(T) calculation. run_cc_gradient(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a CCSD and CCSD(T) gradient calculation. run_cc_property(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; all CC property calculations. run_ccenergy(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a CCSD, CC2, and CC3 calculation. run_cepa(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a cepa-like calculation.; >>> energy('cepa(1)'). run_dcft(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a density cumulant functional theory calculation. run_dcft_gradient(name, **kwargs)[source]¶; Function encoding sequenc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_driver-1.html:7723,energy,energy,7723,psi4manual/4.0b3/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_driver-1.html,2,['energy'],['energy']
Energy Efficiency," code. clean(); Function to remove scratch files. clean_options(); Function to reset options to clean state. clean_variables(); Empties all PSI scalar and array variables that have been set internally. close_outfile(); Closes the output file. dcft(arg0); Runs the density cumulant functional theory code. del_array_variable(arg0); Removes the requested (case-insensitive) Matrix QC variable. del_scalar_variable(arg0); Removes the requested (case-insensitive) double QC variable. del_variable(key). detci(arg0); Runs the determinant-based configuration interaction code. dfmp2(arg0); Runs the DF-MP2 code. dfocc(arg0); Runs the density-fitted orbital optimized CC codes. dmrg(arg0); Runs the DMRG code. doublet(A, B, transA, transB); Returns the multiplication of two matrices A and B, with options to transpose each beforehand. fcidump_tei_helper(nirrep, restricted, …); Write integrals to file in FCIDUMP format. finalize(). flush_outfile(); Flushes the output file. fnocc(arg0); Runs the fno-ccsd(t)/qcisd(t)/mp4/cepa energy code. get_active_molecule(); Returns the currently active molecule object. get_array_variable(key). get_array_variables(). get_atomic_point_charges(); Returns the most recently computed atomic point charges, as a double * object. get_datadir(); Sets the path to shared text resources, PSIDATADIR. get_global_option(arg0); Given a string of a keyword name arg1, returns the value associated with the keyword from the global options. get_global_option_list(); Returns a list of all global options. get_gradient(). get_legacy_gradient(); Returns the global gradient as a (nat, 3) Matrix object. get_legacy_molecule(); Returns the currently active molecule object. get_local_option(arg0, arg1); Given a string of a keyword name arg2 and a particular module arg1, returns the value associated with the keyword in the module options scope. get_memory(); Returns the amount of memory available to Psi (in bytes). get_num_threads(); Returns the number of threads to use in SMP para",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psi4api-1.html:294676,energy,energy,294676,psi4manual/1.3.2/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psi4api-1.html,2,['energy'],['energy']
Energy Efficiency," code.; ; ccsort(...); ccsort() -> float :; Runs CCSORT, which reorders integrals for use in the coupled cluster codes.; ; cctriples(...); cctriples() -> float :; Runs the coupled cluster (T) energy code.; ; clean(...); clean() -> None :; Function to remove scratch files. Call between independent jobs.; ; close_outfile(...); close_outfile() -> None :; Closes the output file.; ; compute_shell(...); compute_shell( (TwoBodyAOInt)arg1, (int)arg2, (int)arg3, (int)arg4, (int)arg5) -> None :; docstring; ; dcft(...); dcft() -> float :; Runs the density cumulant functional theory code.; ; deriv(...); deriv() -> int :; Runs deriv, which contracts density matrices with derivative integrals, to compute gradients.; ; detci(...); detci() -> float :; Runs the determinant-based configuration interaction code.; ; dfmp2(...); dfmp2() -> float :; Runs the DF-MP2 code.; ; dfmp2grad(...); dfmp2grad() -> float :; Runs the DF-MP2 gradient.; ; fd_1_0(...); fd_1_0( (list)arg1) -> PsiReturnType :; Performs a finite difference gradient computation, from energy points.; ; fd_freq_0(...); fd_freq_0( (list)arg1, (int)arg2) -> PsiReturnType :; Performs a finite difference frequency computation, from energy points, for a given irrep.; ; fd_freq_1(...); fd_freq_1( (list)arg1, (int)arg2) -> PsiReturnType :; Performs a finite difference frequency computation, from gradients, for a given irrep.; ; fd_geoms_1_0(...); fd_geoms_1_0() -> matrix_vector :; Gets the list of displacements needed for a finite difference gradient computation, from energy points.; ; fd_geoms_freq_0(...); fd_geoms_freq_0( (int)arg1) -> matrix_vector :; Gets the list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep.; ; fd_geoms_freq_1(...); fd_geoms_freq_1( (int)arg1) -> matrix_vector :; Gets the list of displacements needed fof a finite difference frequency computation, from gradients, for a given irrep; ; fd_geoms_hessian_0(...); fd_geoms_hessian_0() -> matrix_vector :; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/psimod-1.html:155984,energy,energy,155984,psi4manual/4.0b5/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/psimod-1.html,2,['energy'],['energy']
Energy Efficiency," coldim(...); docstring. cols((self: psi4.core.Matrix, arg0: int) -> int); docstring. copy((self: psi4.core.Matrix, ...); docstring. copy_lower_to_upper(...); docstring. copy_upper_to_lower(...); docstring. diagonalize((self: psi4.core.Matrix, ...); docstring. doublet((self: psi4.core.Matrix, ...); docstring. from_array(arr[, name, dim1, dim2]); Converts a numpy array or list of numpy arrays into a Psi4 Matrix (irreped if list). from_serial(json_data); Converts serialized data to the correct Psi4 data type. gemm((self: psi4.core.Matrix, arg0: bool, ...); docstring. get(*args, **kwargs); Overloaded function. identity((self: psi4.core.Matrix) -> None); docstring. invert((self: psi4.core.Matrix) -> None); docstring. load((self: psi4.core.Matrix, arg0: str) -> None); docstring. load_mpqc((self: psi4.core.Matrix, ...); docstring. nirrep((self: psi4.core.Matrix) -> int); docstring. np_read(filename[, prefix]). np_write([filename, prefix]). partial_cholesky_factorize(...); docstring. power((self: psi4.core.Matrix, arg0: float, ...); docstring. print_out((self: psi4.core.Matrix) -> None); docstring. project_out((self: psi4.core.Matrix, ...); docstring. remove_symmetry((self: psi4.core.Matrix, ...); docstring. rms((self: psi4.core.Matrix) -> float); docstring. rotate_columns((self: psi4.core.Matrix, ...); docstring. rowdim(...); docstring. rows((self: psi4.core.Matrix, arg0: int) -> int); docstring. save((self: psi4.core.Matrix, arg0: str, ...); docstring. scale((self: psi4.core.Matrix, ...); docstring. scale_column((self: psi4.core.Matrix, ...); docstring. scale_row((self: psi4.core.Matrix, ...); docstring. schmidt((self: psi4.core.Matrix) -> None). set(*args, **kwargs); Overloaded function. subtract((self: psi4.core.Matrix, ...); docstring. sum_of_squares((self: psi4.core.Matrix) -> float); docstring. symmetrize_gradient((self: psi4.core.Matrix, ...); docstring. symmetry((self: psi4.core.Matrix) -> int); docstring. to_array(matrix[, copy, dense]); Converts a Psi4 Matrix or ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/api/psi4.core.matrix.html:1792,power,power,1792,psi4manual/1.1.0/api/psi4.core.matrix.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.matrix.html,1,['power'],['power']
Energy Efficiency," collect conventional quantities; # energy('mp3', **kwargs); # e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); # ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); # ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'); # e_mp2 = e_scf + ce_mp2; # e_mp3 = e_scf + ce_mp3; #; # # Compute quantities particular to MP2.5; # ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); # e_mp25 = e_scf + ce_mp25; # PsiMod.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25); # PsiMod.set_variable('MP2.5 TOTAL ENERGY', e_mp25); # PsiMod.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); # PsiMod.set_variable('CURRENT ENERGY', e_mp25); #; # # build string of title banner and print results; # banners = ''; # banners += """"""PsiMod.print_out('\\n')\n""""""; # banners += """"""banner(' MP2.5 ')\n""""""; # banners += """"""PsiMod.print_out('\\n')\n\n""""""; # exec(banners); #; # tables = ''; # tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); # tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); # tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); # tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); # tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); # tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); # tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); # PsiMod.print_out(tables); #; # return e_mp25. # A direct translation of a plugin input file into a function call. Function calls are the only; # way to call plugins in sow/reap mode for db(), opt(), etc. This isn't best practices; # but is an example of what to do for a more complicated procedure where different options ; # are set for different qc steps.; #def run_plugin_omega(name, **kwargs):; # r""""""Function encoding sequence of PSI module and plugin calls, as well; # as typical options, to access Rob Parrish's omega plugin.; #; # >>> energy('plugin_omega'); #; # """"""; # lowername = name.lower(); # kwargs = kwargs_lower(kwargs); #; # plugfile = PsiMod.Process.environment[""PSIDATADIR""] + ""/../tests/plugin",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/aliases.html:3700,energy,energy,3700,psi4manual/4.0b4/_modules/aliases.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/aliases.html,1,['energy'],['energy']
Energy Efficiency," component [H]; for the MP2.5 level of theory. MP3 TOTAL ENERGY¶. MP3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP3 level of theory. MP4(SDQ) TOTAL ENERGY¶. MP4(SDQ) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP4 singles, doubles, quadruples level of theory. Quantity; MP4(SDQ) CORRELATION ENERGY is; first right-hand term in Eq. (2). MP4 TOTAL ENERGY¶. MP4 CORRELATION ENERGY¶. MP4(SDTQ) TOTAL ENERGY¶. MP4(SDTQ) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the full MP4 level of theory. Quantity MP4 CORRELATION; ENERGY / MP4(SDTQ) CORRELATION ENERGY is left-hand term in Eq. (2). (2). MPn TOTAL ENERGY¶. MPn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Möller–Plesset perturbation theory level.; n is MP perturbation order. NUCLEAR REPULSION ENERGY¶; The nuclear repulsion energy contribution [H] to the total SCF energy.; Quantity in Eq. (4). (3). OCEPA(0) TOTAL ENERGY¶. OCEPA(0) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the orbital-optimized CEPA(0) level of theory. OMP2 TOTAL ENERGY¶. OMP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the orbital-optimized MP2 level of theory. OMP3 TOTAL ENERGY¶. OMP3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the orbital-optimized MP3 level of theory. ONE-ELECTRON ENERGY¶; The one-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (4). QCISD TOTAL ENERGY¶. QCISD CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the quadratic configuration interaction singles and doubles level; of theory. QCISD(T) TOTAL ENERGY¶. QCISD(T) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy com",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/glossary_psivariables-1.html:13236,energy,energy,13236,psi4manual/1.0.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/glossary_psivariables-1.html,12,['energy'],['energy']
Energy Efficiency," component molecular systems and model chemistry levels into final quantities. Parameters:. results – A set of tasks to process instead of self.task_list. Used in multilevel processing to pass a subset of; self.task_list filtered to only one modelchem level.; client – QCFractal client if using QCArchive for distributed compute. Returns:; When the ManyBodyComputer specifies a single model chemistry level (see self.nbodies_per_mc_level), the; return is a dictionary, nbody_results, described in the table below. Many of the items are actually filled; by successive calls to assemble_nbody_components(). When multiple model chemistry levels are specified, this; function diverts its return to driver_nbody_multilevel.prepare_results() wherein each mc level calls this; function again and collects separate nbody_results dictionaries and processes them into a final return that; is a small subset of the table below. Return type:; nbody_results. ptype_size = (1,)/(nat, 3)/(3 * nat, 3 * nat)e/g/h := energy or gradient or Hessian; rtd := return_total_data. item; size; present / zeroed; contents / interpretation. ret_ptype; ptype_size; always. interaction data requested: IE or total (depending on return_total_data) e/g/h (depending on driver)with cp/nocp/vmfc treatment (depending on 1st of bsse_type). ret_energy; 1; always; interaction energy: IE or total (depending on return_total_data) w/ cp/nocp/vmfc treat. (dep. on 1st of bsse_type). ret_gradient; (nat, 3); when driver is g/h; interaction gradient: IE or total (depending on return_total_data) w/ cp/nocp/vmfc treat. (dep. on 1st of bsse_type. ret_hessian; (nat * 3, nat * 3); when driver is h; interaction Hessian: IE or total (depending on return_total_data) w/ cp/nocp/vmfc treat. (dep. on 1st of bsse_type). nbody; >=1; always; energy n-body QCVariables to be set.   CP-CORRECTED TOTAL ENERGY THROUGH 1-BODY;   1; when cp in bsse_type; MBE sum of subsystems of 1-body. summed are total energies with cp treatment.   CP-CORRECTED TOTAL ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/nbody.html:21307,energy,energy,21307,psi4manual/1.8.x/nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/nbody.html,3,['energy'],['energy']
Energy Efficiency," component of the interaction; to which they contribute. The total component energies (i.e.,; electrostatics, exchange, induction, and dispersion) represent what we; regard as the best estimate available at a given level of SAPT computed; from a subset of the terms of that grouping. The groupings shown above are; not unique and are certainly not rigorously defined. We regard the groupings; used in Psi4 as a “chemist’s grouping” as opposed to a more; mathematically based grouping, which would group all exchange terms; (i.e. , , etc.) in; the exchange component. A final note is that both Disp22(T); and Est.Disp22(T) results appear if MP2 natural orbitals are; used to evaluate the triples correction to dispersion. The Disp22(T); result is the triples correction as computed in the truncated NO basis;; Est.Disp22(T) is a scaled result that attempts to recover; the effect of the truncated virtual space and is our best estimate. The Est.Disp22(T); value is used in the SAPT energy and dispersion component (see [Hohenstein:2010:104107]; for details). Finally, this part of the output file contains sSAPT0, a special scaling; scheme of the SAPT0 energy that can yield improved results and was described in more details; above. The corresponding scaled total component energies are printed as well.; As mentioned above, SAPT results with scaled exchange are also optionally available; by setting the EXCH_SCALE_ALPHA keyword. When activated, the unscaled results are; printed first as reported above, and then repeated with exchange scaling for all; relevant terms:; SAPT Results ==> ALL S2 TERMS SCALED (see Manual) <==. Scaling factor (Exch10/Exch10(S^2))^{Alpha} = 1.007200; with Alpha = 1.000000; --------------------------------------------------------------------------------------------------------; Electrostatics -13.06509118 [mEh] -8.19846883 [kcal/mol] -34.30239689 [kJ/mol]; Elst10,r -13.37542977 [mEh] -8.39320925 [kcal/mol] -35.11719087 [kJ/mol]; Elst12,r 0.04490350 [mEh] 0.0281773",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/sapt-1.html:24691,energy,energy,24691,psi4manual/1.0.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/sapt-1.html,2,['energy'],['energy']
Energy Efficiency," component of the singlet. Uses RHF singlet orbitals. cc22; ROHF-EOM-CCSD/DZ on the lowest two states of each irrep in \(^{3}B_1\) CH2. scf-bz2; Benzene Dimer Out-of-Core HF/cc-pVDZ. fd-freq-energy; SCF STO-3G finite-difference frequencies from energies for H2O. dct4; DCT calculation for the HF+ using DC-06 functional. This performs both two-step and simultaneous update of the orbitals and cumulant using DIIS extrapolation. Four-virtual integrals are first handled in the MO Basis for the first two energy computations. In the next two the ao_basis=disk algorithm is used, where the transformation of integrals for four-virtual case is avoided. The computation is then repeated using the DC-12 functional with the same algorithms. castup1; Test of SAD/Cast-up (mainly not dying due to file weirdness). cc29; CCSD/cc-pVDZ optical rotation calculation (both gauges) on Cartesian H2O2. fsapt-ext-abc-au; analog of fsapt-ext-abc with molecule and external potentials in Bohr. dfomp2-4; OMP2 cc-pVDZ energy for the NO molecule. fci-h2o; 6-31G H2O Test FCI Energy Point. mp2-grad1; MP2 cc-pVDZ gradient for the H2O molecule. cepa1; cc-pvdz H2O Test CEPA(1) Energy. ao-casscf-sp; CASSCF/6-31G** energy point. dft-custom-gga; DFT (LDA/GGA) test of custom implementations in: gga_superfuncs.py. cbs-xtpl-opt; Various extrapolated optimization methods for the H2 molecule. tdscf-6; td-camb3lyp with DiskDF and method/basis specification. cubeprop; RHF orbitals and density for water. omp3-2; OMP3 cc-pCVDZ energy with ROHF initial guess for the NO radical. x2c1; Test of SFX2C-1e on water uncontracted cc-pVDZ-DK The reference numbers are from Lan Cheng’s implementation in Cfour. pywrap-alias; Test parsed and exotic calls to energy() like zapt4, mp2.5, and cisd are working. cc9a; ROHF-CCSD(T) cc-pVDZ energy for the \(^2\Sigma^+\) state of the CN radical, with Z-matrix input. nbody-cp-gradient; Computation of CP-corrected water trimer gradient (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html:13193,energy,energy,13193,psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency," computation completes.; In PsiAPI mode, one can use commands set_options() and; set_module_options() like below. Note that these values; should be of correct type, strings for strings, floats for floats like; convergences. The function ~psi4.core.clean_options that reinitializes; all options may also be useful to separate calculations in a PsiAPI; session.; 1; 2; 3; 4; 5; 6; 7; 8; 9psi4.set_options({; 'scf_type': 'pk',; 'e_convergence': 1.e-5,; 'soscf': True; }). psi4.set_module_options({; 'geom_maxiter': 50; }). Basis Sets¶. Basis Sets; Built-In Basis Sets; Mixing Basis Sets; Decontracted Basis Sets; User-Defined Basis Sets. PSI Variables¶; To harness the power of Python, PSI4 makes the most pertinent results; of each computation available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of; H2 and H atom:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19molecule h2 {; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h {; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol * (2*h_energy - h2_energy); print ""De=%f"" % D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module, and PSI Variables by Alpha defines them. These can be; accessed through the get_variable() function. For example, after; performing a density fitted MP2 computation, both the spin component; scaled energy and the unscaled MP2 energy are made available:; 1; 2e_mp2 = get_variable('MP2 TOTAL ENERGY'); e_scs_mp2 = get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI vari",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psithoninput-1.html:8801,energy,energy,8801,psi4manual/1.1.0/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psithoninput-1.html,2,['energy'],['energy']
Energy Efficiency," computation of the water dimer interaction energy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. mints4; A demonstration of mixed Cartesian/ZMatrix geometry specification, using variables, for the benzene-hydronium complex. Atoms can be placed using ZMatrix coordinates, whether they belong to the same fragment or not. Note that the Cartesian specification must come before the ZMatrix entries because the former define absolute positions, while the latter are relative. tu4-h2o-freq; Optimization followed by frequencies H2O HF/cc-pVDZ. mp2p5-grad1; MP2.5 cc-pVDZ gradient for the H2O molecule. dfmp2-grad3; DF-MP2 cc-pVDZ gradients for the H2O molecule. dfomp2p5-1; DF-OMP2.5 cc-pVDZ energy for the H2O molecule. omp3-3; OMP3 cc-pVDZ energy with B3LYP initial guess for the NO radical. dfomp3-2; DF-OMP3 cc-pVDZ energy for the H2O+ cation. pubchem1; Benzene vertical singlet-triplet energy difference computation, using the PubChem database to obtain the initial geometry, which is optimized at the HF/STO-3G level, before computing single point energies at the RHF, UHF and ROHF levels of theory. opt2; SCF DZ allene geometry optimization, with Cartesian input, first in c2v symmetry, then in Cs symmetry from a starting point with a non-linear central bond angle. dfomp2-3; OMP2 cc-pVDZ energy for the H2O molecule. omp3-2; OMP3 cc-pVDZ energy with ROHF initial guess for the NO radical. ocepa3; OCEPA cc-pVDZ energy with ROHF initial guess for the NO radical. cisd-h2o+-1; 6-31G** H2O+ Test CISD Energy Point. mcscf1; ROHF 6-31G** energy of the \(^{3}B_1\) state of CH2, with Z-matrix input. The occupations are specified explicitly. dfomp2p5-grad2; DF-OMP2.5 cc-pVDZ gradients for the H2O+ cation. props3; DF-SCF cc-pVDZ multipole moments of benzene, up to 7th order and electrostatic potentials evaluated at the nuclear coordinates. scf11-freq-from-energies; Test frequencies by finite differences of energies for planar C4NH4 TS. stability1; UHF->UHF stability a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/testsuite-1.html:19060,energy,energy,19060,psi4manual/1.1.0/testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/testsuite-1.html,4,['energy'],['energy']
Energy Efficiency," computation. The following is an; example of the results for a computation run with the call; energy('fno-qcisd') to energy():; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30QCISD iterations converged!. OS MP2 FNO correction: -0.000819116338; SS MP2 FNO correction: -0.000092278158; MP2 FNO correction: -0.000911394496. OS MP2 correlation energy: -0.166478414245; SS MP2 correlation energy: -0.056669079827; MP2 correlation energy: -0.223147494072; * MP2 total energy: -76.258836941658. OS MP2.5 correlation energy: -0.171225850256; SS MP2.5 correlation energy: -0.054028401038; MP2.5 correlation energy: -0.225254251294; * MP2.5 total energy: -76.260943698880. OS MP3 correlation energy: -0.175973286267; SS MP3 correlation energy: -0.051387722248; MP3 correlation energy: -0.227361008515; * MP3 total energy: -76.263050456101. OS MP4(SDQ) correlation energy: -0.180324322304; SS MP4(SDQ) correlation energy: -0.048798468084; MP4(SDQ) correlation energy: -0.230995119324; * MP4(SDQ) total energy: -76.266684566910. OS QCISD correlation energy: -0.181578117924; SS QCISD correlation energy: -0.049853548145; QCISD correlation energy: -0.231431666069; * QCISD total energy: -76.267121113654. The first set of energies printed corresponds to the second-order FNO; correction mentioned previously. Results for many-body perturbation; theory through partial fourth order are then provided.; The notation MP4(SDQ) indicates that we have included all contributions to; the correlation energy through fourth order, with the exception of that; from connected triple excitations.; One need not run a full QCISD or CCSD computation to obtain these; perturbation theory results. The keywords for invoking perturbation; theory computations are given below in; Table FNOCC Methods. Full MP4 correlation; energies are also available. Coupled electron pair approximation¶; Coupled-pair methods can be viewed as approximations to CCSD or as; size-exten",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/fnocc-1.html:6096,energy,energy,6096,psi4manual/1.1.0/fnocc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/fnocc-1.html,6,['energy'],['energy']
Energy Efficiency," computations of three-body dispersion; corrections. In DFT-D3, three-body dispersion is approximated with the; Axilrod-Teller-Muto model:. \[E_{disp}^{(3)}=-\frac{1}{6}\sum_{A\neqB\neqC}\frac{C_{9}^{ABC}(3\cos{\theta_a}\cos{\theta_b}\cos{\theta_c}+1)}{(r_{AB}r_{BC}r_{AC})^{3}}f_{damp}(\bar{r}_{ABC})\]; where \(\theta_a\) is the angle at atom A corresponding to the triangle formed by atoms A, B, and C,; and \(\bar{r}_{ABC}\) is the geometric mean of the corresponding atomic-pair distances.; The dispersion coefficients are defined as. \[C_{9}^{ABC} = \sqrt{C_{6}^{AB}C_{6}^{BC}C_{6}^{AC}}\]; See the DFT-D3 documentation; for more details.; For now, the three-body correction can be called by using the run_dftd3(); function with d3-atmgr as the passed functional string.; For example, the three-body ATM dispersion correction for a neon trimer could; be computed with:; molecule ne3 {; Ne 0.0 0.0 0.0; Ne 0.0 0.0 1.0; Ne 0.0 1.0 1.0; }; ne.update_geometry(); energy = m.run_dftd3('d3-atmgr', dertype=0); print(energy). Footnotes. 1; Note that there are functionals with these extensions (e.g., wB97X-D) that,; not being Grimme corrections, won’t follow this table exactly. 2; [Grimme:2004:1463]. 3; [Grimme:2006:1787]. 4; [Grimme:2010:154104]. 5; [Grimme:2011:1456]. 6(1,2); [Smith:2016:2197]. 7; [Hujo:2011:3866]. 8; [Chai:2010:6615]. 9; [Pernal:2009:263201]. 10; [Podeszwa:2010:550]. 11; Keyword not used for user-defined functionals where the dft_dict[""dispersion""][""params""]; is easily editable for this purpose. See Advanced Functional Use and Manipulation. 12; [Caldeweyher:2019:154122]. A few practical examples:. DFT-D2 single point with default parameters (dftd3 not called); energy('bp86-d'). DFT-D3BJ optimization with default parameters; optimize('pbe-d3bj'). DFT-D2 optimization with custom s6 parameter; set dft_dispersion_parameters [1.20]; optimize('b3lyp-d2'). DFT-D3ZERO single point (b3lyp) with custom s8 parameter (reset all four values); set dft_dispersion_parameters [1.0",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/dftd3-1.html:8125,energy,energy,8125,psi4manual/1.5.0/dftd3-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/dftd3-1.html,3,['energy'],['energy']
Energy Efficiency," computations of three-body dispersion; corrections. In DFT-D3, three-body dispersion is approximated with the; Axilrod-Teller-Muto model:. \[E_{disp}^{(3)}=-\frac{1}{6}\sum_{A\neqB\neqC}\frac{C_{9}^{ABC}(3\cos{\theta_a}\cos{\theta_b}\cos{\theta_c}+1)}{(r_{AB}r_{BC}r_{AC})^{3}}f_{damp}(\bar{r}_{ABC})\]; where \(\theta_a\) is the angle at atom A corresponding to the triangle formed by atoms A, B, and C,; and \(\bar{r}_{ABC}\) is the geometric mean of the corresponding atomic-pair distances.; The dispersion coefficients are defined as. \[C_{9}^{ABC} = \sqrt{C_{6}^{AB}C_{6}^{BC}C_{6}^{AC}}\]; See the DFT-D3 documentation; for more details.; For now, the three-body correction can be called by using the run_dftd3(); function with d3-atmgr as the passed functional string.; For example, the three-body ATM dispersion correction for a neon trimer could; be computed with:; molecule ne3 {; Ne 0.0 0.0 0.0; Ne 0.0 0.0 1.0; Ne 0.0 1.0 1.0; }; ne.update_geometry(); energy = m.run_dftd3('d3-atmgr', dertype=0); print(energy). Footnotes. 1; Note that there are functionals with these extensions (e.g., wB97X-D) that,; not being Grimme corrections, won’t follow this table exactly. 2; [Grimme:2004:1463]. 3; [Grimme:2006:1787]. 4; [Grimme:2010:154104]. 5; [Grimme:2011:1456]. 6(1,2); [Smith:2016:2197]. 7; [Hujo:2011:3866]. 8; [Chai:2010:6615]. 9; [Pernal:2009:263201]. 10; [Podeszwa:2010:550]. 11; Keyword not used for user-defined functionals where the dft_dict[""dispersion""][""params""]; is easily editable for this purpose. See Advanced Functional Use and Manipulation. A few practical examples:. DFT-D2 single point with default parameters (dftd3 not called); energy('bp86-d'). DFT-D3BJ optimization with default parameters; optimize('pbe-d3bj'). DFT-D2 optimization with custom s6 parameter; set dft_dispersion_parameters [1.20]; optimize('b3lyp-d2'). DFT-D3ZERO single point (b3lyp) with custom s8 parameter (reset all four values); set dft_dispersion_parameters [1.0, 2.0, 1.261, 14.0]; energy('b3",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/dftd3-1.html:7830,energy,energy,7830,psi4manual/1.4.0/dftd3-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/dftd3-1.html,2,['energy'],['energy']
Energy Efficiency," computations of three-body dispersion; corrections. In DFT-D3, three-body dispersion is approximated with the; Axilrod-Teller-Muto model:. \[E_{disp}^{(3)}=-\frac{1}{6}\sum_{A\neqB\neqC}\frac{C_{9}^{ABC}(3\cos{\theta_a}\cos{\theta_b}\cos{\theta_c}+1)}{(r_{AB}r_{BC}r_{AC})^{3}}f_{damp}(\bar{r}_{ABC})\]; where \(\theta_a\) is the angle at atom A corresponding to the triangle formed by atoms A, B, and C,; and \(\bar{r}_{ABC}\) is the geometric mean of the corresponding atomic-pair distances.; The dispersion coefficients are defined as. \[C_{9}^{ABC} = \sqrt{C_{6}^{AB}C_{6}^{BC}C_{6}^{AC}}\]; See the DFT-D3 documentation; for more details.; For now, the three-body correction can be called by using the run_dftd3(); function with d3-atmgr as the passed functional string.; For example, the three-body ATM dispersion correction for a neon trimer could; be computed with:; molecule ne3 {; Ne 0.0 0.0 0.0; Ne 0.0 0.0 1.0; Ne 0.0 1.0 1.0; }; ne.update_geometry(); energy = m.run_dftd3('d3-atmgr', dertype=0); print(energy). Since v1.7, it is preferred to use s-dftd3 for ATM since the 3-body can be run concurrent; with the 2-body contribution.; Footnotes. [1]; Note that there are functionals with these extensions (e.g., wB97X-D) that,; not being Grimme corrections, won’t follow this table exactly. [2]; [Grimme:2004:1463]. [3]; [Grimme:2006:1787]. [4]; (1,2); [Grimme:2010:154104]. [5]; (1,2); [Grimme:2011:1456]. [6]; (1,2,3,4); [Smith:2016:2197]. [7]; [Hujo:2011:3866]. [8]; [Chai:2010:6615]. [9]; [Pernal:2009:263201]. [10]; [Podeszwa:2010:550]. [11]; Keyword not used for user-defined functionals where the dft_dict[""dispersion""][""params""]; is easily editable for this purpose. See Advanced Functional Use and Manipulation. [12]; [Caldeweyher:2019:154122]. A few practical examples:. DFT-D2 single point with default parameters (dftd3 not called); energy('bp86-d'). DFT-D3BJ optimization with default parameters; optimize('pbe-d3bj'). DFT-D2 optimization with custom s6 parameter; set dft_di",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/dftd3.html:10871,energy,energy,10871,psi4manual/1.7.x/dftd3.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/dftd3.html,2,['energy'],['energy']
Energy Efficiency," compute the single-point electronic energy. :returns: *float* |w--w| Total electronic energy in Hartrees. SAPT & EFP return interaction energy. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY <CURRENTENERGY>`; * :psivar:`CURRENT REFERENCE ENERGY <CURRENTREFERENCEENERGY>`; * :psivar:`CURRENT CORRELATION ENERGY <CURRENTCORRELATIONENERGY>`. :type name: string; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type restart_file: string; :param restart_file: ``['file.1, file.32]`` || ``./file`` || etc. Binary data files to be renamed for calculation restart. .. _`table:energy_gen`:. +-------------------------+---------------------------------------------------------------------------------------------------------------+; | name | calls method |; +=========================+===============================================================================================================+; | efp | effective fragment potential (EFP) :ref:`[manual] <sec:libefp>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | scf | Hartree--Fock (HF) or density functional theory (DFT) :ref:`[manual] <sec:scf>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | hf | HF self consiste",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html:7942,energy,energy,7942,psi4manual/1.3.2/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html,3,['energy'],['energy']
Energy Efficiency," conda package into the main environment of an Anaconda or Miniconda; distribution and added that to your PATH, as prompted, then; which psi4 likely yields condadist/bin/psi4 and the PATH; setting lines below are redundant.; If you installed into a conda environment p4env and performed; conda activate p4env, then which psi4 likely yields; condadist/envs/p4env/bin/psi4 and the PATH setting lines; below are redundant.; # csh, tcsh: add to shell or ~/.tcshrc file; unsetenv PSIDATADIR; setenv PATH {prefix}/bin:$PATH; setenv PSI_SCRATCH /path/to/existing/writable/local-not-network/directory/for/scratch/files. # sh, bash: add to shell or ~/.bashrc (Linux/Windows) or ~/.bash_profile (Mac) file; unset PSIDATADIR; export PATH={prefix}/bin:$PATH; export PSI_SCRATCH=/path/to/existing/writable/local-not-network/directory/for/scratch/files. Run PSI4 as executable.; 1; 2; 3; 4; 5; 6; 7; 8>>> cat sample.in; molecule {; He; }; energy('hf/cc-pvdz'); compare_values(-2.85518839, get_variable('current energy'), 5, 'SCF E'); >>> psi4 sample.in; SCF E.............................................................PASSED. or Run PSI4 as Python module.; 1; 2; 3; 4; 5; 6; 7; 8; 9>>> cat sample.py; import psi4; mol = psi4.geometry(""""""; He; """"""); psi4.energy('hf/cc-pvdz'); psi4.compare_values(-2.85518839, psi4.core.get_variable('current energy'), 5, 'SCF E'); >>> python sample.py; SCF E.............................................................PASSED. How to run Psi4 as executable after compilation using driver from source¶; When developing python driver code, it can be annoying to keep makeing to test the code. PSI4 can be run “inplace” through the; following procedure. To be clear, this is running compiled C++ from the; build directory and python from the source directory. This is an expert; option for development, and not all functionality will be available.; 1; 2; 3>>> cd {objdir}; >>> ln -s {top-level-psi4-dir}/{objdir}/stage/lib/psi4/core.cpython-{ext_will_vary}.so ../psi4/core.cpython-{e",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/build_planning-1.html:27418,energy,energy,27418,psi4manual/1.3.2/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/build_planning-1.html,2,['energy'],['energy']
Energy Efficiency," conv double; Default: 1.0e-12. CUBIC_BLOCK_MAX_POINTS¶. CubicScalarGrid maximum number of grid points per evaluation block. Type: integer; Default: 1000. DEBUG¶. The amount of information to print to the output file. Type: integer; Default: 0. DERTYPE¶. Derivative level. Type: string; Possible Values: NONE, FIRST, SECOND, RESPONSE; Default: NONE. DIE_IF_NOT_CONVERGED¶. Psi4 dies if energy does not converge. Type: boolean; Default: true. DKH_ORDER¶. Order of Douglas-Kroll-Hess. Type: integer; Default: 2. EXTERNAL_POTENTIAL_SYMMETRY¶. Assume external fields are arranged so that they have symmetry. It is up to the user to know what to do here. The code does NOT help you out in any way!. Type: boolean; Default: false. MAT_NUM_COLUMN_PRINT¶. Number of columns to print in calls to Matrix::print_mat. Type: integer; Default: 5. PCMSOLVER_PARSED_FNAME¶. Name of the PCMSolver input file as parsed by pcmsolver.py. Type: string; Default: No Default. PCM_SCF_TYPE¶. Use total or separate potentials and charges in the PCM-SCF step. Type: string; Possible Values: TOTAL, SEPARATE; Default: TOTAL. RAS1¶. An array giving the number of orbitals per irrep for RAS1. Type: array; Default: No Default. RAS2¶. An array giving the number of orbitals per irrep for RAS2. Type: array; Default: No Default. RAS3¶. An array giving the number of orbitals per irrep for RAS3. Type: array; Default: No Default. RAS4¶. An array giving the number of orbitals per irrep for RAS4. Type: array; Default: No Default. RELATIVISTIC¶. Relativistic Hamiltonian type. Type: string; Possible Values: NO, X2C; Default: NO. WFN¶. Wavefunction type. Type: string; Default: SCF. table of contents. GLOBALS; General; ACTIVE; BASIS_RELATIVISTIC; BENCH; CC_TYPE; CI_TYPE; CUBEPROP_BASIS_FUNCTIONS; CUBEPROP_FILEPATH; CUBEPROP_ORBITALS; CUBEPROP_TASKS; CUBIC_GRID_OVERAGE; CUBIC_GRID_SPACING; DF_BASIS_CC; DOCC; FREEZE_CORE; FROZEN_DOCC; FROZEN_UOCC; INTEGRAL_PACKAGE; LITERAL_CFOUR; MOLDEN_WITH_VIRTUAL; MP2_TYPE; MP_TYPE; NUM_FROZE",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/module__globals-1.html:7740,charge,charges,7740,psi4manual/1.2.1/autodir_options_c/module__globals-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/module__globals-1.html,2,['charge'],['charges']
Energy Efficiency," converged to the expected accuracy. cepa0-grad2; CEPA cc-pVDZ gradient for the NO radical. cc45; RHF-EOM-CC2/cc-pVDZ lowest two states of each symmetry of H2O. fci-tdm-2; BH-H2+ FCI/cc-pVDZ Transition Dipole Moment. psimrcc-ccsd_t-2; Mk-MRCCSD(T) single point. CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. sad1; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. psimrcc-fd-freq1; Mk-MRCCSD single point. O2 state described using the Ms = 0 component of the triplet. Uses ROHF triplet orbitals. rasci-h2o; RASCI/6-31G** H2O Energy Point. cc17; Single point energies of multiple excited states with EOM-CCSD. tu3-h2o-opt; Optimize H2O HF/cc-pVDZ. mrcc2; CCSDT(Q) cc-pVDZ energy for the H2O molecule using MRCC. This example builds up from CCSD. First CCSD, then CCSDT, finally CCSDT(Q). cc21; ROHF-EOM-CCSD/DZ analytic gradient lowest excited state of H2O+ (B1 excitation). opt4; SCF cc-pVTZ geometry optimzation, with Z-matrix input. cc13a; UHF-CCSD(T)/cc-pVDZ CH2 geometry optimization via analytic gradients. mpn-bh; MP(n)/aug-cc-pVDZ BH Energy Point, with n=2-19. Compare against M. L. Leininger et al., J. Chem. Phys. 112, 9213 (2000). pywrap-checkrun-uhf; This checks that all energy methods can run with a minimal input and set symmetry. omp2_5-grad2; OMP2.5 cc-pVDZ gradient for the NO radical. cc38; RHF-CC2-LR/cc-pVDZ static polarizabilities of HOF molecule. mrcc3; CCSD(T) cc-pVDZ geometry optimization for the H2O molecule using MRCC. opt3; SCF cc-pVDZ geometry optimzation, with Z-matrix input. omp2_5-2; OMP2 cc-pVDZ energy for the H2O molecule. cc3; cc3: RHF-CCSD/6-31G** H2O geometry optimization and vibrational frequency analysis by finite-differences of gradi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_testsuite-1.html:15546,energy,energy,15546,psi4manual/4.0b4/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_testsuite-1.html,4,['energy'],['energy']
Energy Efficiency," converged to the expected accuracy. cepa0-grad2; CEPA cc-pVDZ gradient for the NO radical. cc45; RHF-EOM-CC2/cc-pVDZ lowest two states of each symmetry of H2O. fci-tdm-2; BH-H2+ FCI/cc-pVDZ Transition Dipole Moment. psimrcc-ccsd_t-2; Mk-MRCCSD(T) single point. CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. sad1; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. psimrcc-fd-freq1; Mk-MRCCSD single point. O2 state described using the Ms = 0 component of the triplet. Uses ROHF triplet orbitals. rasci-h2o; RASCI/6-31G** H2O Energy Point. cc17; Single point energies of multiple excited states with EOM-CCSD. tu3-h2o-opt; Optimize H2O HF/cc-pVDZ. mrcc2; CCSDT(Q) cc-pVDZ energy for the H2O molecule using MRCC. This example builds up from CCSD. First CCSD, then CCSDT, finally CCSDT(Q). cc21; ROHF-EOM-CCSD/DZ analytic gradient lowest excited state of H2O+ (B1 excitation). opt7; Various constrained energy minimizations of HOOH with cc-pvdz RHF. For the “frozen” bonds, angles and dihedrals, these coordinates are constrained to remain at their initial values. For “fixed” bonds, angles, or dihedrals, the equilibrium (final) value of the coordinate is provided by the user. opt4; SCF cc-pVTZ geometry optimzation, with Z-matrix input. cc13a; UHF-CCSD(T)/cc-pVDZ CH2 geometry optimization via analytic gradients. mpn-bh; MP(n)/aug-cc-pVDZ BH Energy Point, with n=2-19. Compare against M. L. Leininger et al., J. Chem. Phys. 112, 9213 (2000). pywrap-checkrun-uhf; This checks that all energy methods can run with a minimal input and set symmetry. omp2_5-grad2; OMP2.5 cc-pVDZ gradient for the NO radical. cc38; RHF-CC2-LR/cc-pVDZ static polarizabilities of HOF molecule. mrcc3; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodoc_testsuite-1.html:15630,energy,energy,15630,psi4manual/4.0b5/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodoc_testsuite-1.html,4,['energy'],['energy']
Energy Efficiency," convergence becomes, and the calculation may end up; converging onto a higher lying SCF solution. Because of this, in; practice level shifting is most useful in the initial phase of the; calculation to reduce the orbital error enough for DIIS to work; well. The level shift is controlled by the parameter; LEVEL_SHIFT, and it is turned off when the DIIS error is; smaller than LEVEL_SHIFT_CUTOFF. Reasonable values for; the shift and convergence threshold are 5.0 and 1e-2,; respectively. SOSCF [Off by Default]See Second-order Convergence. ERI Algorithms¶; The key difficulty in the SCF procedure is treatment of the four-index ERI; contributions to the Fock Matrix. A number of algorithms are available in; PSI4 for these terms. The algorithm is selected by the SCF_TYPE; keyword, which may be one of the following. PK [Default]An out-of-core, presorted algorithm using exact ERIs. Quite fast for a; zero-error algorithm if enough memory is available. Integrals are; generated only once, and symmetry is utilized to reduce number of; integrals. OUT_OF_COREAn out-of-core, unsorted algorithm using exact ERIs. Overcomes the; memory bottleneck of the current PK algorithm. Integrals are generated; only once, and symmetry is utilized to reduce number of integrals. DIRECTA threaded, sieved, integral-direct algorithm, with full permutational; symmetry. This algorithm is brand new, but seems to be reasonably fast; up to 1500 basis functions, uses zero disk (if DF pre-iterations are; turned off), and can obtain significant; speedups with negligible error loss if INTS_TOLERANCE; is set to 1.0E-8 or so. DF [Default]A density-fitted algorithm designed for computations with thousands of; basis functions. This algorithm is highly optimized, and is threaded; with a mixture of parallel BLAS and OpenMP. Note that this algorithm; should use the -JKFIT series of auxiliary bases, not the -RI or; -MP2FIT bases. The default guess for auxiliary basis set should work; for most bases, otherwise the DF_BAS",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/scf-1.html:24641,reduce,reduce,24641,psi4manual/1.4.0/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/scf-1.html,6,['reduce'],['reduce']
Energy Efficiency," coordinate system. """"""; stationary_point = gradient_rms < stationary_criterion # 1.e-2 pulled out of a hat. mol = core.get_active_molecule(); efp_present = hasattr(mol, 'EFP'). translations_projection_sound = (not core.get_option('SCF', 'EXTERN') and not core.get_option('SCF', 'PERTURB_H'); and not efp_present); rotations_projection_sound = (translations_projection_sound and stationary_point). return translations_projection_sound, rotations_projection_sound. def _filter_renamed_methods(compute, method):; r""""""Raises UpgradeHelper when a method has been renamed.""""""; if method == ""dcft"":; raise UpgradeHelper(compute + ""('dcft')"", compute + ""('dct')"", 1.4,; "" All instances of 'dcft' should be replaced with 'dct'.""). [docs]; def energy(name, **kwargs):; r""""""Function to compute the single-point electronic energy. :returns: *float* |w--w| Total electronic energy in Hartrees. SAPT & EFP return interaction energy. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY`; * :psivar:`CURRENT REFERENCE ENERGY`; * :psivar:`CURRENT CORRELATION ENERGY`. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type write_orbitals: str, :ref:`boolean <op_py_boolean>`; :param write_orbitals: ``filename`` || |dl| ``'on'`` |dr| || ``'off'`` . (str) Save wfn containing current orbitals to the given file name after each SCF iteration; and retain after |PSIfour|",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:3239,energy,energy,3239,psi4manual/1.8.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html,3,['energy'],['energy']
Energy Efficiency," coordinates, converted to Cartesian coordinates. cc33; CC3(UHF)/cc-pVDZ H2O \(R_e\) geom from Olsen et al., JCP 104, 8007 (1996). dct-grad2; RHF-ODC-12 analytic gradient computations for H2O use AO_BASIS=DISK and AO_BASIS=NONE, respectively. RHF-ODC-06 analytic gradient computations for H2O use AO_BASIS=DISK and AO_BASIS=NONE, respectively. lccd-grad1; LCCD cc-pVDZ gradient for the H2O molecule. sapt-exch-ind-inf; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. dct2; DC-06 calculation for the He dimer. This performs a two-step update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the MO Basis. dct3; DC-06 calculation for the He dimer. This performs a simultaneous update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the AO Basis, using integrals stored on disk. dfccsdt1; DF-CCSD(T) cc-pVDZ energy for the H2O molecule. cc16; ROHF and UHF-B-CCD(T)/cc-pVDZ \(^{3}B_1\) CH2 single-point energy (fzc, MO-basis \(\langle ab|cd \rangle\) ). frac-sym; Fractional occupation with symmetry. scf-ecp2; Water-Argon complex with ECP present; check of RHF Hessian. cc8a; ROHF-CCSD(T) cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Cartesian input. scf2; RI-SCF cc-pVTZ energy of water, with Z-matrix input and cc-pVTZ-RI auxilliary basis. pywrap-checkrun-convcrit; Advanced python example sets different sets of scf/post-scf conv crit and check to be sure computation has actually converged to the expected accuracy. dfomp3-grad2; DF-OMP3 cc-pVDZ gradients for the H2O+ cation. mbis-6; MBIS calculation on H2O. omp2-3; OMP2 cc-pVDZ energy for the NO radical. castup1; Test of SAD/Cast-up (mainly not dying due to file weirdness). mp2p5-grad2; MP2.5 cc-pVDZ gradient for the NO radical. cbs-xtpl-gradient; Various gradients for a strained helium dimer and water molecule. psithon1; Spectroscopic constants of H2, and the full ci cc-pVTZ level of theory. cdo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html:40143,energy,energy,40143,psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency," coordinates, converted to Cartesian coordinates. dfmp2-grad1; DF-MP2 cc-pVDZ gradients for the H2O molecule. pywrap-cbs1; Various basis set extrapolation tests. dfmp2-ecp; Ne-Xe dimer MP2 energies with ECP, with electrons correlated then frozen. scf3; File retention, docc, socc, and bond distances specified explicitly. mbis-2; MBIS calculation on OH- (Expanded Arrays). opt13; B3LYP cc-pVDZ geometry optimzation of phenylacetylene, starting from not quite linear structure updated reference due to new BraggSlater radii. cisd-h2o-clpse; 6-31G** H2O Test CISD Energy Point with subspace collapse. mbis-3; MBIS calculation on OH radical. props1; RHF STO-3G dipole moment computation, performed by applying a finite electric field and numerical differentiation. fnocc4; Test FNO-DF-CCSD(T) energy. cc42; RHF-CC2-LR/STO-3G optical rotation of (S)-methyloxirane. gauge = length, omega = (589 355 nm). cbs-xtpl-energy; Extrapolated water energies. cc8; UHF-CCSD(T) cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Z-matrix input. dft-dsd; DSD S22 Ammonia test. fsapt2; A very quick correctness test of F-SAPT (see fsapt1 for a real example). dft-dens-cut; LibXC density screening test. Tests empty, C-only, X-only and XC superfunctionals. ‘super_mix’ showcases how to use different screening values for X and C parts. SCF will fail or crash (nans) without screening!. casscf-fzc-sp; CASSCF/6-31G** energy point. isapt1; This test case shows an example of running and analyzing an FI-SAPT0/jun-cc-pvdz computation for 2,4-pentanediol (targeting the intramolecular hydrogen bond between the two hydroxyl groups). pywrap-align-chiral; testing aligner on enantiomers based on Table 1 of 10.1021/ci100219f aka J Chem Inf Model 2010 50(12) 2129-2140. cisd-sp; 6-31G** H2O Test CISD Energy Point. dft-grad-lr2; Tests CAM gradients with and without XC pieces to narrow grid error. dfccsd1; DF-CCSD cc-pVDZ energy for the H2O molecule. adc1; ADC(2)/6-31G** on H2O using builtin ADC ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html:8610,energy,energy,8610,psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency," core memory is given. Possible choices are INTEGERWORDS (default), kB, MB, GB, and TB. Psi4 Interface: Keyword set from memory input command when given, always MB. Type: string; Possible Values: INTEGERWORDS, KB, MB, GB, TB; Default: INTEGERWORDS. CFOUR_MEMORY_SIZE (CFOUR)¶CFOUR — Specifies the amount of core memory used in integer words (default) or in the units specified via the keyword CFOUR_MEM_UNIT. Default: 100 000 000 (approximately 381 or 762 MB for 32 or 64 bit machines, respectively). Psi4 Interface: Keyword set in MB from memory input command when given. Type: integer; Default: 100000000. CFOUR_METHOD (CFOUR)¶CFOUR — Specifies the geometry optimization strategy. Four values are permitted: NR (=0) – Straightforward Newton-Raphson search for minimum; RFA (=1) – Rational Function Approximation search for minimum (this method can be used to find minima when the initial structure is in a region where the Hessian index is nonzero); TS (=2) Cerjan-Miller eigenvector following search for a transition state (can be started in a region where the Hessian index is not equal to unity); MANR (=3) – Morse-adjusted Newton-Raphson search for minimum (very efficient minimization scheme, particularly if the Hessian is available); 4 is currently unavailable; SINGLE_POINT (=5) is a single point calculation. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) use PSI’s optimizer and so this keyword has no effect. Use optking keywords instead, particularly OPT_TYPE and STEP_TYPE. Type: string; Possible Values: NR, RFA, TS, MANR, SINGLE_POINT; Default: SINGLE_POINT. CFOUR_MRCC (CFOUR)¶CFOUR — Specifies the type of MRCC calculation. MK performs a MR-CC calculation based on Mukherjee’s ansatz. Type: boolean; Default: false. CFOUR_MULTIPLICITY (CFOUR)¶CFOUR — Specifies the spin multiplicity. Psi4 Interface: Keyword set from active molecule. Type: integer; Default: 1. CFOUR_NACOUPLING (CFOUR)¶CFOUR — Calculation of non-adiabatic coupling. In case of ON (",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:56542,efficient,efficient,56542,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,9,['efficient'],['efficient']
Energy Efficiency," core.clean(); raise ValueError('Hit a wall in proc.py:1599'). core.set_local_option('CCLAMBDA', 'ZETA', 'FALSE'); core.set_local_option('CCDENSITY', 'ZETA', 'FALSE'); core.set_local_option('CCDENSITY', 'XI', 'TRUE'); core.cclambda(ref_wfn); core.ccdensity(ref_wfn); core.set_local_option('CCLAMBDA', 'ZETA', 'TRUE'); core.set_local_option('CCDENSITY', 'ZETA', 'TRUE'); core.set_local_option('CCDENSITY', 'XI', 'FALSE'); core.cclambda(ref_wfn); core.ccdensity(ref_wfn). derivobj = core.Deriv(ref_wfn); grad = derivobj.compute(). ref_wfn.set_gradient(grad). optstash.restore(); return ref_wfn. def run_adc_deprecated(*args, **kwargs):; warnings.warn(""The method 'adc' has been deprecated, please use 'adc2' instead.""; ""The method key 'adc' will be removed Psi4 1.6."", DeprecationWarning); return select_adc2(*args, **kwargs). def run_adc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an algebraic diagrammatic construction calculation. .. caution:: Get rid of active molecule lines- should be handled in energy. """"""; if core.get_option('ADC', 'REFERENCE') != 'RHF':; raise ValidationError('ADC requires reference RHF'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). return core.adc(ref_wfn). def run_adcc(name, **kwargs):; """"""Prepare and run an ADC calculation in adcc, interpret the result and return; as a wavefunction. """"""; # TODO Maybe it would improve readability if this function was spilt; # up and the whole thing went to a separate file (like for sapt,; # interface_cfour.py, ... try:; import adcc; from adcc.backends import InvalidReference; except ModuleNotFoundError:; raise ValidationError(""adcc extras qc_module not available. Try installing ""; ""via 'pip install adcc' or 'conda install -c adcc adcc'.""). if core.get_option('A",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:109971,energy,energy,109971,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,2,['energy'],['energy']
Energy Efficiency," core.clean(); raise ValueError('Hit a wall in proc.py:1599'). core.set_local_option('CCLAMBDA', 'ZETA', 'FALSE'); core.set_local_option('CCDENSITY', 'ZETA', 'FALSE'); core.set_local_option('CCDENSITY', 'XI', 'TRUE'); core.cclambda(ref_wfn); core.ccdensity(ref_wfn); core.set_local_option('CCLAMBDA', 'ZETA', 'TRUE'); core.set_local_option('CCDENSITY', 'ZETA', 'TRUE'); core.set_local_option('CCDENSITY', 'XI', 'FALSE'); core.cclambda(ref_wfn); core.ccdensity(ref_wfn). derivobj = core.Deriv(ref_wfn); grad = derivobj.compute(). ref_wfn.set_gradient(grad). optstash.restore(); return ref_wfn. def run_adc_deprecated(*args, **kwargs):; warnings.warn(""The method 'adc' has been deprecated, please use 'adc2' instead.""; ""The method key 'adc' will be removed Psi4 1.6."", DeprecationWarning); return select_adc2(*args, **kwargs). def run_adc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an algebraic diagrammatic construction calculation. .. caution:: Get rid of active molecule lines- should be handled in energy. """"""; if core.get_option('ADC', 'REFERENCE') != 'RHF':; raise ValidationError('ADC requires reference RHF'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). warnings.warn(""Using built-in `adc` module instead of add-on `adcc` interface is deprecated due ""; ""to certain wrong results, and as soon as 1.7, it will stop working."", category=FutureWarning). error_msg = (""\n\t\t\t\t!!!!! WARNING !!!!!\n"" +; ""\t\tThe built-in ADC(2) method may give incorrect results if\n""; ""\t\tmultiple roots are requested, due to an error in the Davidson solver,\n""; ""\t\tand is no longer maintained. It is slated for removal in Psi4 1.7.\n""; ""\t\tUse of the Psi interface to `adcc` instead is strongly recommended.\n""). core.print_out(error_msg). wfn",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:111645,energy,energy,111645,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,1,['energy'],['energy']
Energy Efficiency," core.get_active_molecule(); molecule.update_geometry(); natoms = molecule.natom(); if natoms != 2:; raise Exception(""The current molecule must be a diatomic for this code to work!""); m1 = molecule.mass(0); m2 = molecule.mass(1). # Optimize the geometry, refitting the surface around each new geometry; core.print_out(""\nOptimizing geometry based on current surface:\n\n"");; re = np.mean(rvals); maxit = 30; thres = 1.0e-9; for i in range(maxit):; derivs = least_squares_fit_polynomial(rvals,energies,localization_point=re); e,g,H = derivs[0:3]; core.print_out("" E = %20.14f, x = %14.7f, grad = %20.14f\n"" % (e, re, g)); if abs(g) < thres:; break; re -= g/H;; if i == maxit-1:; raise ConvergenceError(""diatomic geometry optimization"", maxit); core.print_out("" Final E = %20.14f, x = %14.7f, grad = %20.14f\n"" % (e, re, g));; if re < min(rvals):; raise Exception(""Minimum energy point is outside range of points provided. Use a lower range of r values.""); if re > max(rvals):; raise Exception(""Minimum energy point is outside range of points provided. Use a higher range of r values.""). # Convert to convenient units, and compute spectroscopic constants; d0,d1,d2,d3,d4 = derivs*constants.hartree2aJ; core.print_out(""\nEquilibrium Energy %20.14f Hartrees\n"" % e); core.print_out(""Gradient %20.14f\n"" % g); core.print_out(""Quadratic Force Constant %14.7f MDYNE/A\n"" % d2); core.print_out(""Cubic Force Constant %14.7f MDYNE/A**2\n"" % d3); core.print_out(""Quartic Force Constant %14.7f MDYNE/A**3\n"" % d4). hbar = constants.h / (2.0 * np.pi); mu = ((m1*m2)/(m1+m2))*constants.amu2kg; we = 5.3088375e-11 * np.sqrt(d2/mu); wexe = (1.2415491e-6)*(we/d2)**2 * ((5.0*d3*d3)/(3.0*d2)-d4). # Rotational constant: Be; I = ((m1*m2)/(m1+m2)) * constants.amu2kg * (re * angstrom_to_meter)**2; B = constants.h / (8.0 * np.pi**2 * constants.c * I). # alpha_e and quartic centrifugal distortion constant; ae = -(6.0 * B**2 / we) * ((1.05052209e-3*we*d3)/(np.sqrt(B * d2**3))+1.0); de = 4.0*B**3 / we**2. # B0 and r0 (pl",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/diatomic.html:5139,energy,energy,5139,psi4manual/1.3.2/_modules/psi4/driver/diatomic.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/diatomic.html,2,['energy'],['energy']
Energy Efficiency," core.get_active_molecule(); molecule.update_geometry(); natoms = molecule.natom(); if natoms != 2:; raise Exception(""The current molecule must be a diatomic for this code to work!""); m1 = molecule.mass(0); m2 = molecule.mass(1). # Optimize the geometry, refitting the surface around each new geometry; core.print_out(""\nOptimizing geometry based on current surface:\n\n"");; re = np.mean(rvals); maxit = 30; thres = 1.0e-9; for i in range(maxit):; derivs = least_squares_fit_polynomial(rvals,energies,localization_point=re); e,g,H = derivs[0:3]; core.print_out("" E = %20.14f, x = %14.7f, grad = %20.14f\n"" % (e, re, g)); if abs(g) < thres:; break; re -= g/H;; if i == maxit-1:; raise ConvergenceError(""diatomic geometry optimization"", maxit); core.print_out("" Final E = %20.14f, x = %14.7f, grad = %20.14f\n"" % (e, re, g));; if re < min(rvals):; raise Exception(""Minimum energy point is outside range of points provided. Use a lower range of r values.""); if re > max(rvals):; raise Exception(""Minimum energy point is outside range of points provided. Use a higher range of r values.""). # Convert to convenient units, and compute spectroscopic constants; d0,d1,d2,d3,d4 = derivs*constants.hartree2aJ; core.print_out(""\nEquilibrium Energy %20.14f Hartrees\n"" % e); core.print_out(""Gradient %20.14f\n"" % g); core.print_out(""Quadratic Force Constant %14.7f MDYNE/A\n"" % d2); core.print_out(""Cubic Force Constant %14.7f MDYNE/A**2\n"" % d3); core.print_out(""Quartic Force Constant %14.7f MDYNE/A**3\n"" % d4). hbar = constants.h / (2.0 * pi); mu = ((m1*m2)/(m1+m2))*constants.amu2kg; we = 5.3088375e-11*sqrt(d2/mu); wexe = (1.2415491e-6)*(we/d2)**2 * ((5.0*d3*d3)/(3.0*d2)-d4). # Rotational constant: Be; I = ((m1*m2)/(m1+m2)) * constants.amu2kg * (re * angstrom_to_meter)**2; B = constants.h / (8.0 * pi**2 * constants.c * I). # alpha_e and quartic centrifugal distortion constant; ae = -(6.0 * B**2 / we) * ((1.05052209e-3*we*d3)/(sqrt(B * d2**3))+1.0); de = 4.0*B**3 / we**2. # B0 and r0 (plus re check us",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/diatomic.html:5204,energy,energy,5204,psi4manual/1.1.0/_modules/psi4/driver/diatomic.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/diatomic.html,1,['energy'],['energy']
Energy Efficiency," corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> energy(cbs, corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> energy(cbs, corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> energy(cbs, corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> energy(cbs, corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] a Q5-zeta MP2 calculation, corrected by CCSD(T) at the TQ-zeta extrapolated level, and all-electron CCSD(T) correlation at T-zeta level; >>> energy(cbs, cbs_metadata=[{""wfn"": ""hf"", ""basis"": ""cc-pv5z""}, {""wfn"": ""mp2"", ""basis"": ""cc-pv[q5]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pv[tq]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pvtz"", ""options"": {""freeze_core"": ""False""}}]). >>> # [8] cbs() coupled with database(); >>> TODO database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='sto-3g'). >>> # [9] cbs() coupled with optimize(); >>> TODO optimize('mp2', corl_basis='cc-pV[DT]Z', corl_scheme=corl_xtpl_helgaker_2, func=cbs). """"""; kwargs = p4util.kwargs_lower(kwargs); metadata = _proc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html:44956,energy,energy,44956,psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,6,['energy'],['energy']
Energy Efficiency," corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> energy(cbs, corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> energy(cbs, corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> energy(cbs, corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> energy(cbs, corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] a Q5-zeta MP2 calculation, corrected by CCSD(T) at the TQ-zeta extrapolated level, and all-electron CCSD(T) correlation at T-zeta level; >>> energy(cbs, cbs_metadata=[{""wfn"": ""hf"", ""basis"": ""cc-pv5z""}, {""wfn"": ""mp2"", ""basis"": ""cc-pv[q5]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pv[tq]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pvtz"", ""options"": {""freeze_core"": ""False""}}]). >>> # [8] cbs() coupled with database(); >>> TODO database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='sto-3g'). >>> # [9] cbs() coupled with optimize(); >>> TODO optimize('mp2', corl_basis='cc-pV[DT]Z', corl_scheme=corl_xtpl_helgaker_2, func=cbs). Note; As of October 2018, only two explicit `deltaN_[wfn,ba",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/cbs-1.html:9170,energy,energy,9170,psi4manual/1.3.2/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/cbs-1.html,12,['energy'],['energy']
Energy Efficiency," corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> energy(cbs, corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> energy(cbs, corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> energy(cbs, corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> energy(cbs, corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] a Q5-zeta MP2 calculation, corrected by CCSD(T) at the TQ-zeta extrapolated level, and all-electron CCSD(T) correlation at T-zeta level; >>> energy(cbs, cbs_metadata=[{""wfn"": ""hf"", ""basis"": ""cc-pv5z""}, {""wfn"": ""mp2"", ""basis"": ""cc-pv[q5]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pv[tq]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pvtz"", ""options"": {""freeze_core"": ""False""}}]). >>> # [8] cbs() coupled with database(); >>> TODO database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='sto-3g'). >>> # [9] cbs() coupled with optimize(); >>> TODO optimize('mp2', corl_basis='cc-pV[DT]Z', corl_scheme=corl_xtpl_helgaker_2, func=cbs). «; hide menu. menu; sidebar; »; . Navigation. Index. module",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.driver.cbs-1.html:10734,energy,energy,10734,psi4manual/1.3.2/api/psi4.driver.cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.driver.cbs-1.html,12,['energy'],['energy']
Energy Efficiency," corl_wfn: str; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: str; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: str; :param delta_wfn_lesser: |dl| ``corl_wfn`` |dr| || ``'mp2'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: str; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: str; :param delta2_wfn_lesser: |dl| ``delta_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set set through ``set`` commands have no influence; on a cbs calculation. :type scf_basis: :ref:`basis string <apdx:basisElement>`; :param scf_basis: |dl| ``corl_basis`` |dr| || ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, ``scf_basis`` can default; to ``corl_basis``. :type corl_basis: :ref:`basis string <apdx:basisElement>`; :param corl_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the correlation energy. :type delta_basis: :ref:`basis string <apdx:basisElement>`; :param delta_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. :type delta2_basis: :ref:`basis string ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html:37413,energy,energy,37413,psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,16,['energy'],['energy']
Energy Efficiency," correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] cbs() coupled with database(); >>> database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='sto-3g'). Output¶; At the beginning of a cbs() job is printed a listing of the individual; energy calculations which will be performed. The output snippet below is; from the example job [2] above. It shows first each model chemistry needed; to compute the aggregate model chemistry requested through cbs(). Then,; since, for example, an energy('ccsd(t)') yields CCSD(T), CCSD, MP2,; and SCF energy values, the wrapper condenses this task list into the second; list of minimum number of calculations which will actually be run.; Naive listing of computations required.; scf / aug-cc-pvqz for SCF TOTAL ENERGY; mp2 / aug-cc-pvtz for MP2 CORRELATION ENERGY; mp2 / aug-cc-pvqz for MP2 CORRELATION ENERGY; ccsd(t) / aug-cc-pvdz for CCSD(T) CORRELATION ENERGY; ccsd(t) / aug-cc-pvtz for CCSD(T) CORRELATION ENERGY; mp2 / aug-cc-pvdz for MP2 CORRELATION ENERGY; mp2 / aug-cc-pvtz for MP2 CORRELATION ENERGY. Enlightened listing of computations required.; mp2 / aug-cc-pvqz for MP2 CORRELATION ENERGY; ccsd(t) / aug-cc-pvdz for CCSD(T) CORRELATION ENERGY; ccsd(t) / aug-cc-pvtz for CCSD(T) CORRELATION ENERGY. At the end of a cbs() job is printed a summary section like the one below. First,; in the components section, are listed the results for each model chemistry available, whether; required for the cbs job (*) or not. Next, in the stages section, are listed the results for; each extrapolation. The energies of this s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/cbs-1.html:7624,energy,energy,7624,psi4manual/4.0b2/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/cbs-1.html,8,['energy'],['energy']
Energy Efficiency," correction that perturbatively accounts; for three-particle correlation effects, similarly to the (T) correction in coupled; cluster theory. Computation of the correction can be; requested by setting the THREE_PARTICLE option to PERTURBATIVE. A; combination of the ODC-13 functional with the correction; [denoted as ] has been shown to provide highly; accurate results for open-shell molecules near equilibrium geometries.; At the present moment, all of the DCFT methods support unrestricted reference; orbitals (REFERENCE = UHF), which can be used to perform energy and; gradient computations for both closed- and open-shell molecules. In addition,; the ODC-06 and ODC-12 methods support restricted reference orbitals; (REFERENCE = RHF) for the energy and gradient computations of; closed-shell molecules. Note that in this case restricted reference orbitals; are only available for ALGORITHM = SIMULTANEOUS. Iterative Algorithms¶; As explained in the Theory section, in order to obtain the DCFT energy one; needs to solve a system of coupled equations for orbitals and density; cumulant. At the present moment three iterative algorithms for the solution of the; equations are available. The choice of the algorithm is controlled using the; ALGORITHM option.; 1) Simultaneous algorithm (ALGORITHM = SIMULTANEOUS, currently the default).; In this algorithm the DCFT equations are solved in macroiterations.; Each macroiteration consists of a single iteration of the cumulant update; followed by a single iteration of the orbital update and orbital transformation; of the integrals. The macroiterations are repeated until the simultaneous; convergence of the cumulant and orbitals is achieved.; Convergence of the simultaneous algorithm is accelerated using the; DIIS extrapolation technique.; 2) Two-step algorithm (can be invoked by setting the ALGORITHM option to; TWOSTEP). In the two-step algorithm each macroiteration consists of two sets of; microiterations. In the first set, the density cumu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/dcft-1.html:7247,energy,energy,7247,psi4manual/1.0.0/dcft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/dcft-1.html,2,['energy'],['energy']
Energy Efficiency," correction; to the correlation energy. :type delta2_basis: :ref:`basis string <apdx:basisElement>`; :param delta2_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. :type delta3_basis: :ref:`basis string <apdx:basisElement>`; :param delta3_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the third delta correction; to the correlation energy. :type delta4_basis: :ref:`basis string <apdx:basisElement>`; :param delta4_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the fourth delta correction; to the correlation energy. :type delta5_basis: :ref:`basis string <apdx:basisElement>`; :param delta5_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the fifth delta correction; to the correlation energy. * Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, ``'highest_1'``, which uses the best basis; set available. See `Extrapolation Schemes`_ for all available schemes. :type scf_scheme: function; :param scf_scheme: |dl| ``highest_1`` |dr| || ``scf_xtpl_helgaker_3`` || etc. Indicates the basis set extrapolation scheme to be applied to the reference energy. :type corl_scheme: function; :param corl_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the correlation energy. :type delta_scheme: function; :param delta_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the delta co",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:59760,energy,energy,59760,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,1,['energy'],['energy']
Energy Efficiency," correction; to the correlation energy. :type delta2_basis: :ref:`basis string <apdx:basisElement>`; :param delta2_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. :type delta3_basis: :ref:`basis string <apdx:basisElement>`; :param delta3_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the third delta correction; to the correlation energy. :type delta4_basis: :ref:`basis string <apdx:basisElement>`; :param delta4_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the fourth delta correction; to the correlation energy. :type delta5_basis: :ref:`basis string <apdx:basisElement>`; :param delta5_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the fifth delta correction; to the correlation energy. * Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, ``'xtpl_highest_1'``, which uses the best basis; set available. See :ref:`sec:cbs_xtpl` for all available schemes. :type scf_scheme: function; :param scf_scheme: |dl| ``xtpl_highest_1`` |dr| || ``scf_xtpl_helgaker_3`` || etc. Indicates the basis set extrapolation scheme to be applied to the reference energy.; Defaults to :py:func:`~scf_xtpl_helgaker_3` if three valid basis sets; present in ``scf_basis``, :py:func:`~scf_xtpl_helgaker_2` if two valid basis; sets present in ``scf_basis``, and :py:func:`~xtpl_highest_1` otherwise. .. hlist::; :columns: 1. * xtpl_highest_1; * scf_xtpl_helgaker_3; * scf_xtpl_helgaker_2; * scf_xtpl_truhlar_2; * scf_xtpl_karton_2. :type corl_scheme: f",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html:31462,energy,energy,31462,psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html,1,['energy'],['energy']
Energy Efficiency," correction; to the correlation energy. :type delta2_basis: :ref:`basis string <apdx:basisElement>`; :param delta2_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. :type delta3_basis: :ref:`basis string <apdx:basisElement>`; :param delta3_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the third delta correction; to the correlation energy. :type delta4_basis: :ref:`basis string <apdx:basisElement>`; :param delta4_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the fourth delta correction; to the correlation energy. :type delta5_basis: :ref:`basis string <apdx:basisElement>`; :param delta5_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the fifth delta correction; to the correlation energy. * Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, ``'xtpl_highest_1'``, which uses the best basis; set available. See :ref:`sec:cbs_xtpl` for all available schemes. :type scf_scheme: function; :param scf_scheme: |dl| ``xtpl_highest_1`` |dr| || ``scf_xtpl_helgaker_3`` || etc. Indicates the basis set extrapolation scheme to be applied to the reference energy.; Defaults to :py:func:`~scf_xtpl_helgaker_3` if three valid basis sets; present in ``scf_basis``, :py:func:`~scf_xtpl_helgaker_2` if two valid basis; sets present in ``scf_basis``, and :py:func:`~xtpl_highest_1` otherwise. :type corl_scheme: function; :param corl_scheme: |dl| ``xtpl_highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver_cbs.html:25068,energy,energy,25068,psi4manual/1.1.0/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver_cbs.html,1,['energy'],['energy']
Energy Efficiency," correction; to the correlation energy. :type delta2_basis: :ref:`basis string <apdx:basisElement>`; :param delta2_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. :type delta3_basis: :ref:`basis string <apdx:basisElement>`; :param delta3_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the third delta correction; to the correlation energy. :type delta4_basis: :ref:`basis string <apdx:basisElement>`; :param delta4_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the fourth delta correction; to the correlation energy. :type delta5_basis: :ref:`basis string <apdx:basisElement>`; :param delta5_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the fifth delta correction; to the correlation energy. * Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, ``'xtpl_highest_1'``, which uses the best basis; set available. See `Extrapolation Schemes`_ for all available schemes. :type scf_scheme: function; :param scf_scheme: |dl| ``xtpl_highest_1`` |dr| || ``scf_xtpl_helgaker_3`` || etc. Indicates the basis set extrapolation scheme to be applied to the reference energy.; Defaults to :py:func:`~scf_xtpl_helgaker_3` if three valid basis sets; present in ``scf_basis``, :py:func:`~scf_xtpl_helgaker_2` if two valid basis; sets present in ``scf_basis``, and :py:func:`~xtpl_highest_1` otherwise. :type corl_scheme: function; :param corl_scheme: |dl| ``xtpl_highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapola",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:24710,energy,energy,24710,psi4manual/1.0.0/_modules/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html,1,['energy'],['energy']
Energy Efficiency," correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta_basis and xtpl_highest_1() otherwise. delta2_scheme (function) – \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the second delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta2_basis and xtpl_highest_1() otherwise. delta3_scheme (function) – \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the third delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta3_basis and xtpl_highest_1() otherwise. delta4_scheme (function) – \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the fourth delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta4_basis and xtpl_highest_1() otherwise. delta5_scheme (function) – \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the fifth delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta5_basis and xtpl_highest_1() otherwise. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples:. 1; 2>>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> cbs(name='scf', scf_basis='cc-pVDZ'). 1; 2>>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> cbs(name='mp2', corl_basis='jun-cc-pVDZ'). 1; 2>>> # [3] DTQ-zeta extrapolated scf reference energy; >>> cbs(n",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/cbs-1.html:9757,energy,energy,9757,psi4manual/1.1.0/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/cbs-1.html,3,['energy'],['energy']
Energy Efficiency," corrections and symmetry adapted; perturbation theory methods. These require the definition of which fragments; are interacting within the complex. PSI4 provides a very simple mechanism; for doing so: simply define the complex’s geometry using the standard; Cartesian, Z-matrix, or mixture thereof, specifications and then place two; dashes between nonbonded fragments. For example, to study the interaction; energy of ethane and ethyne molecules, we can use the following molecule; block:; molecule eneyne {; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; }. This specifies that there are two neutral, spin-singlet fragments. It is; possible to further specify that the overall complex is neutral and spin-singlet; by inserting another charge multiplicity line, separated from the first; molecule block by a – line. If any information is missing, PSI4 will set the; unprovided charges and multiplicities to be consistent with those that are given.; For example, the overall charge must be simply the sum of all fragment charges.; PSI4 further assumes that any unpaired electrons are coupled to yield the highest; possible \(M_s\) value. Psi will also favor neutral, spin-singlet fragments.; For anything complicated, we strongly suggest explicitly providing the charge; and multiplicity of each fragment as well as the total molecular charge and multiplicity. For details and examples, see https://github.com/MolSSI/QCElemental/blob/master/qcelemental/molparse/chgmult.py#L105-L136 .; Having defined a molecule containing fragments like eneyne above, it; is a simple matter to perform calculations on only a subset of the; fragments. For instance, the commands below run a scf first on the ethene; fragment alone (extrac",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/psithonmol.html:15178,charge,charge,15178,psi4manual/1.8.x/psithonmol.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/psithonmol.html,3,['charge'],['charge']
Energy Efficiency," correctly update ref_dft_2e/xc due to new BraggSlater radii. pywrap-align; apply linear fragmentation algorithm to a water cluster. scf-hess2; UHF STO-3G (Cartesian) and cc-pVDZ (spherical) water Hessian test, against Psi3 reference values. This test should match RHF values exactly. cc13c; Tests RHF CCSD(T)gradients. dct-grad3; Restricted DF-DCT ODC-12 gradient for ethylene with cc-pVDZ/cc-pVDZ-RI standard/auxiliary basis set. fnocc1; Test QCISD(T) for H2O/cc-pvdz Energy. sapt3; SAPT2+3(CCD) aug-cc-pVDZ+midbond computation of the water dimer interaction energy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. cc8; UHF-CCSD(T) cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Z-matrix input. fci-tdm; He2+ FCI/cc-pVDZ Transition Dipole Moment. dfmp2-grad4; DF-MP2 cc-pVDZ gradient for the NO molecule. cc9; UHF-CCSD(T) cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Z-matrix input. casscf-fzc-sp; CASSCF/6-31G** energy point. opt10; 6-31G MP2 transition-state optimization with initial, computed Hessian. fnocc6; Test method/basis with disk_df. pywrap-checkrun-uhf; This checks that all energy methods can run with a minimal input and set symmetry. scf11-freq-from-energies; Test frequencies by finite differences of energies for planar C4NH4 TS. sapt0-d; Tests SAPT0-D corrections, with a variety of damping functions/parameters. dct7; DCT calculation for the triplet O2 using ODC-06 and ODC-12 functionals. Only simultaneous algorithm is tested. cc32; CC3/cc-pVDZ H2O \(R_e\) geom from Olsen et al., JCP 104, 8007 (1996). cc15; RHF-B-CCD(T)/6-31G** H2O single-point energy (fzc, MO-basis \(\langle ab|cd \rangle\)). fci-h2o-2; 6-31G H2O Test FCI Energy Point. dct10; The multiple guesses for DCT amplitudes for ODC-12. mints-benchmark; run some BLAS benchmarks. cepa2; cc-pvdz H2O Test ACPF Energy/Properties. cc45; RHF-EOM-CC2/cc-pVDZ lowest two states of each symmetry of H2O. mints4; A demonstratio",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html:20574,energy,energy,20574,psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency," cost tradeoff is rough here. omp2-grad1; OMP2 cc-pVDZ gradient for the H2O molecule. dfomp2-3; OMP2 cc-pVDZ energy for the H2O molecule. dfcasscf-sa-sp; Example of state-averaged CASSCF for the C2 molecule. dfmp2-fc; Kr–Kr nocp energies with all-electron basis set to check frozen core. dft-grad-lr3; wB97X-D test for a large UKS molecule update ref gradient due to new BraggSlater radii. fcidump; test FCIDUMP functionality for rhf/uhf. dfomp2p5-2; DF-OMP2.5 cc-pVDZ energy for the H2O+ cation. sapt4; SAPT2+(3) aug-cc-pVDZ computation of the formamide dimer interaction energy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. This example uses frozen core as well as MP2 natural orbital approximations. omp3-3; OMP3 cc-pCVDZ energy with B3LYP initial guess for the NO radical. olccd2; OLCCD cc-pVDZ energy with B3LYP initial guess for the NO radical. nbody-convergence; Convergence of many-body gradients of different BSSE schemes. sapt-dft-api; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. cc46; EOM-CC2/cc-pVDZ on H2O2 with two excited states in each irrep. pubchem1; Benzene vertical singlet-triplet energy difference computation, using the PubChem database to obtain the initial geometry, which is optimized at the HF/STO-3G level, before computing single point energies at the RHF, UHF and ROHF levels of theory. cc13a; UHF-CCSD(T)/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. sad1; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. dfomp3-2; DF-OMP3 cc-pVDZ energy for the H2O+ cation. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Appendices; Test Suite and Sample Inputs. © Copyright",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/testsuite.html:47231,energy,energy,47231,psi4manual/1.7.x/testsuite.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/testsuite.html,1,['energy'],['energy']
Energy Efficiency," cost tradeoff is rough here. omp2-grad1; OMP2 cc-pVDZ gradient for the H2O molecule. dfomp2-3; OMP2 cc-pVDZ energy for the H2O molecule. dfcasscf-sa-sp; Example of state-averaged CASSCF for the C2 molecule. dfmp2-fc; Kr–Kr nocp energies with all-electron basis set to check frozen core. dft-grad-lr3; wB97X-D test for a large UKS molecule update ref gradient due to new BraggSlater radii. fcidump; test FCIDUMP functionality for rhf/uhf. dfomp2p5-2; DF-OMP2.5 cc-pVDZ energy for the H2O+ cation. sapt4; SAPT2+(3) aug-cc-pVDZ computation of the formamide dimer interaction energy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. This example uses frozen core as well as MP2 natural orbital approximations. omp3-3; OMP3 cc-pCVDZ energy with B3LYP initial guess for the NO radical. olccd2; OLCCD cc-pVDZ energy with B3LYP initial guess for the NO radical. nbody-convergence; Convergence of many-body gradients of different BSSE schemes. sapt-dft-api; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. cc46; EOM-CC2/cc-pVDZ on H2O2 with two excited states in each irrep. pubchem1; Benzene vertical singlet-triplet energy difference computation, using the PubChem database to obtain the initial geometry, which is optimized at the HF/STO-3G level, before computing single point energies at the RHF, UHF and ROHF levels of theory. cc13a; UHF-CCSD(T)/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. sad1; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. dfomp3-2; DF-OMP3 cc-pVDZ energy for the H2O+ cation. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Appendices; Test Suite and Sample Inputs; <no title>.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html:46509,energy,energy,46509,psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,1,['energy'],['energy']
Energy Efficiency," could conceivably eliminate the entire H0 block; the program should print warnings if this occurs. Type: integer; Default: 1000. H0_GUESS_SIZE (DETCI); DETCI (Expert) — size of H0 block for initial guess. Type: integer; Default: 1000. H_BOND_CONNECT (OPTKING); OPTKING — For now, this is a general maximum distance for the definition of H-bonds. Type: double; Default: 4.3. H_GUESS_EVERY (OPTKING); OPTKING — Re-estimate the Hessian at every step, i.e., ignore the currently stored Hessian. Type: boolean; Default: false. H_UPDATE_DEN_TOL (OPTKING); OPTKING — Denominator check for hessian update. Type: conv double; Default: 1e-7. HD_AVG (DETCI); DETCI (Expert) — How to average H diag energies over spin coupling sets. HD_EXACT uses the exact diagonal energies which results in expansion vectors which break spin symmetry. HD_KAVE averages the diagonal energies over a spin-coupling set yielding spin pure expansion vectors. ORB_ENER employs the sum of orbital energy approximation giving spin pure expansion vectors but usually doubles the number of Davidson iterations. EVANGELISTI uses the sums and differences of orbital energies with the SCF reference energy to produce spin pure expansion vectors. LEININGER approximation which subtracts the one-electron contribution from the orbital energies, multiplies by 0.5, and adds the one-electron contribution back in, producing spin pure expansion vectors and developed by Matt Leininger and works as well as EVANGELISTI. Type: string; Possible Values: EVANGELISTI, HD_EXACT, HD_KAVE, ORB_ENER, LEININGER, Z_KAVE; Default: EVANGELISTI. HD_OTF (DETCI); DETCI (Expert) — Do compute the diagonal elements of the Hamiltonian matrix on-the-fly? Otherwise, a diagonal element vector is written to a separate file on disk. Type: boolean; Default: true. HEFF4 (PSIMRCC); PSIMRCC — Do include the fourth-order contributions to the effective Hamiltonian?. Type: boolean; Default: true. HEFF_PRINT (PSIMRCC); PSIMRCC — Do print the effective Hamiltonian?. Typ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:136672,energy,energy,136672,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,8,['energy'],['energy']
Energy Efficiency," counterpoise corrections and symmetry adapted; perturbation theory methods. These require the definition of which fragments; are interacting within the complex. PSI4 provides a very simple mechanism; for doing so; simply define the complex’s geometry using the standard; Cartesian, Z-matrix, or mixture thereof, specifications and then place two; dashes between nonbonded fragements. For example, to study the interaction; energy of ethane and ethyne molecules, we can use the following molecule; block:; molecule{; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; }. In this case, the charge and multiplicity of each interacting fragment is; explicitly specified. If the charge and multiplicity are specified for the; first fragment, it is assumed to be the same for all fragments. When; considering interacting fragments, the overall charge is simply the sum of all; fragment charges, and any unpaired electrons are assumed to be coupled to; yield the highest possible value. Job Control¶; PSI4 comprises a number of modules, written in C++, that each perform; specific tasks and are callable directly from the Python front end. Each module; recognizes specific keywords in the input file, detailed in Appendix Keywords by Module, which; control its function. The keywords can be made global, or scoped to apply to; certain specific modules. The following examples demonstrate some of the ways; that global keywords can be specified:; set globals basis cc-pVDZ. or. set basis cc-pVDZ. or. set globals basis = cc-pVDZ. or. set basis = cc-pVDZ. or. set globals{; basis cc-pVDZ; }. or. set {; basis cc-pVDZ; }. or. set {; basis = cc-pVDZ; }. Note the lack of quotes around cc-pVDZ, even though it is a string. The; Psithon p",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/psithoninput-1.html:14586,charge,charge,14586,psi4manual/4.0b3/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psithoninput-1.html,2,['charge'],['charge']
Energy Efficiency," counterpoise corrections and symmetry adapted; perturbation theory methods. These require the definition of which fragments; are interacting within the complex. PSI4 provides a very simple mechanism; for doing so; simply define the complex’s geometry using the standard; Cartesian, Z-matrix, or mixture thereof, specifications and then place two; dashes between nonbonded fragements. For example, to study the interaction; energy of ethane and ethyne molecules, we can use the following molecule; block:; molecule{; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; }. In this case, the charge and multiplicity of each interacting fragment is; explicitly specified. If the charge and multiplicity are specified for the; first fragment, it is assumed to be the same for all fragments. When; considering interacting fragments, the overall charge is simply the sum of all; fragment charges, and any unpaired electrons are assumed to be coupled to; yield the highest possible value. Job Control¶; PSI4 comprises a number of modules, written in C++, that each perform; specific tasks and are callable directly from the Python front end. Each module; recognizes specific keywords in the input file, detailed in Appendix Keywords by Module, which; control its function. The keywords can be made global, or scoped to apply to; certain specific modules. The following examples demonstrate some of the ways; that global keywords can be specified:; set globals basis cc-pVDZ. or. set basis cc-pVDZ. or. set globals basis = cc-pVDZ. or. set basis = cc-pVDZ. or. set globals{; basis cc-pVDZ; }. or. set{; basis cc-pVDZ; }. or. set{; basis = cc-pVDZ; }. Note the lack of quotes around cc-pVDZ, even though it is a string. The; Psithon pre",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:14016,charge,charge,14016,psi4manual/4.0b2/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html,2,['charge'],['charge']
Energy Efficiency," cp kwarg and/or the extended method syntax like; 'mp3/aug-cc-pv[dt]z' to energy(), opt(), etc., respectively.; For many of the PSI4 Python functions described above, it makes scientific; sense that they could be called in combination. For instance, one could; optimize all the reagents in a database or compute a; counterpoise-corrected interaction energy with an extrapolated method. The; table below outlines permitted intercalls between functions, showing that; db(opt(cbs(energy()))) is allowed, while db(cp(energy())) is not. This; table is not yet validated for calls with cp(). Permitted nesting of Psithon functions¶. Caller; Callee. cp; db; opt; cbs; energy. Basis Set Superposition Corrections. —; Y; Y; Y. Database — database(); —. Y; Y; Y. Geometry Optimization — optimize() and gradient(); —; —. Y; Y. Complete Basis Set; —; —; —. Y. Single-Point Energy — energy(); —; —; —; —. The command db(opt(cbs(energy()))) is actually expressed as db(...,; db_func=opt, opt_func=cbs). The perhaps expected final argument of; cbs_func=energy is not necessary since energy() is always the function; called by default. Also, the outermost internal function call (db_func; above can be called as just func. Several examples of intercalls; between Python functions can be found in sample input pywrap-all.; All keyword arguments are passed along to each function traversed in the; Python driver, so there should be no concern for separating them, grouping; them, or designating them for a particular function when undertaking a; nested calculation. Where the same keyword is used by multiple functions,; prefixes are added, e.g., db_mode and opt_mode.; Function intercalls should not be used in sow/reap mode. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Psithon Functions: Invoking a Calculation; Function Intercalls. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/intercalls.html:1352,energy,energy,1352,psi4manual/1.7.x/intercalls.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/intercalls.html,2,['energy'],['energy']
Energy Efficiency," criteria for different calculation types. Type: conv double; Default: 1e-10. E_CONVERGENCE (DETCI)¶DETCI — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. E_CONVERGENCE (DFOCC)¶DFOCC — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. E_CONVERGENCE (DLPNO)¶DLPNO — Energy convergence criteria for local MP2 iterations. Type: conv double; Default: 1e-6. E_CONVERGENCE (FNOCC)¶FNOCC — Convergence criterion for CC energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Note that convergence is met only when E_CONVERGENCE and R_CONVERGENCE are satisfied. Type: conv double; Default: 1.0e-6. E_CONVERGENCE (MCSCF)¶MCSCF — Convergence criterion for energy. Type: conv double; Default: 1e-6. E_CONVERGENCE (MRCC)¶MRCC — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. This becomes tol (option #16) in fort.56. Type: conv double; Default: 1e-6. E_CONVERGENCE (OCC)¶OCC — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. E_CONVERGENCE (PSIMRCC)¶PSIMRCC — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. E_CONVERGENCE (SAPT)¶SAPT — Convergence criterion for energy (change) in the SAPT \(E_{ind,resp}^{(20)}\) term during solution of the CPHF equations. Type: conv double; Default: 1e-10. E_CONVERGENCE (SCF)¶SCF — Convergence criterion for SCF energy. See Table SCF Convergence & Algorithm for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. EA_POLES (OCC)¶OCC",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_glossary_options_c-1.html:118247,energy,energy,118247,psi4manual/1.5.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_glossary_options_c-1.html,6,['energy'],['energy']
Energy Efficiency, criteria for different calculation types. Type: conv double; Default: 1e-10. E_CONVERGENCE (DETCI)¶DETCI — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. E_CONVERGENCE (DFOCC)¶DFOCC — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. E_CONVERGENCE (DLPNO)¶DLPNO — Energy convergence criteria for local MP2 iterations. Type: conv double; Default: 1e-6. E_CONVERGENCE (FNOCC)¶FNOCC — Convergence criterion for CC energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Note that convergence is met only when E_CONVERGENCE and R_CONVERGENCE are satisfied. Type: conv double; Default: 1.0e-6. E_CONVERGENCE (MCSCF)¶MCSCF — Convergence criterion for energy. Type: conv double; Default: 1e-6. E_CONVERGENCE (MRCC)¶MRCC — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. This becomes tol (option #16) in fort.56. Type: conv double; Default: 1e-6. E_CONVERGENCE (OCC)¶OCC — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. E_CONVERGENCE (PSIMRCC)¶PSIMRCC — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. E_CONVERGENCE (SCF)¶SCF — Convergence criterion for SCF energy. See Table SCF Convergence & Algorithm for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. EA_POLES (OCC)¶OCC — Do compute OCC poles for electron affinities? Only valid for OMP2. Type: boolean; Default: false. EFP_DISP (EFP)¶EFP — Do include dispersion energy term in EFP computation?. Type: bo,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_glossary_options_c.html:124508,energy,energy,124508,psi4manual/master/autodoc_glossary_options_c.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_glossary_options_c.html,1,['energy'],['energy']
Energy Efficiency," criterion. Although this is enough to make sure the SCF converged to a; stationary point, this is not a sufficient condition for a minimal SCF solution. It may be; a sadle point or a maximum.; To ensure that a minimum has been found, the electronic Hessian, i.e. the matrix of second; derivatives of the energy with respect to orbital variation parameters, must be computed.; If one or more eigenvalues of the electronic Hessian are negative, the SCF solution is not a minimum.; In that case, orbital parameters can be varied along the lowest Hessian eigenvector to lower the energy.; Orbital variation parameters are usually constrained. For example, in RHF the; spatial parts of the and orbitals are the same. In; UHF, the orbital coefficients are usually constrained to be real. A stability analysis; can check whether a lower SCF solution exists while respecting the constraints of the original; solution; this is an internal instability. If one or more constraints have to be relaxed to reach; a lower-energy solution, there is an external instability. In Psi4, the only external instability; that can be checked at present is the RHF->UHF one.; Currently, two algorithms exist in Psi4 for stability analysis: the original; Direct Inversion and the newly implemented Davidson algorithms. We will first describe; options common to both algorithms. To request a stability analysis at the end of the SCF,; set the keyword STABILITY_ANALYSIS:; set stability_analysis check. to only compute the electronic Hessian eigenvalue and check if an actual SCF minimum; has been found, or:; set stability_analysis follow. to rotate the converged orbitals along the lowest eigenvector, then invoke the SCF; procedure again to lower the energy. In case the minimization does not succeed; or ends up on the same unstable solution, you can tune the scale factor for the orbital; rotation through the keyword FOLLOW_STEP_SCALE:; set follow_step_scale 0.5. The rotation angle is (FOLLOW_STEP_SCALE). The default val",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/scf-1.html:24519,energy,energy,24519,psi4manual/1.0.0/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/scf-1.html,2,['energy'],['energy']
Energy Efficiency," cubeprop(wfn). >>> # [2] Cube files for density (alpha, beta, total, spin) and four orbitals; >>> # (two alpha, two beta); >>> set cubeprop_tasks ['orbitals', 'density']; >>> set cubeprop_orbitals [5, 6, -5, -6]; >>> E, wfn = energy('scf', return_wfn=True); >>> cubeprop(wfn). Introduction¶; PSI4 has the ability to export cube files that store information about; basis functions, molecular orbitals, the electron density, and; the electrostatic potential (ESP). Cube files store the value of a scalar; quantity on a regular Cartesian grid, and can be visualized with several; visualization programs, some of which are free, like VMD; (http://www.ks.uiuc.edu/Research/vmd/).; An example utilization of the code is:; molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set basis cc-pvdz; set scf_type df; set freeze_core True; set cubeprop_tasks ['orbitals']; set cubeprop_orbitals [5,6,-5,-6]. E, wfn = energy('scf', return_wfn=True); cubeprop(wfn). In this example, the cubeprop(); call after the energy('scf') command; executes the cubeprop code. The array CUBEPROP_TASKS specifies which; tasks should be executed. In this case the task 'orbitals' generates cube; files for orbitals. The CUBEPROP_ORBITALS option specifies that cube files; should be generated only for alpha orbitals 5 (HOMO) and 6 (LUMO) and; beta orbitals 5 (indicated as -5) and 6.; If the option CUBEPROP_ORBITALS is not provided, then cube files are; generated for all orbitals.; After running, the above input will generate four files: Psi_a_5_1-B1.cube,; Psi_a_6_4-A1.cube, Psi_a_5_1-B1.cube, and Psi_a_6_4-A1.cube. The subscript a in; Psi_a_5_1-B1.cube indicates an alpha orbital. The first number (5) is the index of the; orbital while 1-B1 indicates that this is the first orbital that belongs to the B1 irrep.; The file Psi_a_5_1-B1.cube begins with two comment lines:; Psi4 Gaussian Cube File.; Property: Psi_a_5_1-B1. Isocontour range for 85% of the density: (0.0787495,-0.0787495). The second line reports the isocon",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/cubeprop-1.html:1715,energy,energy,1715,psi4manual/1.4.0/cubeprop-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/cubeprop-1.html,9,['energy'],['energy']
Energy Efficiency," curve for formamide- formamidine complex; 'FaOOFaNN' dissociation curve for formic acid- formamidine complex. S66¶. Database (Hobza) of interaction energies for bimolecular complexes.; Geometries and reference energies from Rezac et al. JCTC 7 2427 (2011). cp 'off' || 'on'; rlxd 'off'; subset. 'small'; 'large'; 'HB' hydrogen-bonded systems; 'MX' mixed-influence systems; 'DD' dispersion-dominated systems. NCB31¶. Database (Truhlar) of several classes of noncovalent interactions.; Geometries from Truhlar and coworkers at site http://comp.chem.umn.edu/database_noncov/noncovalent.htm; Reference energies from Truhlar and coworkers at site http://comp.chem.umn.edu/database_noncov/noncovalent.htm; First comprehensive citation JPCA 109 5656 (2005). cp 'off' || 'on'; rlxd 'off' || 'on'; benchmark. '<benchmark_name>' <Reference>.; \(\Rightarrow\) '<default_benchmark_name>' \(\Leftarrow\) <Reference>. subset. 'small' 3: HF-HF, He-Ne, HCCH-HCCH; 'large' 1: BzBz_PD; 'HB6' hydrogen-bonded; 'CT7' charge-transfer; 'DI6' dipole-interacting; 'WI7' weakly interacting; 'PPS5' pi-pi stacking. ACENES¶. Database of Ed and Rob’s favorite linear acene dimers.; Geometries from nowhere special, and reference energies undefined. cp 'off' || 'on'; rlxd 'off'; subset. 'small'; 'large'; 'FIRST3' benzene, napthalene, and anthracene dimers; 'FIRST5' benzene - pentacene dimers; 'FIRST10' benzene - decacene dimers. HTR40¶. Database of Hydrogen transfer reactions.; Geometries from Bozkaya and Sherrill.; Reference energies from Bozkaya and Sherrill. benchmark. '<benchmark_name>' <Reference>.; \(\Rightarrow\) '<default_benchmark_name>' \(\Leftarrow\) <Reference>. subset. 'small' <members_description>; 'large' <members_description>; '<subset>' <members_description>. A24¶. Database (Hobza) of interaction energies for bimolecular complexes.; Geometries from <Reference>.; Reference interaction energies from Rezac and Hobza, JCTC (in press). cp 'off' <erase this comment and after unless on is a valid option>",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_available_databases-1.html:4505,charge,charge-transfer,4505,psi4manual/1.5.0/autodoc_available_databases-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_available_databases-1.html,4,['charge'],['charge-transfer']
Energy Efficiency," damping functions/parameters. omp2-1; OMP2 cc-pVDZ energy for the H2O molecule. dfccsdl1; DF-CCSDL cc-pVDZ energy for the H2O molecule. dft-omega; Test omega is setable updated wb97x_20,wb97x_03 to account for new BraggSlater radii. scf6; Tests RHF/ROHF/UHF SCF gradients. zaptn-nh2; ZAPT(n)/6-31G NH2 Energy Point, with n=2-25. olccd-grad1; OLCCD cc-pVDZ gradient for the H2O molecule. cc44; Test case for some of the PSI4 out-of-core codes. The code is given only 2.0 MB of memory, which is insufficient to hold either the A1 or B2 blocks of an ovvv quantity in-core, but is sufficient to hold at least two copies of an oovv quantity in-core. mints15; check SP basis Fortran exponent parsing. cc47; EOM-CCSD/cc-pVDZ on H2O2 with two excited states in each irrep. extern4; External potential calculation involving a TIP3P water and a QM water. Gradient on the external charges is compared to gradient on the QM atoms to validate the gradient on the charges. cdoremp-energy1; Cholesky decomposed OO-REMP/cc-pVDZ energy for the H2O molecule. dfccsd-t-grad1; DF-CCSD(T) cc-pVDZ gradients for the H2O molecule. cc4a; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. This version tests the FROZEN_DOCC option explicitly. gibbs; Test Gibbs free energies at 298 K of N2, H2O, and CH4. mbis-6; MBIS calculation on H2O. psimrcc-fd-freq1; Mk-MRCCSD single point. \(^3 \Sigma ^-\) O2 state described using the Ms = 0 component of the triplet. Uses ROHF triplet orbitals. cc41; RHF-CC2-LR/cc-pVDZ optical rotation of H2O2. gauge = both, omega = (589 355 nm). scf5; Test of all different algorithms and reference types for SCF, on singlet and triplet O2, using the cc-pVTZ basis set. fci-h2o-fzcv; 6-31G H2O Test FCI Energy Point. olccd2; OLCCD cc-pVDZ energy with B3LYP initial guess for the NO radical. dct6; DCT calculation for the triplet O2 using DC-06 and DC-12. Only two-step algorithm is tested. scf-level-shift-rohf; SCF level shift on an ROHF computation. mints8; Patch",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html:42283,energy,energy,42283,psi4manual/master/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency," data. del_array_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) Matrix QC variable. Prefer del_variable(). del_potential_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) ExternalPotential QC variable. (This function is provisional and might be removed in the future.). del_scalar_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) double QC variable. Prefer del_variable(). del_variable(key)¶; Removes scalar or array QCVariable key; from self if present. Parameters:. self (Wavefunction) – Wavefunction instance.; key (str) – Case-insensitive key to instance’s double or; Matrix storage maps. Return type:; None. doccpi(self: psi4.core.Wavefunction, assume_socc_alpha: bool = True) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. efzc(self: psi4.core.Wavefunction) → float¶; Returns the frozen-core energy. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunction’s energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, basis: str, subset: str) → psi4.core.Vector¶; Returns the requested Alpha orbital energies subset. Parameters:. basis – {‘AO’, ‘SO’, ‘MO’}; MO or SO select for Pitzer-ordering the return vector in the full computational point group symmetry.; AO selects for Pitzer-ordering the return vector without point group symmetry.; subset – {‘ALL’, ‘ACTIVE’, ‘FROZEN’, ‘OCC’, ‘VIR’, ‘FROZEN_OCC’, ‘ACTIVE_OCC’, ‘ACTIVE_VIR’, ‘FROZEN_VIR’}; Which subspace of orbital energies should be returned?. Returns:; A Pitzer-ordered vector of the orbitals. Return type:; Vector. epsilon_b(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, basis: str, subset: str) → psi4.core.Vector¶; Returns the requested Beta orbital energies ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Wavefunction.html:14215,energy,energy,14215,psi4manual/1.7.x/api/psi4.core.Wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Wavefunction.html,2,['energy'],['energy']
Energy Efficiency," database, where mol is either; the IUPAC molecule name or the CID number. See PubChem Database for; details. SymmetryThe symmetry can be specified by a line reading symmetry; symbol, where symbol is the Schönflies symbol; of the (Abelian) point group to use for the computation, one of one of; c1, c2, ci, cs, d2, c2h, c2v, or d2h.; This need not be specified, as the molecular symmetry is automatically; detected by PSI4. See Symmetry for details. FragmentsA line reading -- is interpreted as the separator between two non-covalently; bound molecular fragments. See Non-Covalently Bonded Molecule Fragments for details. Multiple Molecules¶; To facilitate more elaborate computations, it is possible to provide a name for; each molecule and tell PSI4 which one should be used in a given; calculation. For example, consider the following input file:; molecule h2 {; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; energy('scf') # on H2. clean(). molecule h {; H; }. set basis cc-pvdz; set reference uhf; energy('scf') # on H. Here, two separate jobs are performed on two different molecules; the first is; performed on H2, while the second is for H atom. The last molecule to be; specified is the “active” molecule by default. To explicitly activate a named; molecule, the activate command is provided. With it, the above input file can be; equivalently written as follows. Alternatively, the molecule can be specified; directly to the computing function. Below, the third calculation is the same as; the first.; molecule h2 {; H; H 1 0.9; }. molecule h {; H; }. activate(h2); set basis cc-pvdz; set reference rhf; energy('scf') # on H2. clean(). activate(h); set basis cc-pvdz; set reference uhf; energy('scf') # on H. # --------------------------------------; # equivalent to previous input ends here. clean(). set reference rhf; energy('scf', molecule=h2) # on H2. Job Control Keywords provides more details about the job control; and calculation keywords used in the above examples. Ghost At",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/psithonmol-1.html:4869,energy,energy,4869,psi4manual/1.4.0/psithonmol-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/psithonmol-1.html,9,['energy'],['energy']
Energy Efficiency," databases of bimolecular complexes; with non-frozen monomers, e.g., HBC6. symm (boolean) – \(\Rightarrow\) 'on' \(\Leftarrow\) || 'off'; Indicates whether the native symmetry of the database reagents is; employed ('on') or whether it is forced to \(C_1\) symmetry; ('off'). Some computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). zpe (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. benchmark (string) – \(\Rightarrow\) 'default' \(\Leftarrow\) || 'S22A' || etc.; Indicates whether a non-default set of reference energies, if; available (See Available Databases), are employed for the; calculation of error statistics. tabulate (array of strings) – \(\Rightarrow\) [] \(\Leftarrow\) || ['scf total energy', 'natom'] || etc.; Indicates whether to form tables of variables other than the; primary requested energy. Available for any PSI variable. subset (string or array of strings) – Indicates a subset of the full database to run. This is a very; flexible option and can be used in three distinct ways, outlined; below. Note that two take a string and the last takes an array.; See Available Databases for available values. 'small' || 'large' || 'equilibrium'; Calls predefined subsets of the requested database, either; 'small', a few of the smallest database members,; 'large', the largest of the database members, or; 'equilibrium', the equilibrium geometries for a database; composed of dissociation curves. 'BzBz_S' || 'FaOOFaON' || 'ArNe' || 'HB' || etc.; For databases composed of dissociation curves, or otherwise; divided into subsets, individual curves and subsets can be; called by name. Consult the database python files for available; molecular systems (case insensitive). [1,2,5] || ['1','2','5'] || ['BzMe-3.5', 'MeMe-5.0'] || etc.; Specify a list of da",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/db-1.html:4139,energy,energy,4139,psi4manual/1.2.1/db-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/db-1.html,6,['energy'],['energy']
Energy Efficiency," defines them. These can be; accessed through the get_variable() function. For example, after; performing a density fitted MP2 computation, both the spin component; scaled energy and the unscaled MP2 energy are made available:; e_mp2 = get_variable('MP2 TOTAL ENERGY'); e_scs_mp2 = get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; are cleared at the start of each energy(), etc. in an input; file by clean_variables().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the; last will include SCF TOTAL ENERGY but not; FCI TOTAL ENERGY.; The entire dictionary of PSI variables can be obtained through; get_variables(). Return Values¶; Most of the usual user computation functions (i.e.,; energy(), optimize(), and; frequency()) return simply the current total energy.; Consult the descriptions of other functions in Psithon Functions: Invoking a Calculation for; what quantities they return and for what data structures they make; available for post-processing. Many users need only deal with the simple return; form for the computation functions.; # E is total energy float; # G is gradient array; # H is hessian array; # wfn is class instance with many computational details. # simple returns; E = energy(...); E = optimize(...); E = frequency(...); G = gradient(...) # used by optimize(); H = hessian(...) # used by frequency(). For more elaborate post-processing of computations, adding; return_wfn=True keyword argument additionally returns; Wavefunction.; # power user returns; E, wfn = energy(..., return_wfn=True); E, wfn = optimize(..., return_wfn=True); E, wfn = frequency(..., return_wfn=True); G, wfn = gradient(..., return_wfn=True) # used by optimize(); H, wfn = hessian(..., return_wfn=True) # used by frequency",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/psithoninput-1.html:9094,energy,energy,9094,psi4manual/1.4.0/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/psithoninput-1.html,20,['energy'],['energy']
Energy Efficiency," del_scalar_variable(self, arg0); Removes the requested (case-insensitive) double QC variable. del_variable(key); Removes scalar or array QCVariable key from cls if present. density_fitted(self); Returns whether this wavefunction was obtained using density fitting or not. diis(self); docstring. diis_manager(self); docstring. doccpi(self); Returns the number of doubly occupied orbitals per irrep. efzc(self); Returns the frozen-core energy. energy(self); Returns the Wavefunction’s energy. epsilon_a(self); Returns the Alpha Eigenvalues. epsilon_a_subset(self, arg0, arg1); Returns the requested Alpha Eigenvalues subset. epsilon_b(self); Returns the Beta Eigenvalues. epsilon_b_subset(self, arg0, arg1); Returns the requested Beta Eigenvalues subset. esp_at_nuclei(self); returns electrostatic potentials at nuclei. external_pot(self); Gets the requested external potential. finalize(self); Cleans up the the Wavefunction’s temporary data. finalize_energy(); Performs stability analysis and calls back SCF with new guess if needed, Returns the SCF energy. find_occupation(self); docstring. force_doccpi(self, arg0); Specialized expert use only. force_soccpi(self, arg0); Specialized expert use only. form_C(self, shift); Forms the Orbital Matrices from the current Fock Matrices. form_D(self); Forms the Density Matrices from the current Orbitals Matrices. form_F(self); Forms the F matrix. form_G(self); Forms the G matrix. form_H(self); Forms the core Hamiltonian. form_Shalf(self); Forms the S^1/2 matrix. form_V(self); Form the Kohn-Sham Potential Matrices from the current Density Matrices. form_initial_C(self); Forms the initial Orbital Matrices from the current Fock Matrices. form_initial_F(self); Forms the initial F matrix. frac_renormalize(self); docstring. frequencies(). from_file(wfn_data); Build Wavefunction from data. frzcpi(self); Returns the number of frozen core orbitals per irrep. frzvpi(self); Returns the number of frozen virtual orbitals per irrep. functional(self); Retu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.cuhf.html:4773,energy,energy,4773,psi4manual/1.4.0/api/psi4.core.cuhf.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.cuhf.html,5,['energy'],['energy']
Energy Efficiency," delta2_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, 'highest_1', which uses the best basis; set available. See Extrapolation Schemes for all available schemes. Parameters:; scf_scheme (function) – highest_1 || scf_xtpl_helgaker_3 || etc.; Indicates the basis set extrapolation scheme to be applied to the reference energy. corl_scheme (function) – highest_1 || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the correlation energy. delta_scheme (function) – highest_1 || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the delta correction; to the correlation energy. delta2_scheme (function) – highest_1 || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the second delta correction; to the correlation energy. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> cbs('scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> cbs('mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> cbs('scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> cbs('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/cbs-1.html:5500,energy,energy,5500,psi4manual/4.0b2/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/cbs-1.html,6,['energy'],['energy']
Energy Efficiency," delta_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. delta2_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. delta3_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the third delta correction; to the correlation energy. delta4_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the fourth delta correction; to the correlation energy. delta5_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the fifth delta correction; to the correlation energy. Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, 'highest_1', which uses the best basis; set available. See Extrapolation Schemes for all available schemes. Parameters:; scf_scheme (function) – highest_1 || scf_xtpl_helgaker_3 || etc.; Indicates the basis set extrapolation scheme to be applied to the reference energy. corl_scheme (function) – highest_1 || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the correlation energy. delta_scheme (function) – highest_1 || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the delta correction; to the correlation energy. delta2_scheme (function) – highest_1 || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the second delta correction; to the correlation energy. d",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/cbs-1.html:6711,energy,energy,6711,psi4manual/4.0b5/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/cbs-1.html,2,['energy'],['energy']
Energy Efficiency," delta_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. delta2_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. delta3_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the third delta correction; to the correlation energy. delta4_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the fourth delta correction; to the correlation energy. delta5_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the fifth delta correction; to the correlation energy. Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, 'xtpl_highest_1', which uses the best basis; set available. See Extrapolation Schemes for all available schemes. Parameters:; scf_scheme (function) – xtpl_highest_1 || scf_xtpl_helgaker_3 || etc.; Indicates the basis set extrapolation scheme to be applied to the reference energy.; Defaults to scf_xtpl_helgaker_3() if three valid basis sets; present in scf_basis, scf_xtpl_helgaker_2() if two valid basis; sets present in scf_basis, and xtpl_highest_1() otherwise. corl_scheme (function) – xtpl_highest_1 || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in corl_basis and xtpl_highest_1() otherwise. delta_scheme (function) – xtpl_highest_1 || corl_xtpl_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/cbs-1.html:6833,energy,energy,6833,psi4manual/1.0.0/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/cbs-1.html,2,['energy'],['energy']
Energy Efficiency," delta_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. delta2_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. delta3_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the third delta correction; to the correlation energy. delta4_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the fourth delta correction; to the correlation energy. delta5_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the fifth delta correction; to the correlation energy. Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, 'xtpl_highest_1', which uses the best basis; set available. See sec:cbs_xtpl for all available schemes. Parameters:; scf_scheme (function) – \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || scf_xtpl_helgaker_3 || etc.; Indicates the basis set extrapolation scheme to be applied to the reference energy.; Defaults to scf_xtpl_helgaker_3() if three valid basis sets; present in scf_basis, scf_xtpl_helgaker_2() if two valid basis; sets present in scf_basis, and xtpl_highest_1() otherwise. corl_scheme (function) – \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in corl_basis and xtpl_highest_1() otherwise. d",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/cbs-1.html:7507,energy,energy,7507,psi4manual/1.1.0/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/cbs-1.html,3,['energy'],['energy']
Energy Efficiency," delta_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. delta2_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. delta3_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the third delta correction; to the correlation energy. delta4_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the fourth delta correction; to the correlation energy. delta5_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the fifth delta correction; to the correlation energy. Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, 'xtpl_highest_1', which uses the best basis; set available. See sec:cbs_xtpl for all available schemes. Parameters:; scf_scheme (function) – \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || scf_xtpl_helgaker_3 || etc.; Indicates the basis set extrapolation scheme to be applied to the reference energy.; Defaults to scf_xtpl_helgaker_3() if three valid basis sets; present in scf_basis, scf_xtpl_helgaker_2() if two valid basis; sets present in scf_basis, and xtpl_highest_1() otherwise. xtpl_highest_1; scf_xtpl_helgaker_3; scf_xtpl_helgaker_2; scf_xtpl_truhlar_2; scf_xtpl_karton_2. corl_scheme (function) – \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the correlation energy.; Defaults to corl_x",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/cbs-1.html:7509,energy,energy,7509,psi4manual/1.2.1/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/cbs-1.html,4,['energy'],['energy']
Energy Efficiency," delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] cbs() coupled with database(); >>> database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='sto-3g'). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call (only energy makes sense for cbs); if not('cbs_func' in kwargs):; if ('func' in kwargs):; kwargs['cbs_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['cbs_func'] = energy; func = kwargs['cbs_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper complete_basis_set.' % (func.__name__)); if not(func is energy):; raise ValidationError('Wrapper complete_basis_set is unhappy to be calling function \'%s\' instead of \'energy\'.' % (func.__name__)). # Define some quantum chemical knowledge, namely what methods are subsumed in others; VARH = {}; VARH['scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['df-scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY'}; VARH['df-mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'df-mp2corl': 'DF-MP2 CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORRELATION ENERGY'}; VARH['ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['bccd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'bccdcorl': 'CCSD CORRELATION ENERGY'}; VARH['cc3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc3corl': 'CC3 CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'S",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:59097,energy,energy,59097,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,4,['energy'],['energy']
Energy Efficiency," delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] cbs() coupled with database(); >>> database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='sto-3g'). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call (only energy makes sense for cbs); if not('cbs_func' in kwargs):; if ('func' in kwargs):; kwargs['cbs_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['cbs_func'] = energy; func = kwargs['cbs_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper complete_basis_set.' % (func.__name__)); if not(func is energy):; raise ValidationError('Wrapper complete_basis_set is unhappy to be calling function \'%s\' instead of \'energy\'.' % (func.__name__)). # Define some quantum chemical knowledge, namely what methods are subsumed in others; VARH = {}; VARH['scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY'}; VARH['mp2.5'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp4(sdq)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY', ; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:60505,energy,energy,60505,psi4manual/4.0b4/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html,2,['energy'],['energy']
Energy Efficiency," density RMS convergence to stop an instruction during successive DMRG instructions. Type: double; Default: 1.e-6. DMRG_SCF_MAX_ITER (DMRG)¶DMRG — Maximum number of DMRG iterations. Type: integer; Default: 100. DMRG_SCF_STATE_AVG (DMRG)¶DMRG — Whether or not to use state-averaging for roots >=2 with DMRG-SCF. Type: boolean; Default: true. DMRG_SWEEP_DVDSON_RTOL (DMRG)¶DMRG — The residual tolerances for the Davidson diagonalization during DMRG instructions. Type: array; Default: No Default. DMRG_SWEEP_ENERGY_CONV (DMRG)¶DMRG — The energy convergence to stop an instruction during successive DMRG instructions. Type: array; Default: No Default. DMRG_SWEEP_MAX_SWEEPS (DMRG)¶DMRG — The maximum number of sweeps to stop an instruction during successive DMRG instructions. Type: array; Default: No Default. DMRG_SWEEP_NOISE_PREFAC (DMRG)¶DMRG — The noise prefactors for successive DMRG instructions. Type: array; Default: No Default. DMRG_SWEEP_STATES (DMRG)¶DMRG — The number of reduced renormalized basis states to be retained during successive DMRG instructions. Type: array; Default: No Default. DMRG_UNITARY_WRITE (DMRG)¶DMRG — Whether or not to store the unitary on disk (convenient for restarting). Type: boolean; Default: true. DO_CCD_DISP (SAPT)¶SAPT (Expert) — Do CCD dispersion correction in SAPT2+, SAPT2+(3) or SAPT2+3?. Type: boolean; Default: false. DO_DIIS (DFOCC)¶DFOCC — Do apply DIIS extrapolation?. Type: boolean; Default: true. DO_DIIS (OCC)¶OCC — Do apply DIIS extrapolation?. Type: boolean; Default: true. DO_DISP_EXCH_SINF (SAPT)¶SAPT (Expert) — For SAPT(DFT) computes the \(S^{inf}\) Exchange-Dispersion terms. Type: boolean; Default: false. DO_IND_EXCH_SINF (SAPT)¶SAPT (Expert) — For SAPT(DFT) computes the \(S^{inf}\) Exchange-Induction terms. Type: boolean; Default: false. DO_LEVEL_SHIFT (DFOCC)¶DFOCC — Do apply level shifting?. Type: boolean; Default: true. DO_LEVEL_SHIFT (OCC)¶OCC — Removed in 1.4. Will raise an error in 1.5. Type: boolean; Default: true. DO_MBPT_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:113541,reduce,reduced,113541,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,4,['reduce'],['reduced']
Energy Efficiency," density RMS convergence to stop an instruction during successive DMRG instructions. Type: double; Default: 1.e-6. DMRG_SCF_MAX_ITER (DMRG)¶DMRG — Maximum number of DMRG iterations. Type: integer; Default: 100. DMRG_SCF_STATE_AVG (DMRG)¶DMRG — Whether or not to use state-averaging for roots >=2 with DMRG-SCF. Type: boolean; Default: true. DMRG_SWEEP_DVDSON_RTOL (DMRG)¶DMRG — The residual tolerances for the Davidson diagonalization during DMRG instructions. Type: array; Default: No Default. DMRG_SWEEP_ENERGY_CONV (DMRG)¶DMRG — The energy convergence to stop an instruction during successive DMRG instructions. Type: array; Default: No Default. DMRG_SWEEP_MAX_SWEEPS (DMRG)¶DMRG — The maximum number of sweeps to stop an instruction during successive DMRG instructions. Type: array; Default: No Default. DMRG_SWEEP_NOISE_PREFAC (DMRG)¶DMRG — The noise prefactors for successive DMRG instructions. Type: array; Default: No Default. DMRG_SWEEP_STATES (DMRG)¶DMRG — The number of reduced renormalized basis states to be retained during successive DMRG instructions. Type: array; Default: No Default. DMRG_UNITARY_WRITE (DMRG)¶DMRG — Whether or not to store the unitary on disk (convenient for restarting). Type: boolean; Default: true. DO_CCD_DISP (SAPT)¶SAPT (Expert) — Do CCD dispersion correction in SAPT2+, SAPT2+(3) or SAPT2+3?. Type: boolean; Default: false. DO_DIIS (DFOCC)¶DFOCC — Do apply DIIS extrapolation?. Type: boolean; Default: true. DO_DIIS (OCC)¶OCC — Do apply DIIS extrapolation?. Type: boolean; Default: true. DO_DISP_EXCH_SINF (SAPT)¶SAPT (Expert) — For SAPT0 or SAPT(DFT), compute the non-approximated second-order exchange-dispersion term. Type: boolean; Default: false. DO_IND30_EXCH_SINF (SAPT)¶SAPT (Expert) — For SAPT2+3, compute the non-approximated third-order exchange-induction term. Type: boolean; Default: false. DO_IND_EXCH_SINF (SAPT)¶SAPT (Expert) — For SAPT0 or SAPT(DFT), compute the non-approximated second-order exchange-induction term. Type: boolean; Default:",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodoc_glossary_options_c.html:115203,reduce,reduced,115203,psi4manual/1.6.x/autodoc_glossary_options_c.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodoc_glossary_options_c.html,5,['reduce'],['reduced']
Energy Efficiency," density as this is often; much more costly than the energy. In addition, the Wavefunction density attributes; (Da and Db) return the SO density and must be transformed to the MO basis; to use with this function. New in version 0.5: wfn parameter passed explicitly. Returns; None. Parameters. filename (string) – destination file name for MOLDEN file (optional); do_virtual (bool) – do write all the MOs to the MOLDEN file (true) or discard the unoccupied MOs, not valid for NO’s (false) (optional); use_natural (bool) – write natural orbitals determined from density on wavefunction. Examples. Molden file with the Kohn-Sham orbitals of a DFT calculation.; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> wfn.molden('mycalc.molden'). Molden file with the natural orbitals of a CCSD computation. For correlated methods, an energy call will not compute the density.; “properties” or “gradient” must be called.; >>> E, wfn = properties('ccsd', return_wfn=True); >>> wfn.molden('ccsd_no.molden', use_natural=True). To supply a custom density matrix, manually set the Da and Db of the wavefunction.; This is used, for example, to write natural orbitals coming from a root computed; by a CIWavefunction computation, e.g., detci, fci, casscf.`; The first two arguments of get_opdm can be set to n, n where n => 0 selects the root to; write out, provided these roots were computed, see NUM_ROOTS. The; third argument controls the spin (""A"", ""B"" or ""SUM"") and the final; boolean option determines whether inactive orbitals are included.; >>> E, wfn = energy('detci', return_wfn=True); >>> wfn.Da() = wfn.get_opdm(0, 0, ""A"", True); >>> wfn.Db() = wfn.get_opdm(0, 0, ""B"", True); >>> molden(wfn, 'no_root1.molden', use_natural=True). write_nbo(name)¶. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. PSI4 API: Linking C++ and Python; HF. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.HF.html:38002,energy,energy,38002,psi4manual/1.6.x/api/psi4.core.HF.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.HF.html,1,['energy'],['energy']
Energy Efficiency," density fitting integrals should be written as (A0|PQ) rather than; (PQ|A0) where possible, because we want the ket to contain more functions than; the bra for efficient blocking. Instantiating integral objects¶; With sieving being introduced in the new integral objects, the cost of their; construction has increased. Although significantly cheaper than computing; integrals themselves, construction of integral objects can be non-negligible,; especially if many threads are used. For example, this pattern can be found in; old versions of the code:; std::vector<std::shared_ptr<TwoBodyAOInt>> ints;; ints.push_back(std::shared_ptr<TwoBodyAOInt>(factory->eri()));; for (int thread = 1; thread < num_threads; thread++) {; ints.push_back(std::shared_ptr<TwoBodyAOInt>(factory->eri()));; }. This builds many objects and the cost can add up. With the new scheme,; integral objects are forced to implement a clone() member that can be used as; follows:; std::vector<std::shared_ptr<TwoBodyAOInt>> ints;; ints.push_back(std::shared_ptr<TwoBodyAOInt>(factory->eri()));; for (int thread = 1; thread < num_threads; thread++) {; ints.push_back(std::shared_ptr<TwoBodyAOInt>(ints[0]->clone()));; }. This method only incurs the cost of creating a single integral object, and; performs much cheaper cloning operations to create the other objects for each; thread. Moreover, if integral objects are created only in the initialization; of each code that uses them, and stored persistently, the cost of integral; object creation is further reduced. table of contents. Integrals in PSI4; Introduction; The older style; The new syntax; Sieving; Buffer address; Density Screening; Shell blocking; Permutational symmetry; Using bra-ket symmetry; Instantiating integral objects. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Integrals in PSI4. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/prog_integrals-1.html:10612,reduce,reduced,10612,psi4manual/1.4.0/prog_integrals-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/prog_integrals-1.html,2,['reduce'],['reduced']
Energy Efficiency," density fitting integrals should be written as (A0|PQ) rather than; (PQ|A0) where possible, because we want the ket to contain more functions than; the bra for efficient blocking. Instantiating integral objects¶; With sieving being introduced in the new integral objects, the cost of their; construction has increased. Although significantly cheaper than computing; integrals themselves, construction of integral objects can be non-negligible,; especially if many threads are used. For example, this pattern can be found in; old versions of the code:; std::vector<std::shared_ptr<TwoBodyAOInt>> ints;; ints.push_back(std::shared_ptr<TwoBodyAOInt>(factory->eri()));; for (int thread = 1; thread < num_threads; thread++) {; ints.push_back(std::shared_ptr<TwoBodyAOInt>(factory->eri()));; }. This builds many objects and the cost can add up. With the new scheme,; integral objects are forced to implement a clone() member that can be used as; follows:; std::vector<std::shared_ptr<TwoBodyAOInt>> ints;; ints.push_back(std::shared_ptr<TwoBodyAOInt>(factory->eri()));; for (int thread = 1; thread < num_threads; thread++) {; ints.push_back(std::shared_ptr<TwoBodyAOInt>(ints[0]->clone()));; }. This method only incurs the cost of creating a single integral object, and; performs much cheaper cloning operations to create the other objects for each; thread. Moreover, if integral objects are created only in the initialization; of each code that uses them, and stored persistently, the cost of integral; object creation is further reduced. table of contents. Integrals in PSI4; Introduction; The older style; The new syntax; Sieving; Buffer address; Density Screening; Shell blocking; Permutational symmetry; Using bra-ket symmetry; Instantiating integral objects. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Integrals in PSI4. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/prog_integrals-1.html:10612,reduce,reduced,10612,psi4manual/1.5.0/prog_integrals-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/prog_integrals-1.html,2,['reduce'],['reduced']
Energy Efficiency," density: (0.0787495,-0.0787495). The second line reports the isocontour values that capture 85% of the probability density using; the least amount of grid points. This quantity is determined for orbitals and densities. The; fraction of the density captured by the isocontour values is by default 0.85, but can; be changed via the option |globals__cubeprop_isocontour_threshold|. Note; If your cube plots are too coarse, try to decrease the grid spacing via; the option CUBIC_GRID_SPACING. If the edges of your plot are cut then; increase the size of the grid via the option CUBIC_GRID_OVERAGE. Cubeprop Tasks¶; The cubeprop utility can be provided a list of tasks to perform.; Tasks are specified by the CUBEPROP_TASKS option, which is a list of strings; that identify the tasks. Several tasks are available. These include:. ORBITALS [Default if CUBEPROP_TASKS is not specified]; Produces cube representations of the molecular orbitals; \(\psi_q(\mathbf{r})\). Orbitals are sorted according to increasing; orbital energy ignoring symmetry.; DENSITY; This task can be used to obtain the alpha and beta electron densities,; \(\rho_\alpha(\mathbf{r})\) and \(\rho_\beta(\mathbf{r})\), together; with the total density; \(\rho(\mathbf{r}) = \rho_\alpha(\mathbf{r}) + \rho_\beta(\mathbf{r})\),; and the spin density; \(\rho(\mathbf{r}) = \rho_\alpha(\mathbf{r}) - \rho_\beta(\mathbf{r})\).; BASIS_FUNCTIONS; This task is useful to produce cube files of the atomic orbital basis; functions \(\chi_\mu(\mathbf{r})\).; ESP; Calculates the total (nuclear + electronic) electrostatic potential; \(V(\mathbf{r})\). Note; The ESP task requires the user to specify a density-fitting basis; via the DF_BASIS_SCF keyword. Warning; It is important to specify the CUBEPROP_ORBITALS option when; dealing with large molecules to avoid running out of disk space.; For example, using the default grid spacing of; 0.2 Ångström, the size of a single cube file for a molecule like water; is of the order of 1.4 MB. For a mol",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/cubeprop-1.html:3673,energy,energy,3673,psi4manual/1.2.1/cubeprop-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/cubeprop-1.html,2,['energy'],['energy']
Energy Efficiency," dertype is unspecified, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; research site: https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/dft-d3; Psi4 mode: When psi4 the python module is importable at import qcdb. time, Psi4 mode is activated, with the following alterations:; * output goes to output file; * gradient returned as psi4.core.Matrix, not list o’lists; * scratch is written to randomly named subdirectory of psi scratch; * psivar “DISPERSION CORRECTION ENERGY” is set; * verbose triggered when PRINT keywork of SCF module >=3. run_gcp(func=None, dertype=None, verbose=False)¶; Function to call Grimme’s dftd3 program (http://toc.uni-muenster.de/DFTD3/); to compute the -D correction of level dashlvl using parameters for; the functional func. The dictionary dashparam can be used to supply; a full set of dispersion parameters in the absense of func or to supply; individual overrides in the presence of func. Returns energy if dertype is 0,; gradient if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The dftd3 executable must be independently compiled and found in; PATH or PSIPATH.; self may be either a qcdb.Molecule (sensibly) or a psi4.Molecule; (works b/c psi4.Molecule has been extended by this method py-side and; only public interface fns used) or a string that can be instantiated; into a qcdb.Molecule. save_string_xyz(self: psi4.core.Molecule) → str¶; Saves the string of an XYZ file to arg2. save_string_xyz_file(self: psi4.core.Molecule) → str¶; Saves an XYZ file to arg2. save_xyz_file(self: psi4.core.Molecule, arg0: str, arg1: bool) → None¶; Saves an XYZ file to arg2. schoenflies_symbol(self: psi4.core.Molecule) → str¶; Returns the Schoenflies symbol. scramble(do_shift=True, do_rotate=True, do_resort=True, deflection=1.0, do_mirror=False, do_plot=False, run_to_completion=False, run_resorting=False, verbose=1)¶; Tester for B787 by shifting, rotating, and atom shuffling ref_mol and; checking that the aligner returns th",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psi4api-1.html:141295,energy,energy,141295,psi4manual/1.2.1/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html,6,['energy'],['energy']
Energy Efficiency," dertype=0); print(energy). Footnotes. 1; Note that there are functionals with these extensions (e.g., wB97X-D) that,; not being Grimme corrections, won’t follow this table exactly. 2; [Grimme:2004:1463]. 3; [Grimme:2006:1787]. 4; [Grimme:2010:154104]. 5; [Grimme:2011:1456]. 6(1,2); [Smith:2016:2197]. 7; [Hujo:2011:3866]. 8; [Chai:2010:6615]. 9; [Pernal:2009:263201]. 10; [Podeszwa:2010:550]. 11; Keyword not used for user-defined functionals where the dft_dict[""dispersion""][""params""]; is easily editable for this purpose. See Advanced Functional Use and Manipulation. A few practical examples:. DFT-D2 single point with default parameters (dftd3 not called); energy('bp86-d'). DFT-D3BJ optimization with default parameters; optimize('pbe-d3bj'). DFT-D2 optimization with custom s6 parameter; set dft_dispersion_parameters [1.20]; optimize('b3lyp-d2'). DFT-D3ZERO single point (b3lyp) with custom s8 parameter (reset all four values); set dft_dispersion_parameters [1.0, 2.0, 1.261, 14.0]; energy('b3lyp-d3'). DFT-D2 single point with dftd3 instead of PSI4‘s libdisp; energy('pbe-d2', engine='dftd3'). If only dispersion corrections (rather than total energies) are of; interest, the dftd3 program can be run independently of the scf; through the python function run_dftd3(). (This function; is the same PSI4/dftd3 interface that is called during an scf job.); This route is much faster than running a DFT-D energy. Some set-up:; molecule nene {; Ne; Ne 1 2.0; }. nene.update_geometry(). The same four dispersion corrections/gradients as the section above:; >>> print nene.run_dftd3('bp86', 'd', dertype=0); -7.735e-05. >>> E, G = nene.run_dftd3('pbe', 'd3bj'); >>> print G; [[0.0, 0.0, -1.1809087569358e-05], [0.0, 0.0, 1.1809087569358e-05]]. >>> E, G = nene.run_dftd3('b3lyp', 'd2', {'s6': 1.20}); >>> print E; -8.84e-05. >>> E, G = nene.run_dftd3(dashlvl='d3', dashparam={'s8': 2.0, 'alpha6': 14.0, 'sr6': 1.261, 's6': 1.0}); >>> print E; -0.00024762. qcdb.Molecule.run_dftd3(self, func=None, da",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/dftd3-1.html:8804,energy,energy,8804,psi4manual/1.4.0/dftd3-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/dftd3-1.html,2,['energy'],['energy']
Energy Efficiency," described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. tdscf-2; td-uhf test on triplet states of methylene (tda), wfn passing. scf11-freq-from-energies; Test frequencies by finite differences of energies for planar C4NH4 TS. dfcasscf-sa-sp; Example of state-averaged CASSCF for the C2 molecule. dft1-alt; DFT Functional Test. cc14; ROHF-CCSD/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. cc4; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. After the computation, the checkpoint file is renamed, using the PSIO handler. ghosts; Density fitted MP2 cc-PVDZ/cc-pVDZ-RI computation of formic acid dimer binding energy using explicit specification of ghost atoms. This is equivalent to the dfmp2_1 sample but uses both (equivalent) specifications of ghost atoms in a manual counterpoise correction. phi-ao; Test computing values of basis functions (puream and non-puream) at points. fd-freq-energy; SCF STO-3G finite-difference frequencies from energies for H2O. cisd-opt-fd; H2O CISD/6-31G** Optimize Geometry by Energies. mbis-6; MBIS calculation on H2O. scf-hess1; RHF STO-3G (Cartesian) and cc-pVDZ (spherical) water Hessian test, against Psi3 reference values. scf-guess-read1; Sample UHF/cc-pVDZ H2O computation on a doublet cation, using RHF/cc-pVDZ orbitals for the closed-shell neutral as a guess. cc13b; Tests RHF CCSD(T)gradients. soscf-large; Second-order SCF convergnece: Benzene. mints-helper; A general test of the MintsHelper function. sapt-dft1; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. pywrap-checkrun-convcrit; Advanced python example sets different sets of scf/post-scf conv crit and check to be sure computation has actually converged to the expected accuracy. scf-guess; Test initial SCF guesses on FH and FH+ in cc-pVTZ basis. frac-ip-fitting; Omega optimization for LRC functional wB97 on water. cc22; ROHF-EOM-CCSD/DZ on the lowest two states of each irrep in \(^{3}B_1\) ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html:26840,energy,energy,26840,psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency," desired, this keyword need not be included. Default : compute vibrational frequencies for all irreducible representations. Type: array; Default: No Default. CFOUR_FD_PROJECT (CFOUR)¶CFOUR — Specifies whether or not rotational degrees of freedoms are projected out from the symmetry-adapted coordinates in a finite difference calculations. ON (=0) uses rotationally projected coordinates, while OFF (=1) retains the rotational degrees of freedom. At a stationary point on the potential energy surface, both options will give equivalent harmonic force fields, but OFF should be used at non-stationary points. Type: string; Possible Values: ON, OFF; Default: ON. CFOUR_FD_STEPSIZE (CFOUR)¶CFOUR — Specifies the step length in mass-weighted coordinates (in \(10^{-4} amu^{1/2} bohr\) ) used in generating the force constant matrix by finite difference of Cartesian gradients. Type: integer; Default: 5. CFOUR_FD_USEGROUP (CFOUR)¶CFOUR — In finite difference calculations using the FINDIF option, this keyword specifies the point group to be used in generating the symmetry-adapted vibrational coordinates. FULL (= 0) specifies the full molecular point group, COMP (= 1) specifies the Abelian subgroup used in the electronic structure calculation. Type: string; Possible Values: FULL, COMP; Default: FULL. CFOUR_FILE_RECSIZ (CFOUR)¶CFOUR — This specifies the physical length (in integer words) of the records used in the word-addressable direct access files used by CFOUR. This value should always be chosen as a multiple of 512 bytes, as your local system manager certainly understands. Type: integer; Default: 2048. CFOUR_FILE_STRIPE (CFOUR)¶CFOUR — This option allows the splitting of files. Input is required in the form N1/N2/N3/N4/N5, where N1, N2, N3, N4, and N5 specify the number of files in which MOINTS, GAMLAM, MOABCD, DERINT, and DERGAM are split, respectively. Type: string; Default: 0/0/0/0/0. CFOUR_FINITE_PERTURBATION (CFOUR)¶CFOUR — Specifies the field strength for a perturbation (defin",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:43664,adapt,adapted,43664,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,9,['adapt'],['adapted']
Energy Efficiency," dfccsdl1; DF-CCSDL cc-pVDZ energy for the H2O molecule. dft-grad-lr1; wB97X-D cc-pVDZ gradient of S22 HCN. fci-h2o-2; 6-31G H2O Test FCI Energy Point. cdomp2-2; OMP2 cc-pVDZ energy for the NO molecule. cepa-module; routing check on lccd, lccsd, cepa(0). pywrap-basis; SAPT calculation on bimolecular complex where monomers are unspecified so driver auto-fragments it. Basis set and auxiliary basis sets are assigned by atom type. cc17; Single point energies of multiple excited states with EOM-CCSD. castup3; SCF with various combinations of pk/density-fitting, castup/no-castup, and spherical/cartesian settings. Demonstrates that puream setting is getting set by orbital basis for all df/castup parts of calc. Demonstrates that answer doesn’t depend on presence/absence of castup. Demonstrates (by comparison to castup2) that output file doesn’t depend on options (scf_type) being set global or local. This input uses local. scf4; RHF cc-pVDZ energy for water, automatically scanning the symmetric stretch and bending coordinates using Python’s built-in loop mechanisms. The geometry is specified using a Z-matrix with variables that are updated during the potential energy surface scan, and then the same procedure is performed using polar coordinates, converted to Cartesian coordinates. cc15; RHF-B-CCD(T)/6-31G** H2O single-point energy (fzc, MO-basis \(\langle ab|cd \rangle\)). fnocc2; Test G2 method for H2O. opt4; SCF cc-pVTZ geometry optimzation, with Z-matrix input. dfmp2-grad1; DF-MP2 cc-pVDZ gradients for the H2O molecule. props4; Electrostatic potential and electric field evaluated on a grid around water. psimrcc-ccsd_t-2; Mk-MRCCSD(T) single point. \(^1A_1\) CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. dft-grac; Gradient regularized asymptotic correction (GRAC) test. cbs-xtpl-freq; Various gradients for a strained helium dimer and water molecule. cisd-h2o-clpse; 6-31G** H2O Test CISD Energy Point with subspace collapse. rasci-h2",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html:28329,energy,energy,28329,psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency," dft-smoke; DFT Functional Smoke Test. dct-grad3; Restricted DF-DCT ODC-12 gradient for ethylene with cc-pVDZ/cc-pVDZ-RI standard/auxiliary basis set. fsapt-d; Tests SAPT0-D corrections, with a variety of damping functions/parameters. mbis-4; MBIS calculation on NaCl. lccd-grad1; LCCD cc-pVDZ gradient for the H2O molecule. cc21; ROHF-EOM-CCSD/DZ analytic gradient lowest \(^{2}A_1\) excited state of H2O+ (B1 excitation). nbody-multi-level; Multilevel computation of water trimer energy (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). dct10; The multiple guesses for DCT amplitudes for ODC-12. nbody-vmfc-hessian; Computation of VMFC-corrected water trimer Hessian (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). dct3; DC-06 calculation for the He dimer. This performs a simultaneous update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the AO Basis, using integrals stored on disk. omp2-2; OMP2 cc-pVDZ energy with ROHF initial guess orbitals for the NO radical. omp2-5; SOS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. cc22; ROHF-EOM-CCSD/DZ on the lowest two states of each irrep in \(^{3}B_1\) CH2. scf-hess3; CONV SCF 6-31G analytical vs finite-difference tests Tests UHF hessian code for Ca != Cb. mom-h2o-4; MOM excitation from LUMO HOMO+4. fci-h2o; 6-31G H2O Test FCI Energy Point. dct1; DC-06, DC-12, ODC-06 and ODC-12 calculation for the He dimer. This performs a simultaneous update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the MO Basis. opt9; Various constrained energy minimizations of HOOH with cc-pvdz RHF. Cartesian-coordinate constrained optimizations of HOOH in internals. cbs-xtpl-energy-conv; Extrapolated water energies - conventional integrals version. cc10; ROHF-CCSD cc-pVDZ energy for the \(^2\Sigma^+\) state of the CN radical. frac-ip-fitting; Omega optimization for LRC functional wB97 on water. cc3; cc3: RHF-CCSD/6-31G** H2O geo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html:40068,energy,energy,40068,psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency," difference frequency computation, from gradients, for a given irrep. psi4.core.finalize() → None¶. psi4.core.fisapt(arg0: psi::Wavefunction) → float¶; Runs the functional-group intramolecular symmetry adapted perturbation theory code. psi4.core.flush_outfile() → None¶; Flushes the output file. psi4.core.fnocc(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the fno-ccsd(t)/qcisd(t)/mp4/cepa energy code. psi4.core.get_active_efp() → psi4.core.EFP¶; Returns the currently active EFP object. psi4.core.get_active_molecule() → psi::Molecule¶; Returns the currently active molecule object. psi4.core.get_array_variable(arg0: str) → psi::Matrix¶; Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available). psi4.core.get_array_variables() → Dict[str, psi::Matrix]¶; Returns dictionary of the PSI variables set internally by the modules or python driver. psi4.core.get_atomic_point_charges() → psi::Vector¶; Returns the most recently computed atomic point charges, as a double * object. psi4.core.get_efp_torque() → psi::Matrix¶; Returns the most recently computed gradient for the EFP portion, as a Nefp by 6 Matrix object. psi4.core.get_environment(arg0: str) → str¶; Get enviromental vairable. psi4.core.get_frequencies() → psi::Vector¶; Returns the most recently computed frequencies, as a 3N-6 Vector object. psi4.core.get_global_option(arg0: str) → object¶; Given a string of a keyword name arg1, returns the value associated with the keyword from the global options. Returns error if keyword is not recognized. psi4.core.get_global_option_list() → List[str]¶; Returns a list of all global options. psi4.core.get_gradient() → psi::Matrix¶; Returns the most recently computed gradient, as a N by 3 Matrix object. psi4.core.get_legacy_molecule() → psi::Molecule¶; Returns the currently active molecule object. psi4.core.get_local_option(arg0: str, arg1: str) → object¶; Given a string of a keyword name arg2 and a particul",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psi4api-1.html:149543,charge,charges,149543,psi4manual/1.1.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psi4api-1.html,2,['charge'],['charges']
Energy Efficiency," dipole moment?. Type: boolean; Default: false. DIPMOM (FNOCC); FNOCC — Compute the dipole moment? Note that dipole moments are only available in the FNOCC module for the ACPF, AQCC, CISD, and CEPA(0) methods. Type: boolean; Default: false. DISP_SIZE (FINDIF); FINDIF — Displacement size in au for finite-differences. Type: double; Default: 0.005. DISTANT_PAIR_CUTOFF (LMP2); LMP2 — Distant pair cutoff. Type: double; Default: 8.0. DISTRIBUTED_MATRIX (SCF); SCF (Expert) — The dimension sizes of the distributed matrix. Type: array; Default: No Default. DO_ALL_TEI (TRANSQT); TRANSQT — Do transform all TEIs. Type: boolean; Default: false. DO_CCD_DISP (SAPT); SAPT (Expert) — Do CCD dispersion correction in SAPT2+, SAPT2+(3) or SAPT2+3?. Type: boolean; Default: false. DO_DIIS (OCC); OCC — Do apply DIIS extrapolation?. Type: boolean; Default: true. DO_LEVEL_SHIFT (OCC); OCC — Do apply level shifting?. Type: boolean; Default: true. DO_SCS (OCC); OCC — Do perform spin-component-scaled OMP2 (SCS-OMP2)? In all computation, SCS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SCS-OMP2, one needs to set ‘DO_SCS’ to true. Type: boolean; Default: false. DO_SINGLETS (CPHF); CPHF — Do singlet states? Default true. Type: boolean; Default: true. DO_SOS (OCC); OCC — Do perform spin-opposite-scaled OMP2 (SOS-OMP2)? In all computation, SOS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SOS-OMP2, one needs to set ‘DO_SOS’ to true. Type: boolean; Default: false. DO_THIRD_ORDER (SAPT); SAPT (Expert) — Do compute third-order corrections?. Type: boolean; Default: false. DO_TRIPLETS (CPHF); CPHF — Do triplet states? Default true. Type: boolean; Default: true. DOCC (GLOBALS); GLOBALS — An array containing the number of doubly-occupied orbitals per irrep (in Cotton order). Type: array; Default: No Default. DOCC (MCSCF); MCSCF — The number of doubly occ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_glossary_options_c-1.html:35397,energy,energy,35397,psi4manual/4.0b4/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_glossary_options_c-1.html,2,['energy'],['energy']
Energy Efficiency," dipole moment?. Type: boolean; Default: false. DISP_SIZE (FINDIF); FINDIF — Displacement size in au for finite-differences. Type: double; Default: 0.005. DISTANT_PAIR_CUTOFF (LMP2); LMP2 — Distant pair cutoff. Type: double; Default: 8.0. DISTRIBUTED_MATRIX (SCF); SCF (Expert) — The dimension sizes of the distributed matrix. Type: array; Default: No Default. DO_ALL_TEI (TRANSQT); TRANSQT — Do transform all TEIs. Type: boolean; Default: false. DO_LEVEL_SHIFT (OMP2); OMP2 — Do apply level shifting?. Type: boolean; Default: false. DO_LEVEL_SHIFT (OMP3); OMP3 — Do apply level shifting to aid convergence. Type: boolean; Default: false. DO_SCS (OMP2); OMP2 — Do perform spin-component-scaled OMP2 (SCS-OMP2)? In all computation, SCS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SCS-OMP2, one needs to set ‘DO_SCS’ to true. Type: boolean; Default: false. DO_SCS (OMP3); OMP3 — Do perform spin-component-scaled OMP3 (SCS-OMP3)? In all computation, SCS-OMP3 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SCS-OMP3, one needs to set ‘DO_SCS’ to true. Type: boolean; Default: false. DO_SINGLETS (CPHF); CPHF — Do singlet states? Default true. Type: boolean; Default: true. DO_SOS (OMP2); OMP2 — Do perform spin-opposite-scaled OMP2 (SOS-OMP2)? In all computation, SOS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SOS-OMP2, one needs to set ‘DO_SOS’ to true. Type: boolean; Default: false. DO_SOS (OMP3); OMP3 — Do perform spin-opposite-scaled OMP3 (SOS-OMP3)? In all computation, SOS-OMP3 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SOS-OMP3, one needs to set ‘DO_SOS’ to true. Type: boolean; Default: false. DO_THIRD_ORDER (SAPT); SAPT (Expert) — Do compute third-order corrections?. Type: boolean; Def",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html:33851,energy,energy,33851,psi4manual/4.0b3/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html,2,['energy'],['energy']
Energy Efficiency," disappear eventually. Works only for full CI and I don’t remember if I could see how their clever scheme might be extended to RAS in general. Type: boolean; Default: false. FCI_STRINGS¶. Do store strings specifically for FCI? (Defaults to TRUE for FCI.). Type: boolean; Default: false. REPL_OTF¶. Do string replacements on the fly in DETCI? Can save a gigantic amount of memory (especially for truncated CI’s) but is somewhat flaky and hasn’t been tested for a while. It may work only works for certain classes of RAS calculations. The current code is very slow with this option turned on. Type: boolean; Default: false. Expert MCSCF¶. MCSCF_ALGORITHM¶. Convergence algorithm to utilize. This is a flag for the future. Type: string; Possible Values: ONE_STEP, TWO_STEP; Default: TWO_STEP. MCSCF_SO¶. Do second-order orbital-orbital MCSCF. Without one-step this typically slows the overall computation considerably. Type: boolean; Default: false. MCSCF_SO_START_E¶. Start second-order orbital-orbital MCSCF based on energy convergence. Type: double; Default: 1e-3. MCSCF_SO_START_GRAD¶. Start second-order orbital-orbital MCSCF based on RMS of orbital gradient. Type: double; Default: 1e-3. Table Of Contents. DETCI; General Options; AVG_STATES; AVG_WEIGHTS; A_RAS3_MAX; B_RAS3_MAX; CALC_S_SQUARED; CIBLKS_PRINT; CI_MAXITER; CI_NUM_THREADS; DETCI_FREEZE_CORE; EX_LEVEL; E_CONVERGENCE; FCI; ICORE; ISTOP; MS0; NUM_DETS_PRINT; NUM_ROOTS; RAS34_MAX; RAS3_MAX; RAS4_MAX; REFERENCE; R_CONVERGENCE; S; VAL_EX_LEVEL. Diagonalization Methods; DIAG_METHOD; LSE; LSE_COLLAPSE; LSE_TOLERANCE; PRECONDITIONER; UPDATE. Density Matrices; DIPMOM; NAT_ORBS; OPDM; OPDM_AVG; OPDM_PRINT; TDM; TDM_PRINT; TDM_WRITE; TPDM_PRINT. Root Following; FOLLOW_ROOT. Guess Vectors; RESTART. File Handling; COLLAPSE_SIZE; MAX_NUM_VECS. General-Order Perturbation Theory; MPN. General-Order Coupled-Cluster; CC; CC_A_RAS3_MAX; CC_B_RAS3_MAX; CC_EX_LEVEL; CC_RAS34_MAX; CC_RAS3_MAX; CC_RAS4_MAX; CC_VAL_EX_LEVEL; CC_VECS_READ; CC_VE",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__detci-1.html:21875,energy,energy,21875,psi4manual/1.0.0/autodir_options_c/module__detci-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__detci-1.html,2,['energy'],['energy']
Energy Efficiency," disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Unlike run_dftd3, func overwrites any; parameter initialized via dashparam.; dashlvl (Optional[str]) – Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or “alias” or; “formal” to run.; dashparam (Optional[Dict]) – Values for the same keys as dashcoeff[dashlvl][‘default’]; used to provide custom values. Unlike run_dftd3, will not have; effect if func given. Must provide all parameters.; Extra parameters will error.; dertype (Union[int, str, None]) – Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int) – Amount of printing. Returns:. energy (float) – When dertype=0, energy [Eh].; gradient (ndarray) – When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray) – When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; This function wraps the QCEngine dftd4 harness which wraps the internal DFTD4 Python API.; As such, the upstream convention of func trumping dashparam holds, rather than the; run_dftd3() behavior of dashparam extending or overriding func. class psi4.driver.procrouting.empirical_dispersion.EmpiricalDispersion(*, name_hint=None, level_hint=None, param_tweaks=None, engine=None, gcp_engine=None, save_pairwise_disp=False)[source]¶; Lightweight unification of empirical dispersion calculation modes. dashlevel¶; {“d1”, “d2”, “chg”, “das2009”, “das2010”, “nl”, “dmp2”, “d3zero2b”, “d3bj2b”, “d3mzero2b”, “d3mbj2b”, “d3zeroatm”, “d3bjatm”, “d3mzeroatm”, “d3mbjatm”, “d4bjeeqatm”}; Name of dispersion correction to be applied. Resolved; from name_hint and/or level_hint into a key of; empirical_dispersion_resources.dashcoeff. Type:; str. dashparams¶; Complete set of parameter values defining the flexible parts; of dashlevel. Number and",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/dftd3.html:15909,energy,energy,15909,psi4manual/1.7.x/dftd3.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/dftd3.html,8,['energy'],['energy']
Energy Efficiency," disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Unlike run_dftd3, func overwrites any; parameter initialized via dashparam.; dashlvl (Optional[str]) – Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or “alias” or; “formal” to run.; dashparam (Optional[Dict]) – Values for the same keys as dashcoeff[dashlvl][‘default’]; used to provide custom values. Unlike run_dftd3, will not have; effect if func given. Must provide all parameters.; Extra parameters will error.; dertype (Union[int, str, None]) – Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int) – Amount of printing. Returns:. energy (float) – When dertype=0, energy [Eh].; gradient (ndarray) – When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray) – When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; This function wraps the QCEngine dftd4 harness which wraps the internal DFTD4 Python API.; As such, the upstream convention of func trumping dashparam holds, rather than the; run_dftd3() behavior of dashparam extending or overriding func. run_gcp(func=None, dertype=None, verbose=1)[source]¶; Compute geometrical BSSE correction via Grimme’s GCP program.; Function to call Grimme’s GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to self for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, func. Returns energy if dertype is 0, gradient; if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The gcp executable must be independently compiled and; found in PATH or PSIPATH. self may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended b",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:30213,energy,energy,30213,psi4manual/1.7.x/api/psi4.core.Molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html,8,['energy'],['energy']
Energy Efficiency, dispersion by truncating the virtual orbital space? Recommended true for all SAPT computations. Type: boolean; Default: true. NAT_ORBS_V4 (SAPT); SAPT — Do use MP2 natural orbital approximations for the block of two-electron integrals in the evaluation of CCD T2 amplitudes? Recommended true for all SAPT computations. Type: boolean; Default: true. NEW_TRIPLES (CCENERGY); CCENERGY — Do use new triples?. Type: boolean; Default: true. NEW_TRIPLES (CCEOM); CCEOM — Do use new triples?. Type: boolean; Default: true. NEWTON_CONVERGENCE (ADC); ADC — The convergence criterion for pole searching step. Type: conv double; Default: 1e-7. NO_DFILE (DETCI); DETCI (Expert) — Do use the last vector space in the BVEC file to write scratch DVEC rather than using a separate DVEC file? (Only possible if NUM_ROOTS = 1.). Type: boolean; Default: false. NO_RESPONSE (SAPT); SAPT — Don’t solve the CPHF equations? Evaluate and instead of their response-including coupterparts. Only turn on this option if the induction energy is not going to be used. Type: boolean; Default: false. NO_SINGLES (PSIMRCC); PSIMRCC — Do disregard updating single excitation amplitudes?. Type: boolean; Default: false. NO_TEI (TRANSQT2); TRANSQT2 (Expert) — Whether to only form the one electron integrals. Type: boolean; Default: false. NORM_TOLERANCE (ADC); ADC — The cutoff norm of residual vector in SEM step. Type: conv double; Default: 1e-6. NUM_AMPS_PRINT (ADC); ADC — Number of components of transition amplitudes printed. Type: integer; Default: 5. NUM_AMPS_PRINT (CCENERGY); CCENERGY — Number of important and amplitudes to print. Type: integer; Default: 10. NUM_AMPS_PRINT (CCEOM); CCEOM — Number of important CC amplitudes to print. Type: integer; Default: 5. NUM_AMPS_PRINT (CCLAMBDA); CCLAMBDA — Number of important CC amplitudes per excitation level to print. CC analog to NUM_DETS_PRINT. Type: integer; Default: 10. NUM_AMPS_PRINT (CCRESPONSE); CCRESPONSE — Number of important CC amplitudes per excitation level to pr,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:170485,energy,energy,170485,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,2,['energy'],['energy']
Energy Efficiency," dispersion interaction should be smaller because; the perpendicular geometry does not allow much overlap between the; monomers. Hence, the SAPT analysis helps clarify (and quantify) our; physical understanding about the interaction between the two monomers. V. Potential Surface Scans and Counterpoise Correction Made Easy¶; Finally, let’s consider an example which highlights the advantages of; being able to interact with Psi4 directly with Python.; Suppose you want to do a limited potential energy surface scan, such as; computing the interaction energy between two neon atoms at various; interatomic distances. One simple but unappealing way to do this is to; generate separate geometries for each distance to be studied. Instead,; we can leverage Python loops and string formatting to make our lives; simpler. Additionally, let’s suppose you want to do counterpoise (CP); correction to compute interaction energies. Counterpoise correction; involves computing the dimer energy and then subtracting out the; energies of the two monomers, each evaluated in the dimer basis. Again,; each of these computations could be run in a separate input file, but; because counterpoise correction is a fairly standard procedure for; intermolecular interactions, Psi4 knows about it and has a built-in; routine to perform counterpoise correction. It only needs to know what; method you want to do the couterpoise correction on (here, let’s; consider CCSD(T)), and it needs to know what’s monomer A and what’s; monomer B. This last issue of specifying the monomers separately was; already dealt with in the previous SAPT example, where we saw that two; dashes in the psi4.geometry() string can be used to separate; monomers.; So, we’re going to do counterpoise-corrected CCSD(T) energies for; Ne\(_2\) at a series of different interatomic distances. And let’s; print out a table of the interatomic distances we’ve considered, and the; CP-corrected CCSD(T) interaction energies (in kcal/mol) at each; geometry:",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psiapi-1.html:17787,energy,energy,17787,psi4manual/1.1.0/psiapi-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psiapi-1.html,4,['energy'],['energy']
Energy Efficiency," displaced ozone, with Z-matrix input. omp2-2; OMP2 cc-pVDZ energy with ROHF initial guess orbitals for the NO radical. cc33; CC3(UHF)/cc-pVDZ H2O \(R_e\) geom from Olsen et al., JCP 104, 8007 (1996). pywrap-freq-e-sowreap; Finite difference of energies frequency, run in sow/reap mode. cc51; EOM-CC3/cc-pVTZ on H2O. opt12; SCF cc-pVDZ geometry optimzation of ketene, starting from bent structure. molden1; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. psimrcc-ccsd_t-3; Mk-MRCCSD(T) single point. \(^1A_1\) CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. cc5; RHF CCSD(T) aug-cc-pvtz frozen-core energy of C4NH4 Anion. mints8; Patch of a glycine with a methyl group, to make alanine, then DF-SCF energy calculation with the cc-pVDZ basis set. psimrcc-fd-freq2; Mk-MRCCSD frequencies. \(^1A_1\) O$_3` state described using the Ms = 0 component of the singlet. Uses TCSCF orbitals. cepa0-grad2; CEPA cc-pVDZ gradient for the NO radical. tu6-cp-ne2; Example potential energy surface scan and CP-correction for Ne2. sapt7; SAPT0 open-shell computation of H2O-HO2 interaction energy First with cc-pVDZ and density fitted integrals with UHF Then with 6-31g and direct integrals, except for dispersion that is computed with cc-pVDZ-ri density fitting with UHF. scf-bs; UHF and broken-symmetry UHF energy for molecular hydrogen. fci-tdm; He2+ FCI/cc-pVDZ Transition Dipole Moment. omp2p5-grad2; OMP2.5 cc-pVDZ gradient for the NO radical. fci-h2o-fzcv; 6-31G H2O Test FCI Energy Point. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/testsuite-1.html:35029,energy,energy,35029,psi4manual/1.1.0/testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/testsuite-1.html,8,['energy'],['energy']
Energy Efficiency," do two things. First, we must set the value of the intermolecular; separation in our Z-matrix (by using Python 3 string; formatting); to the particular value of R. Second, we need to turn the Z-matrix; string into a Psi4 molecule, by passing it to; `psi4.geometry() <http://psicode.org/psi4manual/master/api/psi4.driver.geometry.html#psi4.driver.geometry>`__.; The argument bsse_type='cp' tells Psi4 to perform counterpoise (CP); correction on the dimer to compute the CCSD(T)/aug-cc-pVDZ interaction; energy, which is stored in our ecp dictionary at each iteration of; our Python loop. Note that we didn’t need to specify ghost atoms, and we; didn’t need to call the monomer and dimer computations separately. Psi4; does it all for us, automatically.; Near the very end of the output file output.dat, the counterpoise; correction Python function will print a nice summary of the results of; the counterpoise computation (the energies of the dimer, of monomer 1; with the ghost functions of monomer 2, of monomer 2 with the ghost; functions of monomer 1, and the overall counterpoise corrected; interaction energy):; N-Body: Computing complex (1/2) with fragments (2,) in the basis of fragments (1, 2).; ...; N-Body: Complex Energy (fragments = (2,), basis = (1, 2): -128.70932405488924); ...; N-Body: Computing complex (2/2) with fragments (1,) in the basis of fragments (1, 2).; ...; N-Body: Complex Energy (fragments = (1,), basis = (1, 2): -128.70932405488935); ...; N-Body: Computing complex (1/1) with fragments (1, 2) in the basis of fragments (1, 2).; ...; N-Body: Complex Energy (fragments = (1, 2), basis = (1, 2): -257.41867403127321); ...; ==> N-Body: Counterpoise Corrected (CP) energies <==. n-Body Total Energy [Eh] I.E. [kcal/mol] Delta [kcal/mol]; 1 -257.418648109779 0.000000000000 0.000000000000; 2 -257.418674031273 -0.016265984132 -0.016265984132. And that’s it! The only remaining part of the example is a little table; of the different R values and the CP-corrected CCSD(T) ene",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psiapi-1.html:21749,energy,energy,21749,psi4manual/1.1.0/psiapi-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psiapi-1.html,4,['energy'],['energy']
Energy Efficiency," do_delta3 and do_delta4 and do_delta5:; pass; else:; raise ValidationError('Requested scf (%s) + corl (%s) + delta (%s) + delta2 (%s) + delta3 (%s) + delta4 (%s) + delta5 (%s) not valid. These steps are cummulative.' %; (do_scf, do_corl, do_delta, do_delta2, do_delta3, do_delta4, do_delta5)). # Establish list of valid basis sets for correlation energy; if do_corl:; if 'corl_basis' in kwargs:; BSTC, ZETC = validate_bracketed_basis(kwargs['corl_basis'].lower()); else:; raise ValidationError('CORL basis sets through keyword \'%s\' are required.' % ('corl_basis')). # Establish list of valid basis sets for scf energy; if 'scf_basis' in kwargs:; BSTR, ZETR = validate_bracketed_basis(kwargs['scf_basis'].lower()); else:; if do_corl:; BSTR = BSTC[:]; ZETR = ZETC[:]; else:; raise ValidationError('SCF basis sets through keyword \'%s\' are required. Or perhaps you forgot the \'%s\'.' % ('scf_basis', 'corl_wfn')). # Establish list of valid basis sets for delta correction energy; if do_delta:; if 'delta_basis' in kwargs:; BSTD, ZETD = validate_bracketed_basis(kwargs['delta_basis'].lower()); else:; raise ValidationError('DELTA basis sets through keyword \'%s\' are required.' % ('delta_basis')). # Establish list of valid basis sets for second delta correction energy; if do_delta2:; if 'delta2_basis' in kwargs:; BSTD2, ZETD2 = validate_bracketed_basis(kwargs['delta2_basis'].lower()); else:; raise ValidationError('DELTA2 basis sets through keyword \'%s\' are required.' % ('delta2_basis')). # Establish list of valid basis sets for third delta correction energy; if do_delta3:; if 'delta3_basis' in kwargs:; BSTD3, ZETD3 = validate_bracketed_basis(kwargs['delta3_basis'].lower()); else:; raise ValidationError('DELTA3 basis sets through keyword \'%s\' are required.' % ('delta3_basis')). # Establish list of valid basis sets for fourth delta correction energy; if do_delta4:; if 'delta4_basis' in kwargs:; BSTD4, ZETD4 = validate_bracketed_basis(kwargs['delta4_basis'].lower()); else:; raise V",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:75925,energy,energy,75925,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,1,['energy'],['energy']
Energy Efficiency," docstring. IDAMAX(arg0, arg1, arg2, arg3); docstring. adc(ref_wfn); Runs the ADC propagator code, for excited states. array_variable(key); Returns copy of the Matrix QCVariable key (case-insensitive); prefer variable(). array_variables(); Returns dictionary of all Matrix QCVariables; prefer variables(). be_quiet(); Redirects output to /dev/null. benchmark_blas1(max_dim, min_time); Perform benchmark traverse of BLAS 1 routines. benchmark_blas2(max_dim, min_time); Perform benchmark traverse of BLAS 2 routines. benchmark_blas3(max_dim, min_time[, nthread]); Perform benchmark traverse of BLAS 3 routines. benchmark_disk(max_dim, min_time); Perform benchmark of PSIO disk performance. benchmark_integrals(max_am, min_time); Perform benchmark of psi integrals (of libmints type). benchmark_math(min_time); Perform benchmark of common double floating point operations including most of cmath. ccdensity(ref_wfn); Runs the code to compute coupled cluster density matrices. ccenergy(ref_wfn); Runs the coupled cluster energy code. cceom(ref_wfn); Runs the equation of motion coupled cluster code for excited states. cchbar(ref_wfn); Runs the code to generate the similarity transformed Hamiltonian. cclambda(ref_wfn); Runs the coupled cluster lambda equations code. ccresponse(ref_wfn); Runs the coupled cluster response theory code. cctransort(ref_wfn); Runs cctransort that transforms and reorders integrals for use in the coupled cluster codes. cctriples(ref_wfn); Runs the coupled cluster (T) energy code. clean(); Remove scratch files. clean_options(); Reset options to clean state. clean_timers(); Reinitialize timers for independent timer.dat entries. clean_variables(); Empties all double and Matrix QCVariables that have been set in global memory. close_outfile(); Closes the output file. dct(ref_wfn); Runs the density cumulant (functional) theory code. del_array_variable(key); Removes the Matrix QCVariable key (case-insensitive); prefer del_variable(). del_scalar_variable(key); Removes th",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/psi4api-1.html:3186,energy,energy,3186,psi4manual/1.5.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/psi4api-1.html,3,['energy'],['energy']
Energy Efficiency," docstring. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. efzc(self: psi4.core.Wavefunction) → float¶; Returns the frozen-core energy. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunction’s energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Beta Eigenvalues subset. esp_at_nuclei(self: psi4.core.Wavefunction) → psi4.core.Vector¶; returns electrostatic potentials at nuclei. finalize(self: psi4.core.HF) → None; Cleans up the the Wavefunction’s temporary data. finalize_energy(); Performs stability analysis and calls back SCF with new guess; if needed, Returns the SCF energy. This function should be called; once orbitals are ready for energy/property computations, usually; after iterations() is called. find_occupation(self: psi4.core.HF) → None; docstring. force_doccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use only. Sets the number of doubly occupied oribtals per irrep. Note that this results in inconsistent Wavefunction objects for SCF, so caution is advised. force_soccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use only. Sets the number of singly occupied oribtals per irrep. Note that this results in inconsistent Wavefunction objects for SCF, so caution is advised. form_C(self: psi4.core.HF) → None; Forms the Orbital Matrices from the current Fock Matrices. form_D(self: psi4.core.HF) → None; Forms the Density Matrices from the current Orbitals Matrices. form_F(self: psi4.core.HF) → None; Forms the F matrix. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.hf.html:16119,energy,energy,16119,psi4manual/1.3.2/api/psi4.core.hf.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.hf.html,1,['energy'],['energy']
Energy Efficiency," docstring. so_dkh(self: psi4.core.MintsHelper, arg0: int) → psi4.core.Matrix¶; docstring. so_kinetic(self: psi4.core.MintsHelper) → psi4.core.Matrix¶; docstring. so_nabla(self: psi4.core.MintsHelper) → List[psi4.core.Matrix]¶; docstring. so_overlap(self: psi4.core.MintsHelper) → psi4.core.Matrix¶; docstring. so_potential(self: psi4.core.MintsHelper, arg0: bool) → psi4.core.Matrix¶; docstring. so_quadrupole(self: psi4.core.MintsHelper) → List[psi4.core.Matrix]¶; docstring. so_traceless_quadrupole(self: psi4.core.MintsHelper) → List[psi4.core.Matrix]¶; docstring. sobasisset(self: psi4.core.MintsHelper) → psi::SOBasisSet¶; docstring. class psi4.core.MoldenWriter¶; Bases: object; docstring. write(self: psi4.core.MoldenWriter, arg0: str, arg1: psi4.core.Matrix, arg2: psi4.core.Matrix, arg3: psi4.core.Vector, arg4: psi4.core.Vector, arg5: psi4.core.Vector, arg6: psi4.core.Vector, arg7: bool) → None¶; docstring. class psi4.core.Molecule¶; Bases: object; Class to store the elements, coordinates, fragmentation pattern, basis sets, charge, multiplicity, etc. of a molecule. BFS()¶; Perform a breadth-first search (BFS) on the real atoms; in molecule, returning an array of atom indices of fragments.; Relies upon van der Waals radii and so faulty for close; (esp. hydrogen-bonded) fragments. Original code from; Michael S. Marshall. Z(self: psi4.core.Molecule, arg0: int) → float¶; Nuclear charge of atom arg1 (0-indexed). activate_all_fragments(self: psi4.core.Molecule) → None¶; Sets all fragments in the molecule to be active. add_atom(self: psi4.core.Molecule, arg0: int, arg1: float, arg2: float, arg3: float, arg4: str, arg5: float, arg6: float, arg7: int) → None¶; Adds to Molecule arg0 an atom with atomic number arg1, Cartesian coordinates in Bohr (arg2, arg3, arg4), atomic symbol arg5, mass arg6, charge arg7 (optional), and lineno arg8 (optional). atom_at_position(self: psi4.core.Molecule, arg0: float, arg1: float) → int¶; Tests to see if an atom is at the position arg2 with a gi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psi4api-1.html:77856,charge,charge,77856,psi4manual/1.1.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psi4api-1.html,2,['charge'],['charge']
Energy Efficiency," done to match supplemental info of Szalewicz et. al., Phys. Rev. Lett., 103, 263201 (2009) and Szalewicz et. al., J. Phys. Chem. Lett., 1, 550-555 (2010). dfmp2-grad2; DF-MP2 cc-pVDZ gradient for the NO molecule. cc26; Single-point gradient, analytic and via finite-differences of 2-1A1 state of H2O with EOM-CCSD. mp2p5-grad1; MP2.5 cc-pVDZ gradient for the H2O molecule. sapt-exch-ind-inf; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. adc1; ADC(2)/6-31G** on H2O using builtin ADC module. stability1; UHF->UHF stability analysis test for BH with cc-pVDZ Test direct SCF with and without symmetry, test PK without symmetry. cisd-h2o+-0; 6-31G** H2O+ Test CISD Energy Point. cc2; 6-31G** H2O CCSD optimization by energies, with Z-Matrix input. dfep2-2; Compute three IP and 2 EA’s for the PH3 molecule. omp2p5-2; OMP2.5 cc-pVDZ energy for the H2O molecule. sad-scf-type; Test SAD SCF guesses on noble gas atom. dfmp2-1; Density fitted MP2 cc-PVDZ/cc-pVDZ-RI computation of formic acid dimer binding energy using automatic counterpoise correction. Monomers are specified using Cartesian coordinates. fsapt2; A very quick correctness test of F-SAPT (see fsapt1 for a real example). cepa3; cc-pvdz H2O Test coupled-pair CISD against DETCI CISD. dfomp2-3; OMP2 cc-pVDZ energy for the H2O molecule. cc19; CCSD/cc-pVDZ dipole polarizability at two frequencies. opt12; SCF cc-pVDZ geometry optimzation of ketene, starting from bent structure. cc17; Single point energies of multiple excited states with EOM-CCSD. props2; DF-SCF cc-pVDZ of benzene-hydronium ion, scanning the dissociation coordinate with Python’s built-in loop mechanism. The geometry is specified by a Z-matrix with dummy atoms, fixed parameters, updated parameters, and separate charge/multiplicity specifiers for each monomer. One-electron properties computed for dimer and one monomer. opt2; SCF DZ allene geometry optimization, with Cartesian input, first in c2v symmetry, then in Cs symmetry from a starting point",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html:24713,energy,energy,24713,psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency," double-hybrid, this quantity is equal; to DFT TOTAL ENERGY. SCF TOTAL GRADIENT¶; The total electronic gradient [E_h/a0] of the SCF stage of the calculation, ({nat}, 3). SCF DIPOLE GRADIENT¶; The derivative of the SCF stage dipole [E_h a0/u] = [(e a0/a0)^2/u] with respect to nuclear perturbations; as a degree-of-freedom by dipole component array, (3 * {nat}, 3). SCF TOTAL HESSIAN¶; The total electronic second derivative [E_h/a0/a0] for the SCF stage, (3 * {nat}, 3 * {nat}). SCF STABILITY EIGENVALUES¶; Array of eigenvalues from UHF or ROHF stability analysis. SCS-CCSD TOTAL ENERGY¶. SCS-CCSD CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the CCSD-like method formed by reweighting CCSD DOUBLES ENERGY; by 1.27 opposite-spin and 1.13 same-spin contributions, with; any singles carried along. SCS-MP2 TOTAL ENERGY¶. SCS-MP2 CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the MP2-like method formed by reweighting MP2 DOUBLES ENERGY; by 6/5 opposite-spin and 1/3 same-spin contributions, with; any singles carried along. SCS-MP2-VDW TOTAL ENERGY¶. SCS-MP2-VDW CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the MP2-like method formed by reweighting MP2 DOUBLES ENERGY; by 1.28 opposite-spin and 0.50 same-spin contributions, with; any singles carried along. DOI: 10.1080/00268970802641242. SCS(N)-MP2 TOTAL ENERGY¶. SCS(N)-MP2 CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the MP2-like method formed by reweighting MP2 DOUBLES ENERGY; by 0 opposite-spin and 1.76 same-spin contributions, with; any singles carried along. doi: 10.1021/ct6002737. SCS(N)-OMP2 CORRELATION ENERGY¶. SCS(N)-OMP2 TOTAL ENERGY¶. SCSN-OMP2 CORRELATION ENERGY¶. SCSN-OMP2 TOTAL ENERGY¶; Two spellings of a discontinued QCVariable that may still appear; because the code is frozen pending an update. SCS-OMP2 TOTAL",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html:54611,energy,energy,54611,psi4manual/1.7.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html,8,['energy'],['energy']
Energy Efficiency," e_scf = psi4.get_variable('SCF TOTAL ENERGY'); ce_mp2 = psi4.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = psi4.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; psi4.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; psi4.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; psi4.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); psi4.set_variable('CURRENT ENERGY', e_mp25) # geometry optimizer tracks this variable, permits; # MP2.5 finite difference optimizations; # build string of title banner and print results; banners = ''; banners += """"""psi4.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""psi4.print_out('\\n')\n\n""""""; exec banners. tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); psi4.print_out(tables) # prints nice header and table of all involved quantities to output file. return e_mp25. One final step is necessary. At the end of the aliases.py file, add; the following line.; procedures['energy']['mp2.5'] = run_mp2_5. This permits the newly defined MP2.5 method to be called in the input file; with the following command.; energy('mp2.5'). Previous topic; Customization: Adding Simple Extensions; Next topic; Creating a Database. This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; Psi4 [1.0.0 6a9a71b] » ; Custom",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/quickaddalias-1.html:2838,energy,energy,2838,psi4manual/1.0.0/quickaddalias-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/quickaddalias-1.html,2,['energy'],['energy']
Energy Efficiency," e_scf = psi4.get_variable('SCF TOTAL ENERGY'); ce_mp2 = psi4.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = psi4.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; psi4.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; psi4.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; psi4.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); psi4.set_variable('CURRENT ENERGY', e_mp25) # geometry optimizer tracks this variable, permits; # MP2.5 finite difference optimizations; # build string of title banner and print results; banners = ''; banners += """"""psi4.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""psi4.print_out('\\n')\n\n""""""; exec banners. tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); psi4.print_out(tables) # prints nice header and table of all involved quantities to output file. return e_mp25. One final step is necessary. At the end of the aliases.py file, add; the following line.; procedures['energy']['mp2.5'] = run_mp2_5. This permits the newly defined MP2.5 method to be called in the input file; with the following command.; energy('mp2.5'). Previous topic; User-Defined Basis Sets; Next topic; Creating a Database; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta5] » ; Customization: Adding Simple E",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/quickaddalias-1.html:2776,energy,energy,2776,psi4manual/4.0b5/quickaddalias-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/quickaddalias-1.html,2,['energy'],['energy']
Energy Efficiency," e_scf = psi4.get_variable('SCF TOTAL ENERGY'); ce_mp2 = psi4.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = psi4.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; psi4.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; psi4.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; psi4.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); psi4.set_variable('CURRENT ENERGY', e_mp25) # geometry optimizer tracks this variable, permits; # MP2.5 finite difference optimizations; # build string of title banner and print results; banners = ''; banners += """"""psi4.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""psi4.print_out('\\n')\n\n""""""; exec banners. tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); psi4.print_out(tables) # prints nice header and table of all involved quantities to output file. return e_mp25. One final step is necessary. At the end of the aliases.py file, add; the following line.; procedures['energy']['mp2.5'] = run_mp2_5. This permits the newly defined MP2.5 method to be called in the input file; with the following command.; energy('mp2.5'). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Customization: Adding Simple Extensions; Defining a Method Alias. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created usi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/quickaddalias.html:2935,energy,energy,2935,psi4manual/master/quickaddalias.html,https://psicode.org,https://psicode.org/psi4manual/master/quickaddalias.html,1,['energy'],['energy']
Energy Efficiency," e_scf = psi4.get_variable('SCF TOTAL ENERGY'); ce_mp2 = psi4.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = psi4.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; psi4.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; psi4.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; psi4.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); psi4.set_variable('CURRENT ENERGY', e_mp25) # geometry optimizer tracks this variable, permits; # MP2.5 finite difference optimizations; # build string of title banner and print results; banners = ''; banners += """"""psi4.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""psi4.print_out('\\n')\n\n""""""; exec banners. tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); psi4.print_out(tables) # prints nice header and table of all involved quantities to output file. return e_mp25. One final step is necessary. At the end of the aliases.py file, add; the following line.; procedures['energy']['mp2.5'] = run_mp2_5. This permits the newly defined MP2.5 method to be called in the input file; with the following command.; energy('mp2.5'). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Customization: Adding Simple Extensions; Defining a Method Alias. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/quickaddalias-1.html:2926,energy,energy,2926,psi4manual/1.4.0/quickaddalias-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/quickaddalias-1.html,2,['energy'],['energy']
Energy Efficiency," e_scf = psi4.get_variable('SCF TOTAL ENERGY'); ce_mp2 = psi4.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = psi4.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; psi4.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; psi4.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; psi4.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); psi4.set_variable('CURRENT ENERGY', e_mp25) # geometry optimizer tracks this variable, permits; # MP2.5 finite difference optimizations; # build string of title banner and print results; banners = ''; banners += """"""psi4.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""psi4.print_out('\\n')\n\n""""""; exec banners. tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); psi4.print_out(tables) # prints nice header and table of all involved quantities to output file. return e_mp25. One final step is necessary. At the end of the aliases.py file, add; the following line.; procedures['energy']['mp2.5'] = run_mp2_5. This permits the newly defined MP2.5 method to be called in the input file; with the following command.; energy('mp2.5'). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Customization: Adding Simple Extensions; Defining a Method Alias. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/quickaddalias-1.html:2926,energy,energy,2926,psi4manual/1.5.0/quickaddalias-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/quickaddalias-1.html,2,['energy'],['energy']
Energy Efficiency," e_scf = psi4.get_variable('SCF TOTAL ENERGY'); ce_mp2 = psi4.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = psi4.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; psi4.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; psi4.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; psi4.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); psi4.set_variable('CURRENT ENERGY', e_mp25) # geometry optimizer tracks this variable, permits; # MP2.5 finite difference optimizations; # build string of title banner and print results; banners = ''; banners += """"""psi4.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""psi4.print_out('\\n')\n\n""""""; exec banners. tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); psi4.print_out(tables) # prints nice header and table of all involved quantities to output file. return e_mp25. One final step is necessary. At the end of the aliases.py file, add; the following line.; procedures['energy']['mp2.5'] = run_mp2_5. This permits the newly defined MP2.5 method to be called in the input file; with the following command.; energy('mp2.5'). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Customization: Adding Simple Extensions; Defining a Method Alias. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; .",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/quickaddalias.html:2926,energy,energy,2926,psi4manual/1.6.x/quickaddalias.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/quickaddalias.html,1,['energy'],['energy']
Energy Efficiency," e_scf = psi4.get_variable('SCF TOTAL ENERGY'); ce_mp2 = psi4.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = psi4.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; psi4.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; psi4.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; psi4.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); psi4.set_variable('CURRENT ENERGY', e_mp25) # geometry optimizer tracks this variable, permits; # MP2.5 finite difference optimizations; # build string of title banner and print results; banners = ''; banners += """"""psi4.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""psi4.print_out('\\n')\n\n""""""; exec banners. tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); psi4.print_out(tables) # prints nice header and table of all involved quantities to output file. return e_mp25. One final step is necessary. At the end of the aliases.py file, add; the following line.; procedures['energy']['mp2.5'] = run_mp2_5. This permits the newly defined MP2.5 method to be called in the input file; with the following command.; energy('mp2.5'). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Customization: Adding Simple Extensions; Defining a Method Alias. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/quickaddalias.html:2926,energy,energy,2926,psi4manual/1.7.x/quickaddalias.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/quickaddalias.html,1,['energy'],['energy']
Energy Efficiency," e_scf = psi4.get_variable('SCF TOTAL ENERGY'); ce_mp2 = psi4.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = psi4.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; psi4.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; psi4.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; psi4.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); psi4.set_variable('CURRENT ENERGY', e_mp25) # geometry optimizer tracks this variable, permits; # MP2.5 finite difference optimizations; # build string of title banner and print results; banners = ''; banners += """"""psi4.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""psi4.print_out('\\n')\n\n""""""; exec banners. tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); psi4.print_out(tables) # prints nice header and table of all involved quantities to output file. return e_mp25. One final step is necessary. At the end of the aliases.py file, add; the following line.; procedures['energy']['mp2.5'] = run_mp2_5. This permits the newly defined MP2.5 method to be called in the input file; with the following command.; energy('mp2.5'). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Customization: Adding Simple Extensions; Defining a Method Alias. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/quickaddalias.html:2928,energy,energy,2928,psi4manual/1.8.x/quickaddalias.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/quickaddalias.html,1,['energy'],['energy']
Energy Efficiency," e_scf = psi4.get_variable('SCF TOTAL ENERGY'); ce_mp2 = psi4.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = psi4.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; psi4.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; psi4.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; psi4.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); psi4.set_variable('CURRENT ENERGY', e_mp25) # geometry optimizer tracks this variable, permits; # MP2.5 finite difference optimizations; # build string of title banner and print results; banners = ''; banners += """"""psi4.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""psi4.print_out('\\n')\n\n""""""; exec banners. tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); psi4.print_out(tables) # prints nice header and table of all involved quantities to output file. return e_mp25. One final step is necessary. At the end of the aliases.py file, add; the following line.; procedures['energy']['mp2.5'] = run_mp2_5. This permits the newly defined MP2.5 method to be called in the input file; with the following command.; energy('mp2.5'). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Customization: Adding Simple Extensions; Defining a Method Alias. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/quickaddalias.html:2928,energy,energy,2928,psi4manual/1.9.x/quickaddalias.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/quickaddalias.html,1,['energy'],['energy']
Energy Efficiency," each step in the optimization. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (string) – 'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; Hartree–Fock (HF) or density functional theory (DFT) [manual]. hf; HF self consistent field (SCF) [manual]. dcft; density cumulant functional theory [manual]. mp2; 2nd-order Møller–Plesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order Møller–Plesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized second-order MP perturbation theory [manual]. omp3; orbital-optimized third-order MP perturbation theory [manual]. omp2.5; orbital-optimized MP2.5 [manual]. lccd; Linear CCD [manual] [details]. olccd; orbital optimized LCCD [manual]. ccd; coupled cluster doubles (CCD) [manual]. ccsd; coupled cluster singles and doubles (CCSD) [manual] [details]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual] [details]. eom-ccsd; equation of motion (EOM) CCSD [manual]. Examples:. >>> # [1] Analytic hf optimization; >>>",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/opt-1.html:2798,energy,energy,2798,psi4manual/1.3.2/opt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/opt-1.html,2,['energy'],['energy']
Energy Efficiency," each step in the optimization. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (string) – 'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; Hartree–Fock (HF) or density functional theory (DFT) [manual]. hf; HF self consistent field (SCF) [manual]. dcft; density cumulant functional theory [manual]. mp2; 2nd-order Møller–Plesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order Møller–Plesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized second-order MP perturbation theory [manual]. omp3; orbital-optimized third-order MP perturbation theory [manual]. omp2.5; orbital-optimized MP2.5 [manual]. lccd; Linear CCD [manual] [details]. olccd; orbital optimized LCCD [manual]. ccd; coupled cluster doubles (CCD) [manual]. ccsd; coupled cluster singles and doubles (CCSD) [manual] [details]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual] [details]. eom-ccsd; equation of motion (EOM) CCSD [manual]. name; calls method DFT [manual]. b1lyp; B1LYP Hyb-",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.driver.opt-1.html:2172,energy,energy,2172,psi4manual/1.3.2/api/psi4.driver.opt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.driver.opt-1.html,4,['energy'],['energy']
Energy Efficiency," ecc, aobasis. cfour/pywrap-db1; Database calculation, so no molecule section in input file. Portions of the full databases, restricted by subset keyword, are computed by sapt0 and dfmp2 methods. cfour/dfmp2-1; MP2/cc-PVDZ computation of formic acid dimer binding energy using automatic counterpoise correction. Monomers are specified using Cartesian coordinates. cfour/psi-a24-grad; geometry after three optimization cycles on A24 database, cfour matches psi4. cfour/pywrap-basis; SAPT calculation on bimolecular complex where monomers are unspecified so driver auto-fragments it. Basis set and auxiliary basis sets are assigned by atom type. cfour/sp-rhf-ccsd_t_-fc; single-point CCSD(T)/qz2p on water with ecc, aobasis, and frozen-core. cfour/scf4; RHF cc-pVDZ energy for water, automatically scanning the symmetric stretch and bending coordinates using Python’s built-in loop mechanisms. The geometry is apecified using a Z-matrix with variables that are updated during the potential energy surface scan, and then the same procedure is performed using polar coordinates, converted to Cartesian coordinates. cfour/sp-rhf-cc3; single-point CC3/qz2p on water. cfour/kw-5; Basis set spherical/Cartesian with basis and cfour_spherical. cfour/sp-uhf-ccsd_t_; single-point CCSD(T)/qz2p. cfour/sp-rhf-ccsd-ao; single-point CCSD/qz2p on water with aobasis. cfour/kw-2; testing best practices options, part ii. cfour/sp-rohf-ccsd_t_; single-point CCSD(T)/qz2p on NH2. cfour/mints5; geometries from a variety of input formats. references from psi4, testing whether geometry strings read identically for psi4/cfour. cfour/sp-rohf-scf; single-point HF/qz2p on NH2. cfour/opt-rhf-ccsd_t_; optimization CCSD(T)/dzp on water. cfour/sp-uhf-cc3; single-point CC3/qz2p on NH2. cfour/psi-rhf-scsmp2; MP2 energy components. Checks that computed identically between cfour and psi4. cfour/psi-ghost-grad; MP2 optimization of dimers with one momomer ghosted. Gradients after three opt cycles are compared with those from ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_cfour-1.html:3668,energy,energy,3668,psi4manual/1.2.1/autodoc_testsuite_cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_cfour-1.html,6,['energy'],['energy']
Energy Efficiency," electrons. These are set in the REFERENCE option.; Note that there are not equivalents to ROHF or CUHF, e.g., no ROKS or CUKS. This; is because ROHF is implicitly assumed to be followed by a correlated method; which can break the positive definiteness of the spin polarization. KS-DFT with; the true functional is expected to be the final step, thus restricting the; solution to positive definite spin polarization is not physical. See the; section in [Szabo:1982] on methyl radical for an example. Functional Selection¶; PSI4 features an extensive list of LSDA, GGA, Meta, Hybrid, LRC, and -D; functionals. These can be specified by a variety of means. Perhaps the simplest; is to use the functional name as the energy procedure call:; 1energy('b3lyp'). Note that if you are running an unrestricted computation, you should set the; REFERENCE option before the call to energy:; 1; 2set reference uks; energy('b3lyp'). The functional may also be manually specified by calling energy (or any driver function); with a dft_functional argument:; 1energy('scf', dft_functional = 'b3lyp'). Another alternative is providing a specially crafted dict-ionary to the dft_functional; argument:; 1; 2custom_functional = { ""name"": ""my_unique_name"", ... }; energy('scf', dft_functional = custom_functional). For further details about this so called dict_func syntax, see; Advanced Functional Use and Manipulation.; For hybrid functionals, the fraction of exact exchange is controlled by the; DFT_ALPHA option. For the LRC functionals, the fraction of long-range; Hartree–Fock and short-range DFA is controlled by the DFT_OMEGA option.; Changing these will override the default behavior of the requested functional.; A brief summary of some of the more notable functionals in PSI4, and links; to the complete listing of all functionals of each class are presented below:. All Functionals; All functionals, including LSDA-only functionals. Note that here and; throughout, functionals which end in _X or _C are exchange",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/dft-1.html:14947,energy,energy,14947,psi4manual/1.3.2/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/dft-1.html,2,['energy'],['energy']
Energy Efficiency," else None,; 'epsilon_b': wfn.epsilon_b().to_array() if wfn.epsilon_b() else None,; 'frequencies': wfn.frequencies().to_array() if wfn.frequencies() else None; },; 'dimension': {; 'doccpi': wfn.doccpi().to_tuple(),; 'frzcpi': wfn.frzcpi().to_tuple(),; 'frzvpi': wfn.frzvpi().to_tuple(),; 'nalphapi': wfn.nalphapi().to_tuple(),; 'nbetapi': wfn.nbetapi().to_tuple(),; 'nmopi': wfn.nmopi().to_tuple(),; 'nsopi': wfn.nsopi().to_tuple(),; 'soccpi': wfn.soccpi().to_tuple(); },; 'int': {; 'nalpha': wfn.nalpha(),; 'nbeta': wfn.nbeta(),; 'nfrzc': wfn.nfrzc(),; 'nirrep': wfn.nirrep(),; 'nmo': wfn.nmo(),; 'nso': wfn.nso(),; 'print': wfn.get_print(),; },; 'string': {; 'name': wfn.name(),; 'module': wfn.module(),; 'basisname': wfn.basisset().name(); },; 'boolean': {; 'PCM_enabled': wfn.PCM_enabled(),; 'same_a_b_dens': wfn.same_a_b_dens(),; 'same_a_b_orbs': wfn.same_a_b_orbs(),; 'density_fitted': wfn.density_fitted(),; 'basispuream': wfn.basisset().has_puream(); },; 'float': {; 'energy': wfn.energy(),; 'efzc': wfn.efzc(),; 'dipole_field_x': wfn.get_dipole_field_strength()[0],; 'dipole_field_y': wfn.get_dipole_field_strength()[1],; 'dipole_field_z': wfn.get_dipole_field_strength()[2]; },; 'floatvar': wfn.scalar_variables(),; 'matrixarr': {k: v.to_array() for k, v in wfn.array_variables().items()}; } # yapf: disable. if filename is not None:; if not filename.endswith('.npy'): filename += '.npy'; np.save(filename, wfn_data, allow_pickle=True). return wfn_data. core.Wavefunction.to_file = _core_wavefunction_to_file. ## Python JK helps. @staticmethod; def _core_jk_build(orbital_basis: core.BasisSet, aux: core.BasisSet = None, jk_type: str = None, do_wK: bool = None, memory: int = None) -> core.JK:; """"""; Constructs a Psi4 JK object from an input basis. Parameters; ----------; orbital_basis; Orbital basis to use in the JK object.; aux; Optional auxiliary basis set for density-fitted tensors. Defaults; to the DF_BASIS_SCF if set, otherwise the correspond JKFIT basis; to the passed in `orbital",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:9398,energy,energy,9398,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,3,['energy'],['energy']
Energy Efficiency," else:; return None; elif freq_mode == 'reap':; wfn = core.Wavefunction.build(molecule, core.get_global_option('BASIS')). # Assemble Hessian from gradients; # Final disp is undisp, so wfn has mol, G, H general to freq calc; H = core.fd_freq_1(molecule, gradients, irrep) # TODO or moleculeclone?; wfn.set_hessian(H); wfn.set_gradient(G0); wfn.set_frequencies(core.get_frequencies()). # The last item in the list is the reference energy, return it; core.set_variable('CURRENT ENERGY', energies[-1]). core.set_parent_symmetry(''); optstash.restore(); optstash_conv.restore(). _hessian_write(wfn). if return_wfn:; return (wfn.hessian(), wfn); else:; return wfn.hessian(). else:; core.print_out(""""""hessian() will perform frequency computation by finite difference of analytic energies.\n""""""). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash.restore(); optstash_conv.restore(); optstash_conv = driver_util._set_convergence_criterion('energy', lowername, 10, 11, 10, 11, 10). # Shifting the geometry so need to copy the active molecule; moleculeclone = molecule.clone(). # Obtain list of displacements; displacements = core.fd_geoms_freq_0(moleculeclone, irrep); moleculeclone.fix_orientation(True); moleculeclone.reinterpret_coordentry(False). # Record undisplaced symmetry for projection of diplaced point groups; core.set_parent_symmetry(molecule.schoenflies_symbol()). ndisp = len(displacements). # This version is pretty dependent on the reference geometry being last (as it is now); print(' %d displacements needed.' % ndisp); energies = []. # S/R: Write instructions for sow/reap procedure to output file and reap input file; if freq_mode == 'sow':; instructionsO = """"""\n# The frequency sow/reap procedure has been selected through mode='sow'. In addition\n""""""; instructionsO += """"""# to this output file (which contains no quantum chemical calculations), this job\n""""""; instructionsO += """"""# has produced a number of input files (FREQ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html:78181,energy,energy,78181,psi4manual/1.2.1/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html,1,['energy'],['energy']
Energy Efficiency," else:; return ret_ptype. def _findif_schema_to_wfn(findif_model: AtomicResult) -> core.Wavefunction:; """"""Helper function to produce Wavefunction and Psi4 files from a FiniteDifference-flavored AtomicResult."""""". # new skeleton wavefunction w/mol, highest-SCF basis (just to choose one), & not energy; mol = core.Molecule.from_schema(findif_model.molecule.dict(), nonphysical=True); sbasis = ""def2-svp"" if (findif_model.model.basis == ""(auto)"") else findif_model.model.basis; basis = core.BasisSet.build(mol, ""ORBITAL"", sbasis, quiet=True); wfn = core.Wavefunction(mol, basis); if hasattr(findif_model.provenance, ""module""):; wfn.set_module(findif_model.provenance.module). # setting CURRENT E/G/H on wfn below catches Wfn.energy_, gradient_, hessian_; # setting CURRENT E/G/H on core below is authoritative P::e record; for qcv, val in findif_model.extras[""qcvars""].items():; for obj in [core, wfn]:; obj.set_variable(qcv, val). return wfn. def hessian_write(wfn: core.Wavefunction):; if core.get_option('FINDIF', 'HESSIAN_WRITE'):; filename = core.get_writer_file_prefix(wfn.molecule().name()) + "".hess""; with open(filename, 'wb') as handle:; qcdb.hessparse.to_string(np.asarray(wfn.hessian()), handle, dtype='psi4'). def gradient_write(wfn: core.Wavefunction):; if core.get_option('FINDIF', 'GRADIENT_WRITE'):; filename = core.get_writer_file_prefix(wfn.molecule().name()) + "".grad""; qcdb.gradparse.to_string(np.asarray(wfn.gradient()),; filename,; dtype='GRD',; mol=wfn.molecule(),; energy=wfn.energy()). def _rms(arr: Union[core.Matrix, np.ndarray]) -> float:; """"""Compute root-mean-square of array, be it Psi4 or NumPy array.""""""; if isinstance(arr, np.ndarray):; return np.sqrt(np.mean(np.square(arr))); else:; return arr.rms(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.10a1.dev61;  · . PSI4. Module code; psi4.driver.driver_findif. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html:54688,energy,energy,54688,psi4manual/master/_modules/psi4/driver/driver_findif.html,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_findif.html,2,['energy'],['energy']
Energy Efficiency," else:; tot_e = True; nbody_range = list(energy_body_dict); nbody_range.sort(); for n in nbody_range:; delta_e = (energy_body_dict[n] - previous_e); delta_e_kcal = delta_e * constants.hartree2kcalmol; int_e_kcal = (; energy_body_dict[n] - energy_body_dict[1]) * constants.hartree2kcalmol if not embedding else np.nan; if tot_e:; core.print_out("""""" %4s %20.12f %20.12f %20.12f\n"""""" % (n, energy_body_dict[n], int_e_kcal,; delta_e_kcal)); else:; core.print_out("""""" %4s %20s %20.12f %20.12f\n"""""" % (n, ""N/A"", int_e_kcal,; delta_e_kcal)); previous_e = energy_body_dict[n]; core.print_out(""\n""). [docs]def nbody_gufunc(func: Union[str, Callable], method_string: str, **kwargs):; """"""; Computes the nbody interaction energy, gradient, or Hessian depending on input.; This is a generalized universal function for computing interaction and total quantities. :returns: *return type of func* |w--w| The data. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| data and wavefunction with energy/gradient/hessian set appropriately when **return_wfn** specified. :type func: Callable; :param func: ``energy`` || etc. Python function that accepts method_string and a molecule. Returns a; energy, gradient, or Hessian as requested. :type method_string: str; :param method_string: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, lowercase and usually unlabeled. Indicates the computational; method to be passed to func. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element of a tuple. :type bsse_type: str or list; :param bsse_type: ``'cp'`` || ``['nocp', 'vmfc']`` || |dl| ``None`` |dr| || etc. Type of BSSE correction to compute: CP for counterpoise correction, NoCP; for plain supramolecul",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html:4146,energy,energy,4146,psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html,2,['energy'],['energy']
Energy Efficiency," employed in computing interaction energies. Option available; (See Available Databases) only for databases of bimolecular complexes; with non-frozen monomers, e.g., HBC6. symm (boolean) – \(\Rightarrow\) 'on' \(\Leftarrow\) || 'off'; Indicates whether the native symmetry of the database reagents is; employed ('on') or whether it is forced to \(C_1\) symmetry; ('off'). Some computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). zpe (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. benchmark (string) – \(\Rightarrow\) 'default' \(\Leftarrow\) || 'S22A' || etc.; Indicates whether a non-default set of reference energies, if; available (See Available Databases), are employed for the; calculation of error statistics. tabulate (array of strings) – \(\Rightarrow\) [] \(\Leftarrow\) || ['scf total energy', 'natom'] || etc.; Indicates whether to form tables of variables other than the; primary requested energy. Available for any PSI variable. subset (string or array of strings) – Indicates a subset of the full database to run. This is a very; flexible option and can be used in three distinct ways, outlined; below. Note that two take a string and the last takes an array.; See Available Databases for available values. 'small' || 'large' || 'equilibrium'; Calls predefined subsets of the requested database, either; 'small', a few of the smallest database members,; 'large', the largest of the database members, or; 'equilibrium', the equilibrium geometries for a database; composed of dissociation curves. 'BzBz_S' || 'FaOOFaON' || 'ArNe' || 'HB' || etc.; For databases composed of dissociation curves, or otherwise; divided into subsets, individual curves and subsets can be; called by name. Consult the database python files for available; molecular systems (case",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/db-1.html:4032,energy,energy,4032,psi4manual/1.2.1/db-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/db-1.html,6,['energy'],['energy']
Energy Efficiency," energies for the CH3 radical. opt1; SCF STO-3G geometry optimzation, with Z-matrix input. sapt-ecp; sapt0 of charged system in ECP basis set. cc41; RHF-CC2-LR/cc-pVDZ optical rotation of H2O2. gauge = both, omega = (589 355 nm). cbs-xtpl-energy; Extrapolated water energies - density-fitted version. sapt-dft-api; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. sapt-dft-lrc; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. cc2; 6-31G** H2O CCSD optimization by energies, with Z-Matrix input. cc27; Single point gradient of 1-1B2 state of H2O with EOM-CCSD. mp3-grad2; MP3 cc-pVDZ gradient for the NO radical. cc28; CCSD/cc-pVDZ optical rotation calculation (length gauge only) on Z-mat H2O2. dfccsdat2; DF-A-CCSD(T) cc-pVDZ energy for the NH molecule. props4; Electrostatic potential and electric field evaluated on a grid around water. dfccsdat1; DF-CCSD(AT) cc-pVDZ energy for the H2O molecule. dfmp2-2; Density fitted MP2 energy of H2, using density fitted reference and automatic looping over cc-pVDZ and cc-pVTZ basis sets. Results are tabulated using the built in table functions by using the default options and by specifiying the format. dfomp3-grad1; DF-OMP3 cc-pVDZ gradients for the H2O molecule. dfccd-grad1; DF-CCSD cc-pVDZ gradients for the H2O molecule. omp2-4; SCS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. omp3-5; SOS-OMP3 cc-pVDZ geometry optimization for the H2O molecule. pywrap-align; apply linear fragmentation algorithm to a water cluster. cc50; EOM-CC3(ROHF) on CH radical with user-specified basis and properties for particular root. opt-irc-1; Compute the IRC for HOOH torsional rotation at the RHF/DZP level of theory. mp2-h; check that methods can act on single atom. nbody-he-4b; MP2/aug-cc-pvDZ many body energies of an arbitrary Helium complex, addressing 4-body formulas. dft-ghost; DFT Functional Test for Range-Seperated Hybrids and Ghost atoms. ao-dfcasscf-sp; CASSCF/6-31G** energy point. sapt0-d; Tests SAPT0-D",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html:26227,energy,energy,26227,psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency," energies of an arbitrary Helium complex, addressing 4-body formulas. sapt10; usapt example with empty beta due to frozen core. mints10; H2 with tiny basis set, to test basis set parser’s handling of integers. dfscf-bz2; Benzene Dimer DF-HF/cc-pVDZ. sapt2; SAPT0 aug-cc-pVDZ computation of the benzene-methane interaction energy, using the aug-pVDZ-JKFIT DF basis for SCF, the aug-cc-pVDZ-RI DF basis for SAPT0 induction and dispersion, and the aug-pVDZ-JKFIT DF basis for SAPT0 electrostatics and induction. This example uses frozen core as well as asyncronous I/O while forming the DF integrals and CPHF coefficients. fsapt-d; Tests SAPT0-D corrections, with a variety of damping functions/parameters. matrix1; An example of using BLAS and LAPACK calls directly from the Psi input file, demonstrating matrix multiplication, eigendecomposition, Cholesky decomposition and LU decomposition. These operations are performed on vectors and matrices provided from the Psi library. omp2-3; OMP2 cc-pVDZ energy for the NO radical. cc21; ROHF-EOM-CCSD/DZ analytic gradient lowest \(^{2}A_1\) excited state of H2O+ (B1 excitation). opt1-fd; SCF STO-3G geometry optimzation, with Z-matrix input, by finite-differences. casscf-semi; CASSCF/6-31G** energy point. Check energy with frozen core/virtual orbs. after semicanonicalization. opt12; SCF cc-pVDZ geometry optimzation of ketene, starting from bent structure. scf-coverage; Lithium test for coverage. cc27; Single point gradient of 1-1B2 state of H2O with EOM-CCSD. omp2p5-1; OMP2.5 cc-pVDZ energy for the H2O molecule. dft1-alt; DFT Functional Test. x2c-perturb-h; Test SFX2C-1e with a static electric field on He aug-cc-pVTZ. dfcasscf-fzc-sp; CASSCF/6-31G** energy point. nbody-intermediates; HF/cc-pVDZ many body energies of an arbitrary noble gas trimer complex Size vs cost tradeoff is rough here. fd-freq-gradient-large; SCF DZ finite difference frequencies by gradients for C4NH4. dft-jk; DFT JK on-disk test. dct1; DC-06, DC-12, ODC-06 and ODC-12 ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html:8113,energy,energy,8113,psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency," energies, optx); energy = function_9pt(rvals, energies, optx); psi4.print_out("" E = %20.14f, x = %14.7f, grad = %20.14f\n"" % (energy, optx, grad)); if abs(grad) < thres:; break; optx -= grad / secd;; psi4.print_out("" Final E = %20.14f, x = %14.7f, grad = %20.14f\n"" % (function_5pt(rvals, energies, optx), optx, grad));. if optx < min(rvals):; raise Exception(""Minimum energy point is outside range of points provided. Use a lower range of r values.""); if optx > max(rvals):; raise Exception(""Minimum energy point is outside range of points provided. Use a higher range of r values.""). if (npoints == 5):; energy = function_5pt(rvals, energies, optx); first = first_deriv_5pt(rvals, energies, optx); secd = second_deriv_5pt(rvals, energies, optx) * p4const.psi_hartree2aJ; third = third_deriv_5pt(rvals, energies, optx) * p4const.psi_hartree2aJ; fourth = fourth_deriv_5pt(rvals, energies, optx) * p4const.psi_hartree2aJ; elif (npoints == 9):; energy = function_9pt(rvals, energies, optx); first = first_deriv_9pt(rvals, energies, optx); secd = second_deriv_9pt(rvals, energies, optx) * p4const.psi_hartree2aJ; third = third_deriv_9pt(rvals, energies, optx) * p4const.psi_hartree2aJ; fourth = fourth_deriv_9pt(rvals, energies, optx) * p4const.psi_hartree2aJ. psi4.print_out(""\nEquilibrium Energy %20.14f Hartrees\n"" % energy); psi4.print_out(""Gradient %20.14f\n"" % first); psi4.print_out(""Quadratic Force Constant %14.7f MDYNE/A\n"" % secd); psi4.print_out(""Cubic Force Constant %14.7f MDYNE/A**2\n"" % third); psi4.print_out(""Quartic Force Constant %14.7f MDYNE/A**3\n"" % fourth). hbar = p4const.psi_h / (2.0 * pi); mu = ((m1*m2)/(m1+m2))*p4const.psi_amu2kg; we = 5.3088375e-11*sqrt(secd/mu); wexe = (1.2415491e-6)*(we/secd)**2 * ((5.0*third*third)/(3.0*secd)-fourth). # Rotational constant: Be; I = ((m1*m2)/(m1+m2)) * p4const.psi_amu2kg * (optx * angstrom_to_meter)**2; B = p4const.psi_h / (8.0 * pi**2 * p4const.psi_c * I). # alpha_e and quartic centrifugal distortion constant; ae = -(6.0 * B**2 / ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/diatomic.html:4088,energy,energy,4088,psi4manual/4.0b5/_modules/diatomic.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/diatomic.html,2,['energy'],['energy']
Energy Efficiency," energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CBS TOTAL ENERGY <CBSTOTALENERGY>`; * :psivar:`CBS REFERENCE ENERGY <CBSREFERENCEENERGY>`; * :psivar:`CBS CORRELATION ENERGY <CBSCORRELATIONENERGY>`; * :psivar:`CURRENT ENERGY <CURRENTENERGY>`; * :psivar:`CURRENT REFERENCE ENERGY <CURRENTREFERENCEENERGY>`; * :psivar:`CURRENT CORRELATION ENERGY <CURRENTCORRELATIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - Not all methods hooked in through PSI variables, configuration interaction and arbitrary order MP in particular. - No scheme defaults for given basis zeta number, so scheme must be specified explicitly. - No way to tell function to boost fitting basis size for all calculations. - No way to extrapolate def2 family basis sets. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in several; sequential stages (scf, corl, delta, delta2, delta3, delta4, delta5) covering treatment; of the reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction, etc.. Each is activated by its; stage_wfn keyword and is only allowed if all preceding stages are active. .. include:: cbs_eqn.rst. * Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy. The cbs() function requires, at a minimum, ``name='scf'`` and ``scf_basis``; keywords to be specified for reference-step only jobs and ``name`` and; ``corl_basis`` keywords for correlated jobs. The following energy methods have been set up for cbs(). .. hlist::; :columns: 5. * scf; * mp2; * mp2.5; * mp3; * mp4(sdq); * mp4; * omp2; * omp3; * ocepa; * cepa0; * cepa(0); * cepa(1); * cepa(3); * acpf; * aqcc; * qcisd; * cc2; * ccsd; * fno-df-ccsd; * bccd; * cc3; * qcisd(t); * ccsd(t); * fno-df-ccsd(t); * bccd(t); * cisd; * c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:54030,energy,energy,54030,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,4,['energy'],['energy']
Energy Efficiency," energy surface scan, and then the same procedure is performed using polar coordinates, converted to Cartesian coordinates. cisd-h2o-clpse; 6-31G** H2O Test CISD Energy Point with subspace collapse. dfmp2_2; Density fitted MP2 energy of H2, using density fitted reference and automatic looping over cc-pVDZ and cc-pVTZ basis sets. Results are tabulated using the built in table functions by using the default options and by specifiying the format. cc24; Single point gradient of 1-2B1 state of H2O+ with EOM-CCSD. cc14; ROHF-CCSD/cc-pVDZ CH2 geometry optimization via analytic gradients. cc29; CCSD/cc-pVDZ optical rotation calculation (both gauges) on Cartesian H2O2. dfscf-bz2; Benzene Dimer DF-HF/cc-pVDZ. matrix1; An example of using BLAS and LAPACK calls directly from the Psi input file, demonstrating matrix multiplication, eigendecomposition, Cholesky decomposition and LU decomposition. These operations are performed on vectors and matrices provided from the Psi library. cc36; CC2(RHF)/cc-pVDZ energy of H2O. mp2_1; All-electron MP2 6-31G** geometry optimization of water. cc37; CC2(UHF)/cc-pVDZ energy of H2O+. psimrcc-ccsd_t-4; Mk-MRCCSD(T) single point. O$_3` state described using the Ms = 0 component of the singlet. Uses TCSCF orbitals. zaptn-nh2; ZAPT(n)/6-31G NH2 Energy Point, with n=2-25. cc5; RHF CCSD(T) aug-cc-pvtz frozen-core energy of C4NH4 Anion. mints1; Symmetry tests for a range of molecules. This doesn’t actually compute any energies, but serves as an example of the many ways to specify geometries in Psi4. props2; DF-SCF cc-pVDZ of benzene-hydronium ion, scanning the dissociation coordinate with Python’s built-in loop mechanism. The geometry is specified by a Z-matrix with dummy atoms, fixed parameters, updated parameters, and separate charge/multiplicity specifiers for each monomer. One-electron properties computed for dimer and one monomer. tu5-sapt; Example SAPT computation for ethene*ethine (i.e., ethylene*acetylene), test case 16 from the S22 database. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodoc_testsuite-1.html:15557,energy,energy,15557,psi4manual/4.0b2/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodoc_testsuite-1.html,4,['energy'],['energy']
Energy Efficiency," energy term in EFP computation?. Type: boolean; Default: true. EFP_DISP_DAMPING¶. Fragment-fragment dispersion damping type. TT is a damping formula by Tang and Toennies. OVERLAP is overlap-based dispersion damping. Type: string; Possible Values: TT, OVERLAP, OFF; Default: OVERLAP. EFP_ELST¶. Do include electrostatics energy term in EFP computation?. Type: boolean; Default: true. EFP_ELST_DAMPING¶. Fragment-fragment electrostatic damping type. SCREEN is a damping formula based on screen group in the EFP potential. OVERLAP is damping that computes charge penetration energy. Type: string; Possible Values: SCREEN, OVERLAP, OFF; Default: SCREEN. EFP_EXCH¶. Do include exchange repulsion energy term in EFP computation?. Type: boolean; Default: true. EFP_IND¶. Do include polarization energy term in EFP computation? (EFP_POL c. v1.1). Type: boolean; Default: true. EFP_IND_DAMPING¶. Fragment-fragment polarization damping type. TT is a damping formula like Tang and Toennies. (EFP_POL_DAMPING c. v1.1). Type: string; Possible Values: TT, OFF; Default: TT. EFP_QM_ELST¶. Do include electrostatics energy term in QM/EFP computation? (QMEFP_ELST c. v1.1). Type: boolean; Default: true. EFP_QM_IND¶. Do include polarization energy term in QM/EFP computation? (QMEFP_POL c. v1.1). Type: boolean; Default: true. PRINT¶. The amount of information printed to the output file. Type: integer; Default: 1. Expert¶. DERTYPE¶. Do EFP gradient?. Type: string; Possible Values: NONE, FIRST; Default: NONE. QMEFP¶. Do turn on QM/EFP terms?. Type: boolean; Default: false. table of contents. EFP; General; EFP_DISP; EFP_DISP_DAMPING; EFP_ELST; EFP_ELST_DAMPING; EFP_EXCH; EFP_IND; EFP_IND_DAMPING; EFP_QM_ELST; EFP_QM_IND; PRINT. Expert; DERTYPE; QMEFP. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; EFP. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodir_options_c/module__efp-1.html:1356,energy,energy,1356,psi4manual/1.4.0/autodir_options_c/module__efp-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/module__efp-1.html,4,['energy'],['energy']
Energy Efficiency," energy term in EFP computation?. Type: boolean; Default: true. EFP_DISP_DAMPING¶. Fragment-fragment dispersion damping type. TT is a damping formula by Tang and Toennies. OVERLAP is overlap-based dispersion damping. Type: string; Possible Values: TT, OVERLAP, OFF; Default: OVERLAP. EFP_ELST¶. Do include electrostatics energy term in EFP computation?. Type: boolean; Default: true. EFP_ELST_DAMPING¶. Fragment-fragment electrostatic damping type. SCREEN is a damping formula based on screen group in the EFP potential. OVERLAP is damping that computes charge penetration energy. Type: string; Possible Values: SCREEN, OVERLAP, OFF; Default: SCREEN. EFP_EXCH¶. Do include exchange repulsion energy term in EFP computation?. Type: boolean; Default: true. EFP_IND¶. Do include polarization energy term in EFP computation? (EFP_POL c. v1.1). Type: boolean; Default: true. EFP_IND_DAMPING¶. Fragment-fragment polarization damping type. TT is a damping formula like Tang and Toennies. (EFP_POL_DAMPING c. v1.1). Type: string; Possible Values: TT, OFF; Default: TT. EFP_QM_ELST¶. Do include electrostatics energy term in QM/EFP computation? (QMEFP_ELST c. v1.1). Type: boolean; Default: true. EFP_QM_IND¶. Do include polarization energy term in QM/EFP computation? (QMEFP_POL c. v1.1). Type: boolean; Default: true. PRINT¶. The amount of information printed to the output file. Type: integer; Default: 1. Expert¶. DERTYPE¶. Do EFP gradient?. Type: string; Possible Values: NONE, FIRST; Default: NONE. QMEFP¶. Do turn on QM/EFP terms?. Type: boolean; Default: false. table of contents. EFP; General; EFP_DISP; EFP_DISP_DAMPING; EFP_ELST; EFP_ELST_DAMPING; EFP_EXCH; EFP_IND; EFP_IND_DAMPING; EFP_QM_ELST; EFP_QM_IND; PRINT. Expert; DERTYPE; QMEFP. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Appendices; Keywords by Module; EFP. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodir_options_c/module__efp-1.html:1356,energy,energy,1356,psi4manual/1.5.0/autodir_options_c/module__efp-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodir_options_c/module__efp-1.html,4,['energy'],['energy']
Energy Efficiency," energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, 'xtpl_highest_1', which uses the best basis; set available. See Extrapolation Schemes for all available schemes. Parameters. scf_scheme (Callable) – \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || scf_xtpl_helgaker_3 || etc.; Indicates the basis set extrapolation scheme to be applied to the reference energy.; Defaults to scf_xtpl_helgaker_3() if three valid basis sets; present in psi4.driver.driver_cbs.scf_basis, scf_xtpl_helgaker_2() if two valid basis; sets present in scf_basis, and xtpl_highest_1() otherwise. xtpl_highest_1(); scf_xtpl_helgaker_3(); scf_xtpl_helgaker_2(); scf_xtpl_truhlar_2(); scf_xtpl_karton_2(). corl_scheme (Callable) – \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in corl_basis and xtpl_highest_1() otherwise. xtpl_highest_1(); corl_xtpl_helgaker_2(). delta_scheme (Callable) – \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta_basis and xtpl_highest_1() otherwise. xtpl_highest_1(); corl_xtpl_helgaker_2(). delta2_scheme (Callable) – \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the second delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta2_basis and xtpl_highest_1() otherwise. xtpl_highest_1(); corl_xtpl_helgaker_2(). scf_alpha (float) – \(\Rightarrow\) 1.63 \",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.cbs-1.html:8494,energy,energy,8494,psi4manual/1.4.0/api/psi4.driver.cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.cbs-1.html,8,['energy'],['energy']
Energy Efficiency," energy(...); E = optimize(...); E = frequency(...); G = gradient(...) # used by optimize(); H = hessian(...) # used by frequency(). For more elaborate post-processing of computations, adding; return_wfn=True keyword argument additionally returns; Wavefunction.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16# power user returns; E, wfn = energy(..., return_wfn=True); E, wfn = optimize(..., return_wfn=True); E, wfn = frequency(..., return_wfn=True); G, wfn = gradient(..., return_wfn=True) # used by optimize(); H, wfn = hessian(..., return_wfn=True) # used by frequency(). # print gradient array and its rms; wfn.gradient.print_out(); print wfn.gradient().rms(). # format output for other programs; molden(wfn, 'mycalc.molden'). # access array in another format; np.array(wfn.hessian()). Loops¶; Python provides many control structures, any of which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:; 1; 2; 3; 4basis_sets = [""cc-pVDZ"", ""cc-pVTZ"", ""cc-pVQZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of basis_sets is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that basis_set is a; Python variable, not a string, by prefixing it with a dollar sign.; The geometry specification supports delayed initialization of variable,; which permits potential energy scans. As an example, we can scan both the; angle and bond length in water:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16molecule h2o{; O; H 1 R; H 1 R 2 A; }. Rvals = [0.9, 1.0, 1.1]; Avals = range(102, 106, 2). set basis cc-pvdz; set scf e_convergence=11; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('scf'). The declarations of Rvals and Avals are both completely standard Python syntax.; Having named our molecule h2o we can then set the values of R and A within",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psithoninput-1.html:12012,energy,energy,12012,psi4manual/1.1.0/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psithoninput-1.html,6,['energy'],['energy']
Energy Efficiency," energy(cbs, corl_wfn='mp2', corl_basis='cc-pv[dt]z'); energy(cbs, cbs_metadata=[{""wfn"": ""hf"", ""basis"": ""cc-pvtz""}, {""wfn"": ""mp2"", ""basis"": ""cc-pv[dt]z""}]). A CCSD(T) DT coupled-cluster correction atop a TQ MP2 extrapolation; geometry optimization can also be accessed through the first item below more; conveniently than the equivalent second and third items. optimize('mp2/cc-pv[tq]z + D:ccsd(t)/cc-pvdz'); optimize(cbs, corl_wfn='mp2', corl_basis='cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='cc-pvdz'); optimize(cbs, cbs_metadata=[{""wfn"": ""hf"", ""basis"": ""cc-pvqz""}, {""wfn"": ""mp2"", ""basis"": ""cc-pv[tq]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pvdz""}]). Many examples can be found at cbs-xtpl-energy,; cbs-xtpl-gradient, cbs-xtpl-opt,; cbs-xtpl-freq, cbs-xtpl-func,; cbs-xtpl-wrapper, cbs-xtpl-dict. psi4.cbs(name[, scf_basis, scf_scheme, corl_wfn, corl_basis, corl_scheme, delta_wfn, delta_wfn_lesser, delta_basis, delta_scheme, delta2_wfn, delta2_wfn_lesser, delta2_basis, delta2_scheme, cbs_metadata])[source]¶; Function to define a multistage energy method from combinations of; basis set extrapolations and delta corrections and condense the; components into a minimum number of calculations. Aliases:complete_basis_set(). Returns:(float) – Total electronic energy in Hartrees. PSI variables:. CBS TOTAL ENERGY; CBS REFERENCE ENERGY; CBS CORRELATION ENERGY; CURRENT ENERGY; CURRENT REFERENCE ENERGY; CURRENT CORRELATION ENERGY. Caution; Some features are not yet implemented. Buy a developer a coffee. No way to tell function to boost fitting basis size for all calculations.; Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in several; sequential stages (scf, corl, delta1, delta2, … ) covering treatment; of the reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction, etc.. Each is activated by its; stage_wfn keyword, or as a field in the `cbs_metadata` list, an",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/cbs-1.html:1703,energy,energy,1703,psi4manual/1.3.2/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/cbs-1.html,2,['energy'],['energy']
Energy Efficiency," enough disk space for the; OUT_OF_CORE algorithm.; DF; A density-fitted algorithm designed for computations with thousands of basis; functions. This algorithm is highly optimized, and is threaded with a mixture of; parallel BLAS and OpenMP. Note that this algorithm should use the -JKFIT series; of auxiliary bases, not the -RI or -MP2FIT bases. The default guess for; auxiliary basis set should work for all Dunning bases, otherwise the; DF_BASIS_SCF keyword can be used to manually specify the auxiliary basis.; This algorithm is preferred unless either absolute accuracy is required; [CCSD(T)] or a -JKFIT auxiliary basis is unavailable for the; primary basis/atoms involved. For some of these algorithms, Schwarz and/or density sieving can be used to; identify negligible integral contributions in extended systems. To activate; sieving, set the INTS_TOLERANCE keyword to your desired cutoff; (1.0E-12 is recommended for most applications). Recommendations¶; The SCF code is already quite flexible and powerful, with new features being; added weekly. We have tried as much as possible to keep the number of options to; a minimum, and to allow all options to be used in the presence of all other; options. Below are some rough words of advice about using the SCF code for; practical calculations:. For GUESS, the SAD guess is usually your; friend, even for open-shell systems (at the very least, it gets the right; number of electrons, unlike some other programs). For instance, we have found; that a simple SAD guess is often as good as doing a full SCF in a 3-21G basis; and then performing a cast-up, at a fraction of the cost. However, SAD and; DOCC/SOCC arrays do not play very well together at the moment.; For wall time, DF may be a factor of ten or more faster than the exact; integral technologies available in PSI4.; Use DF unless you need absolute accuracy or do not; have a -JKFIT auxiliary set for your primary basis/atom type. Then use; OUT_OF_CORE unless you run out of disk space.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/scf-1.html:18762,power,powerful,18762,psi4manual/4.0b2/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf-1.html,2,['power'],['powerful']
Energy Efficiency," eom-ccsd | equation of motion (EOM) CCSD :ref:`[manual] <sec:eomcc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+. .. _`table:grad_scf`:. .. include:: ../autodoc_dft_opt.rst. .. include:: ../cfour_table_grad.rst. :examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). """"""; kwargs = p4util.kwargs_lower(kwargs). if hasattr(name, '__call__'):; lowername = name; custom_gradient = True; else:; lowername = name.lower(); custom_gradient = False. return_wfn = kwargs.pop('return_wfn', False). return_history = kwargs.pop('return_history', False); if return_history:; # Add wfn once the deep copy issues are worked out; step_energies = []; step_gradients = []; step_coordinates = []. # For CBS and nbody wrappers, need to set retention on INTCO file; if custom_gradient or ('/' in lowername) or kwargs.get('bsse_type', None) is not None:; core.IOManager.shared_object().set_specific_re",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html:54448,energy,energy,54448,psi4manual/1.3.2/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html,1,['energy'],['energy']
Energy Efficiency," equations for a given set of x vectors. damping_update(self: psi4.core.HF, arg0: float) → None¶; docstring. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. del_array_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) Matrix QC variable. del_scalar_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) double QC variable. del_variable(key)¶. density_fitted(self: psi4.core.Wavefunction) → bool¶; Returns whether this wavefunction was obtained using density fitting or not. diis(self: psi4.core.HF) → bool¶; docstring. diis_enabled_¶; docstring. diis_manager(self: psi4.core.HF) → psi4.core.DIISManager¶; docstring. diis_start_¶; docstring. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. efzc(self: psi4.core.Wavefunction) → float¶; Returns the frozen-core energy. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunction’s energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Beta Eigenvalues subset. esp_at_nuclei(self: psi4.core.Wavefunction) → psi4.core.Vector¶; returns electrostatic potentials at nuclei. finalize(self: psi4.core.HF) → None¶; Cleans up the the Wavefunction’s temporary data. finalize_energy()¶; Performs stability analysis and calls back SCF with new guess; if needed, Returns the SCF energy. This function should be called; once orbitals are ready for energy/property computations, usually; after iterations() is called. find_occupation(self: psi4",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.cuhf.html:6130,energy,energy,6130,psi4manual/1.3.2/api/psi4.core.cuhf.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.cuhf.html,14,['energy'],['energy']
Energy Efficiency," error will be raised, prompting you to restart the job. As a shortcut, the entire set of dihedral angles can be frozen. A subset can then be unfrozen if desired. set {; freeze_all_dihedrals true; unfreeze_dihedrals ""1 2 3 4""; }. To scan the potential energy surface by optimizing at several fixed values; of the dihedral angle of HOOH. molecule hooh {; 0 1; H 0.850718 0.772960 0.563468; O 0.120432 0.684669 -0.035503; O -0.120432 -0.684669 -0.035503; H -0.850718 -0.772960 0.563468; }. set {; basis cc-pvdz; intrafrag_step_limit 0.1; }. lower_bound = [99.99, 109.99, 119.99, 129.99, 149.99]; upper_bound = [100, 110, 120, 130, 140, 150]; PES = []. for lower, upper in zip(lower_bound, upper_bound):; my_string = f""1 2 3 4 {lower} {upper}""; set optking ranged_dihedral = $my_string; E = optimize('scf'); PES.append((upper, E)). print(""\n\tcc-pVDZ SCF energy as a function of phi\n""); for point in PES:; print(""\t%5.1f%20.10f"" % (point[0], point[1])). To scan the potential energy surface without the RANGED_DIHEDRAL keyword, a zmatrix; can be used. Warning; Rotating dihedrals in large increments without allowing the molecule to relax; in between increments can lead to unphysical geometries with overlapping functional groups in larger molecules,; which may prevent successful constrained optimzations. Furthermore, such a relaxed scan of the PES does; not always procude a result close to an IRC, or even a reaction path along which the energy changes in a; continuous way. molecule hooh {; 0 1; H; O 1 0.95; O 2 1.39 1 103; H 3 0.95 2 103 1 D. D = 99. units ang; }. set {; basis cc-pvdz; intrafrag_step_limit 0.1; frozen_dihedral ("" 1 2 3 4 ""); }. dihedrals = [100, 110, 120, 130, 140, 150]; PES = []. for phi in dihedrals:; hooh.D = phi; E = optimize('scf'); PES.append((phi, E)). print(""\n\tcc-pVDZ SCF energy as a function of phi\n""); for point in PES:; print(""\t%5.1f%20.10f"" % (point[0], point[1])). Multi-Fragment Optimizations¶; In previous versions of optking, the metric for connecting ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/optking.html:8098,energy,energy,8098,psi4manual/master/optking.html,https://psicode.org,https://psicode.org/psi4manual/master/optking.html,1,['energy'],['energy']
Energy Efficiency," et. al., Phys. Rev. Lett., 103, 263201 (2009) and Szalewicz et. al., J. Phys. Chem. Lett., 1, 550-555 (2010). mp3-grad1; MP3 cc-pVDZ gradient for the H2O molecule. scf-ecp; Water-Argon complex with ECP present; check of energies and forces. linK-2; RKS Linear Exchange Algorithm test for benzene. sapt-dft1; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. ao-dfcasscf-sp; CASSCF/6-31G** energy point. cbs-parser; mtd/basis syntax examples. dlpnomp2-3; comparison of DF-MP2 and DLPNO-MP2 with a cartesian basis set. fisapt-siao1; This test case shows an example of running the I-SAPT0/jun-cc-pVDZ computation for 2,4-pentanediol (targeting the intramolecular hydrogen bond between the two hydroxyl groups) The SIAO1 link partitioning algorithm is used. An F-SAPT partitioning follows I-SAPT. omp2-2; OMP2 cc-pVDZ energy with ROHF initial guess orbitals for the NO radical. dft-jk; DFT JK on-disk test. cubeprop-esp; RHF orbitals and density for water. cbs-delta-energy; Extrapolated energies with delta correction. dfcasscf-sp; CASSCF/6-31G** energy point. cc9; UHF-CCSD(T) cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Z-matrix input. dfccd-grad1; DF-CCSD cc-pVDZ gradients for the H2O molecule. fsapt-d; Tests SAPT0-D corrections, with a variety of damping functions/parameters. dforemp-grad1; density fitted OO-REMP/cc-pVDZ engrad single points for the H2O molecule. scf-hess4; DF SCF 6-31G UHFl vs RHF test Tests DF UHF hessian code for Ca = Cb. dft-vv10; He Dimer VV10 functional test. notes: DFT_VV10_B/C overwrites the NL_DISPERSION_PARAMETERS tuple updated ‘bench’ reference values for new BraggSlater radii. dct-grad4; Unrestricted DF-DCT ODC-12 gradient for O2 with cc-pVTZ/cc-pVTZ-RI standard/auxiliary basis set. dfomp3-grad2; DF-OMP3 cc-pVDZ gradients for the H2O+ cation. cc12; Single point energies of multiple excited states with EOM-CCSD. fnocc1; Test QCISD(T) for H2O/cc-pvdz Energy. dfmp2-grad3; DF-MP2 cc-pVDZ gradients for the H",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html:31709,energy,energy,31709,psi4manual/master/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency," etc. Indicates the basis set extrapolation scheme to be applied to the fifth delta correction; to the correlation energy. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> cbs('scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> cbs('mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> cbs('scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> cbs('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] cbs() coupled with database(); >>> database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='sto-3g'). >>> # [8] cbs() coupled with optimize(); >>> optimize('mp2', corl_basis='cc-pV[DT]Z', corl_scheme=corl_xtpl_helgaker_2, func=cbs). """"""; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional argumen",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:62506,energy,energy,62506,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,1,['energy'],['energy']
Energy Efficiency," example can be found in; tu1-h2o-energy.; You can run it if you wish.; Once PSI4 is in your path (see the User Configuration; section of the installation instructions), you can run this computation by typing; >>> psi4 input.dat output.dat. If everything goes well, the computation should complete and should report; a final restricted Hartree–Fock energy in a section like this:; Energy converged. @RHF Final Energy: -76.02663273410671. By default, the energy should be converged to about , so agreement; is only expected for about the first 6 digits after the decimal. If the; computation does not complete, there is probably a problem with the; compilation or installation of the program (see the installation; instructions in Sec. Compiling and Installing).; This very simple input is sufficient to run the requested information.; Notice that we didn’t tell the program some otherwise useful information; like the charge on the molecule (0, it’s neutral), the spin multiplicity; (1 for a closed-shell molecule with all electrons paired), or the reference; wavefunction to use (restricted Hartree–Fock, or RHF, is usually; appropriate for a closed-shell molecule). The program correctly guessed; all of these options for us. We can change the default behavior through; additional keywords.; Let’s consider what we would do for an open-shell molecule, where; not all electrons are paired. For example, let’s run a computation; on methylene (CH2), whose ground electronic state has two unpaired; electrons (triplet electronic state, or a spin multiplicity ).; In this case, the default spin multiplicity (1) is not correct, so we; need to tell the program the true value (3). Like many programs, PSI4; can get the charge and multiplicity as the first two integers in the; Z-matrix. Note the line with 0 3 at the beginning of the molecule; specification below. In this example we will also specify the bond length; and bond angle as variables ( and ), whose values are given; at the end of the Z-matr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/tutorial-1.html:1953,charge,charge,1953,psi4manual/4.0b3/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/tutorial-1.html,6,['charge'],['charge']
Energy Efficiency," exceeded without reaching geometry convergence. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY <CURRENTENERGY>`. :type name: string; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`~driver.energy`. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. For maximum; flexibility, ``return_wfn`` is always on in ``'reap'`` mode. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type hessian_with: string; :param hessian_with: ``'scf'`` || ``'mp2'`` || etc. Indicates the comp",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html:50441,energy,energy,50441,psi4manual/1.1.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html,1,['energy'],['energy']
Energy Efficiency," excitations; may be included noniteratively to yield the QCISD(T) method. Both the; QCISD(T) and CCSD(T) methods are implemented for closed-shell references; in the FNOCC module. Many-body perturbation theory¶; QCI and CC methods are closely related to perturbation theory, and the; MP2, MP3, and MP4(SDQ) correlation energies can be obtained as a free; by-product of a CCSD or QCISD computation. The following is an; example of the results for a computation run with the call; energy('fno-qcisd') to energy():; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30QCISD iterations converged!. OS MP2 FNO correction: -0.000819116338; SS MP2 FNO correction: -0.000092278158; MP2 FNO correction: -0.000911394496. OS MP2 correlation energy: -0.166478414245; SS MP2 correlation energy: -0.056669079827; MP2 correlation energy: -0.223147494072; * MP2 total energy: -76.258836941658. OS MP2.5 correlation energy: -0.171225850256; SS MP2.5 correlation energy: -0.054028401038; MP2.5 correlation energy: -0.225254251294; * MP2.5 total energy: -76.260943698880. OS MP3 correlation energy: -0.175973286267; SS MP3 correlation energy: -0.051387722248; MP3 correlation energy: -0.227361008515; * MP3 total energy: -76.263050456101. OS MP4(SDQ) correlation energy: -0.180324322304; SS MP4(SDQ) correlation energy: -0.048798468084; MP4(SDQ) correlation energy: -0.230995119324; * MP4(SDQ) total energy: -76.266684566910. OS QCISD correlation energy: -0.181578117924; SS QCISD correlation energy: -0.049853548145; QCISD correlation energy: -0.231431666069; * QCISD total energy: -76.267121113654. The first set of energies printed corresponds to the second-order FNO; correction mentioned previously. Results for many-body perturbation; theory through partial fourth order are then provided.; The notation MP4(SDQ) indicates that we have included all contributions to; the correlation energy through fourth order, with the exception of that; from connected tr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/fnocc-1.html:5702,energy,energy,5702,psi4manual/1.1.0/fnocc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/fnocc-1.html,6,['energy'],['energy']
Energy Efficiency," explicitly included in isapt1. A video; lecture explaining this example is available; I-SAPT#1,; while an additional video describing how to plot the density and ESP fields from; the I-SAPT embedding procedure is available I-SAPT#2:; memory 1 GB. molecule mol {; 0 1; O 0.39987 2.94222 -0.26535; H 0.05893 2.05436 -0.50962; --; 0 1; O 0.48122 0.30277 -0.77763; H 0.26106 -0.50005 -1.28451; --; 0 1; C 2.33048 -1.00269 0.03771; C 1.89725 0.31533 -0.59009; C 2.28232 1.50669 0.29709; C 1.82204 2.84608 -0.29432; C 2.37905 4.02099 0.49639; H 3.41246 -1.03030 0.19825; H 2.05362 -1.84372 -0.60709; H 1.82714 -1.16382 0.99734; H 2.36243 0.42333 -1.57636; H 3.36962 1.51414 0.43813; H 1.81251 1.38060 1.28140; H 2.14344 2.92967 -1.33843; H 3.47320 4.02400 0.48819; H 2.03535 3.99216 1.53635; H 2.02481 4.96785 0.07455; symmetry c1; no_reorient; no_com; }. # => Standard Options <= #. set {; basis jun-cc-pvdz; scf_type df; guess sad; freeze_core true; fisapt_do_plot true # For extra analysis; }. energy('fisapt0'). This is essentially the same input as for F-SAPT, except that the molecular; system is now divided into three moieties – subsystems A and B whose; intramolecular interaction we wish to compute, and a linking unit C. This file; runs a DF-HF computation on the full system using PSI4‘s existing SCF code.; At the start of the FISAPT code, the occupied orbitals are localized and divided; by charge considerations into A, B, C, and link sets. By default, linking sigma; bonds are assigned to C (this can be changed by the FISAPT_LINK_ASSIGNMENT; options). Then, non-interacting Hartree–Fock solutions for A and B are optimized; in the embedding field of the linking moiety C. At this point, A and B are not; interacting with each other, but have any potential covalent links or other; interactions with C built in by the embedding. A standard F-SAPT0 computation; is then performed between A and B, yielding the I-SAPT interaction energy. Any; F-SAPT considerations are also possible when I-SA",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/fisapt-1.html:9953,energy,energy,9953,psi4manual/1.4.0/fisapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/fisapt-1.html,9,['energy'],['energy']
Energy Efficiency," explicitly inverting it. As such, this algorithm is very slow and it should; be avoided whenever possible. Direct Inversion is automatically invoked if the newer algorithm; is not available.; The Davidson algorithm for stability analysis was implemented recently.; Only the lowest eigenvalues of the electronic Hessian are computed, and Hessian-vector; products are computed instead of the full Hessian. This algorithm is thus; much more efficient than the Direct Inversion, but is at present only available for UHF->UHF stability; analysis. The capabilities of both algorithms are summarized below:. Stability analysis methods available in Psi4¶. Algorithm; REFERENCE; Stability checked; SCF_TYPE. Direct Inversion; RHF; Internal, External (->UHF); PK only. ROHF; Internal; PK only. Davidson; UHF; Internal; Anything. The best algorithm is automatically selected, i.e. Davidson for UHF->UHF and Direct Inversion otherwise.; In addition to the options available for Direct Inversion, the Davidson algorithm can automatically; adapt FOLLOW_STEP_SCALE to find a new SCF minimum. If MAX_ATTEMPTS > 1, additional attempts; will automatically increment FOLLOW_STEP_SCALE by 0.2 every time the SCF falls back to the previously; found unstable minimum. The increment can be adjusted by setting FOLLOW_STEP_INCREMENT:; set follow_step_increment 0.2. The default value is 0.2, adjust if needed to try different values of FOLLOW_STEP_SCALE in a single compution.; The Davidson solver for the eigenvalues is controlled through several keywords. In the following; we only report the most pertinent for stability analysis, see documentation for the CPHF; module for a complete list.; Some default values were modified for the stability analysis code, in that case they are; explicitly indicated here. SOLVER_MAXITER: maximum number of iterations; SOLVER_CONVERGENCE: eigenvector convergence threshold; SOLVER_N_ROOT: Solve for N eigenvectors in each irreducible representation; SOLVER_N_GUESS: Use N guess vectors",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/scf-1.html:27170,adapt,adapt,27170,psi4manual/1.0.0/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/scf-1.html,2,['adapt'],['adapt']
Energy Efficiency," extrapolation in iterative solution of CI vector?. Type: boolean; Default: false. LSE_COLLAPSE (DETCI); DETCI — Number of iterations between least-squares extrapolations. Type: integer; Default: 3. LSE_TOLERANCE (DETCI); DETCI — Minimum converged energy for least-squares extrapolation to be performed. Type: conv double; Default: 3. M_FILE (TRANSQT); TRANSQT — Output integrals file. Type: integer; Default: 0. MADMP2_SLEEP (DFMP2); DFMP2 (Expert) — A helpful option, used only in debugging the MADNESS version. Type: integer; Default: 0. MAT_NUM_COLUMN_PRINT (GLOBALS); GLOBALS (Expert) — Number of columns to print in calls to Matrix::print_mat. Type: integer; Default: 5. MAX_BUCKETS (TRANSQT); TRANSQT — Maximum buckets. Type: integer; Default: 499. MAX_DISP_G_CONVERGENCE (OPTKING); OPTKING — Convergence criterion for geometry optmization: maximum displacement (internal coordinates, atomic units). Type: conv double; Default: 1.2e-3. MAX_ENERGY_G_CONVERGENCE (OPTKING); OPTKING — Convergence criterion for geometry optmization: maximum energy change. Type: conv double; Default: 1.0e-6. MAX_FORCE_G_CONVERGENCE (OPTKING); OPTKING — Convergence criterion for geometry optmization: maximum force (internal coordinates, atomic units). Type: conv double; Default: 3.0e-4. MAX_MOGRAD_CONVERGENCE (OMP2); OMP2 — Convergence criterion for maximum orbital gradient. Type: conv double; Default: 1e-4. MAX_MOGRAD_CONVERGENCE (OMP3); OMP3 — Convergence criterion for maximum orbital gradient. Type: conv double; Default: 1e-4. MAX_NUM_VECS (DETCI); DETCI — Maximum number of Davidson subspace vectors which can be held on disk for the CI coefficient and sigma vectors. (There is one H(diag) vector and the number of D vectors is equal to the number of roots). When the number of vectors on disk reaches the value of MAX_NUM_VECS, the Davidson subspace will be collapsed to COLLAPSE_SIZE vectors for each root. This is very helpful for saving disk space. Defaults to MAXITER * NUM_ROOTS + NUM_INIT_VECS. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html:70023,energy,energy,70023,psi4manual/4.0b3/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html,2,['energy'],['energy']
Energy Efficiency," extrapolation procedures (e.g., DIIS) until the gradient; conditions are met. Note that while the total number of macroiterations will be; less for SOSCF than gradient-based convergence acceleration, the cost of solving; the microiterations typically results in the overall cost being greater for; SOSCF than for gradient-based methods. Therefore, SOSCF should only be used if; it is difficult to locate a stable minimum.; SOSCF is only available for RHF, ROHF, and UHF reference (and only for HF, not DFT).; To turn on, simply set; the option SOSCF to true. Additional options to modify the number of; microiterations taken are as follows:. SOSCF_START_CONVERGENCE: when to start SOSCF based on the current density RMS; SOSCF_MAX_ITER: the maximum number of SOSCF microiterations per macroiteration; SOSCF_CONV: the relative convergence tolerance of the SOSCF microiterations; SOSCF_PRINT: option to print the microiterations or not. Stability Analysis¶; SCF algorithms attempt to minimize the gradient of the energy with respect; to orbital variation parameters. At convergence, the gradient should be approximately zero; given a convergence criterion. Although this is enough to make sure the SCF converged to a; stationary point, this is not a sufficient condition for a minimal SCF solution. It may be; a saddle point or a maximum.; To ensure that a minimum has been found, the electronic Hessian, i.e. the matrix of second; derivatives of the energy with respect to orbital variation parameters, must be computed.; If one or more eigenvalues of the electronic Hessian are negative, the SCF solution is not a minimum.; In that case, orbital parameters can be varied along the lowest Hessian eigenvector to lower the energy.; Orbital variation parameters are usually constrained. For example, in RHF the; spatial parts of the \(\alpha\) and \(\beta\) orbitals are the same. In; UHF, the orbital coefficients are usually constrained to be real. A stability analysis; can check whether a lower SCF",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/scf-1.html:25412,energy,energy,25412,psi4manual/1.1.0/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/scf-1.html,4,['energy'],['energy']
Energy Efficiency," extrapolation stage as `scf` or `corl`, by default only the first stage is `scf` and every later one is `corl`.; `stage`: tag for the stage used in tables. The next items in the `cbs_metadata` array extrapolate correlation. All of the above parameters are available, with only the `wfn` and `basis` keywords required. Other supported parameters are:. `wfn_lo`: the lower method from which the delta correction is to be calculated. By default, it is set to `wfn` from the previous field in the `cbs_metadata` array.; `basis_lo`: basis set to be used for the delta correction. By default, it is the same as the `basis` specified above. Others. Parameters:; molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> energy(cbs, corl_wfn='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> energy('cbs', scf_wfn='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme='scf_xtpl_helgaker_3'). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> energy('cbs', corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme='corl_xtpl_helgaker_2'). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme='corl_xtpl_helgaker_2', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme='corl_xtpl_helgaker_2'). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.cbs.html:12698,energy,energy,12698,psi4manual/1.7.x/api/psi4.driver.cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.cbs.html,16,['energy'],['energy']
Energy Efficiency," file \'%s.out\' has nominal affiliation %s incompatible with item %s.'; % (rfile, s[6], str(n + 1))); if (s[8:10] == ['electronic', 'energy']):; E = float(s[10]); PsiMod.print_out('%s RESULT: electronic energy = %20.12f\n' % ('GRADIENT', E)); freagent.close(); energies.append(E). # S/R: Quit sow after writing files; if (opt_mode.lower() == 'sow'):; return 0.0. if (opt_mode.lower() == 'reap'):; PsiMod.set_variable('CURRENT ENERGY', energies[-1]). # Obtain the gradient; PsiMod.fd_1_0(energies). # The last item in the list is the reference energy, return it; return energies[-1]. [docs]def property(name, **kwargs):; r""""""Function to compute various properties. :aliases: prop(). :returns: (*float*) Total electronic energy in Hartrees. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - This function at present handles property functions only for CC methods.; Consult the keywords sections for other modules for further property capabilities. - Check that energy is actually being returned. - Check if some PSI variables ought to be set. +-------------------------+---------------------------------------------------------------------------------------+; | name | calls method |; +=========================+=======================================================================================+; | scf | Self-consistent field method(s) |; +-------------------------+---------------------------------------------------------------------------------------+; | cc2 | 2nd-order approximate CCSD |; +-------------------------+---------------------------------------------------------------------------------------+; | ccsd | coupled cluster singles and doubles (CCSD) |; +-------------------------+---------------------------------------------------------------------------------------+; | eom-cc2 | 2nd-order approximate EOM-CCSD |; +-------------------------+---------------------------------------------------------------------------------------+; | eom-ccsd | equati",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/driver.html:30342,energy,energy,30342,psi4manual/4.0b2/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/driver.html,1,['energy'],['energy']
Energy Efficiency," file! It is auto-generated by the document_options_and_tests; # script, from psi4topdir/include/physconst.h; psi_h = 6.62606896E-34 # The Planck constant (Js) ; psi_c = 2.99792458E8 # Speed of light (ms$^{-1}$) ; psi_kb = 1.3806504E-23 # The Boltzmann constant (JK$^{-1}$) ; psi_R = 8.314472 # Universal gas constant (JK$^{-1}$mol$^{-1}$) ; psi_bohr2angstroms = 0.52917720859 # Bohr to Angstroms conversion factor ; psi_bohr2m = 0.52917720859E-10 # Bohr to meters conversion factor ; psi_bohr2cm = 0.52917720859E-8 # Bohr to centimeters conversion factor ; psi_amu2g = 1.660538782E-24 # Atomic mass units to grams conversion factor ; psi_amu2kg = 1.660538782E-27 # Atomic mass units to kg conversion factor ; psi_au2amu = 5.485799097E-4 # Atomic units (m$@@e$) to atomic mass units conversion factor ; psi_hartree2J = 4.359744E-18 # Hartree to joule conversion factor ; psi_hartree2aJ = 4.359744 # Hartree to attojoule (10$^{-18}$J) conversion factor ; psi_cal2J = 4.184 # Calorie to joule conversion factor ; psi_dipmom_au2si = 8.47835281E-30 # Atomic units to SI units (Cm) conversion factor for dipoles ; psi_dipmom_au2debye = 2.54174623 # Atomic units to Debye conversion factor for dipoles ; psi_dipmom_debye2si = 3.335640952E-30 # Debye to SI units (Cm) conversion factor for dipoles ; psi_c_au = 137.035999679 # Speed of light in atomic units ; psi_hartree2ev = 27.21138 # Hartree to eV conversion factor ; psi_hartree2wavenumbers = 219474.6 # Hartree to cm$^{-1}$ conversion factor ; psi_hartree2kcalmol = 627.5095 # Hartree to kcal mol$^{-1}$ conversion factor ; psi_hartree2MHz = 6.579684E9 # Hartree to MHz conversion factor ; psi_kcalmol2wavenumbers = 349.7551 # kcal mol$^{-1}$ to cm$^{-1}$ conversion factor ; psi_e0 = 8.854187817E-12 # Vacuum permittivity (Fm$^{-1}$) ; psi_na = 6.02214179E23 # Avagadro's number ; psi_me = 9.10938215E-31 # Electron rest mass (in kg) . wrappers¶; Module with functions that call the four main driver; functions: driver.energy, driver.optimize,; drive",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodoc_driver-1.html:10525,joule,joule,10525,psi4manual/4.0b2/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodoc_driver-1.html,6,['joule'],['joule']
Energy Efficiency," file! It is auto-generated by the document_options_and_tests; # script, from psi4topdir/include/physconst.h; psi_h = 6.62606896E-34 # The Planck constant (Js) ; psi_c = 2.99792458E8 # Speed of light (ms$^{-1}$) ; psi_kb = 1.3806504E-23 # The Boltzmann constant (JK$^{-1}$) ; psi_R = 8.314472 # Universal gas constant (JK$^{-1}$mol$^{-1}$) ; psi_bohr2angstroms = 0.52917720859 # Bohr to Angstroms conversion factor ; psi_bohr2m = 0.52917720859E-10 # Bohr to meters conversion factor ; psi_bohr2cm = 0.52917720859E-8 # Bohr to centimeters conversion factor ; psi_amu2g = 1.660538782E-24 # Atomic mass units to grams conversion factor ; psi_amu2kg = 1.660538782E-27 # Atomic mass units to kg conversion factor ; psi_au2amu = 5.485799097E-4 # Atomic units (m$@@e$) to atomic mass units conversion factor ; psi_hartree2J = 4.359744E-18 # Hartree to joule conversion factor ; psi_hartree2aJ = 4.359744 # Hartree to attojoule (10$^{-18}$J) conversion factor ; psi_cal2J = 4.184 # Calorie to joule conversion factor ; psi_dipmom_au2si = 8.47835281E-30 # Atomic units to SI units (Cm) conversion factor for dipoles ; psi_dipmom_au2debye = 2.54174623 # Atomic units to Debye conversion factor for dipoles ; psi_dipmom_debye2si = 3.335640952E-30 # Debye to SI units (Cm) conversion factor for dipoles ; psi_c_au = 137.035999679 # Speed of light in atomic units ; psi_hartree2ev = 27.21138 # Hartree to eV conversion factor ; psi_hartree2wavenumbers = 219474.6 # Hartree to cm$^{-1}$ conversion factor ; psi_hartree2kcalmol = 627.5095 # Hartree to kcal mol$^{-1}$ conversion factor ; psi_hartree2kJmol = 2625.500 # Hartree to kilojoule mol$^{-1}$ conversion factor ; psi_hartree2MHz = 6.579684E9 # Hartree to MHz conversion factor ; psi_kcalmol2wavenumbers = 349.7551 # kcal mol$^{-1}$ to cm$^{-1}$ conversion factor ; psi_e0 = 8.854187817E-12 # Vacuum permittivity (Fm$^{-1}$) ; psi_na = 6.02214179E23 # Avagadro's number ; psi_me = 9.10938215E-31 # Electron rest mass (in kg) . The psi_ prefix is to prevent c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/psithoninput-1.html:2857,joule,joule,2857,psi4manual/1.0.0/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/psithoninput-1.html,2,['joule'],['joule']
Energy Efficiency," fileAtom, el2masses[fileAtom]). else:; raise ValidationError(""Molecule::init_with_xyz: Malformed atom information line %d."" % (i + 3)); except IndexError:; raise ValidationError(""Molecule::init_with_xyz: Expected atom in file at line %d.\n%s"" % (i + 3, text[i + 2])). # We need to make 1 fragment with all atoms; instance.fragments.append([0, fileNatom - 1]); instance.fragment_types.append('Real'); instance.fragment_charges.append(0); instance.fragment_multiplicities.append(1); # Set the units to bohr since we did the conversion above, if needed.; instance.PYunits = 'Bohr'; instance.input_units_to_au = 1.0. instance.update_geometry(); return instance. [docs] def clone(self):; """"""Returns new, independent Molecule object. >>> dimer = H2OH2O.clone(). """"""; return copy.deepcopy(self). # <<< Methods for Printing >>>. [docs] def print_out(self):; """"""Print the molecule.; (method name in libmints is print). >>> H2OH2O.print_out(); Geometry (in Angstrom), charge = -2, multiplicity = 3:; Center X Y Z; ------------ ----------------- ----------------- -----------------; O -1.551007000000 -0.114520000000 0.000000000000; H -1.934259000000 0.762503000000 0.000000000000; H -0.599677000000 0.040712000000 0.000000000000; O 1.350625000000 0.111469000000 0.000000000000; H 1.680398000000 -0.373741000000 -0.758561000000; H 1.680398000000 -0.373741000000 0.758561000000. """"""; text = """"; if self.natom():; if self.pg:; text += """""" Molecular point group: %s\n"""""" % (self.pg.symbol()); # if self.full_pg: TODO symmetry; # text += """""" Full point group: %s\n\n"""""" % (self.full_point_group()) TODO symmetry; text += """""" Geometry (in %s), charge = %d, multiplicity = %d:\n\n"""""" % \; ('Angstrom' if self.units() == 'Angstrom' else 'Bohr', self.molecular_charge(), self.multiplicity()); text += """""" Center X Y Z \n""""""; text += """""" ------------ ----------------- ----------------- -----------------\n"""""". for i in range(self.natom()):; geom = self.atoms[i].compute(); text += """""" %8s%4s """""" % (self.symbol(i), """" ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html:23411,charge,charge,23411,psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html,3,['charge'],['charge']
Energy Efficiency," files. Initialize skeleton wfn to receive grad for reap; if freq_mode == 'sow':; optstash.restore(); optstash_conv.restore(); if return_wfn:; return (None, None); else:; return None; elif freq_mode == 'reap':; # psi4.set_variable('CURRENT ENERGY', energies[-1]); wfn = psi4.new_wavefunction(molecule, psi4.get_global_option('BASIS')). # Assemble Hessian from energies; H = psi4.fd_freq_0(molecule, energies, irrep); wfn.set_hessian(H); wfn.set_frequencies(psi4.get_frequencies()). # The last item in the list is the reference energy, return it; psi4.set_variable('CURRENT ENERGY', energies[-1]). psi4.set_parent_symmetry(''); optstash.restore(); optstash_conv.restore(). if return_wfn:; return (wfn.hessian(), wfn); else:; return wfn.hessian(). [docs]def frequency(name, **kwargs):; r""""""Function to compute harmonic vibrational frequencies. :aliases: frequencies(), freq(). :returns: *float* |w--w| Total electronic energy in Hartrees. :returns: (*float*, :ref:`Wavefunction<sec:psimod_Wavefunction>`) |w--w| energy and wavefunction when **return_wfn** specified. :type name: string; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :ref:`Wavefunction<sec:psimod_Wavefunction>`; calculation result as the second element (after *float* energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage fin",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver.html:78918,energy,energy,78918,psi4manual/1.0.0/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver.html,1,['energy'],['energy']
Energy Efficiency," first call the SCF module and perform the SCF computation; with RHF reference to obtain a guess for the DCFT orbitals. After SCF is; converged, the program will perform the energy computation using the ODC-12; method. By default, simultaneous algorithm will be used for the solution of; the equations. One can also request to perform geometry; optimization following example below:; molecule {; H; H 1 1.0; }. set basis cc-pvdz. optimize('dcft'). The optimize('dcft') call will first perform all of the procedures; described above to obtain the ODC-12 energy. After that, the ODC-12 analytic; gradients code will be executed and geometry optimization will be performed. Recommendations¶; Here is a list of recommendations for the DCFT module:. Generally, the use of the simultaneous algorithm together with the; AO_BASIS = DISK option is recommended (set by default).; In cases when available memory is insufficient, the use of the AO_BASIS = DISK option; is recommended. This will significantly reduce the memory requirements. However, when; used together with the two-step algorithm, this option can significantly; increase the cost of the energy computation.; In cases when the oscillatory convergence is observed before the DIIS; extrapolation is initialized, it is recommended to increase the threshold for; the RMS of the density cumulant or orbital update residual, below which the; DIIS extrapolation starts. This can be done by setting the; DIIS_START_CONVERGENCE option to the value greater than; by one or two orders of magnitude (e.g. or; ). This can be particularly useful for computions using the; ODC methods, because it can greatly reduce the number of iterations.; If oscillatory convergence is observed for atoms or molecules with high; symmetry, it is recommended to use the quadratically-convergent algorithm.; When using the quadratically-convergent algorithm for the closed-shell molecules, it; is recommended to set the QC_COUPLING option to FALSE for efficiency; reasons (set",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/dcft-1.html:13758,reduce,reduce,13758,psi4manual/1.0.0/dcft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/dcft-1.html,2,['reduce'],['reduce']
Energy Efficiency," first define a table (on line 10) with two row indices and three column; indices. As the potential energy scan is performed, the results are stored; (line 22) and the final table is printed to the output file (line 24). The; table is converted from absolute energies to relative energies (in kcal mol-1); on line 26, before being printed again. The relative energies are reported with; respect to the lowest value in each column. More examples of how to control the; formatting of the tables can be found in the sample input files provided; see; Appendix Test Suite and Sample Inputs for a complete listing. Python Wrappers¶; The Python foundations of the PSI4 driver and Psithon syntax permit; many commonly performed post-processing procedures to be integrated into; the PSI4 suite.; As seen in the neon dimer example from the tutorial section,; the nbody_gufunc() wrapper provides automatic computation of; counterpoise-corrected interaction energies between two molecules. For; example,; energy('mp2', bsse_type='cp'). will compute the counterpoise-corrected density-fitted MP2 interaction energy; between two molecules.; PSI4 also provides the cbs() wrapper,; which automatically computes a complete-basis-set extrapolation (and; automatically sets up the computations with different basis sets required to; do the extrapolation). For example,:; # all equivalent. cbs('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). energy('mp2/cc-pv[dt]z'). will compute a 2-point Helgaker extrapolation of the correlation energy; using the cc-pVDZ and cc-pVTZ basis sets (with method MP2) and add this; extrapolated correlation energy to the Hartree–Fock energy in the; largest basis (cc-pVTZ). cbs() can; either be called directly, as in the first example, or the convenience; syntax of the equivalent second example can be used.; Another very useful and powerful feature of PSI4 is the ability; to compute results on entire databases of molecules at a time,; as provided by the database()",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/psithoninput-1.html:13572,energy,energy,13572,psi4manual/1.4.0/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/psithoninput-1.html,4,['energy'],['energy']
Energy Efficiency," first example, we will consider a Hartree-Fock SCF computation for the water molecule using a cc-pVDZ basis set. First, we will set the available memory for Psi4 to use with the psi4.set_memory() API function, which takes either a string like '30 GB' (with units!) or an integer number of bytes of memory as its argument. Next, our molecular geometry is passed as a string into; psi4.geometry() API. We may input this geometry in either Z-matrix or Cartesian format; to allow the string to break over multiple lines, use Python’s triple-quote """"""string"""""" syntax. Finally, we will compute the Hartree-Fock SCF energy with the cc-pVDZ basis set by passing the method/basis set as a string ('scf/cc-pvdz') into the function psi4.energy(); API:. [3]:. #! Sample HF/cc-pVDZ H2O Computation. psi4.set_memory('500 MB'). h2o = psi4.geometry(""""""; O; H 1 0.96; H 1 0.96 2 104.5; """"""). psi4.energy('scf/cc-pvdz'). [3]:. -76.02663273488399. If everything goes well, the computation should complete and should report a final restricted Hartree-Fock energy in the output file output.dat in a section like this:; Energy converged. @DF-RHF Final Energy: -76.02663273486682. By default, the energy should be converged to about \(1.0\times 10^{-6}\), so agreement is only expected for about the first 6 digits after the decimal. If the computation does not complete, there is probably a problem with the compilation or installation of the program (see the installation instructions in the main Psi4 manual section :psicode:[Compiling and Installing from Source] <psi4manual/master/build_planning.html> .; This very simple input is sufficient to run the requested information. Notice we didn’t tell the program some otherwise useful information like the charge of the molecule (0, it’s neutral), the spin multiplicity (1 for a closed-shell molecule with all electrons paired), or the reference wavefunction to use (restricted Hartree-Fock, or RHF, is usually appropriate for a closed-shell molecule). The program corre",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/psiapi.html:3723,energy,energy,3723,psi4manual/1.6.x/psiapi.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psiapi.html,3,['energy'],['energy']
Energy Efficiency," first example, we will consider a Hartree-Fock SCF computation for the water molecule using a cc-pVDZ basis set. First, we will set the available memory for Psi4 to use with the psi4.set_memory() API function, which takes either a string like '30 GB' (with units!) or an integer number of bytes of memory as its argument. Next, our molecular geometry is passed as a string into; psi4.geometry() API. We may input this geometry in either Z-matrix or Cartesian format; to allow the string to break over multiple lines, use Python’s triple-quote """"""string"""""" syntax. Finally, we will compute the Hartree-Fock SCF energy with the cc-pVDZ basis set by passing the method/basis set as a string ('scf/cc-pvdz') into the function psi4.energy(); API:. [3]:. #! Sample HF/cc-pVDZ H2O Computation. psi4.set_memory('500 MB'). h2o = psi4.geometry(""""""; O; H 1 0.96; H 1 0.96 2 104.5; """"""). psi4.energy('scf/cc-pvdz'). [3]:. -76.02663273488399. If everything goes well, the computation should complete and should report a final restricted Hartree-Fock energy in the output file output.dat in a section like this:; Energy converged. @DF-RHF Final Energy: -76.02663273486682. By default, the energy should be converged to about \(1.0\times 10^{-6}\), so agreement is only expected for about the first 6 digits after the decimal. If the computation does not complete, there is probably a problem with the compilation or installation of the program (see the installation instructions in the main Psi4 manual section Compiling and Installing from Source).; This very simple input is sufficient to run the requested information. Notice we didn’t tell the program some otherwise useful information like the charge of the molecule (0, it’s neutral), the spin multiplicity (1 for a closed-shell molecule with all electrons paired), or the reference wavefunction to use (restricted Hartree-Fock, or RHF, is usually appropriate for a closed-shell molecule). The program correctly guessed all of these options for us. We can ch",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psiapi-1.html:3724,energy,energy,3724,psi4manual/1.3.2/psiapi-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psiapi-1.html,6,['energy'],['energy']
Energy Efficiency," first example, we will consider a Hartree-Fock SCF computation for the water molecule using a cc-pVDZ basis set. First, we will set the available memory for Psi4 to use with the psi4.set_memory() API function, which takes either a string like '30 GB' (with units!) or an integer number of bytes of memory as its argument. Next, our molecular geometry is passed as a string into; psi4.geometry() API. We may input this geometry in either Z-matrix or Cartesian format; to allow the string to break over multiple lines, use Python’s triple-quote """"""string"""""" syntax. Finally, we will compute the Hartree-Fock SCF energy with the cc-pVDZ basis set by passing the method/basis set as a string ('scf/cc-pvdz') into the function psi4.energy(); API:. [3]:. #! Sample HF/cc-pVDZ H2O Computation. psi4.set_memory('500 MB'). h2o = psi4.geometry(""""""; O; H 1 0.96; H 1 0.96 2 104.5; """"""). psi4.energy('scf/cc-pvdz'). [3]:. -76.02663273488399. If everything goes well, the computation should complete and should report a final restricted Hartree-Fock energy in the output file output.dat in a section like this:; Energy converged. @DF-RHF Final Energy: -76.02663273486682. By default, the energy should be converged to about \(1.0\times 10^{-6}\), so agreement is only expected for about the first 6 digits after the decimal. If the computation does not complete, there is probably a problem with the compilation or installation of the program (see the installation instructions in the main Psi4 manual section Compiling and Installing from Source.; This very simple input is sufficient to run the requested information. Notice we didn’t tell the program some otherwise useful information like the charge of the molecule (0, it’s neutral), the spin multiplicity (1 for a closed-shell molecule with all electrons paired), or the reference wavefunction to use (restricted Hartree-Fock, or RHF, is usually appropriate for a closed-shell molecule). The program correctly guessed all of these options for us. We can cha",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/psiapi.html:3599,energy,energy,3599,psi4manual/1.9.x/psiapi.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/psiapi.html,2,['energy'],['energy']
Energy Efficiency," fitted REMP/cc-pVDZ energies for the CO2 molecule. fsapt-diff1; This test case shows an example of running and analyzing a difference F-SAPT0/jun-cc-pvdz procedure for phenol dimer from the S22 database. mints8; Patch of a glycine with a methyl group, to make alanine, then DF-SCF energy calculation with the cc-pVDZ basis set. cbs-xtpl-nbody; RHF interaction energies using nbody and cbs parts of the driver Ne dimer with mp2/v[dt]z + d:ccsd(t)/vdz. aediis-2; EDIIS test case from 10.1063/1.1470195. scf-response3; UHF Dipole Polarizability Test. mom-h2o-3; MOM excitation from LUMO HOMO+3. extern3; External potential calculation with one Ghost atom and one point charge at the same position. pywrap-cbs1; Various basis set extrapolation tests. dft-grad2; DF-BP86-D2 cc-pVDZ frozen core gradient of S22 HCN updated ref gradient due to new BraggSlater radii. tu4-h2o-freq; Optimization followed by frequencies H2O HF/cc-pVDZ. numpy-array-interface; Numpy interface testing. omp2-1; OMP2 cc-pVDZ energy for the H2O molecule. dfomp3-grad1; DF-OMP3 cc-pVDZ gradients for the H2O molecule. cdremp-2; Cholesky decomposed REMP/cc-pVDZ energies for the CH3 radical. mom-h2o-4; MOM excitation from LUMO HOMO+4. frac; Carbon/UHF Fractionally-Occupied SCF Test Case. dfccsd-t-grad2; DF-CCSD(T) cc-pVDZ gradient for the NH molecule. psimrcc-ccsd_t-1; Mk-MRCCSD(T) single point. \(^1A_1\) CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. olccd-grad1; OLCCD cc-pVDZ gradient for the H2O molecule. dfmp2-3; DF-MP2 cc-pVDZ frozen core gradient of benzene, computed at the DF-SCF cc-pVDZ geometry. dfmp2-freq2; DF-MP2 frequency by difference of energies for H2O. cbs-xtpl-dict; Extrapolated water energies. cc33; CC3(UHF)/cc-pVDZ H2O \(R_e\) geom from Olsen et al., JCP 104, 8007 (1996). mp2-property; MP2 cc-pvDZ properties for Nitrogen oxide. opt2-fd; SCF DZ allene geometry optimzation, with Cartesian input. linK-2; RKS Linear Exchange Algorithm test for benzene. cc36;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html:35280,energy,energy,35280,psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency," fix_orientation (bool) – Whether rotation of geom is allowed or disallowed.; fix_symmetry (str, optional) – Maximal point group symmetry which geom should be treated. Lowercase.; geom (ndarray of float) – (3 * nat, ) Cartesian coordinates in units.; elea (ndarray of int) – (nat, ) Mass number for atoms, if known isotope, else -1.; elez (ndarray of int) – (nat, ) Number of protons, nuclear charge for atoms.; elem (ndarray of str) – (nat, ) Element symbol for atoms.; mass (ndarray of float) – (nat, ) Atomic mass [u] for atoms.; real (ndarray of bool) – (nat, ) Real/ghostedness for atoms.; elbl (ndarray of str) – (nat, ) Label with any tagging information from element spec.; fragment_separators (list of int) – (nfr - 1, ) list of atom indices at which to split geom into fragments.; fragment_charges (list of float) – (nfr, ) list of charge allocated to each fragment.; fragment_multiplicities (list of int) – (nfr, ) list of multiplicity allocated to each fragment.; molecular_charge (float) – total charge on system.; molecular_multiplicity (int) – total multiplicity on system.; comment (str, optional) – Additional comment for molecule.; provenance (dict of str) – Accumulated history of molecule, with fields “creator”, “version”, “routine”.; connectivity (list of tuples of int, optional) – (nbond, 3) list of (0-indexed) (atomA, atomB, bond_order) (int, int, double) tuples; EFP extension (this + units is minimal); fragment_files (list of str) – (nfr, ) lowercased names of efp meat fragment files.; hint_types ({‘xyzabc’, ‘points’}) – (nfr, ) type of fragment orientation hint.; geom_hints (list of lists of float) – (nfr, ) inner lists have length 6 (xyzabc; to orient the center) or; 9 (points; to orient the first three atoms) of the EFP fragment.; QMVZ extension (geom_unsettled replaces geom); geom_unsettled (list of lists of str) – (nat, ) all-string Cartesian and/or zmat anchor and value contents; mixing anchors, values, and variables.; variables (list of pairs) – (nvar, 2",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/external_apis-1.html:9245,charge,charge,9245,psi4manual/1.4.0/external_apis-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/external_apis-1.html,5,['charge'],['charge']
Energy Efficiency," flexibility of the basis set; specification is advantageous, for example, when selectively omitting diffuse; functions to make computations more tractable.; In the above example the basis sets have been assigned asymmetrically, reducing; the effective symmetry from \(D_{6h}\) to \(C_{2v}\); PSI4 will detect this; automatically and run in the appropriate point group.; Basis blocks can also be named, e.g., basis; optional_basis_name {...} and the basis defined by it later; applied to another molecule.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32# sets basis keyword; basis mybas {; assign aug-cc-pvtz; assign f cc-pvtz; }. # re-sets basis keyword; set basis aug-cc-pvtz. molecule hf {; H; F 1 1.0; }. molecule h2o {; O; H 1 1.0; H 1 1.0 2 90.0; }. # runs HF and H2O with aug-cc-pvtz; energy('hf', molecule=hf); energy('hf', molecule=h2o). # re-re-sets basis keyword; set basis mybas. # runs HF with cc-pvtz on F and aug-cc-pvtz on H; energy('hf', molecule=hf). # runs H2O with aug-cc-pvtz, effectively; energy('hf', molecule=h2o). Finally, we note that the basis {...} block may also be used; for defining basis sets, as detailed in User-Defined Basis Sets.; Calculations requesting density fitting (on by default for many methods); require auxiliary fitting basis set(s) in addition to the primary; orbital one associated with the BASIS keyword.; When most popular basis sets are being used, including Dunning and; Pople-style, the SCF, DF-MP2, and SAPT codes will chose the appropriate; auxiliary basis set automatically according to Auxiliary Basis Sets,; unless instructed otherwise by setting the auxiliary basis set in the; input.; Should needed elements be missing from the best; auxiliary basis or should the orbital basis be unknown to PSI4,; the auxiliary basis will fall back on def2 quad-zeta fitting bases.; Note that if BASIS is known to be larger than quad-zeta,; PSI4 will not attempt to fall back on the d",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/basissets-1.html:4556,energy,energy,4556,psi4manual/1.2.1/basissets-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/basissets-1.html,6,['energy'],['energy']
Energy Efficiency," float, bool) that can be processed by database wrapper.' % (chgdopt)). # build string of molecule and commands that are dependent on the database; commands += '\n'. if symmetry_override:; commands += """"""molecule.reset_point_group('c1')\n""""""; commands += """"""molecule.fix_orientation(True)\n""""""; commands += """"""molecule.fix_com(True)\n""""""; commands += """"""molecule.update_geometry()\n"""""". if (openshell_override) and (molecule.multiplicity() != 1):; if user_reference == 'RHF':; commands += """"""core.set_global_option('REFERENCE', 'UHF')\n""""""; elif user_reference == 'RKS':; commands += """"""core.set_global_option('REFERENCE', 'UKS')\n"""""". commands += """"""core.set_global_option('WRITER_FILE_LABEL', '%s')\n"""""" % \; (user_writer_file_label + ('' if user_writer_file_label == '' else '-') + rgt). # all modes need to step through the reagents but all for different purposes; # continuous: defines necessary commands, executes energy(method) call, and collects results into dictionary; # sow: opens individual reagent input file, writes the necessary commands, and writes energy(method) call; # reap: opens individual reagent output file, collects results into a dictionary; if db_mode == 'continuous':; exec(banners). molecule = core.Molecule.create_molecule_from_string(GEOS[rgt].create_psi4_string_from_molecule()); molecule.set_name(rgt); molecule.update_geometry(). exec(commands); #print 'MOLECULE LIVES %23s %8s %4d %4d %4s' % (rgt, core.get_global_option('REFERENCE'),; # molecule.molecular_charge(), molecule.multiplicity(), molecule.schoenflies_symbol()); ERGT[rgt] = func(molecule=molecule, **kwargs); core.print_variables(); exec(actives); for envv in db_tabulate:; VRGT[rgt][envv.upper()] = core.get_variable(envv); core.set_global_option(""REFERENCE"", user_reference); core.clean(); #core.opt_clean(); core.clean_variables(). elif db_mode == 'sow':; with open('%s.in' % (rgt), 'w') as freagent:; freagent.write('# This is a psi4 input file auto-generated from the database() wrapper.\n\n'); frea",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/wrapper_database.html:20795,energy,energy,20795,psi4manual/1.1.0/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/wrapper_database.html,2,['energy'],['energy']
Energy Efficiency," float, bool) that can be processed by database wrapper.' % (chgdopt)). # build string of molecule and commands that are dependent on the database; commands += '\n'. if symmetry_override:; commands += """"""molecule.reset_point_group('c1')\n""""""; commands += """"""molecule.fix_orientation(True)\n""""""; commands += """"""molecule.fix_com(True)\n""""""; commands += """"""molecule.update_geometry()\n"""""". if (openshell_override) and (molecule.multiplicity() != 1):; if user_reference == 'RHF':; commands += """"""core.set_global_option('REFERENCE', 'UHF')\n""""""; elif user_reference == 'RKS':; commands += """"""core.set_global_option('REFERENCE', 'UKS')\n"""""". commands += """"""core.set_global_option('WRITER_FILE_LABEL', '%s')\n"""""" % \; (user_writer_file_label + ('' if user_writer_file_label == '' else '-') + rgt). # all modes need to step through the reagents but all for different purposes; # continuous: defines necessary commands, executes energy(method) call, and collects results into dictionary; # sow: opens individual reagent input file, writes the necessary commands, and writes energy(method) call; # reap: opens individual reagent output file, collects results into a dictionary; if db_mode == 'continuous':; exec(banners). molecule = core.Molecule.from_dict(GEOS[rgt].to_dict()); molecule.set_name(rgt); molecule.update_geometry(). exec(commands); #print 'MOLECULE LIVES %23s %8s %4d %4d %4s' % (rgt, core.get_global_option('REFERENCE'),; # molecule.molecular_charge(), molecule.multiplicity(), molecule.schoenflies_symbol()); if allowoptexceeded:; try:; ERGT[rgt] = func(molecule=molecule, **kwargs); except ConvergenceError:; core.print_out(""Optimization exceeded cycles for %s"" % (rgt)); ERGT[rgt] = 0.0; else:; ERGT[rgt] = func(molecule=molecule, **kwargs); core.print_variables(); exec(actives); for envv in db_tabulate:; VRGT[rgt][envv.upper()] = core.get_variable(envv); core.set_global_option(""REFERENCE"", user_reference); core.clean(); #core.opt_clean(); core.clean_variables(). elif db_mode == 'sow':; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/wrapper_database.html:20848,energy,energy,20848,psi4manual/1.2.1/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/wrapper_database.html,2,['energy'],['energy']
Energy Efficiency," float, bool) that can be processed by database wrapper.' % (chgdopt)). # build string of molecule and commands that are dependent on the database; commands += '\n'. if symmetry_override:; commands += """"""molecule.reset_point_group('c1')\n""""""; commands += """"""molecule.fix_orientation(True)\n""""""; commands += """"""molecule.fix_com(True)\n""""""; commands += """"""molecule.update_geometry()\n"""""". if (openshell_override) and (molecule.multiplicity() != 1):; if user_reference == 'RHF':; commands += """"""core.set_global_option('REFERENCE', 'UHF')\n""""""; elif user_reference == 'RKS':; commands += """"""core.set_global_option('REFERENCE', 'UKS')\n"""""". commands += """"""core.set_global_option('WRITER_FILE_LABEL', '%s')\n"""""" % \; (user_writer_file_label + ('' if user_writer_file_label == '' else '-') + rgt). # all modes need to step through the reagents but all for different purposes; # continuous: defines necessary commands, executes energy(method) call, and collects results into dictionary; # sow: opens individual reagent input file, writes the necessary commands, and writes energy(method) call; # reap: opens individual reagent output file, collects results into a dictionary; if db_mode == 'continuous':; exec(banners). molecule = core.Molecule.from_dict(GEOS[rgt].to_dict()); molecule.set_name(rgt); molecule.update_geometry(). exec(commands); #print 'MOLECULE LIVES %23s %8s %4d %4d %4s' % (rgt, core.get_global_option('REFERENCE'),; # molecule.molecular_charge(), molecule.multiplicity(), molecule.schoenflies_symbol()); if allowoptexceeded:; try:; ERGT[rgt] = func(molecule=molecule, **kwargs); except ConvergenceError:; core.print_out(""Optimization exceeded cycles for %s"" % (rgt)); ERGT[rgt] = 0.0; else:; ERGT[rgt] = func(molecule=molecule, **kwargs); core.print_variables(); exec(actives); for envv in db_tabulate:; VRGT[rgt][envv.upper()] = core.variable(envv); core.set_global_option(""REFERENCE"", user_reference); core.clean(); #core.opt_clean(); core.clean_variables(). elif db_mode == 'sow':; with",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html:20565,energy,energy,20565,psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html,2,['energy'],['energy']
Energy Efficiency," float, bool) that can be processed by database wrapper.' % (chgdopt)). # build string of molecule and commands that are dependent on the database; commands += '\n'. if symmetry_override:; commands += """"""molecule.reset_point_group('c1')\n""""""; commands += """"""molecule.fix_orientation(True)\n""""""; commands += """"""molecule.fix_com(True)\n""""""; commands += """"""molecule.update_geometry()\n"""""". if (openshell_override) and (molecule.multiplicity() != 1):; if user_reference == 'RHF':; commands += """"""psi4.set_global_option('REFERENCE', 'UHF')\n""""""; elif user_reference == 'RKS':; commands += """"""psi4.set_global_option('REFERENCE', 'UKS')\n"""""". commands += """"""psi4.set_global_option('WRITER_FILE_LABEL', '%s')\n"""""" % \; (user_writer_file_label + ('' if user_writer_file_label == '' else '-') + rgt). # all modes need to step through the reagents but all for different purposes; # continuous: defines necessary commands, executes energy(method) call, and collects results into dictionary; # sow: opens individual reagent input file, writes the necessary commands, and writes energy(method) call; # reap: opens individual reagent output file, collects results into a dictionary; if db_mode == 'continuous':; exec(banners). molecule = psi4.Molecule.create_molecule_from_string(GEOS[rgt].create_psi4_string_from_molecule()); molecule.set_name(rgt); molecule.update_geometry(). exec(commands); #print 'MOLECULE LIVES %23s %8s %4d %4d %4s' % (rgt, psi4.get_global_option('REFERENCE'),; # molecule.molecular_charge(), molecule.multiplicity(), molecule.schoenflies_symbol()); ERGT[rgt] = func(molecule=molecule, **kwargs); psi4.print_variables(); exec(actives); for envv in db_tabulate:; VRGT[rgt][envv.upper()] = psi4.get_variable(envv); psi4.set_global_option(""REFERENCE"", user_reference); psi4.clean(); #psi4.opt_clean(); psi4.clean_variables(). elif db_mode == 'sow':; with open('%s.in' % (rgt), 'w') as freagent:; freagent.write('# This is a psi4 input file auto-generated from the database() wrapper.\n\n'); frea",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:20669,energy,energy,20669,psi4manual/1.0.0/_modules/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html,2,['energy'],['energy']
Energy Efficiency," fly as necessary. NB: The DIRECT option is not fully implemented and should only be used by experts. Default is NONE. Note: The developers recommend use of this keyword only as a last resort because it significantly slows the calculation. The current algorithms for handling the MO-basis four-virtual-index integrals have been significantly improved and are preferable to the AO-based approach. Type: string; Possible Values: NONE, DISK, DIRECT; Default: NONE. AO_BASIS (CCLAMBDA); CCLAMBDA — The algorithm to use for the terms. Type: string; Possible Values: NONE, DISK, DIRECT; Default: NONE. AO_BASIS (CCSORT); CCSORT — The algorithm to use for the terms. Type: string; Possible Values: NONE, DISK, DIRECT; Default: NONE. AO_BASIS (DCFT); DCFT — Controls whether to avoid the AO->MO transformation of the two-electron integrals for the four-virtual case (<VV||VV>) by computing the corresponding terms in the AO basis. AO_BASIS = DISK algorithm reduces the memory requirements and can significantly reduce the cost of the energy computation if SIMULTANEOUS algorithm is used. For the TWOSTEP algorithm, however, AO_BASIS = DISK option is not recommended due to the extra I/O. Type: string; Possible Values: NONE, DISK; Default: NONE. AO_BASIS (TRANSQT); TRANSQT — The algorithm to use for the terms. Type: string; Possible Values: NONE, DISK, DIRECT; Default: NONE. AO_BASIS (TRANSQT2); TRANSQT2 — The algorithm to use for the terms. Type: string; Possible Values: NONE, DISK, DIRECT; Default: NONE. AVG_STATES (DETCI); DETCI — Array giving the root numbers of the states to average in a state-averaged procedure such as SA-CASSCF. Root numbering starts from 1. Type: array; Default: No Default. AVG_WEIGHTS (DETCI); DETCI — Array giving the weights for each state in a state-averaged procedure. Type: array; Default: No Default. B_RAS3_MAX (DETCI); DETCI — maximum number of beta electrons in RAS III. Type: integer; Default: -1. BASIS (DFMP2); DFMP2 — Primary basis set. Type: string; Possible V",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_glossary_options_c-1.html:3979,reduce,reduces,3979,psi4manual/4.0b4/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_glossary_options_c-1.html,12,"['energy', 'reduce']","['energy', 'reduce', 'reduces']"
Energy Efficiency," fno-ccsd(t); bccd(t); cisd; cisdt. cisdtq; cin; fci; mrccsd; mrccsd(t); mrccsdt; mrccsdt(q). Parameters:; name (string) – 'scf' || 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be 'scf'. Overruled if stage_wfn keywords supplied. scf_wfn (string) – \(\Rightarrow\) 'scf' \(\Leftarrow\) || 'c4-scf' || etc.; Indicates the energy method for which the reference energy is to be; obtained. Generally unnecessary, as ‘scf’ is the scf in PSI4 but; can be used to direct lone scf components to run in PSI4 or Cfour; in a mixed-program composite method. corl_wfn (string) – 'mp2' || 'ccsd(t)' || etc.; Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with name or as the unlabeled; first argument to the function. delta_wfn (string) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. delta_wfn_lesser (string) – \(\Rightarrow\) corl_wfn \(\Leftarrow\) || 'mp2' || etc.; Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. delta2_wfn (string) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. delta2_wfn_lesser (string) – \(\Rightarrow\) delta_wfn \(\Leftarrow\) || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. delta3_wfn (string) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a third delta correction; to the correlation energy is to be obtained. delta3_wfn_lesser (string) – \(\Rightarrow\) delta2_wfn \(\Leftarrow\) || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a third delta correction; to the correlation energ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/cbs-1.html:4163,energy,energy,4163,psi4manual/1.2.1/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/cbs-1.html,14,['energy'],['energy']
Energy Efficiency," fno-df-ccsd(t); * bccd(t); * cisd; * cisdt; * cisdtq; * ci\ *n*; * fci; * mrccsd; * mrccsd(t); * mrccsdt; * mrccsdt(q). :type name: string; :param name: ``'scf'`` || ``'ccsd'`` || etc. First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be ``'scf'``. Overruled if stage_wfn keywords supplied. :type corl_wfn: string; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: string; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: string; :param delta_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: string; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: string; :param delta2_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta3_wfn: string; :param delta3_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a third delta correction; to the correlation energy is to be obtained. :type delta3_wfn_lesser: string; :param delta3_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a third delta correction; to the correlation energy is to be obtained. :type delta4_wfn: string; :param delta4_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:56068,energy,energy,56068,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,2,['energy'],['energy']
Energy Efficiency," fnocc1; Test QCISD(T) for H2O/cc-pvdz Energy. ao-dfcasscf-sp; CASSCF/6-31G** energy point. opt5; 6-31G** UHF CH2 3B1 optimization. Uses a Z-Matrix with dummy atoms, just for demo and testing purposes. cc-module; check that CC is returning the same values btwn CC*, FNOCC, and DFOCC modules. tu4-h2o-freq; Optimization followed by frequencies H2O HF/cc-pVDZ. dct10; The multiple guesses for DCT amplitudes for ODC-12. pubchem2; Superficial test of PubChem interface. dfmp2-grad3; DF-MP2 cc-pVDZ gradients for the H2O molecule. cc26; Single-point gradient, analytic and via finite-differences of 2-1A1 state of H2O with EOM-CCSD. dfomp2-2; OMP2 cc-pVDZ energy for the NO molecule. fnocc5; Test FNO-DF-CCSD(T) energy. cc29; CCSD/cc-pVDZ optical rotation calculation (both gauges) on Cartesian H2O2. props2; DF-SCF cc-pVDZ of benzene-hydronium ion, scanning the dissociation coordinate with Python’s built-in loop mechanism. The geometry is specified by a Z-matrix with dummy atoms, fixed parameters, updated parameters, and separate charge/multiplicity specifiers for each monomer. One-electron properties computed for dimer and one monomer. cc12; Single point energies of multiple excited states with EOM-CCSD. rasci-c2-active; 6-31G* C2 Test RASCI Energy Point, testing two different ways of specifying the active space, either with the ACTIVE keyword, or with RAS1, RAS2, RESTRICTED_DOCC, and RESTRICTED_UOCC. dfccsd-grad1; DF-CCSD cc-pVDZ gradients for the H2O molecule. cc7; Tests CCENERGY’s CCSD gradient in the presence of a dipole field. cc25; Single point gradient of 1-2B2 state of H2O+ with EOM-CCSD. opt-freeze-coords; SCF/cc-pVDZ optimization example with frozen cartesian. sapt0-d; Tests SAPT0-D corrections, with a variety of damping functions/parameters. omp2-1; OMP2 cc-pVDZ energy for the H2O molecule. tu1-h2o-energy; Sample HF/cc-pVDZ H2O computation. opt-multi-frozen-dimer-c2h; Frozen-fragment opt of C2h methane dimer with user-combined reference points. dct1; DC-06, DC-12, ODC-",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html:17398,charge,charge,17398,psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,4,['charge'],['charge']
Energy Efficiency," follow. Since quantum chemical methods in PSI4 are accessed through Python functions, and; most important quantities are available as PSI variables, it is straightforward; to create aliases to commonly run calculations or to define hybrid methods. The; psi4/psi4/driver/aliases.py file is intended for editing by the user for; this purpose.; As an example, the MP2.5 method; (which admittedly is already built in to PSI4); is the average of MP2 and MP3. The latter is; available through the arbitrary order MPn code and returns all lower energies; along with it in PSI variables. The following is basic code that will compute; and return the MP2.5 energy.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14def run_mp2_5(name, **kwargs):. energy('mp3', **kwargs); e_scf = psi4.get_variable('SCF TOTAL ENERGY'); ce_mp2 = psi4.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = psi4.get_variable('MP3 CORRELATION ENERGY'). ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25. print """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); print """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25). return e_mp25. Compare the above to the method that resides in psi4/psi4/driver/aliases.py.; The rationale for the changes is indicated in the comments below.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; 35; 36; 37; 38def run_mp2_5(name, **kwargs):; lowername = name.lower() # handy variable with name keyword in lowercase; kwargs = kwargs_lower(kwargs) # removes case sensitivity in keyword names. # Run detci calculation and collect conventional quantities; energy('mp3', **kwargs); e_scf = psi4.get_variable('SCF TOTAL ENERGY'); ce_mp2 = psi4.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = psi4.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/quickaddalias-1.html:1411,energy,energy,1411,psi4manual/1.1.0/quickaddalias-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/quickaddalias-1.html,6,['energy'],['energy']
Energy Efficiency," following: [Hohenstein:2010:104107]. Basic Keywords Controlling MP2 NO Approximations¶. NAT_ORBS_T2¶. Do use MP2 natural orbital approximations for the block of two-electron integrals in the evaluation of second-order T2 amplitudes? Recommended true for all SAPT computations. Type: boolean; Default: true. NAT_ORBS_T3¶. Do natural orbitals to speed up evaluation of the triples contribution to dispersion by truncating the virtual orbital space? Recommended true for all SAPT computations. Type: boolean; Default: true. NAT_ORBS_V4¶. Do use MP2 natural orbital approximations for the block of two-electron integrals in the evaluation of CCD T2 amplitudes? Recommended true for all SAPT computations. Type: boolean; Default: true. OCC_TOLERANCE¶. Minimum occupation (eigenvalues of the MP2 OPDM) below which virtual natural orbitals are discarded for in each of the above three truncations. Type: conv double; Default: 1.0e-6. Charge-Transfer in SAPT¶; It is possible to obtain the stabilization energy of a complex due to; charge-transfer effects from a SAPT computation. The charge-transfer energy; can be computed with the SAPT module as described by Stone; and Misquitta [Misquitta:2009:201].; Charge-transfer energies can be obtained from the following calls to the; energy function.; energy('sapt0-ct'); energy('sapt2-ct'); energy('sapt2+-ct'); energy('sapt2+(3)-ct'); energy('sapt2+3-ct'); energy('sapt2+(ccd)-ct'); energy('sapt2+(3)(ccd)-ct'); energy('sapt2+3(ccd)-ct'). A SAPT charge-transfer analysis will perform 5 HF computations: the dimer; in the dimer basis, monomer A in the dimer basis, monomer B in the dimer; basis, monomer A in the monomer A basis, and monomer B in the monomer B; basis. Next, it performs two SAPT computations, one in the dimer basis and; one in the monomer basis. Finally, it will print a summary of the; charge-transfer results:; SAPT Charge Transfer Analysis; ------------------------------------------------------------------------------------------------; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/sapt-1.html:17245,energy,energy,17245,psi4manual/1.0.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/sapt-1.html,4,"['charge', 'energy']","['charge-transfer', 'energy']"
Energy Efficiency," for MP2 CORRELATION ENERGY; mp2 / aug-cc-pvqz for MP2 CORRELATION ENERGY; ccsd(t) / aug-cc-pvdz for CCSD(T) CORRELATION ENERGY; ccsd(t) / aug-cc-pvtz for CCSD(T) CORRELATION ENERGY; mp2 / aug-cc-pvdz for MP2 CORRELATION ENERGY; mp2 / aug-cc-pvtz for MP2 CORRELATION ENERGY. Enlightened listing of computations required.; mp2 / aug-cc-pvqz for MP2 CORRELATION ENERGY; ccsd(t) / aug-cc-pvdz for CCSD(T) CORRELATION ENERGY; ccsd(t) / aug-cc-pvtz for CCSD(T) CORRELATION ENERGY. At the end of a cbs() job is printed a summary section like the one below. First,; in the components section, are listed the results for each model chemistry available, whether; required for the cbs job (*) or not. Next, in the stages section, are listed the results for; each extrapolation. The energies of this section must be dotted with the weightings in column Wt; to get the total cbs energy. Finally, in the CBS section, are listed the results for each stage; of the cbs procedure. The stage energies of this section sum outright to the total cbs energy.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; 35; 36; 37; 38==> Components <==. ----------------------------------------------------------------------------------; Method / Basis Rqd Energy [H] Variable; ----------------------------------------------------------------------------------; scf / aug-cc-pvqz * -1.11916375 SCF TOTAL ENERGY; mp2 / aug-cc-pvqz * -0.03407997 MP2 CORRELATION ENERGY; scf / aug-cc-pvdz -1.11662884 SCF TOTAL ENERGY; mp2 / aug-cc-pvdz * -0.02881480 MP2 CORRELATION ENERGY; ccsd(t) / aug-cc-pvdz * -0.03893812 CCSD(T) CORRELATION ENERGY; ccsd / aug-cc-pvdz -0.03893812 CCSD CORRELATION ENERGY; scf / aug-cc-pvtz -1.11881134 SCF TOTAL ENERGY; mp2 / aug-cc-pvtz * -0.03288936 MP2 CORRELATION ENERGY; ccsd(t) / aug-cc-pvtz * -0.04201004 CCSD(T) CORRELATION ENERGY; ccsd / aug-cc-pvtz -0.04201004 CCSD CORRELATION ENERGY; ---------------------------------------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/cbs-1.html:14515,energy,energy,14515,psi4manual/1.2.1/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/cbs-1.html,6,['energy'],['energy']
Energy Efficiency," for MP2 CORRELATION ENERGY; mp2 / aug-cc-pvqz for MP2 CORRELATION ENERGY; ccsd(t) / aug-cc-pvdz for CCSD(T) CORRELATION ENERGY; ccsd(t) / aug-cc-pvtz for CCSD(T) CORRELATION ENERGY; mp2 / aug-cc-pvdz for MP2 CORRELATION ENERGY; mp2 / aug-cc-pvtz for MP2 CORRELATION ENERGY. Enlightened listing of computations required.; mp2 / aug-cc-pvqz for MP2 CORRELATION ENERGY; ccsd(t) / aug-cc-pvdz for CCSD(T) CORRELATION ENERGY; ccsd(t) / aug-cc-pvtz for CCSD(T) CORRELATION ENERGY. At the end of a cbs() job is printed a summary section like the one below. First,; in the components section, are listed the results for each model chemistry available, whether; required for the cbs job (*) or not. Next, in the stages section, are listed the results for; each extrapolation. The energies of this section must be dotted with the weightings in column Wt; to get the total cbs energy. Finally, in the CBS section, are listed the results for each stage; of the cbs procedure. The stage energies of this section sum outright to the total cbs energy.; ==> Components <==. ----------------------------------------------------------------------------------; Method / Basis Rqd Energy [H] Variable; ----------------------------------------------------------------------------------; scf / aug-cc-pvqz * -1.11916375 SCF TOTAL ENERGY; mp2 / aug-cc-pvqz * -0.03407997 MP2 CORRELATION ENERGY; scf / aug-cc-pvdz -1.11662884 SCF TOTAL ENERGY; mp2 / aug-cc-pvdz * -0.02881480 MP2 CORRELATION ENERGY; ccsd(t) / aug-cc-pvdz * -0.03893812 CCSD(T) CORRELATION ENERGY; ccsd / aug-cc-pvdz -0.03893812 CCSD CORRELATION ENERGY; scf / aug-cc-pvtz -1.11881134 SCF TOTAL ENERGY; mp2 / aug-cc-pvtz * -0.03288936 MP2 CORRELATION ENERGY; ccsd(t) / aug-cc-pvtz * -0.04201004 CCSD(T) CORRELATION ENERGY; ccsd / aug-cc-pvtz -0.04201004 CCSD CORRELATION ENERGY; ----------------------------------------------------------------------------------. ==> Stages <==. --------------------------------------------------------------------------------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/cbs-1.html:13344,energy,energy,13344,psi4manual/1.0.0/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/cbs-1.html,19,['energy'],['energy']
Energy Efficiency," for SAPT0 electrostatics and induction. This example uses frozen core as well as asyncronous I/O while forming the DF integrals and CPHF coefficients. cc19; CCSD/cc-pVDZ dipole polarizability at two frequencies. cc4; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. After the computation, the checkpoint file is renamed, using the PSIO handler. cc10; ROHF-CCSD cc-pVDZ energy for the state of the CN radical. castup3; SCF with various combinations of pk/density-fitting, castup/no-castup, and spherical/cartesian settings. Demonstrates that puream setting is getting set by orbital basis for all df/castup parts of calc. Demonstrates that answer doesn’t depend on presence/absence of castup. Demonstrates (by comparison to castup2) that output file doesn’t depend on options (scf_type) being set global or local. This input uses local. cc8c; ROHF-CCSD cc-pVDZ frozen-core energy for the state of the CN radical, with Cartesian input. scf1; RHF cc-pVQZ energy for the BH molecule, with Cartesian input. cisd-h2o+-0; 6-31G** H2O+ Test CISD Energy Point. cc43; RHF-CC2-LR/STO-3G optical rotation of (S)-methyloxirane. gauge = both, omega = (589 355 nm). cc27; Single point gradient of 1-1B2 state of H2O with EOM-CCSD. cisd-sp-2; 6-31G** H2O Test CISD Energy Point. opt1; SCF STO-3G geometry optimzation, with Z-matrix input. dft2; DFT Functional Test. cc15; RHF-B-CCD(T)/6-31G** H2O single-point energy (fzc, MO-basis ). dft1; DFT Functional Test. cc18; RHF-CCSD-LR/cc-pVDZ static polarizability of HOF. mom; Maximum Overlap Method (MOM) Test. MOM is designed to stabilize SCF convergence and to target excited Slater determinants directly. fci-h2o-fzcv; 6-31G H2O Test FCI Energy Point. pywrap-cbs1; Various basis set extrapolation tests. fd-freq-energy; SCF STO-3G finite-difference frequencies from energies. dcft5; DCFT-06 calculation for the O2 molecule (triplet ground state). This performs geometry optimization using two-step and simultaneous solution of the re",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_testsuite-1.html:8013,energy,energy,8013,psi4manual/4.0b3/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_testsuite-1.html,4,['energy'],['energy']
Energy Efficiency," for SCS-MP2. Type: double; Default: 1.0/3.0. MP2_SS_SCALE (CCENERGY); CCENERGY — MP2 same-spin scaling value. Type: double; Default: 1.0/3.0. MP2_SS_SCALE (DFMP2); DFMP2 — SS Scale. Type: double; Default: 1.0/3.0. MP2_SS_SCALE (LMP2); LMP2 — The scale factor used for same-spin pairs in SCS computations. Type: double; Default: 1.0/3.0. MP2_SS_SCALE (MP2); MP2 — The scale factor used for same-spin pairs in SCS computations. Type: double; Default: 1.0/3.0. MP2_SS_SCALE (OMP2); OMP2 — MP2 same-spin scaling value. Type: double; Default: 1.0/3.0. MP2_SS_SCALE (OMP3); OMP3 — MP2 same-spin scaling value. Type: double; Default: 1.0/3.0. MP2_TYPE (MP2); MP2 — What algorithm to use for the MP2 computation. Type: string; Possible Values: DF, CONV; Default: DF. MP2R12A (TRANSQT); TRANSQT — Transformations for explicitly-correlated MP2 methods. Type: string; Possible Values: MP2R12AERI, MP2R12AR12, MP2R12AR12T1; Default: MP2R12AERI. MP3L_ENERGY (OMP3); OMP3 — Do compute mp3l energy? In order to this option to be valid one should use “TPDM_ABCD_TYPE COMPUTE” option. Type: boolean; Default: false. MPN (DETCI); DETCI — Do compute the MPn series out to kth order where k is determined by MAX_NUM_VECS ? For open-shell systems (REFERENCE is ROHF, WFN is ZAPTN), DETCI will compute the ZAPTn series. GUESS_VECTOR must be set to UNIT, HD_OTF must be set to TRUE, and HD_AVG must be set to orb_ener; these should happen by default for MPN = TRUE. Type: boolean; Default: false. MPN_ORDER_SAVE (DETCI); DETCI (Expert) — If 0, save the MPn energy; if 1, save the MP(2n-1) energy (if available from MPN_WIGNER = true); if 2, save the MP(2n-2) energy (if available from MPN_WIGNER = true). Type: integer; Default: 0. MPN_SCHMIDT (DETCI); DETCI (Expert) — Do employ an orthonormal vector space rather than storing the kth order wavefunction?. Type: boolean; Default: false. MPN_WIGNER (DETCI); DETCI (Expert) — Do use Wigner formulas in the series?. Type: boolean; Default: true. MRCC_LEVEL (MRCC); MRCC — Max",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html:77480,energy,energy,77480,psi4manual/4.0b3/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html,2,['energy'],['energy']
Energy Efficiency," for available; molecular systems (case insensitive).; * ``[1,2,5]`` || ``['1','2','5']`` || ``['BzMe-3.5', 'MeMe-5.0']`` || etc.; Specify a list of database members to run. Consult the; database python files for available molecular systems. This; is the only portion of database input that is case sensitive;; choices for this keyword must match the database python file. :examples:. >>> # [1] Two-stage SCF calculation on short, equilibrium, and long helium dimer; >>> db('scf','RGC10',cast_up='sto-3g',subset=['HeHe-0.85','HeHe-1.0','HeHe-1.5'], tabulate=['scf total energy','natom']). >>> # [2] Counterpoise-corrected interaction energies for three complexes in S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('mp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). """"""; lowername = name #TODO; kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name #.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish function to call; func = kwargs.pop('db_func', kwargs.pop('func', energy)); kwargs['db_func'] = func; # Bounce to CP if bsse kwarg (someday); if kwargs.get('bsse_type', None) is not None:; raise ValidationError(""""""Database: Cannot specify bsse_type for database. Use the cp keyword withing database instead.""""""). allowoptexceeded = kwargs.get('allowoptexceeded', False); optstash = p4util.OptionsState(; ['WRITER_FILE_LABEL'],; ['SCF', 'R",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html:7874,energy,energy,7874,psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html,27,['energy'],['energy']
Energy Efficiency," for available; molecular systems (case insensitive).; * ``[1,2,5]`` || ``['1','2','5']`` || ``['BzMe-3.5', 'MeMe-5.0']`` || etc.; Specify a list of database members to run. Consult the; database python files for available molecular systems. This; is the only portion of database input that is case sensitive;; choices for this keyword must match the database python file. :examples:. >>> # [1] Two-stage SCF calculation on short, equilibrium, and long helium dimer; >>> db('scf','RGC10',cast_up='sto-3g',subset=['HeHe-0.85','HeHe-1.0','HeHe-1.5'], tabulate=['scf total energy','natom']). >>> # [2] Counterpoise-corrected interaction energies for three complexes in S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('mp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). """"""; lowername = name #TODO; kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name #.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish function to call; func = kwargs.pop('db_func', kwargs.pop('func', energy)); kwargs['db_func'] = func; # Bounce to CP if bsse kwarg (someday); if kwargs.get('bsse_type', None) is not None:; raise ValidationError(""""""Database: Cannot specify bsse_type for database. Use the cp keyword withing database instead.""""""). optstash = p4util.OptionsState(; ['WRITER_FILE_LABEL'],; ['SCF', 'REFERENCE']). # Wrapper wholly defines molecule. discard an",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:7959,energy,energy,7959,psi4manual/1.0.0/_modules/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html,6,['energy'],['energy']
Energy Efficiency," for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. E_CONVERGENCE (DCT)¶DCT — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-10. E_CONVERGENCE (DETCI)¶DETCI — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. E_CONVERGENCE (DFOCC)¶DFOCC — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. E_CONVERGENCE (FNOCC)¶FNOCC — Convergence criterion for CC energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Note that convergence is met only when E_CONVERGENCE and R_CONVERGENCE are satisfied. Type: conv double; Default: 1.0e-6. E_CONVERGENCE (MCSCF)¶MCSCF — Convergence criterion for energy. Type: conv double; Default: 1e-6. E_CONVERGENCE (MRCC)¶MRCC — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. This becomes tol (option #16) in fort.56. Type: conv double; Default: 1e-6. E_CONVERGENCE (OCC)¶OCC — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. E_CONVERGENCE (PSIMRCC)¶PSIMRCC — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. E_CONVERGENCE (SAPT)¶SAPT — Convergence criterion for energy (change) in the SAPT \(E_{ind,resp}^{(20)}\) term during solution of the CPHF equations. Type: conv double; Default: 1e-10. E_CONVERGENCE (SCF)¶SCF — Convergence criterion for SCF energy. See Table SCF Convergence & Algorithm for default convergen",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:117896,energy,energy,117896,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,2,['energy'],['energy']
Energy Efficiency," for fuller description. [T] CORRECTION ENERGY¶; The coupled-cluster bracket perturbative triples correction [Eh]. (T) CORRECTION ENERGY¶; The coupled-cluster perturbative triples correction [Eh]. (AT) CORRECTION ENERGY¶. A-(T) CORRECTION ENERGY¶; The coupled-cluster asymmetric perturbative triples correction [Eh]. AAA (T) CORRECTION ENERGY¶. AAB (T) CORRECTION ENERGY¶. ABB (T) CORRECTION ENERGY¶. BBB (T) CORRECTION ENERGY¶; Spin components of the UHF-based coupled-cluster perturbative triples correction [Eh]. ACPF DIPOLE¶; Dipole array [e a0] for the averaged coupled-pair functional level of theory, (3,). ACPF QUADRUPOLE¶; Redundant quadrupole array [e a0^2] for the averaged coupled-pair functional level of theory, (3, 3). ACPF TOTAL ENERGY¶. ACPF CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the averaged coupled-pair functional level of theory. ADC ROOT 0 -> ROOT n EXCITATION ENERGY¶. TD-fctl ROOT 0 -> ROOT n EXCITATION ENERGY¶; The excitation energy [Eh} from ground state to root n.; DFT functional labeled if canonical. ADC ROOT 0 (IN h) -> ROOT n (IN i) EXCITATION ENERGY¶. TD-fctl ROOT 0 (IN h) -> ROOT n (IN i) EXCITATION ENERGY¶; The excitation energy [Eh] from the ground state (which is of irrep h); to root n within irrep i.; DFT functional labeled if canonical. ADC ROOT 0 (h) -> ROOT n (i) EXCITATION ENERGY¶. TD-fctl ROOT 0 (h) -> ROOT n (i) EXCITATION ENERGY¶; The excitation energy [Eh] from the ground state (which is of irrep h); to root n (which is of irrep i).; DFT functional labeled if canonical. ADC ROOT 0 -> ROOT n EXCITATION ENERGY - h TRANSITION¶. TD-fctl ROOT 0 -> ROOT n EXCITATION ENERGY - h TRANSITION¶; The excitation energy [Eh] from the ground state to root n, and the; transition is of irrep h.; DFT functional labeled if canonical. ADC ROOT 0 -> ROOT n ELECTRIC TRANSITION DIPOLE MOMENT (LEN)¶. TD-fctl ROOT 0 -> ROOT n ELECTRIC TRANSITION DIPOLE MOMENT (LEN)¶; The electric transition dipole moment",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/glossary_psivariables.html:1313,energy,energy,1313,psi4manual/1.6.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/glossary_psivariables.html,1,['energy'],['energy']
Energy Efficiency," for item in restartfile:; name_split = re.split(r'\.', item); if ""npz"" in item:; fname = os.path.split(os.path.abspath(core.get_writer_file_prefix(molecule.name())))[1]; psi_scratch = core.IOManager.shared_object().get_default_path(); file_num = item.split('.')[-2]; targetfile = os.path.join(psi_scratch, fname + ""."" + file_num + "".npz""); else:; filenum = name_split[-1]; try:; filenum = int(filenum); except ValueError:; filenum = 32 # Default file number is the checkpoint one; psioh = core.IOManager.shared_object(); psio = core.IO.shared_object(); filepath = psioh.get_file_path(filenum); namespace = psio.get_default_namespace(); pid = str(os.getpid()); prefix = 'psi'; targetfile = filepath + prefix + '.' + pid + '.' + namespace + '.' + str(filenum); shutil.copy(item, targetfile). wfn = procedures['energy'][lowername](lowername, molecule=molecule, **kwargs). for postcallback in hooks['energy']['post']:; postcallback(lowername, wfn=wfn, **kwargs). optstash.restore(); if return_wfn: # TODO current energy safer than wfn.energy() for now, but should be revisited. # TODO place this with the associated call, very awkward to call this in other areas at the moment; if lowername in ['efp', 'mrcc', 'dmrg', 'psimrcc']:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the incoming reference wavefunction.\n\n""); elif 'sapt' in lowername:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the dimer SCF wavefunction.\n\n""). return (core.get_variable('CURRENT ENERGY'), wfn); else:; return core.get_variable('CURRENT ENERGY'). [docs]def gradient(name, **kwargs):; r""""""Function complementary to :py:func:~driver.optimize(). Carries out one gradient pass,; deciding analytic or finite difference. :returns: :py:class:`~psi4.core.Matrix` |w--w| Total electronic gradient in Hartrees/Bohr. :returns: (:py:class:`~psi4.core",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html:33323,energy,energy,33323,psi4manual/1.2.1/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html,1,['energy'],['energy']
Energy Efficiency," for item in restartfile:; name_split = re.split(r'\.', item); if ""npz"" in item:; fname = os.path.split(os.path.abspath(core.get_writer_file_prefix(molecule.name())))[1]; psi_scratch = core.IOManager.shared_object().get_default_path(); file_num = item.split('.')[-2]; targetfile = os.path.join(psi_scratch, fname + ""."" + file_num + "".npz""); else:; filenum = name_split[-1]; try:; filenum = int(filenum); except ValueError:; filenum = 32 # Default file number is the checkpoint one; psioh = core.IOManager.shared_object(); psio = core.IO.shared_object(); filepath = psioh.get_file_path(filenum); namespace = psio.get_default_namespace(); pid = str(os.getpid()); prefix = 'psi'; targetfile = filepath + prefix + '.' + pid + '.' + namespace + '.' + str(filenum); shutil.copy(item, targetfile). wfn = procedures['energy'][lowername](lowername, molecule=molecule, **kwargs). for postcallback in hooks['energy']['post']:; postcallback(lowername, wfn=wfn, **kwargs). optstash.restore(); if return_wfn: # TODO current energy safer than wfn.energy() for now, but should be revisited. # TODO place this with the associated call, very awkward to call this in other areas at the moment; if lowername in ['efp', 'mrcc', 'dmrg', 'psimrcc']:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the incoming reference wavefunction.\n\n""); elif 'sapt' in lowername:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the dimer SCF wavefunction.\n\n""). return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]def gradient(name, **kwargs):; r""""""Function complementary to :py:func:~driver.optimize(). Carries out one gradient pass,; deciding analytic or finite difference. :returns: :py:class:`~psi4.core.Matrix` |w--w| Total electronic gradient in Hartrees/Bohr. :returns: (:py:class:`~psi4.core.Matrix`",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html:35557,energy,energy,35557,psi4manual/1.3.2/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html,1,['energy'],['energy']
Energy Efficiency," for m in monomers_in_monomer_basis]; monomer_sum = sum(monomer_energy_list); else:; monomer_sum = _sum_cluster_ptype_data(; ptype,; component_results,; monomers_in_monomer_basis,; fragment_slice_dict,; fragment_size_dict,; mc_level_lbl=mc_level_lbl,; ); else:; monomer_sum = shaped_zero(ptype). nbody_dict = {}. # Compute cp; if 'cp' in metadata['bsse_type']:; for nb in range(1, nbodies[-1] + 1):; if nb == metadata['nfragments']:; if ptype == ""energy"":; cp_body_dict[nb] = cp_by_level[nb] - bsse; else:; cp_body_dict[nb][:] = cp_by_level[nb] - bsse; continue. for k in range(1, nb + 1):; take_nk = math.comb(metadata['nfragments'] - k - 1, nb - k); sign = ((-1)**(nb - k)); cp_body_dict[nb] += take_nk * sign * cp_by_level[k]. if nb == 1:; bsse = cp_body_dict[nb] - monomer_sum; if ptype == ""energy"":; cp_body_dict[nb] = monomer_sum; else:; cp_body_dict[nb] = monomer_sum.copy(); else:; cp_body_dict[nb] -= bsse. if ptype == ""energy"":; if not metadata[""quiet""]:; _print_nbody_energy(cp_body_dict, ""Counterpoise Corrected (CP)"", metadata[""nfragments""], metadata['embedding_charges']). if monomer_sum != 0.0:; nbody_dict[""CP-CORRECTED TOTAL ENERGY""] = cp_body_dict[metadata['max_nbody']]; nbody_dict[""CP-CORRECTED INTERACTION ENERGY""] = cp_body_dict[metadata['max_nbody']] - cp_body_dict[1]. for nb in nbodies[1:]:; nbody_dict[f""CP-CORRECTED INTERACTION ENERGY THROUGH {nb}-BODY""] = cp_body_dict[nb] - cp_body_dict[1]; nbody_dict[f""CP-CORRECTED {nb}-BODY CONTRIBUTION TO ENERGY""] = cp_body_dict[nb] - cp_body_dict[nb-1]; for nb in nbodies:; nbody_dict[f""CP-CORRECTED TOTAL ENERGY THROUGH {nb}-BODY""] = cp_body_dict[nb]. # Compute nocp; if 'nocp' in metadata['bsse_type']:; for nb in range(1, nbodies[-1] + 1):; if nb == metadata['nfragments']:; if ptype == ""energy"":; nocp_body_dict[nb] = nocp_by_level[nb]; else:; nocp_body_dict[nb][:] = nocp_by_level[nb]; continue. for k in range(1, nb + 1):; take_nk = math.comb(metadata['nfragments'] - k - 1, nb - k); sign = ((-1)**(nb - k)); nocp_body_dict[nb]",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html:26957,energy,energy,26957,psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html,5,['energy'],['energy']
Energy Efficiency," for the ACPF, AQCC, CISD, and CEPA(0) methods. Type: boolean; Default: false. DISP_SIZE (FINDIF)¶FINDIF — Displacement size in au for finite-differences. Type: double; Default: 0.005. DISTRIBUTED_MATRIX (SCF)¶SCF (Expert) — The dimension sizes of the distributed matrix. Type: array; Default: No Default. DKH_ORDER (GLOBALS)¶GLOBALS (Expert) — Order of Douglas-Kroll-Hess. Type: integer; Default: 2. DLPNO_LOCAL_ORBITALS (DLPNO)¶DLPNO — Orbital localizer. Type: string; Possible Values: BOYS, PIPEK_MEZEY; Default: BOYS. DLPNO_MAXITER (DLPNO)¶DLPNO — Maximum number of iterations to determine the MP2 amplitudes. Type: integer; Default: 50. DMRG_CASPT2_CALC (DMRG)¶DMRG — Do calculate the DMRG-CASPT2 energy after the DMRGSCF calculations are done?. Type: boolean; Default: false. DMRG_CASPT2_IMAG (DMRG)¶DMRG — CASPT2 Imaginary shift. Type: double; Default: 0.0. DMRG_CASPT2_IPEA (DMRG)¶DMRG — CASPT2 IPEA shift. Type: double; Default: 0.0. DMRG_CASPT2_ORBS (DMRG)¶DMRG — Whether to calculate the DMRG-CASPT2 energy after the DMRGSCF calculations are done. Type: string; Possible Values: PSEUDOCANONICAL, ACTIVE; Default: PSEUDOCANONICAL. DMRG_DIIS (DMRG)¶DMRG — Whether or not to use DIIS for DMRG. Type: boolean; Default: false. DMRG_DIIS_WRITE (DMRG)¶DMRG — Whether or not to store the DIIS checkpoint on disk (convenient for restarting). Type: boolean; Default: true. DMRG_EXCITATION (DMRG)¶DMRG — Which root is targeted: 0 means ground state, 1 first excited state, etc. Type: integer; Default: 0. DMRG_IRREP (DMRG)¶DMRG — The DMRG wavefunction irrep uses the same conventions as PSI4. How convenient :-). Just to avoid confusion, it’s copied here. It can also be found on http://sebwouters.github.io/CheMPS2/doxygen/classCheMPS2_1_1Irreps.html . Symmetry Conventions Irrep Number & Name Group Number & Name 0 1 2 3 4 5 6 7 0: c1 A 1: ci Ag Au 2: c2 A B 3: cs A’ A’’ 4: d2 A B1 B2 B3 5: c2v A1 A2 B1 B2 6: c2h Ag Bg Au Bu 7: d2h Ag B1g B2g B3g Au B1u B2u B3u. Type: integer; Default: -1. DMRG_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_glossary_options_c-1.html:110713,energy,energy,110713,psi4manual/1.5.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_glossary_options_c-1.html,6,['energy'],['energy']
Energy Efficiency," for the H2O molecule. cc2; 6-31G** H2O CCSD optimization by energies, with Z-Matrix input. cc45; RHF-EOM-CC2/cc-pVDZ lowest two states of each symmetry of H2O. fci-tdm-2; BH-H2+ FCI/cc-pVDZ Transition Dipole Moment. psimrcc-ccsd_t-2; Mk-MRCCSD(T) single point. CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. sad1; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. psimrcc-fd-freq1; Mk-MRCCSD single point. O2 state described using the Ms = 0 component of the triplet. Uses ROHF triplet orbitals. rasci-h2o; RASCI/6-31G** H2O Energy Point. cc17; Single point energies of multiple excited states with EOM-CCSD. tu3-h2o-opt; Optimize H2O HF/cc-pVDZ. mrcc2; CCSDT(Q) cc-pVDZ energy for the H2O molecule using MRCC. This example builds up from CCSD. First CCSD, then CCSDT, finally CCSDT(Q). cc21; ROHF-EOM-CCSD/DZ analytic gradient lowest excited state of H2O+ (B1 excitation). opt4; SCF cc-pVTZ geometry optimzation, with Z-matrix input. cc13a; UHF-CCSD(T)/cc-pVDZ CH2 geometry optimization via analytic gradients. mpn-bh; MP(n)/aug-cc-pVDZ BH Energy Point, with n=2-19. Compare against M. L. Leininger et al., J. Chem. Phys. 112, 9213 (2000). cc38; RHF-CC2-LR/cc-pVDZ static polarizabilities of HOF molecule. mrcc3; CCSD(T) cc-pVDZ geometry optimization for the H2O molecule using MRCC. opt3; SCF cc-pVDZ geometry optimzation, with Z-matrix input. cc3; cc3: RHF-CCSD/6-31G** H2O geometry optimization and vibrational frequency analysis by finite-differences of gradients. scf-bz2; Benzene Dimer Out-of-Core HF/cc-pVDZ. cc51; EOM-CC3/cc-pVTZ on H2O. fci-h2o-2; 6-31G H2O Test FCI Energy Point. cc31; CCSD/sto-3g optical rotation calculation (both gauges) at two frequencies on meth",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_testsuite-1.html:13647,energy,energy,13647,psi4manual/4.0b3/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_testsuite-1.html,4,['energy'],['energy']
Energy Efficiency," for the \(^2\Sigma^+\) state of the CN radical, with Z-matrix input. dfremp-2; density fitted REMP/cc-pVDZ energies for the CH3 radical. mints-helper; A general test of the MintsHelper function. dct-grad3; Restricted DF-DCT ODC-12 gradient for ethylene with cc-pVDZ/cc-pVDZ-RI standard/auxiliary basis set. mints10; H2 with tiny basis set, to test basis set parser’s handling of integers. mp2-h; check that methods can act on single atom. dfep2-2; Compute three IP and 2 EA’s for the PH3 molecule. cdremp-1; Cholesky decomposed REMP/cc-pVDZ energies for the CO2 molecule. cbs-xtpl-opt; Various extrapolated optimization methods for the H2 molecule. lccd-grad2; LCCD cc-pVDZ gradient for the NO radical. cc32; CC3/cc-pVDZ H2O \(R_e\) geom from Olsen et al., JCP 104, 8007 (1996). tdscf-6; td-camb3lyp with DiskDF and method/basis specification. cdomp2-2; OMP2 cc-pVDZ energy for the NO molecule. cc13; UHF-CCSD/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. casscf-sp; CASSCF/6-31G** energy point. cc13a; UHF-CCSD(T)/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. cbs-xtpl-func; optimization with method defined via cbs. omp3-2; OMP3 cc-pCVDZ energy with ROHF initial guess for the NO radical. dfmp2-fc; Kr–Kr nocp energies with all-electron basis set to check frozen core. scf-occ; force occupations in scf. cdoremp-energy2; density fitted OO-REMP/cc-pVDZ engrad single points for the H2O+ molecule. dft-b2plyp; Double-hybrid density functional B2PYLP. Reproduces portion of Table I in S. Grimme’s J. Chem. Phys 124 034108 (2006) paper defining the functional. cc5; RHF CCSD(T) cc-pVDZ frozen-core energy of C4NH4 Anion. aediis-2; EDIIS test case from 10.1063/1.1470195. sapt7; SAPT0 open-shell computation of H2O-HO2 interaction energy First with cc-pVDZ and density fitted integrals with UHF Then with 6-31g and direct integrals, except for dispersion that is computed with cc-pVDZ-ri density fitting with UHF. isapt2; This is a shorter version if isa",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html:34513,energy,energy,34513,psi4manual/master/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency," for the perturbatively corrected coupled-cluster (CCSD(T), A-CCSD(T) = CCSD(AT), CCSDT(Q),; up to CC(n-1)(n) level of theory. CCSDT-1a TOTAL ENERGY¶. CCSDT-1a CORRELATION ENERGY¶. CCSDTQ-1a TOTAL ENERGY¶. CCSDTQ-1a CORRELATION ENERGY¶. CCn-1a TOTAL ENERGY¶. CCn-1a CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the approximate coupled-cluster (CCSD(T)-1a, CCSDT(Q)-1a,; up to CCn-1a) level of theory. CCSDT-1b TOTAL ENERGY¶. CCSDT-1b CORRELATION ENERGY¶. CCSDTQ-1b TOTAL ENERGY¶. CCSDTQ-1b CORRELATION ENERGY¶. CCn-1b TOTAL ENERGY¶. CCn-1b CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the approximate coupled-cluster (CCSD(T)-1b, CCSDT(Q)-1b,; up to CCn-1b) level of theory. CCSDT-3 TOTAL ENERGY¶. CCSDT-3 CORRELATION ENERGY¶. CCSDTQ-3 TOTAL ENERGY¶. CCSDTQ-3 CORRELATION ENERGY¶. CCn-3 TOTAL ENERGY¶. CCn-3 CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the approximate coupled-cluster (CCSD(T)-3, CCSDT(Q)-3,; up to CCn-3) level of theory. CCSD(T)_L TOTAL ENERGY¶. CCSD(T)_L CORRELATION ENERGY¶. CCSDT(Q)_L TOTAL ENERGY¶. CCSDT(Q)_L CORRELATION ENERGY¶. CC(n-1)(n)_L TOTAL ENERGY¶. CC(n-1)(n)_L CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the approximate coupled-cluster (CCSD(T)_L, CCSDT(Q)_L,; up to CC(n-1)(n)L level of theory. CCSDT(Q)/A TOTAL ENERGY¶. CCSDT(Q)/A CORRELATION ENERGY¶. CCSDT(Q)/B TOTAL ENERGY¶. CCSDT(Q)/B CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the modified CCSDT(Q) level of theory. CCSD DIPOLE POLARIZABILITY @ xNM¶; The dipole polarizability [au] calculated at the CCSD level; for a given (x) wavelength, (x) rounded to nearest integer. CCSD SPECIFIC ROTATION (LEN) @ xNM¶; The specific rotation [deg/(dm (g/cm^3))] calculated at the CCSD level in the; length gauge for a given (x) wavelength, (x) rounded to n",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/glossary_psivariables-1.html:7672,energy,energy,7672,psi4manual/1.5.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/glossary_psivariables-1.html,4,['energy'],['energy']
Energy Efficiency," for the perturbatively corrected coupled-cluster (CCSD(T), A-CCSD(T) = CCSD(AT), CCSDT(Q),; up to CC(n-1)(n) level of theory. CCSDT-1a TOTAL ENERGY¶. CCSDT-1a CORRELATION ENERGY¶. CCSDTQ-1a TOTAL ENERGY¶. CCSDTQ-1a CORRELATION ENERGY¶. CCn-1a TOTAL ENERGY¶. CCn-1a CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the approximate coupled-cluster (CCSD(T)-1a, CCSDT(Q)-1a,; up to CCn-1a) level of theory. CCSDT-1b TOTAL ENERGY¶. CCSDT-1b CORRELATION ENERGY¶. CCSDTQ-1b TOTAL ENERGY¶. CCSDTQ-1b CORRELATION ENERGY¶. CCn-1b TOTAL ENERGY¶. CCn-1b CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the approximate coupled-cluster (CCSD(T)-1b, CCSDT(Q)-1b,; up to CCn-1b) level of theory. CCSDT-3 TOTAL ENERGY¶. CCSDT-3 CORRELATION ENERGY¶. CCSDTQ-3 TOTAL ENERGY¶. CCSDTQ-3 CORRELATION ENERGY¶. CCn-3 TOTAL ENERGY¶. CCn-3 CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the approximate coupled-cluster (CCSD(T)-3, CCSDT(Q)-3,; up to CCn-3) level of theory. CCSD(T)_L TOTAL ENERGY¶. CCSD(T)_L CORRELATION ENERGY¶. CCSDT(Q)_L TOTAL ENERGY¶. CCSDT(Q)_L CORRELATION ENERGY¶. CC(n-1)(n)_L TOTAL ENERGY¶. CC(n-1)(n)_L CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the approximate coupled-cluster (CCSD(T)_L, CCSDT(Q)_L,; up to CC(n-1)(n)L level of theory. CCSDT(Q)/A TOTAL ENERGY¶. CCSDT(Q)/A CORRELATION ENERGY¶. CCSDT(Q)/B TOTAL ENERGY¶. CCSDT(Q)/B CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the modified CCSDT(Q) level of theory. CEPA(0) DIPOLE¶; Dipole array [e a0] for the coupled electron pair approximation variant 0 level of theory, (3,). CEPA(0) QUADRUPOLE¶; Redundant quadrupole array [e a0^2] for the coupled electron pair approximation variant 0 level of theory, (3, 3). CEPA(0) TOTAL ENERGY¶. CEPA(0) CORRELATION ENERGY¶. CEPA(1) TOTAL ENERGY¶. CEPA",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/glossary_psivariables.html:19607,energy,energy,19607,psi4manual/1.6.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/glossary_psivariables.html,2,['energy'],['energy']
Energy Efficiency," for whether the option has been touched in the global scope, by either user or code. Notwithstanding, code is written such that in practice, this returns whether the option has been touched in the global scope by the user.; ; has_local_option_changed(...); has_local_option_changed( (str)arg1, (str)arg2) -> bool :; Returns boolean for whether the option has been touched in the scope of the specified module, by either user or code. Notwithstanding, code is written such that in practice, this returns whether the option has been touched in the module scope by the user.; ; has_option_changed(...); has_option_changed( (str)arg1, (str)arg2) -> bool :; Returns boolean for whether the option has been touched either locally to the specified module or globally, by either user or code. Notwithstanding, code is written such that in practice, this returns whether the option has been touched by the user.; ; infsapt(...); infsapt( (Wavefunction)arg1, (Wavefunction)arg2, (Wavefunction)arg3) -> float :; Runs the infinite-order variant of the symmetry adapted perturbation theory code.; ; libfock(...); libfock() -> int :; Runs a CPHF calculation, using libfock.; ; mcscf(...); mcscf() -> float :; Runs the MCSCF code, (N.B. restricted to certain active spaces).; ; me(...); me() -> int :; Returns the current process ID in a MADNESS parallel run.; ; mints(...); mints() -> int :; Runs mints, which generate molecular integrals on disk.; ; mrcc_generate_input(...); mrcc_generate_input( (dict)arg1) -> PsiReturnType :; Generates an input for Kallay's MRCC code.; ; mrcc_load_densities(...); mrcc_load_densities( (dict)arg1) -> PsiReturnType :; Reads in the density matrices from Kallay's MRCC code.; ; nproc(...); nproc() -> int :; Returns the number of processors being used in a MADNESS parallel run.; ; nthread(...); nthread() -> int :; Returns the number of threads to use in SMP parallel computations.; ; nuclear_dipole(...); nuclear_dipole( (Molecule)arg1) -> Vector :; docstring; ; occ(...); occ(",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/psimod-1.html:110334,adapt,adapted,110334,psi4manual/4.0b4/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html,2,['adapt'],['adapted']
Energy Efficiency," for; a DFMP2 gradient calculation. run_dfmp2_property(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a DFMP2 property calculation. run_dft(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a density-functional-theory calculation. run_dft_gradient(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a density-functional-theory gradient calculation. run_dftsapt(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a DFT-SAPT calculation of any level. run_eom_cc(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; an EOM-CC calculation, namely EOM-CC2, EOM-CCSD, and EOM-CC3. run_eom_cc_gradient(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; an EOM-CCSD gradient calculation. run_fnocc(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a QCISD(T), CCSD(T), MP2.5, MP3, and MP4 computation.; >>> energy('fno-ccsd(t)'). run_fnodfcc(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a DF-CCSD(T) computation.; >>> energy('df-ccsd(t)'). run_infsapt(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a INF-SAPT0 calculation of any level. run_libfock(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a calculation through libfock, namely RCPHF,; RCIS, RTDHF, RTDA, and RTDDFT. run_mcscf(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a multiconfigurational self-consistent-field calculation. run_mp2(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a MP2 calculation. run_mp2_5(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a MP2.5 calculation. run_mp2_5_gradient(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a MP3 gradient calculation. run_mp2_gradient(name, **kwargs)[source]¶; Function encoding s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_driver-1.html:10368,energy,energy,10368,psi4manual/4.0b4/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_driver-1.html,2,['energy'],['energy']
Energy Efficiency," for; a charge-transfer SAPT calcuation of any level. run_scf(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a self-consistent-field theory (HF & DFT) calculation. run_scf_gradient(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a SCF gradient calculation. run_scf_property(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; SCF calculations. This is a simple alias to run_scf(); since SCF properties all handled through oeprop. scf_helper(name, **kwargs)[source]¶; Function serving as helper to SCF, choosing whether to cast; up or just run SCF with a standard guess. This preserves; previous SCF options set by other procedures (e.g., SAPT; output file types for SCF). select_ccsd(name, **kwargs)[source]¶; Function selecting the algorithm for a CCSD energy call; and directing to specified or best-performance default modules. select_ccsd_at_(name, **kwargs)[source]¶; Function selecting the algorithm for a CCSD(AT) energy call; and directing to specified or best-performance default modules. select_ccsd_gradient(name, **kwargs)[source]¶; Function selecting the algorithm for a CCSD gradient call; and directing to specified or best-performance default modules. select_ccsd_t_(name, **kwargs)[source]¶; Function selecting the algorithm for a CCSD(T) energy call; and directing to specified or best-performance default modules. select_ccsd_t__gradient(name, **kwargs)[source]¶; Function selecting the algorithm for a CCSD(T) gradient call; and directing to specified or best-performance default modules. select_cisd(name, **kwargs)[source]¶; Function selecting the algorithm for a CISD energy call; and directing to specified or best-performance default modules. select_fnoccsd(name, **kwargs)[source]¶; Function selecting the algorithm for a FNO-CCSD energy call; and directing to specified or best-performance default modules. select_fnoccsd_t_(name, **kwargs)[source]¶; Function selecting the algorithm for",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:166532,energy,energy,166532,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,2,['energy'],['energy']
Energy Efficiency," format. Optimizations; are not allowed. Just as for QM, the center of mass; coordinates in the XYZABC format and all coordinates in the POINTS format are; taken to be in Angstroms by default or in Bohr if units au is present.; Charge and multiplicity specifications are encoded in the fragment file; and so are not read from input.; Any combination of EFP and QM fragments can be placed in a molecule; even; the oddity below is legitimate. Note that symmetry and reorientation are; automatically turned off when EFP fragments are present (symmetry c1; and no_com and no_reorient are implied).; molecule qmefp {; efp nh3 0.0 0.0 5.0 5 2 8; --; C 0.0 0.0 0.0; O 0.0 1.5 0.0; O 0.0 -1.5 0.0; --; efp h2o 5.0 0.0 0.0 5 2 8; --; He -3.0 4.0 4.0; He -4.0 5.0 4.0; --; efp ch3oh; 1.275 -2.447 -4.673; 0.709 -3.191 -3.592; 2.213 -1.978 -4.343; }. Running EFP¶; EFP can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the EFP interaction energy for benzene and two waters,; simply provide the following:; molecule {; efp c6h6 0.0 0.0 0.0 0.0 0.0 0.0; --; efp h2o 4.0 0.0 0.0 0.0 0.0 0.0; --; efp h2o -4.0 0.0 0.0 0.0 0.0 0.0; }. energy('efp'). This computation involves purely EFP/EFP fragment interactions and is; performed entirely by the LIBEFP library. PSI4 can also handle mixed; systems of quantum mechanical (QM) and EFP fragments through the native; SCF code augmented by calls to the LIBEFP library. For; example, turning one of the waters in the example above into a QM; fragment is shown below.; molecule {; efp c6h6 0.0 0.0 0.0 0.0 0.0 0.0; --; O 4.0 0.0 0.0; H 4.7 0.7 0.0; H 3.3 -0.7 0.0; --; efp h2o -4.0 0.0 0.0 0.0 0.0 0.0; }. set basis 6-31g; energy('scf'). Whenever an EFP fragment is present in the active molecule, the SCF energy; will include EFP contributions. Warning; Although the EFP geometry is specified alongside the QM; geometry in a molecule name {...} block, internally the handling; of EFP is not so clean. In straightforw",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/libefp-1.html:4926,energy,energy,4926,psi4manual/1.4.0/libefp-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/libefp-1.html,9,['energy'],['energy']
Energy Efficiency," format. Optimizations; are not allowed. Just as for QM, the center of mass; coordinates in the XYZABC format and all coordinates in the POINTS format are; taken to be in Angstroms by default or in Bohr if units au is present.; Charge and multiplicity specifications are encoded in the fragment file; and so are not read from input.; Any combination of EFP and QM fragments can be placed in a molecule; even; the oddity below is legitimate. Note that symmetry and reorientation are; automatically turned off when EFP fragments are present (symmetry c1; and no_com and no_reorient are implied).; molecule qmefp {; efp nh3 0.0 0.0 5.0 5 2 8; --; C 0.0 0.0 0.0; O 0.0 1.5 0.0; O 0.0 -1.5 0.0; --; efp h2o 5.0 0.0 0.0 5 2 8; --; He -3.0 4.0 4.0; He -4.0 5.0 4.0; --; efp ch3oh; 1.275 -2.447 -4.673; 0.709 -3.191 -3.592; 2.213 -1.978 -4.343; }. Running EFP¶; EFP can be invoked in similar fashion as other theories provided in Psi4.; For example, if you want to obtain the EFP interaction energy for benzene and two waters,; simply provide the following:; molecule {; efp c6h6 0.0 0.0 0.0 0.0 0.0 0.0; --; efp h2o 4.0 0.0 0.0 0.0 0.0 0.0; --; efp h2o -4.0 0.0 0.0 0.0 0.0 0.0; }. energy('efp'). This computation involves purely EFP/EFP fragment interactions and is; performed entirely by the LIBEFP library. Psi4 can also handle mixed; systems of quantum mechanical (QM) and EFP fragments through the native; SCF code augmented by calls to the LIBEFP library. For; example, turning one of the waters in the example above into a QM; fragment is shown below.; molecule {; efp c6h6 0.0 0.0 0.0 0.0 0.0 0.0; --; O 4.0 0.0 0.0; H 4.7 0.7 0.0; H 3.3 -0.7 0.0; --; efp h2o -4.0 0.0 0.0 0.0 0.0 0.0; }. set basis 6-31g; energy('scf'). Whenever an EFP fragment is present in the active molecule, the SCF energy; will include EFP contributions. Warning; Although the EFP geometry is specified alongside the QM; geometry in a molecule name {...} block, internally the handling; of EFP is not so clean. In straightforw",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/libefp-1.html:4280,energy,energy,4280,psi4manual/1.0.0/libefp-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/libefp-1.html,2,['energy'],['energy']
Energy Efficiency," formatting of the tables can be found in the sample input files provided; see; Appendix Test Suite and Sample Inputs for a complete listing. Python Wrappers¶; The Python foundations of the PSI4 driver and Psithon syntax permit; many commonly performed post-processing procedures to be integrated into; the PSI4 suite.; As seen in the neon dimer example from the tutorial section,; the nbody_gufunc() wrapper provides automatic computation of; counterpoise-corrected interaction energies between two molecules. For; example,; 1energy('mp2', bsse_type='cp'). will compute the counterpoise-corrected density-fitted MP2 interaction energy; between two molecules.; PSI4 also provides the cbs() wrapper,; which automatically computes a complete-basis-set extrapolation (and; automatically sets up the computations with different basis sets required to; do the extrapolation). For example,:; 1; 2; 3; 4; 5# all equivalent. cbs('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). energy('mp2/cc-pv[dt]z'). will compute a 2-point Helgaker extrapolation of the correlation energy; using the cc-pVDZ and cc-pVTZ basis sets (with method MP2) and add this; extrapolated correlation energy to the Hartree–Fock energy in the; largest basis (cc-pVTZ). cbs() can; either be called directly, as in the first example, or the convenience; syntax of the equivalent second example can be used.; Another very useful and powerful feature of PSI4 is the ability; to compute results on entire databases of molecules at a time,; as provided by the database() wrapper. For example,:; 1database('mp2', 'S22', cp=1, benchmark='S22B'). will perform DF-MP2 counterpoise-corrected interaction energies; (cp=1) on all members of Hobza’s S22 database set of van der Waals; dimers, and then compare the results against the S22B benchmark energies.; Built-in databases include S22, A24, HTBH, HBC6, HSG, S22by5, S66, JSCH,; NCB31, S66by8, and NBC10, among others.; These wrapper functions are discussed separately in; Psi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psithoninput-1.html:15565,energy,energy,15565,psi4manual/1.1.0/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psithoninput-1.html,6,['energy'],['energy']
Energy Efficiency," found as the generalized eigenvectors of the Fock Matrix,. The eigenvalues are the orbital energies, and the metric matrix; is the AO-basis overlap matrix. Note that the Fock Matrix depends on the density (both alpha and beta), and; therefore the orbitals. Because of this, SCF is a nonlinear procedure, which; terminates when the generating orbitals are self-consistent with the Fock matrix; they generate.; The formation of the Coulomb matrix and the exchange matrix; dominate the computational effort of the SCF procedure. For; very large systems, diagonalization of the Fock matrix can also present a; significant hurdle. Minimal Input¶; Minimal input for a Hartree-Fock computation is a molecule block, basis set; option, and a call to energy('scf'):; molecule {; He; }. set basis sto-3g. energy('scf'). This will run a Restricted Hartree-Fock (RHF) on neutral singlet Helium in; spatial symmetry with a minimal STO-3G basis, 1.0E-8 energy; and density convergence criteria, a PK ERI algorithm, symmetric; orthogonalization, DIIS, and a core Hamiltonian guess. For more information on; any of these options, see the relevant section below. Spin/Symmetry Treatment¶; PSI4 implements the most popular spin specializations of Hartree-Fock; theory, including:. Restricted Hartree-Fock (RHF) [Default]; Appropriate only for closed-shell singlet systems, but twice as efficient; as the other flavors, as the alpha and beta densities are constrained to be; identical.; Unrestricted Hartree-Fock (UHF); Appropriate for most open-shell systems, and fairly easy to converge.; The spatial parts of the alpha and beta orbitals are fully independent of each; other, which allows a considerable amount of flexibility in the wavefunction.; However, this flexibility comes at the cost of spin symmetry; UHF wavefunctions; need not be eigenfunctions of the operator. The deviation of; this operator from its expectation value is printed on the output file. If the; deviation is greater than a few hundredths, it",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/scf-1.html:5377,energy,energy,5377,psi4manual/4.0b2/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf-1.html,2,['energy'],['energy']
Energy Efficiency," found.\n' % (sowout)); else:; ValidationError('Aborting upon output file \'%s.out\' not found.\n' % (sowout)); return 0.0; else:; while True:; line = freagent.readline(); if not line:; if E == 0.0:; if allvital:; raise ValidationError('Aborting upon output file \'%s.out\' has no %s RESULT line.\n' % (sowout, quantity)); else:; ValidationError('Aborting upon output file \'%s.out\' has no %s RESULT line.\n' % (sowout, quantity)); break; s = line.strip().split(None, 10); if (len(s) != 0) and (s[0:3] == [quantity, 'RESULT:', 'computation']):; if int(s[3]) != linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (sowout, str(s[3]), str(linkage))); if s[6] != str(sownum + 1):; raise ValidationError('Output file \'%s.out\' has nominal affiliation %s incompatible with item %s.'; % (sowout, s[6], str(sownum + 1))); if label == 'electronic energy' and s[8:10] == ['electronic', 'energy']:; E = float(s[10]); psi4.print_out('%s RESULT: electronic energy = %20.12f\n' % (quantity, E)); if label == 'electronic gradient' and s[8:10] == ['electronic', 'gradient']:; E = ast.literal_eval(s[-1]); psi4.print_out('%s RESULT: electronic gradient = %r\n' % (quantity, E)); freagent.close(); return E. [docs]def prepare_options_for_modules(changedOnly=False, commandsInsteadDict=False):; """"""Function to return a string of commands to replicate the; current state of user-modified options. Used to capture C++; options information for distributed (sow/reap) input files. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - Need some option to get either all or changed. - Need some option to either get dict or set string or psimod command list. - command return doesn't revoke has_changed setting for unchanged with changedOnly=False. """"""; modules = [; # PSI4 Modules; ""ADC"", ""CCENERGY"", ""CCEOM"", ""CCDENSITY"", ""CCLAMBDA"", ""CCHBAR"",; ""CCRESPONSE"", ""CCSORT"", ""CCTRIPLES"", ""CLAG"", ""CPHF"", ""CIS"",; ""DCFT"", ""DETCI"", ""DFMP2""",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/p4util/procutil.html:9526,energy,energy,9526,psi4manual/1.0.0/_modules/p4util/procutil.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/procutil.html,1,['energy'],['energy']
Energy Efficiency," frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Z-matrix input. fci-tdm; He2+ FCI/cc-pVDZ Transition Dipole Moment. dfmp2-grad4; DF-MP2 cc-pVDZ gradient for the NO molecule. cc9; UHF-CCSD(T) cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Z-matrix input. casscf-fzc-sp; CASSCF/6-31G** energy point. opt10; 6-31G MP2 transition-state optimization with initial, computed Hessian. fnocc6; Test method/basis with disk_df. pywrap-checkrun-uhf; This checks that all energy methods can run with a minimal input and set symmetry. scf11-freq-from-energies; Test frequencies by finite differences of energies for planar C4NH4 TS. sapt0-d; Tests SAPT0-D corrections, with a variety of damping functions/parameters. dct7; DCT calculation for the triplet O2 using ODC-06 and ODC-12 functionals. Only simultaneous algorithm is tested. cc32; CC3/cc-pVDZ H2O \(R_e\) geom from Olsen et al., JCP 104, 8007 (1996). cc15; RHF-B-CCD(T)/6-31G** H2O single-point energy (fzc, MO-basis \(\langle ab|cd \rangle\)). fci-h2o-2; 6-31G H2O Test FCI Energy Point. dct10; The multiple guesses for DCT amplitudes for ODC-12. mints-benchmark; run some BLAS benchmarks. cepa2; cc-pvdz H2O Test ACPF Energy/Properties. cc45; RHF-EOM-CC2/cc-pVDZ lowest two states of each symmetry of H2O. mints4; A demonstration of mixed Cartesian/ZMatrix geometry specification, using variables, for the benzene-hydronium complex. Atoms can be placed using ZMatrix coordinates, whether they belong to the same fragment or not. Note that the Cartesian specification must come before the ZMatrix entries because the former define absolute positions, while the latter are relative. dfomp3-grad1; DF-OMP3 cc-pVDZ gradients for the H2O molecule. sapt2; SAPT0 aug-cc-pVDZ computation of the benzene-methane interaction energy, using the aug-pVDZ-JKFIT DF basis for SCF, the aug-cc-pVDZ-RI DF basis for SAPT0 induction and dispersion, and the aug-pVDZ-JKFIT DF basis for SAPT0 electrostatics and indu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html:21230,energy,energy,21230,psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency," full configuration interaction level of theory. HF TOTAL ENERGY¶; The total electronic energy [H] for the Hartree–Fock method, without; any dispersion correction; the first three (or four, since; \(E_{xc} = 0\)) terms in Eq. (4). Quantity \(E_{\text{HF}}\); in Eq. (4). LCC2 (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CC2 level of theory. LCCSD (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CCSD level of theory. MP2 TOTAL ENERGY¶. MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2 level of theory. MP2.5 TOTAL ENERGY¶. MP2.5 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2.5 level of theory. MP3 TOTAL ENERGY¶. MP3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP3 level of theory. MP4(SDQ) TOTAL ENERGY¶. MP4(SDQ) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP4 singles, doubles, quadruples level of theory. Quantity; MP4(SDQ) CORRELATION ENERGY is; first right-hand term in Eq. (2). MP4 TOTAL ENERGY¶. MP4 CORRELATION ENERGY¶. MP4(SDTQ) TOTAL ENERGY¶. MP4(SDTQ) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the full MP4 level of theory. Quantity MP4 CORRELATION; ENERGY / MP4(SDTQ) CORRELATION ENERGY is left-hand term in Eq. (2). (2)¶\[E_{\text{MP4}} = E_{\text{MP4(SDQ)}} + E_{\text{MP4(T)}}\]. MPn TOTAL ENERGY¶. MPn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Møller–Plesset perturbation theory level.; n is MP perturbation order. NUCLEAR REPULSION ENERGY¶; The nuclear repulsion energy contribution [H] to the total SCF energy.; Quantity \(E_{NN}\) in Eq. (4). (3)¶\[E_{NN} = \sum_{i, j<i}^{N_{atom}}\frac{Z_i Z_j}{|\mathbf{R}_i - \mathbf{R}_j|}\]. NBODY (i, j, ..., k)@(a, b, ..., c) TOTAL ENERGY¶; The total",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/glossary_psivariables-1.html:15245,energy,energy,15245,psi4manual/1.2.1/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/glossary_psivariables-1.html,8,['energy'],['energy']
Energy Efficiency," full configuration interaction level of theory. HF TOTAL ENERGY¶; The total electronic energy [H] for the Hartree–Fock method, without; any dispersion correction; the first three (or four, since; \(E_{xc} = 0\)) terms in Eq. (4). Quantity \(E_{\text{HF}}\); in Eq. (4). LCC2 (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CC2 level of theory. LCCSD (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CCSD level of theory. MP2 TOTAL ENERGY¶. MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2 level of theory. MP2.5 TOTAL ENERGY¶. MP2.5 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2.5 level of theory. MP3 TOTAL ENERGY¶. MP3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP3 level of theory. MP4(SDQ) TOTAL ENERGY¶. MP4(SDQ) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP4 singles, doubles, quadruples level of theory. Quantity; MP4(SDQ) CORRELATION ENERGY is; first right-hand term in Eq. (2). MP4 TOTAL ENERGY¶. MP4 CORRELATION ENERGY¶. MP4(SDTQ) TOTAL ENERGY¶. MP4(SDTQ) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the full MP4 level of theory. Quantity MP4 CORRELATION; ENERGY / MP4(SDTQ) CORRELATION ENERGY is left-hand term in Eq. (2). (2)¶\[E_{\text{MP4}} = E_{\text{MP4(SDQ)}} + E_{\text{MP4(T)}}\]. MPn TOTAL ENERGY¶. MPn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Møller–Plesset perturbation theory level.; n is MP perturbation order. NUCLEAR REPULSION ENERGY¶; The nuclear repulsion energy contribution [H] to the total SCF energy.; Quantity \(E_{NN}\) in Eq. (4). (3)¶\[E_{NN} = \sum_{i, j<i}^{N_{atom}}\frac{Z_i Z_j}{|\mathbf{R}_i - \mathbf{R}_j|}\]. OCEPA(0) TOTAL ENERGY¶. OCEPA(0) CORRELATION ENERGY¶; The to",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/glossary_psivariables-1.html:13659,energy,energy,13659,psi4manual/1.1.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/glossary_psivariables-1.html,4,['energy'],['energy']
Energy Efficiency," func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['DETCI']:; func = run_detci. if func is None:; raise ManagedMethodError(['select_mp3', name, 'MP_TYPE', mtd_type, reference, module]). return func(name, **kwargs). Naturally, in the run function, you must either use the type keyword for; type switching or translate it into whatever DO_CD-like keywords your; module uses. At run time with a closed-shell molecule,; 1energy('mp3'). will run OCC, while; 1; 2set qc_module fnocc; energy('mp3'). will run FNOCC mp3.; A special case is DETCI that can run mp3, but oughtn’t to be used for such. So above, ROHF CONV mp3 has no default, but can still access the detci code with; 1; 2; 3set reference rohf; set qc_module detci; energy('mp3'). While the below gives an error; 1; 2set reference rohf; energy('mp3'). Again, whenever a single method name needs to call multiple proc.py run; functions, it should be managed. In Overlapping capabilities of . “Y” is available; “D” is default. “Y” means method available in; module, “D” means module is default for that method, “” mean method not; available. table of contents. Adding Methods to Driver; proc.py; Managed Methods. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Programming: Using the Core Libraries. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/proc_py-1.html:6648,energy,energy,6648,psi4manual/1.2.1/proc_py-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/proc_py-1.html,6,['energy'],['energy']
Energy Efficiency," func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2p5_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OMP2.5 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_lccd(name, **kwargs):; """"""Function selecting the algorithm for a LCCD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'OCC':; func = run_occ; elif module in ['', 'FNOCC']:; func = run_cepa; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_lccd_gradient(name, **kwargs):; """"""Function selecting the algori",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:18091,energy,energy,18091,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,4,['energy'],['energy']
Energy Efficiency," function; if hasattr(name, '__call__'):; return name(energy, kwargs.pop('label', 'custom function'), ptype='energy', **kwargs). # Allow specification of methods to arbitrary order; lowername = name.lower(); lowername, level = driver_util.parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. # Bounce to CP if bsse kwarg; if kwargs.get('bsse_type', None) is not None:; return driver_nbody.nbody_gufunc(energy, name, ptype='energy', **kwargs). # Bounce to CBS if ""method/basis"" name; if ""/"" in lowername:; return driver_cbs._cbs_gufunc(energy, name, ptype='energy', **kwargs). # Commit to procedures['energy'] call hereafter; return_wfn = kwargs.pop('return_wfn', False); core.clean_variables(). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). #for precallback in hooks['energy']['pre']:; # precallback(lowername, **kwargs). optstash = driver_util._set_convergence_criterion('energy', lowername, 6, 8, 6, 8, 6). # Before invoking the procedure, we rename any file that should be read.; # This is a workaround to do restarts with the current PSI4 capabilities; # before actual, clean restarts are put in there; # Restartfile is always converted to a single-element list if; # it contains a single string; # DGAS Note: This is hacked together at this point and should be revamped.; if 'restart_file' in kwargs:; restartfile = kwargs['restart_file'] # Option still available for procedure-specific action; if not isinstance(restartfile, (list, tuple)):; restartfile = (restartfile, ); # Rename the files to be read to be consistent with psi4's file system; for item in restartfile:; name_split = re.split(r'\.', item); if ""npz"" in item:; fname = os.path.split(os.path.abspath(core.get_writer_file_prefix(molecule.name())))[1]; psi_scratch = core.IOManager.shared_object().get_default_path(); file_num = item.split('.')[-2]; targetfile = os.path.join(psi_scratch, fname + ""."" + file_n",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html:31636,energy,energy,31636,psi4manual/1.2.1/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html,1,['energy'],['energy']
Energy Efficiency," function; if hasattr(name, '__call__'):; return name(energy, kwargs.pop('label', 'custom function'), ptype='energy', **kwargs). # Allow specification of methods to arbitrary order; lowername = name.lower(); lowername, level = driver_util.parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. # Bounce to CP if bsse kwarg; if kwargs.get('bsse_type', None) is not None:; return driver_nbody.nbody_gufunc(energy, name, ptype='energy', **kwargs). # Bounce to CBS if ""method/basis"" name; if ""/"" in lowername:; return driver_cbs._cbs_gufunc(energy, name, ptype='energy', **kwargs). # Commit to procedures['energy'] call hereafter; return_wfn = kwargs.pop('return_wfn', False); core.clean_variables(). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). #for precallback in hooks['energy']['pre']:; # precallback(lowername, **kwargs). optstash = driver_util._set_convergence_criterion('energy', lowername, 6, 8, 6, 8, 6). # Before invoking the procedure, we rename any file that should be read.; # This is a workaround to do restarts with the current PSI4 capabilities; # before actual, clean restarts are put in there; # Restartfile is always converted to a single-element list if; # it contains a single string; if 'restart_file' in kwargs:; restartfile = kwargs['restart_file'] # Option still available for procedure-specific action; if restartfile != list(restartfile):; restartfile = [restartfile]; # Rename the files to be read to be consistent with psi4's file system; for item in restartfile:; name_split = re.split(r'\.', item); filenum = name_split[len(name_split) - 1]; try:; filenum = int(filenum); except ValueError:; filenum = 32 # Default file number is the checkpoint one; psioh = core.IOManager.shared_object(); psio = core.IO.shared_object(); filepath = psioh.get_file_path(filenum); namespace = psio.get_default_namespace(); pid = str(os.getpid()); prefix = 'psi'; target",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html:30819,energy,energy,30819,psi4manual/1.1.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html,1,['energy'],['energy']
Energy Efficiency," function>(...); | ; | __setattr__ = new_set_attr(self, name, value); | Function to redefine set_attr method of molecule class.; | ; | activate_all_fragments(...); | activate_all_fragments( (Molecule)arg1) -> None :; | Sets all fragments in the molecule to be active; | ; | add_atom(...); | add_atom( (Molecule)arg1, (int)arg2, (float)arg3, (float)arg4, (float)arg5, (str)arg6, (float)arg7, (float)arg8, (int)arg9) -> None :; | Adds to Molecule arg1 an atom with atomic number arg2, Cartesian coordinates in Bohr (arg3, arg4, arg5), atomic symbol arg6, mass arg7, charge arg8 (optional), and lineno arg9 (optional); | ; | atom_at_position(...); | atom_at_position( (Molecule)arg1, (float)arg2, (float)arg3) -> int :; | Tests to see if an atom is at the position arg2 with a given tolerance arg3; | ; | center_of_mass(...); | center_of_mass( (Molecule)arg1) -> Vector3 :; | Computes center of mass of molecule (does not translate molecule); | ; | charge(...); | charge( (Molecule)arg1, (int)arg2) -> float :; | Gets charge of atom; | ; | clone(...); | clone( (Molecule)arg1) -> Molecule :; | Returns a new Molecule identical to arg1; | ; | deactivate_all_fragments(...); | deactivate_all_fragments( (Molecule)arg1) -> None :; | Sets all fragments in the molecule to be inactive; | ; | extract_subsets(...); | extract_subsets( (Molecule)arg1, (list)arg2, (list)arg3) -> Molecule :; | Returns copy of arg1 with arg2 fragments Real and arg3 fragments Ghost; | ; | extract_subsets( (Molecule)arg1, (list)arg2, (int)arg3) -> Molecule :; | Returns copy of arg1 with arg2 fragments Real and arg3 fragment Ghost; | ; | extract_subsets( (Molecule)arg1, (int)arg2, (list)arg3) -> Molecule :; | Returns copy of arg1 with arg2 fragment Real and arg3 fragments Ghost; | ; | extract_subsets( (Molecule)arg1, (int)arg2, (int)arg3) -> Molecule :; | Returns copy of arg1 with arg2 fragment Real and arg3 fragment Ghost; | ; | extract_subsets( (Molecule)arg1, (list)arg2) -> Molecule :; | Returns copy of arg1 with arg2",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/psimod-1.html:53128,charge,charge,53128,psi4manual/4.0b3/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html,8,['charge'],['charge']
Energy Efficiency," generate FCHK files. Wavefunction information, such as orbitals, densities,; orbital energies and basis set information is currently supported, but geometry; optimization and vibrational frequency information are not supported at this; time. To generate a FCHK file, simply store the wavefunction from the energy; calculation, and use it to create an FCHK writer:; energy, wfn = energy('scf', return_wfn=True); fchk_writer = psi4.FCHKWriter(wfn); fchk_writer.write('output.fchk'). The file will be written to the name passed to the FCHK writer’s write(); method. Note that for MP2 and CCSD methods, the energy can be computed without; the expensive steps required to compute the density, so energy calls for these; methods will return a wavefunction that has the Hartree-Fock density. If a; density is required for these methods, the user should instead request a; gradient computation, to ensure that the density is updated appropriately:; grad, wfn = gradient('mp2', return_wfn=True); fchk_writer = psi4.FCHKWriter(wfn); fchk_writer.write('output.fchk'). fchk(wfn, filename)[source]¶; Function to write wavefunction information in wfn to filename in; Gaussian FCHK format. New in version 0.6. Returns:None. Parameters:; filename (string) – destination file name for FCHK file; wfn (Wavefunction) – set of molecule, basis, orbitals from which to generate fchk file. Examples:. >>> # [1] FCHK file for DFT calculation; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> fchk(wfn, 'mycalc.fchk'). Previous topic; Interface to DKH by A. Wolf, M. Reiher, and B. A. Hess; Next topic; Interface to GDMA Distributed Multipole Analysis by A. J. Stone, gdma(). This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; Psi4 [1.0.0 6a9a71b] » ; Interfaces: Enhancing Psi4 Capabilities ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/fchk-1.html:1940,energy,energy,1940,psi4manual/1.0.0/fchk-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/fchk-1.html,2,['energy'],['energy']
Energy Efficiency," geometry optimzation of ketene, starting from bent structure. scf-ecp; Water-Argon complex with ECP present; check of energies and forces. molden1; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. psimrcc-ccsd_t-3; Mk-MRCCSD(T) single point. \(^1A_1\) CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. cc5; RHF CCSD(T) aug-cc-pvtz frozen-core energy of C4NH4 Anion. mints8; Patch of a glycine with a methyl group, to make alanine, then DF-SCF energy calculation with the cc-pVDZ basis set. psimrcc-fd-freq2; Mk-MRCCSD frequencies. \(^1A_1\) O$_3` state described using the Ms = 0 component of the singlet. Uses TCSCF orbitals. dft-grad2; DF-BP86-D2 cc-pVDZ frozen core gradient of S22 HCN. cepa0-grad2; CEPA cc-pVDZ gradient for the NO radical. tu6-cp-ne2; Example potential energy surface scan and CP-correction for Ne2. sapt7; SAPT0 open-shell computation of H2O-HO2 interaction energy First with cc-pVDZ and density fitted integrals with UHF Then with 6-31g and direct integrals, except for dispersion that is computed with cc-pVDZ-ri density fitting with UHF. mints-benchmark; run some BLAS benchmarks. scf-bs; UHF and broken-symmetry UHF energy for molecular hydrogen. fci-tdm; He2+ FCI/cc-pVDZ Transition Dipole Moment. omp2p5-grad2; OMP2.5 cc-pVDZ gradient for the NO radical. fci-h2o-fzcv; 6-31G H2O Test FCI Energy Point. sapt-dft2; SAPT(DFT) aug-cc-pVDZ computation for the water dimer interaction energy. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Test Suite and Sample Inputs. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html:39030,energy,energy,39030,psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,8,['energy'],['energy']
Energy Efficiency," geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. cbs-delta-energy; Extrapolated energies with delta correction. sapt-dft1; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. dfrasscf-sp; 6-31G** H2O Test RASSCF Energy Point will default to only singles and doubles in the active space. pywrap-db1; Database calculation, so no molecule section in input file. Portions of the full databases, restricted by subset keyword, are computed by sapt0 and dfmp2 methods. frac-ip-fitting; Omega optimization for LRC functional wB97 on water. dfccsdat1; DF-CCSD(AT) cc-pVDZ energy for the H2O molecule. dfomp2-grad1; DF-OMP2 cc-pVDZ gradients for the H2O molecule. tdscf-2; td-uhf test on triplet states of methylene (tda), wfn passing. opt6; Various constrained energy minimizations of HOOH with cc-pvdz RHF Internal-coordinate constraints in internal-coordinate optimizations. scf-freq1; Analytic vs. finite difference DF-SCF frequency test for water. cc51; EOM-CC3/cc-pVTZ on H2O. opt7; Various constrained energy minimizations of HOOH with cc-pvdz RHF. For “fixed” coordinates, the final value is provided by the user. nbody-freq; Vibrational and thermo analysis of water trimer (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). gibbs; Test Gibbs free energies at 298 K of N2, H2O, and CH4. mints5; Tests to determine full point group symmetry. Currently, these only matter for the rotational symmetry number in thermodynamic computations. stability2; ROHF stability analysis check for CN with cc-pVDZ. This test corresponds to the rohf-stab test from Psi3. cc27; Single point gradient of 1-1B2 state of H2O with EOM-CCSD. frac; Carbon/UHF Fractionally-Occupied SCF Test Case. cc33; CC3(UHF)/cc-pVDZ H2O \(R_e\) geom from Olsen et al., JCP 104, 8007 (1996). psimrcc-ccsd_t-1; Mk-MRCCSD(T) si",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html:9625,energy,energy,9625,psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency," given method from ground state to root m in h symmetry. ADC ROOT 0 -> ROOT m CORRELATION ENERGY - h SYMMETRY¶. EOM-CCSD ROOT 0 -> ROOT m CORRELATION ENERGY - h SYMMETRY¶; The correlation energy of given method from ground state reference energy to root m in h symmetry. TD-fctl ROOT 0 -> ROOT m OSCILLATOR STRENGTH (LEN) - h SYMMETRY¶. TD-fctl ROOT 0 -> ROOT m OSCILLATOR STRENGTH (VEL) - h SYMMETRY¶; The oscillator strength in length or velocity gauge of named method; from ground state to root m in h symmetry (if available). DFT; functional labeled if canonical. TD-fctl ROOT 0 -> ROOT m ROTATORY STRENGTH (LEN) - h SYMMETRY¶. TD-fctl ROOT 0 -> ROOT m ROTATORY STRENGTH (VEL) - h SYMMETRY¶; The rotatory strength in length or velocity gauge of named method; from ground state to root m in h symmetry (if available). DFT; functional labeled if canonical. THERMAL ENERGY¶; Total thermal energy E [Eh] at given temperature. THERMAL ENERGY CORRECTION¶; Sum of electronic, translational, rotational, and vibrational corrections [Eh] to the thermal energy at given temperature. TWO-ELECTRON ENERGY¶; The two-electron energy contribution [Eh] to the total SCF energy.; Quantity \(E_{2e^-}\) in Eq. (4). UNCP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [Eh] considering only two-body interactions,; computed without counterpoise correction.; Related variable CP-CORRECTED 2-BODY INTERACTION ENERGY. \[E_{\text{IE}} = E_{dimer} - \sum_{monomer}^{n}{E_{monomer}^{\text{unCP}}}\]. WIBERG LOWDIN INDICES¶; Property of Wiberg bond indices using orthogonal Löwdin orbitals, (nat, nat). ZAPTn TOTAL ENERGY¶. ZAPTn CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the labeled Z-averaged perturbation theory level.; n is ZAPT perturbation order. ZERO K ENTHALPY¶; Total electronic and zero-point energy [Eh] at 0 [K]. ZPVE¶; Vibrational zero-point energy [Eh] at 0 [K]. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .   ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html:49082,energy,energy,49082,psi4manual/1.4.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html,4,['energy'],['energy']
Energy Efficiency," global options (e.g., the local option set by set scf scf_type df will not be respected). Note; To access a database that is not embedded in a PSI4; distribution, add the path to the directory containing the database; to the environment variable PYTHONPATH. Parameters. name (str) – 'scf' || 'sapt0' || 'ccsd(t)' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; psi4.energy(). db_name (str) – 'BASIC' || 'S22' || 'HTBH' || etc.; Second argument, usually unlabeled. Indicates the requested database; name, matching (case insensitive) the name of a python file in; psi4/share/databases or PYTHONPATH. Consult that; directory for available databases and literature citations. func (function) – \(\Rightarrow\) energy \(\Leftarrow\) || optimize || cbs; Indicates the type of calculation to be performed on each database; member. The default performs a single-point energy('name'), while; optimize perfoms a geometry optimization on each reagent, and; cbs performs a compound single-point energy. If a nested series; of python functions is intended (see Function Intercalls), use; keyword db_func instead of func. mode (str) – \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; Indicates whether the calculations required to complete the; database are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. cp (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicates whether counterpoise correction is employed in computing; interaction energies. Use this option and NOT the bsse_type=""cp""; function for BSSE correction in database(). Option available; (See Available Databases) only for databases of bimolecular complexes. rlxd (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicates whether correction for deformation ener",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/db-1.html:1988,energy,energy,1988,psi4manual/1.4.0/db-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/db-1.html,10,['energy'],['energy']
Energy Efficiency," gradient call; and directing to specified or best-performance default modules. select_omp2(name, **kwargs)[source]¶; Function selecting the algorithm for an OMP2 energy call; and directing to specified or best-performance default modules. select_omp2_gradient(name, **kwargs)[source]¶; Function selecting the algorithm for an OMP2 gradient call; and directing to specified or best-performance default modules. select_omp2_property(name, **kwargs)[source]¶; Function selecting the algorithm for an OMP2 property call; and directing to specified or best-performance default modules. select_omp2p5(name, **kwargs)[source]¶; Function selecting the algorithm for an OMP2.5 energy call; and directing to specified or best-performance default modules. select_omp2p5_gradient(name, **kwargs)[source]¶; Function selecting the algorithm for an OMP2.5 gradient call; and directing to specified or best-performance default modules. select_omp3(name, **kwargs)[source]¶; Function selecting the algorithm for an OMP3 energy call; and directing to specified or best-performance default modules. select_omp3_gradient(name, **kwargs)[source]¶; Function selecting the algorithm for an OMP3 gradient call; and directing to specified or best-performance default modules. check_iwl_file_from_scf_type(scf_type, wfn)[source]¶; Ensures that a IWL file has been written based on input SCF type. check_non_symmetric_jk_density(name)[source]¶; Ensure non-symmetric density matrices are supported for the selected JK routine. dft_set_reference_local(name)[source]¶; Figures out the correct DFT reference to set locally. oeprop_validator(prop_list)[source]¶; Validations a list of OEProp computations. Throws if not found. scf_set_reference_local(name)[source]¶; Figures out the correct SCF reference to set locally. run_roa(name, **kwargs)[source]¶; Main driver for managing Raman Optical activity computations with; CC response theory. Uses distributed finite differences approach –>. Sets up a database to keep track of runn",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:170513,energy,energy,170513,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,2,['energy'],['energy']
Energy Efficiency," gradients for the H2O molecule. cc41; RHF-CC2-LR/cc-pVDZ optical rotation of H2O2. gauge = both, omega = (589 355 nm). dct-grad2; RHF-ODC-12 analytic gradient computations for H2O use AO_BASIS=DISK and AO_BASIS=NONE, respectively. RHF-ODC-06 analytic gradient computations for H2O use AO_BASIS=DISK and AO_BASIS=NONE, respectively. opt-multi-dimer-c2h; Multi-fragment opt of C2h methane dimer with user-combined reference points. options1; check all variety of options parsing. dfccsd1; DF-CCSD cc-pVDZ energy for the H2O molecule. mbis-2; MBIS calculation on OH- (Expanded Arrays). scf-bz2; Benzene Dimer Out-of-Core HF/cc-pVDZ. fnocc3; Test FNO-QCISD(T) computation. dft-omega; Test omega is setable updated wb97x_20,wb97x_03 to account for new BraggSlater radii. cepa-module; routing check on lccd, lccsd, cepa(0). opt6; Various constrained energy minimizations of HOOH with cc-pvdz RHF Internal-coordinate constraints in internal-coordinate optimizations. dfomp2p5-1; DF-OMP2.5 cc-pVDZ energy for the H2O molecule. cc8a; ROHF-CCSD(T) cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Cartesian input. scf-dipder; Test SCF dipole derivatives against old Psi3 reference values. tu3-h2o-opt; Optimize H2O HF/cc-pVDZ. dft-dens-cut; LibXC density screening test. Tests empty, C-only, X-only and XC superfunctionals. ‘super_mix’ showcases how to use different screening values for X and C parts. SCF will fail or crash (nans) without screening!. aediis-2; EDIIS test case from 10.1063/1.1470195. cc56; EOM-CCSD/6-31g excited state transition data for water cation. scf-uhf-grad-nobeta; UHF gradient for a one-electron system (no beta electrons). dfomp3-grad2; DF-OMP3 cc-pVDZ gradients for the H2O+ cation. dfmp2-grad5; Tests DF-MP2 gradient in the presence of a dipole field. dfmp2-grad3; DF-MP2 cc-pVDZ gradients for the H2O molecule. scf-response2; Compute the dipole polarizability for water with custom basis set. sapt7; SAPT0 open-shell computation of H2O-HO2 inter",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html:22531,energy,energy,22531,psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency," gradients for the H2O molecule. molden1; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. pywrap-db3; Test that Python Molecule class processes geometry like psi4 Molecule class. casscf-sa-sp; Example of state-averaged CASSCF for the C2 molecule see C. D. Sherrill and P. Piecuch, J. Chem. Phys. 122, 124104 (2005). fsapt-terms; F-SAPT0/jun-cc-pvdz procedure for methane dimer. dct-grad1; Various DCT analytic gradients for the O2 molecule with 6-31G basis set. opt11; Transition-state optimizations of HOOH to both torsional transition states. tu3-h2o-opt; Optimize H2O HF/cc-pVDZ. scf-occ; force occupations in scf. cisd-h2o-clpse; 6-31G** H2O Test CISD Energy Point with subspace collapse. dfccsdt2; DF-CCSD(T) cc-pVDZ energy for the NH molecule. mcscf2; TCSCF cc-pVDZ energy of asymmetrically displaced ozone, with Z-matrix input. scf6; Tests RHF/ROHF/UHF SCF gradients. props3; DF-SCF cc-pVDZ multipole moments of benzene, up to 7th order and electrostatic potentials evaluated at the nuclear coordinates. linK-3; UHF and ROHF Linear Exchange Algorithm test for benzyl cation. opt1; SCF STO-3G geometry optimzation, with Z-matrix input. dft-b3lyp; Check flavors of B3LYP (b3lyp3/b3lyp5) against other programs. cc2; 6-31G** H2O CCSD optimization by energies, with Z-Matrix input. opt-irc-1; Compute the IRC for HOOH torsional rotation at the RHF/DZP level of theory. opt6; Various constrained energy minimizations of HOOH with cc-pvdz RHF Internal-coordinate constraints in internal-coordinate optimizations. dft-freq-analytic; Analytic SVWN frequencies, compared to finite difference values. rasci-h2o; RASCI/6-31G** H2O Energy Point. dfomp3-grad2; DF-OMP3 cc-pVDZ gradients for the H2O+ cation. dfmp2-freq1; DF-MP2",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html:39189,energy,energy,39189,psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency," guess for the anion; neutral_guess = True; if kwargs.has_key('neutral_guess'):; neutral_guess = kwargs['neutral_guess']. # By default, burn-in with UHF first, if UKS; hf_guess = False; if PsiMod.get_global_option('REFERENCE') == 'UKS':; hf_guess = True; if kwargs.has_key('hf_guess'):; hf_guess = kwargs['hf_guess']. # By default, re-guess at each N ; continuous_guess = False; if kwargs.has_key('continuous_guess'):; continuous_guess = kwargs['continuous_guess']. # By default, drop the files to the molecule's name; root = mol.name(); if kwargs.has_key('filename'):; root = kwargs['filename']; traverse_filename = root + '.traverse.dat'; # => Traverse <= #; occs = []; energies = []; potentials = []; convs = []. # => Run the neutral for its orbitals, if requested <= #. old_df_ints_io = PsiMod.get_global_option(""DF_INTS_IO""); PsiMod.set_global_option(""DF_INTS_IO"", ""SAVE""). old_guess = PsiMod.get_global_option(""GUESS""); if (neutral_guess):; if (hf_guess):; PsiMod.set_global_option(""REFERENCE"",""UHF""); energy('scf'); PsiMod.set_global_option(""GUESS"", ""READ""); PsiMod.set_global_option(""DF_INTS_IO"", ""LOAD""). # => Run the anion first <= #. mol.set_molecular_charge(chargem); mol.set_multiplicity(multm); ; # => Burn the anion in with hf, if requested <= #; if (hf_guess):; PsiMod.set_global_option(""REFERENCE"",""UHF""); energy('scf'); PsiMod.set_global_option(""REFERENCE"",""UKS""); PsiMod.set_global_option(""GUESS"", ""READ""); PsiMod.set_global_option(""DF_INTS_IO"", ""SAVE""). PsiMod.set_global_option(""FRAC_START"", frac_start); PsiMod.set_global_option(""FRAC_RENORMALIZE"", True); PsiMod.set_global_option(""FRAC_LOAD"", False). for occ in LUMO_occs:; ; PsiMod.set_global_option(""FRAC_OCC"", [LUMO]); PsiMod.set_global_option(""FRAC_VAL"", [occ]) . E = energy('scf'); C = 1; if (E == 0.0):; E = PsiMod.get_variable('SCF ITERATION ENERGY'); C = 0. if (LUMO > 0):; ref = PsiMod.reference_wavefunction(); eps = ref.epsilon_a(); potentials.append(eps[int(LUMO)-1]); else:; ref = PsiMod.reference_wavefunction(); ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/frac.html:2876,energy,energy,2876,psi4manual/4.0b2/_modules/frac.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/frac.html,2,['energy'],['energy']
Energy Efficiency," guess for the anion; neutral_guess = True; if kwargs.has_key('neutral_guess'):; neutral_guess = kwargs['neutral_guess']. # By default, burn-in with UHF first, if UKS; hf_guess = False; if PsiMod.get_global_option('REFERENCE') == 'UKS':; hf_guess = True; if kwargs.has_key('hf_guess'):; hf_guess = kwargs['hf_guess']. # By default, re-guess at each N ; continuous_guess = False; if kwargs.has_key('continuous_guess'):; continuous_guess = kwargs['continuous_guess']. # By default, drop the files to the molecule's name; root = mol.name(); if kwargs.has_key('filename'):; root = kwargs['filename']; traverse_filename = root + '.traverse.dat'; # => Traverse <= #; occs = []; energies = []; potentials = []; convs = []. # => Run the neutral for its orbitals, if requested <= #. old_df_ints_io = PsiMod.get_global_option(""DF_INTS_IO""); PsiMod.set_global_option(""DF_INTS_IO"", ""SAVE""). old_guess = PsiMod.get_global_option(""GUESS""); if (neutral_guess):; if (hf_guess):; PsiMod.set_global_option(""REFERENCE"",""UHF""); energy('scf'); PsiMod.set_global_option(""GUESS"", ""READ""); PsiMod.set_global_option(""DF_INTS_IO"", ""LOAD""). # => Run the anion first <= #. mol.set_molecular_charge(chargem); mol.set_multiplicity(multm); ; # => Burn the anion in with hf, if requested <= #; if (hf_guess):; PsiMod.set_global_option(""REFERENCE"",""UHF""); energy('scf'); PsiMod.set_global_option(""REFERENCE"",""UKS""); PsiMod.set_global_option(""GUESS"", ""READ""); PsiMod.set_global_option(""DF_INTS_IO"", ""SAVE""). PsiMod.set_global_option(""FRAC_START"", frac_start); PsiMod.set_global_option(""FRAC_RENORMALIZE"", True); PsiMod.set_global_option(""FRAC_LOAD"", False). for occ in LUMO_occs:; ; PsiMod.set_global_option(""FRAC_OCC"", [LUMO]); PsiMod.set_global_option(""FRAC_VAL"", [occ]) . E = energy('scf'); C = 1; if (E == 0.0):; E = PsiMod.get_variable('SCF ITERATION ENERGY'); C = 0. if (LUMO > 0):; ref = PsiMod.wavefunction(); eps = ref.epsilon_a(); potentials.append(eps[int(LUMO)-1]); else:; ref = PsiMod.wavefunction(); eps = ref.epsilon_b(",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/frac.html:2873,energy,energy,2873,psi4manual/4.0b4/_modules/frac.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/frac.html,1,['energy'],['energy']
Energy Efficiency," handling, no symmetry,; no pubchem, no efp, no discarding dummies. This class translated so; that databases can function independently of psi4.; >>> H2OH2O = qcdb.Molecule(""""""; 0 1; O1 -1.551007 -0.114520 0.000000; H1 -1.934259 0.762503 0.000000; H2 -0.599677 0.040712 0.000000; --; 0 1; X 0.000000 0.000000 0.000000; O2 1.350625 0.111469 0.000000; H3 1.680398 -0.373741 -0.758561; H4 1.680398 -0.373741 0.758561; no_com; no_reorient; units angstrom; """"""). >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'). FullPointGroupList = ['ATOM', 'C_inf_v', 'D_inf_h', 'C1', 'Cs', 'Ci', 'Cn', 'Cnv', 'Cnh', 'Sn', 'Dn', 'Dnd', 'Dnh', 'Td', 'Oh', 'Ih']¶. Z(atom)[source]¶; Nuclear charge of atom (0-indexed); >>> print H2OH2O.Z(4); 1. activate_all_fragments()[source]¶; Sets all fragments in the molecule to be active. add_atom(Z, x, y, z, label='', mass=0.0, charge=0.0, lineno=-1)[source]¶; Add an atom to the molecule; Z atomic number; x cartesian coordinate; y cartesian coordinate; z cartesian coordinate; symb atomic symbol to use; mass mass to use if non standard; charge charge to use if non standard; lineno line number when taken from a string. atom_at_position(b, tol=0.05)[source]¶; Tests to see of an atom is at the passed position b in Bohr with a tolerance tol.; >>> print H2OH2O.atom_at_position([1.35*(1.0/psi_bohr2angstroms), 0.10*(1.0/psi_bohr2angstroms), 0.0*(1.0/psi_bohr2angstroms)]); 3. atom_entry(atom)[source]¶; Returns the CoordEntry for an atom. atom_to_unique(iatom)[source]¶; Converts an atom number to the number of its generating unique atom.; The return value is in [0, nunique). atom_to_unique_offset(iatom)[source]¶; Converts an atom number to the offset of this atom; in the list of generated atoms. The unique atom itself is allowed offset 0. center_of_mass()[source]¶; Computes center of mass of molecule (does not translate molecule).; >>> H2OH2O.center_of_mass(); [-0.12442647346606871, 0.00038657002584110707, 0.0]. charge(atom)[source]¶; Returns charge of atom (0-indexed",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:75350,charge,charge,75350,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,4,['charge'],['charge']
Energy Efficiency," handling, no symmetry,; no pubchem, no efp, no discarding dummies. This class translated so; that databases can function independently of psi4.; >>> H2OH2O = qcdb.Molecule(""""""; 0 1; O1 -1.551007 -0.114520 0.000000; H1 -1.934259 0.762503 0.000000; H2 -0.599677 0.040712 0.000000; --; 0 1; X 0.000000 0.000000 0.000000; O2 1.350625 0.111469 0.000000; H3 1.680398 -0.373741 -0.758561; H4 1.680398 -0.373741 0.758561; no_com; no_reorient; units angstrom; """"""). >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'). FullPointGroupList = ['ATOM', 'C_inf_v', 'D_inf_h', 'C1', 'Cs', 'Ci', 'Cn', 'Cnv', 'Cnh', 'Sn', 'Dn', 'Dnd', 'Dnh', 'Td', 'Oh', 'Ih']¶. Z(atom)[source]¶; Nuclear charge of atom (0-indexed); >>> print H2OH2O.Z(4); 1. activate_all_fragments()[source]¶; Sets all fragments in the molecule to be active. add_atom(Z, x, y, z, label='', mass=0.0, charge=0.0, lineno=-1)[source]¶; Add an atom to the molecule; Z atomic number; x cartesian coordinate; y cartesian coordinate; z cartesian coordinate; symb atomic symbol to use; mass mass to use if non standard; charge charge to use if non standard; lineno line number when taken from a string. atom_at_position(b, tol=0.05)[source]¶; Tests to see of an atom is at the passed position b in Bohr with a tolerance tol.; >>> print H2OH2O.atom_at_position([1.35*(1.0/psi_bohr2angstroms), 0.10*(1.0/psi_bohr2angstroms), 0.0*(1.0/psi_bohr2angstroms)]); 3. atom_entry(atom)[source]¶; Returns the CoordEntry for an atom. atom_to_unique(iatom)[source]¶; NYI Converts an atom number to the number of its generating unique atom.; The return value is in [0, nunique). atom_to_unique_offset(iatom)[source]¶; NYI Converts an atom number to the offset of this atom; in the list of generated atoms. The unique atom itself is allowed offset 0. center_of_mass()[source]¶; Computes center of mass of molecule (does not translate molecule).; >>> H2OH2O.center_of_mass(); [-0.12442647346606871, 0.00038657002584110707, 0.0]. charge(atom)[source]¶; Returns charge of atom (0",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodoc_driver-1.html:44509,charge,charge,44509,psi4manual/4.0b5/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodoc_driver-1.html,4,['charge'],['charge']
Energy Efficiency," have been defined at compute time. May be a temporary situation; so message not printed but appears as traceback when error persists. exception QcdbException[source]¶; Error class for QCDB. exception ValidationError(msg)[source]¶; Error called for problems with syntax input file. Prints; error message msg to standard output stream. class Molecule(psi4molstr=None)[source]¶; Class to store python extensions to the MoleculeLibmints class.; Multiple classes allows separation of libmints and extension methods. BFS()[source]¶; Perform a breadth-first search (BFS) on the real atoms; in molecule, returning an array of atom indices of fragments.; Relies upon van der Waals radii and so faulty for close; (esp. hydrogen-bonded) fragments. Original code from; Michael S. Marshall. auto_fragments()[source]¶; Detects fragments in an unfragmented molecule using BFS; algorithm. Returns a new Molecule in Cartesian, fixed-geom; (no variable values), no dummy-atom format. Any non-default; charge and multiplicity assigned to first fragment. format_molecule_for_molpro()[source]¶. format_molecule_for_nwchem()[source]¶. format_molecule_for_psi4()[source]¶; Returns string of molecule definition block. format_molecule_for_qchem()[source]¶. grimme_dftd3(func=None, dashlvl=None, dashparam=None, verbosity=1)[source]¶; Function to call Grimme’s dftd3 program (http://toc.uni-muenster.de/DFTD3/); to compute the -D correction of level dashlvl using parameters for; the functional func. The dictionary dashparam can be used to supply; a full set of dispersion parameters in the absense of func or to supply; individual overrides in the presence of func. The dftd3 executable must be; independently compiled and found in :envvar:PATH. inertia_tensor(masswt=True)[source]¶; Compute inertia tensor.; >>> print H2OH2O.inertia_tensor(); [[8.704574864178731, -8.828375721817082, 0.0], [-8.828375721817082, 280.82861714077666, 0.0], [0.0, 0.0, 281.249500988553]]. inertia_tensor_partial(part, masswt=True)[source]¶; Co",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodoc_driver-1.html:64538,charge,charge,64538,psi4manual/4.0b5/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodoc_driver-1.html,2,['charge'],['charge']
Energy Efficiency," have been defined at compute time. May be a temporary situation; so message not printed but appears as traceback when error persists. exception QcdbException[source]¶; Error class for QCDB. exception ValidationError(msg)[source]¶; Error called for problems with syntax input file. Prints; error message msg to standard output stream. class Molecule(psi4molstr=None)[source]¶; Class to store python extensions to the MoleculeLibmints class.; Multiple classes allows separation of libmints and extension methods. BFS()[source]¶; Perform a breadth-first search (BFS) on the real atoms; in molecule, returning an array of atom indices of fragments.; Relies upon van der Waals radii and so faulty for close; (esp. hydrogen-bonded) fragments. Original code from; Michael S. Marshall. auto_fragments()[source]¶; Detects fragments in an unfragmented molecule using BFS; algorithm. Returns a new Molecule in Cartesian, fixed-geom; (no variable values), no dummy-atom format. Any non-default; charge and multiplicity assigned to first fragment. format_string_for_qchem()[source]¶. classmethod init_with_xyz(xyzfilename, no_com=False, no_reorient=False)[source]¶; Pull information from an XYZ file. No fragment info detected.; Charge, multiplicity, tagline pulled from second line if available.; >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'). save_string_for_psi4()[source]¶; Returns a string of Molecule formatted for psi4.; Includes fragments and reorienting, if specified.; >>> print H2OH2O.save_string_for_psi4(); 6; 0 1; O -1.55100700 -0.11452000 0.00000000; H -1.93425900 0.76250300 0.00000000; H -0.59967700 0.04071200 0.00000000; --; 0 1; @X 0.00000000 0.00000000 0.00000000; O 1.35062500 0.11146900 0.00000000; H 1.68039800 -0.37374100 -0.75856100; H 1.68039800 -0.37374100 0.75856100; units Angstrom. Elemental masses (most common isotope), symbols, and atomic numbers from psi4.; Stuff stolen from psi. Should import or not as necessary; or some better way. Apologies to the coders. compare_matric",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_driver-1.html:60185,charge,charge,60185,psi4manual/4.0b3/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_driver-1.html,4,['charge'],['charge']
Energy Efficiency," have no influence; on a cbs calculation. Parameters:; scf_basis (basis string) – \(\Rightarrow\) corl_basis \(\Leftarrow\) || 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, scf_basis can default; to corl_basis. corl_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the correlation energy. delta_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. delta2_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. delta3_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the third delta correction; to the correlation energy. delta4_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the fourth delta correction; to the correlation energy. delta5_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the fifth delta correction; to the correlation energy. Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, 'xtpl_highest_1', which uses the best basis; set available. See sec:cbs_xtpl for all available schemes. Parameters:; scf_scheme (function) – \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || scf_xtpl_helgaker_3 || etc.; Indicates the basis set extrapolation scheme to be applied to the reference energy.; D",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/cbs-1.html:7088,energy,energy,7088,psi4manual/1.2.1/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/cbs-1.html,7,['energy'],['energy']
Energy Efficiency," here are the specifics, the governing laws. Specifying a piece of input in PSI4 format is entering into; a contract that you mean it. In particular this applies to; molecule (including charge/multiplicity through molecule; optional_molecule_name {...}), memory (through memory; value unit), computational method (through . If Cfour keywords; are specified with values that contradict the PSI4 input,; execution is halted.; As an example, the input below is set up to fail in four ways:; contradictory specification of memory, multiplicity, computational; method, and derivative level. Note, though, that the cfour_units; angstrom setting is permissible, since it concurs with the value; implied in the molecule block.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15memory 300 mb. molecule {; H; H 1 0.7; }. set basis 6-31g; set cfour_multiplicity 3 # clash with implicit singlet in molecule {} above; set cfour_units angstrom # no problem, consistent with molecule {} above; set cfour_memory_size 100000000 # clash with 300 mb above; set cfour_calc_level ccsd # clash with 'c4-scf' below; set cfour_deriv_level first # clash with energy() below (use gradient('c4-scf') to achieve this). energy('c4-scf'). Specifying anything in PSI4 format (molecule, basis, options,; method call) starts building a *CFOUR(...) directive for the; ZMAT file. Since the contents of the cfour {...} block are; blindly appended to any input interpreted from PSI4 format, mixing; of PSI4 and Cfour input formats likely will give rise to multiple; *CFOUR(...) directives in the prospective ZMAT, execution of; which will be trapped and halted. Proper uses for the cfour {...}; block are for the sandwich mode, where the entire ZMAT is enclosed,; or for extra directives like %excite*, which presently have no other; specification route. Specifying the basis is perhaps the regulated piece of input. Since; basis set names differ between PSI4 and Cfour and it’s not; practical to compare exponent-to-exponent, any input ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/cfour-1.html:29154,energy,energy,29154,psi4manual/1.2.1/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/cfour-1.html,6,['energy'],['energy']
Energy Efficiency," hessian matrix; # TODO: set current energy to un-displaced energy. else:; # If not, perform finite difference of energies; print('Performing finite difference calculations by energies'). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash.restore(); if not psi4.has_option_changed('SCF', 'E_CONVERGENCE'):; if procedures['energy'][lowername] == run_scf or procedures['energy'][lowername] == run_dft:; psi4.set_local_option('SCF', 'E_CONVERGENCE', 10); else:; psi4.set_local_option('SCF', 'E_CONVERGENCE', 11); if not psi4.has_option_changed('SCF', 'D_CONVERGENCE'):; if procedures['energy'][lowername] == run_scf or procedures['energy'][lowername] == run_dft:; psi4.set_local_option('SCF', 'D_CONVERGENCE', 10); else:; psi4.set_local_option('SCF', 'D_CONVERGENCE', 11). # Set post-scf convergence criteria (global will cover all correlated modules); if not psi4.has_global_option_changed('E_CONVERGENCE'):; if not procedures['energy'][lowername] == run_scf and not procedures['energy'][lowername] == run_dft:; psi4.set_global_option('E_CONVERGENCE', 10). # Obtain list of displacements; displacements = psi4.fd_geoms_freq_0(irrep); molecule.fix_orientation(True); molecule.reinterpret_coordentry(False); # Make a note of the undisplaced molecule's symmetry; psi4.set_parent_symmetry(molecule.schoenflies_symbol()). ndisp = len(displacements). # This version is pretty dependent on the reference geometry being last (as it is now); print(' %d displacements needed.' % ndisp); energies = []. # S/R: Write instructions for sow/reap procedure to output file and reap input file; if (freq_mode.lower() == 'sow'):; instructionsO = """"""\n# The frequency sow/reap procedure has been selected through mode='sow'. In addition\n""""""; instructionsO += """"""# to this output file (which contains no quantum chemical calculations), this job\n""""""; instructionsO += """"""# has produced a number of input files (FREQ-*.in) for individual components\n""""""; instruc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/driver.html:65373,energy,energy,65373,psi4manual/4.0b5/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/driver.html,2,['energy'],['energy']
Energy Efficiency," highest_1 || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the correlation energy. delta_scheme (function) – highest_1 || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the delta correction; to the correlation energy. delta2_scheme (function) – highest_1 || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the second delta correction; to the correlation energy. delta3_scheme (function) – highest_1 || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the third delta correction; to the correlation energy. delta4_scheme (function) – highest_1 || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the fourth delta correction; to the correlation energy. delta5_scheme (function) – highest_1 || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the fifth delta correction; to the correlation energy. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> cbs('scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> cbs('mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> cbs('scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> cbs('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/cbs-1.html:8286,energy,energy,8286,psi4manual/4.0b5/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/cbs-1.html,2,['energy'],['energy']
Energy Efficiency," how to carry out coupled cluster calculations within PSI4.; For higher-order coupled-cluster methods like CCSDT and CCSDTQ, PSI4; can interface to Kállay’s MRCC code (see MRCC). Current coupled cluster capabilities of PSI4. Method; Reference; Energy; Gradient; Exc. Energies; LR Props. CC2; RHF; Y; —; Y; Y. UHF; Y; —; Y; —. ROHF; Y; —; Y; —. CCSD; RHF; Y; Y; Y; Y. UHF; Y; Y; Y; —. ROHF; Y; Y; Y; —. CCSD(T); RHF; Y; —; n/a; n/a. UHF; Y; Y; n/a; n/a. ROHF; Y; —; n/a; n/a. a-CCSD(T); RHF; Y; —; n/a; n/a. CC3; RHF; Y; —; Y; —. UHF; Y; —; Y; —. ROHF; Y; —; Y; —. CCD; Brueckner; Y; N; N; N. CCD(T); Brueckner; Y; N; n/a; n/a. The following wavefunctions are currently recognized by PSI4 as arguments; to functions like energy(): 'ccsd', 'ccsd(t)', 'a-ccsd(t)', 'cc2',; 'cc3', 'bccd' (CCD with Brueckner orbitals), 'bccd(t)' (CCD(T) with; Brueckner orbitals), 'eom-ccsd', 'eom-cc2' (CC2 for excited states),; 'eom-cc3' (CC3 for excited states). Response properties can be obtained; by calling the function property() (instead of, for example, energy(),; e.g., property('ccsd'). There are many sample; coupled cluster inputs provided in psi4/samples. Basic Keywords¶; A complete list of keywords related to coupled-cluster computations is; provided in the appendices, with the majority of the relevant; keywords appearing in Appendix CCENERGY. For a standard ground-state; CCSD or CCSD(T) computation, the following keywords are common:. REFERENCE¶. Reference wavefunction type. Type: string; Possible Values: RHF; Default: RHF. R_CONVERGENCE¶. Convergence criterion for T2 amplitudes (RMS change). Type: conv double; Default: 1e-5. MAXITER¶. Maximum number of iterations. Type: integer; Default: 50. BRUECKNER_ORBS_R_CONVERGENCE¶. Convergence criterion for Breuckner orbitals. The convergence is determined based on the largest amplitude. Default adjusts depending on E_CONVERGENCE. Type: conv double; Default: 1e-5. RESTART¶. Do restart the coupled-cluster iterations from old and amplitudes? For ge",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/cc-1.html:3505,energy,energy,3505,psi4manual/4.0b5/cc-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/cc-1.html,2,['energy'],['energy']
Energy Efficiency," if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp2p5_gradient(name, **kwargs):; """"""Function selecting the algorithm for a MP2.5 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'); all_electron = (core.get_global_option('FREEZE_CORE') == ""FALSE""). func = None; if reference in ['RHF', 'UHF']:; if mtd_type == 'CONV':; if all_electron:; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module, all_electron]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2p5(name, **kwargs):; """"""Function selecting the algorithm for an OMP2.5 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2p5_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OMP2.5 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in [",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:16604,energy,energy,16604,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,4,['energy'],['energy']
Energy Efficiency," if not (lowername in procedures[types[dertype]]):; print 'Frequencies: dertype = %d for frequencies is not available, switching to automatic determination.' % dertype; dertype = -1. if 'irrep' in kwargs:; irrep = parse_cotton_irreps(kwargs['irrep']) - 1 # externally, A1 irrep is 1, internally 0; else:; irrep = -1 # -1 implies do all irreps. # By default, set func to the energy function; func = energy; func_existed = False; if 'func' in kwargs:; func = kwargs['func']; func_existed = True. if (not('dertype' in kwargs) or dertype == -1):; if lowername in procedures['hessian']:; dertype = 2; elif lowername in procedures['gradient']:; dertype = 1; else:; dertype = 0. # Does an analytic procedure exist for the requested method?; if (dertype == 2 and func_existed == False):; # We have the desired method. Do it.; procedures['hessian'][lowername](lowername, **kwargs); return PsiMod.reference_wavefunction().energy(); elif (dertype == 1 and func_existed == False):; # Ok, we're doing frequencies by gradients; info = 'Performing finite difference by gradient calculations'; print info. func = procedures['gradient'][lowername]. # Obtain list of displacements; displacements = PsiMod.fd_geoms_freq_1(irrep). molecule.reinterpret_coordentry(False); molecule.fix_orientation(True); # Make a note of the undisplaced molecule's symmetry; PsiMod.set_parent_symmetry(molecule.schoenflies_symbol()). ndisp = len(displacements); print ' %d displacements needed.' % ndisp. #print displacements to output.dat; #for n, displacement in enumerate(displacements):; # displacement.print_out();. gradients = []; for n, displacement in enumerate(displacements):; # Print information to output.dat; PsiMod.print_out('\n'); banner('Loading displacement %d of %d' % (n + 1, ndisp)). # Print information to the screen; print ' %d' % (n + 1),; if (n + 1) == ndisp:; print '\n',. # Load in displacement into the active molecule (xyz coordinates only); molecule.set_geometry(displacement). # Perform the gradient calculati",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/driver.html:45056,energy,energy,45056,psi4manual/4.0b2/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/driver.html,1,['energy'],['energy']
Energy Efficiency," if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from the 3rd edition of the IUPAC Green; book [Cohen:GreenBook:2008]) are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that ~/.psi4rc values can be overridden by; the user).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files.; psi_h = 6.62606896E-34 # The Planck constant (Js) ; psi_c = 2.99792458E8 # Speed of light (ms$^{-1}$) ; psi_kb = 1.3806504E-23 # The Boltzmann constant (JK$^{-1}$) ; psi_R = 8.314472 # Universal gas constant (JK$^{-1}$mol$^{-1}$) ; psi_bohr2angstroms = 0.52917720859 # Bohr to Angstroms conversion factor ; psi_bohr2m = 0.52917720859E-10 # Bohr to meters conversion factor ; psi_bohr2cm = 0.52917720859E-8 # Bohr to centimeters conversion factor ; psi_amu2g = 1.660538782E-24 # Atomic mass units to grams conversion factor ; psi_amu2kg = 1.660538782E-27 # Atomic mass units to kg conversion factor ; psi_au2amu = 5.485799097E-4 # Atomic units (m$@@e$) to atomic mass units conversion factor ; psi_hartree2J = 4.359744E-18 # Hartree to joule conversion factor ; psi_hartree2aJ = 4.359744 # Hartree to attojoule (10$^{-18}$J) conversion factor ; psi_cal2J = 4.184 # Calorie to joule conversion factor ; psi_dipmom_au2si = 8.47835281E-30 # Atomic units to SI units (Cm) conversion factor for dipoles ; psi_dipmom_au2debye = 2.54174623 # Atomic units to Debye conversion factor for dipoles ; psi_dipmom_debye2si = 3.335640952E-30 # Debye to SI units (Cm) conversion factor for dipoles ; psi_c_au = 137.035999679 # Speed of light in atomic units ; psi_hartree2ev = 27.21138 # Hartree to eV conversion factor ; psi_hartree2wavenumbers = 219474.6 # Hartree to cm$^",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:2112,meter,meters,2112,psi4manual/4.0b2/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html,8,['meter'],['meters']
Energy Efficiency," image of the scene. Generally the view orientation and some specific; details of the .pymol files require some small tweaks to permit; publication-quality renderings. Adding Point Charges to F/I-SAPT Computations¶; Point charges can be added to the interacting subsystems A and B as well; as to the linking fragment C. Briefly, the interaction between the point charges in A(B); and fragment B(A) enters the SAPT0 interaction energy. It explicitly affects the electrostatics; and induction components, and implicitly affects other SAPT0 components by polarizing the orbitals.; If point charges are present in both subsystems A and B, an additional charge-charge interaction; term is also added to the electrostatic energy. When point charges are assigned to subsystem C, the point; charges in C only polarize the orbitals in both fragment A and B. However, the presence of charges in C does not; directly contribute to the SAPT0 interaction energy.; Examples fsapt-ext-abc and fsapt-ext-abc2; illustrate the use of point charges in F/I-SAPT procedure. Link Orbital Partitioning in I-SAPT¶; The assignment of the A-C and B-C linking electron pairs is controlled by the FISAPT_LINK_ASSIGNMENT; keyword. The default setting fisapt_link_assignment c assigns the entire pair to the linker C together with; a +1 nuclear charge from the connecting atoms of A/B to preserve the electrical neutrality of each fragment.; However, as already noticed in [Parrish:2015:051103], such a partitioning might result in unphysical dipole; moments at the interfragment boundaries. Imagine, for example, that I-SAPT is used to examine the interaction; of two methyl groups connected by some linker fragment. When the linking bonds are assigned to C, the carbon atoms; of the methyl groups are missing electrons on one of their sp^3 hybrid orbitals and a dipole moment appears.; These dipole moments have been observed to lead, in some cases, to I-SAPT energy contributions that do not make; physical sense, for example, t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/fisapt.html:12980,charge,charges,12980,psi4manual/1.8.x/fisapt.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/fisapt.html,3,['charge'],['charges']
Energy Efficiency," import check_iwl_file_from_scf_type; from .exceptions import TestComparisonError, ValidationError; from .testing import compare_integers, compare_recursive, compare_values. [docs]; def fcidump(wfn: core.Wavefunction, fname: str = 'INTDUMP', oe_ints: Optional[List] = None):; """"""Save integrals to file in FCIDUMP format as defined in Comp. Phys. Commun. 54 75 (1989),; https://doi.org/10.1016/0010-4655(89)90033-7 .; Additional one-electron integrals, including orbital energies, can also be saved.; This latter format can be used with the HANDE QMC code but is not standard. Parameters; ----------; wfn; Set of molecule, basis, orbitals from which to generate FCIDUMP file.; fname; Name of the integrals file, defaults to INTDUMP.; oe_ints; List of additional one-electron integrals to save to file. So far only; EIGENVALUES is a valid option. Raises; ------; ValidationError; When SCF wavefunction is not RHF. Examples; --------. >>> # [1] Save one- and two-electron integrals to standard FCIDUMP format; >>> E, wfn = energy('scf', return_wfn=True); >>> fcidump(wfn). >>> # [2] Save orbital energies, one- and two-electron integrals.; >>> E, wfn = energy('scf', return_wfn=True); >>> fcidump(wfn, oe_ints=['EIGENVALUES']). """"""; # Get some options; reference = core.get_option('SCF', 'REFERENCE'); ints_tolerance = core.get_global_option('INTS_TOLERANCE'); # Some sanity checks; if reference not in ['RHF', 'UHF']:; raise ValidationError('FCIDUMP not implemented for {} references\n'.format(reference)); if oe_ints is None:; oe_ints = []. molecule = wfn.molecule(); docc = wfn.doccpi(); frzcpi = wfn.frzcpi(); frzvpi = wfn.frzvpi(); active_docc = docc - frzcpi; active_socc = wfn.soccpi(); active_mopi = wfn.nmopi() - frzcpi - frzvpi. nbf = active_mopi.sum() if wfn.same_a_b_orbs() else 2 * active_mopi.sum(); nirrep = wfn.nirrep(); nelectron = 2 * active_docc.sum() + active_socc.sum(); irrep_map = _irrep_map(wfn). wfn_irrep = 0; for h, n_socc in enumerate(active_socc):; if n_socc % 2 == 1:; wfn_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/fcidump.html:2473,energy,energy,2473,psi4manual/1.9.x/_modules/psi4/driver/p4util/fcidump.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/fcidump.html,2,['energy'],['energy']
Energy Efficiency," in Bohr passed as keyword argument, e.g., `energy(..., external_potentials=[[0.5, [0, 0, 1]], [-0.5, [0, 0, -1]]])`.'). [docs]class QMMMbohr():; """"""Hold charges and :py:class:`psi4.core.ExternalPotential`. To add external charges to a calculation, prefer; passing the array of charges with kwarg ``external_potentials``, as in extern2 example."""""". def __init__(self):; self.charges = []; self.diffuses = []; self.extern = core.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs] def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs] def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / constants.bohr2angstroms, y / constants.bohr2angstroms, z / constants.bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs] def populateExtern(self):; """"""Function to define a charge field external to the; molecule through point and diffuse charges. """"""; # Charges; for charge in self.charges:; self.extern.addCharge(charge[0], charge[1], charge[2], charge[3]); # Diffuses; for diffuse in self.diffuses:; diffuse.populateExtern(self.extern). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.6;  · . PSI4. Module code; psi4.driver.qmmm. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qmmm.html:4901,charge,charges,4901,psi4manual/1.6.x/_modules/psi4/driver/qmmm.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qmmm.html,13,['charge'],"['charge', 'charges']"
Energy Efficiency," in a whitespace-tolerant; format. See Molecule and Geometry Specification for details and; cfour/mints5 for examples. When a PSI4-style molecule is; supplied, its geometry is written to ZMAT in Cartesian form and the; CFOUR_COORDINATES=CARTESIAN, CFOUR_UNITS=ANGSTROM,; CFOUR_CHARGE, and CFOUR_MULTIPLICITY keywords are set; appropriately in the *CFOUR(...) directive. Warning; There exist molecules (e.g., allene) where the; inertial frame is not unique (planes along atoms or between; atoms). The orientation reconciling machinery currently does not; handle these cases and will fail with “Axis unreconcilable between; QC programs”. I will get to this soon. Whenever the molecule is supplied in PSI4 format, the job control; keywords must be too. All Cfour keywords are the usual; ones, prepended by cfour_ to avoid any possible name conflicts. As; detailed in Job Control Keywords, setting keywords is flexible in; format. The previous example translates to:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23# UHF-SCF energy calculation. molecule {; 0 2 # multiplicity from the MULT keyword; N; H 1 R; H 1 R 2 A. R=1.008; A=105.0; }. set {; cfour_CALC_level=HF # only full keyword names allowed; cfour_BASIS=qz2p; #MULT=2 # now in molecule {...} block; cfour_REFerence=UHF; cfour_OCCUPATION [[3, 1, 1, 0], [3,0,1,0] ] # arrays in python notation; cfour_SCF_CONV=12; cfour_MEMORY=20000000; }. energy('cfour'). Here, note that none of capitalization, equals sign, or whitespace matter; for the keyword commands. Specification of strings and integers requires no; translation; booleans have extended freedom of; format; arrays must be translated into Python-style (square-bracket; bounded and comma delimited) of appropriate dimension. There are many; sample inputs in psi4/tests/cfour/ starting with sp- that take; examples from the Cfour manual and first run them in sandwich mode and; then run them as translated into PSI4 format. Note; PSI4 only recognizes keywo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/cfour-1.html:5271,energy,energy,5271,psi4manual/1.2.1/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/cfour-1.html,6,['energy'],['energy']
Energy Efficiency," in diagonalizing the Hamiltonian. The valid options are: RSP, to form the entire H matrix and diagonalize using libciomr to obtain all eigenvalues (n.b. requires HUGE memory); OLSEN, to use Olsen’s preconditioned inverse subspace method (1990); MITRUSHENKOV, to use a 2x2 Olsen/Davidson method; and DAVIDSON (or SEM) to use Liu’s Simultaneous Expansion Method, which is identical to the Davidson method if only one root is to be found. There also exists a SEM debugging mode, SEMTEST. The SEM method is the most robust, but it also requires \(2NM+1\) CI vectors on disk, where \(N\) is the maximum number of iterations and \(M\) is the number of roots. Type: string; Possible Values: RSP, DAVIDSON, SEM; Default: SEM. DIAGONAL_CCSD_T (PSIMRCC); PSIMRCC — Do include the diagonal corrections in (T) computations?. Type: boolean; Default: true. DIAGONALIZE_HEFF (PSIMRCC); PSIMRCC — Do diagonalize the effective Hamiltonian?. Type: boolean; Default: false. DIE_IF_NOT_CONVERGED (GLOBALS); GLOBALS (Expert) — Psi4 dies if energy does not converge. Type: boolean; Default: true. DIIS (CCENERGY); CCENERGY — Do use DIIS extrapolation to accelerate convergence?. Type: boolean; Default: true. DIIS (CCLAMBDA); CCLAMBDA — Do use DIIS extrapolation to accelerate convergence?. Type: boolean; Default: true. DIIS (CCRESPONSE); CCRESPONSE — Do use DIIS extrapolation to accelerate convergence?. Type: boolean; Default: true. DIIS (DETCI); DETCI — Do use DIIS extrapolation to accelerate CC convergence?. Type: boolean; Default: true. DIIS (MCSCF); MCSCF — Do use DIIS extrapolation to accelerate convergence of the SCF energy (MO coefficients only)?. Type: boolean; Default: true. DIIS (SCF); SCF — Do use DIIS extrapolation to accelerate convergence?. Type: boolean; Default: true. DIIS_FREQ (DETCI); DETCI — How often to do a DIIS extrapolation. 1 means do DIIS every iteration, 2 is every other iteration, etc. Type: integer; Default: 1. DIIS_MAX_VECS (DCFT); DCFT (Expert) — Maximum number of error vector",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html:105363,energy,energy,105363,psi4manual/1.2.1/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html,6,['energy'],['energy']
Energy Efficiency," in optimizing; and extending the code, so expect performance gains and extensions to; gradients/hessians and TDDFT in future releases.; Some rough guidelines for using the KS-DFT code are as follows,. Use DF for the ERI algorithm wherever possible.; PSI4 is a “tight” code, meaning we’ve set the default numerical cutoffs; for integrals, grids, and convergence criteria in such a way that you will often; get many more digits of precision than needed. You may be able to realize; additional speed gains by loosening some of these thresholds. See; SCF Convergence for default convergence criteria.; Read the literature to determine which functional technology to use. The world; contains far too many papers using B3LYP on noncovalent interactions without a -D. The “best-practice” input file for KS-DFT is:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14memory 1 GB # As much as you've got, the DF algorithm can use. molecule {; H; H 1 0.7; }. set {; basis cc-pvdz; scf_type df; guess sad; }. energy('b3lyp'). Advanced Functional Use and Manipulation¶; New DFT functionals can be created from scratch from within the input; file and accessed using the dft_functional keyword argument in the; energy call:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28# DFT Custom Functional. molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; basis sto-3g; dft_spherical_points 302; dft_radial_points 99; reference rks; }. pbe0 = {; ""name"": ""my_PBE0"",; ""x_functionals"": {""GGA_X_PBE"": {""alpha"": 0.75}},; ""x_hf"": {""alpha"": 0.25},; ""c_functionals"": {""GGA_C_PBE"": {}}; }. func_call = energy('SCF', dft_functional=pbe0). # as PBE0 is a pre-defined functional, the call above is equivalent to both below:; func_call = energy('SCF', dft_functional=""PBE0""); func_call = energy('PBE0'). Supported keywords include:. name: string, name of the functional. for custom defined functionals used for printing only.; xc_functionals: dict, definition of a complete (X +",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/dft-1.html:27139,energy,energy,27139,psi4manual/1.3.2/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/dft-1.html,2,['energy'],['energy']
Energy Efficiency," in optimizing; and extending the code, so expect performance gains and extensions to; gradients/hessians and TDDFT in future releases.; Some rough guidelines for using the KS-DFT code are as follows,. Use DF for the ERI algorithm wherever possible.; PSI4 is a “tight” code, meaning we’ve set the default numerical cutoffs; for integrals, grids, and convergence criteria in such a way that you will often; get many more digits of precision than needed. You may be able to realize; additional speed gains by loosening some of these thresholds. See; SCF Convergence for default convergence criteria.; Read the literature to determine which functional technology to use. The world; contains far too many papers using B3LYP on noncovalent interactions without a -D. The “best-practice” input file for KS-DFT is:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14memory 1 GB # As much as you've got, the DF algorithm can use. molecule {; H; H 1 0.7; }. set {; basis cc-pvdz; scf_type df; guess sad; }. energy('b3lyp'). Advanced Functional Use and Manipulation¶; Using the dft_functional keyword argument in the energy procedure call, one is able to use the orbitals generated by DFT for correlated wavefunction methods:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17# MP2 with a PBE0 reference computation. molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; basis 6-31G; dft_spherical_points 302; dft_radial_points 99; reference rks; }. mp2_dft = energy(""MP2"", dft_functional=""PBE0""). Note that this would only update the generic Psi variables (e.g., “CURRENT ENERGY”) and not the MP2 or DFT variables.; Psi4 also supports easy customization and manipulation of DFT functionals. The values of alpha and omega can be adjusted with the DFT_ALPHA; and DFT_OMEGA keywords. For example, for LRC functionals, one can control the fraction of long-range Hartree-Fock and short-range DFA by changing DFT_OMEGA:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22molecule ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/dft-1.html:27457,energy,energy,27457,psi4manual/1.2.1/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/dft-1.html,2,['energy'],['energy']
Energy Efficiency," in parallel?. Type: boolean; Default: false. PROCESS_GRID¶. The dimension sizes of the processor grid. Type: array; Default: No Default. TILE_SZ¶. The tile size for the distributed matrices. Type: integer; Default: 512. Expert Misc.¶. SAPT¶. Are going to do SAPT? If so, what part?. Type: string; Default: FALSE. Expert DFSCF Algorithm¶. DF_FITTING_CONDITION¶. Fitting Condition, i.e. eigenvalue threshold for RI basis. Analogous to S_TOLERANCE. Type: double; Default: 1.0e-10. DF_INTS_IO¶. IO caching for CP corrections, etc. Changing this selects Disk_DF over Mem_DF. Note that setting this forces DiskDFJK when SCF_TYPE=DF. Type: string; Possible Values: NONE, SAVE, LOAD; Default: NONE. Expert COSX Algorithm¶. COSX_BASIS_TOLERANCE¶. Screening criteria for basis function values on COSX grids. Type: conv double; Default: 1.0e-10. COSX_DENSITY_TOLERANCE¶. Screening criteria for shell-pair densities in COSX. Type: conv double; Default: 1.0e-10. COSX_OVERLAP_FITTING¶. Do reduce numerical COSX errors with overlap fitting?. Type: boolean; Default: true. COSX_PRUNING_SCHEME¶. Pruning scheme for COSX grids. Type: string; Default: ROBUST. Expert snLinK Algorithm¶. SNLINK_BASIS_TOLERANCE¶. Screening criteria for basis function values on snLinK grids. Type: conv double; Default: 1.0e-10. SNLINK_DENSITY_TOLERANCE¶. Screening criteria for shell-pair densities in snLinK. Type: conv double; Default: 1.0e-10. SNLINK_FORCE_CARTESIAN¶. Force snLinK to use cartesian coordinates. Type: boolean; Default: false. SNLINK_GPU_MEM¶. Proportion (in %) of available GPU memory to allocate to snLinK. Type: boolean; Default: 90. SNLINK_GRID_BATCH_SIZE¶. Maximum number of grid points per grid block for GauXC. Type: integer; Default: 2048. SNLINK_INTEGRATOR_KERNEL¶. Integrator execution kernel for snLinK GauXC also has SHELLBATCHED, but it is incompatible with Psi4 due to not being yet implemented with sn-LinK. Type: string; Possible Values: DEFAULT, INCORE; Default: DEFAULT. SNLINK_LOAD_BALANCER_KERNEL¶",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodir_options_c/module__scf.html:21916,reduce,reduce,21916,psi4manual/master/autodir_options_c/module__scf.html,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/module__scf.html,1,['reduce'],['reduce']
Energy Efficiency," in python the psi4 libmints; CoordValue and CoordEntry classes, which were developed by; Justin M. Turney, with incremental improvements by other; psi4 developers. class CartesianEntry(entry_number, Z, charge, mass, symbol, label, x, y, z)[source]¶; Class to hold all information about an atom, including its; coordinate specification as three Cartesians. clone()[source]¶; Returns new, independent CartesianEntry object. compute()[source]¶; Computes the values of the coordinates (in whichever units; were inputted), returning them in a Vector. everything()[source]¶. invalidate()[source]¶; Flags the current coordinates as being outdated. print_in_input_format()[source]¶; Prints the updated geometry, in the format provided by the user. set_coordinates(x, y, z)[source]¶; Given the current set of coordinates, updates the values of this; atom’s coordinates and any variables that may depend on it. type()[source]¶; The type of CoordEntry specialization. class CoordEntry(entry_number, Z, charge, mass, symbol, label='')[source]¶; Class to. Z()[source]¶; The nuclear charge of the current atom (0 if ghosted). static a(a1, a2, a3)[source]¶; Computes the angle (in rad.) between three sets of coordinates. charge()[source]¶; The “atomic charge” of the current atom (for SAD purposes). static d(a1, a2, a3, a4)[source]¶; Computes the dihedral (in rad.) between four sets of coordinates. entry_number()[source]¶; The order in which this appears in the full atom list. everything()[source]¶. is_computed()[source]¶; Whether the current atom’s coordinates are up-to-date. is_equivalent_to(other)[source]¶; Whether this atom has the same mass and ghost status as atom other.; Unlike the libmints version, this does not compare basisset assignment. is_ghosted()[source]¶; Whether the current atom is ghosted or not. label()[source]¶; The atom label. mass()[source]¶; The atomic mass of the current atom. static r(a1, a2)[source]¶; Computes the distance between two sets of coordinates. set_ghosted(gh)[so",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_driver-1.html:35801,charge,charge,35801,psi4manual/4.0b3/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_driver-1.html,6,['charge'],['charge']
Energy Efficiency," in range(self.nlattice):; latx = self.clattice[3 * ilat + 0] * unit_conv; laty = self.clattice[3 * ilat + 1] * unit_conv; latz = self.clattice[3 * ilat + 2] * unit_conv; self.lattice_field.extern.addCharge(self.lattice[ilat], latx, laty, latz); psi4.core.set_global_option_python('EXTERN', self.lattice_field.extern); self.set_lattice = True. # Respond to the >NLATTICE command; def recv_nlattice(self, nlattice=None):; """""" Receive the number of lattice point charges through MDI. Arguments:; nlattice: New number of point charges. If None, receive through MDI.; """"""; if nlattice is None:; self.nlattice = MDI_Recv(1, MDI_INT, self.comm); else:; self.nlattice = nlattice; self.clattice = [0.0 for ilat in range(3 * self.nlattice)]; self.lattice = [0.0 for ilat in range(self.nlattice)]; self.set_lattice_field(). # Respond to the >CLATTICE command; def recv_clattice(self, clattice=None):; """""" Receive the coordinates of a set of lattice point charges through MDI. Arguments:; clattice: New coordinates of the lattice of point charges. If None, receive through MDI.; """"""; if clattice is None:; self.clattice = MDI_Recv(3 * self.nlattice, MDI_DOUBLE, self.comm); else:; self.clattice = clattice; self.set_lattice_field(). # Respond to the >LATTICE command; def recv_lattice(self, lattice=None):; """""" Receive the charges of a set of lattice point charges through MDI. Arguments:; lattice: New charges of the lattice of point charges. If None, receive through MDI.; """"""; if lattice is None:; self.lattice = MDI_Recv(self.nlattice, MDI_DOUBLE, self.comm); else:; self.lattice = lattice; self.set_lattice_field(). # Respond to the SCF command; def run_scf(self):; """""" Run an energy calculation; """"""; self.energy = psi4.energy(self.scf_method, **self.kwargs). # Respond to the <DIMENSIONS command; def send_dimensions(self):; """""" Send the dimensionality of the system through MDI. :returns: *dimensions* Dimensionality of the system; """"""; dimensions = [1, 1, 1]; MDI_Send(dimensions, 3, MDI_INT, self.comm)",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html:9704,charge,charges,9704,psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html,2,['charge'],['charges']
Energy Efficiency," in stage['d_need'].items():; MODELCHEM.append(lvl[1]). # Apply chemical reasoning to choose the minimum computations to run; JOBS = MODELCHEM[:]. addlremark = {'energy': '', 'gradient': ', GRADIENT', 'hessian': ', HESSIAN'}; instructions = ''; instructions += """""" Naive listing of computations required.\n""""""; for mc in JOBS:; instructions += """""" %12s / %-24s for %s%s\n"""""" % \; (mc['f_wfn'], mc['f_basis'] + "" + options""*bool(mc['f_options']),; VARH[mc['f_wfn']][mc['f_wfn']], addlremark[ptype]). # Remove duplicate modelchem portion listings; for mc in MODELCHEM:; dups = -1; for indx_job, job in enumerate(JOBS):; if (job['f_wfn'] == mc['f_wfn']) and (job['f_basis'] == mc['f_basis']) and \; (job['f_options'] == mc['f_options']) and (job['f_options'] != False):; dups += 1; if dups >= 1:; del JOBS[indx_job]. # Remove chemically subsumed modelchem portion listings; if ptype == 'energy':; for mc in MODELCHEM:; for wfn in VARH[mc['f_wfn']]:; for indx_job, job in enumerate(JOBS):; if (VARH[mc['f_wfn']][wfn] == VARH[job['f_wfn']][job['f_wfn']]) and \; (mc['f_basis'] == job['f_basis']) and not \; (mc['f_wfn'] == job['f_wfn']) and \; (mc['f_options'] == False):; del JOBS[indx_job]. instructions += """"""\n Enlightened listing of computations required.\n""""""; for mc in JOBS:; instructions += """""" %12s / %-24s for %s%s\n"""""" % \; (mc['f_wfn'], mc['f_basis'] + "" + options""*bool(mc['f_options']),; VARH[mc['f_wfn']][mc['f_wfn']], addlremark[ptype]). # Expand listings to all that will be obtained; JOBS_EXT = []; for job in JOBS:; for wfn in VARH[job['f_wfn']]:; JOBS_EXT.append(; dict(; zip(f_fields, [; wfn, job['f_basis'], job['f_zeta'], 0.0,; core.Matrix(natom, 3),; core.Matrix(3 * natom, 3 * natom), job['f_options']; ]))). instructions += """"""\n Full listing of computations to be obtained (required and bonus).\n""""""; for mc in JOBS_EXT:; instructions += """""" %12s / %-24s for %s%s\n"""""" % \; (mc['f_wfn'], mc['f_basis'] + "" + options""*bool(mc['f_options']),; VARH[mc['f_wfn']][mc['f_wfn']], addl",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html:49948,energy,energy,49948,psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,1,['energy'],['energy']
Energy Efficiency," in the MO basis to build alpha NO’s from (optional); density_b (Matrix) – density in the MO basis to build beta NO’s from, assumes restricted if not supplied (optional); dovirtual (bool) – do write all the MOs to the MOLDEN file (true) or discard the unoccupied MOs, not valid for NO’s (false) (optional). Examples. Molden file with the Kohn-Sham orbitals of a DFT calculation.; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> molden(wfn, 'mycalc.molden'). Molden file for CI/MCSCF computation using NO roots.; Any method returning a CIWavefunction object will work: detci,; fci, casscf, etc. The first two arguments of get_opdm can be; set to n, n where n => 0 selects the root to write out, provided; these roots were computed, see NUM_ROOTS. The; third argument controls the spin (""A"", ""B"" or ""SUM"") and the final; boolean option determines whether inactive orbitals are included.; >>> E, wfn = energy('detci', return_wfn=True); >>> molden(wfn, 'no_root1.molden', density_a=wfn.get_opdm(0, 0, ""A"", True)). The following produces an INCORRECT Molden file, because the; molden function needs orbitals in the MO basis (which are internally; converted and written to the Molden file in the AO basis). The correct; usage is given in the next point.; >>> E, wfn = energy('ccsd', return_wfn=True); >>> molden(wfn, 'ccsd_no.molden', density_a=wfn.Da()). Molden file with the natural orbitals of the ground-state 1RDM of a; Post-HF calculation. Note the required transformation of Da (SO->MO).; >>> E, wfn = properties('ccsd', return_wfn=True); >>> Da_so = wfn.Da(); >>> SCa = core.doublet(wfn.S(), wfn.Ca(), False, False); >>> Da_mo = core.triplet(SCa, Da_so, SCa, True, False, False); >>> molden(wfn, 'ccsd_no.molden', density_a=Da_mo). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. PSI4 API: Linking C++ and Python; molden. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.molden-1.html:2169,energy,energy,2169,psi4manual/1.4.0/api/psi4.driver.molden-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.molden-1.html,2,['energy'],['energy']
Energy Efficiency," in the MO basis to build alpha NO’s from (optional); density_b (Matrix) – density in the MO basis to build beta NO’s from, assumes restricted if not supplied (optional); dovirtual (bool) – do write all the MOs to the MOLDEN file (true) or discard the unoccupied MOs, not valid for NO’s (false) (optional). Examples. Molden file with the Kohn-Sham orbitals of a DFT calculation.; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> molden(wfn, 'mycalc.molden'). Molden file for CI/MCSCF computation using NO roots.; Any method returning a CIWavefunction object will work: detci,; fci, casscf, etc. The first two arguments of get_opdm can be; set to n, n where n => 0 selects the root to write out, provided; these roots were computed, see NUM_ROOTS. The; third argument controls the spin (""A"", ""B"" or ""SUM"") and the final; boolean option determines whether inactive orbitals are included.; >>> E, wfn = energy('detci', return_wfn=True); >>> molden(wfn, 'no_root1.molden', density_a=wfn.get_opdm(0, 0, ""A"", True)). The following produces an INCORRECT Molden file, because the; molden function needs orbitals in the MO basis (which are internally; converted and written to the Molden file in the AO basis). The correct; usage is given in the next point.; >>> E, wfn = energy('ccsd', return_wfn=True); >>> molden(wfn, 'ccsd_no.molden', density_a=wfn.Da()). Molden file with the natural orbitals of the ground-state 1RDM of a; Post-HF calculation. Note the required transformation of Da (SO->MO).; >>> E, wfn = properties('ccsd', return_wfn=True); >>> Da_so = wfn.Da(); >>> SCa = core.doublet(wfn.S(), wfn.Ca(), False, False); >>> Da_mo = core.triplet(SCa, Da_so, SCa, True, False, False); >>> molden(wfn, 'ccsd_no.molden', density_a=Da_mo). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. PSI4 API: Linking C++ and Python; molden. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.driver.molden-1.html:2169,energy,energy,2169,psi4manual/1.5.0/api/psi4.driver.molden-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.driver.molden-1.html,2,['energy'],['energy']
Energy Efficiency," in the active space. ao-casscf-sp; CASSCF/6-31G** energy point. tu2-ch2-energy; Sample UHF/6-31G** CH2 computation. opt13; B3LYP cc-pVDZ geometry optimzation of phenylacetylene, starting from not quite linear structure. dft-b3lyp; Check flavors of B3LYP (b3lyp3/b3lyp5) against other programs. dfomp2-grad1; DF-OMP2 cc-pVDZ gradients for the H2O molecule. psimrcc-fd-freq1; Mk-MRCCSD single point. \(^3 \Sigma ^-\) O2 state described using the Ms = 0 component of the triplet. Uses ROHF triplet orbitals. cbs-xtpl-energy; Extrapolated water energies. soscf1; Second-order SCF convergnece: Benzene. mints6; Patch of a glycine with a methyl group, to make alanine, then DF-SCF energy calculation with the cc-pVDZ basis set. isapt2; This is a shorter version if isapt1 - does not do cube plots. See isapt1 for full details. casscf-sa-sp; Example of state-averaged CASSCF for the C2 molecule see C. D. Sherrill and P. Piecuch, J. Chem. Phys. 122, 124104 (2005). cbs-xtpl-wrapper; RHF aug-cc-pVQZ energy for the BH molecule, with Cartesian input. Various gradients for a strained helium dimer and water molecule. dfccsd1; DF-CCSD cc-pVDZ energy for the H2O molecule. cc13b; Tests RHF CCSD(T)gradients. x2c1; Test of SFX2C-1e on water uncontracted cc-pVDZ-DK The reference numbers are from Lan Cheng’s implementation in Cfour. scf-property; UFH and B3LYP cc-pVQZ properties for the CH2 molecule. dfomp2p5-2; DF-OMP2.5 cc-pVDZ energy for the H2O+ cation. opt14; 6-31G(d) optimization of SF4 starting from linear bond angle that is not linear in the optimized structure but is in a symmetry plane of the molecule. dcft-grad1; DCFT DC-06 gradient for the O2 molecule with cc-pVDZ basis set. pywrap-checkrun-rhf; This checks that all energy methods can run with a minimal input and set symmetry. opt5; 6-31G** UHF CH2 3B1 optimization. Uses a Z-Matrix with dummy atoms, just for demo and testing purposes. cc53; Matches Table II a-CCSD(T)/cc-pVDZ H2O @ 2.5 * Re value from Crawford and Stanton, IJQC 98, 601-6",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/testsuite-1.html:13400,energy,energy,13400,psi4manual/1.1.0/testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/testsuite-1.html,4,['energy'],['energy']
Energy Efficiency," in the customary Psi4 driver interface: ``(e/g/h, wfn)``. Parameters; ----------; return_wfn; Whether to additionally return the dummy :py:class:`~psi4.core.Wavefunction`; calculation result as the second element of a tuple. Contents are:. - undisplaced molecule; - compute basis if simple, else dummy basis def2-svp; - e/g/h member data; - QCVariables; - module. Returns; -------; ret; Gradient or Hessian according to self.driver.; wfn; Wavefunction described above when *return_wfn* specified. """"""; findif_model = self.get_results(client=client). ret_ptype = core.Matrix.from_array(findif_model.return_result); wfn = _findif_schema_to_wfn(findif_model). gradient_write(wfn); hessian_write(wfn). if return_wfn:; return (ret_ptype, wfn); else:; return ret_ptype. def _findif_schema_to_wfn(findif_model: AtomicResult) -> core.Wavefunction:; """"""Helper function to produce Wavefunction and Psi4 files from a FiniteDifference-flavored AtomicResult."""""". # new skeleton wavefunction w/mol, highest-SCF basis (just to choose one), & not energy; mol = core.Molecule.from_schema(findif_model.molecule.dict(), nonphysical=True); sbasis = ""def2-svp"" if (findif_model.model.basis == ""(auto)"") else findif_model.model.basis; basis = core.BasisSet.build(mol, ""ORBITAL"", sbasis, quiet=True); wfn = core.Wavefunction(mol, basis); if hasattr(findif_model.provenance, ""module""):; wfn.set_module(findif_model.provenance.module). # setting CURRENT E/G/H on wfn below catches Wfn.energy_, gradient_, hessian_; # setting CURRENT E/G/H on core below is authoritative P::e record; for qcv, val in findif_model.extras[""qcvars""].items():; for obj in [core, wfn]:; obj.set_variable(qcv, val). return wfn. def hessian_write(wfn: core.Wavefunction):; if core.get_option('FINDIF', 'HESSIAN_WRITE'):; filename = core.get_writer_file_prefix(wfn.molecule().name()) + "".hess""; with open(filename, 'wb') as handle:; qcdb.hessparse.to_string(np.asarray(wfn.hessian()), handle, dtype='psi4'). def gradient_write(wfn: core.Wavefunction):",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html:53521,energy,energy,53521,psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,3,['energy'],['energy']
Energy Efficiency," in water:; molecule h2o{; O; H 1 R; H 1 R 2 A; }. Rvals = [0.9, 1.0, 1.1]; Avals = range(102, 106, 2). set basis cc-pvdz; set scf e_convergence=11; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('scf'). The declarations of Rvals and Avals are both completely standard Python syntax.; Having named our molecule h2o we can then set the values of R and A within; the loops. Note that we do not need the dollar sign to access the Python; variable in this example; that is required only when using Python variables; with the set keyword.; Cartesian geometries, because of details of the geometry update process,; need to be specified within the loop(s) along with their basis set when; geometry scans are performed. See scf4 for analogous Z-matrix; and Cartiesian scans. Tables of Results¶; The Psithon function psi4.driver.p4util.Table has been removed,; as the Python ecosystem provides many more flexible alternatives. An; example tabulating a potential energy surface scan for water with Pandas; is shown below:; molecule h2o {; O; H 1 R; H 1 R 2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(100,103,2). rows = []; table = []. set basis cc-pvdz. for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('mp2'); escf = variable('SCF TOTAL ENERGY'); edfmp2 = variable('MP2 TOTAL ENERGY'); escsmp2 = variable('SCS-MP2 TOTAL ENERGY'); rows.append((R, A)); table.append([escf, escsmp2, edfmp2]). import pandas as pd; df = pd.DataFrame(table, columns = [""E(SCF)"", ""E(SCS)"", ""E(DFMP2)""], index=rows); print(df). # E(SCF) E(SCS) E(DFMP2); # (0.9, 100) -76.020680 -76.217006 -76.221189; # (0.9, 102) -76.021305 -76.217439 -76.221605; # (1.0, 100) -76.021264 -76.224987 -76.228727; # (1.0, 102) -76.021460 -76.224946 -76.228668; # (1.1, 100) -75.990195 -76.201891 -76.205087; # (1.1, 102) -75.990085 -76.201498 -76.204676. Python Wrappers¶; The Python foundations of the PSI4 driver and Psithon syntax permit; many commonly performed post-processing procedures to be integrated into; the PSI4 su",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/psithoninput.html:12084,energy,energy,12084,psi4manual/1.7.x/psithoninput.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/psithoninput.html,3,['energy'],['energy']
Energy Efficiency," in-core, but is sufficient to hold at least two copies of an oovv quantity in-core. cc35; CC3(ROHF)/cc-pVDZ H2O geom from Olsen et al., JCP 104, 8007 (1996). omp2-4; SCS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. mp2_5-grad2; MP2.5 cc-pVDZ gradient for the NO radical. cc9a; ROHF-CCSD(T) cc-pVDZ energy for the state of the CN radical, with Z-matrix input. dfmp2-2; Density fitted MP2 energy of H2, using density fitted reference and automatic looping over cc-pVDZ and cc-pVTZ basis sets. Results are tabulated using the built in table functions by using the default options and by specifiying the format. omp2-grad1; OMP2 cc-pVDZ gradient for the H2O molecule. cc1; RHF-CCSD 6-31G** all-electron optimization of the H2O molecule. scf4; RHF cc-pVDZ energy for water, automatically scanning the symmetric stretch and bending coordinates using Python’s built-in loop mechanisms. The geometry is apecified using a Z-matrix with variables that are updated during the potential energy surface scan, and then the same procedure is performed using polar coordinates, converted to Cartesian coordinates. cisd-h2o-clpse; 6-31G** H2O Test CISD Energy Point with subspace collapse. omp2-3; OMP2 cc-pVDZ energy for the NO radical. cepa1; cc-pvdz H2O Test CEPA(1) Energy. cc24; Single point gradient of 1-2B1 state of H2O+ with EOM-CCSD. dftd3-grad; DF-BP86-D2 cc-pVDZ frozen core gradient of S22 HCN, calling Grimme’s dftd3 program for -D2 gradients. cc14; ROHF-CCSD/cc-pVDZ CH2 geometry optimization via analytic gradients. mp3-grad2; MP3 cc-pVDZ gradient for the NO radical. cc29; CCSD/cc-pVDZ optical rotation calculation (both gauges) on Cartesian H2O2. dfscf-bz2; Benzene Dimer DF-HF/cc-pVDZ. psithon1; Spectroscopic constants of H2, and the full ci cc-pVTZ level of theory. ocepa3; OCEPA cc-pVDZ energy with ROHF initial guess for the NO radical. matrix1; An example of using BLAS and LAPACK calls directly from the Psi input file, demonstrating matrix multiplication, eigendecomposition, Cho",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_testsuite-1.html:20016,energy,energy,20016,psi4manual/4.0b4/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_testsuite-1.html,4,['energy'],['energy']
Energy Efficiency," in; database db_name. If no reference is available, this will be a large; and nonsensical value. \[\frac{1}{n}\sum_{rxn}^{n}{| \textsf{\textsl{name}}_{rxn}-\text{REF}_{rxn} | }\]. db_name DATABASE MEAN SIGNED DEVIATION¶; The mean deviation [kcal mol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. \[\frac{1}{n}\sum_{rxn}^{n}{\textsf{\textsl{name}}_{rxn}-\text{REF}_{rxn}}\]. db_name DATABASE ROOT-MEAN-SQUARE DEVIATION¶; The rms deviation [kcal mol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. \[\sqrt{\frac{1}{n}\sum_{rxn}^{n}{(\textsf{\textsl{name}}_{rxn}-\text{REF}_{rxn})^2}}\]. DCT LAMBDA ENERGY¶; An energy term in density cumulant theory [E_h]. This term is the; 2-electron cumulant’s contribution contribution to the reduced; density matrix energy expression. Not recommended for interpretative; use except by reduced density matrix specialists. DCT SCF ENERGY¶; An energy term in density cumulant theory [E_h]. This term is the; 1-electron reduced density matrix (1RDM) contribution to the reduced; density matrix energy expression, plus the contribution of the; antisymmetrized product of 1RDMs. Not recommended for interpretative; use except by reduced density matrix specialists. DCT THREE-PARTICLE ENERGY¶; The three-particle correlation energy correction [E_h] in density cumulant; theory, akin to (T) CORRECTION ENERGY in coupled-cluster. DCT TOTAL ENERGY¶; Total energy [E_h] in density cumulant theory. Sum of DCT SCF ENERGY,; DCT LAMBDA ENERGY, and DCT THREE-PARTICLE ENERGY when present. DETCI AVG DVEC NORM¶; A measure of configuration interaction convergence. DFT FUNCTIONAL TOTAL ENERGY¶; The total electronic energy [E_h] for the underlying functional of the; requested DFT method, with",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html:27147,reduce,reduced,27147,psi4manual/1.7.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html,8,"['energy', 'reduce']","['energy', 'reduced']"
Energy Efficiency," induction-classified correction from MP2 implemented for SAPT2.; Value varies by SAPT level. SAPT0 DISP ENERGY¶. SAPT0 ELST ENERGY¶. SAPT0 EXCH ENERGY¶. SAPT0 IND ENERGY¶. SSAPT0 DISP ENERGY¶. SSAPT0 ELST ENERGY¶. SSAPT0 EXCH ENERGY¶. SSAPT0 IND ENERGY¶. SAPT2 DISP ENERGY¶. SAPT2 ELST ENERGY¶. SAPT2 EXCH ENERGY¶. SAPT2 IND ENERGY¶. SAPT2+ DISP ENERGY¶. SAPT2+ ELST ENERGY¶. SAPT2+ EXCH ENERGY¶. SAPT2+ IND ENERGY¶. SAPT2+(3) DISP ENERGY¶. SAPT2+(3) ELST ENERGY¶. SAPT2+(3) EXCH ENERGY¶. SAPT2+(3) IND ENERGY¶. SAPT2+3 DISP ENERGY¶. SAPT2+3 ELST ENERGY¶. SAPT2+3 EXCH ENERGY¶. SAPT2+3 IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [Eh] for the; given SAPT level of theory. The sum of these four components yields; the SAPT Level TOTAL ENERGY. SAPT0 TOTAL ENERGY¶. SSAPT0 TOTAL ENERGY¶. SAPT2 TOTAL ENERGY¶. SAPT2+ TOTAL ENERGY¶. SAPT2+(3) TOTAL ENERGY¶. SAPT2+3 TOTAL ENERGY¶; The total electronic interaction energy [Eh] for the labeled SAPT level; of theory. SAPT2+(CCD) DISP ENERGY¶. SAPT2+(CCD) ELST ENERGY¶. SAPT2+(CCD) EXCH ENERGY¶. SAPT2+(CCD) IND ENERGY¶. SAPT2+(3)(CCD) DISP ENERGY¶. SAPT2+(3)(CCD) ELST ENERGY¶. SAPT2+(3)(CCD) EXCH ENERGY¶. SAPT2+(3)(CCD) IND ENERGY¶. SAPT2+3(CCD) DISP ENERGY¶. SAPT2+3(CCD) ELST ENERGY¶. SAPT2+3(CCD) EXCH ENERGY¶. SAPT2+3(CCD) IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [Eh] for the; given SAPT level of theory that incorporates coupled-cluster dispersion.; The sum of these four components yields the SAPT Level TOTAL ENERGY. SAPT2+(CCD) TOTAL ENERGY¶. SAPT2+(3)(CCD) TOTAL ENERGY¶. SAPT2+3(CCD) TOTAL ENERGY¶; The total electronic interaction energy [Eh] for the labeled SAPT level; of theory that incorporates coupled-cluster dispersion. SAPT2+DMP2 DISP ENERGY¶. SAPT2+DMP2 ELST ENERGY¶. SAPT2+DMP2 EXCH ENERGY¶. SAPT2+DMP2 IND ENERGY¶. SAPT2+(3)DMP2 DISP ENERGY¶",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html:40019,energy,energy,40019,psi4manual/1.4.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html,5,['energy'],['energy']
Energy Efficiency," inferior energy method for which a fourth delta correction; to the correlation energy is to be obtained. delta5_wfn (string) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a fifth delta correction; to the correlation energy is to be obtained. delta5_wfn_lesser (string) – \(\Rightarrow\) delta4_wfn \(\Leftarrow\) || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a fifth delta correction; to the correlation energy is to be obtained. Basis Sets; Currently, the basis set set through set commands have no influence; on a cbs calculation. Parameters:; scf_basis (basis string) – \(\Rightarrow\) corl_basis \(\Leftarrow\) || 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, scf_basis can default; to corl_basis. corl_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the correlation energy. delta_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. delta2_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. delta3_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the third delta correction; to the correlation energy. delta4_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the fourth delta correction; to the correlation energy. delta5_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the fifth delta correction; to the correlation energy. Schemes; Transfor",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/cbs-1.html:6524,energy,energy,6524,psi4manual/1.2.1/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/cbs-1.html,7,['energy'],['energy']
Energy Efficiency," information from a wavefunction object, and writes it to an FCHK file. write(self: psi4.core.FCHKWriter, filename: str) → None¶; Write wavefunction information to file. class psi4.core.FDDS_Dispersion¶; Bases: pybind11_builtins.pybind11_object; docstring. aux_overlap(self: psi4.core.FDDS_Dispersion) → psi4.core.Matrix¶; Obtains the FDDS aux_overlap. form_unc_amplitude(self: psi4.core.FDDS_Dispersion, arg0: str, arg1: float) → psi4.core.Matrix¶; Forms the uncoupled amplitudes for either monomer. metric(self: psi4.core.FDDS_Dispersion) → psi4.core.Matrix¶; Obtains the FDDS metric. metric_inv(self: psi4.core.FDDS_Dispersion) → psi4.core.Matrix¶; Obtains the FDDS metric_inv. project_densities(self: psi4.core.FDDS_Dispersion, arg0: List[psi4.core.Matrix]) → List[psi4.core.Matrix]¶; Projects a density from the primary AO to auxiliary AO space. class psi4.core.FISAPT¶; Bases: pybind11_builtins.pybind11_object; A Fragment-SAPT Wavefunction. compute_energy(self: psi4.core.FISAPT) → None¶; Computes the FSAPT energy. disp(self: psi4.core.FISAPT, arg0: Dict[str, psi4.core.Matrix], arg1: Dict[str, psi4.core.Vector], arg2: bool) → None¶; Computes the MP2-based DispE20 and Exch-DispE20 energy. scalars(self: psi4.core.FISAPT) → Dict[str, float]¶; Return the interally computed scalars. class psi4.core.FittedSlaterCorrelationFactor¶; Bases: psi4.core.CorrelationFactor; docstring. exponent(self: psi4.core.FittedSlaterCorrelationFactor) → float¶. set_params(self: psi4.core.CorrelationFactor, coeff: psi4.core.Vector, exponent: psi4.core.Vector) → None¶; Set coefficient and exponent. class psi4.core.FittingMetric¶; Bases: pybind11_builtins.pybind11_object; docstring. form_QR_inverse(self: psi4.core.FittingMetric, arg0: float) → None¶; docstring. form_cholesky_inverse(self: psi4.core.FittingMetric) → None¶; docstring. form_eig_inverse(self: psi4.core.FittingMetric, arg0: float) → None¶; docstring. form_fitting_metric(self: psi4.core.FittingMetric) → None¶; docstring. form_full_inverse(sel",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psi4api-1.html:64070,energy,energy,64070,psi4manual/1.2.1/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html,2,['energy'],['energy']
Energy Efficiency," information to output.dat; PsiMod.print_out('\n'); banner('Loading displacement %d of %d' % (n + 1, ndisp)). # Print information to the screen; print(' %d' % (n + 1), end=""""); if (n + 1) == ndisp:; print('\n', end=""""); sys.stdout.flush(). # Load in displacement into the active molecule (xyz coordinates only); molecule.set_geometry(displacement). # Perform the gradient calculation; func(lowername, **kwargs). # Save the gradient; G = PsiMod.get_gradient(); gradients.append(G). # clean may be necessary when changing irreps of displacements; PsiMod.clean(). PsiMod.fd_freq_1(gradients, irrep). print(' Computation complete.'). # Clear the ""parent"" symmetry now; PsiMod.set_parent_symmetry(""""). # TODO: These need to be restored to the user specified setting; PsiMod.get_active_molecule().fix_orientation(False); # But not this one, it always goes back to True; PsiMod.get_active_molecule().reinterpret_coordentry(True). else: # Assume energy points; # If not, perform finite difference of energies; info = 'Performing finite difference calculations by energies'; print(info). # Obtain list of displacements; displacements = PsiMod.fd_geoms_freq_0(irrep); molecule.fix_orientation(True); molecule.reinterpret_coordentry(False); # Make a note of the undisplaced molecule's symmetry; PsiMod.set_parent_symmetry(molecule.schoenflies_symbol()). ndisp = len(displacements). # This version is pretty dependent on the reference geometry being last (as it is now); print(' %d displacements needed.' % ndisp); energies = []; for n, displacement in enumerate(displacements):; # Print information to output.dat; PsiMod.print_out('\n'); banner('Loading displacement %d of %d' % (n + 1, ndisp)). # Print information to the screen; print(' %d' % (n + 1), end=""""); if (n + 1) == ndisp:; print('\n', end=''); sys.stdout.flush(). # Load in displacement into the active molecule; molecule.set_geometry(displacement). # Perform the energy calculation; E = func(lowername, **kwargs). # Save the energy; energies.append",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/driver.html:49807,energy,energy,49807,psi4manual/4.0b3/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/driver.html,1,['energy'],['energy']
Energy Efficiency," input. psimrcc-ccsd_t-3; Mk-MRCCSD(T) single point. \(^1A_1\) CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. cc35; CC3(ROHF)/cc-pVDZ H2O \(R_e\) geom from Olsen et al., JCP 104, 8007 (1996). dfccsd-t-grad1; DF-CCSD(T) cc-pVDZ gradients for the H2O molecule. mints15; check SP basis Fortran exponent parsing. tdscf-5; td-camb3lyp with DiskDF and method/basis specification. dfccsd1; DF-CCSD cc-pVDZ energy for the H2O molecule. fci-tdm; He2+ FCI/cc-pVDZ Transition Dipole Moment. cc7; Tests CCENERGY’s CCSD gradient in the presence of a dipole field. psimrcc-ccsd_t-4; Mk-MRCCSD(T) single point. \(^1A_1\) O$_3` state described using the Ms = 0 component of the singlet. Uses TCSCF orbitals. cc1; RHF-CCSD 6-31G** all-electron optimization of the H2O molecule. dft-vv10; He Dimer VV10 functional test. notes: DFT_VV10_B/C overwrites the NL_DISPERSION_PARAMETERS tuple updated ‘bench’ reference values for new BraggSlater radii. dfccsdat1; DF-CCSD(AT) cc-pVDZ energy for the H2O molecule. psimrcc-fd-freq2; Mk-MRCCSD frequencies. \(^1A_1\) O$_3` state described using the Ms = 0 component of the singlet. Uses TCSCF orbitals. sapt-exch-disp-inf; SAPT0 with S^inf exch-disp20. dfmp2-grad5; Tests DF-MP2 gradient in the presence of a dipole field. cbs-xtpl-func; optimization with method defined via cbs. mp2-def2; Test case for Binding Energy of C4H5N (Pyrrole) with CO2 using MP2/def2-TZVPP. opt3; SCF cc-pVDZ geometry optimzation, with Z-matrix input. omp2-2; OMP2 cc-pVDZ energy with ROHF initial guess orbitals for the NO radical. mints-helper; A general test of the MintsHelper function. cc8a; ROHF-CCSD(T) cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Cartesian input. scf7; Tests SCF gradient in the presence of a dipole field. cc13c; Tests RHF CCSD(T)gradients. dft-grad-disk; A range-seperated gradient for SO2 to test disk algorithms by explicitly setting low memory. cc26; Single-point gradient, analytic and via f",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html:24563,energy,energy,24563,psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency," instance.PYmove_to_com = not no_com; instance.PYfix_orientation = no_reorient. if contentsNotFilename:; text = xyzfilename.splitlines(); else:; try:; infile = open(xyzfilename, 'r'); except IOError:; raise ValidationError(; """"""Molecule::init_with_mol2: given filename '%s' does not exist."""""" % (xyzfilename)); if os.stat(xyzfilename).st_size == 0:; raise ValidationError(""""""Molecule::init_with_mol2: given filename '%s' is blank."""""" % (xyzfilename)); text = infile.readlines(). # fixed-width regex ((?=[ ]*-?\d+)[ -\d]{5}); v2000 = re.compile(r'^((?=[ ]*\d+)[ \d]{3})((?=[ ]*\d+)[ \d]{3})(.*)V2000\s*$'); vend = re.compile(r'^\s*M\s+END\s*$'); NUMBER = ""((?:[-+]?\\d*\\.\\d+(?:[DdEe][-+]?\\d+)?)|(?:[-+]?\\d+\\.\\d*(?:[DdEe][-+]?\\d+)?))""; xyzM = re.compile(; r'^(?:\s*)' + NUMBER + r'(?:\s+)' + NUMBER + r'(?:\s+)' + NUMBER + r'(?:\s+)([A-Z](?:[a-z])?)(?:\s+)(.*)',; re.IGNORECASE). ## now charge and multiplicity; # $chargem = 0 ; $multm = 1 ;; #while (<MOL>) {; #if (/CHARGE/) { $chargem = <MOL> ; chop($chargem) ;}; #if (/MULTIPLICITY/) { $multm = <MOL> ; chop($multm) }; # } # end while charge and multiplicity. if not text:; raise ValidationError(""Molecule::init_with_mol2: file blank""); # Try to match header/footer; if vend.match(text[-1]):; pass; else:; raise ValidationError(""Molecule::init_with_mol2: Malformed file termination\n%s"" % (text[-1])); sysname = '_'.join(text[0].strip().split()); comment = text[2].strip(); if comment:; instance.tagline = sysname + ' ' + comment; else:; instance.tagline = sysname; #instance.tagline = text[0].strip() + ' ' + text[2].strip(); fileUnits = 'Angstrom' # defined for MOL; #instance.set_molecular_charge(int(xyz2.match(text[1]).group(1))); #instance.set_multiplicity(int(xyz2.match(text[1]).group(2))); if v2000.match(text[3]):; fileNatom = int(v2000.match(text[3]).group(1)); fileNbond = int(v2000.match(text[3]).group(2)); else:; raise ValidationError(""Molecule::init_with_mol2: Malformed fourth line\n%s"" % (text[3])); if fileNatom < 1:; raise ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/qcdb/molecule.html:7083,charge,charge,7083,psi4manual/1.3.2/_modules/psi4/driver/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/qcdb/molecule.html,40,['charge'],"['charge', 'chargem']"
Energy Efficiency," integer; Default: 100. MCSCF_ALGORITHM (DETCI); DETCI — Convergence algorithm to utilize. Two-Step, Augmented Hessian, or One-Step. Defaults to TS for RASSCF. Type: string; Possible Values: TS, AH; Default: TS. MCSCF_CI_CLEANUP (DETCI); DETCI — Cleanup the CI info at the end of a run?. Type: boolean; Default: true. MCSCF_DIIS_ERROR_TYPE (DETCI); DETCI — DIIS error vector type either, the AO orbital gradient or the orbital rotation update matrix. Type: string; Possible Values: GRAD, UPDATE; Default: GRAD. MCSCF_DIIS_FREQ (DETCI); DETCI — How often to do a DIIS extrapolation for TS convergence. Type: integer; Default: 1. MCSCF_DIIS_MAX_VECS (DETCI); DETCI — Maximum number of DIIS vectors for TS convergence. Type: integer; Default: 8. MCSCF_DIIS_START (DETCI); DETCI — Iteration to turn on DIIS for TS convergence. Type: integer; Default: 3. MCSCF_DPD_CLEANUP (DETCI); DETCI — Cleanup the DPD MCSCF object at the end of a run?. Type: boolean; Default: true. MCSCF_E_CONVERGENCE (DETCI); DETCI — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-7. MCSCF_GUESS (DETCI); DETCI — Initial MCSCF starting guess, MP2 natural orbitals only available for DF-RHF reference. Type: string; Possible Values: MP2, SCF; Default: SCF. MCSCF_MAX_ROT (DETCI); DETCI — Maximum value in the rotation matrix. If a value is greater than this number all values are scaled. Type: double; Default: 0.5. MCSCF_MAXITER (DETCI); DETCI — Maximum number MCSCF of iterations. Type: integer; Default: 30. MCSCF_R_CONVERGENCE (DETCI); DETCI — Convergence criterion for the RMS of the orbital gradient. Type: conv double; Default: 1e-5. MCSCF_ROTATE (DETCI); DETCI — Apply a list of 2x2 rotation matrices to the orbitals in the form of [irrep, orbital1, orbital2, theta] where an angle of 0 would do nothing and an angle of 90 would switch the two orbitals. Type: array; Default: No Default. MCSCF_SO_START_E (DETC",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodoc_glossary_options_c-1.html:159801,energy,energy,159801,psi4manual/1.3.2/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodoc_glossary_options_c-1.html,2,['energy'],['energy']
Energy Efficiency," integrals; #if 'cp' in bsse_type_list and (len(bsse_type_list) == 1):; # # Set to save RI integrals for repeated full-basis computations; # ri_ints_io = core.get_global_option('DF_INTS_IO'). # # inquire if above at all applies to dfmp2 or just scf; # core.set_global_option('DF_INTS_IO', 'SAVE'); # psioh = core.IOManager.shared_object(); # psioh.set_specific_retention(97, True). bsse_str = metadata['bsse_type_list'][0]; if len(metadata['bsse_type_list']) > 1:; bsse_str = str(metadata['bsse_type_list']); core.print_out(""\n\n""); core.print_out("" ===> N-Body Interaction Abacus <===\n""); core.print_out("" BSSE Treatment: %s\n"" % bsse_str). # Get compute list; metadata = build_nbody_compute_list(metadata). # Compute N-Body components; component_results = compute_nbody_components(func, method_string, metadata). # Assemble N-Body quantities; nbody_results = assemble_nbody_components(metadata, component_results). # Figure out returns; if metadata['ptype'] != 'energy':; if metadata['return_total_data']:; np_final_ptype = nbody_results['ptype_body_dict'][metadata['max_nbody']].copy(); else:; np_final_ptype = nbody_results['ptype_body_dict'][metadata['max_nbody']].copy(); np_final_ptype -= ptype_body_dict[1]. nbody_results['ret_ptype'] = core.Matrix.from_array(np_final_ptype); else:; nbody_results['ret_ptype'] = nbody_results['ret_energy']. # Build wfn and bind variables; wfn = core.Wavefunction.build(metadata['molecule'], 'def2-svp'); dicts = ['energies', 'ptype', 'intermediates', 'energy_body_dict', 'ptype_body_dict', 'nbody']; for r in [component_results, nbody_results]:; for d in r:; if d in dicts:; for var, value in r[d].items():; wfn.set_variable(str(var), value); core.set_variable(str(var), value). if metadata['ptype'] == 'gradient':; wfn.set_gradient(ret_ptype); elif metadata['ptype'] == 'hessian':; wfn.set_hessian(ret_ptype). core.set_variable(""CURRENT ENERGY"", nbody_results['ret_energy']); wfn.set_variable(""CURRENT ENERGY"", nbody_results['ret_energy']). if metadata['r",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_nbody.html:8020,energy,energy,8020,psi4manual/1.2.1/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_nbody.html,1,['energy'],['energy']
Energy Efficiency," interaction and arbitrary order MP in particular.; No scheme defaults for given basis zeta number, so scheme must be specified explicitly.; No way to tell function to boost fitting basis size for all calculations.; No way to extrapolate def2 family basis sets; Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in several; sequential stages (scf, corl, delta, delta2, delta3, delta4, delta5) covering treatment; of the reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction, etc.. Each is activated by its; stage_wfn keyword and is only allowed if all preceding stages are active. Here, is an energy or energy extrapolation scheme, and the following also hold. A translation of this ungainly equation to example [5] below is as; follows. In words, this is a double- and triple-zeta 2-point; Helgaker-extrapolated CCSD(T) coupled-cluster correlation correction; appended to a triple- and quadruple-zeta 2-point; Helgaker-extrapolated MP2 correlation energy appended to a SCF/aug-cc-pVQZ; reference energy. Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy.; The cbs() function requires, at a minimum, name='scf' and scf_basis; keywords to be specified for reference-step only jobs and name and; corl_basis keywords for correlated jobs.; The following energy methods have been set up for cbs(). scf; mp2; mp2.5; mp3; mp4(sdq); mp4; omp2. omp3; ocepa; cepa0; cepa(0); cepa(1); cepa(3); acpf. aqcc; qcisd; cc2; ccsd; fno-df-ccsd; bccd; cc3. qcisd(t); ccsd(t); fno-df-ccsd(t); bccd(t); cisd; cisdt; cisdtq. cin; fci; mrccsd; mrccsd(t); mrccsdt; mrccsdt(q). Parameters:; name (string) – 'scf' || 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/cbs-1.html:2269,energy,energy,2269,psi4manual/4.0b5/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/cbs-1.html,4,['energy'],['energy']
Energy Efficiency," irrep (in Cotton order) so a user can specify the number of retained natural orbitals rather than determining them with OCC_TOLERANCE. This keyword overrides OCC_TOLERANCE and OCC_PERCENTAGE. Type: array; Default: No Default. ADD_AUXILIARY_BONDS (OPTKING)¶OPTKING — Do add bond coordinates at nearby atoms for non-bonded systems?. Type: boolean; Default: true. AEL (CCDENSITY)¶CCDENSITY (Expert) — Do compute the approximate excitation level? See Stanton and Bartlett, JCP, 98, 1993, 7034. Type: boolean; Default: false. AIO_CPHF (SAPT)¶SAPT — Do use asynchronous disk I/O in the solution of the CPHF equations? Use may speed up the computation slightly at the cost of spawning an additional thread. Type: boolean; Default: false. AIO_DF_INTS (SAPT)¶SAPT — Do use asynchronous disk I/O in the formation of the DF integrals? Use may speed up the computation slightly at the cost of spawning an additional thread. Type: boolean; Default: false. ALGORITHM (DCT)¶DCT — Algorithm to use for the density cumulant and orbital updates in the DCT energy computation. Two-step algorithm is usually more efficient for small systems, but for large systems simultaneous algorithm (default) is recommended. If convergence problems are encountered (especially for highly symmetric systems) QC algorithm can be used. Type: string; Possible Values: TWOSTEP, SIMULTANEOUS, QC; Default: SIMULTANEOUS. ANALYZE (CCENERGY)¶CCENERGY — Do analyze T2 amplitudes. Type: boolean; Default: false. ANALYZE (CCRESPONSE)¶CCRESPONSE — Do analyze X2 amplitudes. Type: boolean; Default: false. AO_BASIS (CCDENSITY)¶CCDENSITY — The algorithm to use for the \(\left\langle VV||VV\right \rangle\) terms. Type: string; Possible Values: NONE, DISK, DIRECT; Default: NONE. AO_BASIS (CCENERGY)¶CCENERGY (Expert) — The algorithm to use for the \(\left\langle VV||VV\right\rangle\) terms If AO_BASIS is NONE, the MO-basis integrals will be used; if AO_BASIS is DISK, the AO-basis integrals stored on disk will be used; if AO_BASIS is DIRECT, t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:2008,energy,energy,2008,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,5,['energy'],['energy']
Energy Efficiency," irrep i. CCname ROOT m (h) -> ROOT n (i) EINSTEIN A (LEN)¶; The Einstein A coefficient, the spontaneous emission ‘probability.’; Units are in [1/s].; Describes the transition between roots m and n, which are in irreps h and i, respectively.. CCname ROOT m -> ROOT n EINSTEIN A (LEN) - h TRANSITION¶; The Einstein A coefficient, the spontaneous emission ‘probability.’; Units are in [1/s].; Describes the irrep h transition between roots m and n. CCname ROOT m -> ROOT n EINSTEIN B (LEN)¶; The Einstein B coefficient, the stimulated emission ‘probability’; in terms of energy density. Units are in [m^3 / J / s^2].; Describes the transition between roots m and n. CCname ROOT m (IN h) -> ROOT n (IN i) EINSTEIN B (LEN)¶; The Einstein B coefficient, the stimulated emission ‘probability’; in terms of energy density. Units are in [m^3 / J / s^2].; Describes the transition between root m within irrep h and root n which irrep i. CCname ROOT m (h) -> ROOT n (i) EINSTEIN B (LEN)¶; The Einstein B coefficient, the stimulated emission ‘probability’; in terms of energy density. Units are in [m^3 / J / s^2].; Describes the transition between roots m and n, which are in irreps h and i, respectively.. CCname ROOT m -> ROOT n EINSTEIN B (LEN) - h TRANSITION¶; The Einstein B coefficient, the stimulated emission ‘probability’; in terms of energy density. Units are in [m^3 / J / s^2].; Describes the irrep h transition between roots m and n. CCname ROOT m -> ROOT n ROTATORY STRENGTH (LEN)¶. TD-fctl ROOT 0 -> ROOT n ROTATORY STRENGTH (LEN)¶; The length-gauge rotatory strength of the transition from root m to root n.; DFT functional labeled if canonical. CCname ROOT m (IN h) -> ROOT n (IN i) ROTATORY STRENGTH (LEN)¶. TD-fctl ROOT 0 (IN h) -> ROOT n (IN i) ROTATORY STRENGTH (LEN)¶; The length-gauge oscillator strength of the transition from root m within irrep h; to root n within irrep i.; DFT functional labeled if canonical. CCname ROOT m (h) -> ROOT n (i) ROTATORY STRENGTH (LEN)¶. TD-fctl ROOT 0",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/glossary_psivariables.html:12766,energy,energy,12766,psi4manual/1.6.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/glossary_psivariables.html,5,['energy'],['energy']
Energy Efficiency," irrep. efzc(self: psi4.core.Wavefunction) → float¶; Returns the frozen-core energy. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunction’s energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Beta Eigenvalues subset. esp_at_nuclei(self: psi4.core.Wavefunction) → psi4.core.Vector¶; returns electrostatic potentials at nuclei. finalize(self: psi4.core.HF) → None; Cleans up the the Wavefunction’s temporary data. finalize_energy(); Performs stability analysis and calls back SCF with new guess; if needed, Returns the SCF energy. This function should be called; once orbitals are ready for energy/property computations, usually; after iterations() is called. find_occupation(self: psi4.core.HF) → None; docstring. force_doccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use only. Sets the number of doubly occupied oribtals per irrep. Note that this results in inconsistent Wavefunction objects for SCF, so caution is advised. force_soccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use only. Sets the number of singly occupied oribtals per irrep. Note that this results in inconsistent Wavefunction objects for SCF, so caution is advised. form_C(self: psi4.core.HF) → None; Forms the Orbital Matrices from the current Fock Matrices. form_D(self: psi4.core.HF) → None; Forms the Density Matrices from the current Orbitals Matrices. form_F(self: psi4.core.HF) → None; Forms the F matrix. form_G(self: psi4.core.HF) → None; Forms the G matrix. form_H(self: psi4.core.HF) → None; Forms the core Hamiltonian. form_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.hf.html:16187,energy,energy,16187,psi4manual/1.3.2/api/psi4.core.hf.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.hf.html,1,['energy'],['energy']
Energy Efficiency," is None:; raise ValidationError(""""""Frequency execution mode 'reap' requires a linkage option.""""""); else:; raise ValidationError(""""""Frequency execution mode '%s' not valid."""""" % (freq_mode)). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash_conv = driver_util._set_convergence_criterion('energy', lowername, 8, 10, 8, 10, 8). # Select certain irreps; irrep = kwargs.get('irrep', -1); if irrep == -1:; pass # do all irreps; else:; irrep = driver_util.parse_cotton_irreps(irrep, molecule.schoenflies_symbol()); irrep -= 1 # A1 irrep is externally 1, internally 0. # Does an analytic procedure exist for the requested method?; if dertype == 2:; psi4.print_out(""""""hessian() will perform analytic frequency computation.\n""""""). # We have the desired method. Do it.; wfn = procedures['hessian'][lowername](lowername, molecule=molecule, **kwargs); optstash.restore(); optstash_conv.restore(). # TODO: check that current energy's being set to the right figure when this code is actually used; psi4.set_variable('CURRENT ENERGY', wfn.energy()). if return_wfn:; return (wfn.hessian(), wfn); else:; return wfn.hessian(). elif dertype == 1:; psi4.print_out(""""""hessian() will perform frequency computation by finite difference of analytic gradients.\n""""""). # Shifting the geometry so need to copy the active molecule; moleculeclone = molecule.clone(). # Obtain list of displacements; displacements = psi4.fd_geoms_freq_1(moleculeclone, irrep); moleculeclone.reinterpret_coordentry(False); moleculeclone.fix_orientation(True). # Record undisplaced symmetry for projection of diplaced point groups; psi4.set_parent_symmetry(molecule.schoenflies_symbol()). ndisp = len(displacements); print("""""" %d displacements needed."""""" % ndisp); gradients = []; energies = []. # S/R: Write instructions for sow/reap procedure to output file and reap input file; if freq_mode == 'sow':; instructionsO = """"""\n# The frequency sow/reap procedure has been selected through",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver.html:65448,energy,energy,65448,psi4manual/1.0.0/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver.html,1,['energy'],['energy']
Energy Efficiency," is a light wrapper over; hessian() that computes the Hessian then adds a; thermochemical analysis. psi4.frequency(name[, molecule, return_wfn, func, mode, dertype, irrep])[source]¶; Function to compute harmonic vibrational frequencies. Aliases:frequencies(), freq(). Returns:float – Total electronic energy in Hartrees. Returns:(float, Wavefunction) – energy and wavefunction when return_wfn specified. Parameters:; name (string) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype) – \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- they’re not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or string) – \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF. For all other methods, Frequencies will; proceed through finite differences accordin",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/freq-1.html:1586,energy,energy,1586,psi4manual/1.3.2/freq-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/freq-1.html,2,['energy'],['energy']
Energy Efficiency," is a light wrapper over; hessian() that computes the Hessian then adds a; thermochemical analysis. psi4.frequency(name[, molecule, return_wfn, func, mode, dertype, irrep])[source]¶; Function to compute harmonic vibrational frequencies. Aliases:frequencies(), freq(). Returns:float – Total electronic energy in Hartrees. Returns:(float, Wavefunction) – energy and wavefunction when return_wfn specified. Parameters:; name (string) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. mode (string) – \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies or gradients frequency, indicates; whether the calculations required to complete the frequency are to be run; in one file ('continuous') or are to be farmed out in an; embarrassingly parallel fashion ('sow'/'reap')/ For the latter,; run an initial job with 'sow' and follow instructions in its output file.; For maximum flexibility, return_wfn is always on in 'reap' mode. dertype (dertype) – \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- they’re not), finite; difference of gradients (if available) or finite",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/freq-1.html:1584,energy,energy,1584,psi4manual/1.1.0/freq-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/freq-1.html,4,['energy'],['energy']
Energy Efficiency," is not recognized '%s'."" % type(valueLO)). def scf_xtpl_karton_2(functionname, zLO, valueLO, zHI, valueHI, verbose=True, alpha=None):; r""""""Extrapolation scheme using root-power form for reference energies with two adjacent zeta-level bases.; Used by :py:func:`~psi4.cbs`.; Karton, Martin, Theor. Chem. Acc. 115 (2006) 330-333, DOI: 10.1007/s00214-005-0028-6. .. math:: E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha\sqrt{X}}, \alpha = 6.3. """""". if type(valueLO) != type(valueHI):; raise ValidationError(""scf_xtpl_karton_2: Inputs must be of the same datatype! (%s, %s)""; % (type(valueLO), type(valueHI))). if alpha is None:; alpha = 6.30. beta_division = 1 / (math.exp(-1 * alpha) * (math.exp(math.sqrt(zHI)) - math.exp(math.sqrt(zLO)))); beta_mult = math.exp(-1 * alpha * math.sqrt(zHI)). if isinstance(valueLO, float):; beta = (valueHI - valueLO) * beta_division; value = valueHI - beta * beta_mult. if verbose:; # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> Karton 2-point power form SCF extrapolation for method: %s <==\n\n"""""" % (functionname.upper()); cbsscheme += """""" LO-zeta (%s) Energy: % 16.12f\n"""""" % (str(zLO), valueLO); cbsscheme += """""" HI-zeta (%s) Energy: % 16.12f\n"""""" % (str(zHI), valueHI); cbsscheme += """""" Alpha (exponent) Value: % 16.12f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: % 16.12f\n\n"""""" % (beta). name_str = ""%s/(%s,%s)"" % (functionname.upper(), zeta_val2sym[zLO].upper(), zeta_val2sym[zHI].upper()); cbsscheme += """""" @Extrapolated """"""; cbsscheme += name_str + ':'; cbsscheme += "" "" * (18 - len(name_str)); cbsscheme += """"""% 16.12f\n\n"""""" % value; core.print_out(cbsscheme). return value. elif isinstance(valueLO, (core.Matrix, core.Vector)):; beta = valueHI.clone(); beta.name = 'Karton SCF (%s, %s) beta' % (zLO, zHI); beta.subtract(valueLO); beta.scale(beta_division); beta.scale(beta_mult). value = valueHI.clone(); value.subtract(beta); value.name = 'Karton SCF (%s, %s) data' % (zLO, zHI). if verbose > ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html:12165,power,power,12165,psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html,1,['power'],['power']
Energy Efficiency," is to be obtained. delta_wfn_lesser (string) – corl_wfn || 'mp2' || etc.; Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. delta2_wfn (string) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. delta2_wfn_lesser (string) – delta_wfn || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. delta3_wfn (string) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a third delta correction; to the correlation energy is to be obtained. delta3_wfn_lesser (string) – delta2_wfn || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a third delta correction; to the correlation energy is to be obtained. delta4_wfn (string) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a fourth delta correction; to the correlation energy is to be obtained. delta4_wfn_lesser (string) – delta3_wfn || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a fourth delta correction; to the correlation energy is to be obtained. delta5_wfn (string) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a fifth delta correction; to the correlation energy is to be obtained. delta5_wfn_lesser (string) – delta4_wfn || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a fifth delta correction; to the correlation energy is to be obtained. Basis Sets; Currently, the basis set set through set commands have no influence; on a cbs calculation. Parameters:; scf_basis (basis string) – corl_basis || 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, scf_basis can default; to corl_basis. corl_basis (basis string) – 'cc-pV[TQ]Z' ||",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/cbs-1.html:4708,energy,energy,4708,psi4manual/1.0.0/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/cbs-1.html,4,['energy'],['energy']
Energy Efficiency," it by keyword argument to the calculation.; The successor to the psi4.driver.QMMM class,; psi4.driver.QMMMbohr, is operable, but it is discouraged; from being used directly. To run a computation in a constant dipole field, the PERTURB_H,; PERTURB_WITH and PERTURB_DIPOLE keywords can be used. As an; example, to add a dipole field of magnitude 0.05 a.u. in the y direction and; 0.1 a.u. in the z direction, we can use the following keywords:; set perturb_h true; set perturb_with dipole; set perturb_dipole [ 0, 0.05, 0.1 ]. Note that if any specified fields do not fall along a symmetry axis, the; symmetry of the calculation should be reduced accordingly; if in doubt run the; calculation in C1 symmetry. For examples of SCF and MP2 calculations in an; external field, see scf7 and dfmp2-grad5. Convergence and Algorithm Defaults¶. SCF algorithm and convergence criteria defaults by calculation type 1¶. Ab Initio Method; Calculation Type; E_CONVERGENCE; D_CONVERGENCE; SCF_TYPE. SCF of HF or DFT; energy; 6; 6; DF. optimization; 8; 8. frequency 7; 8; 8. SCF of post-HF; energy; 8; 8; PK 3. optimization; 10; 10. frequency 7; 10; 10. CC property 2; 10; 10. Post-SCF convergence criteria defaults by calculation type 4¶. Ab Initio Method; Calculation Type; E_CONVERGENCE 5; R_CONVERGENCE 6. post-HF of post-HF; energy; 6. optimization; 8. frequency 7; 8. CC property 2; 8. Footnotes. 1; Note that this table applies only the SCF module,; not to the final convergence criteria for post-HF methods or to methods; that use an alternate starting point, like MCSCF. SAPT computations, too,; set tighter values. 2(1,2); This applies to properties computed through the properties() function. 3; Post-HF methods that do not rely upon the usual 4-index AO integrals use a; density-fitted SCF reference. That is, for DF-MP2 and SAPT, the default SCF_TYPE is DF. 4; Note that this table applies to the final convergence criteria for; all the post-SCF modules that define a E_CONVERGENCE keyword. 5; The E_CONV",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/scf.html:46712,energy,energy,46712,psi4manual/1.6.x/scf.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/scf.html,1,['energy'],['energy']
Energy Efficiency," it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with functions that call upon those in modules; :py:mod:`proc`, :py:mod:`driver`, and :py:mod:`wrappers`. Place in this file quickly defined procedures such as; - aliases for complex methods; - simple modifications to existing methods. """"""; import os; import re; import math; import warnings. from psi4.driver import driver_cbs. # Python procedures like these can be run directly from the input file or integrated; # with the energy(), etc. routines by means of lines like those at the end; # of this file. def fake_file11(wfn, filename='fake_file11.dat', **kwargs):; r""""""Function to print a file *filename* of the old file11 format; from molecule and gradient information in *wfn*. .. versionadded:: 0.6; *wfn* parameter passed explicitly. :returns: None. :type filename: string; :param filename: destination file name for file11 file. :type wfn: :py:class:`~psi4.core.Wavefunction`; :param wfn: set of molecule, gradient from which to generate file11. :examples:. >>> # [1] file11 for CISD calculation; >>> G, wfn = gradient('cisd', return_wfn=True); >>> fake_file11(wfn, 'mycalc.11'). """"""; molecule = wfn.molecule(); molecule.update_geometry(); gradient = wfn.gradient(). with open(filename, 'w') as handle:; handle.write('%d\n' % (molecule.natom())). for at in range(molecule.natom()):; handle.write('%6s %16.8f %16.8f %16.8f\n' % (molecule.symbol(; at), molecule.x(at), molecule.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/aliases.html:1509,energy,energy,1509,psi4manual/1.3.2/_modules/psi4/driver/aliases.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/aliases.html,1,['energy'],['energy']
Energy Efficiency," it. Basis set and auxiliary basis sets are assigned by atom type. cfour/sp-rhf-ccsd_t_-fc; single-point CCSD(T)/qz2p on water with ecc, aobasis, and frozen-core. cfour/scf4; RHF cc-pVDZ energy for water, automatically scanning the symmetric stretch and bending coordinates using Python’s built-in loop mechanisms. The geometry is apecified using a Z-matrix with variables that are updated during the potential energy surface scan, and then the same procedure is performed using polar coordinates, converted to Cartesian coordinates. cfour/sp-rhf-cc3; single-point CC3/qz2p on water. cfour/kw-5; Basis set spherical/Cartesian with basis and cfour_spherical. cfour/sp-uhf-ccsd_t_; single-point CCSD(T)/qz2p. cfour/sp-rhf-ccsd-ao; single-point CCSD/qz2p on water with aobasis. cfour/kw-2; testing best practices options, part ii. cfour/sp-rohf-ccsd_t_; single-point CCSD(T)/qz2p on NH2. cfour/mints5; geometries from a variety of input formats. references from psi4, testing whether geometry strings read identically for psi4/cfour. cfour/sp-rohf-scf; single-point HF/qz2p on NH2. cfour/opt-rhf-ccsd_t_; optimization CCSD(T)/dzp on water. cfour/sp-uhf-cc3; single-point CC3/qz2p on NH2. cfour/psi-rhf-scsmp2; MP2 energy components. Checks that computed identically between cfour and psi4. cfour/psi-ghost-grad; MP2 optimization of dimers with one momomer ghosted. Gradients after three opt cycles are compared with those from psi4. cfour/kw-6; Basis set spherical/Cartesian with cfour_basis and puream. cfour/psi-uhf-scsmp2; UHF MP2 energy components. Checks that computed identically between cfour and psi4. cfour/sp-rohf-mp4-sc; single-point MP4/qz2p on NH2. cfour/sp-rhf-ccsd_t_-ecc; single-point CCSD(T)/qz2p on water with ecc module. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Appendices; Test Suite and Sample Inputs. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_cfour-1.html:4468,energy,energy,4468,psi4manual/1.3.2/autodoc_testsuite_cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_cfour-1.html,4,['energy'],['energy']
Energy Efficiency," iterations between least-squares extrapolations. Type: integer; Default: 3. LSE_TOLERANCE (DETCI)¶DETCI — Minimum converged energy for least-squares extrapolation to be performed. Type: conv double; Default: 3. MADMP2_SLEEP (DFMP2)¶DFMP2 (Expert) — A helpful option, used only in debugging the MADNESS version. Type: integer; Default: 0. MAT_NUM_COLUMN_PRINT (GLOBALS)¶GLOBALS (Expert) — Number of columns to print in calls to Matrix::print_mat. Type: integer; Default: 5. MAX_ATTEMPTS (SCF)¶SCF (Expert) — When using STABILITY_ANALYSIS FOLLOW, maximum number of orbital optimization attempts to make the wavefunction stable. Type: integer; Default: 1. MAX_CCD_DIISVECS (SAPT)¶SAPT — Maximum number of vectors used in CCD-DIIS. Type: integer; Default: 10. MAX_DISP_G_CONVERGENCE (OPTKING)¶OPTKING — Convergence criterion for geometry optmization: maximum displacement (internal coordinates, atomic units). Type: conv double; Default: 1.2e-3. MAX_ENERGY_G_CONVERGENCE (OPTKING)¶OPTKING — Convergence criterion for geometry optmization: maximum energy change. Type: conv double; Default: 1.0e-6. MAX_FORCE_G_CONVERGENCE (OPTKING)¶OPTKING — Convergence criterion for geometry optmization: maximum force (internal coordinates, atomic units). Type: conv double; Default: 3.0e-4. MAX_MEM_BUF (SCF)¶SCF — Max memory per buf for PK algo REORDER, for debug and tuning. Type: integer; Default: 0. MAX_MOGRAD_CONVERGENCE (DFOCC)¶DFOCC — Convergence criterion for maximum orbital gradient. If this keyword is not set by the user, DFOCC will estimate and use a value required to achieve the desired E_CONVERGENCE. The listed default will be used for the default value of E_CONVERGENCE. Type: conv double; Default: 1e-4. MAX_MOGRAD_CONVERGENCE (OCC)¶OCC — Convergence criterion for maximum orbital gradient. If this keyword is not set by the user, OCC will estimate and use a value required to achieve the desired E_CONVERGENCE. The listed default will be used for the default value of E_CONVERGENCE. Type: conv d",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:159389,energy,energy,159389,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,9,['energy'],['energy']
Energy Efficiency," its output file. cp (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicates whether counterpoise correction is employed in computing; interaction energies. Use this option and NOT the cp(); function for BSSE correction in database(). Option available; (See Available Databases) only for databases of bimolecular complexes. rlxd (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicates whether correction for deformation energy is; employed in computing interaction energies. Option available; (See Available Databases) only for databases of bimolecular complexes; with non-frozen monomers, e.g., HBC6. symm (boolean) – \(\Rightarrow\) 'on' \(\Leftarrow\) || 'off'; Indicates whether the native symmetry of the database reagents is; employed ('on') or whether it is forced to \(C_1\) symmetry; ('off'). Some computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). zpe (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. benchmark (string) – \(\Rightarrow\) 'default' \(\Leftarrow\) || 'S22A' || etc.; Indicates whether a non-default set of reference energies, if; available (See Available Databases), are employed for the; calculation of error statistics. tabulate (array of strings) – \(\Rightarrow\) [] \(\Leftarrow\) || ['scf total energy', 'natom'] || etc.; Indicates whether to form tables of variables other than the; primary requested energy. Available for any PSI variable. subset (string or array of strings) – Indicates a subset of the full database to run. This is a very; flexible option and can be used in three distinct ways, outlined; below. Note that two take a string and the last takes an array.; See Available Databases for available values. 'small' || 'large' || 'equilibrium'; Calls predefined subsets of the requested database, eith",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/db-1.html:3565,energy,energy,3565,psi4manual/1.2.1/db-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/db-1.html,12,['energy'],['energy']
Energy Efficiency," keyword argument, e.g., `energy(..., external_potentials=[[0.5, [0, 0, 1]], [-0.5, [0, 0, -1]]])`.'). [docs]; class QMMMbohr():; """"""Hold charges and :py:class:`psi4.core.ExternalPotential`. To add external charges to a calculation, prefer; passing the array of charges with kwarg ``external_potentials``, as in extern2 example."""""". def __init__(self):; self.charges = []; self.diffuses = []; self.extern = core.ExternalPotential(). [docs]; def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs]; def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs]; def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / constants.bohr2angstroms, y / constants.bohr2angstroms, z / constants.bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs]; def populateExtern(self):; """"""Function to define a charge field external to the; molecule through point and diffuse charges. """"""; # Charges; for charge in self.charges:; self.extern.addCharge(charge[0], charge[1], charge[2], charge[3]); # Diffuses; for diffuse in self.diffuses:; diffuse.populateExtern(self.extern). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.8.2;  · . PSI4. Module code; psi4.driver.qmmm. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:04AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qmmm.html:4904,charge,charges,4904,psi4manual/1.8.x/_modules/psi4/driver/qmmm.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qmmm.html,13,['charge'],"['charge', 'charges']"
Energy Efficiency," keyword argument, e.g., `energy(..., external_potentials=[[0.5, [0, 0, 1]], [-0.5, [0, 0, -1]]])`.'). [docs]; class QMMMbohr():; """"""Hold charges and :py:class:`psi4.core.ExternalPotential`. To add external charges to a calculation, prefer; passing the array of charges with kwarg ``external_potentials``, as in extern2 example."""""". def __init__(self):; self.charges = []; self.diffuses = []; self.extern = core.ExternalPotential(). [docs]; def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs]; def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs]; def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / constants.bohr2angstroms, y / constants.bohr2angstroms, z / constants.bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs]; def populateExtern(self):; """"""Function to define a charge field external to the; molecule through point and diffuse charges. """"""; # Charges; for charge in self.charges:; self.extern.addCharge(charge[0], charge[1], charge[2], charge[3]); # Diffuses; for diffuse in self.diffuses:; diffuse.populateExtern(self.extern). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.9.1;  · . PSI4. Module code; psi4.driver.qmmm. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/qmmm.html:4969,charge,charges,4969,psi4manual/1.9.x/_modules/psi4/driver/qmmm.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/qmmm.html,13,['charge'],"['charge', 'charges']"
Energy Efficiency," keyword translation only takes place; if the keywords are explicitly set in the input file (part of that; contract that you mean it), meaning that Psi4‘s defaults don’t; get imposed on Cfour. Also, in the case where a translatable pure-Psi4 keyword and its translation Cfour keyword are both set,; the value attached to the latter is always used. Below are a few; clarifying examples. uses SCF conv crit since that’s Cfour’s default; for CFOUR_SCF_CONV; energy('c4-scf'). uses SCF conv crit since default overwritten by; keyword; set cfour_scf_conv 6; energy('c4-scf'). uses SCF conv crit since default overwritten by; SCF module keyword; set d_convergence 5; energy('c4-scf'). uses SCF conv crit since default overwritten by; SCF module keyword (local scope works, too) where; the Psi4‘s more flexible float input has been rounded down to; the integer required by Cfour; set scf d_convergence 5e-6; energy('c4-scf'). uses SCF conv crit since default overwritten; and Cfour module keyword trumps Psi4 SCF module keyword; set cfour_scf_conv 6; set d_convergence 8; energy('c4-scf'). The keyword translation feature is still in the proof-of-principle; stage, so only a handful (found here) of keywords participate. Note; Longtime Cfour users who may consider this keyword; translation a flaw rather than a feature can avoid it entirely by; confining keywords to the Cfour module along with; BASIS and PUREAM (opt, too?). Misc. Running¶; Naturally, in Psi4 multiple jobs can be run in succession from the input file.; Control optimizations with optking keywords HERE. Cfour GRD file is; written to Psi4 output file. Gradient transformed back into the frame; in which it was shipped off to Cfour is also written to the Psi4; output file and is available from input as get_gradient().; sandwich mode := molecule and cfour list within; Naturally, additional jobs can follow in the input file.; Depending on the nature of preceeding or following jobs, it is prudent to; separate them with the following:; c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/cfour-1.html:33782,energy,energy,33782,psi4manual/1.0.0/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/cfour-1.html,2,['energy'],['energy']
Energy Efficiency," kwarg and/or the extended method syntax like; 'mp3/aug-cc-pv[dt]z' to energy(), opt(), etc., respectively.; For many of the PSI4 Python functions described above, it makes scientific; sense that they could be called in combination. For instance, one could; optimize all the reagents in a database or compute a; counterpoise-corrected interaction energy with an extrapolated method. The; table below outlines permitted intercalls between functions, showing that; db(opt(cbs(energy()))) is allowed, while db(cp(energy())) is not. This; table is not yet validated for calls with cp(). Permitted nesting of Psithon functions¶. Caller; Callee. cp; db; opt; cbs; energy. Basis Set Superposition Corrections. —; Y; Y; Y. Database — database(); —. Y; Y; Y. Geometry Optimization — optimize() and gradient(); —; —. Y; Y. Complete Basis Set; —; —; —. Y. Single-Point Energy — energy(); —; —; —; —. The command db(opt(cbs(energy()))) is actually expressed as db(...,; db_func=opt, opt_func=cbs). The perhaps expected final argument of; cbs_func=energy is not necessary since energy() is always the function; called by default. Also, the outermost internal function call (db_func; above can be called as just func. Several examples of intercalls; between Python functions can be found in sample input pywrap-all.; All keyword arguments are passed along to each function traversed in the; Python driver, so there should be no concern for separating them, grouping; them, or designating them for a particular function when undertaking a; nested calculation. Where the same keyword is used by multiple functions,; prefixes are added, e.g., db_mode and opt_mode.; Function intercalls should not be used in sow/reap mode. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Psithon Functions: Invoking a Calculation; Function Intercalls. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/intercalls.html:1354,energy,energy,1354,psi4manual/1.8.x/intercalls.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/intercalls.html,2,['energy'],['energy']
Energy Efficiency," kwarg and/or the extended method syntax like; 'mp3/aug-cc-pv[dt]z' to energy(), opt(), etc., respectively.; For many of the PSI4 Python functions described above, it makes scientific; sense that they could be called in combination. For instance, one could; optimize all the reagents in a database or compute a; counterpoise-corrected interaction energy with an extrapolated method. The; table below outlines permitted intercalls between functions, showing that; db(opt(cbs(energy()))) is allowed, while db(cp(energy())) is not. This; table is not yet validated for calls with cp(). Permitted nesting of Psithon functions¶. Caller; Callee. cp; db; opt; cbs; energy. Basis Set Superposition Corrections. —; Y; Y; Y. Database — database(); —. Y; Y; Y. Geometry Optimization — optimize() and gradient(); —; —. Y; Y. Complete Basis Set; —; —; —. Y. Single-Point Energy — energy(); —; —; —; —. The command db(opt(cbs(energy()))) is actually expressed as db(...,; db_func=opt, opt_func=cbs). The perhaps expected final argument of; cbs_func=energy is not necessary since energy() is always the function; called by default. Also, the outermost internal function call (db_func; above can be called as just func. Several examples of intercalls; between Python functions can be found in sample input pywrap-all.; All keyword arguments are passed along to each function traversed in the; Python driver, so there should be no concern for separating them, grouping; them, or designating them for a particular function when undertaking a; nested calculation. Where the same keyword is used by multiple functions,; prefixes are added, e.g., db_mode and opt_mode.; Function intercalls should not be used in sow/reap mode. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Psithon Functions: Invoking a Calculation; Function Intercalls. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/intercalls.html:1354,energy,energy,1354,psi4manual/1.9.x/intercalls.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/intercalls.html,2,['energy'],['energy']
Energy Efficiency," kwargs['hf_guess']. # By default, re-guess at each N; continuous_guess = False; if kwargs.has_key('continuous_guess'):; continuous_guess = kwargs['continuous_guess']. # By default, drop the files to the molecule's name; root = mol.name(); if kwargs.has_key('filename'):; root = kwargs['filename']; traverse_filename = root + '.traverse.dat'; # => Traverse <= #; occs = []; energies = []; potentials = []; convs = []. # => Run the neutral for its orbitals, if requested <= #. old_df_ints_io = psi4.get_global_option(""DF_INTS_IO""); psi4.set_global_option(""DF_INTS_IO"", ""SAVE""). old_guess = psi4.get_global_option(""GUESS""); if (neutral_guess):; if (hf_guess):; psi4.set_global_option(""REFERENCE"",""UHF""); energy('scf'); psi4.set_global_option(""GUESS"", ""READ""); psi4.set_global_option(""DF_INTS_IO"", ""LOAD""). # => Run the anion first <= #. mol.set_molecular_charge(chargem); mol.set_multiplicity(multm). # => Burn the anion in with hf, if requested <= #; if (hf_guess):; psi4.set_global_option(""REFERENCE"",""UHF""); energy('scf'); psi4.set_global_option(""REFERENCE"",""UKS""); psi4.set_global_option(""GUESS"", ""READ""); psi4.set_global_option(""DF_INTS_IO"", ""SAVE""). psi4.set_global_option(""FRAC_START"", frac_start); psi4.set_global_option(""FRAC_RENORMALIZE"", True); psi4.set_global_option(""FRAC_LOAD"", False). for occ in LUMO_occs:. psi4.set_global_option(""FRAC_OCC"", [LUMO]); psi4.set_global_option(""FRAC_VAL"", [occ]). E = energy('scf'); C = 1; if (E == 0.0):; E = psi4.get_variable('SCF ITERATION ENERGY'); C = 0. if (LUMO > 0):; ref = psi4.wavefunction(); eps = ref.epsilon_a(); potentials.append(eps[int(LUMO)-1]); else:; ref = psi4.wavefunction(); eps = ref.epsilon_b(); potentials.append(eps[-int(LUMO)-1]). occs.append(occ); energies.append(E); convs.append(C). psi4.set_global_option(""FRAC_START"", 2); psi4.set_global_option(""FRAC_LOAD"", True); psi4.set_global_option(""GUESS"", ""READ""); psi4.set_global_option(""FRAC_DIIS"", frac_diis); psi4.set_global_option(""DF_INTS_IO"", ""LOAD""). # => Run the neutral nex",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/frac.html:3953,energy,energy,3953,psi4manual/4.0b5/_modules/frac.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/frac.html,1,['energy'],['energy']
Energy Efficiency," label prepended to all psivars computed. :examples:. >>> # [1] Moments with specific label; >>> E, wfn = energy('hf', return_wfn=True); >>> oeprop(wfn, 'DIPOLE', 'QUADRUPOLE', title='H3O+ SCF'). """"""; oe = core.OEProp(wfn); if 'title' in kwargs:; oe.set_title(kwargs['title']); for prop in args:; oe.add(prop); ; # If we're doing MBIS, we want the free-atom volumes; # in order to compute volume ratios,; # but only if we're calling oeprop as the whole molecule; free_atom = kwargs.get('free_atom',False); if ""MBIS"" in prop.upper() and not free_atom:; core.print_out("" Computing free-atom volumes\n""); free_atom_volumes(wfn) . oe.compute(). [docs]def cubeprop(wfn, **kwargs):; """"""Evaluate properties on a grid and generate cube files. .. versionadded:: 0.5; *wfn* parameter passed explicitly. :returns: None. :type wfn: :py:class:`~psi4.core.Wavefunction`; :param wfn: set of molecule, basis, orbitals from which to generate cube files. :examples:. >>> # [1] Cube files for all orbitals; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> cubeprop(wfn). >>> # [2] Cube files for density (alpha, beta, total, spin) and four orbitals; >>> # (two alpha, two beta); >>> set cubeprop_tasks ['orbitals', 'density']; >>> set cubeprop_orbitals [5, 6, -5, -6]; >>> E, wfn = energy('scf', return_wfn=True); >>> cubeprop(wfn). """"""; # By default compute the orbitals; if not core.has_global_option_changed('CUBEPROP_TASKS'):; core.set_global_option('CUBEPROP_TASKS', ['ORBITALS']). if ((core.get_global_option('INTEGRAL_PACKAGE') == 'ERD') and ('ESP' in core.get_global_option('CUBEPROP_TASKS'))):; raise ValidationError('INTEGRAL_PACKAGE ERD does not play nicely with electrostatic potential, so stopping.'). cp = core.CubeProperties(wfn); cp.compute_properties(). [docs]def set_memory(inputval: Union[str, int, float], execute: bool = True, quiet: bool = False) -> int:; """"""Function to reset the total memory allocation. Takes memory value; *inputval* as type int, float, or str; int and float are taken literal",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/util.html:2655,energy,energy,2655,psi4manual/1.4.0/_modules/psi4/driver/p4util/util.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/util.html,2,['energy'],['energy']
Energy Efficiency," len(findif_meta_dict[""displacements""]) + 1. print("""""" %d displacements needed."""""" % ndisp). wfn = _process_displacement(gradient, lowername, molecule, findif_meta_dict[""reference""], 1, ndisp,; **kwargs); var_dict = core.variables(); # ensure displacement calculations do not use restart_file orbitals.; kwargs.pop('restart_file', None). for n, displacement in enumerate(findif_meta_dict[""displacements""].values(), start=2):; _process_displacement(; gradient, lowername, molecule, displacement, n, ndisp, write_orbitals=False, **kwargs). # Reset variables; for key, val in var_dict.items():; core.set_variable(key, val). # Assemble Hessian from gradients; # Final disp is undisp, so wfn has mol, G, H general to freq calc; H = driver_findif.assemble_hessian_from_gradients(findif_meta_dict, irrep); wfn.set_hessian(core.Matrix.from_array(H)); wfn.set_gradient(G0). # Explicitly set the current energy..; if isinstance(lowername, str) and lowername in procedures['energy']:; # this correctly filters out cbs fn and ""hf/cc-pvtz""; # it probably incorrectly filters out mp5, but reconsider in DDD; core.set_variable(f""CURRENT HESSIAN"", H); core.set_variable(f""{lowername.upper()} TOTAL HESSIAN"", H); core.set_variable(f""{lowername.upper()} TOTAL GRADIENT"", G0); wfn.set_variable(f""{lowername.upper()} TOTAL HESSIAN"", H); wfn.set_variable(f""{lowername.upper()} TOTAL GRADIENT"", G0); core.set_variable('CURRENT ENERGY', findif_meta_dict[""reference""][""energy""]); wfn.set_variable('CURRENT ENERGY', findif_meta_dict[""reference""][""energy""]). core.set_global_option(""PARENT_SYMMETRY"", """"); optstash.restore(); optstash_conv.restore(). else:; core.print_out(""""""hessian() will perform frequency computation by finite difference of analytic energies.\n""""""). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash.restore(); optstash_conv.restore(); optstash_conv = driver_util._set_convergence_criterion('energy', lowername, 10, 11, 10, 11, 10). # Obtain l",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/driver.html:80209,energy,energy,80209,psi4manual/1.5.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/driver.html,1,['energy'],['energy']
Energy Efficiency," less than 0, hence may violate the N-representability condition. They further; discussed that the orbital response equations generally have a singularity problem at the unrestriction point; where spin-restricted orbitals become unstable to unrestriction. This singularity yields to extremely large or; small eigenvalues of the one-particle density matrix (OPDM). These abnormal eigenvalues may lead to unphysical; molecular properties such as vibrational frequencies. However, orbital optimized MP2 (hence Orbital optimized MP3); will solve this N-representability problem by disregarding orbital response contribution of one-partical; density matrix.; Although the performance of coupled-cluster singles and doubles (CCSD) and orbital-optimized; CCD (OD) is similar, the situation is different in the case of triples corrections, especially at stretched; geometries [Bozkaya:2012:odtl]. Bozkaya and Schaefer demonstrated that orbital-optimized coupled cluster based; triple corrections, especially those of asymmetrics, provide significantly better potential energy curves than; CCSD based triples corrections. Theory¶; What follows is a very basic description of orbital-optimized Møller–Plesset perturbation; theory as implemented in PSI4. We will follow our previous presentations ([Bozkaya:2011:omp2],; [Bozkaya:2011:omp3], and [Bozkaya:2012:odtl]); The orbital variations may be expressed by means of an exponential unitary operator. where is the orbital rotation operator. The effect of the orbital rotations on the MO coefficients can be written as. where is the initial MO coefficient matrix and is the new; MO coefficient matrix as a function of .; Now, let us define a variational energy functional (Lagrangian) as a function of . OMP2. OMP3. OCEPA. where subscript c means only connected diagrams are allowed, and; , , and defined as. where , and are the one- and two-electron components of normal-ordered Hamiltonian. Then,; first and second derivatives of the energy with respect to th",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/occ-1.html:2898,energy,energy,2898,psi4manual/4.0b4/occ-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/occ-1.html,4,['energy'],['energy']
Energy Efficiency," less than 0, hence may violate the N-representability condition. They further; discussed that the orbital response equations generally have a singularity problem at the unrestriction point; where spin-restricted orbitals become unstable to unrestriction. This singularity yields to extremely large or; small eigenvalues of the one-particle density matrix (OPDM). These abnormal eigenvalues may lead to unphysical; molecular properties such as vibrational frequencies. However, orbital optimized MP2 (hence Orbital optimized MP3); will solve this N-representability problem by disregarding orbital response contribution of one-partical; density matrix.; Although the performance of coupled-cluster singles and doubles (CCSD) and orbital-optimized; CCD (OD) is similar, the situation is different in the case of triples corrections, especially at stretched; geometries [Bozkaya:2012:odtl]. Bozkaya and Schaefer demonstrated that orbital-optimized coupled cluster based; triple corrections, especially those of asymmetrics, provide significantly better potential energy curves than; CCSD based triples corrections. Theory¶; What follows is a very basic description of orbital-optimized Møller–Plesset perturbation; theory as implemented in PSI4. We will follow our previous presentations ([Bozkaya:2011:omp2],; [Bozkaya:2011:omp3], and [Bozkaya:2012:odtl]); The orbital variations may be expressed by means of an exponential unitary operator. where is the orbital rotation operator. The effect of the orbital rotations on the MO coefficients can be written as. where is the initial MO coefficient matrix and is the new; MO coefficient matrix as a function of .; Now, let us define a variational energy functional (Lagrangian) as a function of . OMP2. OMP3. where , , and defined as. and first and second derivatives of the energy with respect to the parameter at . Then the energy can be expanded up to second-order as follows. where is the MO gradient vector, is the MO rotation vector,; and is the MO",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/ompn-1.html:2896,energy,energy,2896,psi4manual/4.0b3/ompn-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/ompn-1.html,2,['energy'],['energy']
Energy Efficiency," less than 0, hence may violate the N-representability condition. They further; discussed that the orbital response equations generally have a singularity problem at the unrestriction point; where spin-restricted orbitals become unstable to unrestriction. This singularity yields to extremely large or; small eigenvalues of the one-particle density matrix (OPDM). These abnormal eigenvalues may lead to unphysical; molecular properties such as vibrational frequencies. However, orbital optimized MP2 (hence Orbital optimized MP3); will solve this N-representability problem by disregarding orbital response contribution of one-partical; density matrix.; Although the performance of coupled-cluster singles and doubles (CCSD) and orbital-optimized; CCD (OD) is similar, the situation is different in the case of triples corrections, especially at stretched; geometries [Bozkaya:2012:odtl]. Bozkaya and Schaefer demonstrated that orbital-optimized coupled cluster based; triple corrections, especially those of asymmetrics, provide significantly better potential energy curves than; CCSD based triples corrections.; A lot of the functionality in OCC has been enabled with Density Fitting (DF) and Cholesky; Decomposition (CD) techniques, which can greatly speed up calculations and reduce memory; requirements for typically negligible losses in accuracy.; NOTE: As will be discussed later, all methods with orbital-optimization functionality have non-orbital; optimized counterparts. Consequently, there arise two possible ways to call density-fitted MP2. In most; cases, users should prefer the DF-MP2 code described in the DF-MP2 section because it is; faster. If gradients are needed (like in a geometry optimization), then the procedures outlined hereafter; should be followed.; Thus, there arise a few categories of method, each with corresponding input keywords:. Orbital-optimized MP and CC methods with conventional integrals (OMP Methods OCC keywords); Orbital-optimized MP and CC methods with",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/occ-1.html:2977,energy,energy,2977,psi4manual/1.0.0/occ-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/occ-1.html,2,['energy'],['energy']
Energy Efficiency," level of theory. MP3 TOTAL ENERGY¶. MP3 CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the MP3 level of theory. MP4(T) CORRECTION ENERGY¶; The MP4 triples component [E_h]. Quantity is second right-hand term in; Eq. (2). MP4(SDQ) TOTAL ENERGY¶. MP4(SDQ) CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the MP4 singles, doubles, quadruples level of theory. Quantity; MP4(SDQ) CORRELATION ENERGY is; first right-hand term in Eq. (2). MP4 TOTAL ENERGY¶. MP4 CORRELATION ENERGY¶. MP4(SDTQ) TOTAL ENERGY¶. MP4(SDTQ) CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the full MP4 level of theory. Quantity MP4 CORRELATION; ENERGY / MP4(SDTQ) CORRELATION ENERGY; is left-hand term in Eq. (2). (2)¶\[E_{\text{MP4}} = E_{\text{MP4(SDQ)}} + E_{\text{MP4(T)}}\]. MPn TOTAL ENERGY¶. MPn CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the labeled Møller–Plesset perturbation theory level.; n is MP perturbation order. MP2 DOUBLES ENERGY¶. MP2.5 DOUBLES ENERGY¶. MP3 DOUBLES ENERGY¶. CEPA(0) DOUBLES ENERGY¶. CEPA(1) DOUBLES ENERGY¶. CEPA(2) DOUBLES ENERGY¶. CEPA(3) DOUBLES ENERGY¶. ACPF DOUBLES ENERGY¶. AQCC DOUBLES ENERGY¶. CISD DOUBLES ENERGY¶. QCISD DOUBLES ENERGY¶. REMP2 DOUBLES ENERGY¶. LCCD DOUBLES ENERGY¶. CCD DOUBLES ENERGY¶. LCCSD DOUBLES ENERGY¶. CCSD DOUBLES ENERGY¶. OMP2 DOUBLES ENERGY¶. OMP2.5 DOUBLES ENERGY¶. OMP3 DOUBLES ENERGY¶. OREMP2 DOUBLES ENERGY¶. OLCCD DOUBLES ENERGY¶; The doubles portion [E_h] of the named correlation energy; including same-spin and opposite-spin correlations. MP2 SINGLES ENERGY¶. MP2.5 SINGLES ENERGY¶. MP3 SINGLES ENERGY¶. CEPA(0) SINGLES ENERGY¶. CEPA(1) SINGLES ENERGY¶. CEPA(2) SINGLES ENERGY¶. CEPA(3) SINGLES ENERGY¶. ACPF SINGLES ENERGY¶. AQCC SINGLES ENERGY¶. CISD SINGLES ENERGY¶. QCISD SINGLES ENERGY¶. REMP2 SINGLES ENERGY¶. LCCD SINGLES ENERGY¶. CC",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html:37517,energy,energy,37517,psi4manual/1.7.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html,8,['energy'],['energy']
Energy Efficiency," level of; theory.; Deprecated in favor of CI ROOT n -> ROOT m QUADRUPOLE. CI ROOT n DIPOLE¶; Dipole array [e a0] for the requested configuration interaction level of theory and root n, (3,). CI ROOT n DIPOLE X¶. CI ROOT n DIPOLE Y¶. CI ROOT n DIPOLE Z¶; The three components of the dipole [Debye] for the requested; configuration interaction level of theory and root n.; Deprecated in favor of CI ROOT n DIPOLE. CI ROOT n QUADRUPOLE¶; Redundant quadrupole array [e a0^2] for the requested configuration interaction level of theory and root n, (3, 3). CI ROOT n QUADRUPOLE XX¶. CI ROOT n QUADRUPOLE XY¶. CI ROOT n QUADRUPOLE XZ¶. CI ROOT n QUADRUPOLE YY¶. CI ROOT n QUADRUPOLE YZ¶. CI ROOT n QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; configuration interaction level of theory and root n.; Deprecated in favor of CI ROOT n QUADRUPOLE. CI ROOT n TOTAL ENERGY¶. CI ROOT n CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the requested configuration interaction level of theory and root; n (numbering starts at 0). CI STATE-AVERAGED TOTAL ENERGY¶. CI STATE-AVERAGED CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for state-averaged CI/CASSCF levels of theory. CI TOTAL ENERGY¶. CI CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the requested configuration interaction level of theory and root. CISD DIPOLE¶; Dipole array [e a0] for the configuration interaction singles and doubles level of theory, (3,). CISD DIPOLE X¶. CISD DIPOLE Y¶. CISD DIPOLE Z¶; The three components of the dipole [Debye] for the; configuration interaction singles and doubles level of theory and root.; Deprecated in favor of CISD DIPOLE. CISD QUADRUPOLE¶; Redundant quadrupole array [e a0^2] for the configuration interaction singles and doubles level of theory, (3, 3). CISD QUADRUPOLE XX¶. CISD QUADRUPOLE XY¶. CISD QUADRUPOLE XZ¶. CISD QUA",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html:12843,energy,energy,12843,psi4manual/1.4.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html,8,['energy'],['energy']
Energy Efficiency," library is distributed with Psi4; and requires no additional licence, downloads, or configuration.; The library is documented at http://pcmsolver.readthedocs.org/, while the source code is hosted at; https://github.com/PCMSolver/pcmsolver/; The library allows for calculations in solution with the polarizable continuum model (PCM),; a continuum solvation model.; Compilation of the library and its interface to Psi4 can be disabled by passing the; --pcmsolver=off to the setup script or -DENABLE_PCMSOLVER=OFF directly to CMake. Using the polarizable continuum model¶; The inclusion of a PCM description of the solvent into your calculation; is achieved by setting pcm true in your input file.; Psi4 understands the additional option pcm_scf_type with possible values total; (the default) or separate.; The latter forces the separate handling of nuclear and electronic electrostatic potentials and; polarization charges. It is mainly useful for debugging. Note; At present PCM can only be used for energy calculations with SCF wavefunctions.; Moreover, the PCMSolver library cannot exploit molecular point group symmetry. The PCM model and molecular cavity are specified in a pcm section that has; to be explicitly typed in by the user. This additional section follows a syntax; that is slightly different from that of Psi4 and is fully documented; here; A typical input for a Hartree-Fock calculation with PCM would look like the following:; molecule NH3 {; symmetry c1; N -0.0000000001 -0.1040380466 0.0000000000; H -0.9015844116 0.4818470201 -1.5615900098; H -0.9015844116 0.4818470201 1.5615900098; H 1.8031688251 0.4818470204 0.0000000000; units bohr; no_reorient; no_com; }. set {; basis STO-3G; scf_type pk; pcm true; pcm_scf_type total; }. pcm = {; Units = Angstrom; Medium {; SolverType = IEFPCM; Solvent = Water; }. Cavity {; RadiiSet = UFF; Type = GePol; Scaling = False; Area = 0.3; Mode = Implicit; }; }. More examples can be found in the directories with PCM tests; pcmsolver/pcm_scf,",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/pcmsolver-1.html:1504,energy,energy,1504,psi4manual/1.0.0/pcmsolver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/pcmsolver-1.html,2,['energy'],['energy']
Energy Efficiency," line.; The syntax is:; >>> psi4 input-name output-name. If you give an input name but no output name, then the output name will; be the same as the input name (replacing any “.in” or “.dat” extension by “.out”). Sample Input Files¶; Below, we will provide a few simple input files as examples. A large; number of sample input files, covering everything from single-point energies; using density-functional theory to response properties from coupled-cluster; theory, can be found in the psi4/samples directory. Running a Basic Hartree–Fock Calculation¶; In our first example, we will consider a Hartree–Fock SCF computation; for the water molecule using a cc-pVDZ basis set. We will specify the; geometry of our water molecule using a standard Z-matrix.; # Any line starting with the # character is a comment line; #! Sample HF/cc-pVDZ H2O computation. memory 600 mb. molecule h2o {; O ; H 1 0.96; H 1 0.96 2 104.5; }. set basis cc-pVDZ; energy('scf'). Note; The memory and basis set specifications are placed before the; energy function is called. Any user options need to; be set before the procedure they are meant to affect. For your convenience, the above example can be found in; tu1-h2o-energy.; You can run it if you wish.; Once PSI4 is in your path (see the; User Configuration; section of the installation instructions), you can run this computation by typing; >>> psi4 input.dat output.dat. If everything goes well, the computation should complete and should report; a final restricted Hartree–Fock energy in a section like this:; 1; 2; 3Energy converged. @RHF Final Energy: -76.02663273410671. By default, the energy should be converged to about \(1.0 \times 10^{-6}\), so agreement; is only expected for about the first 6 digits after the decimal. If the; computation does not complete, there is probably a problem with the; compilation or installation of the program (see the installation; instructions in Sec. Compiling and Installing from Source).; This very simple input is sufficien",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/tutorial-1.html:2272,energy,energy,2272,psi4manual/1.3.2/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/tutorial-1.html,2,['energy'],['energy']
Energy Efficiency," line.; The syntax is:; >>> psi4 input-name output-name. If you give an input name but no output name, then the output name will; be the same as the input name (replacing any “.in” or “.dat” extension by “.out”). Sample Input Files¶; Below, we will provide a few simple input files as examples. A large; number of sample input files, covering everything from single-point energies; using density-functional theory to response properties from coupled-cluster; theory, can be found in the psi4/samples directory. Running a Basic Hartree–Fock Calculation¶; In our first example, we will consider a Hartree–Fock SCF computation; for the water molecule using a cc-pVDZ basis set. We will specify the; geometry of our water molecule using a standard Z-matrix.; # Any line starting with the # character is a comment line; #! Sample HF/cc-pVDZ H2O computation. memory 600 mb. molecule h2o {; O ; H 1 0.96; H 1 0.96 2 104.5; }. set basis cc-pVDZ; energy('scf'). Note; The memory and basis set specifications are placed before the; energy function is called. Any user options need to; be set before the procedure they are meant to affect. For your convenience, the above example can be found in; tu1-h2o-energy.; You can run it if you wish.; Once PSI4 is in your path (see the; User Configuration; section of the installation instructions), you can run this computation by typing; >>> psi4 input.dat output.dat. If everything goes well, the computation should complete and should report; a final restricted Hartree–Fock energy in a section like this:; Energy converged. @RHF Final Energy: -76.02663273410671. By default, the energy should be converged to about \(1.0 \times 10^{-6}\), so agreement; is only expected for about the first 6 digits after the decimal. If the; computation does not complete, there is probably a problem with the; compilation or installation of the program (see the installation; instructions in Sec. Compiling and Installing from Source).; This very simple input is sufficient to ru",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/tutorial-1.html:2317,energy,energy,2317,psi4manual/1.4.0/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/tutorial-1.html,9,['energy'],['energy']
Energy Efficiency," linear bond angle that is not linear in the optimized structure but is in a symmetry plane of the molecule. freq-isotope1; Vibrational and thermo analysis of several water isotopologs. Demonstrates Hessian reuse for different temperatures and pressures but not for different isotopologs. tdscf-1; td-uhf test on triplet states of methylene (rpa). dct6; DCT calculation for the triplet O2 using DC-06 and DC-12. Only two-step algorithm is tested. sapt8; SAPT0(ROHF) open-shell computation of CN - Ne interaction energy First with jun-cc-pVDZ and density fitted integrals with ROHF Then with cc-pVDZ and direct integrals, except for dispersion that is computed with cc-pVDZ-ri density fitting with ROHF. fnocc4; Test FNO-DF-CCSD(T) energy. cdremp-1; Cholesky decomposed REMP/cc-pVDZ energies for the CO2 molecule. opt13; B3LYP cc-pVDZ geometry optimzation of phenylacetylene, starting from not quite linear structure updated reference due to new BraggSlater radii. olccd2; OLCCD cc-pVDZ energy with B3LYP initial guess for the NO radical. scf-uhf-grad-nobeta; UHF gradient for a one-electron system (no beta electrons). dfccsdt1; DF-CCSD(T) cc-pVDZ energy for the H2O molecule. pywrap-align-chiral; testing aligner on enantiomers based on Table 1 of 10.1021/ci100219f aka J Chem Inf Model 2010 50(12) 2129-2140. dft-grad-disk; A range-seperated gradient for SO2 to test disk algorithms by explicitly setting low memory. cc5; RHF CCSD(T) cc-pVDZ frozen-core energy of C4NH4 Anion. cc35; CC3(ROHF)/cc-pVDZ H2O \(R_e\) geom from Olsen et al., JCP 104, 8007 (1996). omp3-4; SCS-OMP3 cc-pVDZ geometry optimization for the H2O molecule. scf-ecp2; Water-Argon complex with ECP present; check of RHF Hessian. cbs-xtpl-gradient; Various gradients for a strained helium dimer and water molecule. scf-response1; Compute the dipole, quadrupole, and traceless quadrupoles for water. dfomp3-grad2; DF-OMP3 cc-pVDZ gradients for the H2O+ cation. cdomp2-1; OMP2 cc-pVDZ energy for the H2O molecule. cc4; RHF-CCSD(T) c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html:32039,energy,energy,32039,psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency," linear dependencies. fnocc6; Test method/basis with disk_df. tdscf-2; td-uhf test on triplet states of methylene (tda), wfn passing. cc26; Single-point gradient, analytic and via finite-differences of 2-1A1 state of H2O with EOM-CCSD. cc55; EOM-CCSD/6-31g excited state transition data for water with two excited states per irrep. dfmp2-1; Density fitted MP2 cc-PVDZ/cc-pVDZ-RI computation of formic acid dimer binding energy using automatic counterpoise correction. Monomers are specified using Cartesian coordinates. dct3; DC-06 calculation for the He dimer. This performs a simultaneous update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the AO Basis, using integrals stored on disk. pywrap-alias; Test parsed and exotic calls to energy() like zapt4, mp2.5, and cisd are working. cc6; Frozen-core CCSD(T)/cc-pVDZ on C4H4N anion with disk ao algorithm. omp3-4; SCS-OMP3 cc-pVDZ geometry optimization for the H2O molecule. sapt-ecp; sapt0 of charged system in ECP basis set. cisd-h2o+-0; 6-31G** H2O+ Test CISD Energy Point. oremp-grad2; integral conventional OO-REMP/cc-pVDZ engrad single points for the H2O molecule. single point energies were independently checked using the original wavels code. oremp-grad1; integral conventional OO-REMP/cc-pVDZ engrad single points for the H2O molecule. castup1; Test of SAD/Cast-up (mainly not dying due to file weirdness). phi-ao; Test computing values of basis functions (puream and non-puream) at points. omp2p5-grad1; OMP2.5 cc-pVDZ gradient for the H2O molecule. tu4-h2o-freq; Optimization followed by frequencies H2O HF/cc-pVDZ. dft-grad1; DF-BP86-D2 cc-pVDZ frozen core gradient of S22 HCN update ref gradient due to new BraggSlater radii. sapt-dft-lrc; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. cc39; RHF-CC2-LR/cc-pVDZ dynamic polarizabilities of HOF molecule. dct11; Restricted DF-DCT ODC-12 energies with linearly dependent basis functions. mp2p5-grad1; MP2.5 cc-pVDZ grad",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html:40184,charge,charged,40184,psi4manual/master/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html,2,['charge'],['charged']
Energy Efficiency," list of database members to run. Consult the; database python files for available molecular systems. The; choices for this keyword are case sensitive and must match the; database python file. :examples:. >>> # [1] Two-stage SCF calculation on short, equilibrium, and long helium dimer; >>> db('scf','RGC10',cast_up='sto-3g',subset=['HeHe-0.85','HeHe-1.0','HeHe-1.5'], tabulate=['scf total energy','natom']). >>> # [2] Counterpoise-corrected interaction energies for three complexes in S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('dfmp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs); #hartree2kcalmol = 627.509469 # consistent with perl SETS scripts. # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish function to call; if not('db_func' in kwargs):; if ('func' in kwargs):; kwargs['db_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['db_func'] = energy; func = kwargs['db_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper database.' % (func.__name__)); if (func is cp):; raise ValidationError('Wrapper database is unhappy to be calling function \'%s\'. Use the cp keyword within database instead.' % (func.__name__)). # Define path and load module for requested database; sys.path.append('%sdataba",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:28699,energy,energy,28699,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,2,['energy'],['energy']
Energy Efficiency," list of database members to run. Consult the; database python files for available molecular systems. The; choices for this keyword are case sensitive and must match the; database python file. Examples :. >>> # [1] Two-stage SCF calculation on short, equilibrium, and long helium dimer; >>> db('scf','RGC10',cast_up='sto-3g',subset=['HeHe-0.85','HeHe-1.0','HeHe-1.5'], tabulate=['scf total energy','natom']). >>> # [2] Counterpoise-corrected interaction energies for three complexes in S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('dfmp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). Output¶; At the beginning of a database job is printed a listing of the individual system; calculations which will be performed. The output snippet below is from the example job [1]; above. It shows each reagent required for the subset of database reactions requested.; Note that this is an un-counterpoise-corrected example, and the wrapper is smart enough; to compute only once the monomer whose energy will be subtracted from each of the three dimers.; RGC1-HeHe-0.85-dimer; RGC1-He-mono-unCP; RGC1-HeHe-1.0-dimer; RGC1-HeHe-1.5-dimer. At the end of the job, the Requested Energy table is printed that gives the total; energies for the requested model chemistry for each reagent and each reaction, as; well as the stoichoimetric weights by which the reagent energies are transfromed; into the reaction energy. In this case, the dimer is +1 and the monomer is -2,; indicating the the interaction energy is comp",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/db-1.html:5614,energy,energy,5614,psi4manual/4.0b2/db-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/db-1.html,4,['energy'],['energy']
Energy Efficiency," list of valid basis sets for delta correction energy; if do_delta:; if 'delta_basis' in kwargs:; BSTD, ZETD = _expand_bracketed_basis(kwargs['delta_basis'].lower(), molecule=molstr); else:; raise ValidationError(""""""DELTA basis sets through keyword '%s' are required."""""" % ('delta_basis')). # Establish list of valid basis sets for second delta correction energy; if do_delta2:; if 'delta2_basis' in kwargs:; BSTD2, ZETD2 = _expand_bracketed_basis(kwargs['delta2_basis'].lower(), molecule=molstr); else:; raise ValidationError(""""""DELTA2 basis sets through keyword '%s' are required."""""" % ('delta2_basis')). # # Establish list of valid basis sets for third delta correction energy; # if do_delta3:; # if 'delta3_basis' in kwargs:; # BSTD3, ZETD3 = validate_bracketed_basis(kwargs['delta3_basis'].lower()); # else:; # raise ValidationError('DELTA3 basis sets through keyword \'%s\' are required.' % ('delta3_basis')); #; # # Establish list of valid basis sets for fourth delta correction energy; # if do_delta4:; # if 'delta4_basis' in kwargs:; # BSTD4, ZETD4 = validate_bracketed_basis(kwargs['delta4_basis'].lower()); # else:; # raise ValidationError('DELTA4 basis sets through keyword \'%s\' are required.' % ('delta4_basis')); #; # # Establish list of valid basis sets for fifth delta correction energy; # if do_delta5:; # if 'delta5_basis' in kwargs:; # BSTD5, ZETD5 = validate_bracketed_basis(kwargs['delta5_basis'].lower()); # else:; # raise ValidationError('DELTA5 basis sets through keyword \'%s\' are required.' % ('delta5_basis')). # Establish treatment for scf energy (validity check useless since python will catch it long before here); if (len(BSTR) == 3) and ('scf_basis' in kwargs):; cbs_scf_scheme = scf_xtpl_helgaker_3; elif (len(BSTR) == 2) and ('scf_basis' in kwargs):; cbs_scf_scheme = scf_xtpl_helgaker_2; elif (len(BSTR) == 1) and ('scf_basis' in kwargs):; cbs_scf_scheme = xtpl_highest_1; elif 'scf_basis' in kwargs:; raise ValidationError(""""""SCF basis sets of number %d cannot b",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:37500,energy,energy,37500,psi4manual/1.0.0/_modules/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html,3,['energy'],['energy']
Energy Efficiency," listing. Python Wrappers¶; The Python foundations of the PSI4 driver and Psithon syntax permit; many commonly performed post-processing procedures to be integrated into; the PSI4 suite.; As seen in the neon dimer example from the tutorial section,; the nbody_gufunc() wrapper provides automatic computation of; counterpoise-corrected interaction energies between two molecules. For; example,; 1energy('mp2', bsse_type='cp'). will compute the counterpoise-corrected density-fitted MP2 interaction energy; between two molecules.; PSI4 also provides the cbs() wrapper,; which automatically computes a complete-basis-set extrapolation (and; automatically sets up the computations with different basis sets required to; do the extrapolation). For example,:; 1; 2; 3; 4; 5# all equivalent. cbs('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). energy('mp2/cc-pv[dt]z'). will compute a 2-point Helgaker extrapolation of the correlation energy; using the cc-pVDZ and cc-pVTZ basis sets (with method MP2) and add this; extrapolated correlation energy to the Hartree–Fock energy in the; largest basis (cc-pVTZ). cbs() can; either be called directly, as in the first example, or the convenience; syntax of the equivalent second example can be used.; Another very useful and powerful feature of PSI4 is the ability; to compute results on entire databases of molecules at a time,; as provided by the database() wrapper. For example,:; 1database('mp2', 'S22', cp=1, benchmark='S22B'). will perform DF-MP2 counterpoise-corrected interaction energies; (cp=1) on all members of Hobza’s S22 database set of van der Waals; dimers, and then compare the results against the S22B benchmark energies.; Built-in databases include S22, A24, HTBH, HBC6, HSG, S22by5, S66, JSCH,; NCB31, S66by8, and NBC10, among others.; These wrapper functions are discussed separately in; Psithon Functions: Invoking a Calculation. Note that the options documented for Python; functions are placed as arguments in the comman",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psithoninput-1.html:15656,energy,energy,15656,psi4manual/1.1.0/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psithoninput-1.html,18,['energy'],['energy']
Energy Efficiency," long before here); cbs_scf_scheme = highest_1; if 'scf_scheme' in kwargs:; cbs_scf_scheme = kwargs['scf_scheme']. # Establish treatment for correlation energy; cbs_corl_scheme = highest_1; if 'corl_scheme' in kwargs:; cbs_corl_scheme = kwargs['corl_scheme']. # Establish treatment for delta correction energy; cbs_delta_scheme = highest_1; if 'delta_scheme' in kwargs:; cbs_delta_scheme = kwargs['delta_scheme']. # Establish treatment for delta2 correction energy; cbs_delta2_scheme = highest_1; if 'delta2_scheme' in kwargs:; cbs_delta2_scheme = kwargs['delta2_scheme']. # Build string of title banner; cbsbanners = ''; cbsbanners += """"""PsiMod.print_out('\\n')\n""""""; cbsbanners += """"""banner(' CBS Setup ')\n""""""; cbsbanners += """"""PsiMod.print_out('\\n')\n\n""""""; exec(cbsbanners). # Call schemes for each portion of total energy to 'place orders' for calculations needed; d_fields = ['d_stage', 'd_scheme', 'd_basis', 'd_wfn', 'd_need', 'd_coef', 'd_energy']; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; GRAND_NEED = []; MODELCHEM = []; bstring = ''; if do_scf:; NEED = call_function_in_1st_argument(cbs_scf_scheme,; mode='requisition', basisname=BSTR, basiszeta=ZETR, wfnname='scf'); GRAND_NEED.append(dict(zip(d_fields, ['scf', cbs_scf_scheme, reconstitute_bracketed_basis(NEED), 'scf', NEED, +1, 0.0]))). if do_corl:; NEED = call_function_in_1st_argument(cbs_corl_scheme,; mode='requisition', basisname=BSTC, basiszeta=ZETC, wfnname=cbs_corl_wfn); GRAND_NEED.append(dict(zip(d_fields, ['corl', cbs_corl_scheme, reconstitute_bracketed_basis(NEED), cbs_corl_wfn, NEED, +1, 0.0]))). if do_delta:; NEED = call_function_in_1st_argument(cbs_delta_scheme,; mode='requisition', basisname=BSTD, basiszeta=ZETD, wfnname=cbs_delta_wfn); GRAND_NEED.append(dict(zip(d_fields, ['delta', cbs_delta_scheme, reconstitute_bracketed_basis(NEED), cbs_delta_wfn, NEED, +1, 0.0]))). NEED = call_function_in_1st_argument(cbs_delta_scheme,; mode='requisition', basisname=BSTD, basiszeta=ZETD, wfnn",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html:67026,energy,energy,67026,psi4manual/4.0b3/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html,2,['energy'],['energy']
Energy Efficiency," lowername in energy_only_methods:; raise ValidationError(f""`gradient('{name}')` does not have an associated gradient.""). # * Avert pydantic anger at incomplete modelchem spec; userbas = core.get_global_option('BASIS') or kwargs.get('basis'); if lowername in integrated_basis_methods and userbas is None:; kwargs['basis'] = '(auto)'. # Are we planning?; plan = task_planner.task_planner(""gradient"", lowername, molecule, **kwargs); logger.debug('GRADIENT PLAN'); logger.debug(pp.pformat(plan.dict())). if kwargs.get(""return_plan"", False):; # Plan-only requested; return plan. elif not isinstance(plan, AtomicComputer):; # Advanced ""Computer"" active; plan.compute(); return plan.get_psi_results(return_wfn=return_wfn). else:; # We have unpacked to an AtomicInput; lowername = plan.method; basis = plan.basis; core.set_global_option(""BASIS"", basis). ## Second half of this fn -- entry means program running exactly analytic 1st derivative. # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash = driver_util.negotiate_convergence_criterion((1, 1), lowername, return_optstash=True). # Commit to procedures[] call hereafter; core.clean_variables(). # no analytic derivatives for scf_type cd; if core.get_global_option('SCF_TYPE') == 'CD':; raise ValidationError(""""""No analytic derivatives for SCF_TYPE CD.""""""). core.print_out(""""""gradient() will perform analytic gradient computation.\n""""""). # Perform the gradient calculation; logger.info(f""Compute gradient(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); wfn = procedures['gradient'][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return gradient(): {core.variable('CURRENT ENERGY')}""); logger.info(nppp(wfn.gradient().np)). basisstash.restore(); opts",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html:37654,energy,energy,37654,psi4manual/1.6.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html,5,['energy'],['energy']
Energy Efficiency," made to; files in $PSIDATADIR aka psi4/lib, including those described below. Defining a Method Alias¶; Since quantum chemical methods in PSI4 are accessed through Python functions, and; most important quantities are available as PSI variables, it is straightforward; to create aliases to commonly run calculations or to define hybrid methods. The; psi4/lib/python/aliases.py file is intended for editing by the user for; this purpose.; As an example, the MP2.5 method is the average of MP2 and MP3. The latter is; available through the arbitrary order MPn code and returns all lower energies; along with it in PSI variables. The following is basic code that will compute; and return the MP2.5 energy.; def run_mp2_5(name, **kwargs):. energy('mp3', **kwargs); e_scf = psi4.get_variable('SCF TOTAL ENERGY'); ce_mp2 = psi4.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = psi4.get_variable('MP3 CORRELATION ENERGY'). ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25. print """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); print """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25). return e_mp25. Compare the above to the method that resides in psi4/lib/python/aliases.py.; The rationale for the changes is indicated in the comments below.; def run_mp2_5(name, **kwargs):; lowername = name.lower() # handy variable with name keyword in lowercase; kwargs = kwargs_lower(kwargs) # removes case sensitivity in keyword names. # Run detci calculation and collect conventional quantities; energy('mp3', **kwargs); e_scf = psi4.get_variable('SCF TOTAL ENERGY'); ce_mp2 = psi4.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = psi4.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; psi4.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; psi4.set_variable('MP2.5 TOTAL ENER",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/quickaddalias-1.html:1242,energy,energy,1242,psi4manual/4.0b5/quickaddalias-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/quickaddalias-1.html,2,['energy'],['energy']
Energy Efficiency," magneton ratio [] uncertainty=0.000 000 0085. proton_mag_shielding_correction; 0.000025691; proton mag. shielding correction [] uncertainty=0.011 e-6. proton_mass; 1.672621898E-27; proton mass [kg] uncertainty=0.000 000 021 e-27. proton_mass_energy_equivalent; 1.503277593E-10; proton mass energy equivalent [J] uncertainty=0.000 000 018 e-10. proton_mass_energy_equivalent_in_MeV; 938.2720813; proton mass energy equivalent in MeV [MeV] uncertainty=0.000 0058. proton_mass_in_u; 1.007276466879; proton mass in u [u] uncertainty=0.000 000 000 091. proton_molar_mass; 0.001007276466879; proton molar mass [kg mol^{-1}] uncertainty=0.000 000 000 091 e-3. proton_muon_mass_ratio; 8.88024338; proton-muon mass ratio [] uncertainty=0.000 000 20. proton_neutron_mag_mom_ratio; -1.45989805; proton-neutron mag. mom. ratio [] uncertainty=0.000 000 34. proton_neutron_mass_ratio; 0.99862347844; proton-neutron mass ratio [] uncertainty=0.000 000 000 51. proton_rms_charge_radius; 8.751E-16; proton rms charge radius [m] uncertainty=0.0061 e-15. proton_tau_mass_ratio; 0.528063; proton-tau mass ratio [] uncertainty=0.000 048. quantum_of_circulation; 0.00036369475486; quantum of circulation [m^2 s^{-1}] uncertainty=0.000 000 0017 e-4. quantum_of_circulation_times_2; 0.00072738950972; quantum of circulation times 2 [m^2 s^{-1}] uncertainty=0.000 000 0033 e-4. Rydberg_constant; 10973731.568508; Rydberg constant [m^{-1}] uncertainty=0.000 065. Rydberg_constant_times_c_in_Hz; 3.289841960355E+15; Rydberg constant times c in Hz [Hz] uncertainty=0.000 000 000 019 e15. Rydberg_constant_times_hc_in_eV; 13.605693009; Rydberg constant times hc in eV [eV] uncertainty=0.000 000 084. Rydberg_constant_times_hc_in_J; 2.179872325E-18; Rydberg constant times hc in J [J] uncertainty=0.000 000 027 e-18. Sackur_Tetrode_constant_1_K_100_kPa; -1.1517084; Sackur-Tetrode constant (1 K, 100 kPa) [] uncertainty=0.000 0014. Sackur_Tetrode_constant_1_K_101325_kPa; -1.1648714; Sackur-Tetrode constant (1 K, 101.325 kPa) []",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodoc_physconst-1.html:30960,charge,charge,30960,psi4manual/1.3.2/autodoc_physconst-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodoc_physconst-1.html,11,['charge'],['charge']
Energy Efficiency," mass(self, atom):; """"""Returns mass of atom (0-indexed). >>> print H2OH2O.mass(4); 1.00782503207. """"""; if self.atoms[atom].mass() != 0.0:; return self.atoms[atom].mass(). if math.fabs(self.atoms[atom].Z() - int(self.atoms[atom].Z())) > 0.0:; print(""""""WARNING: Obtaining masses from atom with fractional charge...may be incorrect!!!\n""""""); # TODO outfile; return z2mass[int(self.atoms[atom].Z())]. [docs] def symbol(self, atom):; """"""Returns the cleaned up label of the atom (C2 => C, H4 = H) (0-indexed). >>> print H2OH2O.symbol(4); H. """"""; return self.atoms[atom].symbol(). [docs] def label(self, atom):; """"""Returns the original label of the atom (0-indexed) as given in the input file (C2, H4). (0-indexed). >>> print H2OH2O.label(4); H3. """"""; return self.atoms[atom].label(). [docs] def charge(self, atom):; """"""Returns charge of atom (0-indexed).; Related to SAD guess in libmints version. >>> print H2OH2O.charge(4); 1.0. """"""; return self.atoms[atom].charge(). [docs] def fZ(self, atom):; """"""Nuclear charge of atom (includes dummies). >>> print H2OH2O.fZ(4); 8. """"""; return self.full_atoms[atom].Z(). [docs] def fx(self, atom):; """"""x position of atom (0-indexed, includes dummies) in Bohr. >>> print H2OH2O.fx(4); 2.55231135823. """"""; return self.input_units_to_au * self.full_atoms[atom].compute()[0]. [docs] def fy(self, atom):; """"""y position of atom (0-indexed, includes dummies) in Bohr. >>> print H2OH2O.fy(4); 0.210645882307. """"""; return self.input_units_to_au * self.full_atoms[atom].compute()[1]. [docs] def fz(self, atom):; """"""z position of atom (0-indexed, includes dummies) in Bohr. >>> print H2OH2O.fz(4); 0.0. """"""; return self.input_units_to_au * self.full_atoms[atom].compute()[2]. [docs] def fxyz(self, atom):; """"""Returns a Vector3 with x, y, z position of atom; (0-indexed) in Bohr (includes dummies). >>> print H2OH2O.fxyz(4); [2.5523113582286716, 0.21064588230662976, 0.0]. """"""; return scale(self.full_atoms[atom].compute(), self.input_units_to_au). [docs] def fmass(self, atom):;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:9450,charge,charge,9450,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,1,['charge'],['charge']
Energy Efficiency," mass; coordinates in the XYZABC format and all coordinates in the POINTS format are; taken to be in Angstroms by default or in Bohr if units au is present.; Charge and multiplicity specifications are encoded in the fragment file; and so are not read from input.; Any combination of EFP and QM fragments can be placed in a molecule; even; the oddity below is legitimate. Note that symmetry and reorientation are; automatically turned off when EFP fragments are present (symmetry c1; and no_com and no_reorient are implied).; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17molecule qmefp {; efp nh3 0.0 0.0 5.0 5 2 8; --; C 0.0 0.0 0.0; O 0.0 1.5 0.0; O 0.0 -1.5 0.0; --; efp h2o 5.0 0.0 0.0 5 2 8; --; He -3.0 4.0 4.0; He -4.0 5.0 4.0; --; efp ch3oh; 1.275 -2.447 -4.673; 0.709 -3.191 -3.592; 2.213 -1.978 -4.343; }. Running EFP¶; EFP can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the EFP interaction energy for benzene and two waters,; simply provide the following:; 1; 2; 3; 4; 5; 6; 7; 8; 9molecule {; efp c6h6 0.0 0.0 0.0 0.0 0.0 0.0; --; efp h2o 4.0 0.0 0.0 0.0 0.0 0.0; --; efp h2o -4.0 0.0 0.0 0.0 0.0 0.0; }. energy('efp'). This computation involves purely EFP/EFP fragment interactions and is; performed entirely by the LIBEFP library. PSI4 can also handle mixed; systems of quantum mechanical (QM) and EFP fragments through the native; SCF code augmented by calls to the LIBEFP library. For; example, turning one of the waters in the example above into a QM; fragment is shown below.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12molecule {; efp c6h6 0.0 0.0 0.0 0.0 0.0 0.0; --; O 4.0 0.0 0.0; H 4.7 0.7 0.0; H 3.3 -0.7 0.0; --; efp h2o -4.0 0.0 0.0 0.0 0.0 0.0; }. set basis 6-31g; energy('scf'). Whenever an EFP fragment is present in the active molecule, the SCF energy; will include EFP contributions. Warning; Although the EFP geometry is specified alongside the QM; geometry in a molecule name {...} block, internally the",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/libefp-1.html:4924,energy,energy,4924,psi4manual/1.1.0/libefp-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/libefp-1.html,6,['energy'],['energy']
Energy Efficiency," matrices with derivative integrals, to compute gradients.; ; detci(...); detci() -> float :; Runs the determinant-based configuration interaction code.; ; dfmp2(...); dfmp2() -> float :; Runs the DF-MP2 code.; ; dfmp2grad(...); dfmp2grad() -> float :; Runs the DF-MP2 gradient.; ; fd_1_0(...); fd_1_0( (list)arg1) -> PsiReturnType :; Performs a finite difference gradient computation, from energy points.; ; fd_freq_0(...); fd_freq_0( (list)arg1, (int)arg2) -> PsiReturnType :; Performs a finite difference frequency computation, from energy points, for a given irrep.; ; fd_freq_1(...); fd_freq_1( (list)arg1, (int)arg2) -> PsiReturnType :; Performs a finite difference frequency computation, from gradients, for a given irrep.; ; fd_geoms_1_0(...); fd_geoms_1_0() -> matrix_vector :; Gets the list of displacements needed for a finite difference gradient computation, from energy points.; ; fd_geoms_freq_0(...); fd_geoms_freq_0( (int)arg1) -> matrix_vector :; Gets the list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep.; ; fd_geoms_freq_1(...); fd_geoms_freq_1( (int)arg1) -> matrix_vector :; Gets the list of displacements needed fof a finite difference frequency computation, from gradients, for a given irrep; ; fd_geoms_hessian_0(...); fd_geoms_hessian_0() -> matrix_vector :; Gets the list of displacements needed fof a finite difference frequency computation, from energy points.; ; fd_hessian_0(...); fd_hessian_0( (list)arg1) -> PsiReturnType :; Performs a finite difference frequency computation, from energy points.; ; flush_outfile(...); flush_outfile() -> None :; Flushes the output file.; ; fnocc(...); fnocc() -> float :; Runs the fno-ccsd(t)/qcisd(t)/mp4/cepa energy code; ; get_active_molecule(...); get_active_molecule() -> Molecule :; Returns the currently active molecule object.; ; get_frequencies(...); get_frequencies() -> Vector :; Returns the most recently computed frequencies, as a 3N-6 Vector object.; ; g",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/psimod-1.html:156647,energy,energy,156647,psi4manual/4.0b5/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/psimod-1.html,2,['energy'],['energy']
Energy Efficiency," matrices with derivative integrals, to compute gradients.; ; detci(...); detci() -> float :; Runs the determinant-based configuration interaction code.; ; dfmp2(...); dfmp2() -> float :; Runs the DF-MP2 code.; ; dfmp2grad(...); dfmp2grad() -> float :; Runs the DF-MP2 gradient.; ; fd_1_0(...); fd_1_0( (list)arg1) -> PsiReturnType :; Performs a finite difference gradient computation, from energy points.; ; fd_freq_0(...); fd_freq_0( (list)arg1, (int)arg2) -> PsiReturnType :; Performs a finite difference frequency computation, from energy points, for a given irrep.; ; fd_freq_1(...); fd_freq_1( (list)arg1, (int)arg2) -> PsiReturnType :; Performs a finite difference frequency computation, from gradients, for a given irrep.; ; fd_geoms_1_0(...); fd_geoms_1_0() -> matrix_vector :; Gets the list of displacements needed for a finite difference gradient computation, from energy points.; ; fd_geoms_freq_0(...); fd_geoms_freq_0( (int)arg1) -> matrix_vector :; Gets the list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep.; ; fd_geoms_freq_1(...); fd_geoms_freq_1( (int)arg1) -> matrix_vector :; Gets the list of displacements needed fof a finite difference frequency computation, from gradients, for a given irrep; ; fd_geoms_hessian_0(...); fd_geoms_hessian_0() -> matrix_vector :; Gets the list of displacements needed fof a finite difference frequency computation, from energy points.; ; fd_hessian_0(...); fd_hessian_0( (list)arg1) -> PsiReturnType :; Performs a finite difference frequency computation, from energy points.; ; flush_outfile(...); flush_outfile() -> None :; Flushes the output file.; ; get_active_molecule(...); get_active_molecule() -> Molecule :; Returns the currently active molecule object.; ; get_global_option(...); get_global_option( (str)arg1) -> object :; Given a string of a keyword name, returns the value associated with the keyword from the global options. Returns error if keyword is not recognized.;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/psimod-1.html:106434,energy,energy,106434,psi4manual/4.0b3/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html,2,['energy'],['energy']
Energy Efficiency," matrix = array_to_matrix(irrep_data); >>> print matrix.rowspi().to_tuple(); (2, 0, 4). classmethod from_serial(json_data)¶; Converts serialized data to the correct Psi4 data type. gemm(self: psi4.core.Matrix, arg0: bool, arg1: bool, arg2: float, arg3: psi4.core.Matrix, arg4: psi4.core.Matrix, arg5: float) → None¶; docstring. get(*args, **kwargs)¶; Overloaded function. get(self: psi4.core.Matrix, arg0: int, arg1: int, arg2: int) -> float. docstring. get(self: psi4.core.Matrix, arg0: int, arg1: int) -> float. docstring. identity(self: psi4.core.Matrix) → None¶; docstring. invert(self: psi4.core.Matrix) → None¶; docstring. load(self: psi4.core.Matrix, arg0: str) → None¶; docstring. load_mpqc(self: psi4.core.Matrix, arg0: str) → None¶; docstring. nirrep(self: psi4.core.Matrix) → int¶; docstring. classmethod np_read(filename, prefix='')¶. np_write(filename=None, prefix='')¶. partial_cholesky_factorize(self: psi4.core.Matrix, arg0: float, arg1: bool) → psi4.core.Matrix¶; docstring. power(self: psi4.core.Matrix, arg0: float, arg1: float) → psi4.core.Dimension¶; docstring. print_out(self: psi4.core.Matrix) → None¶; docstring. project_out(self: psi4.core.Matrix, arg0: psi4.core.Matrix) → None¶; docstring. remove_symmetry(self: psi4.core.Matrix, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix) → None¶; docstring. rms(self: psi4.core.Matrix) → float¶; docstring. rotate_columns(self: psi4.core.Matrix, arg0: int, arg1: int, arg2: int, arg3: float) → None¶; docstring. rowdim(self: psi4.core.Matrix) → psi4.core.Dimension¶; docstring. rows(self: psi4.core.Matrix, arg0: int) → int¶; docstring. save(self: psi4.core.Matrix, arg0: str, arg1: bool, arg2: bool, arg3: bool) → None¶; docstring. scale(self: psi4.core.Matrix, arg0: float) → None¶; docstring. scale_column(self: psi4.core.Matrix, arg0: int, arg1: int, arg2: float) → None¶; docstring. scale_row(self: psi4.core.Matrix, arg0: int, arg1: int, arg2: float) → None¶; docstring. schmidt(self: psi4.core.Matrix) → None¶. set(*args, **kw",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/api/psi4.core.matrix.html:6888,power,power,6888,psi4manual/1.1.0/api/psi4.core.matrix.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.matrix.html,1,['power'],['power']
Energy Efficiency," matrix in Helgaker’s language. Defaults to a JKFIT basis. Type: string; Possible Values: basis string; Default: No Default. MCSCF_ALGORITHM¶. Convergence algorithm to utilize. Two-Step, Augmented Hessian, or One-Step. Defaults to TS for RASSCF. Type: string; Possible Values: TS, AH; Default: TS. MCSCF_CI_CLEANUP¶. Cleanup the CI info at the end of a run?. Type: boolean; Default: true. MCSCF_DIIS_ERROR_TYPE¶. DIIS error vector type either, the AO orbital gradient or the orbital rotation update matrix. Type: string; Possible Values: GRAD, UPDATE; Default: GRAD. MCSCF_DIIS_FREQ¶. How often to do a DIIS extrapolation for TS convergence. Type: integer; Default: 1. MCSCF_DIIS_MAX_VECS¶. Maximum number of DIIS vectors for TS convergence. Type: integer; Default: 8. MCSCF_DIIS_START¶. Iteration to turn on DIIS for TS convergence. Type: integer; Default: 3. MCSCF_DPD_CLEANUP¶. Cleanup the DPD MCSCF object at the end of a run?. Type: boolean; Default: true. MCSCF_E_CONVERGENCE¶. Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-7. MCSCF_GUESS¶. Initial MCSCF starting guess, MP2 natural orbitals only available for DF-RHF reference. Type: string; Possible Values: MP2, SCF; Default: SCF. MCSCF_MAXITER¶. Maximum number MCSCF of iterations. Type: integer; Default: 30. MCSCF_MAX_ROT¶. Maximum value in the rotation matrix. If a value is greater than this number all values are scaled. Type: double; Default: 0.5. MCSCF_ROTATE¶. Apply a list of 2x2 rotation matrices to the orbitals in the form of [irrep, orbital1, orbital2, theta] where an angle of 0 would do nothing and an angle of 90 would switch the two orbitals. Type: array; Default: No Default. MCSCF_R_CONVERGENCE¶. Convergence criterion for the RMS of the orbital gradient. Type: conv double; Default: 1e-5. MCSCF_SO_START_E¶. Start second-order (AH or OS) orbital-orbital MCSCF based on energy convergence. Type: double; D",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__detci-1.html:10597,energy,energy,10597,psi4manual/1.3.2/autodir_options_c/module__detci-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__detci-1.html,7,['energy'],['energy']
Energy Efficiency," max_holes_I, max_parts_IV, max_I+IV], [ex_lvl, max_holes_I, max_parts_IV, max_I+IV], ... ] Optional additional restrictions on allowed excitations in coupled-cluster computations, based on macroconfiguration selection. For each sub-array, [ex_lvl, max_holes_I, max_parts_IV, max_I+IV], eliminate cluster amplitudes in which: [the excitation level (holes in I + II) is equal to ex_lvl] AND [there are more than max_holes_I holes in RAS I, there are more than max_parts_IV particles in RAS IV, OR there are more than max_I+IV quasiparticles in RAS I + RAS IV]. Type: array; Default: No Default. CC_MIXED¶. Do ignore block if num holes in RAS I and II is \(>\) cc_ex_lvl and if any indices correspond to RAS I or IV (i.e., include only all-active higher excitations)?. Type: boolean; Default: true. CC_UPDATE_EPS¶. Do update T amplitudes with orbital eigenvalues? (Usually would do this). Not doing this is experimental. Type: boolean; Default: true. CC_VARIATIONAL¶. Do use variational energy expression in CC computation? Experimental. Type: boolean; Default: false. Expert Alternative Algorithms¶. BENDAZZOLI¶. Do use some routines based on the papers of Bendazzoli et al. to calculate sigma? Seems to be slower and not worthwhile; may disappear eventually. Works only for full CI and I don’t remember if I could see how their clever scheme might be extended to RAS in general. Type: boolean; Default: false. FCI_STRINGS¶. Do store strings specifically for FCI? (Defaults to TRUE for FCI.). Type: boolean; Default: false. REPL_OTF¶. Do string replacements on the fly in DETCI? Can save a gigantic amount of memory (especially for truncated CI’s) but is somewhat flaky and hasn’t been tested for a while. It may work only works for certain classes of RAS calculations. The current code is very slow with this option turned on. Type: boolean; Default: false. table of contents. DETCI; General Options; AVG_STATES; AVG_WEIGHTS; A_RAS3_MAX; B_RAS3_MAX; CALC_S_SQUARED; CIBLKS_PRINT; CI_MAXITER; DETCI_FR",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/module__detci-1.html:21235,energy,energy,21235,psi4manual/1.1.0/autodir_options_c/module__detci-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/module__detci-1.html,2,['energy'],['energy']
Energy Efficiency," maximum number of electrons in RAS IV, for CC. Type: integer; Default: -1. CC_SCALE_OS (FNOCC)¶FNOCC — Oppposite-spin scaling factor for SCS-CCSD. Type: double; Default: 1.27. CC_SCALE_SS (FNOCC)¶FNOCC — Same-spin scaling factor for SCS-CCSD. Type: double; Default: 1.13. CC_SS_SCALE (CCENERGY)¶CCENERGY — Coupled-cluster same-spin scaling value. Type: double; Default: 1.13. CC_TIMINGS (FNOCC)¶FNOCC — Do time each cc diagram?. Type: boolean; Default: false. CC_TYPE (GLOBALS)¶GLOBALS — Algorithm to use for CC or CEPA computation (e.g., CCD, CCSD(T), CEPA(3), ACPF, REMP). See Cross-module Redundancies for details. Type: string; Possible Values: DF, CONV, CD; Default: CONV. CC_UPDATE_EPS (DETCI)¶DETCI (Expert) — Do update T amplitudes with orbital eigenvalues? (Usually would do this). Not doing this is experimental. Type: boolean; Default: true. CC_VAL_EX_LEVEL (DETCI)¶DETCI — The CC valence excitation level. Type: integer; Default: 0. CC_VARIATIONAL (DETCI)¶DETCI (Expert) — Do use variational energy expression in CC computation? Experimental. Type: boolean; Default: false. CC_VECS_READ (DETCI)¶DETCI — Do import a CC vector from disk?. Type: boolean; Default: false. CC_VECS_WRITE (DETCI)¶DETCI — Do export a CC vector to disk?. Type: boolean; Default: false. CCD_E_CONVERGENCE (SAPT)¶SAPT — E converge value for CCD. Type: conv double; Default: 1e-8. CCD_MAXITER (SAPT)¶SAPT — Max CCD iterations. Type: integer; Default: 50. CCD_T_CONVERGENCE (SAPT)¶SAPT — Convergence tolerance for CCD amplitudes. Type: conv double; Default: 1e-8. CCL_ENERGY (OCC)¶OCC — Do compute CC Lambda energy? In order to this option to be valid one should use “TPDM_ABCD_TYPE = COMPUTE” option. Type: boolean; Default: false. CEPA_LEVEL (FNOCC)¶FNOCC (Expert) — Which coupled-pair method is called? This parameter is used internally by the python driver. Changing its value won’t have any effect on the procedure. Type: string; Default: CEPA(0). CEPA_NO_SINGLES (FNOCC)¶FNOCC — Flag to exclude singly excited ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_glossary_options_c.html:16216,energy,energy,16216,psi4manual/1.7.x/autodoc_glossary_options_c.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_glossary_options_c.html,4,['energy'],['energy']
Energy Efficiency," maximum number of iterations and is the number of roots. Type: string; Possible Values: RSP, OLSEN, MITRUSHENKOV, DAVIDSON, SEM, SEMTEST; Default: SEM. DIAGONAL_CCSD_T (PSIMRCC); PSIMRCC — Do include the diagonal corrections in (T) computations?. Type: boolean; Default: true. DIAGONALIZE_HEFF (PSIMRCC); PSIMRCC — Do diagonalize the effective Hamiltonian?. Type: boolean; Default: false. DIIS (CCENERGY); CCENERGY — Do use DIIS extrapolation to accelerate convergence?. Type: boolean; Default: true. DIIS (CCLAMBDA); CCLAMBDA — Do use DIIS extrapolation to accelerate convergence?. Type: boolean; Default: true. DIIS (CCRESPONSE); CCRESPONSE — Do use DIIS extrapolation to accelerate convergence?. Type: boolean; Default: true. DIIS (DETCI); DETCI — Do use DIIS extrapolation to accelerate CC convergence?. Type: boolean; Default: true. DIIS (LMP2); LMP2 — Do use DIIS extrapolation to accelerate convergence?. Type: boolean; Default: true. DIIS (MCSCF); MCSCF — Do use DIIS extrapolation to accelerate convergence of the SCF energy (MO coefficients only)?. Type: boolean; Default: true. DIIS (SCF); SCF — Do use DIIS extrapolation to accelerate convergence?. Type: boolean; Default: true. DIIS_FREQ (DETCI); DETCI — How often to do a DIIS extrapolation. 1 means do DIIS every iteration, 2 is every other iteration, etc. Type: integer; Default: 1. DIIS_MAX_VECS (DCFT); DCFT — Maximum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 6. DIIS_MAX_VECS (DETCI); DETCI — Maximum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 5. DIIS_MAX_VECS (LMP2); LMP2 — Maximum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 5. DIIS_MAX_VECS (MCSCF); MCSCF — Maximum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 7. DIIS_MAX_VECS (OMP2); OMP2 — Number of vectors used in DIIS. Type: integer; Default: 4. DIIS_MAX_VECS (PSIMRCC); PSIMRCC — Maximum number of error vectors stored for DIIS ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodoc_glossary_options_c-1.html:23821,energy,energy,23821,psi4manual/4.0b2/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodoc_glossary_options_c-1.html,2,['energy'],['energy']
Energy Efficiency," maximum number of iterations, try increasing; SOLVER_MAXITER. External potentials and QM/MM¶; In addition to the implementation of EFP for accurate QM/MM; computations, Psi4 can perform more rudimentary QM/MM procedures via the; EXTERN keyword. The following snippet, extracted from the; extern1 test case, demonstrates its use for a TIP3P external potential:; Chrgfield = QMMM(); Chrgfield.extern.addCharge(-0.834, 1.649232019048, 0.0, -2.356023604706); Chrgfield.extern.addCharge( 0.417, 0.544757019107, 0.0, -3.799961446760); Chrgfield.extern.addCharge( 0.417, 0.544757019107, 0.0, -0.912085762652); psi4.set_global_option_python('EXTERN',Chrgfield.extern). First a QMMM object is created, then three separate particles are added to this; object before the SCF code is told about its existence on the last line. The; calls to addCharge take the atomic charge, x coordinate, y coordinate, and; z coordinate in that order. The atomic charge is specified in atomic units,; and the coordinates always use the same units as the geometry specification in; the regular QM region. Additional MM molecules may be specified by adding; extra calls to addCharge to describe the full MM region. Convergence and Algorithm Defaults¶. SCF algorithm and convergence criteria defaults by calculation type [1]¶. Ab Initio Method; Calculation Type; E_CONVERGENCE; D_CONVERGENCE; SCF_TYPE. SCF of HF or DFT; energy; 6; 6; DF. optimization; 8; 8. frequency [7]; 8; 8. SCF of post-HF; energy; 8; 8; PK [3]. optimization; 10; 10. frequency [7]; 10; 10. CC property [2]; 10; 10. Post-SCF convergence criteria defaults by calculation type [4]¶. Ab Initio Method; Calculation Type; E_CONVERGENCE [5]; R_CONVERGENCE [6]. post-HF of post-HF; energy; 6;  . optimization; 8;  . frequency [7]; 8;  . CC property [2]; 8;  . Footnotes. [1]Note that this table applies only the SCF module,; not to the final convergence criteria for post-HF methods or to methods; that use an alternate starting point, like MCSCF. SAPT computations",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/scf-1.html:30121,charge,charge,30121,psi4manual/1.0.0/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/scf-1.html,2,['charge'],['charge']
Energy Efficiency," may arise in the course; of an optimization. In such cases, try restarting from the most recent geometry.; Alternatively, setting OPT_COORDINATES to cartesian will avoid any internal; coordinate difficulties altogether. These coordinate changes can be automatically; performed by turning DYNAMIC_LEVEL to 1. Warning; In some cases, such as the coordinate issues described above, optking will reset to maintain; a consistent history. If an error occurs in Psi4 due to GEOM_MAXITER being exceeded but; the final step report indicates that optking has not taken GEOM_MAXITER steps, such a; reset has occured. Inspection will show that the step counter was reset to 1 somewhere in the; optimization. Convergence Criteria¶; Optking monitors five quantities to evaluate the progress of a geometry; optimization. These are (with their keywords) the change in energy; (MAX_ENERGY_G_CONVERGENCE), the maximum element of; the gradient (MAX_FORCE_G_CONVERGENCE), the root-mean-square; of the gradient (RMS_FORCE_G_CONVERGENCE), the maximum element; of displacement (MAX_DISP_G_CONVERGENCE), and the; root-mean-square of displacement (RMS_DISP_G_CONVERGENCE),; all in internal coordinates and atomic units. Usually, these options will not; be set directly. Primary control for geometry convergence lies with the keyword; G_CONVERGENCE which sets the aforementioned in accordance; with Table Geometry Convergence. Summary of sets of geometry optimization criteria available in PSI4¶. G_CONVERGENCE; Max Energy; Max Force; RMS Force; Max Disp; RMS Disp. NWCHEM_LOOSE [4]. \(4.5 \times 10^{-3}\); \(3.0 \times 10^{-3}\); \(5.4 \times 10^{-3}\); \(3.6 \times 10^{-3}\). GAU_LOOSE [6]. \(2.5 \times 10^{-3}\); \(1.7 \times 10^{-3}\); \(1.0 \times 10^{-2}\); \(6.7 \times 10^{-3}\). TURBOMOLE [4]; \(1.0 \times 10^{-6}\); \(1.0 \times 10^{-3}\); \(5.0 \times 10^{-4}\); \(1.0 \times 10^{-3}\); \(5.0 \times 10^{-4}\). GAU [3] [6]. \(4.5 \times 10^{-4}\); \(3.0 \times 10^{-4}\); \(1.8 \times 10^{-3}\); \(1.2 \times 10",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/optking.html:18347,energy,energy,18347,psi4manual/1.7.x/optking.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/optking.html,4,['energy'],['energy']
Energy Efficiency," may; want to have more control over the SCF procedure. You have the option of; doing the driver job in the input file, by performing the dimer and monomer computations; yourself. In the example below, we do a stability analysis for the open-shell monomer only; molecule {; 0 2; O 0.000000 0.000000 0.000000; O 0.000000 2.503900 0.000000; H 0.000000 -0.424700 -1.839500; --; 0 1; O 0.000000 0.000000 6.000000; H 0.000000 1.431500 4.890600; H 0.000000 -1.431500 4.890600; units bohr; symmetry c1; no_reorient; no_com; }. dimer = psi4.get_active_molecule(). set {; reference uhf; scf_type df; basis cc-pVDZ; df_basis_sapt cc-pVDZ-ri; guess sad; }. dimer = psi4.get_active_molecule(). set df_ints_io save; psi4.IO.set_default_namespace('dimer'); Edim, wfn_dimer = energy('scf',molecule=dimer,return_wfn=True); set df_ints_io load. monomerA = dimer.extract_subsets(1,2); psi4.IO.change_file_namespace(97, 'dimer', 'monomerA'); psi4.IO.set_default_namespace('monomerA'); set {; stability_analysis follow; }; EmonA, wfn_monA = energy('scf',molecule=monomerA,return_wfn=True). monomerB = dimer.extract_subsets(2,1); psi4.IO.change_file_namespace(97, 'monomerA', 'monomerB'); psi4.IO.set_default_namespace('monomerB'); set {; stability_analysis none; }; EmonB, wfn_monB = energy('scf',molecule=monomerB,return_wfn=True). psi4.IO.change_file_namespace(97, 'monomerB', 'dimer'); psi4.IO.set_default_namespace('dimer'). aux_basis = psi4.core.BasisSet.build(wfn_dimer.molecule(), ""DF_BASIS_SAPT"",; psi4.core.get_global_option(""DF_BASIS_SAPT""),; ""RIFIT"", psi4.core.get_global_option(""BASIS"")); wfn_dimer.set_basisset(""DF_BASIS_SAPT"", aux_basis); wfn_dimer.set_basisset(""DF_BASIS_ELST"", aux_basis). psi4.sapt(wfn_dimer,wfn_monA,wfn_monB). In this way, any of the SCF options can be tweaked for individual fragments.; For optimal efficiency, the example uses set df_ints_io save to keep file 97,; which contains the three-index integrals for density fitting. set df_ints_io load; then instructs the program to read ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/sapt-1.html:14590,energy,energy,14590,psi4manual/1.4.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/sapt-1.html,9,['energy'],['energy']
Energy Efficiency, method for which the correlation energy is to be; obtained. Can also be specified with name or as the unlabeled; first argument to the function. delta_wfn (string) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. delta_wfn_lesser (string) – \(\Rightarrow\) corl_wfn \(\Leftarrow\) || 'mp2' || etc.; Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. delta2_wfn (string) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. delta2_wfn_lesser (string) – \(\Rightarrow\) delta_wfn \(\Leftarrow\) || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. delta3_wfn (string) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a third delta correction; to the correlation energy is to be obtained. delta3_wfn_lesser (string) – \(\Rightarrow\) delta2_wfn \(\Leftarrow\) || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a third delta correction; to the correlation energy is to be obtained. delta4_wfn (string) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a fourth delta correction; to the correlation energy is to be obtained. delta4_wfn_lesser (string) – \(\Rightarrow\) delta3_wfn \(\Leftarrow\) || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a fourth delta correction; to the correlation energy is to be obtained. delta5_wfn (string) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a fifth delta correction; to the correlation energy is to be obtained. delta5_wfn_lesser (string) – \(\Rightarrow\) delta4_wfn \(\Leftarrow\) || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a fifth delta correction; to the ,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/cbs-1.html:4909,energy,energy,4909,psi4manual/1.2.1/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/cbs-1.html,14,['energy'],['energy']
Energy Efficiency," methods can run with a minimal input and set symmetry. cbs-xtpl-nbody; RHF interaction energies using nbody and cbs parts of the driver Ne dimer with mp2/v[dt]z + d:ccsd(t)/vdz. dfep2-2; Compute three IP and 2 EA’s for the PH3 molecule. mints8; Patch of a glycine with a methyl group, to make alanine, then DF-SCF energy calculation with the cc-pVDZ basis set. cc44; Test case for some of the PSI4 out-of-core codes. The code is given only 2.0 MB of memory, which is insufficient to hold either the A1 or B2 blocks of an ovvv quantity in-core, but is sufficient to hold at least two copies of an oovv quantity in-core. cc54; CCSD dipole with user-specified basis set. dfccd-grad1; DF-CCSD cc-pVDZ gradients for the H2O molecule. mints1; Symmetry tests for a range of molecules. This doesn’t actually compute any energies, but serves as an example of the many ways to specify geometries in Psi4. fcidump; test FCIDUMP functionality for rhf/uhf. cc8c; ROHF-CCSD cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Cartesian input. scf-hess3; CONV SCF 6-31G analytical vs finite-difference tests Tests UHF hessian code for Ca != Cb. cc27; Single point gradient of 1-1B2 state of H2O with EOM-CCSD. rasci-ne; Ne atom RASCI/cc-pVQZ Example of split-virtual CISD[TQ] from Sherrill and Schaefer, J. Phys. Chem. XXX This uses a “primary” virtual space 3s3p (RAS 2), a “secondary” virtual space 3d4s4p4d4f (RAS 3), and a “tertiary” virtual space consisting of the remaining virtuals. First, an initial CISD computation is run to get the natural orbitals; this allows a meaningful partitioning of the virtual orbitals into groups of different importance. Next, the RASCI is run. The split-virtual CISD[TQ] takes all singles and doubles, and all triples and quadruples with no more than 2 electrons in the secondary virtual subspace (RAS 3). If any electrons are present in the tertiary virtual subspace (RAS 4), then that excitation is only allowed if it is a single or double. scf-",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html:3934,energy,energy,3934,psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency," methods for the H2 molecule. isapt2; This is a shorter version if isapt1 - does not do cube plots. See isapt1 for full details. scf-hess5; DF SCF 6-31G analytical vs finite-difference tests Tests DF UHF hessian code for Ca != Cb. cc43; RHF-CC2-LR/STO-3G optical rotation of (S)-methyloxirane. gauge = both, omega = (589 355 nm). pywrap-molecule; Check that C++ Molecule class and qcdb molecule class are reading molecule input strings identically. dfmp2-3; DF-MP2 cc-pVDZ frozen core gradient of benzene, computed at the DF-SCF cc-pVDZ geometry. castup2; SCF with various combinations of pk/density-fitting, castup/no-castup, and spherical/cartesian settings. Demonstrates that puream setting is getting set by orbital basis for all df/castup parts of calc. Demonstrates that answer doesn’t depend on presence/absence of castup. Demonstrates (by comparison to castup3) that output file doesn’t depend on options (scf_type) being set global or local. This input uses global. sapt-ecp; sapt0 of charged system in ECP basis set. ci-property; CI/MCSCF cc-pvDZ properties for Potassium nitrate (rocket fuel!). sapt10; usapt example with empty beta due to frozen core. scf-hess1; RHF STO-3G (Cartesian) and cc-pVDZ (spherical) water Hessian test, against Psi3 reference values. fnocc2; Test G2 method for H2O. olccd3; OLCCD cc-pVDZ energy with ROHF initial guess for the NO radical. freq-isotope2; Vibrational and thermo analysis of several water isotopologs. Demonstrates Hessian reuse for different temperatures, pressures, and isotopologs. dft-freq; Frequencies for H2O B3LYP/6-31G* at optimized geometry. props3; DF-SCF cc-pVDZ multipole moments of benzene, up to 7th order and electrostatic potentials evaluated at the nuclear coordinates. mints15; check SP basis Fortran exponent parsing. dct1; DC-06, DC-12, ODC-06 and ODC-12 calculation for the He dimer. This performs a simultaneous update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the MO Basis",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html:34446,charge,charged,34446,psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,4,['charge'],['charged']
Energy Efficiency," methods with DF and CD integrals (MP/CC Methods DFOCC keywords). Theory¶; What follows is a very basic description of orbital-optimized Møller–Plesset perturbation; theory as implemented in Psi4. We will follow our previous presentations ([Bozkaya:2011:omp2],; [Bozkaya:2011:omp3], and [Bozkaya:2012:odtl]); The orbital variations may be expressed by means of an exponential unitary operator. where is the orbital rotation operator. The effect of the orbital rotations on the MO coefficients can be written as. where is the initial MO coefficient matrix and is the new; MO coefficient matrix as a function of .; Now, let us define a variational energy functional (Lagrangian) as a function of . OMP2. OMP3. OLCCD. where subscript c means only connected diagrams are allowed, and; , , and defined as. where , and are the one- and two-electron components of normal-ordered Hamiltonian. Then,; first and second derivatives of the energy with respect to the parameter at . Then the energy can be expanded up to second-order as follows. where is the MO gradient vector, is the MO rotation vector,; and is the MO Hessian matrix. Therefore, minimizing the energy with respect to ; yields. This final equation corresponds to the usual Newton-Raphson step.; Publications resulting from the use of the orbital-optimized code should cite the following publications:. OMP2 [Bozkaya:2011:omp2] and [Bozkaya:2013:omp2grad]; OMP3 [Bozkaya:2011:omp3] , [Bozkaya:2013:omp3], and [Bozkaya:2013:omp3grad]; OMP2.5 [Bozkaya:2011:omp3]; OLCCD [Bozkaya:2013:ocepa]; LCCD [Bozkaya:2013:ocepa]. Convergence Problems¶; For problematic open-shell systems, we recommend to use the ROHF or DFT orbitals as an initial guess for orbital-optimized methods. Both ROHF and; DFT orbitals may provide better initial guesses than UHF orbitals, hence convergence may be significantly speeded up with ROHF or DFT orbitals.; In order to use ROHF orbitals we can simply use “reference rohf” option. For DFT orbitals one should use “reference",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/occ-1.html:5075,energy,energy,5075,psi4manual/1.0.0/occ-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/occ-1.html,2,['energy'],['energy']
Energy Efficiency," methods:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17# MP2 with a PBE0 reference computation. molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; basis 6-31G; dft_spherical_points 302; dft_radial_points 99; reference rks; }. mp2_dft = energy(""MP2"", dft_functional=""PBE0""). Note that this would only update the generic Psi variables (e.g., “CURRENT ENERGY”) and not the MP2 or DFT variables.; Psi4 also supports easy customization and manipulation of DFT functionals. The values of alpha and omega can be adjusted with the DFT_ALPHA; and DFT_OMEGA keywords. For example, for LRC functionals, one can control the fraction of long-range Hartree-Fock and short-range DFA by changing DFT_OMEGA:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22molecule ch2 {; 0 3; C; H 1 R; H 1 R 2 A. R = 1.075; A = 133.93; }. set reference uhf; set guess gwh; set basis cc-pvdz; set e_convergence 8. # Override the default value of omega; set dft_omega 2.0. E = energy('wb97x'). # Revoke the change for later computations if needed; revoke_global_option_changed('DFT_OMEGA'). This feature would be useful after finishing IP fitting procedure, for example.; Furthermore, new DFT functionals can be created from scratch from within the input file:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28# DFT Custom Functional. molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; basis sto-3g; dft_spherical_points 302; dft_radial_points 99; reference rks; }. pbe0 = {; ""name"": ""my_PBE0"",; ""x_functionals"": {""GGA_X_PBE"": {""alpha"": 0.75}},; ""x_hf"": {""alpha"": 0.25},; ""c_functionals"": {""GGA_C_PBE"": {}}; }. func_call = energy('SCF', dft_functional=pbe0). # as PBE0 is a pre-defined functional, the call above is equivalent to both below:; func_call = energy('SCF', dft_functional=""PBE0""); func_call = energy('PBE0'). Supported keywords include:. name: string, name of the functional, for custom defined functionals us",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/dft-1.html:28660,energy,energy,28660,psi4manual/1.2.1/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/dft-1.html,2,['energy'],['energy']
Energy Efficiency," mo_f12_squared() psi4.core.MintsHelper method, [1], [2]. mo_f12g12() psi4.core.MintsHelper method, [1], [2]. MO_MAXITER (DFOCC). (OCC). mo_oei_deriv1() psi4.core.MintsHelper method, [1], [2]. mo_oei_deriv2() psi4.core.MintsHelper method, [1], [2]. MO_READ (MCSCF). (OCC). MO_RELAX (DCFT). mo_spin_eri() psi4.core.MintsHelper method, [1], [2]. MO_STEP_MAX (DFOCC). (OCC). mo_tei_deriv1() psi4.core.MintsHelper method, [1], [2]. mo_tei_deriv2() psi4.core.MintsHelper method, [1], [2]. mo_transform() psi4.core.MintsHelper method, [1], [2]. MO_WRITE (OCC). MODULE (CPHF). moFa() psi4.core.ROHF method, [1], [2]. moFb() psi4.core.ROHF method, [1], [2]. moFeff() psi4.core.ROHF method, [1], [2]. MOGRAD_DAMPING (OCC). Molden. molden() in module psi4. in module psi4.driver. MOLDEN_WITH_VIRTUAL (GLOBALS). MOLDEN_WRITE (DCFT). (DFOCC). (SCF). MoldenWriter class in psi4.core, [1]. molecular_charge() psi4.core.Molecule method, [1], [2]. MolecularGrid class in psi4.core, [1]. molecule. ; EFP. PubChem. charge. ghost. isotope. multiple fragments. multiple in input file. multiplicity. no_reorient. setting keywords. specification. symmetry. units. Molecule class in psi4.core, [1]. molecule() psi4.core.BasisSet method, [1], [2]. psi4.core.CCWavefunction method, [1]. psi4.core.CIWavefunction method, [1]. psi4.core.CUHF method, [1]. psi4.core.DFEP2Wavefunction method, [1]. psi4.core.FISAPT method, [1], [2]. psi4.core.HF method, [1]. psi4.core.RHF method, [1]. psi4.core.ROHF method, [1]. psi4.core.UHF method, [1]. psi4.core.Wavefunction method, [1], [2]. molecule_from_arrays in module psi4.driver. molecule_from_schema in module psi4.driver. molecule_from_string in module psi4.driver. molecule_get_attr() in module psi4.driver. molecule_set_attr() in module psi4.driver. MOM. MOM_excited_ psi4.core.CUHF attribute, [1]. psi4.core.HF attribute, [1], [2]. psi4.core.RHF attribute, [1]. psi4.core.ROHF attribute, [1]. psi4.core.UHF attribute, [1]. MOM_OCC (SCF). MOM_performed_ psi4.core.CUHF attribute,",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/genindex-1.html:90061,charge,charge,90061,psi4manual/1.3.2/genindex-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/genindex-1.html,2,['charge'],['charge']
Energy Efficiency," mo_f12_squared() psi4.core.MintsHelper method, [1], [2]. mo_f12g12() psi4.core.MintsHelper method, [1], [2]. MO_MAXITER (DFOCC). (OCC). mo_oei_deriv1() psi4.core.MintsHelper method, [1], [2]. mo_oei_deriv2() psi4.core.MintsHelper method, [1], [2]. MO_READ (MCSCF). (OCC). MO_RELAX (DCFT). mo_spin_eri() psi4.core.MintsHelper method, [1], [2]. MO_STEP_MAX (DFOCC). (OCC). mo_tei_deriv1() psi4.core.MintsHelper method, [1], [2]. mo_tei_deriv2() psi4.core.MintsHelper method, [1], [2]. mo_transform() psi4.core.MintsHelper method, [1], [2]. MO_WRITE (OCC). MODULE (CPHF). moFa() psi4.core.ROHF method, [1], [2]. moFb() psi4.core.ROHF method, [1], [2]. moFeff() psi4.core.ROHF method, [1], [2]. MOGRAD_DAMPING (OCC). Molden. molden() in module psi4. in module psi4.driver. MOLDEN_WITH_VIRTUAL (GLOBALS). MOLDEN_WRITE (DCFT). (DFOCC). (SCF). MoldenWriter class in psi4.core, [1]. molecular_charge() psi4.core.Molecule method, [1], [2]. MolecularGrid class in psi4.core, [1]. molecule. ; EFP. PubChem. charge. ghost. isotope. multiple fragments. multiple in input file. multiplicity. no_reorient. setting keywords. specification. symmetry. units. Molecule class in psi4.core, [1]. molecule() psi4.core.BasisSet method, [1], [2]. psi4.core.CIWavefunction method, [1]. psi4.core.CUHF method, [1]. psi4.core.DFEP2Wavefunction method, [1]. psi4.core.HF method, [1]. psi4.core.RHF method, [1]. psi4.core.ROHF method, [1]. psi4.core.UHF method, [1]. psi4.core.Wavefunction method, [1], [2]. molecule_from_arrays in module psi4.driver. molecule_from_schema in module psi4.driver. molecule_from_string in module psi4.driver. molecule_get_attr() in module psi4.driver. molecule_set_attr() in module psi4.driver. MOM. MOM_OCC (SCF). MOM_START (SCF). MOM_VIR (SCF). MONTAGE. MOSpace class in psi4.core, [1]. move_atom() psi4.core.BasisSet method, [1], [2]. move_to_com() psi4.core.Molecule method, [1], [2]. MOWriter class in psi4.core, [1]. MP2. ; density-fitting. MP2.5CORRELATIONENERGY. MP2.5TOTALENERGY. MP2_AMP_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/genindex-1.html:76603,charge,charge,76603,psi4manual/1.2.1/genindex-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/genindex-1.html,2,['charge'],['charge']
Energy Efficiency," module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_lccd_gradient(name, **kwargs):; """"""Function selecting the algorithm for a LCCD gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('CC_TYPE'); module = core.get_global_option('QC_MODULE'); all_electron = (core.get_global_option('FREEZE_CORE') == ""FALSE""); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF']:; if mtd_type == 'CONV':; if all_electron:; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError(['select_lccd_gradient', name, 'CC_TYPE', mtd_type, reference, module, all_electron]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_olccd(name, **kwargs):; """"""Function selecting the algorithm for an OLCCD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('CC_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError(['select_olccd', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_olccd_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OLCCD gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('CC_TYPE'); module = core.ge",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:19564,energy,energy,19564,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,3,['energy'],['energy']
Energy Efficiency," modules    . toc    ; PSI4 [beta5] » ; Module code ». Source code for proc; #; #@BEGIN LICENSE; #; # PSI4: an ab initio quantum chemistry software package; #; # This program is free software; you can redistribute it and/or modify; # it under the terms of the GNU General Public License as published by; # the Free Software Foundation; either version 2 of the License, or; # (at your option) any later version.; #; # This program is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU General Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; #@END LICENSE; #. from __future__ import print_function; """"""Module with functions that encode the sequence of PSI module; calls for each of the *name* values of the energy(), optimize(),; response(), and frequency() function. """"""; import shutil; import os; import subprocess; import re; import psi4; import p4const; import p4util; from p4regex import *; #from extend_Molecule import *; from molutil import *; from functional import *; # never import driver, wrappers, or aliases into this file. # ATTN NEW ADDITIONS!; # consult http://sirius.chem.vt.edu/psi4manual/master/proc_py.html. [docs]def run_dcft(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density cumulant functional theory calculation. """"""; optstash = p4util.OptionsState(; ['SCF', 'REFERENCE'],; ['DCFT', 'REFERENCE']). psi4.set_local_option('SCF', 'REFERENCE', 'UHF'); psi4.set_local_option('DCFT', 'REFERENCE', 'UHF'). # Bypass routine scf if user did something special to get it to converge; if not (('bypass_scf' in kwargs) and yes.match(str(kwargs['bypass_scf']))):; scf_helper(name, **kwargs); psi4.dcft(). optstash.restor",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/proc.html:1100,energy,energy,1100,psi4manual/4.0b5/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html,1,['energy'],['energy']
Energy Efficiency," modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. Interface to MRCC by M. Kállay¶; Code author: Justin M. Turney and Andrew C. Simmonett; Section author: Justin M. Turney; Module: Keywords, PSI Variables, MRCC, Samples; PSI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (http://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; 1; 2; 3; 4; 5; 6; 7; 8; 9molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC.; Perturbative methods (ccsd(t), ccsdtqp(h)_l, etc.); are available with REFERENCE ROHF in versions of MRCC published; at least after July 1, 2014.; When using ROHF-CCSDT(Q), MRCC will compute and report two variants:; CCSDT(Q)/A and CCSDT(Q)/B.[Kallay:2008:144101]_ Psi4 will save both energies but will use; the CCSDT(Q)/B as the CCSDT(Q) e",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/mrcc-1.html:1060,energy,energy,1060,psi4manual/1.2.1/mrcc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/mrcc-1.html,2,['energy'],['energy']
Energy Efficiency," modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. Interface to MRCC by M. Kállay¶; Code author: Justin M. Turney and Andrew C. Simmonett; Section author: Justin M. Turney; Module: Keywords, PSI Variables, MRCC, Samples; PSI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (http://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; 1; 2; 3; 4; 5; 6; 7; 8; 9molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC.; Perturbative methods (ccsd(t), ccsdtqp(h)_l, etc.); are available with REFERENCE ROHF in versions of MRCC published; at least after July 1, 2014.; When using ROHF-CCSDT(Q), MRCC will compute and report two variants:; CCSDT(Q)/A and CCSDT(Q)/B.[Kallay:2008:144101]_ Psi4 will save both energies but will use; the CCSDT(Q)/B as the CCSDT(Q) e",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/mrcc-1.html:1060,energy,energy,1060,psi4manual/1.3.2/mrcc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/mrcc-1.html,2,['energy'],['energy']
Energy Efficiency," modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to MRCC by M. Kállay. Interface to MRCC by M. Kállay¶; Code author: Justin M. Turney and Andrew C. Simmonett; Section author: Justin M. Turney; Module: Keywords, PSI Variables, MRCC, Samples; PSI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (https://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; To indicate MRCC as the target software, set QC_MODULE=MRCC.; This is a change as of October 2022; previously, one prefixed the method by “mr”; to indicate MRCC (e.g., energy('mrccsdt')).; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; qc_module mrcc; }; energy('ccsdt'). 'ccsdt' in the call to energy() plus qc_module=mrcc instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; Here the qc_module=mrcc is optional since PSI4 has no builtin module; that can perform CCSDT. For a method like CCSD, no specification of QC_MODULE; will default to the CCENERGY module, and specification with value mrcc is; required to route the computation to the MRCC program.; For a CCSDT(Q) energy, simply use 'ccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any m",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/mrcc.html:1045,energy,energy,1045,psi4manual/1.8.x/mrcc.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/mrcc.html,1,['energy'],['energy']
Energy Efficiency," modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to MRCC by M. Kállay. Interface to MRCC by M. Kállay¶; Code author: Justin M. Turney and Andrew C. Simmonett; Section author: Justin M. Turney; Module: Keywords, PSI Variables, MRCC, Samples; PSI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (https://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; To indicate MRCC as the target software, set QC_MODULE=MRCC.; This is a change as of October 2022; previously, one prefixed the method by “mr”; to indicate MRCC (e.g., energy('mrccsdt')).; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; qc_module mrcc; }; energy('ccsdt'). 'ccsdt' in the call to energy() plus qc_module=mrcc instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; Here the qc_module=mrcc is optional since PSI4 has no builtin module; that can perform CCSDT. For a method like CCSD, no specification of QC_MODULE; will default to the CCENERGY module, and specification with value mrcc is; required to route the computation to the MRCC program.; For a CCSDT(Q) energy, simply use 'ccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any m",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/mrcc.html:1045,energy,energy,1045,psi4manual/1.9.x/mrcc.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/mrcc.html,1,['energy'],['energy']
Energy Efficiency," mol {; He 0 0 0; --; He 0 0 4; --; He 0 4 0; --; He 4 0 0; }. # Returns the nocp energy as its first in the list; energy('CCSD(T)', bsse_type=['nocp', 'cp', 'vmfc'], max_nbody=3). API¶. class psi4.driver.driver_nbody.BsseEnum(value, names=None, *, module=None, qualname=None, type=None, start=1, boundary=None)[source]¶; Available basis-set superposition error (BSSE) treatments. cp = 'cp'¶. nocp = 'nocp'¶. vmfc = 'vmfc'¶. pydantic model psi4.driver.driver_nbody.ManyBodyComputer[source]¶. Show JSON schema{; ""title"": ""ManyBodyComputer"",; ""description"": ""Base class for \""computers\"" that plan, run, and process QC tasks."",; ""type"": ""object"",; ""properties"": {; ""molecule"": {; ""title"": ""Molecule"",; ""description"": ""The target molecule, if not the last molecule defined.""; },; ""basis"": {; ""title"": ""Basis"",; ""default"": ""(auto)"",; ""type"": ""string""; },; ""method"": {; ""title"": ""Method"",; ""default"": ""(auto)"",; ""type"": ""string""; },; ""driver"": {; ""description"": ""The computation driver; i.e., energy, gradient, hessian."",; ""allOf"": [; {; ""$ref"": ""#/definitions/DriverEnum""; }; ]; },; ""keywords"": {; ""title"": ""Keywords"",; ""description"": ""The computation keywords/options."",; ""default"": {},; ""type"": ""object""; },; ""bsse_type"": {; ""description"": ""Requested BSSE treatments. First in list determines which interaction or total energy/gradient/Hessian returned."",; ""default"": [; ""cp""; ],; ""type"": ""array"",; ""items"": {; ""$ref"": ""#/definitions/BsseEnum""; }; },; ""nfragments"": {; ""title"": ""Nfragments"",; ""description"": ""Number of distinct fragments comprising full molecular supersystem."",; ""default"": -1,; ""type"": ""integer""; },; ""max_nbody"": {; ""title"": ""Max Nbody"",; ""description"": ""Maximum number of bodies to include in the many-body treatment. Possible: max_nbody <= nfragments. Default: max_nbody = nfragments."",; ""default"": -1,; ""type"": ""integer""; },; ""nbodies_per_mc_level"": {; ""title"": ""Nbodies Per Mc Level"",; ""description"": ""Distribution of active n-body levels among model chemistry levels. All bodies",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/nbody.html:4531,energy,energy,4531,psi4manual/1.8.x/nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/nbody.html,1,['energy'],['energy']
Energy Efficiency," molecule the user provided is the active one; if ('molecule' in kwargs):; activate(kwargs['molecule']); del kwargs['molecule']; molecule = psi4.get_active_molecule(); molecule.update_geometry(); psi4.set_global_option('BASIS', psi4.get_global_option('BASIS')). # S/R: Mode of operation- whether finite difference opt run in one job or files farmed out; opt_mode = 'continuous'; if ('mode' in kwargs) and (dertype == 0):; opt_mode = kwargs['mode']. if (opt_mode.lower() == 'continuous'):; pass; elif (opt_mode.lower() == 'sow'):; pass; elif (opt_mode.lower() == 'reap'):; if('linkage' in kwargs):; opt_linkage = kwargs['linkage']; else:; raise ValidationError('Optimize execution mode \'reap\' requires a linkage option.'); else:; raise ValidationError('Optimize execution mode \'%s\' not valid.' % (opt_mode)). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); if not psi4.has_option_changed('SCF', 'E_CONVERGENCE'):; if procedures['energy'][lowername] == run_scf or procedures['energy'][lowername] == run_dft:; psi4.set_local_option('SCF', 'E_CONVERGENCE', 8); else:; psi4.set_local_option('SCF', 'E_CONVERGENCE', 10); if not psi4.has_option_changed('SCF', 'D_CONVERGENCE'):; if procedures['energy'][lowername] == run_scf or procedures['energy'][lowername] == run_dft:; psi4.set_local_option('SCF', 'D_CONVERGENCE', 8); else:; psi4.set_local_option('SCF', 'D_CONVERGENCE', 10). # Set post-scf convergence criteria (global will cover all correlated modules); if not psi4.has_global_option_changed('E_CONVERGENCE'):; if not procedures['energy'][lowername] == run_scf and not procedures['energy'][lowername] == run_dft:; psi4.set_global_option('E_CONVERGENCE', 8). # Does dertype indicate an analytic procedure both exists and is wanted?; if (dertype == 1):; # Nothing to it but to do it. Gradient information is saved; # into the current reference wavefunction; procedures['gradient'][lowername](lowername, **kwargs). if 'mode' in kwargs and kwar",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/driver.html:34186,energy,energy,34186,psi4manual/4.0b5/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/driver.html,2,['energy'],['energy']
Energy Efficiency," molecule, if not the last molecule defined. Examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> molecule mol {\nH 0.0 0.0 0.0\nH 2.0 0.0 0.0\nF 0.0 1.0 0.0\nF 2.0 1.0 0.0\n}; >>> print mol.nfragments() # 1; >>> fragmol = auto_fragments(); >>> print fragmol.nfragments() # 2. qmmm¶; Module with classes to integrate MM charges into; a QM calculation. class Diffuse(molecule, basisname, ribasisname)[source]¶. fitGeneral()[source]¶; Function to perform a general fit of diffuse charges; to wavefunction density. fitScf()[source]¶; Function to run scf and fit a system of diffuse charges to; resulting density. populateExtern(extern)[source]¶. class QMMM[source]¶. addChargeAngstrom(Q, x, y, z)[source]¶; Function to add a point charge of magnitude Q at; position (x, y, z) Angstroms. addChargeBohr(Q, x, y, z)[source]¶; Function to add a point charge of magnitude Q at; position (x, y, z) Bohr. addDiffuse(diffuse)[source]¶; Function to add a diffuse charge field diffuse. populateExtern()[source]¶; Function to define a charge field external to the; molecule through point and diffuse charges. qcdb¶; Module to facilitate quantum chemical computations on chemical; databases. Contains Molecule class and physical constants from psi4 suite.; Module with commands building BasisFamily objects; for Pople and other non-Dunning orbital basis sets. Some; plausible fitting basis sets are supplied as defaults. load_basfam_other()[source]¶. class CharacterTable(*args)[source]¶; The CharacterTable class provides a workable character table for; all of the non-cubic point groups. While I have tried to match the; ordering in Cotton’s book, I don’t guarantee that it is always; followed. It shouldn’t matter anyway. Also note that I don’t lump; symmetry operations of the same class together. For example, in C3v; there are two distinct C3 rotations and 3 distinct reflections, each; with a separate character. Thus symop has 6 elements ra",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:9459,charge,charge,9459,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,2,['charge'],['charge']
Energy Efficiency," molecule. psimrcc-sp1; Mk-MRCCSD single point. \(^3 \Sigma ^-\) O2 state described using the Ms = 0 component of the triplet. Uses ROHF triplet orbitals. castup2; SCF with various combinations of pk/density-fitting, castup/no-castup, and spherical/cartesian settings. Demonstrates that puream setting is getting set by orbital basis for all df/castup parts of calc. Demonstrates that answer doesn’t depend on presence/absence of castup. Demonstrates (by comparison to castup3) that output file doesn’t depend on options (scf_type) being set global or local. This input uses global. cc10; ROHF-CCSD cc-pVDZ energy for the \(^2\Sigma^+\) state of the CN radical. opt-freeze-coords; SCF/cc-pVDZ optimization example with frozen cartesian. cc27; Single point gradient of 1-1B2 state of H2O with EOM-CCSD. mpn-bh; MP(n)/aug-cc-pVDZ BH Energy Point, with n=2-19. Compare against M. L. Leininger et al., J. Chem. Phys. 112, 9213 (2000). sapt-sf1; Tests the Psi4 SF-SAPT code. cbs-delta-energy; Extrapolated energies with delta correction. omp2-5; SOS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. scf-freq1; Analytic vs. finite difference DF-SCF frequency test for water. cc22; ROHF-EOM-CCSD/DZ on the lowest two states of each irrep in \(^{3}B_1\) CH2. cc14; ROHF-CCSD/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. mp2-1; All-electron MP2 6-31G** geometry optimization of water. cepa1; cc-pvdz H2O Test CEPA(1) Energy. casscf-fzc-sp; CASSCF/6-31G** energy point. extern2; External potential calculation involving a TIP3P water and a QM water for DFMP2. Finite different test of the gradient is performed to validate forces. opt9; Various constrained energy minimizations of HOOH with cc-pvdz RHF. Cartesian-coordinate constrained optimizations of HOOH in internals. cc9a; ROHF-CCSD(T) cc-pVDZ energy for the \(^2\Sigma^+\) state of the CN radical, with Z-matrix input. mints1; Symmetry tests for a range of molecules. This doesn’t actually compute any energies, but serve",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html:17543,energy,energy,17543,psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency," molecule.molecular_charge() != 0:; raise ValidationError(""""""IP Fitting requires neutral molecule to start.""""""); if molecule.schoenflies_symbol() != 'c1':; core.print_out("""""" Requested procedure `ip_fitting` does not make use of molecular symmetry: """"""; """"""further calculations in C1 point group.\n""""""); molecule = molecule.clone(); molecule.reset_point_group('c1'); molecule.update_geometry(). charge0 = molecule.molecular_charge(); mult0 = molecule.multiplicity(). # How many electrons are there?; N = 0; for A in range(molecule.natom()):; N += molecule.Z(A); N -= charge0; N = int(N); Nb = int((N - mult0 + 1) / 2); Na = int(N - Nb). # Work in the ot namespace for this procedure; core.IO.set_default_namespace(""ot""). # Burn in to determine orbital eigenvalues; if read:; core.set_local_option(""SCF"", ""GUESS"", ""READ""); copy_file_to_scratch(read180, 'psi', 'ot', 180); core.set_local_option(""SCF"", ""DF_INTS_IO"", ""SAVE""); E, wfn = driver.energy('scf', dft_functional=name, return_wfn=True, molecule=molecule,; banner='IP Fitting SCF: Burn-in', **kwargs); core.set_local_option(""SCF"", ""DF_INTS_IO"", ""LOAD""). if not wfn.functional().is_x_lrc():; raise ValidationError(""""""Not sensible to optimize omega for non-long-range-correction functional.""""""). # Determine HOMO, to determine mult1; eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); if Na == Nb:; HOMO = -Nb; elif Nb == 0:; HOMO = Na; else:; E_a = eps_a.np[int(Na - 1)]; E_b = eps_b.np[int(Nb - 1)]; if E_a >= E_b:; HOMO = Na; else:; HOMO = -Nb. Na1 = Na; Nb1 = Nb; if HOMO > 0:; Na1 -= 1; else:; Nb1 -= 1. charge1 = charge0 + 1; mult1 = Na1 - Nb1 + 1. omegas = []; E0s = []; E1s = []; kIPs = []; IPs = []; types = []. # Right endpoint; core.set_local_option('SCF', 'DFT_OMEGA', omega_r). # Neutral; if read:; core.set_local_option(""SCF"", ""GUESS"", ""READ""); p4util.copy_file_to_scratch(read180, 'psi', 'ot', 180). molecule.set_molecular_charge(charge0); molecule.set_multiplicity(mult0); E0r, wfn = driver.energy('scf', dft_functional=name, return_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/frac.html:16863,energy,energy,16863,psi4manual/1.7.x/_modules/psi4/driver/frac.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/frac.html,4,['energy'],['energy']
Energy Efficiency," mom; Maximum Overlap Method (MOM) Test. MOM is designed to stabilize SCF convergence and to target excited Slater determinants directly. dft-custom-hybrid; DFT (hybrids) test of implementations in: hybrid_superfuncs.py. fsapt-ext-abc2; FSAPT with external charge on dimer. cc34; RHF-CCSD/cc-pVDZ energy of H2O partitioned into pair energy contributions. cc23; ROHF-EOM-CCSD/DZ analytic gradient lowest \(^{2}B_1\) state of H2O+ (A1 excitation). omp3-1; OMP3 cc-pVDZ energy for the H2O molecule. pywrap-db3; Test that Python Molecule class processes geometry like psi4 Molecule class. dft-freq-analytic; Analytic SVWN frequencies, compared to finite difference values. scf-response3; UHF Dipole Polarizability Test. psithon2; Accesses basis sets, databases, plugins, and executables in non-install locations. cc36; CC2(RHF)/cc-pVDZ energy of H2O. opt11; Transition-state optimizations of HOOH to both torsional transition states. opt6; Various constrained energy minimizations of HOOH with cc-pvdz RHF Internal-coordinate constraints in internal-coordinate optimizations. dfmp2-grad2; DF-MP2 cc-pVDZ gradient for the NO molecule. sapt11; sapt example with orbital freezing with alkali metal and dMP2. cc46; EOM-CC2/cc-pVDZ on H2O2 with two excited states in each irrep. cc52; CCSD Response for H2O2. dft-grad2; DF-BP86-D2 cc-pVDZ frozen core gradient of S22 HCN updated ref gradient due to new BraggSlater radii. dforemp-grad1; density fitted OO-REMP/cc-pVDZ engrad single points for the H2O molecule. fsapt1; This test case shows an example of running and analyzing a standard F-SAPT0/jun-cc-pvdz procedure for phenol dimer from the S22 database. dfmp2-freq1; DF-MP2 frequency by difference of energies for H2O. cc56; EOM-CCSD/6-31g excited state transition data for water cation. dfmp2-grad5; Tests DF-MP2 gradient in the presence of a dipole field. dlpnomp2-1; comparison of DF-MP2 and DLPNO-MP2. dft-custom-gga; DFT (LDA/GGA) test of custom implementations in: gga_superfuncs.py. ci-property; CI/",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html:12550,energy,energy,12550,psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency," monomer basis for CP total data; if n == 1:; monomers_in_monomer_basis = [v for v in nocp_compute_list[1] if len(v[1]) == 1]; monomer_energies = 0.0; monomer_energy_list = []; for i in monomers_in_monomer_basis:; monomer_energy_list.append(component_results['energies'][i]); monomer_energies += component_results['energies'][i]. cp_energy_by_level[n] = sum(component_results['energies'][v] for v in cp_compute_list[n]); nocp_energy_by_level[n] = sum(component_results['energies'][v] for v in nocp_compute_list[n]). # Special vmfc case; if n > 1:; vmfc_energy_body_dict[n] = vmfc_energy_body_dict[n - 1]; for tup in vmfc_level_list[n]:; vmfc_energy_body_dict[n] += ((-1)**(n - len(tup[0]))) * component_results['energies'][tup]. # Do ptype; if metadata['ptype'] != 'energy':; _sum_cluster_ptype_data(metadata['ptype'], component_results['ptype'], cp_compute_list[n],; fragment_slice_dict, fragment_size_dict, cp_ptype_by_level[n]); _sum_cluster_ptype_data(metadata['ptype'], component_results['ptype'], nocp_compute_list[n],; fragment_slice_dict, fragment_size_dict, nocp_ptype_by_level[n]); _sum_cluster_ptype_data(; metadata['ptype'],; component_results['ptype'],; vmfc_level_list[n],; fragment_slice_dict,; fragment_size_dict,; vmfc_ptype_by_level[n],; vmfc=True,; n=n). if metadata['ptype'] != 'energy':; # Extract ptype data for monomers in monomer basis for CP total data; monomer_ptype = np.zeros(arr_shape); _sum_cluster_ptype_data(metadata['ptype'], component_results['ptype'], monomers_in_monomer_basis,; fragment_slice_dict, fragment_size_dict, monomer_ptype). # Compute cp energy and ptype; if 'cp' in metadata['bsse_type_list']:; for n in nbody_range:; if n == metadata['max_frag']:; cp_energy_body_dict[n] = cp_energy_by_level[n] - bsse; if metadata['ptype'] != 'energy':; cp_ptype_body_dict[n][:] = cp_ptype_by_level[n] - bsse_ptype; continue. for k in range(1, n + 1):; take_nk = nCr(metadata['max_frag'] - k - 1, n - k); sign = ((-1)**(n - k)); value = cp_energy_by_level[k]; cp_energ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html:24377,energy,energy,24377,psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html,2,['energy'],['energy']
Energy Efficiency," more; efficient by means of the Density-Fitting (DF) approximation (also known as; Resolution-of-the-Identity or RI), wherein the quadratic \(ov\) products in the; bra- and ket- of the \((ov|ov)\)-type Electron Repulsion Integrals (ERIs); appearing in MP2 are cast onto a linear-scaling auxiliary basis by least-squares; fitting. Substitution of the DF factorization into the MP2 equations results in; a formal scaling and prefactor reduction of MP2, and further speed gains are; possible due to heavy utilization of matrix-multiplication kernels and minimal; storage requirements in a DF approach. The method has been found to be quite; robust and accurate, and it should be preferred unless extreme accuracy is required; or a fitting basis is not defined for the primary basis and atom type; encountered. In particular, we have found excellent efficiency and tractability; gains when using DF-MP2 in concert with a DF-SCF reference. An efficient,; threaded, disk-based DF-MP2 code is available in PSI4 for all single; reference types available in the SCF module.; MP2 defaults in PSI4 to the density-fitted code. See; MP2_TYPE for performing a MP2 with conventional integrals.; An example utilization of the code is:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set basis cc-pvdz; set scf_type df; set freeze_core True. energy('mp2'). The energy('mp2') call to energy() executes; the predefined DF-MP2 procedure, first calling; the SCF module with a default RHF reference and DF algorithm for the; two-electron integrals. When the orbitals are converged, the DF-MP2 module is; launched, which forms the density-fitted \((Q|ov)\) integrals and then builds the; full \((ov|ov)\) tensor in blocks, evaluating the contributions to the MP2 energy; as it goes. A RHF-MP2 wavefunction is selected automatically due to the RHF; reference. In this example, we freeze the core, both for efficiency and; because split-valence bases like cc-pVDZ do not contain co",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/dfmp2-1.html:1576,efficient,efficient,1576,psi4manual/1.2.1/dfmp2-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/dfmp2-1.html,6,['efficient'],['efficient']
Energy Efficiency," more; efficient by means of the Density-Fitting (DF) approximation (also known as; Resolution-of-the-Identity or RI), wherein the quadratic \(ov\) products in the; bra- and ket- of the \((ov|ov)\)-type Electron Repulsion Integrals (ERIs); appearing in MP2 are cast onto a linear-scaling auxiliary basis by least-squares; fitting. Substitution of the DF factorization into the MP2 equations results in; a formal scaling and prefactor reduction of MP2, and further speed gains are; possible due to heavy utilization of matrix-multiplication kernels and minimal; storage requirements in a DF approach. The method has been found to be quite; robust and accurate, and it should be preferred unless extreme accuracy is required; or a fitting basis is not defined for the primary basis and atom type; encountered. In particular, we have found excellent efficiency and tractability; gains when using DF-MP2 in concert with a DF-SCF reference. An efficient,; threaded, disk-based DF-MP2 code is available in PSI4 for all single; reference types available in the SCF module.; MP2 defaults in PSI4 to the density-fitted code. See; MP2_TYPE for performing a MP2 with conventional integrals.; An example utilization of the code is:; molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set basis cc-pvdz; set scf_type df; set freeze_core True. energy('mp2'). The energy('mp2') call to energy() executes; the predefined DF-MP2 procedure, first calling; the SCF module with a default RHF reference and DF algorithm for the; two-electron integrals. When the orbitals are converged, the DF-MP2 module is; launched, which forms the density-fitted \((Q|ov)\) integrals and then builds the; full \((ov|ov)\) tensor in blocks, evaluating the contributions to the MP2 energy; as it goes. A RHF-MP2 wavefunction is selected automatically due to the RHF; reference. In this example, we freeze the core, both for efficiency and; because split-valence bases like cc-pVDZ do not contain core correlation; functions. The result",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/dfmp2-1.html:1643,efficient,efficient,1643,psi4manual/1.4.0/dfmp2-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/dfmp2-1.html,5,['efficient'],['efficient']
Energy Efficiency," more; efficient by means of the Density-Fitting (DF) approximation (also known as; Resolution-of-the-Identity or RI), wherein the quadratic \(ov\) products in the; bra- and ket- of the \((ov|ov)\)-type Electron Repulsion Integrals (ERIs); appearing in MP2 are cast onto a linear-scaling auxiliary basis by least-squares; fitting. Substitution of the DF factorization into the MP2 equations results in; a formal scaling and prefactor reduction of MP2, and further speed gains are; possible due to heavy utilization of matrix-multiplication kernels and minimal; storage requirements in a DF approach. The method has been found to be quite; robust and accurate, and it should be preferred unless extreme accuracy is required; or a fitting basis is not defined for the primary basis and atom type; encountered. In particular, we have found excellent efficiency and tractability; gains when using DF-MP2 in concert with a DF-SCF reference. An efficient,; threaded, disk-based DF-MP2 code is available in PSI4 for all single; reference types available in the SCF module.; MP2 defaults in PSI4 to the density-fitted code.; The support for MP2 by the DFMP2 module in PSI4 is detailed in; Table DFMP2 Capabilities. Even without; set qc_module dfmp2, methods will default to this module, but; alternate implementations and use of MP2_TYPE for performing; a MP2 with conventional integrals can be seen at other modules. Detailed capabilities of the DFMP2 module. “✓” runs analytically. Single underline “✓̲” is default module when QC_MODULE unspecified. Double underline “✓̳” is default algorithm type when type selector (e.g., CC_TYPE) unspecified.¶. ◻; ◻; name ↓ →; ◻; ◻. ◻; REFERENCE →; ◻; type[1] ↓ →; FREEZE_CORE[2]→. QC_MODULE=DFMP2 Capabilities. Restricted (RHF); Unrestricted (UHF); Restricted Open (ROHF). energy(); gradient()[3]; energy(); gradient()[3]; energy(); gradient()[3]. CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD. A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/dfmp2.html:1643,efficient,efficient,1643,psi4manual/1.7.x/dfmp2.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/dfmp2.html,4,['efficient'],['efficient']
Energy Efficiency," mp2. df-mp2; cc2; ccsd. bccd; cc3; ccsd(t). cisd; cisdt; cisdtq. cin; fci. Parameters:; name (string) – 'scf' || 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be 'scf'. Overruled if stage_wfn keywords supplied. corl_wfn (string) – 'mp2' || 'ccsd(t)' || etc.; Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with name or as the unlabeled; first argument to the function. delta_wfn (string) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. delta_wfn_lesser (string) – 'mp2' || 'ccsd' || etc.; Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. delta2_wfn (string) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. delta2_wfn_lesser (string) – 'mp2' || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. Basis Sets; Currently, the basis set set through set commands have no influence; on a cbs calculation. Parameters:; scf_basis (basis string) – corl_basis || 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, scf_basis can default; to corl_basis. corl_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the correlation energy. delta_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. delta2_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/cbs-1.html:3642,energy,energy,3642,psi4manual/4.0b3/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/cbs-1.html,4,['energy'],['energy']
Energy Efficiency," must also be available for these methods to; run. Unlike every other method in PSI4, if a basis set has not been; set, these will default to their intended basis sets: MINIX for HF-3c; and def2-mSVP for PBEh-3c. If a basis has previously been set, but you; want to use the default basis, use the slash syntax to “empty” the basis; option for the scope of the current calculation, energy(""hf3c/"").; A few practical examples:. HF-3c single point with default minix basis; 1energy('hf3c'). PBEh-3c optimization with default def2-mSVP basis; 1optimize('pbeh3c'). HF-3c with non-standard basis; 1; 2set basis cc-pvdz; energy('hf3c'). PBEh-3c with default basis after basis set; 1; 2set basis cc-pvdz; energy('pbeh3c/'). If only BSSE/basis set corrections (rather than total energies) are of; interest, the gcp program can be run independently of the scf; through the python function run_gcp(). (This function; is the same PSI4/gcp interface that is called during an scf job.); This route is much faster than running a HF or DFT energy.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10molecule nene {; Ne; Ne 1 2.0; }. nene.update_geometry(). >>> E, G = nene.run_gcp('hf3c'). >>> E, G = nene.run_gcp(func='HF3c', verbose=True). qcdb.interface_gcp.run_gcp(self, func=None, dertype=None, verbose=False)[source]¶; Function to call Grimme’s GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to self for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, func. Returns energy if dertype is 0, gradient; if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The gcp executable must be independently compiled and; found in PATH or PSIPATH. self may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.Molecule. table of contents.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/gcp-1.html:2636,energy,energy,2636,psi4manual/1.3.2/gcp-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/gcp-1.html,2,['energy'],['energy']
Energy Efficiency," must also be available for these methods to; run. Unlike every other method in PSI4, if a basis set has not been; set, these will default to their intended basis sets: MINIX for HF-3c; and def2-mSVP for PBEh-3c. If a basis has previously been set, but you; want to use the default basis, use the slash syntax to “empty” the basis; option for the scope of the current calculation, energy(""hf3c/"").; A few practical examples:. HF-3c single point with default minix basis; 1energy('hf3c'). PBEh-3c optimization with default def2-mSVP basis; 1optimize('pbeh3c'). HF-3c with non-standard basis; 1; 2set basis cc-pvdz; energy('hf3c'). PBEh-3c with default basis after basis set; 1; 2set basis cc-pvdz; energy('pbeh3c/'). If only BSSE/basis set corrections (rather than total energies) are of; interest, the gcp program can be run independently of the scf; through the python function run_gcp(). (This function; is the same PSI4/gcp interface that is called during an scf job.); This route is much faster than running a HF or DFT energy.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10molecule nene {; Ne; Ne 1 2.0; }. nene.update_geometry(). >>> E, G = nene.run_gcp('hf3c'). >>> E, G = nene.run_gcp(func='HF3c', verbose=True). qcdb.interface_gcp.run_gcp(self, func=None, dertype=None, verbose=False)[source]¶; Function to call Grimme’s dftd3 program (http://toc.uni-muenster.de/DFTD3/); to compute the -D correction of level dashlvl using parameters for; the functional func. The dictionary dashparam can be used to supply; a full set of dispersion parameters in the absense of func or to supply; individual overrides in the presence of func. Returns energy if dertype is 0,; gradient if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The dftd3 executable must be independently compiled and found in; PATH or PSIPATH.; self may be either a qcdb.Molecule (sensibly) or a psi4.Molecule; (works b/c psi4.Molecule has been extended by this method py-side and; only public interface fns used) or a stri",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/gcp-1.html:2477,energy,energy,2477,psi4manual/1.1.0/gcp-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/gcp-1.html,4,['energy'],['energy']
Energy Efficiency," name to atom number number (1-indexed, includes dummies). set_basis_by_symbol(symbol, name, type='BASIS')[source]¶; NYI Assigns basis name to all symbol atoms. set_com_fixed(_fix=True)[source]¶; NYI Fix the center of mass at its current frame.; Not used in libmints so not implemented. set_full_geometry(geom)[source]¶; Sets the full geometry (dummies included), given a N X 3 array of coordinates geom in Bohr.; >>> H2OH2O.set_full geometry([[1,2,3],[4,5,6],[7,8,9],[0,0,0],[-1,-2,-3],[-4,-5,-6],[-7,-8,-9]]). set_full_point_group(tol=1e-08)[source]¶; NYI Determine and set FULL point group. set_geometry(geom)[source]¶; Sets the geometry, given a N X 3 array of coordinates geom in Bohr.; >>> H2OH2O.set_geometry([[1,2,3],[4,5,6],[7,8,9],[-1,-2,-3],[-4,-5,-6],[-7,-8,-9]]). set_ghost_fragment(fr)[source]¶; Tags fragment index fr as composed of ghost atoms. set_ghost_fragments(ghosts)[source]¶; Tags the fragments in array ghosts as composed of ghost atoms. set_molecular_charge(charge)[source]¶; Sets the molecular charge; >>> H2OH2O.set_molecular_charge(-2). set_multiplicity(mult)[source]¶; Sets the multiplicity (defined as 2Ms + 1); >>> H2OH2O.set_multiplicity(3). set_name(name)[source]¶; Set molecule name; >>> H2OH2O.set_name('water_dimer'). set_point_group(pg)[source]¶; NYI Set the point group to object pg. set_units(units)[source]¶; Sets the geometry units; >>> H2OH2O.set_units('Angstom'). set_variable(vstr, val)[source]¶; Assigns the value val to the variable labelled string in the; list of geometry variables. Also calls update_geometry(). sym_label()[source]¶; NYI Returns the symmetry label. symbol(atom)[source]¶; Returns the cleaned up label of the atom (C2 => C, H4 = H) (0-indexed); >>> print H2OH2O.symbol(4); H. symmetrize()[source]¶; NYI Force the molecule to have the symmetry specified in pg.; This is to handle noise coming in from optking. symmetry_frame(tol=1e-08)[source]¶; Determine symmetry reference frame. If noreorient is not set,; this is the rotation matrix",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_driver-1.html:56155,charge,charge,56155,psi4manual/4.0b3/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_driver-1.html,8,['charge'],['charge']
Energy Efficiency," name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_ccsd_at_(name, **kwargs):; """"""Function selecting the algorithm for a CCSD(AT) energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('CC_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ/ccenergy. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError(['select_ccsd_at_', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_cisd(name, **kwargs):; """"""Function selecting the algorithm for a CISD energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('CI_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only detci/fnocc. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module in ['', 'FNOCC']:; func = run_cepa; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['', 'DETCI']:; func = run_detci. if func is None:; raise ManagedMethodError(['select_cisd', name, 'CI_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_mp4(name, **kwargs):; """"""Function selecting the algorithm for a MP4 energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP_TYPE'); module = psi4.get_global_option('QC_MODULE'); ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:24434,energy,energy,24434,psi4manual/1.0.0/_modules/procedures/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html,1,['energy'],['energy']
Energy Efficiency," name.lower(); kwargs = kwargs_lower(kwargs). Case sensitivity for kwargs dictionary values still needs to be handled. The first line below shows how to convert argument values to lowercase for matching. When not matching a whole value such that regular expressions are needed, the second line below performs a case insensitive match.; if (kwargs['db_mode'].lower() == 'continuous'):; if re.match(r'^sapt', name, flags=re.IGNORECASE):. Match boolean keywords (db_cp in the example below) with expressions like the following, which allow case insensitive yes/true/on/1/no/false/off/0 user input. If your argument’s value is a derivative level, similarly, use input.der0th, input.der1st, and input.der2nd.; if input.yes.match(str(db_cp)):; elif input.no.match(str(db_cp)):. For keywords that might be used in other functions as well as your own, prepend the argument name with a short representation of your function name. For example, there are keywords cp_func, db_func, and opt_func to request what python function, if not energy(), is called by cp(), database(), and optimize(). Upon checking in a new python file, edit the file psi4/doc/userman/source/index.rst and follow the instructions therein that your file may be autodocumented here. Write docstrings! For a major function intended for use in input files, emulate any docstring in psi4/share/python/driver.py. For a behind-the-scenes function or if you don’t want the bother of dealing with reStructuredText, just write an ordinary docstring. It will get slurped into the documentation in plain text. Your python function should follow PEP8 conventions (without the line-length restriction). I’m aiming for files to pass the line below, unless for good reason. The second line is for database Python files.; >>> pep8.py -r --ignore=E501 pythonfile.py; >>> pep8.py -r --ignore=E501,E221,E222,E241,E201,E202 databasefile.py. Your python function should not prevent any test case from passing. A test case(s) should be written and checked in f",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/bestpractices_py-1.html:2908,energy,energy,2908,psi4manual/1.0.0/bestpractices_py-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/bestpractices_py-1.html,2,['energy'],['energy']
Energy Efficiency," name.lower(); kwargs = kwargs_lower(kwargs). Case sensitivity for kwargs dictionary values still needs to be handled. The first line below shows how to convert argument values to lowercase for matching. When not matching a whole value such that regular expressions are needed, the second line below performs a case insensitive match.; if (kwargs['db_mode'].lower() == 'continuous'):; if re.match(r'^sapt', name, flags=re.IGNORECASE):. Match boolean keywords (db_cp in the example below) with expressions like the following, which allow case insensitive yes/true/on/1/no/false/off/0 user input. If your argument’s value is a derivative level, similarly, use input.der0th, input.der1st, and input.der2nd.; if input.yes.match(str(db_cp)):; elif input.no.match(str(db_cp)):. For keywords that might be used in other functions as well as your own, prepend the argument name with a short representation of your function name. For example, there are keywords cp_func, db_func, and opt_func to request what python function, if not energy(), is called by cp(), database(), and optimize(). Upon checking in a new python file, edit the file psi4/doc/userman/source/index.rst and follow the instructions therein that your file may be autodocumented here. Write docstrings! For a major function intended for use in input files, start with the skeleton docstring in psi4/lib/python/example_docstring and replace anything that looks like <this>. For a behind-the-scenes function or if you don’t want the bother of dealing with reStructuredText, just write an ordinary docstring. It will get slurped into the documentation in plain text. Your python function should follow PEP8 conventions (without the line-length restriction). I’m aiming for files to pass the line below, unless for good reason. The second line is for database Python files.; >>> pep8.py -r --ignore=E501 pythonfile.py; >>> pep8.py -r --ignore=E501,E221,E222,E241,E201,E202 databasefile.py. Your python function should not prevent any test case (",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/bestpractices_py-1.html:2876,energy,energy,2876,psi4manual/4.0b2/bestpractices_py-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/bestpractices_py-1.html,8,['energy'],['energy']
Energy Efficiency," natural orbital approximations. omp2p5-1; OMP2.5 cc-pVDZ energy for the H2O molecule. tu5-sapt; Example SAPT computation for ethene*ethine (i.e., ethylene*acetylene), test case 16 from the S22 database. scf-dipder; Test SCF dipole derivatives against old Psi3 reference values. matrix2; An example of using BLAS and LAPACK calls directly from the Psi input file, demonstrating. dft-grad-meta; meta-GGA gradients of water and ssh molecules reference gradients updated due to new BraggSlater radii. mpn-bh; MP(n)/aug-cc-pVDZ BH Energy Point, with n=2-19. Compare against M. L. Leininger et al., J. Chem. Phys. 112, 9213 (2000). fsapt-ext; Quick test of external potential in F-SAPT (see fsapt1 for a real example). psimrcc-ccsd_t-3; Mk-MRCCSD(T) single point. \(^1A_1\) CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. dct7; DCT calculation for the triplet O2 using ODC-06 and ODC-12 functionals. Only simultaneous algorithm is tested. dfomp2-4; OMP2 cc-pVDZ energy for the NO molecule. fd-freq-gradient; SCF STO-3G finite-differences frequencies from gradients for H2O. psithon2; Accesses basis sets, databases, plugins, and executables in non-install locations. opt3; SCF cc-pVDZ geometry optimzation, with Z-matrix input. props3; DF-SCF cc-pVDZ multipole moments of benzene, up to 7th order and electrostatic potentials evaluated at the nuclear coordinates. stability3; Test LDA stability analysis against QChem. dct1; DC-06, DC-12, ODC-06 and ODC-12 calculation for the He dimer. This performs a simultaneous update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the MO Basis. opt-freeze-coords; SCF/cc-pVDZ optimization example with frozen cartesian. scf-level-shift-rks; SCF level shift on an RKS computation. cc1; RHF-CCSD 6-31G** all-electron optimization of the H2O molecule. cc36; CC2(RHF)/cc-pVDZ energy of H2O. tu6-cp-ne2; Example potential energy surface scan and CP-correction for Ne2. fnocc3; Test F",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html:21034,energy,energy,21034,psi4manual/master/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency," natural orbitals (FNO)¶; The computational cost of the CCSD [Purvis:1982], CCSD(T); [Raghavachari:1989], and related methods be reduced by constructing a; compact representation of the virtual space based on the natural orbitals; of second-order perturbation theory [Sosa:1989:148]. The most demanding; steps in the CCSD and (T) algorithms scale as ; and , where and represent the; number of oribitals that are occupied and unoccupied (virtual) in the; reference function, respectively. By reducing the the size of the virtual; space, the cost of evaluating these terms reduces by a factor of , where represents the number of virtual; orbitals retained after the FNO truncation.; The general outline for the FNO procedure in PSI4 is:. construct the virtual-virtual block of the unrelaxed MP2 one-particle density matrix (OPDM); diagonalize this block of the OPDM to obtain a set of natural virtual orbitals; based on some occupancy threshold, determine which orbitals are unimportant and may be discarded; project the virtual-virtual block of the Fock matrix onto the truncated space; construct semicanonical orbitals by diagonalizing the virtual-virtual block of the Fock matrix; proceed with the QCISD(T) / CCSD(T) / MP4 computation in the reduced virtual space. A second-order correction based upon the MP2 energies in the full and; truncated spaces captures much of the missing correlation effects. More; details on the implementation and numerical accuracy of FNO methods in; PSI4 can be found in Ref. [DePrince:2013:293]. FNO computations; are controlled through the keywords NAT_ORBS and; OCC_TOLERANCE, or by prepending a valid method name with “fno” in; the energy call as; energy('fno-ccsd(t)'). QCISD(T), CCSD(T), MP4, and CEPA¶; The FNOCC module in PSI4 supports several related many-body quantum; chemistry methods, including the CCSD(T) and QCISD(T) methods, several; orders of many-body perturbation theory (MP2-MP4), and a family methods; related to the coupled electron pair approxi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/fnocc-1.html:1646,reduce,reduced,1646,psi4manual/4.0b5/fnocc-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/fnocc-1.html,2,['reduce'],['reduced']
Energy Efficiency," natural orbitals (FNO)¶; The computational cost of the CCSD [Purvis:1982], CCSD(T); [Raghavachari:1989], and related methods be reduced by constructing a; compact representation of the virtual space based on the natural orbitals; of second-order perturbation theory [Sosa:1989:148]. The most demanding; steps in the CCSD and (T) algorithms scale as ; and , where and represent the; number of oribitals that are occupied and unoccupied (virtual) in the; reference function, respectively. By reducing the the size of the virtual; space, the cost of evaluating these terms reduces by a factor of , where represents the number of virtual; orbitals retained after the FNO truncation.; The general outline for the FNO procedure in Psi4 is:. construct the virtual-virtual block of the unrelaxed MP2 one-particle density matrix (OPDM); diagonalize this block of the OPDM to obtain a set of natural virtual orbitals; based on some occupancy threshold, determine which orbitals are unimportant and may be discarded; project the virtual-virtual block of the Fock matrix onto the truncated space; construct semicanonical orbitals by diagonalizing the virtual-virtual block of the Fock matrix; proceed with the QCISD(T) / CCSD(T) / MP4 computation in the reduced virtual space. A second-order correction based upon the MP2 energies in the full and; truncated spaces captures much of the missing correlation effects. More; details on the implementation and numerical accuracy of FNO methods in; Psi4 can be found in Ref. [DePrince:2013:293]. FNO computations; are controlled through the keywords NAT_ORBS and; OCC_TOLERANCE, or by prepending a valid method name with “fno” in; the energy call as; energy('fno-ccsd(t)'). If you wish to specify the number of active natural orbitals manually, use; the keyword ACTIVE_NAT_ORBS. This keyword will override the; keyword OCC_TOLERANCE. QCISD(T), CCSD(T), MP4, and CEPA¶; The FNOCC module in Psi4 supports several related many-body quantum; chemistry methods, including ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/fnocc-1.html:2112,reduce,reduced,2112,psi4manual/1.0.0/fnocc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/fnocc-1.html,2,['reduce'],['reduced']
Energy Efficiency," natural orbitals from density (MO basis) if supplied.; Warning! Most post-SCF Wavefunctions do not build the density as this is often; much more costly than the energy. In addition, the Wavefunction density attributes; (Da and Db) return the SO density and must be transformed to the MO basis; to use with this function. New in version 0.5: wfn parameter passed explicitly. Returns; None. Parameters. wfn (Wavefunction) – set of molecule, basis, orbitals from which to generate cube files; filename (str) – destination file name for MOLDEN file (optional); density_a (Matrix) – density in the MO basis to build alpha NO’s from (optional); density_b (Matrix) – density in the MO basis to build beta NO’s from, assumes restricted if not supplied (optional); dovirtual (bool) – do write all the MOs to the MOLDEN file (true) or discard the unoccupied MOs, not valid for NO’s (false) (optional). Examples. Molden file with the Kohn-Sham orbitals of a DFT calculation.; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> molden(wfn, 'mycalc.molden'). Molden file for CI/MCSCF computation using NO roots.; Any method returning a CIWavefunction object will work: detci,; fci, casscf, etc. The first two arguments of get_opdm can be; set to n, n where n => 0 selects the root to write out, provided; these roots were computed, see NUM_ROOTS. The; third argument controls the spin (""A"", ""B"" or ""SUM"") and the final; boolean option determines whether inactive orbitals are included.; >>> E, wfn = energy('detci', return_wfn=True); >>> molden(wfn, 'no_root1.molden', density_a=wfn.get_opdm(0, 0, ""A"", True)). The following produces an INCORRECT Molden file, because the; molden function needs orbitals in the MO basis (which are internally; converted and written to the Molden file in the AO basis). The correct; usage is given in the next point.; >>> E, wfn = energy('ccsd', return_wfn=True); >>> molden(wfn, 'ccsd_no.molden', density_a=wfn.Da()). Molden file with the natural orbitals of the ground-state 1RDM",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.molden-1.html:1297,energy,energy,1297,psi4manual/1.4.0/api/psi4.driver.molden-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.molden-1.html,10,['energy'],['energy']
Energy Efficiency," nbody_dict[var_key] = cp_energy_body_dict[n] - cp_energy_body_dict[1]. _print_nbody_energy(cp_energy_body_dict, ""Counterpoise Corrected (CP)"", metadata['embedding_charges']); cp_interaction_energy = cp_energy_body_dict[metadata['max_nbody']] - cp_energy_body_dict[1]; if monomer_energies != 0.0:; nbody_dict['Counterpoise Corrected Total Energy'] = cp_energy_body_dict[metadata['max_nbody']]; nbody_dict['Counterpoise Corrected Interaction Energy'] = cp_interaction_energy. # Compute nocp energy and ptype; if 'nocp' in metadata['bsse_type_list']:; for n in nbody_range:; if n == metadata['max_frag']:; nocp_energy_body_dict[n] = nocp_energy_by_level[n]; if metadata['ptype'] != 'energy':; nocp_ptype_body_dict[n][:] = nocp_ptype_by_level[n]; continue. for k in range(1, n + 1):; take_nk = nCr(metadata['max_frag'] - k - 1, n - k); sign = ((-1)**(n - k)); value = nocp_energy_by_level[k]; nocp_energy_body_dict[n] += take_nk * sign * value. if metadata['ptype'] != 'energy':; value = nocp_ptype_by_level[k]; nocp_ptype_body_dict[n] += take_nk * sign * value. _print_nbody_energy(nocp_energy_body_dict, ""Non-Counterpoise Corrected (NoCP)"", metadata['embedding_charges']); nocp_interaction_energy = nocp_energy_body_dict[metadata['max_nbody']] - nocp_energy_body_dict[1]; nbody_dict['Non-Counterpoise Corrected Total Energy'] = nocp_energy_body_dict[metadata['max_nbody']]; nbody_dict['Non-Counterpoise Corrected Interaction Energy'] = nocp_interaction_energy. for n in nbody_range[1:]:; var_key = 'NOCP-CORRECTED %d-BODY INTERACTION ENERGY' % n; nbody_dict[var_key] = nocp_energy_body_dict[n] - nocp_energy_body_dict[1]. # Compute vmfc ptype; if 'vmfc' in metadata['bsse_type_list']:; if metadata['ptype'] != 'energy':; for n in nbody_range:; if n > 1:; vmfc_ptype_body_dict[n] = vmfc_ptype_by_level[n - 1]; vmfc_ptype_body_dict[n] += vmfc_ptype_by_level[n]. _print_nbody_energy(vmfc_energy_body_dict, ""Valiron-Mayer Function Couterpoise (VMFC)"",; metadata['embedding_charges']); vmfc_interaction_ene",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html:27341,energy,energy,27341,psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html,2,['energy'],['energy']
Energy Efficiency," nbody_range:; delta_e = (energy_body_dict[n] - previous_e); delta_e_kcal = delta_e * constants.hartree2kcalmol; int_e_kcal = (; energy_body_dict[n] - energy_body_dict[1]) * constants.hartree2kcalmol if not embedding else np.nan; if tot_e:; core.print_out("""""" %4s %20.12f %20.12f %20.12f\n"""""" % (n, energy_body_dict[n], int_e_kcal,; delta_e_kcal)); else:; core.print_out("""""" %4s %20s %20.12f %20.12f\n"""""" % (n, ""N/A"", int_e_kcal,; delta_e_kcal)); previous_e = energy_body_dict[n]; core.print_out(""\n""). [docs]def nbody_gufunc(func: Union[str, Callable], method_string: str, **kwargs):; """"""; Computes the nbody interaction energy, gradient, or Hessian depending on input.; This is a generalized universal function for computing interaction and total quantities. :returns: *return type of func* |w--w| The data. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| data and wavefunction with energy/gradient/hessian set appropriately when **return_wfn** specified. :type func: Callable; :param func: ``energy`` || etc. Python function that accepts method_string and a molecule. Returns a; energy, gradient, or Hessian as requested. :type method_string: str; :param method_string: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, lowercase and usually unlabeled. Indicates the computational; method to be passed to func. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element of a tuple. :type bsse_type: str or list; :param bsse_type: ``'cp'`` || ``['nocp', 'vmfc']`` || |dl| ``None`` |dr| || etc. Type of BSSE correction to compute: CP for counterpoise correction, NoCP; for plain supramolecular interaction energy, or VMFC for Valiron-Mayer; Function Counterpoise correction. If ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html:4256,energy,energy,4256,psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html,2,['energy'],['energy']
Energy Efficiency," next    . previous    ; Psi4 [1.0.0 6a9a71b] » ; Appendices »; Test Suite and Sample Inputs ». Input File; Description. cc24; Single point gradient of 1-2B1 state of H2O+ with EOM-CCSD. cc53; Matches Table II a-CCSD(T)/cc-pVDZ H2O @ 2.5 * Re value from Crawford and Stanton, IJQC 98, 601-611 (1998). soscf2; Triple and Singlet Oxygen energy SOSCF, also tests non-symmetric density matrices. cbs-xtpl-gradient; Various gradients for a strained helium dimer and water molecule. mints5; Tests to determine full point group symmetry. Currently, these only matter for the rotational symmetry number in thermodynamic computations. dcft-grad1; DCFT DC-06 gradient for the O2 molecule with cc-pVDZ basis set. pubchem2; Superficial test of PubChem interface. cepa-module; routing check on lccd, lccsd, cepa(0). cc4a; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. This version tests the FROZEN_DOCC option explicitly. decontract; RHF/cc-pvdz-decontract HCl single-point energy Testing the in line -decontract option for basis sets. dfomp2-grad2; OMP2 cc-pVDZ energy for the NO molecule. pywrap-all; Intercalls among python wrappers- database, cbs, optimize, energy, etc. Though each call below functions individually, running them all in sequence or mixing up the sequence is aspirational at present. Also aspirational is using the intended types of gradients. omp3-4; SCS-OMP3 cc-pVDZ geometry optimization for the H2O molecule. adc2; ADC/aug-cc-pVDZ on two water molecules that are distant from 1000 angstroms from each other. pywrap-db1; Database calculation, so no molecule section in input file. Portions of the full databases, restricted by subset keyword, are computed by sapt0 and dfmp2 methods. opt8; Various constrained energy minimizations of HOOH with cc-pvdz RHF. Cartesian-coordinate constrained optimizations of HOOH in Cartesians. pubchem1; Benzene vertical singlet-triplet energy difference computation, using the PubChem database to obtain the initial geom",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html:1079,energy,energy,1079,psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html,2,['energy'],['energy']
Energy Efficiency," no orbitals of a particular symmetry type a zero must be entered. If the reference function is for an open-shell system, two strings of NIRREP occupation numbers separated by a slash are input for the and sets of orbitals. An example of the use of the OCCUPATION keyword for the water molecule would be OCCUPATION=3-1-1-0. For the water cation, an open-shell system, the keyword would be specified by OCCUPATION=3-1-1-0/2-1-1-0. It should be noted that the xvmol integral program orders the irreducible representations in a strange way, which most users do not perceive to be a logical order. Hence, it is usually advisable initially to run just a single point integral and HF-SCF calculation in order to determine the number and ordering of the irreducible representations. The occupation keyword may be omitted, in which case an initial orbital occupancy is determined by diagonalization of the core Hamiltonian. In many cases, HF-SCF calculations run with the core Hamiltonian guess will usually converge to the lowest energy HF-SCF solution, but this should not be blindly assumed. (Default: The occupation is given by the core Hamiltonian initial guess). Psi4 Interface: The arrays above are specified in PSI as (whitespace-tolerant) [3,1,1,0] and [[3,1,1,0],[3,0,1,0]]. Type: array; Default: No Default. CFOUR_OMP_NUM_THREADS (CFOUR); CFOUR (Expert) — Sets the OMP_NUM_THREADS environment variable before calling CFOUR. If the environment variable OMP_NUM_THREADS is set prior to calling Psi4 then that value is used. When set, this option overrides everything. Be aware the -n command-line option described in section Threading does not affect CFOUR. Type: integer; Default: 1. CFOUR_OPEN-SHELL (CFOUR); CFOUR — Specifies which kind of open-shell CC treatment is employed. The default is a spin-orbital CC treatment (SPIN-ORBITAL =1) which is the only possible choice for UHF-CC schemes anyways. For ROHF-CC treatments, the possible options are beside the standard spin-orbital scheme a spin-r",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:60204,energy,energy,60204,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,2,['energy'],['energy']
Energy Efficiency," no orbitals of a particular symmetry type a zero must be entered. If the reference function is for an open-shell system, two strings of NIRREP occupation numbers separated by a slash are input for the and sets of orbitals. An example of the use of the OCCUPATION keyword for the water molecule would be OCCUPATION=3-1-1-0. For the water cation, an open-shell system, the keyword would be specified by OCCUPATION=3-1-1-0/2-1-1-0. It should be noted that the xvmol integral program orders the irreducible representations in a strange way, which most users do not perceive to be a logical order. Hence, it is usually advisable initially to run just a single point integral and HF-SCF calculation in order to determine the number and ordering of the irreducible representations. The occupation keyword may be omitted, in which case an initial orbital occupancy is determined by diagonalization of the core Hamiltonian. In many cases, HF-SCF calculations run with the core Hamiltonian guess will usually converge to the lowest energy HF-SCF solution, but this should not be blindly assumed. (Default: The occupation is given by the core Hamiltonian initial guess). Psi4 Interface: The arrays above are specified in PSI as (whitespace-tolerant) [3,1,1,0] and [[3,1,1,0],[3,0,1,0]]. Type: array; Default: No Default. CFOUR_OPEN-SHELL¶. Specifies which kind of open-shell CC treatment is employed. The default is a spin-orbital CC treatment (SPIN-ORBITAL =1) which is the only possible choice for UHF-CC schemes anyways. For ROHF-CC treatments, the possible options are beside the standard spin-orbital scheme a spin-restricted CC approach (SR-CC=3), as well as a corresponding linear approximation (which in the literature usually is referred to as partially-spin-adapted CC scheme) (PSA-CC=1). SR-CC and PSA-CC are within the CCSD approximation restricted to excitations defined by the first-order interacting space arguments. With the keywords PSA-CC_FULL (=2) or SR-CC_FULL (=6) inclusion of the so calle",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__cfour-1.html:41941,energy,energy,41941,psi4manual/1.0.0/autodir_options_c/module__cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__cfour-1.html,2,['energy'],['energy']
Energy Efficiency," noCP, VMFC, and CP energy for a helium cluster, limited at 3 bodies; molecule mol {; He 0 0 0; --; He 0 0 4; --; He 0 4 0; --; He 4 0 0; }. # Returns the nocp energy as its first in the list; energy('CCSD(T)', bsse_type=['nocp', 'cp', 'vmfc'], max_nbody=3). API¶. class psi4.driver.driver_nbody.BsseEnum(value)[source]¶; Available basis-set superposition error (BSSE) treatments. cp = 'cp'¶. nocp = 'nocp'¶. vmfc = 'vmfc'¶. pydantic model psi4.driver.driver_nbody.ManyBodyComputer[source]¶. Show JSON schema{; ""title"": ""ManyBodyComputer"",; ""description"": ""Base class for \""computers\"" that plan, run, and process QC tasks."",; ""type"": ""object"",; ""properties"": {; ""molecule"": {; ""title"": ""Molecule"",; ""description"": ""The target molecule, if not the last molecule defined.""; },; ""basis"": {; ""title"": ""Basis"",; ""default"": ""(auto)"",; ""type"": ""string""; },; ""method"": {; ""title"": ""Method"",; ""default"": ""(auto)"",; ""type"": ""string""; },; ""driver"": {; ""description"": ""The computation driver; i.e., energy, gradient, hessian."",; ""allOf"": [; {; ""$ref"": ""#/definitions/DriverEnum""; }; ]; },; ""keywords"": {; ""title"": ""Keywords"",; ""description"": ""The computation keywords/options."",; ""default"": {},; ""type"": ""object""; },; ""bsse_type"": {; ""description"": ""Requested BSSE treatments. First in list determines which interaction or total energy/gradient/Hessian returned."",; ""default"": [; ""cp""; ],; ""type"": ""array"",; ""items"": {; ""$ref"": ""#/definitions/BsseEnum""; }; },; ""nfragments"": {; ""title"": ""Nfragments"",; ""description"": ""Number of distinct fragments comprising full molecular supersystem."",; ""default"": -1,; ""type"": ""integer""; },; ""max_nbody"": {; ""title"": ""Max Nbody"",; ""description"": ""Maximum number of bodies to include in the many-body treatment. Possible: max_nbody <= nfragments. Default: max_nbody = nfragments."",; ""default"": -1,; ""type"": ""integer""; },; ""nbodies_per_mc_level"": {; ""title"": ""Nbodies Per Mc Level"",; ""description"": ""Distribution of active n-body levels among model chemistry levels. All bodies",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/nbody.html:4451,energy,energy,4451,psi4manual/1.7.x/nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/nbody.html,3,['energy'],['energy']
Energy Efficiency," not consistent ... the density; # is e.g. not the proper one (i.e. not the MP(n) one); adc_wfn = core.Wavefunction(ref_wfn.molecule(), ref_wfn.basisset()); adc_wfn.shallow_copy(ref_wfn); adc_wfn.set_reference_wavefunction(ref_wfn); adc_wfn.set_name(name); adc_wfn.set_module(""adcc""). # MP(3) energy for CVS-ADC(3) calculations is still a missing feature in adcc; # ... we store this variant here to be able to fall back to MP(2) energies.; is_cvs_adc3 = state.method.level >= 3 and state.ground_state.has_core_occupied_space. # Ground-state energies; mp = state.ground_state; mp_energy = mp.energy(state.method.level if not is_cvs_adc3 else 2); mp_corr = 0.0; if state.method.level > 1:; core.print_out(""Ground state energy breakdown:\n""); core.print_out("" Energy SCF {0:15.8g} [Eh]\n"".format(ref_wfn.energy())); for level in range(2, state.method.level + 1):; if level >= 3 and is_cvs_adc3:; continue; energy = mp.energy_correction(level); mp_corr += energy; adc_wfn.set_variable(f""MP{level} CORRELATION ENERGY"", energy); adc_wfn.set_variable(f""MP{level} TOTAL ENERGY"", mp.energy(level)); core.print_out(f"" Energy correlation MP{level} {energy:15.8g} [Eh]\n""); core.print_out("" Energy total {0:15.8g} [Eh]\n"".format(mp_energy)); adc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", mp_corr) # P::e ADC; adc_wfn.set_variable(""CURRENT ENERGY"", mp_energy) # P::e ADC. # Set results of excited-states computation; # TODO Does not work: Can't use strings; # adc_wfn.set_variable(""excitation kind"", state.kind); adc_wfn.set_variable(""ADC ITERATIONS"", state.n_iter) # P::e ADC; adc_wfn.set_variable(name + "" excitation energies"",; core.Matrix.from_array(state.excitation_energy.reshape(-1, 1))); adc_wfn.set_variable(""number of excited states"", len(state.excitation_energy)). core.print_out(""\n\n ==> Excited states summary <== \n""); core.print_out(""\n"" + state.describe(oscillator_strengths=False) + ""\n""). # TODO Setting the excitation amplitude elements inside the wavefunction is a little; # challenging,",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:115883,energy,energy,115883,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,2,['energy'],['energy']
Energy Efficiency," not consistent ... the density; # is e.g. not the proper one (i.e. not the MP(n) one); adc_wfn = core.Wavefunction(ref_wfn.molecule(), ref_wfn.basisset()); adc_wfn.shallow_copy(ref_wfn); adc_wfn.set_reference_wavefunction(ref_wfn); adc_wfn.set_name(name); adc_wfn.set_module(""adcc""). # MP(3) energy for CVS-ADC(3) calculations is still a missing feature in adcc; # ... we store this variant here to be able to fall back to MP(2) energies.; is_cvs_adc3 = state.method.level >= 3 and state.ground_state.has_core_occupied_space. # Ground-state energies; mp = state.ground_state; mp_energy = mp.energy(state.method.level if not is_cvs_adc3 else 2); mp_corr = 0.0; if state.method.level > 1:; core.print_out(""Ground state energy breakdown:\n""); core.print_out("" Energy SCF {0:15.8g} [Eh]\n"".format(ref_wfn.energy())); for level in range(2, state.method.level + 1):; if level >= 3 and is_cvs_adc3:; continue; energy = mp.energy_correction(level); mp_corr += energy; adc_wfn.set_variable(f""MP{level} CORRELATION ENERGY"", energy); adc_wfn.set_variable(f""MP{level} TOTAL ENERGY"", mp.energy(level)); core.print_out(f"" Energy correlation MP{level} {energy:15.8g} [Eh]\n""); core.print_out("" Energy total {0:15.8g} [Eh]\n"".format(mp_energy)); adc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", mp_corr) # P::e ADC; adc_wfn.set_variable(""CURRENT ENERGY"", mp_energy) # P::e ADC. # Set results of excited-states computation; # TODO Does not work: Can't use strings; # adc_wfn.set_variable(""excitation kind"", state.kind); adc_wfn.set_variable(""number of excited states"", len(state.excitation_energy)); adc_wfn.set_variable(""ADC ITERATIONS"", state.n_iter) # P::e ADC; methods = [name.upper(), 'ADC']; for excitation in state.excitations:; root_index = excitation.index + 1; for method in methods:; adc_wfn.set_variable(f""{method} ROOT 0 (A) -> ROOT {root_index} (A) EXCITATION ENERGY"",; excitation.excitation_energy); adc_wfn.set_variable(f""{method} ROOT 0 (IN A) -> ROOT {root_index} (IN A) EXCITATION ENERGY"",; excit",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:118160,energy,energy,118160,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,5,['energy'],['energy']
Energy Efficiency," not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DISK_DF'); core.print_out("""""" Method '%s' requires SCF_TYPE = DISK_DF, setting.\n"""""" % name); elif core.get_global_option('SCF_TYPE') == ""DF"":; core.set_global_option('SCF_TYPE', 'DISK_DF'); core.print_out("""""" Method '%s' requires SCF_TYPE = DISK_DF, setting.\n"""""" % name); else:; if core.get_global_option('SCF_TYPE') != ""DISK_DF"":; raise ValidationError("" %s requires SCF_TYPE = DISK_DF, please use SCF_TYPE = DF to automatically choose the correct DFJK implementation."" % name). def print_ci_results(ciwfn, rname, scf_e, ci_e, print_opdm_no=False):; """"""; Printing for all CI Wavefunctions; """""". # Print out energetics; core.print_out(""\n ==> Energetics <==\n\n""); core.print_out("" SCF energy = %20.15f\n"" % scf_e); if ""CI"" in rname:; core.print_out("" Total CI energy = %20.15f\n"" % ci_e); elif ""MP"" in rname:; core.print_out("" Total MP energy = %20.15f\n"" % ci_e); elif ""ZAPT"" in rname:; core.print_out("" Total ZAPT energy = %20.15f\n"" % ci_e); else:; core.print_out("" Total MCSCF energy = %20.15f\n"" % ci_e). # Nothing to be done for ZAPT or MP; if (""MP"" in rname) or (""ZAPT"" in rname):; core.print_out(""\n""); return. # Initial info; ci_nroots = core.get_option(""DETCI"", ""NUM_ROOTS""); irrep_labels = ciwfn.molecule().irrep_labels(). # Grab the D-vector; dvec = ciwfn.D_vector(); dvec.init_io_files(True). for root in range(ci_nroots):; core.print_out(""\n ==> %s root %d information <==\n\n"" % (rname, root)). # Print total energy; root_e = core.get_variable(""CI ROOT %d TOTAL ENERGY"" % (root)); core.print_out("" %s Root %d energy = %20.15f\n"" % (rname, root, root_e)). # Print natural occupations; if print_opdm_no:; core.print_out(""\n Active Space Natural occupation numbers:\n\n""). occs_list = []; r_opdm = ciwfn.get_opdm(root, root, ""SUM"", False); for h in range(len(r_opdm.nph)):; if 0 in r_opdm.nph[h].shape:; continue; nocc, rot = np.linalg.eigh(r_opdm.nph[h]); for e in nocc:; occs_list.append((e, irrep",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc_util.html:5200,energy,energy,5200,psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc_util.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc_util.html,1,['energy'],['energy']
Energy Efficiency," not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DISK_DF'); core.print_out("""""" Method '%s' requires SCF_TYPE = DISK_DF, setting.\n"""""" % name); elif core.get_global_option('SCF_TYPE') == ""DF"":; core.set_global_option('SCF_TYPE', 'DISK_DF'); core.print_out("""""" Method '%s' requires SCF_TYPE = DISK_DF, setting.\n"""""" % name); else:; if core.get_global_option('SCF_TYPE') != ""DISK_DF"":; raise ValidationError("" %s requires SCF_TYPE = DISK_DF, please use SCF_TYPE = DF to automatically choose the correct DFJK implementation."" % name). def print_ci_results(ciwfn, rname, scf_e, ci_e, print_opdm_no=False):; """"""; Printing for all CI Wavefunctions; """""". # Print out energetics; core.print_out(""\n ==> Energetics <==\n\n""); core.print_out("" SCF energy = %20.15f\n"" % scf_e); if ""CI"" in rname:; core.print_out("" Total CI energy = %20.15f\n"" % ci_e); elif ""MP"" in rname:; core.print_out("" Total MP energy = %20.15f\n"" % ci_e); elif ""ZAPT"" in rname:; core.print_out("" Total ZAPT energy = %20.15f\n"" % ci_e); else:; core.print_out("" Total MCSCF energy = %20.15f\n"" % ci_e). # Nothing to be done for ZAPT or MP; if (""MP"" in rname) or (""ZAPT"" in rname):; core.print_out(""\n""); return. # Initial info; ci_nroots = core.get_option(""DETCI"", ""NUM_ROOTS""); irrep_labels = ciwfn.molecule().irrep_labels(). # Grab the D-vector; dvec = ciwfn.D_vector(); dvec.init_io_files(True). for root in range(ci_nroots):; core.print_out(""\n ==> %s root %d information <==\n\n"" % (rname, root)). # Print total energy; root_e = core.variable(""CI ROOT %d TOTAL ENERGY"" % (root)); core.print_out("" %s Root %d energy = %20.15f\n"" % (rname, root, root_e)). # Print natural occupations; if print_opdm_no:; core.print_out(""\n Active Space Natural occupation numbers:\n\n""). occs_list = []; r_opdm = ciwfn.get_opdm(root, root, ""SUM"", False); for h in range(len(r_opdm.nph)):; if 0 in r_opdm.nph[h].shape:; continue; nocc, rot = np.linalg.eigh(r_opdm.nph[h]); for e in nocc:; occs_list.append((e, irrep_lab",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc_util.html:5069,energy,energy,5069,psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc_util.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc_util.html,1,['energy'],['energy']
Energy Efficiency," not currently recognized by Psi4. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (str) – 'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; Hartree–Fock (HF) or density functional theory (DFT) [manual] [details]. hf; HF self consistent field (SCF) [manual] [details]. dct; density cumulant (functional) theory [manual]. mp2; 2nd-order Møller–Plesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order Møller–Plesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized second-order MP perturbation theory [manual] [details]. omp3; orbital-optimized third-order MP perturbation theory [manual] [details]. omp2.5; orbital-optimized MP2.5 [manual] [details]. oremp2; orbital-optimized REMP2 [manual] [details]. lccd; Linear CCD [manual] [details]. olccd; orbital optimized LCCD [manual] [details]. cc2; approximate coupled cluster singles and doubles (CC2) [manual] [details]. ccd; coupled cluster doubles (CCD) [manual] [details]. ccsd; coupled cluster singles and dou",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.opt.html:2669,energy,energy,2669,psi4manual/1.7.x/api/psi4.driver.opt.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.opt.html,12,['energy'],['energy']
Energy Efficiency," not linear in the optimized structure but is in a symmetry plane of the molecule. nbody-vmfc-gradient; Computation of VMFC-corrected water trimer gradient (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). mp2-property; MP2 cc-pvDZ properties for Nitrogen oxide. x2c3; Test of SFX2C-1e on Water uncontracted cc-pVDZ The reference numbers are from Lan Cheng’s implementation in Cfour. scf3; File retention, docc, socc, and bond distances specified explicitly. dfomp2-grad1; DF-OMP2 cc-pVDZ gradients for the H2O molecule. fci-tdm; He2+ FCI/cc-pVDZ Transition Dipole Moment. options1; check all variety of options parsing. cbs-xtpl-energy-conv; Extrapolated water energies - conventional integrals version. rasci-c2-active; 6-31G* C2 Test RASCI Energy Point, testing two different ways of specifying the active space, either with the ACTIVE keyword, or with RAS1, RAS2, RESTRICTED_DOCC, and RESTRICTED_UOCC. isapt-charged; This test case shows an example of running the I-SAPT0/aug-cc-pVDZ computation for a positively charged system, illustrating the cation-pi interaction. The SIAO1 link partitioning algorithm is used. The system is taken from http://dx.doi.org/10.1016/j.comptc.2014.02.008. fnocc7; Test fnocc with linear dependencies. fnocc6; Test method/basis with disk_df. tdscf-2; td-uhf test on triplet states of methylene (tda), wfn passing. cc26; Single-point gradient, analytic and via finite-differences of 2-1A1 state of H2O with EOM-CCSD. cc55; EOM-CCSD/6-31g excited state transition data for water with two excited states per irrep. dfmp2-1; Density fitted MP2 cc-PVDZ/cc-pVDZ-RI computation of formic acid dimer binding energy using automatic counterpoise correction. Monomers are specified using Cartesian coordinates. dct3; DC-06 calculation for the He dimer. This performs a simultaneous update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the AO Basis, using integrals stored on disk. pywrap-alias; Test parsed and exoti",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html:38886,charge,charged,38886,psi4manual/master/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html,4,['charge'],['charged']
Energy Efficiency," not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type return_history: :ref:`boolean <op_py_boolean>`; :param return_history: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type hessian_with: string; :param hessian_with: ``'scf'`` || ``'mp2'`` || etc. Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. .. warning:: Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. .. note:: Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. .. _`table:grad_gen`:. +-------------------------+---------------------------------------------------------------------------------------------------------------+; | name | calls method |; +=========================+=============================================================================================================",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html:49080,energy,energy,49080,psi4manual/1.3.2/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html,1,['energy'],['energy']
Energy Efficiency," not yet implemented. Buy a developer some coffee. - In sow/reap mode, use only global options (e.g., the local option set by ``set scf scf_type df`` will not be respected). .. note:: To access a database that is not embedded in a |PSIfour|; distribution, add the path to the directory containing the database; to the environment variable :envvar:`PYTHONPATH`. :type name: string; :param name: ``'scf'`` || ``'sapt0'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`~driver.energy`. :type db_name: string; :param db_name: ``'BASIC'`` || ``'S22'`` || ``'HTBH'`` || etc. Second argument, usually unlabeled. Indicates the requested database; name, matching (case insensitive) the name of a python file in; ``psi4/share/databases`` or :envvar:`PYTHONPATH`. Consult that; directory for available databases and literature citations. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on each database; member. The default performs a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs`` performs a compound single-point energy. If a nested series; of python functions is intended (see :ref:`sec:intercalls`), use; keyword ``db_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. Indicates whether the calculations required to complete the; database are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type cp: :ref:`boolean <op_py_boolean>`; :param cp: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether counterpoise correction is employed in computing; interaction energies. U",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html:3430,energy,energy,3430,psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html,4,['energy'],['energy']
Energy Efficiency," nso: int) -> bool. Load a matrix from a PSIO object from fileno with tocentry of size nso. load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType=SaveType.LowerTriangle) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str) → None¶; Loads a matrix from an ASCII file in MPQC format. nirrep(self: psi4.core.Matrix) → int¶; Returns the number of irreps. classmethod np_read(filename, prefix='')¶; Reads the data from a NumPy compress file. np_write(filename=None, prefix='')¶; Writes the irreped matrix to a NumPy zipped file.; Can return the packed data for saving many matrices into the same file. partial_cholesky_factorize(self: psi4.core.Matrix, delta: float=0.0, throw_if_negative: bool=False) → psi4.core.Matrix¶; Computes the fully pivoted partial Cholesky factorization of a real symmetric positive semidefinite matrix, to numerical precision delta. power(self: psi4.core.Matrix, alpha: float, cutoff: float=1e-12) → psi4.core.Dimension¶; Takes the matrix to the alpha power with precision cutoff. print_atom_vector(self: psi4.core.Matrix, RMRoutfile: str='outfile') → None¶; Print the matrix with atom labels, assuming it is an natom X 3 tensor. print_out(self: psi4.core.Matrix) → None¶; Prints the matrix to the output file. pseudoinverse(self: psi4.core.Matrix, condition: float, nremoved: int) → psi4.core.Matrix¶; Computes the matrix which is the conditioned pseudoinverse of this matrix. remove_symmetry(self: psi4.core.Matrix, a: psi4.core.Matrix, transformer: psi4.core.Matrix) → None¶; Remove symmetry from a matrix A with PetiteList::sotoao(). rms(self: psi4.core.Matrix) → float¶; Returns the rms of this matrix. rotate_columns(self: psi4.core.Matrix, h: int, i: int, j: int, theta: float) → None¶; Rotates columns i and j in irrep h by angle theta. rowdim(self: psi4.core.Matrix) → psi4.core.Dimension¶; Returns the rows per irrep array. rows(se",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.matrix.html:11812,power,power,11812,psi4manual/1.3.2/api/psi4.core.matrix.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.matrix.html,2,['power'],['power']
Energy Efficiency," number of a posteriori dispersion corrections are available in; PSI4. While some are computed within PSI4‘s codebase (-D1, -D2,; -CHG, -DAS2009, -DAS2010), the -D3 or -D4 corrections and their variants are; available only through the DFTD3 or DFTD4 programs. Once installed, the; dftd3/PSI4 and dftd4/PSI4 interfaces are transparent, and all corrections are; interfaced exactly alike.; The -D3 interface can use classic or simple-dftd3 programs interchangeably and will prefer the latter.; Despite different defaults in these programs when run independently,; when run through PSI4 as EmpiricalDispersion engine, each should; produce the same result. Moreover, PSI4‘s own defaults and aliases; are unchanged by the new engines, so -D continues to mean -D2,; -D3 continues to mean zero-damping without 3-body correction,; and input files should continue producing the same results. Please file; an issue if found otherwise.; Dispersion corrections are built into DFT functionals, so appending an a; posteriori correction to a computation is as simple as; energy('b2plyp-d') vs. energy('b2plyp'). For example, the; following input file computes (with much redundant work) for water a; B3LYP, a B3LYP-D2, a B3LYP-D3 (zero-damping), and a B3LYP-D4 (Becke-Johnson damping) energy.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('b3lyp'); energy('b3lyp-d'); energy('b3lyp-d3'); energy('b3lyp-d4'). Consult the table -D Functionals to see for each; functional what corrections are available and what default parameters; define them. The dispersion correction is available after a calculation in; the PSI variable DISPERSION CORRECTION ENERGY.; By default, the output from the dftd3; program is suppressed; to see it in the output file, set print > 2.; No text output is available from the dftd4 or s-dftd3 programs. Variants of dispersion corrections¶. Extension [1] and Aliases; Variant; Computing Program (engine); DFT_DISPERSION_PARAMETERS [11]. -D; alias to -D2. -D1; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/dftd3.html:6990,energy,energy,6990,psi4manual/1.7.x/dftd3.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/dftd3.html,2,['energy'],['energy']
Energy Efficiency," number, so scheme must be specified explicitly.; No way to tell function to boost fitting basis size for all calculations.; No way to extrapolate def2 family basis sets; Need to add more extrapolation schemes; Must specify conventional or density-fitted mp2 through kwargs ; with value ‘conv-mp2’ or ‘df-mp2’, not with c-side option. As represented in the equation below, a CBS energy method is defined in four; sequential stages (scf, corl, delta, delta2) covering treatment of the; reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction. Each is activated by its; stage_wfn keyword and is only allowed if all preceding stages are active. Here, is an energy or energy extrapolation scheme, and the following also hold. A translation of this ungainly equation to example [5] below is as; follows. In words, this is a double- and triple-zeta 2-point; Helgaker-extrapolated CCSD(T) coupled-cluster correlation correction; appended to a triple- and quadruple-zeta 2-point; Helgaker-extrapolated MP2 correlation energy appended to a SCF/aug-cc-pVQZ; reference energy. Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy.; The cbs() function requires, at a minimum, name='scf' and scf_basis; keywords to be specified for reference-step only jobs and name and; corl_basis keywords for correlated jobs.; The following energy methods have been set up for cbs(). scf; df-scf; mp2. df-mp2; cc2; ccsd. bccd; cc3; ccsd(t). cisd; cisdt; cisdtq. cin; fci. Parameters:; name (string) – 'scf' || 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be 'scf'. Overruled if stage_wfn keywords supplied. corl_wfn (string) – 'mp2' || 'ccsd(t)' || etc.; Indicates the energy method for",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/cbs-1.html:2180,energy,energy,2180,psi4manual/4.0b3/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/cbs-1.html,4,['energy'],['energy']
Energy Efficiency," of Atomic Densities. Builds the initial density as the; spin-averaged sum of atomic UHF computations in the current basis. If an; open-shell system, uniform scaling of the spin-averaged density matrices is; performed. If orbitals are needed (e.g., in density fitting), a partial; Cholesky factorization of the density matrices is used. Often extremely; accurate, particularly for closed-shell systems.; GWH; Generalized Wolfsberg-Helmholtz, a simple Huckel-Theory-like method based on; the overlap and core Hamiltonian matrices. May be useful in open-shell systems.; READ; Read the previous orbitals from a checkpoint file, casting from one basis to; another if needed. Useful for starting anion computations from neutral; orbitals, or after small geometry changes. At present, casting from a; different molecular point group is not supported. These are all set by the GUESS keyword. Also, an automatic Python; procedure has been developed for converging the SCF in a small basis, and then; casting up to the true basis, This can be done by placing a cast_up =; 'SMALL_BASIS' modifier in the energy() procedure call. We recommend the; 3-21G basis for the small basis due to its efficient mix of flexibility and; compactness. An example of performing an RHF solution of water by SAD guessing; in a 3-21G basis and then casting up to cc-pVTZ is shown below:; molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; basis cc-pvtz; guess sad; }. energy('scf', cast_up = '3-21G'). With regard to convergence stabilization, Pulay’s Direct Inversion of the; Iterative Subspace (DIIS) extrapolation, Gill’s Maximum Overlap Method (MOM),; and damping are all implemented. A summary of each is presented below,. DIIS [On by Default]; DIIS uses previous iterates of the Fock Matrix together; with an error criterion based on the orbital gradient to produce an informed; estimate of the next Fock Matrix. DIIS is almost always necessary to converge; the SCF procedure and is therefore turned on by default. I",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/scf-1.html:14110,energy,energy,14110,psi4manual/4.0b2/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf-1.html,2,['energy'],['energy']
Energy Efficiency," of S auxiliary functions iwth Df coefficients. addCharge(self, Z, x, y, z); Add a charge Z at (x,y,z). appendCharges(self, arg0); Append a vector of charge tuples to a current ExternalPotential. clear(self); Reset the field to zero (eliminates all entries). computeExternExternInteraction(self, arg0); Compute the interaction between this potential and other external potential. computeNuclearEnergy(self, arg0); Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self, basis); Compute the external potential matrix in the given basis set. getCharges(self); Get the vector of charge tuples. print_out(self); Print python print helper to the outfile. setName(self, arg0); Sets the name. Methods Documentation. addBasis(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet, coefs: psi4.core.Vector) → None¶; Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self: psi4.core.ExternalPotential, Z: float, x: float, y: float, z: float) → None¶; Add a charge Z at (x,y,z). appendCharges(self: psi4.core.ExternalPotential, arg0: List[Tuple[float, float, float, float]]) → None¶; Append a vector of charge tuples to a current ExternalPotential. clear(self: psi4.core.ExternalPotential) → None¶; Reset the field to zero (eliminates all entries). computeExternExternInteraction(self: psi4.core.ExternalPotential, arg0: psi4.core.ExternalPotential) → float¶; Compute the interaction between this potential and other external potential. computeNuclearEnergy(self: psi4.core.ExternalPotential, arg0: psi4.core.Molecule) → float¶; Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet) → psi4.core.Matrix¶; Compute the external potential matrix in the given basis set. getCharges(self: psi4.core.ExternalPotential) → List[Tuple[float, float, float, float]]¶; Get the vector of charge tuples. print_out(self: psi4.core.Exte",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.ExternalPotential.html:1395,charge,charge,1395,psi4manual/1.6.x/api/psi4.core.ExternalPotential.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.ExternalPotential.html,3,['charge'],['charge']
Energy Efficiency," of SFX2C-1e on water uncontracted cc-pVDZ-DK The reference numbers are from Lan Cheng’s implementation in Cfour. scf-bz2; Benzene Dimer Out-of-Core HF/cc-pVDZ. pywrap-checkrun-uhf; This checks that all energy methods can run with a minimal input and set symmetry. psimrcc-ccsd_t-1; Mk-MRCCSD(T) single point. \(^1A_1\) CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. tdscf-2; td-uhf test on triplet states of methylene (tda), wfn passing. scf11-freq-from-energies; Test frequencies by finite differences of energies for planar C4NH4 TS. dfcasscf-sa-sp; Example of state-averaged CASSCF for the C2 molecule. dft1-alt; DFT Functional Test. cc14; ROHF-CCSD/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. cc4; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. After the computation, the checkpoint file is renamed, using the PSIO handler. ghosts; Density fitted MP2 cc-PVDZ/cc-pVDZ-RI computation of formic acid dimer binding energy using explicit specification of ghost atoms. This is equivalent to the dfmp2_1 sample but uses both (equivalent) specifications of ghost atoms in a manual counterpoise correction. phi-ao; Test computing values of basis functions (puream and non-puream) at points. fd-freq-energy; SCF STO-3G finite-difference frequencies from energies for H2O. cisd-opt-fd; H2O CISD/6-31G** Optimize Geometry by Energies. mbis-6; MBIS calculation on H2O. scf-hess1; RHF STO-3G (Cartesian) and cc-pVDZ (spherical) water Hessian test, against Psi3 reference values. scf-guess-read1; Sample UHF/cc-pVDZ H2O computation on a doublet cation, using RHF/cc-pVDZ orbitals for the closed-shell neutral as a guess. cc13b; Tests RHF CCSD(T)gradients. soscf-large; Second-order SCF convergnece: Benzene. mints-helper; A general test of the MintsHelper function. sapt-dft1; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. pywrap-checkrun-convcrit; Advanced python example sets different ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html:26561,energy,energy,26561,psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency," of a single electron; pair between monomers.; The \(S^{2}\) approximation is usually pretty good, but may; break down for short intermolecular distance, particularly in high-order; terms. To compensate these deviations, Parker et al. [Parker:2014:094106]; recommend to scale all \(S^{2}\) approximated exchange terms by the ratio:. \[p_{EX}(\alpha) = \left( \frac{E_{exch}^{(10)}}{E_{exch}^{(10)}(S^{2})} \right)^{\alpha}\]; where the recommended exponent is \(\alpha = 1\). To obtain SAPT energies with this scaling,; simply set the keyword exch_scale_alpha true. Alternatively, another value for \(\alpha\); can be specified by setting EXCH_SCALE_ALPHA to a value. For example,; set exch_scale_alpha 1.0. will set \(\alpha = 1.0\) and scale exchange energies with \(p_{EX}(1.0)\).; Instead of this straightforward scaling, SAPT0 energies benefit from a slightly modified; recipe that involves an empirically adjusted exponent \(\alpha = 3.0\).; To distinguish it from its unscaled counterpart, this energy is denoted sSAPT0 (see [Parker:2014:094106]). (9)¶\[E_{sSAPT0} = E_{elst}^{(10)} + E_{exch}^{(10)} + E_{ind,resp}^{(20)} +; p_{EX}(3.0) E_{exch-ind,resp}^{(20)} + E_{disp}^{(20)} + p_{EX}(3.0) E_{exch-disp}^{(20)}; + \delta_{HF}^{(2)}\]; where \(\delta_{HF}^{(2)}\) is computed without any scaling. Please note that; sSAPT0 is thus not the same as requesting exch_scale_alpha 3.0, and that the; scaling is automatically performed by requesting energy('ssapt0'). A First Example¶; The following is the simplest possible input that will perform all; available SAPT computations (normally, you would pick one of these methods,; not all of them).; molecule water_dimer {; 0 1; O -1.551007 -0.114520 0.000000; H -1.934259 0.762503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.680398 -0.373741 -0.758561; H 1.680398 -0.373741 0.758561. units angstrom; no_reorient; symmetry c1; }. set basis aug-cc-pvdz. energy('sapt0'); energy('sapt2'); energy('sapt2+'); en",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/sapt-1.html:9463,energy,energy,9463,psi4manual/1.4.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/sapt-1.html,7,['energy'],['energy']
Energy Efficiency," of an ovvv quantity in-core, but is sufficient to hold at least two copies of an oovv quantity in-core. cc13; UHF-CCSD/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. mbis-3; MBIS calculation on OH radical. cc4; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. After the computation, the checkpoint file is renamed, using the PSIO handler. dft-grad-disk; A range-seperated gradient for SO2 to test disk algorithms by explicitly setting low memory. mcscf3; RHF 6-31G** energy of water, using the MCSCF module and Z-matrix input. cisd-sp; 6-31G** H2O Test CISD Energy Point. cbs-xtpl-alpha; Extrapolated water energies. tdscf-3; td-wb97x excitation energies of singlet states of h2o, wfn passing. cbs-xtpl-nbody; RHF interaction energies using nbody and cbs parts of the driver Ne dimer with mp2/v[dt]z + d:ccsd(t)/vdz. cc13b; Tests RHF CCSD(T)gradients. olccd-grad1; OLCCD cc-pVDZ gradient for the H2O molecule. omp2p5-1; OMP2.5 cc-pVDZ energy for the H2O molecule. scf-dipder; Test SCF dipole derivatives against old Psi3 reference values. cc13a; UHF-CCSD(T)/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. tu4-h2o-freq; Optimization followed by frequencies H2O HF/cc-pVDZ. tdscf-4; td-wb97x singlet excitation energies of methylene (tda). mbis-4; MBIS calculation on NaCl. numpy-array-interface; Numpy interface testing. props1; RHF STO-3G dipole moment computation, performed by applying a finite electric field and numerical differentiation. fci-dipole; 6-31G H2O Test FCI Energy Point. dft-custom-dhdf; DSD-PBEP86 S22 Ammonia test. cisd-h2o+-2; 6-31G** H2O+ Test CISD Energy Point. scf5; Test of all different algorithms and reference types for SCF, on singlet and triplet O2, using the cc-pVTZ basis set. mints8; Patch of a glycine with a methyl group, to make alanine, then DF-SCF energy calculation with the cc-pVDZ basis set. ci-multi; BH single points, checking that program can run multiple instances of DETCI in ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html:16105,energy,energy,16105,psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency," of analysis gives a lot; of insight into the nature of intermolecular interactions, and PSI4; makes these computations easier than ever.; For a SAPT computation, the input needs to provide information on two; distinct molecules. This is very easy, we just give a Z-matrix or set of; Cartesian coordinates for each molecule, and separate the two with two; dashes, like this:; # Example SAPT computation for ethene*ethine (*i.e.*, ethylene*acetylene),; # test case 16 from the S22 database. molecule dimer {; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; units angstrom. }. Here’s the second half of the input, where we specify the computation; options:; set {; basis jun-cc-pVDZ; scf_type DF; freeze_core True; }. energy('sapt0'). Before, we have been setting keywords individually with commands like; set basis cc-pVDZ. Because we have a few more options now, it’s; convenient to place them together into the set; block, bounded by {...}. This; will set all of these options as “global” options (meaning that they are; visible to all parts of the program). Most common PSI4 options can be; set in a globals section like this. If an option needs to be visible; only to one part of the program (e.g., we only want to increase the; energy convergence in the SCF code, but not the rest of the; code), it can be placed in a section of input visible to that part of the; program (e.g., set scf e_convergence 1.0E-8).; Back to our SAPT example, we have found that for basic-level SAPT; computations (i.e., SAPT0), a good error cancellation is found; [Hohenstein:2012:WIREs] with the jun-cc-pVDZ basis (this is the; usual aug-cc-pVDZ basis, but without diffuse functions on hydrogen and; without diffuse \(d\) functions on heavy ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/tutorial-1.html:11338,energy,energy,11338,psi4manual/1.4.0/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/tutorial-1.html,9,['energy'],['energy']
Energy Efficiency," of benzene-hydronium ion, scanning the dissociation coordinate with Python’s built-in loop mechanism. The geometry is specified by a Z-matrix with dummy atoms, fixed parameters, updated parameters, and separate charge/multiplicity specifiers for each monomer. One-electron properties computed for dimer and one monomer. olccd-freq1; OLCCD cc-pVDZ freqs for C2H2. mp2-grad2; MP2 cc-pVDZ gradient for the NO radical. scf-guess-read1; Sample UHF/cc-pVDZ H2O computation on a doublet cation, using RHF/cc-pVDZ orbitals for the closed-shell neutral as a guess. cepa-module; routing check on lccd, lccsd, cepa(0). scf4; RHF cc-pVDZ energy for water, automatically scanning the symmetric stretch and bending coordinates using Python’s built-in loop mechanisms. The geometry is specified using a Z-matrix with variables that are updated during the potential energy surface scan, and then the same procedure is performed using polar coordinates, converted to Cartesian coordinates. dfccdl1; DF-CCDL cc-pVDZ energy for the H2O molecule. cc13b; Tests RHF CCSD(T)gradients. nbody-hessian; Computation of VMFC-corrected HF dimer Hessian. sapt-compare; SAPT0 aug-cc-pVDZ computation of the water-water interaction energy, using the three SAPT codes. sapt-exch-ind30-inf; SAPT2+3 with S^inf exch-ind30 Geometries taken from the S66x10 database, the shortest-range point (R = 0.7 R_e). pywrap-molecule; Check that C++ Molecule class and qcdb molecule class are reading molecule input strings identically. dft-dens-cut; LibXC density screening test. Tests empty, C-only, X-only and XC superfunctionals. ‘super_mix’ showcases how to use different screening values for X and C parts. SCF will fail or crash (nans) without screening!. fd-freq-gradient; SCF STO-3G finite-differences frequencies from gradients for H2O. castup2; SCF with various combinations of pk/density-fitting, castup/no-castup, and spherical/cartesian settings. Demonstrates that puream setting is getting set by orbital basis for all df/castup par",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html:29489,energy,energy,29489,psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency," of bimolecular complexes. rlxd (boolean) – 'on' || 'off' ; Indicates whether correction for deformation energy is; employed in computing interaction energies. Option available; (See Available Databases) only for databases of bimolecular complexes; with non-frozen monomers, e.g., HBC6. symm (boolean) – 'on' || 'off'; Indicates whether the native symmetry of the database reagents is; employed ('on') or whether it is forced to symmetry; ('off'). Some computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). zpe (boolean) – 'on' || 'off' ; Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. benchmark (string) – 'default' || 'S22A' || etc.; Indicates whether a non-default set of reference energies, if; available (See Available Databases), are employed for the; calculation of error statistics. tabulate (array of strings) – [] || ['scf total energy', 'natom'] || etc.; Indicates whether to form tables of variables other than the; primary requested energy. Available for any PSI variable. subset (string or array of strings) – Indicates a subset of the full database to run. This is a very; flexible option and can be used in three distinct ways, outlined; below. Note that two take a string and the last takes an array.; See Available Databases for available values. 'small' || 'large' || 'equilibrium'; Calls predefined subsets of the requested database, either; 'small', a few of the smallest database members,; 'large', the largest of the database members, or; 'equilibrium', the equilibrium geometries for a database; composed of dissociation curves. 'BzBz_S' || 'FaOOFaON' || 'ArNe' || 'HB' || etc.; For databases composed of dissociation curves, or otherwise; divided into subsets, individual curves and subsets can be; called by name. Consult the database python files for available; molecular systems (case insensitive). ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/db-1.html:3798,energy,energy,3798,psi4manual/1.0.0/db-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/db-1.html,8,['energy'],['energy']
Energy Efficiency," of bimolecular complexes. rlxd (boolean) – 'on' || 'off' ; Indicates whether correction for deformation energy is; employed in computing interaction energies. Option available; (See Available Databases) only for databases of bimolecular complexes; with non-frozen monomers, e.g., HBC6. symm (boolean) – 'on' || 'off'; Indicates whether the native symmetry of the database reagents is; employed ('on') or whether it is forced to symmetry; ('off'). Some computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). zpe (boolean) – 'on' || 'off' ; Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. benchmark (string) – 'default' || 'S22A' || etc.; Indicates whether a non-default set of reference energies, if; available (See Available Databases), are employed for the; calculation of error statistics. tabulate (array of strings) – [] || ['scf total energy', 'natom'] || etc.; Indicates whether to form tables of variables other than the; primary requested energy. Available for any PSI variable. subset (string or array of strings) – Indicates a subset of the full database to run. This is a very; flexible option and can be used in three distinct ways, outlined; below. Note that two take a string and the last takes an array.; See Available Databases for available values. 'small' || 'large' || 'equilibrium'; Calls predefined subsets of the requested database, either; 'small', a few of the smallest database members,; 'large', the largest of the database members, or; 'equilibrium', the equilibrium geometries for a database; composed of dissociation curves. 'BzBz_S' || 'FaOOFaON' || 'ArNe' || etc.; For databases composed of dissociation curves, individual; curves can be called by name. Consult the database python; files for available molecular systems. The choices for this; keyword are case sensitive and must match the databas",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/db-1.html:3483,energy,energy,3483,psi4manual/4.0b2/db-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/db-1.html,2,['energy'],['energy']
Energy Efficiency," of core memory used in integer words (default) or in the units specified via the keyword CFOUR_MEM_UNIT Default: 100 000 000 (approximately 381 or 762 MB for 32 or 64 bit machines, respectively). Psi4 Interface: Keyword set in MB from memory input command when given. Type: integer; Default: 100000000. CFOUR_MEM_UNIT¶. Specifies the units in which the amount of requested core memory is given. Possible choices are INTEGERWORDS (default), kB, MB, GB, and TB. Psi4 Interface: Keyword set from memory input command when given, always MB. Type: string; Possible Values: INTEGERWORDS, KB, MB, GB, TB; Default: INTEGERWORDS. CFOUR_METHOD¶. Specifies the geometry optimization strategy. Four values are permitted: NR (=0) – Straightforward Newton-Raphson search for minimum; RFA (=1) – Rational Function Approximation search for minimum (this method can be used to find minima when the initial structure is in a region where the Hessian index is nonzero); TS (=2) Cerjan-Miller eigenvector following search for a transition state (can be started in a region where the Hessian index is not equal to unity); MANR (=3) – Morse-adjusted Newton-Raphson search for minimum (very efficient minimization scheme, particularly if the Hessian is available); 4 is currently unavailable; SINGLE_POINT (=5) is a single point calculation. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) use PSI’s optimizer and so this keyword has no effect. Use optking keywords instead, particularly OPT_TYPE and STEP_TYPE. Type: string; Possible Values: NR, RFA, TS, MANR, SINGLE_POINT; Default: SINGLE_POINT. CFOUR_MRCC¶. Specifies the type of MRCC calculation. MK performs a MR-CC calculation based on Mukherjee’s ansatz. Type: boolean; Default: false. CFOUR_MULTIPLICITY¶. Specifies the spin multiplicity. Psi4 Interface: Keyword set from active molecule. Type: integer; Default: 1. CFOUR_NACOUPLING¶. Calculation of non-adiabatic coupling. In case of ON (=1) the method by Ichino, Gauss, Stanton i",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__cfour-1.html:37659,efficient,efficient,37659,psi4manual/1.3.2/autodir_options_c/module__cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__cfour-1.html,17,['efficient'],['efficient']
Energy Efficiency," of isotopologs (see manual entries associated with anharmonic calculations for an example); 2) calculation of vibrational energy levels with VPT2. This keyword also directs the program to analyze resonances and calculate intensities of one- and two-quantum transitions. FULLQUARTIC (=2) (not part of the public release) is largely self-explanatory; it directs the program to calculate all quartic constants. This is sufficient (but this has not been implemented) to generate the full quartic force field of all isotopologs. Type: string; Possible Values: CUBIC, VPT2, FULLQUARTIC, VIBROT, OFF; Default: OFF. CFOUR_AO_LADDERS (CFOUR); CFOUR — Can be used to control the algorithm used by CFOUR when terms involving \(\langle ab||cd\rangle\) molecular orbital integrals are calculated in the atomic orbital basis (see CFOUR_ABCDTYPE). MULTIPASS (= 0) uses an approach where the AO integral file is read a number of times in order to ensure maximal vectorization and is usually the optimal strategy on supercomputers; SINGLEPASS (= 1) determines the contributions with only a single pass through the AO integrals, but at the cost of significantly reduced vectorization. In general, however, SINGLEPASS is definitely preferable on workstations with RISC architectures. (Default : MULTIPASS on all 64-bit machines (e.g., CRAY-YMP) ; SINGLEPASS on all 32-bit machines (e.g., IBM-RS6000, HP-735, SGI-Indigo, DEC alphastations)). SPARSE_AO (=2) uses a sparse matrix algorithm which first rearranges the integral matrix in order to get “well-occupied” and “very sparse” blocks. “Well-occupied” blocks will be multiplied by matrix multiplication while in “very sparse” blocks only the non-zero elements are considered. The computational time is further reduced using symmetrized and anti-symmetrized integral and amplitude matrices in the multiplication. Substantial saving is assumed if SPARSE_AO (=2) is used. Type: string; Possible Values: MULTIPASS, SINGLEPASS; Default: SINGLEPASS. CFOUR_AV_SCF (CFOUR); ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html:22352,reduce,reduced,22352,psi4manual/1.2.1/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html,6,['reduce'],['reduced']
Energy Efficiency," of negative eigenvalues in the orbital rotation Hessian. A third option, FOLLOW (=2) performs the stability analysis and then proceeds to rotate the SCF orbitals in the direction of a particular negative eigenvalue of the orbital rotation Hessian (see the explanation of keyword CFOUR_ROT_EVEC , after which the SCF is rerun. Type: string; Possible Values: OFF, ON, FOLLOW; Default: OFF. CFOUR_INCORE¶. This keyword can be used to significantly reduce disk i/o, and should be implemented very soon. The following options are available: OFF (= 0), no special algorithms are used (the default case); ALL (=1) all quantities except the molecular integral lists are held in core; PARTIAL (= 2), the T2 and T1 vectors are held in core throughout the calculation; (=4) all quantities except the and integrals are held in core; (=5) and and two-index quantities are held in core; (=6) all direct access files (MOINTS, GAMLAM, etc.) are held in core. At present, these options have been implemented only in the energy code xvcc and the excitation energy code xvee. (Default: 0). Type: string; Possible Values: OFF, ALL, PARTIAL; Default: OFF. CFOUR_INPUT_MRCC¶. Specifies whether an input for mrcc is written (ON, =0) or not (OFF, =1) if CFOUR_CC_PROGRAM =EXTERNAL has been specified. Type: boolean; Default: true. CFOUR_INTEGRALS¶. This keyword defines what type of integral input will be written by xjoda. VMOL (=1) has to be used with the programs of CFOUR. Using ARGOS (=0), input for Pitzer’s ARGOS integral program will be written. (Default: VMOL). Type: string; Possible Values: VMOL, ARGOS; Default: VMOL. CFOUR_JODA_PRINT¶. Controls amount of debug printing performed by xjoda. The higher the number, the more information is printed. Values of 25 or higher generally do not produce anything of interest to the general user. Do not set JODA_PRINT to 999 as this will cause the core vector to be dumped to disk. Type: integer; Default: 0. CFOUR_LINEQ_CONV¶. Convergence threshold for linear equations",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__cfour-1.html:34165,energy,energy,34165,psi4manual/1.0.0/autodir_options_c/module__cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__cfour-1.html,4,['energy'],['energy']
Energy Efficiency," of positive charges on fragments, an additional shell may be unfrozen, to ensure there are valence electrons in each fragment. With FALSE or 0, no electrons are frozen (with the exception of electrons treated by an ECP). With -1, -2, and -3, the user might request strict freezing of the previous first/second/third noble gas shell on every atom. In this case, when there are no valence electrons, the code raises an exception. More precise control over the number of frozen orbitals can be attained by using the keywords NUM_FROZEN_DOCC (gives the total number of orbitals to freeze, program picks the lowest-energy orbitals) or FROZEN_DOCC (gives the number of orbitals to freeze per irreducible representation). Type: string; Possible Values: FALSE, TRUE, 1, 0, -1, -2, -3; Default: FALSE. R_CONVERGENCE¶. Convergence for the CC amplitudes. Note that convergence is met only when E_CONVERGENCE and R_CONVERGENCE are satisfied. Type: conv double; Default: 1.0e-7. E_CONVERGENCE¶. Convergence criterion for CC energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Note that convergence is met only when E_CONVERGENCE and R_CONVERGENCE are satisfied. Type: conv double; Default: 1.0e-6. MAXITER¶. Maximum number of CC iterations. Type: integer; Default: 100. DIIS_MAX_VECS¶. Desired number of DIIS vectors. Type: integer; Default: 8. NAT_ORBS¶. Do use MP2 NOs to truncate virtual space for QCISD/CCSD and (T)?. Type: boolean; Default: false. OCC_TOLERANCE¶. Cutoff for occupation of MP2 virtual NOs in FNO-QCISD/CCSD(T). Virtual NOs with occupations less than OCC_TOLERANCE will be discarded. This option is only used if NAT_ORBS = true. Type: conv double; Default: 1.0e-6. TRIPLES_LOW_MEMORY¶. Do use low memory option for triples contribution? Note that this option is enabled automatically if the memory requirements of the conventional algorithm would exceed the available resources. The low memory algorithm is faster in general and has been tu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/fnocc-1.html:16072,energy,energy,16072,psi4manual/1.4.0/fnocc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/fnocc-1.html,5,['energy'],['energy']
Energy Efficiency," of positive charges on fragments, an additional shell may be unfrozen, to ensure there are valence electrons in each fragment. With FALSE or 0, no electrons are frozen (with the exception of electrons treated by an ECP). With -1, -2, and -3, the user might request strict freezing of the previous first/second/third noble gas shell on every atom. In this case, when there are no valence electrons, the code raises an exception. More precise control over the number of frozen orbitals can be attained by using the keywords NUM_FROZEN_DOCC (gives the total number of orbitals to freeze, program picks the lowest-energy orbitals) or FROZEN_DOCC (gives the number of orbitals to freeze per irreducible representation). Type: string; Possible Values: FALSE, TRUE, 1, 0, -1, -2, -3; Default: FALSE. R_CONVERGENCE¶. Convergence for the CC amplitudes. Note that convergence is met only when E_CONVERGENCE and R_CONVERGENCE are satisfied. Type: conv double; Default: 1.0e-7. E_CONVERGENCE¶. Convergence criterion for CC energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Note that convergence is met only when E_CONVERGENCE and R_CONVERGENCE are satisfied. Type: conv double; Default: 1.0e-6. MAXITER¶. Maximum number of CC iterations. Type: integer; Default: 100. DIIS_MAX_VECS¶. Desired number of DIIS vectors. Type: integer; Default: 8. NAT_ORBS¶. Do use MP2 NOs to truncate virtual space for QCISD/CCSD and (T)?. Type: boolean; Default: false. OCC_TOLERANCE¶. Cutoff for occupation of MP2 virtual NOs in FNO-QCISD/CCSD(T). Virtual NOs with occupations less than OCC_TOLERANCE will be discarded. This option is only used if NAT_ORBS = true. Type: conv double; Default: 1.0e-6. TRIPLES_LOW_MEMORY¶. Do use low memory option for triples contribution? Note that this option is enabled automatically if the memory requirements of the conventional algorithm would exceed the available resources. Type: boolean; Default: false. CC_TIMINGS¶. Do time each cc d",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/fnocc-1.html:16161,energy,energy,16161,psi4manual/1.3.2/fnocc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/fnocc-1.html,2,['energy'],['energy']
Energy Efficiency," of running and analyzing a standard F-SAPT0/jun-cc-pvdz procedure for phenol dimer from the S22 database. cc22; ROHF-EOM-CCSD/DZ on the lowest two states of each irrep in \(^{3}B_1\) CH2. fsapt-diff1; This test case shows an example of running and analyzing a difference F-SAPT0/jun-cc-pvdz procedure for phenol dimer from the S22 database. tdscf-5; td-camb3lyp with DiskDF and method/basis specification. pywrap-checkrun-uhf; This checks that all energy methods can run with a minimal input and set symmetry. omp2p5-1; OMP2.5 cc-pVDZ energy for the H2O molecule. fsapt-ext-abc-au; analog of fsapt-ext-abc with molecule and external potentials in Bohr. dfccsdl1; DF-CCSDL cc-pVDZ energy for the H2O molecule. dfcasscf-sp; CASSCF/6-31G** energy point. cisd-h2o+-1; 6-31G** H2O+ Test CISD Energy Point. scf-level-shift-rohf; SCF level shift on an ROHF computation. scf-hess3; CONV SCF 6-31G analytical vs finite-difference tests Tests UHF hessian code for Ca != Cb. pywrap-alias; Test parsed and exotic calls to energy() like zapt4, mp2.5, and cisd are working. scf-response3; UHF Dipole Polarizability Test. ddd-deriv; Sample HF/cc-pVDZ H2O computation all derivatives. pywrap-db3; Test that Python Molecule class processes geometry like psi4 Molecule class. sapt8; SAPT0(ROHF) open-shell computation of CN - Ne interaction energy First with jun-cc-pVDZ and density fitted integrals with ROHF Then with cc-pVDZ and direct integrals, except for dispersion that is computed with cc-pVDZ-ri density fitting with ROHF. dfccsdat1; DF-CCSD(AT) cc-pVDZ energy for the H2O molecule. scf-coverage; Lithium test for coverage. tdscf-2; td-uhf test on triplet states of methylene (tda), wfn passing. cc9a; ROHF-CCSD(T) cc-pVDZ energy for the \(^2\Sigma^+\) state of the CN radical, with Z-matrix input. cbs-parser; mtd/basis syntax examples. casscf-fzc-sp; CASSCF/6-31G** energy point. scf-hess4; DF SCF 6-31G UHFl vs RHF test Tests DF UHF hessian code for Ca = Cb. dft-pruning; Tests all grid pruning options av",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html:3771,energy,energy,3771,psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency," of stage_scheme.; An exception is the default, 'xtpl_highest_1', which uses the best basis; set available. See sec:cbs_xtpl for all available schemes. Parameters:; scf_scheme (function) – \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || scf_xtpl_helgaker_3 || etc.; Indicates the basis set extrapolation scheme to be applied to the reference energy.; Defaults to scf_xtpl_helgaker_3() if three valid basis sets; present in scf_basis, scf_xtpl_helgaker_2() if two valid basis; sets present in scf_basis, and xtpl_highest_1() otherwise. corl_scheme (function) – \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in corl_basis and xtpl_highest_1() otherwise. delta_scheme (function) – \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta_basis and xtpl_highest_1() otherwise. delta2_scheme (function) – \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the second delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta2_basis and xtpl_highest_1() otherwise. delta3_scheme (function) – \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the third delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta3_basis and xtpl_highest_1() otherwise. delta4_scheme (function) – \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation sc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/cbs-1.html:8736,energy,energy,8736,psi4manual/1.1.0/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/cbs-1.html,3,['energy'],['energy']
Energy Efficiency," of the CN radical, with Cartesian input. scf1; RHF cc-pVQZ energy for the BH molecule, with Cartesian input. cisd-h2o+-0; 6-31G** H2O+ Test CISD Energy Point. cc43; RHF-CC2-LR/STO-3G optical rotation of (S)-methyloxirane. gauge = both, omega = (589 355 nm). cc27; Single point gradient of 1-1B2 state of H2O with EOM-CCSD. cisd-sp-2; 6-31G** H2O Test CISD Energy Point. pywrap_db2; Database calculation with psi4-generated input. Should not be used as a model input file but as a canary to avoid breaking database/input parser dependencies. opt1; SCF STO-3G geometry optimzation, with Z-matrix input. dft2; DFT Functional Test. cc15; RHF-B-CCD(T)/6-31G** H2O single-point energy (fzc, MO-basis ). dft1; DFT Functional Test. cc18; RHF-CCSD-LR/cc-pVDZ static polarizability of HOF. mom; Maximum Overlap Method (MOM) Test. MOM is designed to stabilize SCF convergence and to target excited Slater determinants directly. fci-h2o-fzcv; 6-31G H2O Test FCI Energy Point. fd-freq-energy; SCF STO-3G finite-difference frequencies from energies. dcft5; DCFT-06 calculation for the O2 molecule (triplet ground state). This performs geometry optimization using two-step and simultaneous solution of the response equations for the analytic gradient. opt2; SCF DZ allene geometry optimzation, with Cartesian input. scf11-freq-from-energies; Test frequencies by finite differences of energies for planar C4NH4 TS. opt5; 6-31G** UHF CH2 3B1 optimization. cc23; ROHF-EOM-CCSD/DZ analytic gradient lowest state of H2O+ (A1 excitation). cc26; Single-point gradient, analytic and via finite-differences of 2-1A1 state of H2O with EOM-CCSD. fci-tdm; He2+ FCI/cc-pVDZ Transition Dipole Moment. rasci-c2-active; 6-31G* C2 Test RASCI Energy Point, testing two different ways of specifying the active space, either with the ACTIVE keyword, or with RAS1, RAS2, RESTRICTED_DOCC, and RESTRICTED_UOCC. docs_dft; This test is used to construct the documentation; it is not suitable for emulation by users. tu2-ch2-energy; Sample ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodoc_testsuite-1.html:7231,energy,energy,7231,psi4manual/4.0b2/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodoc_testsuite-1.html,4,['energy'],['energy']
Energy Efficiency," of the ERI tensor. Type: conv double; Default: 1.0e-4. CEPA_NO_SINGLES¶. Flag to exclude singly excited configurations from a coupled-pair computation. Type: boolean; Default: false. DIPMOM¶. Compute the dipole moment? Note that dipole moments are only available in the FNOCC module for the ACPF, AQCC, CISD, and CEPA(0) methods. Type: boolean; Default: false. Advanced FNOCC Keywords¶. SCS_MP2¶. Do SCS-MP2?. Type: boolean; Default: false. MP2_SCALE_OS¶. Opposite-spin scaling factor for SCS-MP2. Type: double; Default: 1.20. MP2_SCALE_SS¶. Same-spin scaling factor for SCS-MP2. Type: double; Default: 1.0. SCS_CCSD¶. Do SCS-CCSD?. Type: boolean; Default: false. CC_SCALE_OS¶. Oppposite-spin scaling factor for SCS-CCSD. Type: double; Default: 1.27. CC_SCALE_SS¶. Same-spin scaling factor for SCS-CCSD. Type: double; Default: 1.13. RUN_MP2¶. do only evaluate mp2 energy?. Type: boolean; Default: false. RUN_MP3¶. do only evaluate mp3 energy?. Type: boolean; Default: false. RUN_MP4¶. do only evaluate mp4 energy?. Type: boolean; Default: false. RUN_CCSD¶. do ccsd rather than qcisd?. Type: boolean; Default: false. RUN_CEPA¶. Is this a CEPA job? This parameter is used internally by the pythond driver. Changing its value won’t have any effect on the procedure. Type: boolean; Default: false. COMPUTE_TRIPLES¶. Do compute triples contribution?. Type: boolean; Default: true. COMPUTE_MP4_TRIPLES¶. Do compute MP4 triples contribution?. Type: boolean; Default: false. DFCC¶. Do use density fitting or cholesky decomposition in CC? This keyword is used internally by the driver. Changing its value will have no effect on the computation. Type: boolean; Default: false. CEPA_LEVEL¶. Which coupled-pair method is called? This parameter is used internally by the python driver. Changing its value won’t have any effect on the procedure. Type: string; Default: CEPA(0). table of contents. FNOCC: Frozen natural orbitals for CCSD(T), QCISD(T), CEPA, and MP4; Frozen natural orbitals (FNO); QCISD(T), CCSD(T",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/fnocc-1.html:18367,energy,energy,18367,psi4manual/1.3.2/fnocc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/fnocc-1.html,11,['energy'],['energy']
Energy Efficiency," of the SOS method. Type: string; Possible Values: SOS, SOSPI; Default: SOS. SOS_TYPE (OCC); OCC — Type of the SOS method. Type: string; Possible Values: SOS, SOSPI; Default: SOS. SOSCF (SCF); SCF — Do use second-order SCF convergence methods?. Type: boolean; Default: false. SOSCF_CONV (SCF); SCF — Secord order convergence threshold. Type: conv double; Default: 5.0e-3. SOSCF_MAX_ITER (SCF); SCF — Maximum number of second-order microiterations to perform. Type: integer; Default: 5. SOSCF_MIN_ITER (SCF); SCF — Minimum number of second-order microiterations to perform. Type: integer; Default: 1. SOSCF_PRINT (SCF); SCF — Do we print the SOSCF microiterations?. Type: boolean; Default: false. SOSCF_R_START (SCF); SCF — When to start second-order SCF iterations based on gradient RMS. Type: double; Default: 1.0e-2. SPINADAPT_ENERGIES (CCENERGY); CCENERGY — Do print spin-adapted pair energies?. Type: boolean; Default: false. SS_E_CONVERGENCE (CCEOM); CCEOM — Convergence criterion for excitation energy (change) in the Davidson algorithm for the CIS guess to CC-EOM. Type: conv double; Default: 1e-6. SS_R_CONVERGENCE (CCEOM); CCEOM — Convergence criterion for norm of the residual vector in the Davidson algorithm for the CIS guess to CC-EOM. Type: conv double; Default: 1e-6. SS_SKIP_DIAG (CCEOM); CCEOM — Do skip diagonalization of Hbar SS block?. Type: boolean; Default: false. SS_VECS_PER_ROOT (CCEOM); CCEOM — SS vectors stored per root. Type: integer; Default: 5. SSAPT0_SCALE (FISAPT); FISAPT — Do sSAPT0 exchange-scaling with F-SAPT. Type: boolean; Default: false. STABILITY_ADD_VECTORS (DCFT); DCFT (Expert) — The number of vectors that can be added simultaneously into the subspace for Davidson’s diagonalization in stability check. Type: integer; Default: 20. STABILITY_ANALYSIS (SCF); SCF — Whether to perform stability analysis after convergence. NONE prevents analysis being performed. CHECK will print out the analysis of the wavefunction stability at the end of the computation.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:209026,energy,energy,209026,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,2,['energy'],['energy']
Energy Efficiency," of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix; Computes the Hessian of the Wavefunction. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None; Deep copies the internal data. del_array_variable(self: psi4.core.Wavefunction, arg0: str) → int; Removes the requested (case-insensitive) Matrix QC variable. del_scalar_variable(self: psi4.core.Wavefunction, arg0: str) → int; Removes the requested (case-insensitive) double QC variable. del_variable(key). density_fitted(self: psi4.core.Wavefunction) → bool; Returns whether this wavefunction was obtained using density fitting or not. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension; Returns the number of doubly occupied orbitals per irrep. efzc(self: psi4.core.Wavefunction) → float; Returns the frozen-core energy. energy(self: psi4.core.Wavefunction) → float; Returns the Wavefunction’s energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction) → psi4.core.Vector; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector; Returns the requested Beta Eigenvalues subset. esp_at_nuclei(self: psi4.core.Wavefunction) → psi4.core.Vector; returns electrostatic potentials at nuclei. force_doccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None; Specialized expert use only. Sets the number of doubly occupied oribtals per irrep. Note that this results in inconsistent Wavefunction objects for SCF, so caution is advised. force_soccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None; Specialized expert use only. Sets the number of singly occupied oribtals per ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.wavefunction.html:20967,energy,energy,20967,psi4manual/1.3.2/api/psi4.core.wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.wavefunction.html,1,['energy'],['energy']
Energy Efficiency," of the \(\boldsymbol{\gamma_1}\) N-representability, but differ in describing the orbital relaxation:; the former methods account for the relaxation only partially, while the latter fully relax the orbitals.; Both DC-06 and DC-12 methods have similar computational cost, same is true when comparing ODC-06 and ODC-12.; Meanwhile, the DC methods are generally more efficient than their ODC analogs, due to a more expensive orbital update step; needed for the full orbital optimization. In the ODC-13 method, the third- and; fourth-order N-representability conditions are used for the density cumulant; and the correlated contribution \(\boldsymbol{\tau}\), respectively,; and the orbitals are variationally optimized.; For most of the applications, it is recommended to use the ODC-12 method, which; provides an optimal balance between accuracy and efficiency, especially for; molecules with open-shell character. If highly accurate results are desired, a; combination of the ODC-13 method with a three-particle energy correction; [\(\mbox{ODC-13$(\lambda_3)$}\)] can be used (see below).; For the detailed comparison of the quality of these methods we refer; users to our publications.; The DCFT functional can be specified by the DCFT_FUNCTIONAL option. The; default choice is the ODC-12 functional. In addition to five methods listed; above, DCFT_FUNCTIONAL option can be set to CEPA0 (coupled electron; pair approximation zero, equivalent to linearized coupled cluster doubles; method, LCCD). CEPA0 can be considered as a particular case of the DC-06 and DC-12; methods in the limit of zero non-idempotency of \(\boldsymbol{\gamma_1}\). This option has a limited; functionality and should only be used for test purposes. For the production-level CEPA0 code, see the; OCC module. The DCFT code can also be used to; compute the \((\lambda_3)\) energy correction that perturbatively accounts; for three-particle correlation effects, similarly to the (T) correction in coupled; cluster theory. Computa",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/dcft-1.html:6380,energy,energy,6380,psi4manual/1.2.1/dcft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/dcft-1.html,6,['energy'],['energy']
Energy Efficiency," of the \(\boldsymbol{\gamma_1}\) N-representability, but differ in describing the orbital relaxation:; the former methods account for the relaxation only partially, while the latter fully relax the orbitals.; Both DC-06 and DC-12 methods have similar computational cost, same is true when comparing ODC-06 and ODC-12.; Meanwhile, the DC methods are generally more efficient than their ODC analogs, due to a more expensive orbital update step; needed for the full orbital optimization. In the ODC-13 method, the third- and; fourth-order N-representability conditions are used for the density cumulant; and the correlated contribution \(\boldsymbol{\tau}\), respectively,; and the orbitals are variationally optimized.; For most of the applications, it is recommended to use the ODC-12 method, which; provides an optimal balance between accuracy and efficiency, especially for; molecules with open-shell character. If highly accurate results are desired, a; combination of the ODC-13 method with a three-particle energy correction; [\(\mbox{ODC-13$(\lambda_3)$}\)] can be used (see below).; For the detailed comparison of the quality of these methods, we refer; users to our publications.; The DCT functional can be specified by the DCT_FUNCTIONAL option. The; default choice is the ODC-12 functional. The DCT code can also be used to; compute the \((\lambda_3)\) energy correction that perturbatively accounts; for three-particle correlation effects, similarly to the (T) correction in coupled; cluster theory. Computation of the \((\lambda_3)\) correction can be; requested by setting the THREE_PARTICLE option to PERTURBATIVE. A; combination of the ODC-13 functional with the \((\lambda_3)\) correction; [denoted as \(\mbox{ODC-13$(\lambda_3)$}\)] has been shown to provide highly; accurate results for open-shell molecules near equilibrium geometries.; At the present moment, all of the DCT methods support unrestricted reference; orbitals (REFERENCE UHF), which can be used to perform energy and; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/dct-1.html:6364,energy,energy,6364,psi4manual/1.4.0/dct-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/dct-1.html,9,['energy'],['energy']
Energy Efficiency," of the density cumulant guarantees that all of the DCFT methods; are size-extensive and size-consistent. Furthermore, the N-representability; problem is now greatly simplified, because the idempotent part of is; N-representable by construction. One only needs to worry about the; N-representability of the density cumulant, which is a relatively small part of; .; In order to obtain the DCFT energy, two conditions must be satisfied:; 1) The energy must be stationary with respect to a set of orbitals. This can be done by; diagonalizing the generalized Fock operator (as in the DC-06 and DC-12 methods, see below),; which introduces partial orbital relaxation, or by fully relaxing the orbitals and minimizing the entire energy expression; (as in the ODC-06 and ODC-12 methods).; 2) The energy must be stationary with respect to the variation of the density; cumulant , constrained to N-representability conditions.; Making the energy stationary requires solution of two sets of coupled; equations for orbitals and density cumulant, respectively (also known as; residual equations). At the present moment, three different algorithms for the; solution of the system of coupled equations are available (see section; Iterative Algorithms for details).; Publications resulting from the use of the DCFT code should cite contributions; listed here. Methods¶; Currently five DCFT methods (functionals) are available: DC-06, DC-12, ODC-06, ODC-12, and ODC-13. The first four; methods use approximate N-representability conditions derived from; second-order perturbation theory and differ in the description of the; correlated (non-idempotent) part of the one-particle density; matrix and orbital optimization. While in the DC-06 and ODC-06 methods is derived from the density cumulant; in an approximate way (labelled by ‘06’), the DC-12 and ODC-12 methods derive this contribution exactly, and; take full advantage of the N-representability conditions (which is denoted by ‘12’). The corresponding DC and O",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/dcft-1.html:3374,energy,energy,3374,psi4manual/1.0.0/dcft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/dcft-1.html,2,['energy'],['energy']
Energy Efficiency," of the last geometry. harvest_mp2(lines, psivar)[source]¶; Harvest the MP2 results. harvest_scf_from_outfile(lines, psivar)[source]¶; Harvest SCF results from the SCF section of the output file. muster_memory(mem)[source]¶; Transform input mem in MB into psi4-type options for orca. muster_modelchem(name, dertype)[source]¶; Transform calculation method name and derivative level dertype; into options for orca. While deliberately requested pieces,; generally orca__orca_deriv_level and orca__orca_calc_level,; are set to complain if contradicted (‘clobber’ set to True), other; ‘recommended’ settings, can be countermanded by keywords in input file; (‘clobber’ set to False). Occasionally, we want these pieces to actually; overcome keywords in input file (‘superclobber’ set to True). orca_gradient_list()[source]¶; Return an array of Orca methods with analytical gradients.; Appended to procedures[‘gradient’]. orca_list()[source]¶; Return an array of Orca methods with energies. Appended; to procedures[‘energy’]. class OrderedDict(*args, **kwds)[source]¶; Dictionary that remembers insertion order. clear() → None. Remove all items from od.[source]¶. copy() → a shallow copy of od[source]¶. classmethod fromkeys(S[, v]) → New ordered dictionary with keys from S[source]¶; and values equal to v (which defaults to None). items() → list of (key, value) pairs in od[source]¶. iteritems()[source]¶; od.iteritems -> an iterator over the (key, value) items in od. iterkeys() → an iterator over the keys in od[source]¶. itervalues()[source]¶; od.itervalues -> an iterator over the values in od. keys() → list of keys in od[source]¶. pop(k[, d]) → v, remove specified key and return the corresponding value.[source]¶; If key is not found, d is returned if given, otherwise KeyError is raised. popitem() → (k, v), return and remove a (key, value) pair.[source]¶; Pairs are returned in LIFO order if last is true or FIFO order if false. setdefault(k[, d]) → od.get(k,d), also set od[k]=d if k not in od[so",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:53276,energy,energy,53276,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,2,['energy'],['energy']
Energy Efficiency," of the named method; from ground state to root n, and the transition is of irrep h. DFT; functional labeled if canonical. TD-fctl ROOT 0 -> ROOT n RIGHT EIGENVECTOR BETA¶; The right beta spin eigenvectors of the named method; from ground state to root n. DFT; functional labeled if canonical. TD-fctl ROOT 0 (IN h) -> ROOT n (IN i) RIGHT EIGENVECTOR BETA¶; The right beta spin eigenvectors of the named method; from ground state, which is in irrep h, to root n within irrep i. DFT; functional labeled if canonical. TD-fctl ROOT 0 (h) -> ROOT n (i) RIGHT EIGENVECTOR BETA¶; The right beta spin eigenvectors of the named method; from ground state, which is in irrep h, to root n, which is in irrep i. DFT; functional labeled if canonical. TD-fctl ROOT 0 -> ROOT n RIGHT EIGENVECTOR BETA - h TRANSITION¶; The right alpha and beta spin eigenvectors of the named method; from ground state to root n, and the transition is of irrep h. DFT; functional labeled if canonical. THERMAL ENERGY¶; Total thermal energy E [Eh] at given temperature. THERMAL ENERGY CORRECTION¶; Sum of electronic, translational, rotational, and vibrational corrections [Eh] to the thermal energy at given temperature. TWO-ELECTRON ENERGY¶; The two-electron energy contribution [Eh] to the total SCF energy.; Quantity \(E_{2e^-}\) in Eq. (4). UNCP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [Eh] considering only two-body interactions,; computed without counterpoise correction.; Related variable CP-CORRECTED 2-BODY INTERACTION ENERGY. \[E_{\text{IE}} = E_{dimer} - \sum_{monomer}^{n}{E_{monomer}^{\text{unCP}}}\]. WIBERG LOWDIN INDICES¶; Property of Wiberg bond indices using orthogonal Löwdin orbitals, (nat, nat). ZAPTn TOTAL ENERGY¶. ZAPTn CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the labeled Z-averaged perturbation theory level.; n is ZAPT perturbation order. ZERO K ENTHALPY¶; Total electronic and zero-point energy [Eh] at 0 [K]. ZPVE¶; Vibrational ze",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/glossary_psivariables.html:60003,energy,energy,60003,psi4manual/1.6.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/glossary_psivariables.html,1,['energy'],['energy']
Energy Efficiency," of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. fci-dipole; 6-31G H2O Test FCI Energy Point. tdscf-5; td-camb3lyp with DiskDF and method/basis specification. dft-grac; Gradient regularized asymptotic correction (GRAC) test. castup2; SCF with various combinations of pk/density-fitting, castup/no-castup, and spherical/cartesian settings. Demonstrates that puream setting is getting set by orbital basis for all df/castup parts of calc. Demonstrates that answer doesn’t depend on presence/absence of castup. Demonstrates (by comparison to castup3) that output file doesn’t depend on options (scf_type) being set global or local. This input uses global. cisd-sp-2; 6-31G** H2O Test CISD Energy Point. tu2-ch2-energy; Sample UHF/6-31G** CH2 computation. scf-hess5; DF SCF 6-31G analytical vs finite-difference tests Tests DF UHF hessian code for Ca != Cb. linK-3; UHF and ROHF Linear Exchange Algorithm test for benzyl cation. scf7; Tests SCF gradient in the presence of a dipole field. pywrap-molecule; Check that C++ Molecule class and qcdb molecule class are reading molecule input strings identically. cisd-h2o-clpse; 6-31G** H2O Test CISD Energy Point with subspace collapse. cc43; RHF-CC2-LR/STO-3G optical rotation of (S)-methyloxirane. gauge = both, omega = (589 355 nm). cc45; RHF-EOM-CC2/cc-pVDZ lowest two states of each symmetry of H2O. pywrap-db3; Test that Python Molecule class processes geometry like psi4 Molecule class. fnocc2; Test G2 method for H2O. mints2-bse; Similar to mints2, but using the BSE to specify the basis sets. isapt-siao1; This test case shows an example of running the I-SAPT0/jun-cc-pVDZ computation for 2,4-pentanediol (targeting the intramolecular hydrogen bond between the two hydroxyl ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html:17639,energy,energy,17639,psi4manual/master/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency," of the two; monomers and for the dimer). The next keyword symmetry c1 tells PSI4 to run; in C1 point-group symmetry (i.e., without using symmetry), even if a; higher symmetry is detected. SAPT computations know to turn off; symmetry and fix orientation even without the user specifying these; molecule keywords.; Here’s the second half of the input:; set {; basis jun-cc-pVDZ; scf_type DF; freeze_core True; }. energy('sapt0'). Before, we have been setting keywords individually with commands like; set basis cc-pVDZ. Because we have a few more options now, it’s; convenient to place them together into the set or set globals; block, bounded by {...}. This; will set all of these options as “global” options (meaning that they are; visible to all parts of the program). Most common PSI4 options can be; set in a globals section like this. If an option needs to be visible; only to one part of the program (e.g., we only want to increase the; energy convergence in the SCF code, but not the rest of the; code), it can be placed in a section of input visible to that part of the; program (e.g., set scf e_convergence 1.0E-8).; Back to our SAPT example, we have found that for basic-level SAPT; computations (i.e., SAPT0), a good error cancellation is found; [Hohenstein:2012:WIREs] with the jun-cc-pVDZ basis (this is the; usual aug-cc-pVDZ basis, but without diffuse functions on hydrogen and; without diffuse functions on heavy atoms) [Papajak:2011:10]. So,; we’ll use that as our standard basis set. The SAPT code is designed to; use density fitting techniques, because they introduce minimal errors; while providing much faster computations [Hohenstein:2010:184111]; [Hohenstein:2010:014101]. Since we’re using density fitting for the SAPT,; we might as well also use it for the Hartree–Fock computations that are; performed as part of the SAPT. We can specify that with; scf_type DF.; Density fitting procedures require the use of auxiliary basis sets that; pair with the primary basis set. Fortun",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/tutorial-1.html:10544,energy,energy,10544,psi4manual/4.0b4/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/tutorial-1.html,2,['energy'],['energy']
Energy Efficiency," of “weak pairs” in the local-CCSD method. The value of NONE (unique avaliable option) treats weak pairs in the same manner as strong pairs. Type: string; Default: NONE. LOCAL_WEAKP (CCRESPONSE); CCRESPONSE — Desired treatment of “weak pairs” in the local-CCSD method. The value of NONE (unique avaliable option) treats weak pairs in the same manner as strong pairs. Type: string; Default: NONE. LOCAL_WEAKP (CCSORT); CCSORT — Desired treatment of “weak pairs” in the local-CCSD method. The value of NONE (unique avaliable option) treats weak pairs in the same manner as strong pairs. Type: string; Default: NONE. LOCK_SINGLET (PSIMRCC); PSIMRCC — Do lock onto a singlet root?. Type: boolean; Default: false. LSE (DETCI); DETCI — Do use least-squares extrapolation in iterative solution of CI vector?. Type: boolean; Default: false. LSE_COLLAPSE (DETCI); DETCI — Number of iterations between least-squares extrapolations. Type: integer; Default: 3. LSE_TOLERANCE (DETCI); DETCI — Minimum converged energy for least-squares extrapolation to be performed. Type: conv double; Default: 3. MADMP2_SLEEP (DFMP2); DFMP2 (Expert) — A helpful option, used only in debugging the MADNESS version. Type: integer; Default: 0. MAT_NUM_COLUMN_PRINT (GLOBALS); GLOBALS (Expert) — Number of columns to print in calls to Matrix::print_mat. Type: integer; Default: 5. MAX_ATTEMPTS (SCF); SCF (Expert) — When using STABILITY_ANALYSIS = FOLLOW, maximum number of orbital optimization attempts to make the wavefunction stable. Type: integer; Default: 1. MAX_CCD_DIISVECS (SAPT); SAPT — Maximum number of vectors used in CCD-DIIS. Type: integer; Default: 10. MAX_DISP_G_CONVERGENCE (OPTKING); OPTKING — Convergence criterion for geometry optmization: maximum displacement (internal coordinates, atomic units). Type: conv double; Default: 1.2e-3. MAX_ENERGY_G_CONVERGENCE (OPTKING); OPTKING — Convergence criterion for geometry optmization: maximum energy change. Type: conv double; Default: 1.0e-6. MAX_FORCE_G_CONVERGENCE (",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:154877,energy,energy,154877,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,2,['energy'],['energy']
Energy Efficiency," old_guess = PsiMod.get_global_option(""GUESS""); PsiMod.set_global_option(""DF_INTS_IO"", ""SAVE""); PsiMod.print_out('\n\t==> IP Fitting SCF: Burn-in <==\n'); energy('scf'); PsiMod.set_global_option(""DF_INTS_IO"", ""LOAD""). # Determine HOMO, to determine mult1; ref = PsiMod.wavefunction(); eps_a = ref.epsilon_a(); eps_b = ref.epsilon_b(); if (Na == Nb):; HOMO = -Nb; elif (Nb == 0):; HOMO = Na; else:; E_a = eps_a[int(Na - 1)] ; E_b = eps_b[int(Nb - 1)] ; if (E_a >= E_b):; HOMO = Na; else: ; HOMO = -Nb. Na1 = Na;; Nb1 = Nb;; if (HOMO > 0):; Na1 = Na1-1;; else:; Nb1 = Nb1-1;; ; charge1 = charge0 + 1; ; mult1 = Na1 - Nb1 + 1. omegas = [];; E0s = [];; E1s = [];; kIPs = [];; IPs = [];; types = [];; ; # Right endpoint; PsiMod.set_global_option('DFT_OMEGA',omega_r). # Neutral; if (read):; PsiMod.set_global_option(""GUESS"", ""READ""); copy_file_to_scratch(read180, 'psi', 'ot', 180). mol.set_molecular_charge(charge0); mol.set_multiplicity(mult0); PsiMod.print_out('\n\t==> IP Fitting SCF: Neutral, Right Endpoint <==\n'); E0r = energy('scf'); ref = PsiMod.wavefunction(); eps_a = ref.epsilon_a(); eps_b = ref.epsilon_b(); E_HOMO = 0.0;; if (Nb == 0):; E_HOMO = eps_a[int(Na-1)]; else:; E_a = eps_a[int(Na - 1)] ; E_b = eps_b[int(Nb - 1)] ; if (E_a >= E_b):; E_HOMO = E_a;; else: ; E_HOMO = E_b;; E_HOMOr = E_HOMO;; PsiMod.IO.change_file_namespace(180,""ot"",""neutral""); ; # Cation; if (read):; PsiMod.set_global_option(""GUESS"", ""READ""); copy_file_to_scratch(read180, 'psi', 'ot', 180). mol.set_molecular_charge(charge1); mol.set_multiplicity(mult1); PsiMod.print_out('\n\t==> IP Fitting SCF: Cation, Right Endpoint <==\n'); E1r = energy('scf'); PsiMod.IO.change_file_namespace(180,""ot"",""cation""). IPr = E1r - E0r;; kIPr = -E_HOMOr;; delta_r = IPr - kIPr;. if (IPr > kIPr):; PsiMod.print_out('\n***IP Fitting Error: Right Omega limit should have kIP > IP'); sys.exit(1). omegas.append(omega_r); types.append('Right Limit'); E0s.append(E0r); E1s.append(E1r); IPs.append(IPr); kIPs.append(kIPr). # Use previous",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/frac.html:12939,energy,energy,12939,psi4manual/4.0b4/_modules/frac.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/frac.html,1,['energy'],['energy']
Energy Efficiency," on density fitting with the default basis, otherwise the specified basis is used. Type: string; Possible Values: basis string; Default: FALSE. DIIS¶. Do use DIIS extrapolation to accelerate convergence?. Type: boolean; Default: true. DIIS_MAX_VECS¶. Maximum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 10. DIIS_MIN_VECS¶. Minimum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 2. DIIS_RMS_ERROR¶. Use RMS error instead of the more robust absolute error?. Type: boolean; Default: true. DIIS_START¶. The minimum iteration to start storing DIIS vectors. Type: integer; Default: 1. D_CONVERGENCE¶. Convergence criterion for SCF density, defined as the RMS or maximum absolute value of the orbital gradient. See Table SCF Convergence & Algorithm for default convergence criteria for different calculation types. Cfour Interface: Keyword translates into CFOUR_SCF_CONV. Type: conv double; Default: 1e-6. E_CONVERGENCE¶. Convergence criterion for SCF energy. See Table SCF Convergence & Algorithm for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. FAIL_ON_MAXITER¶. Fail if we reach maxiter without converging?. Type: boolean; Default: true. INCFOCK¶. Do Perform Incremental Fock Build?. Type: boolean; Default: false. INCFOCK_FULL_FOCK_EVERY¶. Frequency with which to compute the full Fock matrix if using INCFOCK . N means rebuild every N SCF iterations to avoid accumulating error from the incremental procedure. Type: integer; Default: 5. LEVEL_SHIFT¶. Do use a level shift?. Type: double; Default: 0.0. LEVEL_SHIFT_CUTOFF¶. DIIS error at which to stop applying the level shift. Type: double; Default: 1e-2. MAXITER¶. Maximum number of iterations. Cfour Interface: Keyword translates into CFOUR_SCF_MAXCYC. Type: integer; Default: 100. MOM_OCC¶. The absolute indices of orbitals to excite from in MOM (+/- for alpha/beta). Type: array; Default: No Default. MOM_START¶. The iteration to ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodir_options_c/module__scf-1.html:5639,energy,energy,5639,psi4manual/1.5.0/autodir_options_c/module__scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodir_options_c/module__scf-1.html,2,['energy'],['energy']
Energy Efficiency," on density fitting with the default basis, otherwise the specified basis is used. Type: string; Possible Values: basis string; Default: FALSE. DIIS¶. Do use DIIS extrapolation to accelerate convergence?. Type: boolean; Default: true. DIIS_MAX_VECS¶. Maximum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 10. DIIS_MIN_VECS¶. Minimum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 2. DIIS_RMS_ERROR¶. Use RMS error instead of the more robust absolute error?. Type: boolean; Default: true. DIIS_START¶. The minimum iteration to start storing DIIS vectors. Type: integer; Default: 1. D_CONVERGENCE¶. Convergence criterion for SCF density, defined as the RMS or maximum absolute value of the orbital gradient. See Table SCF Convergence & Algorithm for default convergence criteria for different calculation types. Cfour Interface: Keyword translates into CFOUR_SCF_CONV. Type: conv double; Default: 1e-6. E_CONVERGENCE¶. Convergence criterion for SCF energy. See Table SCF Convergence & Algorithm for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. FAIL_ON_MAXITER¶. Fail if we reach maxiter without converging?. Type: boolean; Default: true. LEVEL_SHIFT¶. Do use a level shift?. Type: double; Default: 0.0. LEVEL_SHIFT_CUTOFF¶. DIIS error at which to stop applying the level shift. Type: double; Default: 1e-2. MAXITER¶. Maximum number of iterations. Cfour Interface: Keyword translates into CFOUR_SCF_MAXCYC. Type: integer; Default: 100. MOM_OCC¶. The absolute indices of orbitals to excite from in MOM (+/- for alpha/beta). Type: array; Default: No Default. MOM_START¶. The iteration to start MOM on (or 0 for no MOM). Type: integer; Default: 0. MOM_VIR¶. The absolute indices of orbitals to excite to in MOM (+/- for alpha/beta). Type: array; Default: No Default. SOSCF¶. Do use second-order SCF convergence methods?. Type: boolean; Default: false. SOSCF_CONV¶. Second order convergence ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodir_options_c/module__scf-1.html:5599,energy,energy,5599,psi4manual/1.4.0/autodir_options_c/module__scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/module__scf-1.html,2,['energy'],['energy']
Energy Efficiency," on density fitting with the default basis, otherwise the specified basis is used. Type: string; Possible Values: basis string; Default: FALSE. DIIS¶. Do use DIIS extrapolation to accelerate convergence?. Type: boolean; Default: true. DIIS_MAX_VECS¶. Maximum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 10. DIIS_MIN_VECS¶. Minimum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 2. DIIS_RMS_ERROR¶. Use RMS error instead of the more robust absolute error?. Type: boolean; Default: true. DIIS_START¶. The minimum iteration to start storing DIIS vectors. Type: integer; Default: 1. D_CONVERGENCE¶. Convergence criterion for SCF density, defined as the RMS or maximum absolute value of the orbital gradient. See Table SCF Convergence & Algorithm for default convergence criteria for different calculation types. Cfour Interface: Keyword translates into CFOUR_SCF_CONV. Type: conv double; Default: 1e-6. E_CONVERGENCE¶. Convergence criterion for SCF energy. See Table SCF Convergence & Algorithm for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. FAIL_ON_MAXITER¶. Fail if we reach maxiter without converging?. Type: boolean; Default: true. MAXITER¶. Maximum number of iterations. Cfour Interface: Keyword translates into CFOUR_SCF_MAXCYC. Type: integer; Default: 100. MOM_OCC¶. The absolute indices of orbitals to excite from in MOM (+/- for alpha/beta). Type: array; Default: No Default. MOM_START¶. The iteration to start MOM on (or 0 for no MOM). Type: integer; Default: 0. MOM_VIR¶. The absolute indices of orbitals to excite to in MOM (+/- for alpha/beta). Type: array; Default: No Default. SOSCF¶. Do use second-order SCF convergence methods?. Type: boolean; Default: false. SOSCF_CONV¶. Second order convergence threshold. Cease microiterating at this value. Type: conv double; Default: 5.0e-3. SOSCF_MAX_ITER¶. Maximum number of second-order microiterations to perform. Type: inte",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__scf-1.html:5235,energy,energy,5235,psi4manual/1.3.2/autodir_options_c/module__scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__scf-1.html,2,['energy'],['energy']
Energy Efficiency," only the y coordinates of atoms 2 and 3; freeze_list = """"""; 2 y; 3 y; """"""; set optking frozen_cartesian $freeze_list. To optimize toward a value of 0.95 Angstroms for the distance between; atoms 1 and 3, as well as that between 2 and 4; set optking {; fixed_distance = (""; 1 3 0.95; 2 4 0.95; ""); }. Note that the effect of the frozen and fixed keywords is independent of; how the geometry of the molecule was input (whether Z-matrix or cartesian, etc.).. To scan the potential energy surface by optimizing at several fixed values; of the dihedral angle of HOOH.; molecule hooh {; 0 1; H 0.850718 0.772960 0.563468; O 0.120432 0.684669 -0.035503; O -0.120432 -0.684669 -0.035503; H -0.850718 -0.772960 0.563468; }. set {; basis cc-pvdz; intrafrag_step_limit 0.1; }. dihedrals = [100,110,120,130,140,150]; PES = []. for phi in dihedrals:; my_string = ""1 2 3 4 "" + str(phi); set optking fixed_dihedral = $my_string; E = optimize('scf'); PES.append((phi, E)). print ""\n\tcc-pVDZ SCF energy as a function of phi\n""; for point in PES:; print ""\t%5.1f%20.10f"" % (point[0], point[1]). Dealing with problematic optimizations¶; Although optking is continuously improved with robustness in mind, some; attempted optimizations will inevitably fail to converge to the desired minima.; For difficult cases, the following suggestions are made. As for any optimizer, computing the Hessian and limiting the step size will; successfully converge a higher percentage of cases. The default settings have; been chosen because they perform efficiently for common, representative test sets.; More restrictive, cautious steps are sometimes necessary.; DYNAMIC_LEVEL allows optking to change the method of optimization; toward algorithms that, while often less efficient, may help to converge difficult; cases. If this is initially set to 1, then optking, as poor steps are detected,; will increase the level through several forms of more robust and cautious algorithms.; The changes will reduce the trust radius, allow back",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/optking-1.html:7668,energy,energy,7668,psi4manual/1.0.0/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/optking-1.html,2,['energy'],['energy']
Energy Efficiency," open a new terminal.; If you installed the Psi4conda distribution or installed the PSI4; conda package into the main environment of an Anaconda or Miniconda; distribution and added that to your PATH, as prompted, then; which psi4 likely yields condadist/bin/psi4 and the PATH; setting lines below are redundant.; If you installed into a conda environment p4env and performed; conda activate p4env, then which psi4 likely yields; condadist/envs/p4env/bin/psi4 and the PATH setting lines; below are redundant.; # csh, tcsh: add to shell or ~/.tcshrc file; unsetenv PSIDATADIR; setenv PATH {prefix}/bin:$PATH; setenv PSI_SCRATCH /path/to/existing/writable/local-not-network/directory/for/scratch/files. # sh, bash: add to shell or ~/.bashrc (Linux/Windows) or ~/.bash_profile (Mac) file; unset PSIDATADIR; export PATH={prefix}/bin:$PATH; export PSI_SCRATCH=/path/to/existing/writable/local-not-network/directory/for/scratch/files. Run PSI4 as executable.; >>> cat sample.in; molecule {; He; }; energy('hf/cc-pvdz'); compare_values(-2.85518839, get_variable('current energy'), 5, 'SCF E'); >>> psi4 sample.in; SCF E.............................................................PASSED. or Run PSI4 as Python module.; >>> cat sample.py; import psi4; mol = psi4.geometry(""""""; He; """"""); psi4.energy('hf/cc-pvdz'); psi4.compare_values(-2.85518839, psi4.core.get_variable('current energy'), 5, 'SCF E'); >>> python sample.py; SCF E.............................................................PASSED. How to run Psi4 as executable after compilation using driver from source¶; When developing python driver code, it can be annoying to keep makeing to test the code. PSI4 can be run “inplace” through the; following procedure. To be clear, this is running compiled C++ from the; build directory and python from the source directory. This is an expert; option for development, and not all functionality will be available.; >>> cd {objdir}; >>> ln -s {top-level-psi4-dir}/{objdir}/stage/lib/psi4/core.cpython-{ext_wi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/build_planning-1.html:30296,energy,energy,30296,psi4manual/1.4.0/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/build_planning-1.html,9,['energy'],['energy']
Energy Efficiency," opt7; Various constrained energy minimizations of HOOH with cc-pvdz RHF. For “fixed” coordinates, the final value is provided by the user. fci-tdm-2; BH-H2+ FCI/cc-pVDZ Transition Dipole Moment. dft-pbe0-2; Internal match to psi4, test to match to literature values in litref.in/litref.out. opt3; SCF cc-pVDZ geometry optimzation, with Z-matrix input. pywrap-checkrun-convcrit; Advanced python example sets different sets of scf/post-scf conv crit and check to be sure computation has actually converged to the expected accuracy. cc13a; UHF-CCSD(T)/cc-pVDZ CH2 geometry optimization via analytic gradients. mints9; A test of the basis specification. Various basis sets are specified outright and in blocks, both orbital and auxiliary. Constructs libmints BasisSet objects through the constructor that calls qcdb.BasisSet infrastructure. Checks that the resulting bases are of the right size and checks that symmetry of the Molecule observes the basis assignment to atoms. dfccsdl1; DF-CCSDL cc-pVDZ energy for the H2O molecule. dfmp2-4; conventional and density-fitting mp2 test of mp2 itself and setting scs-mp2. tu2-ch2-energy; Sample UHF/6-31G** CH2 computation. mcscf2; TCSCF cc-pVDZ energy of asymmetrically displaced ozone, with Z-matrix input. mints6; Patch of a glycine with a methyl group, to make alanine, then DF-SCF energy calculation with the cc-pVDZ basis set. sapt3; SAPT2+3(CCD) aug-cc-pVDZ computation of the water dimer interaction energy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. cc16; ROHF and UHF-B-CCD(T)/cc-pVDZ CH2 single-point energy (fzc, MO-basis ). dcft-grad4; Unrestricted DF-DCFT ODC-12 gradient for O2 with cc-pVTZ/cc-pVTZ-RI standard/auxiliary basis set. mints8; Patch of a glycine with a methyl group, to make alanine, then DF-SCF energy calculation with the cc-pVDZ basis set. ocepa-grad1; OCEPA cc-pVDZ gradient for the H2O molecule. fd-gradient; SCF STO-3G finite-difference tests. psimrcc-sp1; Mk-MRCCSD single point. O2 state de",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html:7824,energy,energy,7824,psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency," optimizations and frequency computations with SOS-OMP2, one needs to set ‘DO_SOS’ to true. Type: boolean; Default: false. DO_SOS (OCC)¶OCC — Removed in 1.4. Will raise an error in 1.5. Pass the method name, like scs-mp2, to energy instead. Type: boolean; Default: false. DO_THIRD_ORDER (SAPT)¶SAPT (Expert) — Do compute third-order corrections?. Type: boolean; Default: false. DO_TRIPLETS (CPHF)¶CPHF — Do triplet states? Default true. Type: boolean; Default: true. DOCC (GLOBALS)¶GLOBALS — An array containing the number of doubly-occupied orbitals per irrep (in Cotton order). Type: array; Default: No Default. DOCC (MCSCF)¶MCSCF — The number of doubly occupied orbitals, per irrep. Type: array; Default: No Default. DYNAMIC_LEVEL (OPTKING)¶OPTKING — Starting level for dynamic optimization (0=nondynamic, higher=>more conservative). Type: integer; Default: 0. E3_SCALE (DFOCC)¶DFOCC — CEPA opposite-spin scaling value from SCS-CCSD. Type: double; Default: 0.25. E3_SCALE (OCC)¶OCC — Scaling value for 3rd order energy correction (S. Grimme, Vol. 24, pp. 1529, J. Comput. Chem.). Type: double; Default: 0.25. E_CONVERGENCE (CCENERGY)¶CCENERGY — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. E_CONVERGENCE (CCEOM)¶CCEOM — Convergence criterion for excitation energy (change) in the Davidson algorithm for CC-EOM. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. E_CONVERGENCE (DCT)¶DCT — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-10. E_CONVERGENCE (DETCI)¶DETCI — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. E_CONVERGENCE (DFOCC)¶DFOCC — Convergence criteri",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:116422,energy,energy,116422,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,2,['energy'],['energy']
Energy Efficiency," optimizations. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) use PSI’s optimizer and so this keyword has no effect. Use optking keywords instead, particularly INTRAFRAG_STEP_LIMIT. Type: integer; Default: 300. CFOUR_GEO_METHOD (CFOUR); CFOUR — Specifies the used geometry optimization methods. The following values are permitted: NR (=0) — straightforward Newton-Raphson search for minimum; RFA (=1) — Rational Function Approximation search for minimum (this method can be used to find minima when the initial structure is in a region where the Hessian index is nonzero); TS (=2) Cerjan-Miller eigenvector following search for a transition state (can be started in a region where the Hessian index is not equal to unity); MANR (=3) — Morse-adjusted Newton-Raphson search for minimum (very efficient minimization scheme, particularly if the Hessian is available); SINGLE_POINT (=5) for a single-point energy calculation. ENERONLY (=6) requests a geometry optimization based on single-point energy calculations. Default: SINGLE-POINT (NR as soon as variables are marked to be optimized). Type: string; Possible Values: NR, RFA, TS, MANR, SINGLE_POINT, ENERONLY; Default: SINGLE_POINT. CFOUR_GIAO (CFOUR); CFOUR — Specifies whether gauge-including atomic orbitals are used (ON) or not (OFF). Default: ON for CFOUR_PROPS =NMR and =MAGNETIC, otherwise OFF. Type: string; Possible Values: ON, OFF; Default: No Default. CFOUR_GRID (CFOUR); CFOUR — Keyword used to control type of grid calculation (see later section in this manual). Options are OFF (=0), no grid calculation; CARTESIAN (=1), steps are in Cartesian coordinates (which must be run with CFOUR_COORDINATES =CARTESIAN); INTERNAL (=2), steps are in Z-matrix internal coordinates; QUADRATURE (=3) steps are chosen for an integration based on Gauss-Hermite quadrature. (Default: OFF). Type: string; Possible Values: OFF, CARTESIAN, INTERNAL, QUADRATURE; Default: OFF. CFOUR_GUESS (CFOUR); CFOUR — Where the initi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:49273,energy,energy,49273,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,8,['energy'],['energy']
Energy Efficiency," optimize geometry at mp2 (no frozen core) level; # note: freeze_core isn't an option in MP2; psi4.set_global_option('FREEZE_CORE',""FALSE""); optimize('conv-mp2'); psi4.clean(). # qcisd(t); psi4.set_local_option('FNOCC','COMPUTE_MP4_TRIPLES',""TRUE""); psi4.set_global_option('FREEZE_CORE',""TRUE""); psi4.set_global_option('BASIS',""6-311G(D_P)""); run_fnocc('qcisd(t)',**kwargs). # HLC: high-level correction based on number of valence electrons; ref = psi4.wavefunction(); nirrep = ref.nirrep(); frzcpi = ref.frzcpi(); nfzc = 0; for i in range (0,nirrep):; nfzc += frzcpi[i]; nalpha = ref.nalpha() - nfzc; nbeta = ref.nbeta() - nfzc; # hlc of gaussian-2; hlc = -0.00481 * nalpha -0.00019 * nbeta; # hlc of gaussian-1; hlc1 = -0.00614 * nalpha. eqci_6311gdp = psi4.get_variable(""QCISD(T) TOTAL ENERGY""); emp4_6311gd = psi4.get_variable(""MP4 TOTAL ENERGY""); emp2_6311gd = psi4.get_variable(""MP2 TOTAL ENERGY""); psi4.clean(). # correction for diffuse functions; psi4.set_global_option('BASIS',""6-311+G(D_P)""); energy('mp4'); emp4_6311pg_dp = psi4.get_variable(""MP4 TOTAL ENERGY""); emp2_6311pg_dp = psi4.get_variable(""MP2 TOTAL ENERGY""); psi4.clean(). # correction for polarization functions; psi4.set_global_option('BASIS',""6-311G(2DF_P)""); energy('mp4'); emp4_6311g2dfp = psi4.get_variable(""MP4 TOTAL ENERGY""); emp2_6311g2dfp = psi4.get_variable(""MP2 TOTAL ENERGY""); psi4.clean(). # big basis mp2; psi4.set_global_option('BASIS',""6-311+G(3DF_2P)""); run_fnocc('_mp2',**kwargs); emp2_big = psi4.get_variable(""MP2 TOTAL ENERGY""); psi4.clean(). eqci = eqci_6311gdp; e_delta_g2 = emp2_big + emp2_6311gd - emp2_6311g2dfp - emp2_6311pg_dp; e_plus = emp4_6311pg_dp - emp4_6311gd; e_2df = emp4_6311g2dfp - emp4_6311gd. eg2 = eqci + e_delta_g2 + e_plus + e_2df; eg2_mp2_0k = eqci + (emp2_big - emp2_6311gd) + hlc + zpe. psi4.print_out('\n'); psi4.print_out(' ==> G1/G2 Energy Components <==\n'); psi4.print_out('\n'); psi4.print_out(' QCISD(T): %20.12lf\n' % eqci); psi4.print_out(' E(Delta): %20.12lf\n' % e_delta_g",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/gaussian_n.html:3238,energy,energy,3238,psi4manual/4.0b5/_modules/gaussian_n.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/gaussian_n.html,1,['energy'],['energy']
Energy Efficiency," option for triples contribution? Note that this option is enabled automatically if the memory requirements of the conventional algorithm would exceed the available resources. Type: boolean; Default: false. Expert¶. CEPA_LEVEL¶. Which coupled-pair method is called? This parameter is used internally by the python driver. Changing its value won’t have any effect on the procedure. Type: string; Default: CEPA(0). COMPUTE_MP4_TRIPLES¶. Do compute MP4 triples contribution?. Type: boolean; Default: false. COMPUTE_TRIPLES¶. Do compute triples contribution?. Type: boolean; Default: true. RUN_CCSD¶. do ccsd rather than qcisd?. Type: boolean; Default: false. RUN_CEPA¶. Is this a CEPA job? This parameter is used internally by the pythond driver. Changing its value won’t have any effect on the procedure. Type: boolean; Default: false. RUN_MP2¶. do only evaluate mp2 energy?. Type: boolean; Default: false. RUN_MP3¶. do only evaluate mp3 energy?. Type: boolean; Default: false. RUN_MP4¶. do only evaluate mp4 energy?. Type: boolean; Default: false. USE_DF_INTS¶. Use 3-index integrals to generate 4-index ERI’s? This keyword is used for testing purposes only. Changing its value will have no effect on the computation. Type: boolean; Default: false. Table Of Contents. FNOCC; General; ACTIVE_NAT_ORBS; BRUECKNER_MAXITER; CC_SCALE_OS; CC_SCALE_SS; CC_TIMINGS; CEPA_NO_SINGLES; CHOLESKY_TOLERANCE; DFCC; DF_BASIS_CC; DIIS_MAX_VECS; DIPMOM; E_CONVERGENCE; MAXITER; MP2_SCALE_OS; MP2_SCALE_SS; NAT_ORBS; OCC_PERCENTAGE; OCC_TOLERANCE; R_CONVERGENCE; SCS_CCSD; SCS_CEPA; SCS_MP2; TRIPLES_LOW_MEMORY. Expert; CEPA_LEVEL; COMPUTE_MP4_TRIPLES; COMPUTE_TRIPLES; RUN_CCSD; RUN_CEPA; RUN_MP2; RUN_MP3; RUN_MP4; USE_DF_INTS. Previous topic; SSAPT0_SCALE; Next topic; ACTIVE_NAT_ORBS. This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; Psi4 [1.0.0 6a9a71b] » ; Appendices »; Keywords by Module ». © Copyr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__fnocc-1.html:4309,energy,energy,4309,psi4manual/1.0.0/autodir_options_c/module__fnocc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__fnocc-1.html,2,['energy'],['energy']
Energy Efficiency," option for triples contribution? Note that this option is enabled automatically if the memory requirements of the conventional algorithm would exceed the available resources. Type: boolean; Default: false. Expert¶. CEPA_LEVEL¶. Which coupled-pair method is called? This parameter is used internally by the python driver. Changing its value won’t have any effect on the procedure. Type: string; Default: CEPA(0). COMPUTE_MP4_TRIPLES¶. Do compute MP4 triples contribution?. Type: boolean; Default: false. COMPUTE_TRIPLES¶. Do compute triples contribution?. Type: boolean; Default: true. RUN_CCSD¶. do ccsd rather than qcisd?. Type: boolean; Default: false. RUN_CEPA¶. Is this a CEPA job? This parameter is used internally by the pythond driver. Changing its value won’t have any effect on the procedure. Type: boolean; Default: false. RUN_MP2¶. do only evaluate mp2 energy?. Type: boolean; Default: false. RUN_MP3¶. do only evaluate mp3 energy?. Type: boolean; Default: false. RUN_MP4¶. do only evaluate mp4 energy?. Type: boolean; Default: false. USE_DF_INTS¶. Use 3-index integrals to generate 4-index ERI’s? This keyword is used for testing purposes only. Changing its value will have no effect on the computation. Type: boolean; Default: false. Table Of Contents. FNOCC; General; BRUECKNER_MAXITER; CC_SCALE_OS; CC_SCALE_SS; CC_TIMINGS; CEPA_NO_SINGLES; CHOLESKY_TOLERANCE; DFCC; DF_BASIS_CC; DIIS_MAX_VECS; DIPMOM; E_CONVERGENCE; MAXITER; MP2_SCALE_OS; MP2_SCALE_SS; NAT_ORBS; OCC_TOLERANCE; R_CONVERGENCE; SCS_CCSD; SCS_CEPA; SCS_MP2; TRIPLES_LOW_MEMORY. Expert; CEPA_LEVEL; COMPUTE_MP4_TRIPLES; COMPUTE_TRIPLES; RUN_CCSD; RUN_CEPA; RUN_MP2; RUN_MP3; RUN_MP4; USE_DF_INTS. Previous topic; POINTS; Next topic; BRUECKNER_MAXITER; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta5] » ; Appendices »; Keywords by Module ». © Copyright 2013, The Psi4 Project.; Last updated on",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodir_options_c/module__fnocc-1.html:3561,energy,energy,3561,psi4manual/4.0b5/autodir_options_c/module__fnocc-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/module__fnocc-1.html,2,['energy'],['energy']
Energy Efficiency," or 6. Alternate Implementations¶; Depending on the reference (RHF, UHF, ROHF) and the integral treatment; (conventional CONV, density-fitted DF, and Cholesky-decomposed CD),; computational methods are sometimes implemented by multiple coders or even; multiple times. PSI4 transparently selects the most efficient; implementation, so one generally needn’t consult this table. However, to; understand the details of what combinations are accessible or what; alternate implementations are available, read on.; Below, “Y” means method available in module, “D” means module is default; for that method, and “” means method not available. HF, DFT, and MP2; default to density-fitted integrals, while all higher methods default to; conventional integrals. Therefore, for a closed-shell molecule:. runs MP2 with default DF with default implementation DFMP2; 1energy('mp2'). runs MP2 with CONV with default implementation OCC; 1; 2set mp2_type conv; energy('mp2'). runs MP2 with default DF with implementation OCC; 1; 2set qc_module occ; energy('mp2'). Overlapping capabilities of PSI4. “Y” is available; “D” is default.¶. name; _; type select [1]. QC_MODULE; REFERENCE; _. energy(); gradient(). RHF; UHF; ROHF; RHF; UHF; ROHF. CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD. mp2; MP2_TYPE. CCENERGY;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  . DETCI; Y;  ;  ;  ;  ;  ; Y;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  . DFMP2;  ; D [2];  ;  ; D [2];  ;  ; D;  ;  ; D;  ;  ;  ;  ;  ;  ;  . FNOCC; Y;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  . OCC; D; Y; D; D; Y; Y; D; Y; D; D; Y;  ; D; D;  ;  ;  ;  . mp3; MP_TYPE. CCENERGY;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  . DETCI; Y;  ;  ;  ;  ;  ; Y [3];  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  . DFMP2;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  . FNOCC; Y;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  . OCC; D; D; D; D; D; D;  ;  ;  ; D; D;  ; D; D;  ;  ;  ;  . mp2.5; MP_TYPE. CCENERGY;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/notes_c-1.html:2163,energy,energy,2163,psi4manual/1.1.0/notes_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/notes_c-1.html,6,['energy'],['energy']
Energy Efficiency," or psi4.core.Molecule, optional) – Single molecule with same number of real atoms as self with atoms; reordered into adjacent fragments and fragment markers inserted.; Loses ghost/dummy info from self; keeps total charge but not total mult.; Only provided if return_molecule is True.; Returned is of same type as self. Notes. Relies upon van der Waals radii and so faulty for close (especially; hydrogen-bonded) fragments. See seed_atoms. Any existing fragmentation info/chgmult encoded in self is lost.; Original code from Michael S. Marshall, linear-scaling algorithm from; Trent M. Parker, revamped by Lori A. Burns. Z(self: psi4.core.Molecule, arg0: int) → float; Nuclear charge of atom arg0 (0-indexed without dummies). activate_all_fragments(self: psi4.core.Molecule) → None; Sets all fragments in the molecule to be active. add_atom(self: psi4.core.Molecule, Z: float, x: float, y: float, z: float, symbol: str, mass: float, charge: float, label: str, A: int) → None; Adds to self Molecule an atom with atomic number Z, Cartesian coordinates in Bohr (x, y, z), atomic symbol, mass, and charge, extended atomic label, and mass number A. atom_at_position(*args, **kwargs); Overloaded function. atom_at_position(self: psi4.core.Molecule, coord: float, tol: float) -> int. Tests to see if an atom is at the position coord with a given tolerance tol. atom_at_position(self: psi4.core.Molecule, coord: List[float[3]], tol: float) -> int. Tests to see if an atom is at the position coord with a given tolerance tol. basis_on_atom(self: psi4.core.Molecule, arg0: int) → str; Gets the label of the orbital basis set on a given atom arg0. center_of_mass(self: psi4.core.Molecule) → psi4.core.Vector3; Computes center of mass of molecule (does not translate molecule). charge(self: psi4.core.Molecule, atom: int) → float; Gets charge of atom (0-indexed without dummies). clone(self: psi4.core.Molecule) → psi4.core.Molecule; Returns a new Molecule identical to arg1. com_fixed(self: psi4.core.Molecule) ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.molecule.html:41394,charge,charge,41394,psi4manual/1.3.2/api/psi4.core.molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.molecule.html,2,['charge'],['charge']
Energy Efficiency," orbital localization. PetiteList; Handles symmetry transformations. PointFunctions; docstring. PointGroup; Contains information about the point group. PotentialInt; Computes potential integrals. PrimitiveType; May be Normalized or Unnormalized. Prop; docstring. ProtoIntVector. ProtoVector. PsiReturnType; Return status. QuadrupoleInt; Computes quadrupole integrals. RHF; docstring. RKSFunctions; docstring. ROHF; docstring. SADGuess; docstring. SOBasisSet; An SOBasis object describes the transformation from an atomic orbital basis to a symmetry orbital basis. SOMCSCF; docstring. SalcComponent; Component of a Cartesian displacement SALC in the basis of atomic displacements. SaveType; The layout of the matrix for saving. ShellInfo. Slice; Slicing for Matrix and Vector objects. SuperFunctional; docstring. SymmetryOperation; Class to provide a 3 by 3 matrix representation of a symmetry operation, such as a rotation or reflection. TLaplaceDenominator; Computer class for a Laplace factorization of the six-index energy denominator in coupled-cluster theory. ThreeCenterOverlapInt; Three center overlap integrals. TracelessQuadrupoleInt; Computes traceless quadrupole integrals. TwoBodyAOInt; Two body integral base class. TwoElectronInt; Computes two-electron repulsion integrals. UHF; docstring. UKSFunctions; docstring. VBase; docstring. Vector; Class for creating and manipulating vectors. Vector3; Class for vectors of length three, often Cartesian coordinate vectors, and their common operations. Wavefunction; docstring. dpdbuf4; docstring. dpdfile2; docstring. psio_entry; docstring. Class Inheritance Diagram¶. psi4.driver Package¶. Functions¶. activate(mol); Function to set molecule object mol as the current active molecule. banner(text[, type, width, strNotOutfile]); Format text into a banner style and print or return it. basis_helper(block[, name, key, set_option]); Helper to specify a custom basis set in PsiAPI mode. cbs(func, label, **kwargs); Function to define a multistage",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/psi4api.html:15090,energy,energy,15090,psi4manual/1.7.x/psi4api.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/psi4api.html,4,['energy'],['energy']
Energy Efficiency," orbital occupancy of the reference function in terms of the occupation numbers of the orbitals and their irreducible representations. The occupancy is specified by either NIRREP or 2*NIRREP integers specifying the number of occupied orbitals of each symmetry type, where NIRREP is the number of irreducible representations in the computational point group. If there are no orbitals of a particular symmetry type a zero must be entered. If the reference function is for an open-shell system, two strings of NIRREP occupation numbers separated by a slash are input for the \(\alpha\) and \(\beta\) sets of orbitals. An example of the use of the OCCUPATION keyword for the water molecule would be OCCUPATION=3-1-1-0. For the \(^2A_1\) water cation, an open-shell system, the keyword would be specified by OCCUPATION=3-1-1-0/2-1-1-0. It should be noted that the xvmol integral program orders the irreducible representations in a strange way, which most users do not perceive to be a logical order. Hence, it is usually advisable initially to run just a single point integral and HF-SCF calculation in order to determine the number and ordering of the irreducible representations. The occupation keyword may be omitted, in which case an initial orbital occupancy is determined by diagonalization of the core Hamiltonian. In many cases, HF-SCF calculations run with the core Hamiltonian guess will usually converge to the lowest energy HF-SCF solution, but this should not be blindly assumed. (Default: The occupation is given by the core Hamiltonian initial guess). Psi4 Interface: The arrays above are specified in PSI as (white space tolerant) [3,1,1,0] and [[3,1,1,0],[3,0,1,0]]. Type: array; Default: No Default. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Appendices; Keywords by Module; CFOUR; CFOUR_OCCUPATION. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodir_options_c/cfour__cfour_occupation.html:1604,energy,energy,1604,psi4manual/1.8.x/autodir_options_c/cfour__cfour_occupation.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodir_options_c/cfour__cfour_occupation.html,1,['energy'],['energy']
Energy Efficiency," orbital occupancy of the reference function in terms of the occupation numbers of the orbitals and their irreducible representations. The occupancy is specified by either NIRREP or 2*NIRREP integers specifying the number of occupied orbitals of each symmetry type, where NIRREP is the number of irreducible representations in the computational point group. If there are no orbitals of a particular symmetry type a zero must be entered. If the reference function is for an open-shell system, two strings of NIRREP occupation numbers separated by a slash are input for the \(\alpha\) and \(\beta\) sets of orbitals. An example of the use of the OCCUPATION keyword for the water molecule would be OCCUPATION=3-1-1-0. For the \(^2A_1\) water cation, an open-shell system, the keyword would be specified by OCCUPATION=3-1-1-0/2-1-1-0. It should be noted that the xvmol integral program orders the irreducible representations in a strange way, which most users do not perceive to be a logical order. Hence, it is usually advisable initially to run just a single point integral and HF-SCF calculation in order to determine the number and ordering of the irreducible representations. The occupation keyword may be omitted, in which case an initial orbital occupancy is determined by diagonalization of the core Hamiltonian. In many cases, HF-SCF calculations run with the core Hamiltonian guess will usually converge to the lowest energy HF-SCF solution, but this should not be blindly assumed. (Default: The occupation is given by the core Hamiltonian initial guess). Psi4 Interface: The arrays above are specified in PSI as (white space tolerant) [3,1,1,0] and [[3,1,1,0],[3,0,1,0]]. Type: array; Default: No Default. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Appendices; Keywords by Module; CFOUR; CFOUR_OCCUPATION. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodir_options_c/cfour__cfour_occupation.html:1604,energy,energy,1604,psi4manual/1.9.x/autodir_options_c/cfour__cfour_occupation.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodir_options_c/cfour__cfour_occupation.html,1,['energy'],['energy']
Energy Efficiency," orbitals as a guess for the anion; neutral_guess = kwargs.get('neutral_guess', True). # By default, burn-in with UHF first, if UKS; hf_guess = False; if psi4.get_global_option('REFERENCE') == 'UKS':; hf_guess = kwargs.get('hf_guess', True). # By default, re-guess at each N; continuous_guess = kwargs.get('continuous_guess', False). # By default, drop the files to the molecule's name; root = kwargs.get('filename', molecule.name()); traverse_filename = root + '.traverse.dat'; # => Traverse <= #; occs = []; energies = []; potentials = []; convs = []. # => Run the neutral for its orbitals, if requested <= #. old_df_ints_io = psi4.get_global_option(""DF_INTS_IO""); psi4.set_global_option(""DF_INTS_IO"", ""SAVE""). old_guess = psi4.get_global_option(""GUESS""); if (neutral_guess):; if (hf_guess):; psi4.set_global_option(""REFERENCE"",""UHF""); energy('scf'); psi4.set_global_option(""GUESS"", ""READ""); psi4.set_global_option(""DF_INTS_IO"", ""LOAD""). # => Run the anion first <= #. molecule.set_molecular_charge(chargem); molecule.set_multiplicity(multm). # => Burn the anion in with hf, if requested <= #; if hf_guess:; psi4.set_global_option(""REFERENCE"",""UHF""); energy('scf', molecule=molecule, **kwargs); psi4.set_global_option(""REFERENCE"",""UKS""); psi4.set_global_option(""GUESS"", ""READ""); psi4.set_global_option(""DF_INTS_IO"", ""SAVE""). psi4.set_global_option(""FRAC_START"", frac_start); psi4.set_global_option(""FRAC_RENORMALIZE"", True); psi4.set_global_option(""FRAC_LOAD"", False). for occ in LUMO_occs:. psi4.set_global_option(""FRAC_OCC"", [LUMO]); psi4.set_global_option(""FRAC_VAL"", [occ]). E, wfn = energy('scf', return_wfn=True, molecule=molecule, **kwargs); C = 1; if E == 0.0:; E = psi4.get_variable('SCF ITERATION ENERGY'); C = 0. if LUMO > 0:; eps = wfn.epsilon_a(); potentials.append(eps[int(LUMO) - 1]); else:; eps = wfn.epsilon_b(); potentials.append(eps[-int(LUMO) - 1]). occs.append(occ); energies.append(E); convs.append(C). psi4.set_global_option(""FRAC_START"", 2); psi4.set_global_option(""FRAC_LOA",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/frac.html:3579,charge,chargem,3579,psi4manual/1.0.0/_modules/frac.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/frac.html,1,['charge'],['chargem']
Energy Efficiency," orbitals from Superposition of Atomic Densities. Similar; to the above, but it forms natural orbitals from the SAD density; matrix to get proper orbitals which are used to start the; calculation, see [Lehtola:2019:1593]. GWHA generalized Wolfsberg-Helmholtz modification of the core; Hamiltonian matrix. May be useful in open-shell systems, but is; often less accurate than the core guess (see; [Lehtola:2019:1593]). HUCKELAn extended Hückel guess based on on-the-fly atomic UHF; calculations alike SAD, see [Lehtola:2019:1593]. READRead the previous orbitals from a wfn file, casting from; one basis to another if needed. Useful for starting anion; computations from neutral orbitals, or after small geometry; changes. At present, casting from a different molecular point; group is not supported. This becomes the default for the second; and later iterations of geometry optimizations. SAPSuperposition of Atomic Potentials. This is essentially a; modification of the core Hamiltonian, which includes screening; effects by using a radially screened effective atomic charge. The; screening effects have been calculated at the complete basis set; limit with finite-element calculations, see [Lehtola:2019:25945]; and [Lehtola:2020:012516]. The guess and its implementation have; been described in [Lehtola:2019:1593]. The guess is evaluated on a; DFT quadrature grid, so the guess energy depends slightly on the; used DFT quadrature. The current implementation is based on; exchange-only local density calculations that are but nanohartree; away from the complete basis set limit [Lehtola:2020:012516]. These are all set by the GUESS keyword. Also, an automatic Python; procedure has been developed for converging the SCF in a small basis, and then; casting up to the true basis. This can be done by adding; BASIS_GUESS = SMALL_BASIS to the options list. We recommend the; 3-21G or pcseg-0 basis for the small basis due to its efficient mix of flexibility and; compactness. An example of performing an",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/scf-1.html:18530,charge,charge,18530,psi4manual/1.4.0/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/scf-1.html,4,['charge'],['charge']
Energy Efficiency," orbitals. omp3-grad1; OMP3 cc-pVDZ gradient for the H2O molecule. psimrcc-ccsd_t-3; Mk-MRCCSD(T) single point. \(^1A_1\) CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. mom-h2o-3; MOM excitation from LUMO HOMO+3. dfccsdt2; DF-CCSD(T) cc-pVDZ energy for the NH molecule. dfmp2-ecp; Ne-Xe dimer MP2 energies with ECP, with electrons correlated then frozen. explicit-am-basis; Check that basis sets can be input with explicit angular momentum format. pywrap-cbs1; Various basis set extrapolation tests. fnocc2; Test G2 method for H2O. cbs-xtpl-dict; Extrapolated water energies. cc26; Single-point gradient, analytic and via finite-differences of 2-1A1 state of H2O with EOM-CCSD. mpn-bh; MP(n)/aug-cc-pVDZ BH Energy Point, with n=2-19. Compare against M. L. Leininger et al., J. Chem. Phys. 112, 9213 (2000). mints15; check SP basis Fortran exponent parsing. dfmp2-freq2; DF-MP2 frequency by difference of energies for H2O. omp3-2; OMP3 cc-pCVDZ energy with ROHF initial guess for the NO radical. cc45; RHF-EOM-CC2/cc-pVDZ lowest two states of each symmetry of H2O. dfomp2-grad3; Tests OMP2 gradient in the presence of a dipole field. omp2p5-grad1; OMP2.5 cc-pVDZ gradient for the H2O molecule. opt-freeze-coords; SCF/cc-pVDZ optimization example with frozen cartesian. sapt10; usapt example with empty beta due to frozen core. dft-grad-lr1; wB97X-D cc-pVDZ gradient of S22 HCN update df/pk_ref values due to new BraggSlater radii. scf-cholesky-basis; incremental Cholesky filtered SCF. scf-guess-read3; Test if the the guess read in the same basis converges. extern3; External potential calculation with one Ghost atom and one point charge at the same position. mbis-3; MBIS calculation on OH radical. dfomp2p5-2; DF-OMP2.5 cc-pVDZ energy for the H2O+ cation. isapt-charged; This test case shows an example of running the I-SAPT0/aug-cc-pVDZ computation for a positively charged system, illustrating the cation-pi interaction. The SIAO1 link partitioning algo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html:20458,energy,energy,20458,psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency," order has the spin-orbital formula:. (1); Here and are occupied spin orbitals, and; are virtual spin orbitals, are the ; Fock Matrix elements, are the orbital eigenvalues, and; are the antisymmetrized physicist’s ERIs.; For converged RHF and UHF references, the singles correction,. is zero due to the Brillioun Condition, and the first contribution to the; perturbation series is at the second order:. In the DFMP2 module, the first-order contribution, or “singles energy” is; always evaluated. This term is a significant contributor to the total; second-order energy if a ROHF reference is used. In this case, we have chosen; to use the ROHF-MBPT(2) ansatz, in which the ROHF orbitals are; semicanonicalized, the resultant nonzero Fock matrix elements are used; to form the singles amplitudes, and then the second-order amplitudes are formed; with the semicanonical spin orbitals via the same machinery as a UHF-MP2. Note; that the singles energy should be very close to zero for RHF and UHF references;; if it is not, there is a good chance your orbitals are not well converged.; Tighten the SCF E_CONVERGENCE and/or D_CONVERGENCE keywords; and try again.; To increase the efficiency of MP2 energy evaluation, spin integration; and simplification is carried out. This also allows for the identification of; Same-Spin (SS) and Opposite-Spin (OS) terms for use in Grimme’s Spin-Component; Scaled (SCS) MP2. For RHF-MP2 (also labeled as RMP2), the spin-free equations are; (note that the integrals are now chemist’s integrals over spatial orbitals). and. For UHF-MP2 (also labeled as UMP2) and the second-order contribution to; ROHF-MBPT(2) using semicanonical orbitals, the spin-free equations are. and. Note that the UHF-MP2 equations use three classes of integrals, while the; RHF-MP2 equations use only one class. Because of this, a UHF-MP2 or; ROHF-MBPT(2) energy should take roughly three times as long as an RHF-MP2; energy. Recommendations¶; All-in-all, DFMP2 should be a simple module to use",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/dfmp2-1.html:4756,energy,energy,4756,psi4manual/1.0.0/dfmp2-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/dfmp2-1.html,10,['energy'],['energy']
Energy Efficiency," os.path.join(psi_scratch, fname + ""."" + file_num + "".npy""); if not item.endswith("".npy""):; item = item + "".npy""; else:; filenum = name_split[-1]; try:; filenum = int(filenum); except ValueError:; filenum = 32 # Default file number is the checkpoint one; psioh = core.IOManager.shared_object(); psio = core.IO.shared_object(); filepath = psioh.get_file_path(filenum); namespace = psio.get_default_namespace(); pid = str(os.getpid()); prefix = 'psi'; targetfile = filepath + prefix + '.' + pid + '.' + namespace + '.' + str(filenum); core.print_out(f"" \n Copying restart file <{item}> to <{targetfile}> for internal processing\n""); shutil.copy(item, targetfile). logger.info(f""Compute energy(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); wfn = procedures['energy'][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return energy(): {core.variable('CURRENT ENERGY')}""). for postcallback in hooks['energy']['post']:; postcallback(lowername, wfn=wfn, **kwargs). basisstash.restore(); optstash.restore(); optstash2.restore(). if return_wfn: # TODO current energy safer than wfn.energy() for now, but should be revisited. # TODO place this with the associated call, very awkward to call this in other areas at the moment; if lowername in ['efp', 'mrcc', 'dmrg']:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the incoming reference wavefunction.\n\n""); elif 'sapt' in lowername:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the dimer SCF wavefunction.\n\n""). return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]; def gradient(name,",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:40662,energy,energy,40662,psi4manual/1.8.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html,3,['energy'],['energy']
Energy Efficiency," os.path.join(psi_scratch, fname + ""."" + file_num + "".npy""); if not item.endswith("".npy""):; item = item + "".npy""; else:; filenum = name_split[-1]; try:; filenum = int(filenum); except ValueError:; filenum = 32 # Default file number is the checkpoint one; psioh = core.IOManager.shared_object(); psio = core.IO.shared_object(); filepath = psioh.get_file_path(filenum); namespace = psio.get_default_namespace(); pid = str(os.getpid()); prefix = 'psi'; targetfile = filepath + prefix + '.' + pid + '.' + namespace + '.' + str(filenum); core.print_out(f"" \n Copying restart file <{item}> to <{targetfile}> for internal processing\n""); shutil.copy(item, targetfile). logger.info(f""Compute energy(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); wfn = procedures['energy'][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return energy(): {core.variable('CURRENT ENERGY')}""). for postcallback in hooks['energy']['post']:; postcallback(lowername, wfn=wfn, **kwargs). basisstash.restore(); optstash.restore(); optstash2.restore(). if return_wfn: # TODO current energy safer than wfn.energy() for now, but should be revisited. # TODO place this with the associated call, very awkward to call this in other areas at the moment; if lowername in ['efp', 'mrcc', 'dmrg']:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the incoming reference wavefunction.\n\n""); elif 'sapt' in lowername:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the dimer SCF wavefunction.\n\n""). return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]def gradient(name, *",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html:33828,energy,energy,33828,psi4manual/1.6.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html,2,['energy'],['energy']
Energy Efficiency," otherwise. xtpl_highest_1(); scf_xtpl_helgaker_3(); scf_xtpl_helgaker_2(); scf_xtpl_truhlar_2(); scf_xtpl_karton_2(). corl_scheme (str) – \(\Rightarrow\) 'xtpl_highest_1' \(\Leftarrow\) || 'corl_xtpl_helgaker_2' || etc.; Indicates the basis set extrapolation scheme to be applied to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in corl_basis and xtpl_highest_1() otherwise. xtpl_highest_1(); corl_xtpl_helgaker_2(). delta_scheme (str) – \(\Rightarrow\) 'xtpl_highest_1' \(\Leftarrow\) || 'corl_xtpl_helgaker_2' || etc.; Indicates the basis set extrapolation scheme to be applied to the delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta_basis and xtpl_highest_1() otherwise. xtpl_highest_1(); corl_xtpl_helgaker_2(). delta2_scheme (str) – \(\Rightarrow\) 'xtpl_highest_1' \(\Leftarrow\) || 'corl_xtpl_helgaker_2' || etc.; Indicates the basis set extrapolation scheme to be applied to the second delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta2_basis and xtpl_highest_1() otherwise. xtpl_highest_1(); corl_xtpl_helgaker_2(). scf_alpha (float) – \(\Rightarrow\) 1.63 \(\Leftarrow\); Overrides the default alpha parameter used in the listed SCF extrapolation procedures.; Has no effect on others, including xtpl_highest_1() and scf_xtpl_helgaker_3(). scf_xtpl_helgaker_2(); scf_xtpl_truhlar_2(); scf_xtpl_karton_2(). corl_alpha (float) – \(\Rightarrow\) 3.00 \(\Leftarrow\); Overrides the default alpha parameter used in the listed corl_xtpl_helgaker_2() correlation; extrapolation to the corl stage. The supplied alpha does not impact delta or any further stages. corl_xtpl_helgaker_2(). delta_alpha (float) – \(\Rightarrow\) 3.00 \(\Leftarrow\); Overrides the default alpha parameter used in the listed; corl_xtpl_helgaker_2() correlation extrapolation for the delta correction. Useful when; delta correcti",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.cbs.html:9251,energy,energy,9251,psi4manual/1.7.x/api/psi4.driver.cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.cbs.html,8,['energy'],['energy']
Energy Efficiency," outright and in blocks, both orbital and auxiliary. Constructs libmints BasisSet objects through the constructor that calls qcdb.BasisSet infrastructure. Checks that the resulting bases are of the right size and checks that symmetry of the Molecule observes the basis assignment to atoms. cisd-h2o+-0; 6-31G** H2O+ Test CISD Energy Point. dft-reference; MP2 with a PBE0 reference computation. nbody-nocp-gradient; Computation of NoCP-corrected water trimer gradient (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). dlpnomp2-1; comparison of DF-MP2 and DLPNO-MP2. linK-1; RHF Linear Exchange Algorithm test for water. omp3-5; SOS-OMP3 cc-pVDZ geometry optimization for the H2O molecule. cisd-h2o+-2; 6-31G** H2O+ Test CISD Energy Point. dfomp2-2; OMP2 cc-pVDZ energy for the NO molecule. cc27; Single point gradient of 1-1B2 state of H2O with EOM-CCSD. psithon2; Accesses basis sets, databases, plugins, and executables in non-install locations. mcscf2; TCSCF cc-pVDZ energy of asymmetrically displaced ozone, with Z-matrix input. tdscf-2; td-uhf test on triplet states of methylene (tda), wfn passing. mp2-h; check that methods can act on single atom. linK-2; RKS Linear Exchange Algorithm test for benzene. nbody-intermediates; HF/cc-pVDZ many body energies of an arbitrary noble gas trimer complex Size vs cost tradeoff is rough here. pywrap-checkrun-rohf; This checks that all energy methods can run with a minimal input and set symmetry. fsapt-ext-abc2; FSAPT with external charge on dimer. fd-freq-energy; SCF STO-3G finite-difference frequencies from energies for H2O. dft-grad1; DF-BP86-D2 cc-pVDZ frozen core gradient of S22 HCN update ref gradient due to new BraggSlater radii. opt-full-hess-every; SCF/sto-3g optimization with a hessian every step. fsaptd-terms; F-SAPT0/jun-cc-pvdz procedure for methane dimer. dft-jk; DFT JK on-disk test. fd-freq-gradient; SCF STO-3G finite-differences frequencies from gradients for H2O. cc15; RHF-B-CCD(T)/6-31G** H2O single-point energy (",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html:28340,energy,energy,28340,psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency," overlap integrals S. partition(self); Partition the nuclei and electrons. plot(); Filesystem wrapper for FISAPT::plot. print_header(self); Print header, bases, sizes, etc. print_trailer(self); Print SAPT results. raw_plot(self, arg0); Plot some analysis files. scalars(self); Return the interally computed scalars (not copied). scf(self); Solve the relaxed SCF equations for A0 and B0. sinf_disp(self, arg0, arg1, arg2); Computes the MP2-based DispE20 and Exch-DispE20 energy without S^2. unify(self); Produce unified matrices for A', B', and C'. vectors(self); Return the interally computed vectors (not copied). Methods Documentation. compute_energy(external_potentials=None)¶; Computes the FSAPT energy. FISAPT::compute_energy. coulomb(self: psi4.core.FISAPT) → None¶; Build the J/K potentials for C, D, and E. dHF(self: psi4.core.FISAPT) → None¶; SAPT0 delta HF. disp(self: psi4.core.FISAPT, arg0: Dict[str, psi4.core.Matrix], arg1: Dict[str, psi4.core.Vector], arg2: bool) → None¶; Computes the MP2-based DispE20 and Exch-DispE20 energy. elst(self: psi4.core.FISAPT) → None¶; SAPT0 electrostatics. exch(self: psi4.core.FISAPT) → None¶; SAPT0 exchange. fdisp(self: psi4.core.FISAPT) → None¶; F-SAPT0 dispersion. fdrop(external_potentials=None)¶; Drop output files from FSAPT calculation. FISAPT::fdrop. felst(self: psi4.core.FISAPT) → None¶; F-SAPT0 electrostatics. fexch(self: psi4.core.FISAPT) → None¶; F-SAPT0 exchange. find(self: psi4.core.FISAPT) → None¶; F-SAPT0 induction. flocalize(self: psi4.core.FISAPT) → None¶; F-SAPT0 localize. freeze_core(self: psi4.core.FISAPT) → None¶; Freeze the core orbitals. ind(self: psi4.core.FISAPT) → None¶; SAPT0 induction. kinetic(self: psi4.core.FISAPT) → None¶; Build the kinetic integrals T. localize(self: psi4.core.FISAPT) → None¶; Localize the active occupied orbitals via IBO2. matrices(self: psi4.core.FISAPT) → Dict[str, psi4.core.Matrix]¶; Return the interally computed matrices (not copied). molecule(self: psi4.core.FISAPT) → psi4.core.Molec",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.fisapt.html:2212,energy,energy,2212,psi4manual/1.5.0/api/psi4.core.fisapt.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.fisapt.html,3,['energy'],['energy']
Energy Efficiency," overlaps, and finally \(t_{ij}^{ab}\) are the MP2; amplitudes to be solved for. Virtual orbitals may be different for each pair; of occupied orbitals. For a given occupied orbital pair ij, all virtuals are; orthogonal and canonical, but virtuals belonging to different pair domains; may not be orthogonal.; The following expression is used to evaluate the energy of a given set of amplitudes:. (3)¶\[\begin{split}E^{(2)} &= \sum_{i,j} e_{ij}, \\; e_{ij} &= \sum_{a, b}((ia|jb) + R_{ij}^{ab})(2t_{ij}^{ab} - t_{ij}^{ba}).\end{split}\]; The error in \(E^{(2)}\) scales quadratically with the error in the amplitudes.; No local approximations have been made so far, and this iterative approach can; be used to exactly determine \(E^{(2)}\) with \({\cal O}(N^5)\) cost.; In DLPNO-MP2, the first local approximation is to screen distant, non-interacting; orbital pairs ij. Orbital pairs are screened if below both an overlap criteria:. (4)¶\[DOI_{ij} \equiv \sqrt{\int d\mathbf{r} | \chi_{i}(\mathbf{r}) | ^{2} | \chi_{j}(\mathbf{r}) | ^{2}},\]; and a pair energy estimate:. (5)¶\[e_{ij}^{approx} = -\frac{4}{R^{6}} \sum_{a_{i} \in [i],b_{j} \in [j]} \frac{ (2 \langle i | \mathbf{r} | a_{i} \rangle \langle j | \mathbf{r} | b_{j} \rangle)^{2}}{\epsilon_{a_{i}} + \epsilon_{b_{j}} - f_{ii} - f_{jj}},\]; in which small domains of virtual orbitals are used for each local MO. As a; result, an asymptotically linear number of ij pairs enter the local MP2; equations, and the approximate pair energy of neglected pairs is added to; the final energy.; The second major local approximation in DLPNO-MP2 is the truncation of the virtual; space. Initially, exchange integrals are calculated in the LMO/PAO basis using the; standard density fitting approach:. (6)¶\[(ia|jb) = \sum_{K,L \in [ij]} (ia|K)[\mathbf{J}^{-1}]_{KL}(L|jb)\]; This is done with linear scaling effort by exploiting the locality of the LMOs, PAOs,; and auxiliary basis functions.; Solving the iterative local MP2 equations in the LMO/PAO bas",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/dlpnomp2-1.html:4866,energy,energy,4866,psi4manual/1.5.0/dlpnomp2-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/dlpnomp2-1.html,7,['energy'],['energy']
Energy Efficiency," pair domains. Type: string; Default: NONE. LOCAL_PAIRDEF (CCSORT); CCSORT — Definition of local pair domains, unique avaliable option is BP, Boughton-Pulay. Type: string; Default: BP. LOCAL_PRECONDITIONER (CCEOM); CCEOM — Preconditioner will be used in local CC computations. Type: string; Possible Values: HBAR, FOCK; Default: HBAR. LOCAL_WEAKP (CCENERGY); CCENERGY — Desired treatment of “weak pairs” in the local-CCSD method. A value of NEGLECT ignores weak pairs entirely. A value of NONE treats weak pairs in the same manner as strong pairs. A value of MP2 uses second-order perturbation theory to correct the local-CCSD energy computed with weak pairs ignored. Type: string; Possible Values: NONE, NEGLECT, MP2; Default: NONE. LOCAL_WEAKP (CCEOM); CCEOM — Desired treatment of “weak pairs” in the local-CCSD method. A value of NEGLECT ignores weak pairs entirely. A value of NONE treats weak pairs in the same manner as strong pairs. A value of MP2 uses second-order perturbation theory to correct the local-CCSD energy computed with weak pairs ignored. Type: string; Possible Values: NONE, MP2, NEGLECT; Default: NONE. LOCAL_WEAKP (CCLAMBDA); CCLAMBDA — Desired treatment of “weak pairs” in the local-CCSD method. The value of NONE (unique avaliable option) treats weak pairs in the same manner as strong pairs. Type: string; Default: NONE. LOCAL_WEAKP (CCRESPONSE); CCRESPONSE — Desired treatment of “weak pairs” in the local-CCSD method. The value of NONE (unique avaliable option) treats weak pairs in the same manner as strong pairs. Type: string; Default: NONE. LOCAL_WEAKP (CCSORT); CCSORT — Desired treatment of “weak pairs” in the local-CCSD method. The value of NONE (unique avaliable option) treats weak pairs in the same manner as strong pairs. Type: string; Default: NONE. LOCAL_WEAKP (CIS); CIS — Desired treatment of “weak pairs” in the local-CIS method. A value of NEGLECT ignores weak pairs entirely. A value of NONE treats weak pairs in the same manner as strong pairs. A val",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html:67492,energy,energy,67492,psi4manual/4.0b3/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html,4,['energy'],['energy']
Energy Efficiency," pairs. Type: string; Default: NONE. LOCAL_WEAKP (CIS); CIS — Desired treatment of “weak pairs” in the local-CIS method. A value of NEGLECT ignores weak pairs entirely. A value of NONE treats weak pairs in the same manner as strong pairs. A value of MP2 uses second-order perturbation theory to correct the local-CIS energy computed with weak pairs ignored. Type: string; Possible Values: MP2, NEGLECT, NONE; Default: MP2. LOCK_OCC (DCFT); DCFT (Expert) — Controls whether to force the occupation to be that of the SCF guess. For practical applications only the default must be used. Type: boolean; Default: true. LOCK_SINGLET (PSIMRCC); PSIMRCC — Do lock onto a singlet root?. Type: boolean; Default: false. LSE (DETCI); DETCI — Do use least-squares extrapolation in iterative solution of CI vector?. Type: boolean; Default: false. LSE_COLLAPSE (DETCI); DETCI — Number of iterations between least-squares extrapolations. Type: integer; Default: 3. LSE_TOLERANCE (DETCI); DETCI — Minimum converged energy for least-squares extrapolation to be performed. Type: conv double; Default: 3. M_FILE (TRANSQT); TRANSQT — Output integrals file. Type: integer; Default: 0. MADMP2_SLEEP (DFMP2); DFMP2 (Expert) — A helpful option, used only in debugging the MADNESS version. Type: integer; Default: 0. MAT_NUM_COLUMN_PRINT (GLOBALS); GLOBALS (Expert) — Number of columns to print in calls to Matrix::print_mat. Type: integer; Default: 5. MAX_BUCKETS (TRANSQT); TRANSQT — Maximum buckets. Type: integer; Default: 499. MAX_CCD_DIISVECS (SAPT); SAPT — Maximum number of vectors used in CCD-DIIS. Type: integer; Default: 10. MAX_DISP_G_CONVERGENCE (OPTKING); OPTKING — Convergence criterion for geometry optmization: maximum displacement (internal coordinates, atomic units). Type: conv double; Default: 1.2e-3. MAX_ENERGY_G_CONVERGENCE (OPTKING); OPTKING — Convergence criterion for geometry optmization: maximum energy change. Type: conv double; Default: 1.0e-6. MAX_FORCE_G_CONVERGENCE (OPTKING); OPTKING — Conver",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_glossary_options_c-1.html:73491,energy,energy,73491,psi4manual/4.0b4/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_glossary_options_c-1.html,2,['energy'],['energy']
Energy Efficiency," pairs. Type: string; Default: NONE. LOCAL_WEAKP (CIS); CIS — Desired treatment of “weak pairs” in the local-CIS method. A value of NEGLECT ignores weak pairs entirely. A value of NONE treats weak pairs in the same manner as strong pairs. A value of MP2 uses second-order perturbation theory to correct the local-CIS energy computed with weak pairs ignored. Type: string; Possible Values: MP2, NEGLECT, NONE; Default: MP2. LOCK_OCC (DCFT); DCFT (Expert) — Controls whether to force the occupation to be that of the SCF guess. For practical applications only the default must be used. Type: boolean; Default: true. LOCK_SINGLET (PSIMRCC); PSIMRCC — Do lock onto a singlet root?. Type: boolean; Default: false. LSE (DETCI); DETCI — Do use least-squares extrapolation in iterative solution of CI vector?. Type: boolean; Default: false. LSE_COLLAPSE (DETCI); DETCI — Number of iterations between least-squares extrapolations. Type: integer; Default: 3. LSE_TOLERANCE (DETCI); DETCI — Minimum converged energy for least-squares extrapolation to be performed. Type: conv double; Default: 3. M_FILE (TRANSQT); TRANSQT — Output integrals file. Type: integer; Default: 0. MADMP2_SLEEP (DFMP2); DFMP2 (Expert) — A helpful option, used only in debugging the MADNESS version. Type: integer; Default: 0. MAT_NUM_COLUMN_PRINT (GLOBALS); GLOBALS (Expert) — Number of columns to print in calls to Matrix::print_mat. Type: integer; Default: 5. MAX_BUCKETS (TRANSQT); TRANSQT — Maximum buckets. Type: integer; Default: 499. MAX_DISP_G_CONVERGENCE (OPTKING); OPTKING — Convergence criterion for geometry optmization: maximum displacement (internal coordinates, atomic units). Type: conv double; Default: 1.2e-3. MAX_ENERGY_G_CONVERGENCE (OPTKING); OPTKING — Convergence criterion for geometry optmization: maximum energy change. Type: conv double; Default: 1.0e-6. MAX_FORCE_G_CONVERGENCE (OPTKING); OPTKING — Convergence criterion for geometry optmization: maximum force (internal coordinates, atomic units). Type: conv",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html:69226,energy,energy,69226,psi4manual/4.0b3/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html,2,['energy'],['energy']
Energy Efficiency," part of the core space.; Other keywords and examples.; Apart from the mentioned keywords, the following are common:. REFERENCE¶. Reference wavefunction type. Type: string; Possible Values: RHF, UHF; Default: RHF. R_CONVERGENCE¶. Convergence threshold for ADC matrix diagonalisation. Negative values keep the * adcc default (1e-6). Type: conv double; Default: -1. NUM_GUESSES¶. Number of guess vectors to generate and use. Negative values keep * the adcc default (currently 2 * ROOTS_PER_IRREP). This option is only available for the adcc backend. Type: integer; Default: -1. CUTOFF_AMPS_PRINT¶. Tolerance for extracted or printed amplitudes. This option is only available for the adcc backend. Type: double; Default: 0.01. The full list is provided in appendix ADC; and many more sample input files can be found in the adc and adcc; subfolders of psi4/samples.; Note, that not all keywords are supported by all backends.; Switching between ADC backends.; Psi4 currently defaults to the built-in implementation for all ADC(2) energy calculations.; You can explicitly set the QC_MODULE option to 'adcc'; enforce using adcc also for this case. Interface to adcc¶; Code author: Michael F. Herbst; Section author: Michael F. Herbst; For most implemented ADC methods PSI4 relies; on an interface to the adcc python package.; The approach of adcc is to directly diagonalise the; ADC matrix \(\mathbf{A}\) in an iterative diagonalisation; procedure, usually a Jacobi-preconditioned Davidson. Expensive parts; of the ADC matrix-vector product are precomputed and stored; in memory. This approach is general in the sense; that it can be applied to a large range of ADC methods and variants.; So far levels up to ADC(3) and CVS-ADC(3) are available; and additional approximations such as; FREEZE_CORE and NUM_FROZEN_UOCC; are supported with all ADC methods using the adcc backend.; Currently adcc is only capable of performing in-core calculations,; for which, however, permutational symmetry and spin symmetry",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/adc-1.html:8541,energy,energy,8541,psi4manual/1.4.0/adc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/adc-1.html,5,['energy'],['energy']
Energy Efficiency," partially; converged orbital which should be occupied in the fully-optimized SCF solution; has a slightly higher orbital eigenvalue than some other orbital which should be; destined to be a virtual orbital. This results in the virtual orbital being; spuriously occupied for one or more iterations. Sometimes this resolves itself; without help, other times the occupation flips back and forth between two, four,; or more orbitals. This is typically visible in the output as a non-converging; SCF which eventually settles down to steady oscillation between two (or more); different total energies. This behavior can be ameliorated by choosing occupied; orbitals by “shape” instead of by orbital eigenvalue, i.e., by choosing the set; of new orbitals which looks most like some previously known “good” set. The; “good” set is typically the occupied orbitals from an one of the oscillating; iterations with the lowest total energy. For an oscillating system where the; lowest total energy occurs on iterations , invoking; MOM_START can often rescue the convergence of the SCF. MOM can; be used in concert with DIIS, though care should be taken to not turn MOM on; until the oscillatory behavior begins.; Damping [Off by Default]; In some cases, a static mixing of Fock Matrices from adjacent iterations can; quench oscillations. This mixing, known as “damping” can be activated by setting; the DAMPING_PERCENTAGE keyword to a nonzero percent. ERI Algorithms¶; The key difficulty in the SCF procedure is treatment of the four-index ERI; contributions to the Fock Matrix. A number of algorithms are available in; PSI4 for these terms. The algorithm is selected by the SCF_TYPE; keyword, which may be one of the following. PK [Default]; An in-core, presorted algorithm using exact ERIs. Quite fast; for a zero-error algorithm if enough memory is available. Integrals are; generated only once, and symmetry is utilized to reduce number of integrals.; OUT_OF_CORE; An out-of-core, unsorted algorithm using exa",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/scf-1.html:16305,energy,energy,16305,psi4manual/4.0b2/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf-1.html,4,['energy'],['energy']
Energy Efficiency," partially; converged orbital which should be occupied in the fully-optimized SCF solution; has a slightly higher orbital eigenvalue than some other orbital which should be; destined to be a virtual orbital. This results in the virtual orbital being; spuriously occupied for one or more iterations. Sometimes this resolves itself; without help, other times the occupation flips back and forth between two, four,; or more orbitals. This is typically visible in the output as a non-converging; SCF which eventually settles down to steady oscillation between two (or more); different total energies. This behavior can be ameliorated by choosing occupied; orbitals by “shape” instead of by orbital eigenvalue, i.e., by choosing the set; of new orbitals which looks most like some previously known “good” set. The; “good” set is typically the occupied orbitals from an one of the oscillating; iterations with the lowest total energy. For an oscillating system where the; lowest total energy occurs on iterations , invoking; MOM_START can often rescue the convergence of the SCF. MOM can; be used in concert with DIIS, though care should be taken to not turn MOM on; until the oscillatory behavior begins.; Damping [Off by Default]; In some cases, a static mixing of Fock Matrices from adjacent iterations can; quench oscillations. This mixing, known as “damping” can be activated by setting; the DAMPING_PERCENTAGE keyword to a nonzero percent. ERI Algorithms¶; The key difficulty in the SCF procedure is treatment of the four-index ERI; contributions to the Fock Matrix. A number of algorithms are available in; PSI4 for these terms. The algorithm is selected by the SCF_TYPE; keyword, which may be one of the following. PK [Default]; An out-of-core, presorted algorithm using exact ERIs. Quite fast for a; zero-error algorithm if enough memory is available. Integrals are; generated only once, and symmetry is utilized to reduce number of; integrals.; OUT_OF_CORE; An out-of-core, unsorted algorithm usin",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/scf-1.html:17882,energy,energy,17882,psi4manual/4.0b5/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/scf-1.html,2,['energy'],['energy']
Energy Efficiency," partially; converged orbital which should be occupied in the fully-optimized SCF solution; has a slightly higher orbital eigenvalue than some other orbital which should be; destined to be a virtual orbital. This results in the virtual orbital being; spuriously occupied for one or more iterations. Sometimes this resolves itself; without help, other times the occupation flips back and forth between two, four,; or more orbitals. This is typically visible in the output as a non-converging; SCF which eventually settles down to steady oscillation between two (or more); different total energies. This behavior can be ameliorated by choosing occupied; orbitals by “shape” instead of by orbital eigenvalue, i.e., by choosing the set; of new orbitals which looks most like some previously known “good” set. The; “good” set is typically the occupied orbitals from an one of the oscillating; iterations with the lowest total energy. For an oscillating system where the; lowest total energy occurs on iterations , invoking; MOM_START can often rescue the convergence of the SCF. MOM can; be used in concert with DIIS, though care should be taken to not turn MOM on; until the oscillatory behavior begins.; Damping [Off by Default]; In some cases, a static mixing of Fock Matrices from adjacent iterations can; quench oscillations. This mixing, known as “damping” can be activated by setting; the DAMPING_PERCENTAGE keyword to a nonzero percent. ERI Algorithms¶; The key difficulty in the SCF procedure is treatment of the four-index ERI; contributions to the Fock Matrix. A number of algorithms are available in; PSI4 for these terms. The algorithm is selected by the SCF_TYPE; keyword, which may be one of the following. PK [Default]; An out-of-core, presorted algorithm using exact ERIs. Quite fast; for a zero-error algorithm if enough memory is available. Integrals are; generated only once, and symmetry is utilized to reduce number of integrals.; OUT_OF_CORE; An out-of-core, unsorted algorithm using",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/scf-1.html:17882,energy,energy,17882,psi4manual/4.0b4/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/scf-1.html,2,['energy'],['energy']
Energy Efficiency," partially; converged orbital which should be occupied in the fully-optimized SCF solution; has a slightly higher orbital eigenvalue than some other orbital which should be; destined to be a virtual orbital. This results in the virtual orbital being; spuriously occupied for one or more iterations. Sometimes this resolves itself; without help, other times the occupation flips back and forth between two, four,; or more orbitals. This is typically visible in the output as a non-converging; SCF which eventually settles down to steady oscillation between two (or more); different total energies. This behavior can be ameliorated by choosing occupied; orbitals by “shape” instead of by orbital eigenvalue, i.e., by choosing the set; of new orbitals which looks most like some previously known “good” set. The; “good” set is typically the occupied orbitals from an one of the oscillating; iterations with the lowest total energy. For an oscillating system where the; lowest total energy occurs on iterations , invoking; MOM_START can often rescue the convergence of the SCF. MOM can; be used in concert with DIIS, though care should be taken to not turn MOM on; until the oscillatory behavior begins.; Damping [Off by Default]; In some cases, a static mixing of Fock Matrices from adjacent iterations can; quench oscillations. This mixing, known as “damping” can be activated by setting; the DAMPING_PERCENTAGE keyword to a nonzero percent. ERI Algorithms¶; The key difficulty in the SCF procedure is treatment of the four-index ERI; contributions to the Fock Matrix. A number of algorithms are available in; Psi4 for these terms. The algorithm is selected by the SCF_TYPE; keyword, which may be one of the following. PK [Default]; An out-of-core, presorted algorithm using exact ERIs. Quite fast for a; zero-error algorithm if enough memory is available. Integrals are; generated only once, and symmetry is utilized to reduce number of; integrals.; OUT_OF_CORE; An out-of-core, unsorted algorithm usin",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/scf-1.html:17813,energy,energy,17813,psi4manual/1.0.0/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/scf-1.html,2,['energy'],['energy']
Energy Efficiency," particles are added to this; object before the SCF code is told about its existence on the last line. The; calls to addCharge take the atomic charge, x coordinate, y coordinate, and; z coordinate in that order. The atomic charge is specified in atomic units,; and the coordinates always use the same units as the geometry specification in; the regular QM region. Additional MM molecules may be specified by adding; extra calls to addCharge to describe the full MM region. Convergence and Algorithm Defaults¶. SCF algorithm and convergence criteria defaults by calculation type [1]¶. Ab Initio Method; Calculation Type; E_CONVERGENCE; D_CONVERGENCE; SCF_TYPE. SCF of HF or DFT; energy; 6; 6; DF. optimization; 8; 8. frequency [7]; 8; 8. SCF of post-HF; energy; 8; 8; PK [3]. optimization; 10; 10. frequency [7]; 10; 10. CC property [2]; 10; 10. Post-SCF convergence criteria defaults by calculation type [4]¶. Ab Initio Method; Calculation Type; E_CONVERGENCE [5]; R_CONVERGENCE [6]. post-HF of post-HF; energy; 6;  . optimization; 8;  . frequency [7]; 8;  . CC property [2]; 8;  . Footnotes. [1]Note that this table applies only the SCF module,; not to the final convergence criteria for post-HF methods or to methods; that use an alternate starting point, like MCSCF. SAPT computations, too,; set tighter values. [2](1, 2) This applies to properties computed through the property() function. [3]Post-HF methods that do not rely upon the usual 4-index AO integrals use a density-; fitted SCF reference. That is, for DF-MP2 and SAPT, the default SCF_TYPE is DF. [4]Note that this table applies to the final convergence criteria for; all the post-SCF modules that define a E_CONVERGENCE keyword. [5]The E_CONVERGENCE keyword is implemented for most post-SCF modules.; See a list beginning at E_CONVERGENCE. [6]The R_CONVERGENCE keyword places a convergence check on an internal; residual error measure and is implemented for several post-SCF; modules (see list beginning at R_CONVERGENCE). It is defin",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/scf-1.html:30902,energy,energy,30902,psi4manual/1.0.0/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/scf-1.html,2,['energy'],['energy']
Energy Efficiency," pattern, basis sets, charge, multiplicity, etc. of a molecule.; Methods Summary. B787(ref_mol[, do_plot, verbose, atoms_map, …]); Finds shift, rotation, and atom reordering of concern_mol that best aligns with ref_mol. BFS([seed_atoms, bond_threshold, …]); Detect fragments among real atoms through a breadth-first search (BFS) algorithm. Z(self, arg0); Nuclear charge of atom. activate_all_fragments(self); Sets all fragments in the molecule to be active. add_atom(self, arg0, arg1, arg2, arg3, arg4, …); Adds to Molecule arg1 an atom with atomic number arg2, Cartesian coordinates in Bohr (arg3, arg4, arg5), atomic symbol arg6, mass arg7, charge arg8 (optional), and lineno arg9 (optional). atom_at_position(self, arg0, arg1); Tests to see if an atom is at the position arg2 with a given tolerance arg3. basis_on_atom(self, arg0); Gets the label of the orbital basis set on a given atom. center_of_mass(self); Computes center of mass of molecule (does not translate molecule). charge(self, arg0); Gets charge of atom. clone(self); Returns a new Molecule identical to arg1. com_fixed(self); Get whether or not COM is fixed. create_molecule_from_string(arg0); Returns a new Molecule with member data from the geometry string arg1 in psi4 format. create_psi4_string_from_molecule(self); Gets a string reexpressing in input format the current states of the molecule. deactivate_all_fragments(self); Sets all fragments in the molecule to be inactive. distance_matrix(self); Returns Matrix of interatom distances. extract_subsets(*args, **kwargs); Overloaded function. fZ(self, arg0); Nuclear charge of atom arg1 (0-indexed including dummies). find_point_group(self, arg0); Finds computational molecular point group, user can override this with the symmetry keyword. fix_com(self, arg0); Whether to fix the Cartesian position, or to translate to the C.O.M. fix_orientation(self, arg0); Fix the orientation at its current frame. form_symmetry_information(self, arg0); Uses the point group object obtain b",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/api/psi4.core.molecule.html:1233,charge,charge,1233,psi4manual/1.2.1/api/psi4.core.molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/api/psi4.core.molecule.html,2,['charge'],['charge']
Energy Efficiency," performs a simultaneous update of orbitals and cumulants, using DIIS extrapolation. Four-virtual integrals are handled in the AO basis, where integral transformation is avoided. In the next RHF-ODC-12 computation, AO_BASIS=NONE is used, where four-virtual integrals are transformed into MO basis. tdscf-4; td-wb97x singlet excitation energies of methylene (tda). opt12; SCF cc-pVDZ geometry optimzation of ketene, starting from bent structure. pywrap-checkrun-convcrit; Advanced python example sets different sets of scf/post-scf conv crit and check to be sure computation has actually converged to the expected accuracy. dfremp-2; density fitted REMP/cc-pVDZ energies for the CH3 radical. opt1; SCF STO-3G geometry optimzation, with Z-matrix input. sapt-ecp; sapt0 of charged system in ECP basis set. cc41; RHF-CC2-LR/cc-pVDZ optical rotation of H2O2. gauge = both, omega = (589 355 nm). cbs-xtpl-energy; Extrapolated water energies - density-fitted version. sapt-dft-api; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. sapt-dft-lrc; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. cc2; 6-31G** H2O CCSD optimization by energies, with Z-Matrix input. cc27; Single point gradient of 1-1B2 state of H2O with EOM-CCSD. mp3-grad2; MP3 cc-pVDZ gradient for the NO radical. cc28; CCSD/cc-pVDZ optical rotation calculation (length gauge only) on Z-mat H2O2. dfccsdat2; DF-A-CCSD(T) cc-pVDZ energy for the NH molecule. props4; Electrostatic potential and electric field evaluated on a grid around water. dfccsdat1; DF-CCSD(AT) cc-pVDZ energy for the H2O molecule. dfmp2-2; Density fitted MP2 energy of H2, using density fitted reference and automatic looping over cc-pVDZ and cc-pVTZ basis sets. Results are tabulated using the built in table functions by using the default options and by specifiying the format. dfomp3-grad1; DF-OMP3 cc-pVDZ gradients for the H2O molecule. dfccd-grad1; DF-CCSD cc-pVDZ gradients for the H2O molecule. omp2-4; SCS-OMP2 cc-pVDZ geometry",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html:25613,energy,energy,25613,psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency," performs a simultaneous update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the MO Basis. opt-freeze-coords; SCF/cc-pVDZ optimization example with frozen cartesian. scf-level-shift-rks; SCF level shift on an RKS computation. cc1; RHF-CCSD 6-31G** all-electron optimization of the H2O molecule. cc36; CC2(RHF)/cc-pVDZ energy of H2O. tu6-cp-ne2; Example potential energy surface scan and CP-correction for Ne2. fnocc3; Test FNO-QCISD(T) computation. frac-sym; Fractional occupation with symmetry. tdscf-7; TD-HF test variable access. cisd-h2o+-1; 6-31G** H2O+ Test CISD Energy Point. nbody-multi-level; Multilevel computation of water trimer energy (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). dft-grad-lr2; Tests CAM gradients with and without XC pieces to narrow grid error. dfcasscf-sa-sp; Example of state-averaged CASSCF for the C2 molecule. dft1-alt; DFT Functional Test. cc16; ROHF and UHF-B-CCD(T)/cc-pVDZ \(^{3}B_1\) CH2 single-point energy (fzc, MO-basis \(\langle ab|cd \rangle\) ). scf-upcast-custom-basis; test scf castup with custom basis sets. mints4; A demonstration of mixed Cartesian/ZMatrix geometry specification, using variables, for the benzene-hydronium complex. Atoms can be placed using ZMatrix coordinates, whether they belong to the same fragment or not. Note that the Cartesian specification must come before the ZMatrix entries because the former define absolute positions, while the latter are relative. dfmp2-3; DF-MP2 cc-pVDZ frozen core gradient of benzene, computed at the DF-SCF cc-pVDZ geometry. dfomp2p5-1; DF-OMP2.5 cc-pVDZ energy for the H2O molecule. cc31; CCSD/sto-3g optical rotation calculation (both gauges) at two frequencies on methyloxirane. mints3; Test individual integral objects for correctness. dft-custom; DFT custom functional test. lccd-grad1; LCCD cc-pVDZ gradient for the H2O molecule. cc34; RHF-CCSD/cc-pVDZ energy of H2O partitioned into pair energy contributions. dfmp2-freq1",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html:22571,energy,energy,22571,psi4manual/master/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency," permutational symmetry and spin symmetry is taken; into account for both tensor computations and tensor storage.; Inside adcc some heuristic checks for overly excessive memory requirements; are implemented, resulting in a warning in case a; successful execution is unlikely. There are no guarantees for the memory; to be sufficient in case such a warning is not displayed.; More detailed documentation about adcc and its features can be found; at https://adc-connect.org,; especially the theory section.; If you are using adcc from PSI4 for your calculations,; please cite both PSI4 as well as adcc [Herbst2020]; in your published work.; The ADC wavefunction object.; After running the ADC calculation in adcc, the interface code sets; a number of variables in the returned Wavefunction; in case they are computed.; In the following the <method> prefix refers to the ADC method (such as adc(1),; adc(3), cvs-adc(2)-x). Ground state energy terms like MP2 correlation energy, MP3 correlation energy,; MP2 total energy, MP3 total energy, current correlation energy and current energy.; MP2 dipole X and the other components: Ground state dipole moments at MP(2) level.; number of iterations: The number of iterations the iterative solver required to converge.; number of excited states: The number of excited states, which were computed.; More variables are summarized in PSI Variables by Alpha. The following attribute is set on returned wavefunctions:. adcc_state: The adcc.ExcitedStates; object used by adcc to store the ADC(n) excitation energies and all precomputed data; in the format used by adcc.; Provides direct access to analysis and plotting capabilities from adcc.; For example adcc_state.plot_spectrum() plots a broadened excited states spectrum; in matplotlib. See the adcc calculations documentation; for details. Tips for convergence issues.; If you encounter convergence issues inside adcc, the following parameters; are worth tweaking:. MAX_NUM_VECS: Specifies the maximal number of s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/adc.html:10580,energy,energy,10580,psi4manual/1.6.x/adc.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/adc.html,35,['energy'],['energy']
Energy Efficiency," petite_list; petite_list(...) unbound psi4.SOBasisSet method. petite_list( (SOBasisSet)arg1) -> PetiteList :. docstring; C++ signature :. N5boost10shared_ptrIN3psi10PetiteListEEE petite_list(N3psi10SOBasisSetE {lvalue}). SuperFunctional¶. psi4.SuperFunctional.add_c_functional()¶; Python Library Documentation: method add_c_functional; add_c_functional(...) unbound psi4.SuperFunctional method. add_c_functional( (SuperFunctional)arg1, (Functional)arg2) -> None :. docstring; C++ signature :. void add_c_functional(N3psi15SuperFunctionalE {lvalue},N5boost10shared_ptrIN3psi10FunctionalEEE). psi4.SuperFunctional.add_x_functional()¶; Python Library Documentation: method add_x_functional; add_x_functional(...) unbound psi4.SuperFunctional method. add_x_functional( (SuperFunctional)arg1, (Functional)arg2) -> None :. docstring; C++ signature :. void add_x_functional(N3psi15SuperFunctionalE {lvalue},N5boost10shared_ptrIN3psi10FunctionalEEE). psi4.SuperFunctional.allocate()¶; Python Library Documentation: method allocate; allocate(...) unbound psi4.SuperFunctional method. allocate( (SuperFunctional)arg1) -> None :. docstring; C++ signature :. void allocate(N3psi15SuperFunctionalE {lvalue}). psi4.SuperFunctional.ansatz()¶; Python Library Documentation: method ansatz; ansatz(...) unbound psi4.SuperFunctional method. ansatz( (SuperFunctional)arg1) -> int :. docstring; C++ signature :. i ansatz(N3psi15SuperFunctionalE {lvalue}). psi4.SuperFunctional.blank()¶; Python Library Documentation: built-in function blank; blank(...). blank() -> SuperFunctional :. docstring; C++ signature :. N5boost10shared_ptrIN3psi15SuperFunctionalEEE blank(). psi4.SuperFunctional.build()¶; Python Library Documentation: built-in function build; build(...). build( (str)arg1, (int)arg2, (int)arg3) -> SuperFunctional :. docstring; C++ signature :. N5boost10shared_ptrIN3psi15SuperFunctionalEEE build(Ss,i,i). psi4.SuperFunctional.c_alpha()¶; Python Library Documentation: method c_alpha; c_alpha(...) unbound psi4",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:329531,allocate,allocate,329531,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,6,['allocate'],['allocate']
Energy Efficiency," phenylacetylene, starting from not quite linear structure updated reference due to new BraggSlater radii. cisd-h2o-clpse; 6-31G** H2O Test CISD Energy Point with subspace collapse. mbis-3; MBIS calculation on OH radical. props1; RHF STO-3G dipole moment computation, performed by applying a finite electric field and numerical differentiation. fnocc4; Test FNO-DF-CCSD(T) energy. cc42; RHF-CC2-LR/STO-3G optical rotation of (S)-methyloxirane. gauge = length, omega = (589 355 nm). cbs-xtpl-energy; Extrapolated water energies. cc8; UHF-CCSD(T) cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Z-matrix input. dft-dsd; DSD S22 Ammonia test. fsapt2; A very quick correctness test of F-SAPT (see fsapt1 for a real example). dft-dens-cut; LibXC density screening test. Tests empty, C-only, X-only and XC superfunctionals. ‘super_mix’ showcases how to use different screening values for X and C parts. SCF will fail or crash (nans) without screening!. casscf-fzc-sp; CASSCF/6-31G** energy point. isapt1; This test case shows an example of running and analyzing an FI-SAPT0/jun-cc-pvdz computation for 2,4-pentanediol (targeting the intramolecular hydrogen bond between the two hydroxyl groups). pywrap-align-chiral; testing aligner on enantiomers based on Table 1 of 10.1021/ci100219f aka J Chem Inf Model 2010 50(12) 2129-2140. cisd-sp; 6-31G** H2O Test CISD Energy Point. dft-grad-lr2; Tests CAM gradients with and without XC pieces to narrow grid error. dfccsd1; DF-CCSD cc-pVDZ energy for the H2O molecule. adc1; ADC(2)/6-31G** on H2O using builtin ADC module. cc5; RHF CCSD(T) aug-cc-pvtz frozen-core energy of C4NH4 Anion. scf-uhf-grad-nobeta; UHF gradient for a one-electron system (no beta electrons). cc24; Single point gradient of 1-2B1 state of H2O+ with EOM-CCSD. cc46; EOM-CC2/cc-pVDZ on H2O2 with two excited states in each irrep. dfccdl1; DF-CCDL cc-pVDZ energy for the H2O molecule. omp2-5; SOS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. dft-g",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html:9054,energy,energy,9054,psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency," plane of the molecule. pubchem1; Benzene vertical singlet-triplet energy difference computation, using the PubChem database to obtain the initial geometry, which is optimized at the HF/STO-3G level, before computing single point energies at the RHF, UHF and ROHF levels of theory. mints6; Patch of a glycine with a methyl group, to make alanine, then DF-SCF energy calculation with the cc-pVDZ basis set. dft-custom-dhdf; DSD-PBEP86 S22 Ammonia test. cc41; RHF-CC2-LR/cc-pVDZ optical rotation of H2O2. gauge = both, omega = (589 355 nm). mpn-bh; MP(n)/aug-cc-pVDZ BH Energy Point, with n=2-19. Compare against M. L. Leininger et al., J. Chem. Phys. 112, 9213 (2000). omp3-grad1; OMP3 cc-pVDZ gradient for the H2O molecule. cbs-delta-energy; Extrapolated energies with delta correction. dfomp2-1; OMP2 cc-pVDZ energy for the H2O molecule. cbs-xtpl-nbody; RHF interaction energies using nbody and cbs parts of the driver Ne dimer with mp2/v[dt]z + d:ccsd(t)/vdz. cc10; ROHF-CCSD cc-pVDZ energy for the \(^2\Sigma^+\) state of the CN radical. dfmp2-freq2; DF-MP2 frequency by difference of energies for H2O. cc1; RHF-CCSD 6-31G** all-electron optimization of the H2O molecule. omp3-grad2; OMP3 cc-pVDZ gradient for the NO radical. cdomp2-2; OMP2 cc-pVDZ energy for the NO molecule. fd-freq-energy-large; SCF DZ finite difference frequencies by energies for C4NH4. dct11; Restricted DF-DCT ODC-12 energies with linearly dependent basis functions. opt-freeze-coords; SCF/cc-pVDZ optimization example with frozen cartesian. scf1; RHF cc-pVQZ energy for the BH molecule, with Cartesian input. mints15; check SP basis Fortran exponent parsing. dct4; DCT calculation for the HF+ using DC-06 functional. This performs both two-step and simultaneous update of the orbitals and cumulant using DIIS extrapolation. Four-virtual integrals are first handled in the MO Basis for the first two energy computations. In the next two the ao_basis=disk algorithm is used, where the transformation of integrals for four-vir",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html:8888,energy,energy,8888,psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency," plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). inputalt.dat — Sample input file for the plugin (new style).; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation and Available Plugins; for this file’s final destination. To create a purely Python plugin, create a new plugin directory, then; remove the Makefile, myplugin.cc, and input.dat files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; inputalt.da",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/plugins-1.html:6694,energy,energy,6694,psi4manual/4.0b2/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins-1.html,4,['energy'],['energy']
Energy Efficiency," point gradient of 1-2B2 state of H2O+ with EOM-CCSD. opt-freeze-coords; SCF/cc-pVDZ optimization example with frozen cartesian. sapt0-d; Tests SAPT0-D corrections, with a variety of damping functions/parameters. omp2-1; OMP2 cc-pVDZ energy for the H2O molecule. tu1-h2o-energy; Sample HF/cc-pVDZ H2O computation. opt-multi-frozen-dimer-c2h; Frozen-fragment opt of C2h methane dimer with user-combined reference points. dct1; DC-06, DC-12, ODC-06 and ODC-12 calculation for the He dimer. This performs a simultaneous update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the MO Basis. cc16; ROHF and UHF-B-CCD(T)/cc-pVDZ \(^{3}B_1\) CH2 single-point energy (fzc, MO-basis \(\langle ab|cd \rangle\) ). x2c3; Test of SFX2C-1e on Water uncontracted cc-pVDZ The reference numbers are from Lan Cheng’s implementation in Cfour. mp2-h; check that methods can act on single atom. sapt3; SAPT2+3(CCD) aug-cc-pVDZ+midbond computation of the water dimer interaction energy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. fci-dipole; 6-31G H2O Test FCI Energy Point. dfomp2p5-1; DF-OMP2.5 cc-pVDZ energy for the H2O molecule. sapt-dft-api; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. cbs-xtpl-wrapper; RHF aug-cc-pVQZ energy for the BH molecule, with Cartesian input. Various gradients for a strained helium dimer and water molecule. cc53; Matches Table II a-CCSD(T)/cc-pVDZ H2O @ 2.5 * Re value from Crawford and Stanton, IJQC 98, 601-611 (1998). opt-multi-dimer-c1; Multi-fragment opt of C2h methane dimer with user-combined reference points. olccd-freq1; OLCCD cc-pVDZ freqs for C2H2. cc6; Frozen-core CCSD(T)/cc-pVDZ on C4H4N anion with disk ao algorithm. rasci-h2o; RASCI/6-31G** H2O Energy Point. dfomp2-grad3; Tests OMP2 gradient in the presence of a dipole field. extern2; External potential calculation involving a TIP3P water and a QM water for DFMP2. Finite different test of the gradient is performed to v",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html:18925,energy,energy,18925,psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency," point. CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. dfmp2-3; DF-MP2 cc-pVDZ frozen core gradient of benzene, computed at the DF-SCF cc-pVDZ geometry. mcscf1; ROHF 6-31G** energy of the state of CH2, with Z-matrix input. The occupations are specified explicitly. ci-multi; BH single points, checking that program can run multiple instances of DETCI in a single input, without an intervening clean() call. sapt5; SAPT0 aug-cc-pVTZ computation of the charge transfer energy of the water dimer. adc2; ADC/aug-cc-pVDZ on two water molecules that are distant from 1000 angstroms from each other. cc40; RHF-CC2-LR/cc-pVDZ optical rotation of H2O2. gauge = length, omega = (589 355 nm). dcft2; DC-06 calculation for the He dimer. This performs a two-step update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the MO Basis. cc32; CC3/cc-pVDZ H2O geom from Olsen et al., JCP 104, 8007 (1996). tu1-h2o-energy; Sample HF/cc-pVDZ H2O computation. dcft4; DCFT calculation for the HF+ using DC-06 functional. This performs both two-step and simultaneous update of the orbitals and cumulant using DIIS extrapolation. Four-virtual integrals are first handled in the MO Basis for the first two energy computations. In the next two the ao_basis=disk algorithm is used, where the transformation of integrals for four-virtual case is avoided. The computation is then repeated using the DC-12 functional with the same algorithms. pywrap-db3; Test that Python Molecule class processes geometry like PsiMod Molecule class. fci-h2o; 6-31G H2O Test FCI Energy Point. ocepa1; OCEPA cc-pVDZ energy for the H2O molecule. psimrcc-pt2; Mk-MRPT2 single point. F2 state described using the Ms = 0 component of the singlet. Uses TCSCF singlet orbitals. cc46; EOM-CC2/cc-pVDZ on H2O2 with two excited states in each irrep. mp2_5-grad1; MP2.5 cc-pVDZ gradient for the H2O molecule. mints4; A demonstration of mixed Cartesian/ZMatrix geometry sp",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_testsuite-1.html:2133,energy,energy,2133,psi4manual/4.0b4/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_testsuite-1.html,4,['energy'],['energy']
Energy Efficiency," point. CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. dfmp2-3; DF-MP2 cc-pVDZ frozen core gradient of benzene, computed at the DF-SCF cc-pVDZ geometry. mcscf1; ROHF 6-31G** energy of the state of CH2, with Z-matrix input. The occupations are specified explicitly. ci-multi; BH single points, checking that program can run multiple instances of DETCI in a single input, without an intervening clean() call. sapt5; SAPT0 aug-cc-pVTZ computation of the charge transfer energy of the water dimer. adc2; ADC/aug-cc-pVDZ on two water molecules that are distant from 1000 angstroms from each other. cc40; RHF-CC2-LR/cc-pVDZ optical rotation of H2O2. gauge = length, omega = (589 355 nm). dcft2; DC-06 calculation for the He dimer. This performs a two-step update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the MO Basis. cc32; CC3/cc-pVDZ H2O geom from Olsen et al., JCP 104, 8007 (1996). tu1-h2o-energy; Sample HF/cc-pVDZ H2O computation. dcft4; DCFT calculation for the HF+ using DC-06 functional. This performs both two-step and simultaneous update of the orbitals and cumulant using DIIS extrapolation. Four-virtual integrals are first handled in the MO Basis for the first two energy computations. In the next two the ao_basis=disk algorithm is used, where the transformation of integrals for four-virtual case is avoided. The computation is then repeated using the DC-12 functional with the same algorithms. pywrap-db3; Test that Python Molecule class processes geometry like psi4 Molecule class. fci-h2o; 6-31G H2O Test FCI Energy Point. ocepa1; OCEPA cc-pVDZ energy for the H2O molecule. psimrcc-pt2; Mk-MRPT2 single point. F2 state described using the Ms = 0 component of the singlet. Uses TCSCF singlet orbitals. cc46; EOM-CC2/cc-pVDZ on H2O2 with two excited states in each irrep. mp2_5-grad1; MP2.5 cc-pVDZ gradient for the H2O molecule. mints4; A demonstration of mixed Cartesian/ZMatrix geometry spec",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodoc_testsuite-1.html:2133,energy,energy,2133,psi4manual/4.0b5/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodoc_testsuite-1.html,4,['energy'],['energy']
Energy Efficiency," polarizability,; or optical rotation angles) for some models. Excited states can; also be computed by the CC2 and CC3 models, or by EOM-CCSD. Table; CC Methods summarizes these capabilities. This section; describes how to carry out coupled cluster calculations within PSI4.; For higher-order coupled-cluster methods like CCSDT and CCSDTQ, PSI4; can interface to Kállay’s MRCC code (see MRCC). Current coupled cluster capabilities of PSI4. Method; Reference; Energy; Gradient; Exc. Energies; LR Props. CC2; RHF; Y; —; Y; Y. UHF; Y; —; Y; —. ROHF; Y; —; Y; —. CCSD; RHF; Y; Y; Y; Y. UHF; Y; Y; Y; —. ROHF; Y; Y; Y; —. CCSD(T); RHF; Y; —; n/a; n/a. UHF; Y; Y; n/a; n/a. ROHF; Y; —; n/a; n/a. a-CCSD(T); RHF; Y; —; n/a; n/a. CC3; RHF; Y; —; Y; —. UHF; Y; —; Y; —. ROHF; Y; —; Y; —. CCD; Brueckner; Y; N; N; N. CCD(T); Brueckner; Y; N; n/a; n/a. The following wavefunctions are currently recognized by PSI4 as arguments; to functions like energy(): 'ccsd', 'ccsd(t)', 'a-ccsd(t)', 'cc2',; 'cc3', 'bccd' (CCD with Brueckner orbitals), 'bccd(t)' (CCD(T) with; Brueckner orbitals), 'eom-ccsd', 'eom-cc2' (CC2 for excited states),; 'eom-cc3' (CC3 for excited states). Response properties can be obtained; by calling the function property() (instead of, for example, energy(),; e.g., property('ccsd'). There are many sample; coupled cluster inputs provided in psi4/samples. Basic Keywords¶; A complete list of keywords related to coupled-cluster computations is; provided in the appendices, with the majority of the relevant; keywords appearing in Appendix CCENERGY. For a standard ground-state; CCSD or CCSD(T) computation, the following keywords are common:. REFERENCE¶. Reference wavefunction type. Type: string; Possible Values: RHF; Default: RHF. R_CONVERGENCE¶. Convergence criterion for T2 amplitudes (RMS change). Type: conv double; Default: 1e-5. MAXITER¶. Maximum number of iterations. Type: integer; Default: 50. BRUECKNER_ORBS_R_CONVERGENCE¶. Convergence criterion for Breuckner orbitals. The conv",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/cc-1.html:3182,energy,energy,3182,psi4manual/4.0b5/cc-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/cc-1.html,2,['energy'],['energy']
Energy Efficiency," practical calculations:. For GUESS, the SAD guess is usually your; friend, even for open-shell systems (at the very least, it gets the right; number of electrons, unlike some other programs). For instance, we have found; that a simple SAD guess is often as good as doing a full SCF in a 3-21G basis; and then performing a cast-up, at a fraction of the cost. However, SAD and; DOCC/SOCC arrays do not play very well together at the moment. Also, the SAD; UHF guess is very slow in large basis sets, so you may want to cast up for; >TZ.; For wall time, DF may be a factor of ten or more faster than the exact; integral technologies available in PSI4.; Use DF unless you need absolute accuracy or do not; have a -JKFIT auxiliary set for your primary basis/atom type. Then use; DIRECT.; Don’t mess with the DIIS convergence options unless convergence is a problem.; We have optimized the parameters for efficiency over a wide array of system; types.; Buy a developer a beer!. The “best-practice” input file for HF is:; memory 1 GB # As much as you've got, the DF algorithm can use. molecule {; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; basis cc-pvdz; scf_type df; guess sad; ints_tolerance 1.0E-10 # Even this is epically tight, 1.0E-8 is OK; }. energy('scf'). Table Of Contents. HF: Hartree–Fock Theory; Introduction; Theory; Minimal Input; Spin/Symmetry Treatment; Broken Symmetry; Orthogonalization; Initial Guess/Convergence Stabilization; ERI Algorithms; Second-order Convergence; Stability Analysis; External potentials and QM/MM; Convergence and Algorithm Defaults; Recommendations. Previous topic; Notes on Options; Next topic; DFT: Density Functional Theory. This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; Psi4 [1.0.0 6a9a71b] » ; Theoretical Methods: SCF to FCI ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/scf-1.html:33874,energy,energy,33874,psi4manual/1.0.0/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/scf-1.html,2,['energy'],['energy']
Energy Efficiency," presence of a dipole field. pywrap-db3; Test that Python Molecule class processes geometry like psi4 Molecule class. cc16; ROHF and UHF-B-CCD(T)/cc-pVDZ \(^{3}B_1\) CH2 single-point energy (fzc, MO-basis \(\langle ab|cd \rangle\) ). fci-h2o; 6-31G H2O Test FCI Energy Point. ocepa1; OCEPA cc-pVDZ energy for the H2O molecule. opt-multi-dimer-c2h; Multi-fragment opt of C2h methane dimer with user-combined reference points. fd-freq-energy; SCF STO-3G finite-difference frequencies from energies. cc30; CCSD/sto-3g optical rotation calculation (length gauge only) at two frequencies on methyloxirane. numpy-array-interface; Numpy interface testing. ghosts; Density fitted MP2 cc-PVDZ/cc-pVDZ-RI computation of formic acid dimer binding energy using explicit specification of ghost atoms. This is equivalent to the dfmp2_1 sample but uses both (equivalent) specifications of ghost atoms in a manual counterpoise correction. sapt3; SAPT2+3(CCD) aug-cc-pVDZ computation of the water dimer interaction energy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. mints4; A demonstration of mixed Cartesian/ZMatrix geometry specification, using variables, for the benzene-hydronium complex. Atoms can be placed using ZMatrix coordinates, whether they belong to the same fragment or not. Note that the Cartesian specification must come before the ZMatrix entries because the former define absolute positions, while the latter are relative. tu4-h2o-freq; Optimization followed by frequencies H2O HF/cc-pVDZ. mp2p5-grad1; MP2.5 cc-pVDZ gradient for the H2O molecule. dfmp2-grad3; DF-MP2 cc-pVDZ gradients for the H2O molecule. dfomp2p5-1; DF-OMP2.5 cc-pVDZ energy for the H2O molecule. omp3-3; OMP3 cc-pVDZ energy with B3LYP initial guess for the NO radical. dfomp3-2; DF-OMP3 cc-pVDZ energy for the H2O+ cation. pubchem1; Benzene vertical singlet-triplet energy difference computation, using the PubChem database to obtain the initial geometry, which is optimized at the HF/STO-3G level,",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/testsuite-1.html:18189,energy,energy,18189,psi4manual/1.1.0/testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/testsuite-1.html,4,['energy'],['energy']
Energy Efficiency," print_preiterations([small]). push_back_external_potential(self, V); Add an external potential to the private external_potentials list. reference_wavefunction(self); Returns the reference wavefunction. reset_occupation(self); docstring. rotate_orbitals(self, arg0, arg1); docstring. same_a_b_dens(self); Returns true if the alpha and beta densities are the same. same_a_b_orbs(self); Returns true if the alpha and beta orbitals are the same. save_density_and_energy(self); docstring. scalar_variable(self, arg0); Returns the requested (case-insensitive) double QC variable. scalar_variables(self); Returns the dictionary of all double QC variables. semicanonicalize(self); Semicanonicalizes the orbitals for ROHF. set_array(key, val). Deprecated since version 1.4. set_array_variable(self, arg0, arg1); Sets the requested (case-insensitive) Matrix QC variable. set_basisset(self, arg0, arg1); Sets the requested auxiliary basis. set_energies(self, arg0, arg1); docstring. set_energy(self, arg0); Sets the Wavefunction’s energy. set_external_cpscf_perturbation(self, name, …); Add an external potential/perturbation to the private external_cpscf_perturbations map for CPSCF. set_external_potential(self, arg0); Sets the requested external potential. set_frequencies(val). Deprecated since version 1.4. set_gradient(self, arg0); Sets the Wavefunction’s gradient. set_hessian(self, arg0); Sets the Wavefunction’s Hessian. set_jk(self, arg0); Sets the internal JK object !expert. set_lagrangian(self, arg0); Sets the orbital Lagrangian matrix. set_legacy_frequencies(self, arg0); Sets the frequencies of the Hessian. set_module(self, module); Sets name of the last/highest level of theory module (internal or external) touching the wavefunction. set_name(self, arg0); Sets the level of theory this wavefunction corresponds to. set_potential_variable(self, arg0, arg1); Sets the requested (case-insensitive) ExternalPotential QC variable. set_print(self, arg0); Sets the print level of the Wavefunction. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.cuhf.html:9779,energy,energy,9779,psi4manual/1.4.0/api/psi4.core.cuhf.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.cuhf.html,5,['energy'],['energy']
Energy Efficiency," printing.; zLO (int) – Zeta number of the smaller basis set in 2-point extrapolation.; valueLO (Union[float, Matrix, Vector]) – Energy, gradient, or Hessian value at the smaller basis set in 2-point; extrapolation.; zHI (int) – Zeta number of the larger basis set in 2-point extrapolation.; Must be zLO + 1.; valueHI (Union[float, Matrix, Vector]) – Energy, gradient, or Hessian value at the larger basis set in 2-point; extrapolation.; verbose (int) – Controls volume of printing.; alpha (Optional[float]) – Overrides the default \(\alpha = 3.0\). Returns:; Eponymous function applied to input zetas and values; type from valueLO. Return type:; float or ndarray. Notes; The extrapolation is calculated according to [5]:; \(E_{corl}^X = E_{corl}^{\infty} + \beta X^{-alpha}\); References. [5]; Halkier, Helgaker, Jorgensen, Klopper, Koch, Olsen, & Wilson,; Chem. Phys. Lett. 286 (1998) 243-252,; DOI: 10.1016/S0009-2614(99)00179-7. Examples; >>> # [1] CISD extrapolation; >>> energy('cbs', corl_wfn='cisd', corl_basis='cc-pV[DT]Z', corl_scheme='corl_xtpl_helgaker_2'). psi4.driver.driver_cbs._get_default_xtpl(nbasis, xtpl_type)[source]¶; A helper function to determine default extrapolation type. Parameters:. nbasis (int) – Number of basis sets; xtpl_type (str) – {‘scf’, ‘corl’}; Extrapolation type: ‘scf’ for the total energy, ‘corl’ for just the; correlation component. Returns:; Extrapolation function to be used. Return type:; Callable. Additional extrapolation schemes are easy to define by the; user. Follow models in psi4/psi4/driver/driver_cbs_helper.py; and pywrap-cbs1 and use the; psi4.driver.driver_cbs_helper.register_xtpl_function() to make; user-defined functions known to PSI4. psi4.driver.driver_cbs_helper.register_xtpl_function(func)[source]¶; Register a user-defined extrapolation function to use like an built-in one. Parameters:; func (Callable) – A Python function that applies a basis set extrapolation formula to scalars and optionally to; NumPy arrays. See psi4/psi4/driv",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/cbs.html:28923,energy,energy,28923,psi4manual/1.7.x/cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/cbs.html,4,['energy'],['energy']
Energy Efficiency," printing.; zLO (int) – Zeta number of the smaller basis set in 2-point extrapolation.; valueLO (Union[float, Matrix, Vector]) – Energy, gradient, or Hessian value at the smaller basis set in 2-point; extrapolation.; zHI (int) – Zeta number of the larger basis set in 2-point extrapolation.; Must be zLO + 1.; valueHI (Union[float, Matrix, Vector]) – Energy, gradient, or Hessian value at the larger basis set in 2-point; extrapolation.; verbose (int) – Controls volume of printing.; alpha (Optional[float]) – Overrides the default \(\alpha = 3.0\). Returns; Eponymous function applied to input zetas and values; type from valueLO. Return type; float or numpy.ndarray. Notes; The extrapolation is calculated according to 5:; \(E_{corl}^X = E_{corl}^{\infty} + \beta X^{-alpha}\); References. 5; Halkier, Helgaker, Jorgensen, Klopper, Koch, Olsen, & Wilson,; Chem. Phys. Lett. 286 (1998) 243-252,; DOI: 10.1016/S0009-2614(99)00179-7. Examples; >>> # [1] CISD extrapolation; >>> energy('cbs', corl_wfn='cisd', corl_basis='cc-pV[DT]Z', corl_scheme='corl_xtpl_helgaker_2'). psi4.driver.driver_cbs._get_default_xtpl(nbasis, xtpl_type)[source]¶; A helper function to determine default extrapolation type. Parameters. nbasis (int) – Number of basis sets; xtpl_type (str) – {‘scf’, ‘corl’}; Extrapolation type: ‘scf’ for the total energy, ‘corl’ for just the; correlation component. Returns; Extrapolation function to be used. Return type; Callable. Additional extrapolation schemes are easy to define by the; user. Follow models in psi4/psi4/driver/driver_cbs_helper.py; and pywrap-cbs1 and use the; psi4.driver.driver_cbs_helper.register_xtpl_function() to make; user-defined functions known to PSI4. psi4.driver.driver_cbs_helper.register_xtpl_function(func)[source]¶; Register a user-defined extrapolation function to use like an built-in one. Parameters; func (Callable) – A Python function that applies a basis set extrapolation formula to scalars and optionally to; NumPy arrays. See psi4/psi4/driver/d",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/cbs.html:28866,energy,energy,28866,psi4manual/1.6.x/cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/cbs.html,1,['energy'],['energy']
Energy Efficiency," program.; Function to call Grimme’s GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to self for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, func. Returns energy if dertype is 0, gradient; if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The gcp executable must be independently compiled and; found in PATH or PSIPATH. self may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.Molecule. Parameters. func (str, optional) – Name of method/basis combination or composite method for which to compute the correction; (e.g., HF/cc-pVDZ, DFT/def2-SVP, HF3c, PBEh3c).; dertype (int or str, optional) – Maximum derivative level at which to run GCP. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int, optional) – Amount of printing. Unused at present. Returns. energy (float) – When dertype=0, energy [Eh].; gradient (ndarray) – When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray) – When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. save_string_xyz(self: psi4.core.Molecule) → str¶; Saves the string of an XYZ file to arg2. save_string_xyz_file(self: psi4.core.Molecule) → str¶; Saves an XYZ file to arg2. save_xyz_file(self: psi4.core.Molecule, arg0: str, arg1: bool) → None¶; Saves an XYZ file to arg0. schoenflies_symbol(self: psi4.core.Molecule) → str¶; Returns the Schoenflies symbol. scramble(do_shift=True, do_rotate=True, do_resort=True, deflection=1.0, do_mirror=False, do_plot=False, run_to_completion=False, run_resorting=False, verbose=1)[source]¶; Tester for B787 by shifting, rotating, and atom shuffling ref_mol and; checking that the",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.molecule.html:29724,energy,energy-only,29724,psi4manual/1.4.0/api/psi4.core.molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.molecule.html,6,"['efficient', 'energy']","['efficient', 'energy-only']"
Energy Efficiency," provided by the user. mints1; Symmetry tests for a range of molecules. This doesn’t actually compute any energies, but serves as an example of the many ways to specify geometries in Psi4. dct11; Restricted DF-DCT ODC-12 energies with linearly dependent basis functions. cc49; EOM-CC3(UHF) on CH radical with user-specified basis and properties for particular root. density-screen-2; RKS Density Matrix based-Integral Screening Test for benzene. opt3; SCF cc-pVDZ geometry optimzation, with Z-matrix input. pywrap-all; Intercalls among python wrappers- database, cbs, optimize, energy, etc. Though each call below functions individually, running them all in sequence or mixing up the sequence is aspirational at present. Also aspirational is using the intended types of gradients. nbody-multi-level-2; many-body different levels of theory on each body of helium tetramer. cc37; CC2(UHF)/cc-pVDZ energy of H2O+. dfccdl1; DF-CCDL cc-pVDZ energy for the H2O molecule. opt8; Various constrained energy minimizations of HOOH with cc-pvdz RHF. Cartesian-coordinate constrained optimizations of HOOH in Cartesians. castup1; Test of SAD/Cast-up (mainly not dying due to file weirdness). dfscf-bz2; Benzene Dimer DF-HF/cc-pVDZ. ddd-deriv; Sample HF/cc-pVDZ H2O computation all derivatives. scf-property; UFH and B3LYP cc-pVQZ properties for the CH2 molecule. dft-pruning; Tests all grid pruning options available and screening of small weights. Check against grid size. cisd-h2o+-0; 6-31G** H2O+ Test CISD Energy Point. dft-smoke; DFT Functional Smoke Test. dct-grad3; Restricted DF-DCT ODC-12 gradient for ethylene with cc-pVDZ/cc-pVDZ-RI standard/auxiliary basis set. fsapt-d; Tests SAPT0-D corrections, with a variety of damping functions/parameters. mbis-4; MBIS calculation on NaCl. lccd-grad1; LCCD cc-pVDZ gradient for the H2O molecule. cc21; ROHF-EOM-CCSD/DZ analytic gradient lowest \(^{2}A_1\) excited state of H2O+ (B1 excitation). nbody-multi-level; Multilevel computation of water trimer energy (g",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html:38567,energy,energy,38567,psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency, psi4.core.MintsHelper method. mo_overlap_half_deriv1() psi4.core.MintsHelper method. MO_READ (MCSCF). (OCC). mo_spin_eri() psi4.core.MintsHelper method. MO_STEP_MAX (DFOCC). (OCC). mo_tei_deriv1() psi4.core.MintsHelper method. mo_tei_deriv2() psi4.core.MintsHelper method. mo_transform() psi4.core.MintsHelper method. MO_WRITE (OCC). module. ; psi4.core. psi4.driver. psi4.driver.qcdb.vib. MODULE (CPHF). module() psi4.core.CCWavefunction method. psi4.core.CIWavefunction method. psi4.core.CUHF method. psi4.core.DFEP2Wavefunction method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. psi4.core.Wavefunction method. moFa() psi4.core.ROHF method. moFb() psi4.core.ROHF method. moFeff() psi4.core.ROHF method. MOGRAD_DAMPING (OCC). Molden. molden() in module psi4.driver. MOLDEN_WITH_VIRTUAL (GLOBALS). MOLDEN_WRITE (DFOCC). (SCF). MoldenWriter class in psi4.core. molecular_charge() psi4.core.Molecule method. MolecularGrid class in psi4.core. molecule. ; charge. EFP. ghost. isotope. multiple fragments. multiple in input file. multiplicity. no_reorient. PubChem. setting keywords. specification. symmetry. units. Molecule class in psi4.core. class in psi4.driver.qcdb. molecule() psi4.core.BasisSet method. psi4.core.CCWavefunction method. psi4.core.CIWavefunction method. psi4.core.CUHF method. psi4.core.DFEP2Wavefunction method. psi4.core.FISAPT method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. psi4.core.Wavefunction method. molecule_get_attr() in module psi4.driver. molecule_set_attr() in module psi4.driver. MOM. MOM_excited_ psi4.core.CUHF attribute. psi4.core.HF attribute. psi4.core.RHF attribute. psi4.core.ROHF attribute. psi4.core.UHF attribute. MOM_OCC (SCF). MOM_performed_ psi4.core.CUHF attribute. psi4.core.HF attribute. psi4.core.RHF attribute. psi4.core.ROHF attribute. psi4.core.UHF attribute. MOM_START (SCF). MOM_VIR (SCF). MONTAGE. MOSpace class in psi4.core. move_atom() psi4.core.Bas,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/genindex-1.html:87753,charge,charge,87753,psi4manual/1.4.0/genindex-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/genindex-1.html,5,['charge'],['charge']
Energy Efficiency," psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.Wavefunction, basis: psi4.core.BasisSet) → psi4.core.Wavefunction¶; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet *basis. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Beta Eigenvalues subset. esp_at_nuclei(self: psi4.core.Wavefunction) → psi4.core.Vector¶; returns electrostatic potentials at nuclei. force_doccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use only. Sets the number of doubly occupied oribtals per irrep. Note that this results in inconsistent Wavefunction objects for SCF, so caution is advised. force_soccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use only",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psi4api-1.html:218236,energy,energy,218236,psi4manual/1.2.1/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html,3,['energy'],['energy']
Energy Efficiency," psi4.core.dfmp2(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the DF-MP2 code. psi4.core.dfocc(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the density-fitted orbital optimized CC codes. psi4.core.displace_atom(arg0: psi::Matrix, arg1: int, arg2: int, arg3: int, arg4: float) → None¶; Displaces one coordinate of single atom. psi4.core.dmrg(arg0: psi::Wavefunction) → float¶; Runs the DMRG code. psi4.core.efp_init() → psi4.core.EFP¶; Initializes the EFP library and returns an EFP object. psi4.core.efp_set_options() → None¶; Set EFP options from environment options object. psi4.core.fcidump_tei_helper(nirrep: int, restricted: bool, DPD_info: Dict[str, int], ints_tolerance: float, fname: str='INTDUMP') → None¶; Write integrals to file in FCIDUMP format. psi4.core.fd_1_0(arg0: psi::Molecule, arg1: list) → psi::Matrix¶; Performs a finite difference gradient computation, from energy points. psi4.core.fd_freq_0(arg0: psi::Molecule, arg1: list, arg2: int) → psi::Matrix¶; Performs a finite difference frequency computation, from energy points, for a given irrep. psi4.core.fd_freq_1(arg0: psi::Molecule, arg1: list, arg2: int) → psi::Matrix¶; Performs a finite difference frequency computation, from gradients, for a given irrep. psi4.core.fd_geoms_1_0(arg0: psi::Molecule) → List[psi::Matrix]¶; Gets list of displacements needed for a finite difference gradient computation, from energy points. psi4.core.fd_geoms_freq_0(arg0: psi::Molecule, arg1: int) → List[psi::Matrix]¶; Gets list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep. psi4.core.fd_geoms_freq_1(arg0: psi::Molecule, arg1: int) → List[psi::Matrix]¶; Gets list of displacements needed fof a finite difference frequency computation, from gradients, for a given irrep. psi4.core.finalize() → None¶. psi4.core.flush_outfile() → None¶; Flushes the output file. psi4.core.fnocc(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the fno-ccsd(t)/qcisd(t)/mp4/cep",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psi4api-1.html:227122,energy,energy,227122,psi4manual/1.2.1/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html,2,['energy'],['energy']
Energy Efficiency," psi4.set_variable(""CURRENT CORRELATION ENERGY"",cemp4sdq); elif ( lowername == 'fno-mp4(sdq)'):; emp4sdq = psi4.get_variable(""MP4(SDQ) TOTAL ENERGY""); cemp4sdq = psi4.get_variable(""MP4(SDQ) CORRELATION ENERGY""); psi4.set_variable(""CURRENT ENERGY"",emp4sdq); psi4.set_variable(""CURRENT CORRELATION ENERGY"",cemp4sdq); elif ( lowername == 'fno-mp4'):; emp4 = psi4.get_variable(""MP4 TOTAL ENERGY""); cemp4 = psi4.get_variable(""MP4 CORRELATION ENERGY""); psi4.set_variable(""CURRENT ENERGY"",emp4); psi4.set_variable(""CURRENT CORRELATION ENERGY"",cemp4); elif (lowername == 'fnocc-mp') and (level == 4):; emp4 = psi4.get_variable(""MP4 TOTAL ENERGY""); cemp4 = psi4.get_variable(""MP4 CORRELATION ENERGY""); psi4.set_variable(""CURRENT ENERGY"",emp4); psi4.set_variable(""CURRENT CORRELATION ENERGY"",cemp4). # restore options; optstash.restore(). return psi4.get_variable(""CURRENT ENERGY""). [docs]def run_cepa(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a cepa-like calculation. >>> energy('cepa(1)'). """"""; lowername = name.lower(); uppername = name.upper(); kwargs = p4util.kwargs_lower(kwargs). # save user options; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['FNOCC', 'NAT_ORBS'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'USE_DF_INTS'],; ['FNOCC', 'CEPA_NO_SINGLES']). psi4.set_local_option('FNOCC','RUN_CEPA', True); psi4.set_local_option('FNOCC','USE_DF_INTS', False). # what type of cepa?; cepa_level = uppername; if (lowername == 'cepa(2)'):; raise ValidationError(""Error: %s not implemented\n"" % lowername); if (lowername == 'dci'):; cepa_level = 'CISD'; if (lowername == 'sdci'):; cepa_level = 'CISD'. if (lowername == 'fno-cepa(0)'):; cepa_level = 'CEPA(0)'; psi4.set_local_option('FNOCC', 'NAT_ORBS', True); if (lowername == 'fno-cepa(1)'):; psi4.set_local_option('FNOCC', 'NAT_ORBS', True); cepa_level = 'CEPA(1)'; if (lowername == 'fno-cepa(3)'):; psi4.set_local_option('FNOCC', 'NAT_ORBS', True); cepa_level = 'CEPA(3)'; if (lowername == 'fno-acpf'):; psi4.set_local_op",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/proc.html:72265,energy,energy,72265,psi4manual/4.0b5/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html,1,['energy'],['energy']
Energy Efficiency," psioh.get_file_path(filenum); namespace = psio.get_default_namespace(); pid = str(os.getpid()); prefix = 'psi'; targetfile = filepath + prefix + '.' + pid + '.' + namespace + '.' + str(filenum); core.print_out(f"" \n Copying restart file <{item}> to <{targetfile}> for internal processing\n""); shutil.copy(item, targetfile). logger.info(f""Compute energy(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); wfn = procedures['energy'][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return energy(): {core.variable('CURRENT ENERGY')}""). for postcallback in hooks['energy']['post']:; postcallback(lowername, wfn=wfn, **kwargs). basisstash.restore(); optstash.restore(); optstash2.restore(). if return_wfn: # TODO current energy safer than wfn.energy() for now, but should be revisited. # TODO place this with the associated call, very awkward to call this in other areas at the moment; if lowername in ['efp', 'mrcc', 'dmrg']:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the incoming reference wavefunction.\n\n""); elif 'sapt' in lowername:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the dimer SCF wavefunction.\n\n""). return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]; def gradient(name, **kwargs):; r""""""Function complementary to :py:func:`~psi4.driver.optimize()`. Carries out one gradient pass,; deciding analytic or finite difference. :returns: :py:class:`~psi4.core.Matrix` |w--w| Total electronic gradient in Hartrees/Bohr. :returns: (:py:class:`~psi4.core.Matrix`, :py:class:`~psi4.core.Wavefunction`) |w--w| gradient",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:40996,energy,energy,40996,psi4manual/1.8.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html,3,['energy'],['energy']
Energy Efficiency," psioh.get_file_path(filenum); namespace = psio.get_default_namespace(); pid = str(os.getpid()); prefix = 'psi'; targetfile = filepath + prefix + '.' + pid + '.' + namespace + '.' + str(filenum); core.print_out(f"" \n Copying restart file <{item}> to <{targetfile}> for internal processing\n""); shutil.copy(item, targetfile). logger.info(f""Compute energy(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); wfn = procedures['energy'][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return energy(): {core.variable('CURRENT ENERGY')}""). for postcallback in hooks['energy']['post']:; postcallback(lowername, wfn=wfn, **kwargs). basisstash.restore(); optstash.restore(); optstash2.restore(). if return_wfn: # TODO current energy safer than wfn.energy() for now, but should be revisited. # TODO place this with the associated call, very awkward to call this in other areas at the moment; if lowername in ['efp', 'mrcc', 'dmrg']:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the incoming reference wavefunction.\n\n""); elif 'sapt' in lowername:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the dimer SCF wavefunction.\n\n""). return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]def gradient(name, **kwargs):; r""""""Function complementary to :py:func:`~psi4.driver.optimize()`. Carries out one gradient pass,; deciding analytic or finite difference. :returns: :py:class:`~psi4.core.Matrix` |w--w| Total electronic gradient in Hartrees/Bohr. :returns: (:py:class:`~psi4.core.Matrix`, :py:class:`~psi4.core.Wavefunction`) |w--w| gradient a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html:40992,energy,energy,40992,psi4manual/1.7.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html,1,['energy'],['energy']
Energy Efficiency," psioh.get_file_path(filenum); namespace = psio.get_default_namespace(); pid = str(os.getpid()); prefix = 'psi'; targetfile = filepath + prefix + '.' + pid + '.' + namespace + '.' + str(filenum); core.print_out(f"" \n Copying restart file <{item}> to <{targetfile}> for internal processing\n""); shutil.copy(item, targetfile). logger.info(f""Compute energy(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); wfn = procedures['energy'][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return energy(): {core.variable('CURRENT ENERGY')}""). for postcallback in hooks['energy']['post']:; postcallback(lowername, wfn=wfn, **kwargs). basisstash.restore(); optstash.restore(); optstash2.restore(). if return_wfn: # TODO current energy safer than wfn.energy() for now, but should be revisited. # TODO place this with the associated call, very awkward to call this in other areas at the moment; if lowername in ['efp', 'mrcc', 'dmrg']:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the incoming reference wavefunction.\n\n""); elif 'sapt' in lowername:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the dimer SCF wavefunction.\n\n""). return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]def gradient(name, **kwargs):; r""""""Function complementary to :py:func:`~psi4.optimize()`. Carries out one gradient pass,; deciding analytic or finite difference. :returns: :py:class:`~psi4.core.Matrix` |w--w| Total electronic gradient in Hartrees/Bohr. :returns: (:py:class:`~psi4.core.Matrix`, :py:class:`~psi4.core.Wavefunction`) |w--w| gradient and wave",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html:34162,energy,energy,34162,psi4manual/1.6.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html,1,['energy'],['energy']
Energy Efficiency," published using early; PSI4 SAPT code may show discrepancies of 0.01-0.10 kcal/mol in; individual terms, particularly \(E_{exch}^{(11)}\) and \(E_{exch}^{(12)}\). Caution; January 28th 2016, the default for all NAT_ORBS options; was changed to true. Hence the code now by default uses natural; orbital truncation to speed up the evaluation of energy terms; wherever possible, according to literature recommendations.; In early July 2016, some total SAPT energy psivars were renamed. Caution; February 7, 2020, a missing term in \(E^{(30)}_{ind}\) was added, causing; possible discrepancies with prior versions of the code on the order of; 0.01 kcal/mol. See https://github.com/psi4/psi4/issues/1677. Symmetry-adapted perturbation theory (SAPT) provides a means of directly; computing the noncovalent interaction between two molecules, that is, the; interaction energy is determined without computing the total energy of the; monomers or dimer. In addition, SAPT provides a decomposition of the; interaction energy into physically meaningful components: i.e.,; electrostatic, exchange, induction, and dispersion terms. In SAPT, the; Hamiltonian of the dimer is partitioned into contributions from each; monomer and the interaction. \[H=F_A+W_A+F_B+W_B+V\]; Here, the Hamiltonian is written as a sum of the usual monomer Fock; operators, \(F\), the fluctuation potential of each monomer, \(W\), and the; interaction potential, \(V\). The monomer Fock operators, \(F_A+F_B\), are; treated as the zeroth-order Hamiltonian and the interaction energy is; evaluated through a perturbative expansion of \(V\), \(W_A\), and \(W_B\).; Through first-order in \(V\), electrostatic and exchange interactions are; included; induction and dispersion first appear at second-order in \(V\). For; a complete description of SAPT, the reader is referred to the excellent; review by Jeziorski, Moszynski, and Szalewicz [Jeziorski:1994:1887].; Several truncations of the closed-shell SAPT expansion are available in the S",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/sapt-1.html:1854,energy,energy,1854,psi4manual/1.4.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/sapt-1.html,2,['energy'],['energy']
Energy Efficiency," python files for available; molecular systems (case insensitive). [1,2,5] || ['1','2','5'] || ['BzMe-3.5', 'MeMe-5.0'] || etc.; Specify a list of database members to run. Consult the; database python files for available molecular systems. This; is the only portion of database input that is case sensitive;; choices for this keyword must match the database python file. Examples :. >>> # [1] Two-stage SCF calculation on short, equilibrium, and long helium dimer; >>> db('scf','RGC10',cast_up='sto-3g',subset=['HeHe-0.85','HeHe-1.0','HeHe-1.5'], tabulate=['scf total energy','natom']). >>> # [2] Counterpoise-corrected interaction energies for three complexes in S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('dfmp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). Output¶; At the beginning of a database job is printed a listing of the individual system; calculations which will be performed. The output snippet below is from the example job [1]; above. It shows each reagent required for the subset of database reactions requested.; Note that this is an un-counterpoise-corrected example, and the wrapper is smart enough; to compute only once the monomer whose energy will be subtracted from each of the three dimers.; RGC1-HeHe-0.85-dimer; RGC1-He-mono-unCP; RGC1-HeHe-1.0-dimer; RGC1-HeHe-1.5-dimer. At the end of the job, the Requested Energy table is printed that gives the total; energies for the requested model chemistry for each reagent and each reaction, as; well as the stoichoimetric we",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/db-1.html:5676,energy,energy,5676,psi4manual/4.0b3/db-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/db-1.html,6,['energy'],['energy']
Energy Efficiency," qcisd(t); ccsd(t); fno-df-ccsd(t). bccd(t); cisd; cisdt; cisdtq; cin; fci. Parameters:; name (string) – 'scf' || 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be 'scf'. Overruled if stage_wfn keywords supplied. corl_wfn (string) – 'mp2' || 'ccsd(t)' || etc.; Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with name or as the unlabeled; first argument to the function. delta_wfn (string) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. delta_wfn_lesser (string) – 'mp2' || 'ccsd' || etc.; Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. delta2_wfn (string) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. delta2_wfn_lesser (string) – 'mp2' || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. Basis Sets; Currently, the basis set set through set commands have no influence; on a cbs calculation. Parameters:; scf_basis (basis string) – corl_basis || 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, scf_basis can default; to corl_basis. corl_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the correlation energy. delta_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. delta2_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/cbs-1.html:3649,energy,energy,3649,psi4manual/4.0b4/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/cbs-1.html,4,['energy'],['energy']
Energy Efficiency," qcmtdIN[self.method]:; text += """"""%s\n"""""" % (line); text += """"""show[1,20f20.12],ee*,ce*,te*\n""""""; text += """"""show[1,60f20.12],_E*\n""""""; text += '\n'. return text. qcmtdIN = {; 'ccsd(t)-f12': [; 'rhf',; 'eehf=energy',; 'ccsd(t)-f12,df_basis=mp2fit,df_basis_exch=jkfitb,ri_basis=jkfitb',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'eemp3=emp3',; 'cemp3=eemp3-eehf',; 'eeccsd=energc',; 'ceccsd=eeccsd-eehf',; 'eeccsdt=energy',; 'ceccsdt=eeccsdt-eehf',; 'temp2=emp2_trip',; 'teccsd=ectrip'],. 'ccsd(t)': [; 'rhf',; 'eehf=energy',; 'ccsd(t)',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'eemp3=emp3',; 'cemp3=eemp3-eehf',; 'eeccsd=energc',; 'ceccsd=eeccsd-eehf',; 'eeccsdt=energy',; 'ceccsdt=eeccsdt-eehf',; 'temp2=emp2_trip',; 'teccsd=ectrip'],. 'mp3': [; 'gdirect',; 'rhf',; 'eehf=energy',; 'mp3',; 'eemp2=emp2',; 'eemp3=emp3',; 'eemp25=0.5*(eemp2+eemp3)',; 'cemp2=eemp2-eehf',; 'cemp3=eemp3-eehf',; 'cemp25=eemp25-eehf',; 'temp2=emp2_trip',; 'temp3=ectrip'],. 'mp2': [; 'gdirect',; 'rhf',; 'eehf=energy',; 'mp2',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'temp2=emp2_trip'],. 'df-hf-mp2': [; 'gdirect',; '{df-hf,basis=jkfit}',; 'eehf=energy',; 'mp2',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'temp2=emp2_trip'],. 'hf-df-mp2': [; 'gdirect',; 'rhf',; 'eehf=energy',; '{df-mp2,basis_mp2=mp2fit}',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'temp2=emp2_trip'],. 'hf': [; 'rhf',; 'eehf=energy'],. 'mp2-f12': [; 'gdirect',; 'rhf',; 'eehf=energy',; 'mp2-f12',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'temp2=emp2_trip'],. 'df-mp2-f12': [; 'gdirect',; #'rhf',; '{df-hf,basis=jkfit}',; 'eehf=energy',; #'{df-mp2-f12,df_basis=mp2fit,df_basis_exch=jkfit,ri_basis=optrib}',; '{df-mp2-f12,df_basis=mp2fit,df_basis_exch=jkfitb,ri_basis=jkfitb}',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'temp2=emp2_trip'],. 'df-mp2': [; 'gdirect',; '{df-hf,basis=jkfit}',; 'eehf=energy',; '{df-mp2,basis_mp2=mp2fit}',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'temp2=emp2_trip'],. 'df-hf': [; 'gdirect',; '{df-hf,basis=jkfit}',; 'eehf=energy'],. 'b3lyp-d': [; 'gdirect',; '",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro.html:4546,energy,energy,4546,psi4manual/1.0.0/_modules/qcdb/molpro.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro.html,1,['energy'],['energy']
Energy Efficiency," quantities; # energy('mp3', **kwargs); # e_scf = psi4.get_variable('SCF TOTAL ENERGY'); # ce_mp2 = psi4.get_variable('MP2 CORRELATION ENERGY'); # ce_mp3 = psi4.get_variable('MP3 CORRELATION ENERGY'); # e_mp2 = e_scf + ce_mp2; # e_mp3 = e_scf + ce_mp3; #; # # Compute quantities particular to MP2.5; # ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); # e_mp25 = e_scf + ce_mp25; # psi4.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25); # psi4.set_variable('MP2.5 TOTAL ENERGY', e_mp25); # psi4.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); # psi4.set_variable('CURRENT ENERGY', e_mp25); #; # # build string of title banner and print results; # banners = ''; # banners += """"""psi4.print_out('\\n')\n""""""; # banners += """"""banner(' MP2.5 ')\n""""""; # banners += """"""psi4.print_out('\\n')\n\n""""""; # exec(banners); #; # tables = ''; # tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); # tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); # tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); # tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); # tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); # tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); # tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); # psi4.print_out(tables); #; # return e_mp25. # A direct translation of a plugin input file into a function call. Function calls are the only; # way to call plugins in sow/reap mode for db(), opt(), etc. This isn't best practices; # but is an example of what to do for a more complicated procedure where different options; # are set for different qc steps.; #def run_plugin_omega(name, **kwargs):; # r""""""Function encoding sequence of PSI module and plugin calls, as well; # as typical options, to access Rob Parrish's omega plugin.; #; # >>> energy('plugin_omega'); #; # """"""; # lowername = name.lower(); # kwargs = p4util.kwargs_lower(kwargs); #; # plugfile = psi4.Process.environment[""PSIDATADIR""] + ""/../tests/plugin_omega/plugin_omega.so""; # psi4.plugi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/aliases.html:7918,energy,energy,7918,psi4manual/4.0b5/_modules/aliases.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/aliases.html,1,['energy'],['energy']
Energy Efficiency," r""""""Function to compute the single-point electronic energy. :returns: *float* |w--w| Total electronic energy in Hartrees. SAPT & EFP return interaction energy. :returns: (*float*, :ref:`Wavefunction<sec:psimod_Wavefunction>`) |w--w| energy and wavefunction when **return_wfn** specified. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY <CURRENTENERGY>`; * :psivar:`CURRENT REFERENCE ENERGY <CURRENTREFERENCEENERGY>`; * :psivar:`CURRENT CORRELATION ENERGY <CURRENTCORRELATIONENERGY>`. :type name: string; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :ref:`Wavefunction<sec:psimod_Wavefunction>`; calculation result as the second element (after *float* energy) of a tuple. :type restart_file: string; :param restart_file: ``['file.1, file.32]`` || ``./file`` || etc. Binary data files to be renamed for calculation restart. .. _`table:energy_gen`:. +-------------------------+---------------------------------------------------------------------------------------------------------------+; | name | calls method |; +=========================+===============================================================================================================+; | efp | effective fragment potential (EFP) :ref:`[manual] <sec:libefp>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | scf | Hartree--Fock (HF) or density functional theory (DFT) :ref:`[manual] <sec:scf>` |; +-------------------------+-------------------------------------------------------------------------------------------------------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver.html:4641,energy,energy,4641,psi4manual/1.0.0/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver.html,1,['energy'],['energy']
Energy Efficiency," r_1); \phi_{\nu} (\vec r_1); \frac{1}{r_{12}}; \phi_{\lambda} (\vec r_2); \phi_{\sigma} (\vec r_2); \ \mathrm{d}^3 r_1; \ \mathrm{d}^3 r_2.\]; The MO coefficients are found as the generalized eigenvectors of the Fock Matrix,. \[F^\alpha C^\alpha = S C^\alpha \epsilon^\alpha\]; The eigenvalues \(\epsilon\) are the orbital energies, and the metric matrix; \(S\) is the AO-basis overlap matrix. \[S_{\mu\nu} = (\mu | \nu )\]; Note that the Fock Matrix depends on the density (both alpha and beta), and; therefore the orbitals. Because of this, SCF is a nonlinear procedure, which; terminates when the generating orbitals are self-consistent with the Fock matrix; they generate.; The formation of the Coulomb matrix \(J\) and the exchange matrix; \(K^{\alpha}\) dominate the computational effort of the SCF procedure. For; very large systems, diagonalization of the Fock matrix can also present a; significant hurdle. Minimal Input¶; Minimal input for a Hartree–Fock computation is a molecule block, basis set; option, and a call to energy('scf'):; 1; 2; 3; 4; 5; 6; 7molecule {; He; }. set basis sto-3g. energy('scf'). This will run a Restricted Hartree–Fock (RHF) on neutral singlet Helium in; \(D_{2h}\) spatial symmetry with a minimal STO-3G basis, 1.0E-6; energy and density convergence criteria (since single-point, see; SCF Convergence & Algorithm), a DF ERI algorithm, symmetric; orthogonalization, DIIS, and a core Hamiltonian guess. For more; information on any of these options, see the relevant section below. Spin/Symmetry Treatment¶; PSI4 implements the most popular spin specializations of Hartree–Fock; theory, including:. Restricted Hartree–Fock (RHF) [Default]; Appropriate only for closed-shell singlet systems, but twice as efficient; as the other flavors, as the alpha and beta densities are constrained to be; identical.; Unrestricted Hartree–Fock (UHF); Appropriate for most open-shell systems and fairly easy to converge.; The spatial parts of the alpha and beta orbitals are fu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/scf-1.html:7582,energy,energy,7582,psi4manual/1.1.0/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/scf-1.html,6,['energy'],['energy']
Energy Efficiency," reaching; accurate energies even in the presence of significant linear; dependencies [Lehtola:2020:04224].; In PSI4, symmetric orthogonalization is used by default, unless; the smallest overlap eigenvalue falls below the user-supplied double; option S_TOLERANCE, which defaults to 1E-7. If the smallest; eigenvalue is below this cutoff, canonical orthogonalization is; forced, and all eigenvectors corresponding to eigenvalues below the; cutoff are eliminated.; If the eigendecomposition is detected to be numerically unstable - the; reciprocal condition number of the overlap matrix to be smaller than; the machine epsilon - the partial Cholesky decomposition is undertaken; until S_CHOLESKY_TOLERANCE, which defaults to 1E-8.; Use of symmetric, canonical, and partial Cholesky orthogonalization; can be forced by setting the S_ORTHOGONALIZATION option to; SYMMETRIC, CANONICAL, or PARTIALCHOLESKY,; respectively.; Note that in practice, the MOs and OSOs are built separately within; each irrep from the symmetry-adapted combinations of AOs known as; Unique Symmetry Orbitals (USOs). For canonical orthogonalization,; this implies that the number of MOs and OSOs per irrep may be slightly; smaller than the number of USOs per irrep.; A contrived example demonstrating OSOs/MOs vs. AOs with symmetry is shown; below:; molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; symmetry c2 # Two irreps is easier to comprehend; }. set {; s_tolerance 0.0001 # Set an unreasonably tight; # tolerance to force canonical; basis aug-cc-pv5z # This diffuse basis will have; # small-ish eigenvalues for even H2O; print 3; }. energy('scf'). Output:; ==> Pre-Iterations <==. -------------------------------------------------------; Irrep Nso Nmo Nalpha Nbeta Ndocc Nsocc; -------------------------------------------------------; A 145 145 0 0 0 0; B 142 142 0 0 0 0; -------------------------------------------------------; Total 287 287 5 5 5 0; -------------------------------------------------------. ... Minimum ei",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/scf-1.html:14081,adapt,adapted,14081,psi4manual/1.4.0/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/scf-1.html,6,['adapt'],['adapted']
Energy Efficiency," reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. \[\sqrt{\frac{1}{n}\sum_{rxn}^{n}{(\textsf{\textsl{name}}_{rxn}-\text{REF}_{rxn})^2}}\]. DCT LAMBDA ENERGY¶; An energy term in density cumulant theory [E_h]. This term is the; 2-electron cumulant’s contribution contribution to the reduced; density matrix energy expression. Not recommended for interpretative; use except by reduced density matrix specialists. DCT SCF ENERGY¶; An energy term in density cumulant theory [E_h]. This term is the; 1-electron reduced density matrix (1RDM) contribution to the reduced; density matrix energy expression, plus the contribution of the; antisymmetrized product of 1RDMs. Not recommended for interpretative; use except by reduced density matrix specialists. DCT THREE-PARTICLE ENERGY¶; The three-particle correlation energy correction [E_h] in density cumulant; theory, akin to (T) CORRECTION ENERGY in coupled-cluster. DCT TOTAL ENERGY¶; Total energy [E_h] in density cumulant theory. Sum of DCT SCF ENERGY,; DCT LAMBDA ENERGY, and DCT THREE-PARTICLE ENERGY when present. DETCI AVG DVEC NORM¶; A measure of configuration interaction convergence. DFT FUNCTIONAL TOTAL ENERGY¶; The total electronic energy [E_h] for the underlying functional of the; requested DFT method, without any dispersion correction; the first four; terms in Eq. (4) or (1). Quantity; \(E_{\text{FCTL}}\) in Eqs. (4) and (1).; Unless the method includes a dispersion correction, this quantity is; equal to SCF TOTAL ENERGY. DFT TOTAL ENERGY¶; The total electronic energy [E_h] for the requested DFT method,; \(E_{\text{DFT}}\) in Eq. (1). \begin{align*}; E_{\text{DFT}} & = E_{NN} + E_{1e^-} + E_{2e^-} + E_{xc} + E_{\text{-D}} + E_{\text{DH}} \\; & = E_{\text{FCTL}} + E_{\text{-D}} + E_{\text{DH}} \\; & = E_{\text{SCF}} + E_{\text{DH}}; \end{align*}Unless the method is a DFT double-hybrid, this quantity is equal to; SCF TOTAL ENERGY. If the method is neither a; double-hybrid",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html:27801,energy,energy,27801,psi4manual/1.7.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html,4,['energy'],['energy']
Energy Efficiency," read from disk. Returns; A deserialized Wavefunction object. Return type; Wavefunction. frzcpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of frozen core orbitals per irrep. frzvpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of frozen virtual orbitals per irrep. get_amplitudes(self: psi4.core.CCWavefunction) → Dict[str, psi4.core.Matrix]¶; Get dict of converged T amplitudes. Returns. amps (dict (spacestr, SharedMatrix)) – spacestr is a description of the amplitude set using the following conventions. I,J,K -> alpha occupied; i,j,k -> beta occupied; A,B,C -> alpha virtual; a,b,c -> beta virtual. The following entries are stored in the amps, depending on the reference type; RHF (tIA, tIjAb); UHF (tIA, tia, tIjAb, tIJAB, tijab); ROHF (tIA, tia, tIjAb, tIJAB, tijab). Examples; RHF T1 diagnostic = sqrt(sum_ia (T_ia * T_ia)/nelec); >>> mol = “””; … 0 1; … Ne 0.0 0.0 0.0; … symmetry c1”””; >>> e, wfn = psi4.energy(“CCSD/cc-pvdz”, return_wfn=True); >>> t1 = wfn.get_amplitudes()[‘tia’].to_array(); >>> t1_diagnostic = np.sqrt(np.dot(t1.ravel(),t1.ravel())/ (2 * wfn.nalpha()); >>> t1_diagnostic == psi4.variable(“CC T1 DIAGNOSTIC”); True. Warning; Symmetry free calculations only (nirreps > 1 will cause error). Warning; No checks that the amplitudes will fit in core. Do not use for proteins. get_array(key)¶. Deprecated since version 1.4: Use psi4.core.Wavefunction.variable() instead. get_basisset(self: psi4.core.Wavefunction, arg0: str) → psi4.core.BasisSet¶; Returns the requested auxiliary basis. get_density(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Experimental!. get_dipole_field_strength(self: psi4.core.Wavefunction) → List[float[3]]¶; Returns a vector of length 3, containing the x, y, and z dipole field strengths. get_print(self: psi4.core.Wavefunction) → int¶; Get the print level of the Wavefunction. get_scratch_filename(filenumber)¶; Given a wavefunction and a scratch file number, canonicalizes ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CCWavefunction.html:17515,energy,energy,17515,psi4manual/1.6.x/api/psi4.core.CCWavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CCWavefunction.html,1,['energy'],['energy']
Energy Efficiency," read from disk. Returns; A deserialized Wavefunction object. Return type; Wavefunction. frzcpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of frozen core orbitals per irrep. frzvpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of frozen virtual orbitals per irrep. get_amplitudes(self: psi4.core.CCWavefunction) → Dict[str, psi4.core.Matrix]¶; Get dict of converged T amplitudes. Returns. amps (dict (spacestr, SharedMatrix)) – spacestr is a description of the amplitude set using the following conventions. I,J,K -> alpha occupied; i,j,k -> beta occupied; A,B,C -> alpha virtual; a,b,c -> beta virtual. The following entries are stored in the amps, depending on the reference type; RHF (tIA, tIjAb); UHF (tIA, tia, tIjAb, tIJAB, tijab); ROHF (tIA, tia, tIjAb, tIJAB, tijab). Examples; RHF T1 diagnostic = sqrt(sum_ia (T_ia * T_ia)/nelec); >>> mol = “””; … 0 1; … Ne 0.0 0.0 0.0; … symmetry c1”””; >>> e, wfn = psi4.energy(“CCSD/cc-pvdz”, return_wfn=True); >>> t1 = wfn.get_amplitudes()[‘tia’].to_array(); >>> t1_diagnostic = np.sqrt(np.dot(t1.ravel(),t1.ravel())/ (2 * wfn.nalpha()); >>> t1_diagnostic == psi4.variable(“CC T1 DIAGNOSTIC”); True. Warning; Symmetry free calculations only (nirreps > 1 will cause error). Warning; No checks that the amplitudes will fit in core. Do not use for proteins. get_array(key)¶. Deprecated since version 1.4: Use psi4.core.Wavefunction.variable() instead. get_basisset(self: psi4.core.Wavefunction, arg0: str) → psi4.core.BasisSet¶; Returns the requested auxiliary basis. get_dipole_field_strength(self: psi4.core.Wavefunction) → List[float[3]]¶; Returns a vector of length 3, containing the x, y, and z dipole field strengths. get_print(self: psi4.core.Wavefunction) → int¶; Get the print level of the Wavefunction. get_scratch_filename(filenumber)¶; Given a wavefunction and a scratch file number, canonicalizes the name; so that files can be consistently written and read. get_variable(key)¶. Depreca",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ccwavefunction.html:16314,energy,energy,16314,psi4manual/1.4.0/api/psi4.core.ccwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ccwavefunction.html,2,['energy'],['energy']
Energy Efficiency," rebuild PSI4 to detect PCMSolver and activate dependent code. To remove a conda installation, conda remove pcmsolver. Source. If using PSI4 built from source and you want PCMSolver built from; from source also,; enable it as a feature with ENABLE_PCMSolver,; and let the build system fetch and build it and activate dependent code. Using the polarizable continuum model¶; The inclusion of a PCM description of the solvent into your calculation; can be achieved in two ways in PSI4, using either the PCMSolver or ddx package.; PCMSolver is based on a boundary-element discretisation [Cances:1998:309],; while ddx is based on a domain decomposition approach; [Cances:2013:054111] making it linear scaling.; For more details about ddx see the section on ddx.; Using PCMsolver is achieved instead by setting PCM true in your input file.; PSI4 understands the additional option PCM_SCF_TYPE with possible values total; (the default) or separate.; The latter forces the separate handling of nuclear and electronic electrostatic potentials and; polarization charges. It is mainly useful for debugging.; For the calculation of vertical excitation energies with PCM non-equilibrium solvation should be included with:; pcm = {; Medium {; Nonequilibrium = True; }; }. Note; At present PCM can only be used for energy calculations with SCF; wavefunctions and CC wavefunctions in the PTE approximation [Cammi:2009:164104].; All ERI algorithms (PK, OUT_OF_CORE, DIRECT, DF, CD) are supported. Note; linear response calculations (static polarisabilities, TD-SCF) are supported for RHF/UHF if available. Warning; The PCMSolver library cannot exploit molecular point group symmetry. Warning; ROHF with PCM is known not to work. See issue #999 on GitHub.; For the adventurous, a fix is available in pull request #953 on GitHub. Warning; Analytic gradients and Hessians are not available with PCM. Finite differences will be used; regardless of the dertype passed to the optimize function.; See pcmsolver/opt-fd for a s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/pcmsolver.html:2264,charge,charges,2264,psi4manual/1.7.x/pcmsolver.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/pcmsolver.html,4,['charge'],['charges']
Energy Efficiency," recognizes that the local DFA is potentially exact at short range in the; exchange hole, and that the hybrid-exchange energy of the noninteracting; quasiparticles is also exact for true electrons at long range in the exchange; hole. Therefore LRC switches from DFA at short range to hybrid exchange at long; range, typically using the function as a; partition function.; Tying all these pieces together, a full LRC-hybrid GKS functional has the; generic form,. For LRC functionals, the choice of range-separtion parameter has; been the subject of considerable activity since the inception of LRC; functionals. Some authors advocate a static range-separation parameter; determined by optimization over a test set of chemical systems. However, a more; physically-motivated and often more accurate approach is the idea of “gap; fitting” or “optimal tuning” or simply “tuning.” The most popular tuned-LRC; approach is IP-fitting, in which the is varied until the; Koopman’s IP (the opposite of the HOMO energy) matches the true IP (the; difference between -electron and -electron total; energies), within the LRC functional ansatz. This guarantees the asymptotics of; the exchange potential,. Note that LRC functionals with default only capture the; dependence,. hybrid functionals only capture part of the dependence,. and local functionals decay exponentially, resulting in completely incorrect; asymptotics,. IP-tuned LRC functionals effectively pin the chemical potential at ; electrons to the correct value determined by the ionization potential. This; often cleans up the MSIE problem for a surprisingly large number of high-lying; occupied orbitals, as determined by fractional particle curves. Other gap; fitting techniques involving the electron affinity or band gap are sometimes; also used. IP-fitting is found to be particularly critical for the qualitative; determination of excited state ordering in many low band-gap systems.; For dispersion-bound complexes, a very simple additive empiric",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/dft-1.html:7355,energy,energy,7355,psi4manual/1.0.0/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/dft-1.html,10,['energy'],['energy']
Energy Efficiency," recommendations.; In early July 2016, some total SAPT energy psivars were renamed. Caution; February 7, 2020, a missing term in \(E^{(30)}_{ind}\) was added, causing; possible discrepancies with prior versions of the code on the order of; 0.01 kcal/mol. See https://github.com/psi4/psi4/issues/1677. Caution; August 2021, the number of frozen core orbitals used in the dMP2 computations; is now standardized. Specifically, we now rigorously enforce that the number of core orbitals; frozen in dimer computations is equal to the sum of frozen orbitals of each monomer. Prior to; this, a discrepency between these values was possible when one of the monomers was (exclusively); a charged alkali metal. Symmetry-adapted perturbation theory (SAPT) provides a means of directly; computing the noncovalent interaction between two molecules, that is, the; interaction energy is determined without computing the total energy of the; monomers or dimer. In addition, SAPT provides a decomposition of the; interaction energy into physically meaningful components: i.e.,; electrostatic, exchange, induction, and dispersion terms. In SAPT, the; Hamiltonian of the dimer is partitioned into contributions from each; monomer and the interaction. \[H=F_A+W_A+F_B+W_B+V\]; Here, the Hamiltonian is written as a sum of the usual monomer Fock; operators, \(F\), the fluctuation potential of each monomer, \(W\), and the; interaction potential, \(V\). The monomer Fock operators, \(F_A+F_B\), are; treated as the zeroth-order Hamiltonian and the interaction energy is; evaluated through a perturbative expansion of \(V\), \(W_A\), and \(W_B\).; Through first-order in \(V\), electrostatic and exchange interactions are; included; induction and dispersion first appear at second-order in \(V\). For; a complete description of SAPT, the reader is referred to the excellent; review by Jeziorski, Moszynski, and Szalewicz [Jeziorski:1994:1887].; Several truncations of the closed-shell SAPT expansion are available in the S",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/sapt-1.html:2254,energy,energy,2254,psi4manual/1.5.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/sapt-1.html,2,['energy'],['energy']
Energy Efficiency," reference values. This test should match RHF values exactly. rasscf-sp; 6-31G** H2O Test RASSCF Energy Point will default to only singles and doubles in the active space. dfep2-1; Compute three IP and 2 EA’s for the PH3 molecule. scf-response1; Compute the dipole, quadrupole, and traceless quadrupoles for water. basis-ecp; check mixing ECP and non-ECP orbital/fitting basis sets in a session. cc29; CCSD/cc-pVDZ optical rotation calculation (both gauges) on Cartesian H2O2. mints-benchmark; run some BLAS benchmarks. cc18; RHF-CCSD-LR/cc-pVDZ static polarizability of HOF. fd-freq-gradient-large; SCF DZ finite difference frequencies by gradients for C4NH4. linK-1; RHF Linear Exchange Algorithm test for water. fci-h2o-2; 6-31G H2O Test FCI Energy Point. dfmp2-grad4; DF-MP2 cc-pVDZ gradient for the NO molecule. psithon1; Spectroscopic constants of H2, and the full ci cc-pVTZ level of theory. cc27; Single point gradient of 1-1B2 state of H2O with EOM-CCSD. omp3-3; OMP3 cc-pCVDZ energy with B3LYP initial guess for the NO radical. props1; RHF STO-3G dipole moment computation, performed by applying a finite electric field and numerical differentiation. omp2-grad1; OMP2 cc-pVDZ gradient for the H2O molecule. dfomp2-2; OMP2 cc-pVDZ energy for the NO molecule. mom-h2o-4; MOM excitation from LUMO HOMO+4. dfcasscf-fzc-sp; CASSCF/6-31G** energy point. olccd-grad2; OLCCD cc-pVDZ gradient for the NO radical. scf-property; UFH and B3LYP cc-pVQZ properties for the CH2 molecule. olccd-freq1; OLCCD cc-pVDZ freqs for C2H2. omp3-grad2; OMP3 cc-pVDZ gradient for the NO radical. scf-response3; UHF Dipole Polarizability Test. cc37; CC2(UHF)/cc-pVDZ energy of H2O+. sapt10; usapt example with empty beta due to frozen core. cc8c; ROHF-CCSD cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Cartesian input. extern2; External potential calculation involving a TIP3P water and a QM water for DFMP2. Finite different test of the gradient is performed to validate forces. sc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html:3623,energy,energy,3623,psi4manual/master/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency," reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_mp2_property(name, **kwargs):; """"""Function selecting the algorithm for a MP2 property call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP2_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only dfmp2 for now. func = None; if reference == 'RHF':; if mtd_type == 'DF':; #if module == 'OCC':; # func = run_dfocc_property; if module in ['', 'DFMP2']:; func = run_dfmp2_property; #elif reference == 'UHF':; # if mtd_type == 'DF':; # if module in ['', 'OCC']:; # func = run_dfocc_property. if func is None:; raise ManagedMethodError(['select_mp2_property', name, 'MP2_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_omp2(name, **kwargs):; """"""Function selecting the algorithm for an OMP2 energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP2_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError(['select_omp2', name, 'MP2_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_omp2_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OMP2 gradient call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP2_TYPE'); module =",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:5587,energy,energy,5587,psi4manual/1.0.0/_modules/procedures/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html,1,['energy'],['energy']
Energy Efficiency," repeat_l > 1:; delta_l = delta_l / 2.0; if repeat_r > 1:; delta_r = delta_r / 2.0; omega = - (omega_r - omega_l) / (delta_r - delta_l) * delta_l + omega_l; psi4.set_global_option('DFT_OMEGA', omega). # Neutral; psi4.IO.change_file_namespace(180, ""neutral"", ""ot""); molecule.set_molecular_charge(charge0); molecule.set_multiplicity(mult0); psi4.print_out(""""""\n\t==> IP Fitting SCF: Neutral, Omega = %11.3E <==\n"""""" % omega); E0, wfn = energy('scf', return_wfn=True, molecule=molecule, **kwargs); eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); E_HOMO = 0.0; if Nb == 0:; E_HOMO = eps_a[int(Na - 1)]; else:; E_a = eps_a[int(Na - 1)]; E_b = eps_b[int(Nb - 1)]; if E_a >= E_b:; E_HOMO = E_a; else:; E_HOMO = E_b; psi4.IO.change_file_namespace(180, ""ot"", ""neutral""). # Cation; psi4.IO.change_file_namespace(180, ""cation"", ""ot""); molecule.set_molecular_charge(charge1); molecule.set_multiplicity(mult1); psi4.print_out(""""""\n\t==> IP Fitting SCF: Cation, Omega = %11.3E <==\n"""""" % omega); E1 = energy('scf', molecule=molecule, **kwargs); psi4.IO.change_file_namespace(180, ""ot"", ""cation""). IP = E1 - E0; kIP = -E_HOMO; delta = IP - kIP. if kIP > IP:; omega_r = omega; E0r = E0; E1r = E1; IPr = IP; kIPr = kIP; delta_r = delta; repeat_r = 0; repeat_l = repeat_l + 1; else:; omega_l = omega; E0l = E0; E1l = E1; IPl = IP; kIPl = kIP; delta_l = delta; repeat_l = 0;; repeat_r = repeat_r + 1. omegas.append(omega); types.append('Regula-Falsi'); E0s.append(E0); E1s.append(E1); IPs.append(IP); kIPs.append(kIP). # Termination; if (abs(omega_l - omega_r) < omega_tol or step > maxiter):; converged = True; break. # Properly, should clone molecule but since not returned and easy to unblemish,; molecule.set_molecular_charge(charge0); molecule.set_multiplicity(mult0); psi4.IO.set_default_namespace(""""). psi4.print_out(""""""\n\t==> IP Fitting Results <==\n\n""""""). psi4.print_out(""""""\t => Occupation Determination <= \n\n""""""); psi4.print_out(""""""\t %6s %6s %6s %6s %6s %6s\n"""""" % ('N', 'Na', 'Nb', 'Charge', 'Mult', ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/frac.html:17110,energy,energy,17110,psi4manual/1.0.0/_modules/frac.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/frac.html,1,['energy'],['energy']
Energy Efficiency," requested (case-insensitive) Matrix QC variable. del_potential_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) ExternalPotential QC variable. (This function is provisional and might be removed in the future.). del_scalar_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) double QC variable. del_variable(key)¶; Removes scalar or array QCVariable key from cls if present. Return type; None. Parameters. cls (psi4.core.Wavefunction) – ; key (str) – . density_fitted(self: psi4.core.Wavefunction) → bool¶; Returns whether this wavefunction was obtained using density fitting or not. diis(self: psi4.core.HF) → bool¶; docstring. diis_manager(self: psi4.core.HF) → psi4.core.DIISManager¶; docstring. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. efzc(self: psi4.core.Wavefunction) → float¶; Returns the frozen-core energy. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunction’s energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Beta Eigenvalues subset. esp_at_nuclei(self: psi4.core.Wavefunction) → psi4.core.Vector¶; returns electrostatic potentials at nuclei. external_pot(self: psi4.core.Wavefunction) → psi4.core.ExternalPotential¶; Gets the requested external potential. finalize(self: psi4.core.HF) → None¶; Cleans up the the Wavefunction’s temporary data. finalize_energy()¶; Performs stability analysis and calls back SCF with new guess; if needed, Returns the SCF energy. This function should be called; once orbi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.cuhf.html:19751,energy,energy,19751,psi4manual/1.4.0/api/psi4.core.cuhf.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.cuhf.html,5,['energy'],['energy']
Energy Efficiency," required matrix elements have; been coded for high-spin cases, meaning that results will correspond to an; approximate Mk-MRCC computation for high-spin cases. A Simple Example¶; The CORR_WFN allows you to select one of three methods; Mk-MRPT2 [PT2], Mk-MRCCSD [CCSD], or Mk-MRCCSD(T) [CCSD_T].; The CORR_MULTP option allows you to select the Slater; determinants with a particular value. The WFN_SYM; keyword is neccesary if you do not want to compute the energy of the; totally-symmetric state. The FOLLOW_ROOT option may be used; to follow different roots of the effective Hamiltonian. A value of 1; instructs PSIMRCC to follow the solution with the lowest energy given; a certain set of determinants.; molecule o2 {; 0 3; O; O 1 2.265122720724; units au; }; set {; basis cc-pvtz; }; set mcscf {; reference rohf; docc [3,0,0,0,0,2,1,1] # Doubly occupied MOs; socc [0,0,1,1,0,0,0,0] # Singly occupied MOs; }; set psimrcc {; corr_wfn ccsd # Do Mk-MRCCSD; frozen_docc [1,0,0,0,0,1,0,0] # Frozen MOs; restricted_docc [2,0,0,0,0,1,1,1] # Doubly occupied MOs; active [0,0,1,1,0,0,0,0] # Active MOs; frozen_uocc [0,0,0,0,0,0,0,0] # Frozen virtual MOs; corr_multp 1 # Select the Ms = 0 component; follow_root 1; wfn_sym B1g # Select the B1g state; }; energy('psimrcc'). Note that the oxygen molecule has 16 electrons (including core), while; the docc array contains only 7 doubly-occupied orbitals (or 14; electrons). Hence, two more electrons are available to place into; the active space (given by active), which consists of 2 orbitals.; Thus there are two active electrons in two orbitals. In this particular; example, we are using standard ROHF orbitals for the Mk-MRCCSD procedure,; rather than TCSCF orbitals. Nevertheless, with the present code,; these orbitals must be provided through the MCSCF module, as specified in the; set mcscf section above. Orbital ordering and selection of the model space¶; The reference determinants are specified in PSIMRCC; via occupational numbers. PSIMRCC requires",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/psimrcc-1.html:4669,energy,energy,4669,psi4manual/1.0.0/psimrcc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/psimrcc-1.html,2,['energy'],['energy']
Energy Efficiency," response = task.return_result; reference[""module""] = getattr(task.provenance, ""module"", None). if task.driver == 'energy':; reference['energy'] = response. elif task.driver == 'gradient':; reference['gradient'] = response; reference['energy'] = task.extras['qcvars']['CURRENT ENERGY']. elif task.driver == 'hessian':; reference['hessian'] = response; reference['energy'] = task.extras['qcvars']['CURRENT ENERGY']; if 'CURRENT GRADIENT' in task.extras['qcvars']:; reference['gradient'] = task.extras['qcvars']['CURRENT GRADIENT']. dipole_available = False; if 'CURRENT DIPOLE' in task.extras['qcvars']:; reference['dipole'] = task.extras['qcvars']['CURRENT DIPOLE']; dipole_available = True. # load AtomicComputer results into findifrec[displacements]; for label, displacement in self.findifrec[""displacements""].items():; task = results_list[label]; response = task.return_result. if task.driver == 'energy':; displacement['energy'] = response. elif task.driver == 'gradient':; displacement['gradient'] = response; displacement['energy'] = task.extras['qcvars']['CURRENT ENERGY']. elif task.driver == 'hessian':; displacement['hessian'] = response; displacement['energy'] = task.extras['qcvars']['CURRENT ENERGY']; if 'CURRENT GRADIENT' in task.extras['qcvars']:; displacement['gradient'] = task.extras['qcvars']['CURRENT GRADIENT']. if 'CURRENT DIPOLE' in task.extras['qcvars']:; displacement['dipole'] = task.extras['qcvars']['CURRENT DIPOLE']. # apply finite difference formulas and load derivatives into findifrec[reference]; if self.metameta['mode'] == '1_0':; G0 = assemble_gradient_from_energies(self.findifrec); self.findifrec[""reference""][self.driver.name] = G0. elif self.metameta['mode'] == '2_1':; if dipole_available:; DD0 = assemble_dipder_from_dipoles(self.findifrec, self.metameta['irrep']); self.findifrec[""reference""][""dipole derivative""] = DD0. H0 = assemble_hessian_from_gradients(self.findifrec, self.metameta['irrep']); self.findifrec[""reference""][self.driver.name] = H0. elif s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html:47772,energy,energy,47772,psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html,4,['energy'],['energy']
Energy Efficiency," response? (not recommended). Type: boolean; Default: false. FISAPT_FSAPT_IND_SCALE¶. Do F-SAPT induction scaling? (ratio of HF induction to F-SAPT induction). Type: boolean; Default: true. FISAPT_FSSAPT_FILEPATH¶. Filepath to drop sSAPT0 exchange-scaling F-SAPT data. Type: string; Default: s-fsapt/. FISAPT_LINK_ASSIGNMENT¶. Where do sigma links go (to C or to AB)?. Type: string; Possible Values: C, AB; Default: C. FISAPT_LINK_SELECTION¶. Specification algorithm for link bonds in ISAPT. Type: string; Possible Values: AUTOMATIC, MANUAL; Default: AUTOMATIC. FISAPT_MANUAL_LINKS¶. Manual link bond specification [[Atom1, Atom2], ...]. Type: array; Default: No Default. FISAPT_PLOT_FILEPATH¶. Filepath to drop scalar data. Type: string; Default: plot/. INTS_TOLERANCE¶. Minimum absolute value below which integrals are neglected. Type: conv double; Default: 0.0. LOCAL_CONVERGENCE¶. Relative convergence in orbital localization. Type: conv double; Default: 1.0e-12. LOCAL_IBO_POWER¶. IBO localization metric power. Type: integer; Default: 4. LOCAL_IBO_STARS¶. IBO Centers for Pi Degeneracy. Type: array; Default: No Default. LOCAL_IBO_STARS_COMPLETENESS¶. IBO Charge metric for classification as Pi. Type: double; Default: 0.90. LOCAL_IBO_USE_STARS¶. IBO Stars procedure. Type: boolean; Default: false. LOCAL_MAXITER¶. Maximum iterations in localization. Type: integer; Default: 1000. MAXITER¶. Maximum number of iterations for CPHF. Type: integer; Default: 50. SSAPT0_SCALE¶. Do sSAPT0 exchange-scaling with F-SAPT. Type: boolean; Default: false. Expert¶. CUBIC_BASIS_TOLERANCE¶. CubicScalarGrid basis cutoff. Type: conv double; Default: 1.0e-12. CUBIC_BLOCK_MAX_POINTS¶. CubicScalarGrid maximum number of grid points per evaluation block. Type: integer; Default: 1000. FISAPT_MEM_SAFETY_FACTOR¶. Memory safety factor for heavy FISAPT operations. Type: double; Default: 0.9. LOCAL_IBO_CONDITION¶. Condition number to use in IBO metric inversions. Type: double; Default: 1.0e-7. LOCAL_USE_GHOSTS¶. U",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/module__fisapt-1.html:2080,power,power,2080,psi4manual/1.1.0/autodir_options_c/module__fisapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/module__fisapt-1.html,2,['power'],['power']
Energy Efficiency," restriction). I’m aiming for files to pass the line below, unless for good reason. The second line is for database Python files.; >>> pep8.py -r --ignore=E501 pythonfile.py; >>> pep8.py -r --ignore=E501,E221,E222,E241,E201,E202 databasefile.py. Your python function should not prevent any test case (make tests, NOT make longtests) from passing. A test case(s) should be written and checked in for any major python function, so that others do not break your code. If most of your work was on the python (as opposed to c++) side, the test case prefix pywrap_ is suggested. Be sure to set any new PSI variables through lines like those below. Especially if the function returns an energy, set the ‘current energy’ variable. This last is needed to communicate with the optimizer.; PsiMod.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25); PsiMod.set_variable('MP2.5 TOTAL ENERGY', e_mp25); PsiMod.set_variable('CURRENT ENERGY', e_mp25). Once your python function is fairly stable on its own, it’s potential for interoperability with energy()/opt()/cp()/db()/cbs()/etc. should be evaluated. If it makes physical sense that it should work, you should strive to make that interoperability a reality. Some steps:. If any interoperability is possible, define an argument xx_func, where xx is a short name for your function. Add near the top of your function code like the below (less the final two lines). The net result of this code is that if the user specifies no *_func arguments, then energy() gets called. If the user defines xx_func, then its value gets called. If the user defines func, then its value gets reassigned to xx_func, func itself is deleted, and xx_func() gets called. Whatever is getting called is stored in func within the function.; # Establish function to call; if not('xx_func' in kwargs):; if ('func' in kwargs):; kwargs['xx_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['xx_func'] = energy; func = kwargs['xx_func']; if not func:; raise ValidationError('Function \'%s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/bestpractices_py-1.html:4582,energy,energy,4582,psi4manual/4.0b2/bestpractices_py-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/bestpractices_py-1.html,6,['energy'],['energy']
Energy Efficiency," return 'fnocc-mp', 4; else:; return 'detci-mp', 4; # Otherwise return method and order; else:; return namestump, namelevel; else:; return namelower, None; else:; return namelower, None. [docs]def hessian(name, **kwargs):; r""""""Function complementary to :py:func:`~frequency`. Computes force; constants, deciding analytic, finite difference of gradients, or; finite difference of energies. """"""; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs); dertype = 2. optstash = p4util.OptionsState(; ['SCF', 'E_CONVERGENCE'],; ['SCF', 'D_CONVERGENCE'],; ['E_CONVERGENCE']). # Order of precedence:; # 1. Default for wavefunction; # 2. Value obtained from kwargs, if user changed it; # 3. If user provides a custom 'func' use that. # Allow specification of methods to arbitrary order; lowername, level = parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. # 1. set the default to that of the provided name; if lowername in procedures['hessian']:; dertype = 2; elif lowername in procedures['gradient']:; dertype = 1; func = gradient; elif lowername in procedures['energy']:; dertype = 0; func = energy. # 2. Check if the user passes dertype into this function; if 'dertype' in kwargs:; freq_dertype = kwargs['dertype']. if der0th.match(str(freq_dertype)):; dertype = 0; func = energy; elif der1st.match(str(freq_dertype)):; dertype = 1; func = gradient; elif der2nd.match(str(freq_dertype)):; dertype = 2; else:; raise ValidationError('Requested derivative level \'dertype\' %s not valid for helper function frequency.' % (freq_dertype)). # 3. if the user provides a custom function THAT takes precedence; if ('freq_func' in kwargs) or ('func' in kwargs):; if ('func' in kwargs):; kwargs['freq_func'] = kwargs['func']; del kwargs['func']; dertype = 0; func = kwargs['freq_func']. # Summary validation; if (dertype == 2) and (lowername in procedures['hessian']):; pass; elif (dertype == 1) and (func is gradient) and (lowername in procedures['gradient']):; pass; elif (dertype == 1) ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/driver.html:58795,energy,energy,58795,psi4manual/4.0b5/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/driver.html,2,['energy'],['energy']
Energy Efficiency," return values, see below.; verbose (int, optional) – Amount of printing. Returns. energy (float) – When dertype=0, energy [Eh].; gradient (ndarray) – When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray) – When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; This function wraps the QCEngine dftd4 harness which wraps the internal DFTD4 Python API.; As such, the upstream convention of func trumping dashparam holds, rather than the; run_dftd3() behavior of dashparam extending or overriding func. run_gcp(func=None, dertype=None, verbose=1)[source]¶; Compute geometrical BSSE correction via Grimme’s GCP program.; Function to call Grimme’s GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to self for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, func. Returns energy if dertype is 0, gradient; if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The gcp executable must be independently compiled and; found in PATH or PSIPATH. self may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.Molecule. Parameters. func (str, optional) – Name of method/basis combination or composite method for which to compute the correction; (e.g., HF/cc-pVDZ, DFT/def2-SVP, HF3c, PBEh3c).; dertype (int or str, optional) – Maximum derivative level at which to run GCP. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int, optional) – Amount of printing. Unused at present. Returns. energy (float) – When dertype=0, energy [Eh].; gradient (ndarray) – When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray) – When dertype=None,",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.molecule.html:30666,energy,energy,30666,psi4manual/1.5.0/api/psi4.core.molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.molecule.html,4,['energy'],['energy']
Energy Efficiency," rfile = 'FREQ-%s' % (n + 1). # Build string of title banner; banners = ''; banners += """"""core.print_out('\\n')\n""""""; banners += """"""p4util.banner(' Hessian Computation: Energy Displacement %d ')\n"""""" % (n + 1); banners += """"""core.print_out('\\n')\n\n"""""". if freq_mode == 'continuous':. # print progress to file and screen; core.print_out('\n'); p4util.banner('Loading displacement %d of %d' % (n + 1, ndisp)); print("""""" %d"""""" % (n + 1), end=('\n' if (n + 1 == ndisp) else '')); sys.stdout.flush(). # Load in displacement into the active molecule; moleculeclone.set_geometry(displacement). # Perform the energy calculation; E, wfn = energy(lowername, return_wfn=True, molecule=moleculeclone, **kwargs); energies.append(core.get_variable('CURRENT ENERGY')). # clean may be necessary when changing irreps of displacements; core.clean(). # S/R: Write each displaced geometry to an input file; elif freq_mode == 'sow':; moleculeclone.set_geometry(displacement). # S/R: Prepare molecule, options, kwargs, function call and energy save; with open('%s.in' % (rfile), 'wb') as freagent:; freagent.write('# This is a psi4 input file auto-generated from the gradient() wrapper.\n\n'); freagent.write(p4util.format_molecule_for_input(moleculeclone, forcexyz=True).encode('utf-8')); freagent.write(p4util.format_options_for_input(moleculeclone, **kwargs).encode('utf-8')); p4util.format_kwargs_for_input(freagent, **kwargs); freagent.write(""""""electronic_energy = %s('%s', **kwargs)\n\n"""""" % (energy.__name__, lowername)); freagent.write(""""""core.print_out('\\nHESSIAN RESULT: computation %d for item %d """""" % (os.getpid(), n + 1)); freagent.write(""""""yields electronic energy %20.12f\\n' % (electronic_energy))\n\n""""""). # S/R: Read energy from each displaced geometry output file and save in energies array; elif freq_mode == 'reap':; exec(banners); core.set_variable('NUCLEAR REPULSION ENERGY', moleculeclone.nuclear_repulsion_energy()); energies.append(p4util.extract_sowreap_from_output(rfile, 'HESSIAN', n, freq",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html:78860,energy,energy,78860,psi4manual/1.1.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html,2,['energy'],['energy']
Energy Efficiency," rfile = 'FREQ-%s' % (n + 1). # Build string of title banner; banners = ''; banners += """"""psi4.print_out('\\n')\n""""""; banners += """"""p4util.banner(' Hessian Computation: Energy Displacement %d ')\n"""""" % (n + 1); banners += """"""psi4.print_out('\\n')\n\n"""""". if freq_mode == 'continuous':. # print progress to file and screen; psi4.print_out('\n'); p4util.banner('Loading displacement %d of %d' % (n + 1, ndisp)); print("""""" %d"""""" % (n + 1), end=('\n' if (n + 1 == ndisp) else '')); sys.stdout.flush(). # Load in displacement into the active molecule; moleculeclone.set_geometry(displacement). # Perform the energy calculation; E, wfn = energy(lowername, return_wfn=True, molecule=moleculeclone, **kwargs); energies.append(psi4.get_variable('CURRENT ENERGY')). # clean may be necessary when changing irreps of displacements; psi4.clean(). # S/R: Write each displaced geometry to an input file; elif freq_mode == 'sow':; moleculeclone.set_geometry(displacement). # S/R: Prepare molecule, options, kwargs, function call and energy save; with open('%s.in' % (rfile), 'wb') as freagent:; freagent.write('# This is a psi4 input file auto-generated from the gradient() wrapper.\n\n'); freagent.write(p4util.format_molecule_for_input(moleculeclone, forcexyz=True).encode('utf-8')); freagent.write(p4util.format_options_for_input(moleculeclone, **kwargs).encode('utf-8')); p4util.format_kwargs_for_input(freagent, **kwargs); freagent.write(""""""electronic_energy = %s('%s', **kwargs)\n\n"""""" % (energy.__name__, lowername)); freagent.write(""""""psi4.print_out('\\nHESSIAN RESULT: computation %d for item %d """""" % (os.getpid(), n + 1)); freagent.write(""""""yields electronic energy %20.12f\\n' % (electronic_energy))\n\n""""""). # S/R: Read energy from each displaced geometry output file and save in energies array; elif freq_mode == 'reap':; exec(banners); psi4.set_variable('NUCLEAR REPULSION ENERGY', moleculeclone.nuclear_repulsion_energy()); energies.append(p4util.extract_sowreap_from_output(rfile, 'HESSIAN', n, freq",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver.html:76878,energy,energy,76878,psi4manual/1.0.0/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver.html,1,['energy'],['energy']
Energy Efficiency," robust and accurate, and it should be preferred unless extreme accuracy is required; or a fitting basis is not defined for the primary basis and atom type; encountered. In particular, we have found excellent efficiency and tractability; gains when using DF-MP2 in concert with a DF-SCF reference. An efficient,; threaded, disk-based DF-MP2 code is available in Psi4 for all single; reference types available in the SCF module.; MP2 defaults in Psi4 to the density-fitted code. See; MP2_TYPE for performing a MP2 with conventional integrals.; An example utilization of the code is:; molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set basis cc-pvdz; set scf_type df; set freeze_core True. energy('mp2'). The energy('mp2') call to energy() executes; the predefined DF-MP2 procedure, first calling; the SCF module with a default RHF reference and DF algorithm for the; two-electron integrals. When the orbitals are converged, the DF-MP2 module is; launched, which forms the density-fitted integrals and then builds the; full tensor in blocks, evaluating the contributions to the MP2 energy; as it goes. A RHF-MP2 wavefunction is selected automatically due to the RHF; reference. In this example, we freeze the core, both for efficiency and; because split-valence bases like cc-pVDZ do not contain core correlation; functions. The result looks something like:; ----------------------------------------------------------; ====================> MP2 Energies <====================; ----------------------------------------------------------; Reference Energy = -76.0213974789664633 [H]; Singles Energy = -0.0000000000000001 [H]; Same-Spin Energy = -0.0512503261762665 [H]; Opposite-Spin Energy = -0.1534098129352447 [H]; Correlation Energy = -0.2046601391115113 [H]; Total Energy = -76.2260576180779736 [H]; ----------------------------------------------------------; ==================> SCS-MP2 Energies <==================; ----------------------------------------------------------; SCS Same-Spin S",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/dfmp2-1.html:2381,energy,energy,2381,psi4manual/1.0.0/dfmp2-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/dfmp2-1.html,2,['energy'],['energy']
Energy Efficiency," rotation [deg/(dm (g/cm^3))] calculated at the CC2 level in the; length gauge for a given (x) wavelength, (x) rounded to nearest integer. CC2 SPECIFIC ROTATION (VEL) @ xNM¶; The specific rotation [deg/(dm (g/cm^3))] calculated at the CC2 level in the; velocity gauge for a given (x) wavelength, (x) rounded to nearest integer. CC2 SPECIFIC ROTATION (MVG) @ xNM¶; The specific rotation [deg/(dm (g/cm^3))] calculated at the CC2 level in the; modified velocity gauge for a given (x) wavelength, (x) rounded to nearest integer. CC QUADRUPOLE XX¶. CC QUADRUPOLE XY¶. CC QUADRUPOLE XZ¶. CC QUADRUPOLE YY¶. CC QUADRUPOLE YZ¶. CC QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; coupled cluster level of theory and root. CCSD TOTAL ENERGY¶. CCSD CORRELATION ENERGY¶. CCSDT TOTAL ENERGY¶. CCSDT CORRELATION ENERGY¶. CCSDTQ TOTAL ENERGY¶. CCSDTQ CORRELATION ENERGY¶. CCn TOTAL ENERGY¶. CCn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested full coupled-cluster (CCSD, CCSDT, up to CCn); level of theory. CCSD(T) TOTAL ENERGY¶. CCSD(T) CORRELATION ENERGY¶. A-CCSD(T) TOTAL ENERGY¶. A-CCSD(T) CORRELATION ENERGY¶. CCSDT(Q) TOTAL ENERGY¶. CCSDT(Q) CORRELATION ENERGY¶. CC(n-1)(n) TOTAL ENERGY¶. CC(n-1)(n) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the perturbatively corrected coupled-cluster (CCSD(T), a-CCSD(T), CCSDT(Q),; up to CC(n-1)(n) level of theory. CCSDT-1a TOTAL ENERGY¶. CCSDT-1a CORRELATION ENERGY¶. CCSDTQ-1a TOTAL ENERGY¶. CCSDTQ-1a CORRELATION ENERGY¶. CCn-1a TOTAL ENERGY¶. CCn-1a CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the approximate coupled-cluster (CCSD(T)-1a, CCSDT(Q)-1a,; up to CCn-1a) level of theory. CCSDT-1b TOTAL ENERGY¶. CCSDT-1b CORRELATION ENERGY¶. CCSDTQ-1b TOTAL ENERGY¶. CCSDTQ-1b CORRELATION ENERGY¶. CCn-1b TOTAL ENERGY¶. CCn-1b CORRELATION ENERGY¶; The total electronic e",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/glossary_psivariables-1.html:4751,energy,energy,4751,psi4manual/1.2.1/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/glossary_psivariables-1.html,8,['energy'],['energy']
Energy Efficiency," rotation calculation (length gauge only) at two frequencies on methyloxirane. dfccsd-grad2; DF-CCSD cc-pVDZ gradient for the NH molecule. dft-pruning; Tests all grid pruning options available and screening of small weights. Check against grid size. cc51; EOM-CC3/cc-pVTZ on H2O. opt7; Various constrained energy minimizations of HOOH with cc-pvdz RHF. For “fixed” coordinates, the final value is provided by the user. cbs-xtpl-gradient; Various gradients for a strained helium dimer and water molecule. sapt9; usapt example with empty beta. cc7; Tests CCENERGY’s CCSD gradient in the presence of a dipole field. mcscf2; TCSCF cc-pVDZ energy of asymmetrically displaced ozone, with Z-matrix input. dct5; DC-06 calculation for the O2 molecule (triplet ground state). This performs geometry optimization using two-step and simultaneous solution of the response equations for the analytic gradient. dfscf-bz2; Benzene Dimer DF-HF/cc-pVDZ. cepa1; cc-pvdz H2O Test CEPA(1) Energy. tu1-h2o-energy; Sample HF/cc-pVDZ H2O computation. cc56; EOM-CCSD/6-31g excited state transition data for water cation. cc3; cc3: RHF-CCSD/6-31G** H2O geometry optimization and vibrational frequency analysis by finite-differences of gradients. dfmp2-grad1; DF-MP2 cc-pVDZ gradients for the H2O molecule. opt-irc-2; Compute the IRC for HCN <-> NCH interconversion at the RHF/DZP level of theory. dft-ghost; DFT Functional Test for Range-Seperated Hybrids and Ghost atoms. freq-isotope2; Vibrational and thermo analysis of several water isotopologs. Demonstrates Hessian reuse for different temperatures, pressures, and isotopologs. scf-hess1; RHF STO-3G (Cartesian) and cc-pVDZ (spherical) water Hessian test, against Psi3 reference values. fnocc5; Test FNO-DF-CCSD(T) energy. dfmp2-grad5; Tests DF-MP2 gradient in the presence of a dipole field. scf-uhf-grad-nobeta; UHF gradient for a one-electron system (no beta electrons). cc10; ROHF-CCSD cc-pVDZ energy for the \(^2\Sigma^+\) state of the CN radical. dft-smoke; DFT Func",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html:6288,energy,energy,6288,psi4manual/master/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency," run in sow/reap mode. fsapt-allterms; This test case shows an example of running and analyzing a standard F-SAPT0/jun-cc-pvdz procedure for HSG-18-dimer from the HSG database. cc51; EOM-CC3/cc-pVTZ on H2O. opt12; SCF cc-pVDZ geometry optimzation of ketene, starting from bent structure. scf-ecp; Water-Argon complex with ECP present; check of energies and forces. nbody-freq; Vibrational and thermo analysis of water trimer (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). molden1; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. psimrcc-ccsd_t-3; Mk-MRCCSD(T) single point. \(^1A_1\) CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. cc5; RHF CCSD(T) aug-cc-pvtz frozen-core energy of C4NH4 Anion. mints8; Patch of a glycine with a methyl group, to make alanine, then DF-SCF energy calculation with the cc-pVDZ basis set. psimrcc-fd-freq2; Mk-MRCCSD frequencies. \(^1A_1\) O$_3` state described using the Ms = 0 component of the singlet. Uses TCSCF orbitals. dft-grad2; DF-BP86-D2 cc-pVDZ frozen core gradient of S22 HCN. cepa0-grad2; CEPA cc-pVDZ gradient for the NO radical. tu6-cp-ne2; Example potential energy surface scan and CP-correction for Ne2. sapt7; SAPT0 open-shell computation of H2O-HO2 interaction energy First with cc-pVDZ and density fitted integrals with UHF Then with 6-31g and direct integrals, except for dispersion that is computed with cc-pVDZ-ri density fitting with UHF. mints-benchmark; run some BLAS benchmarks. scf-bs; UHF and broken-symmetry UHF energy for molecular hydrogen. fci-tdm; He2+ FCI/cc-pVDZ Transition Dipole Moment. omp2p5-grad2; OMP2.5 cc-pVDZ gradient for the NO radical. fci-h2o-fzcv; 6-31G H2O Test FCI Energy Point. sa",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html:40336,energy,energy,40336,psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency," run_sapt_ct,; 'sapt2+(3)(ccd)-ct' : run_sapt_ct,; 'sapt2+3(ccd)-ct' : run_sapt_ct,; 'mp2c' : run_mp2c,; 'ccenergy' : run_ccenergy, # full control over ccenergy; 'ccsd' : run_ccenergy,; 'ccsd(t)' : run_ccenergy,; 'ccsd(at)' : run_ccenergy,; 'a-ccsd(t)' : run_ccenergy,; 'cc2' : run_ccenergy,; 'cc3' : run_ccenergy,; 'mrcc' : run_mrcc, # interface to Kallay's MRCC program; 'bccd' : run_bccd,; 'bccd(t)' : run_bccd_t,; 'eom-ccsd' : run_eom_cc,; 'eom-cc2' : run_eom_cc,; 'eom-cc3' : run_eom_cc,; 'detci' : run_detci, # full control over detci; 'mp' : run_detci, # arbitrary order mp(n); 'detci-mp' : run_detci, # arbitrary order mp(n); 'zapt' : run_detci, # arbitrary order zapt(n); 'cisd' : run_detci,; 'cisdt' : run_detci,; 'cisdtq' : run_detci,; 'ci' : run_detci, # arbitrary order ci(n); 'fci' : run_detci,; 'adc' : run_adc,; 'cphf' : run_libfock,; 'cis' : run_libfock,; 'tdhf' : run_libfock,; 'cpks' : run_libfock,; 'tda' : run_libfock,; 'tddft' : run_libfock,; 'psimrcc' : run_psimrcc,; 'psimrcc_scf' : run_psimrcc_scf,; 'hf' : run_scf,; 'rhf' : run_scf,; 'uhf' : run_scf,; 'rohf' : run_scf,; 'rscf' : run_scf,; 'uscf' : run_scf,; 'roscf' : run_scf,; 'qcisd' : run_fnocc,; 'qcisd(t)' : run_fnocc,; 'mp4(sdq)' : run_fnocc,; 'fno-ccsd' : run_fnocc,; 'fno-ccsd(t)' : run_fnocc,; 'fno-qcisd' : run_fnocc,; 'fno-qcisd(t)' : run_fnocc,; 'fno-mp3' : run_fnocc,; 'fno-mp4(sdq)' : run_fnocc,; 'fno-mp4' : run_fnocc,; 'fnocc-mp' : run_fnocc,; 'df-ccsd' : run_fnodfcc,; 'df-ccsd(t)' : run_fnodfcc,; 'fno-df-ccsd' : run_fnodfcc,; 'fno-df-ccsd(t)': run_fnodfcc,; 'fno-cepa(0)' : run_cepa,; 'fno-cepa(1)' : run_cepa,; 'fno-cepa(3)' : run_cepa,; 'fno-acpf' : run_cepa,; 'fno-aqcc' : run_cepa,; 'fno-sdci' : run_cepa,; 'fno-dci' : run_cepa,; 'cepa(0)' : run_cepa,; 'cepa(1)' : run_cepa,; 'cepa(3)' : run_cepa,; 'acpf' : run_cepa,; 'aqcc' : run_cepa,; 'sdci' : run_cepa,; 'dci' : run_cepa,; # Upon adding a method to this list, add it to the docstring in energy() below; # If you must add an alias to this list (e.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/driver.html:4473,energy,energy,4473,psi4manual/4.0b5/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/driver.html,1,['energy'],['energy']
Energy Efficiency, s] uncertainty=0.000 000 081 e-34. Planck_constant_in_eV_s; 4.135667662E-15; Planck constant in eV s [eV s] uncertainty=0.000 000 025 e-15. Planck_constant_over_2_pi; 1.054571800E-34; Planck constant over 2 pi [J s] uncertainty=0.000 000 013 e-34. Planck_constant_over_2_pi_in_eV_s; 6.582119514E-16; Planck constant over 2 pi in eV s [eV s] uncertainty=0.000 000 040 e-16. Planck_constant_over_2_pi_times_c_in_MeV_fm; 197.3269788; Planck constant over 2 pi times c in MeV fm [MeV fm] uncertainty=0.000 0012. Planck_length; 1.616229E-35; Planck length [m] uncertainty=0.000 038 e-35. Planck_mass; 2.176470E-8; Planck mass [kg] uncertainty=0.000 051 e-8. Planck_mass_energy_equivalent_in_GeV; 1.220910E+19; Planck mass energy equivalent in GeV [GeV] uncertainty=0.000 029 e19. Planck_temperature; 1.416808E+32; Planck temperature [K] uncertainty=0.000 033 e32. Planck_time; 5.39116E-44; Planck time [s] uncertainty=0.000 13 e-44. proton_charge_to_mass_quotient; 95788332.26; proton charge to mass quotient [C kg^{-1}] uncertainty=0.000 000 059 e7. proton_Compton_wavelength; 1.32140985396E-15; proton Compton wavelength [m] uncertainty=0.000 000 000 61 e-15. proton_Compton_wavelength_over_2_pi; 2.10308910109E-16; proton Compton wavelength over 2 pi [m] uncertainty=0.000 000 000 097 e-15. proton_electron_mass_ratio; 1836.15267389; proton-electron mass ratio [] uncertainty=0.000 000 17. proton_g_factor; 5.585694702; proton g factor [] uncertainty=0.000 000 017. proton_gyromag_ratio; 267522190.0; proton gyromag. ratio [s^{-1} T^{-1}] uncertainty=0.000 000 018 e8. proton_gyromag_ratio_over_2_pi; 42.57747892; proton gyromag. ratio over 2 pi [MHz T^{-1}] uncertainty=0.000 000 29. proton_mag_mom; 1.4106067873E-26; proton mag. mom. [J T^{-1}] uncertainty=0.000 000 0097 e-26. proton_mag_mom_to_Bohr_magneton_ratio; 0.0015210322053; proton mag. mom. to Bohr magneton ratio [] uncertainty=0.000 000 0046 e-3. proton_mag_mom_to_nuclear_magneton_ratio; 2.7928473508; proton mag. mom. to nuclear magneto,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodoc_physconst-1.html:28954,charge,charge,28954,psi4manual/1.3.2/autodoc_physconst-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodoc_physconst-1.html,11,['charge'],['charge']
Energy Efficiency," sapt-exch-disp-inf; SAPT0 with S^inf exch-disp20. dct-grad3; Restricted DF-DCT ODC-12 gradient for ethylene with cc-pVDZ/cc-pVDZ-RI standard/auxiliary basis set. fsapt1; This test case shows an example of running and analyzing a standard F-SAPT0/jun-cc-pvdz procedure for phenol dimer from the S22 database. dft-custom; DFT custom functional test. dfep2-1; Compute three IP and 2 EA’s for the PH3 molecule. cc30; CCSD/sto-3g optical rotation calculation (length gauge only) at two frequencies on methyloxirane. dfccd1; DF-CCD cc-pVDZ energy for the H2O molecule. sad1; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. cc47; EOM-CCSD/cc-pVDZ on H2O2 with two excited states in each irrep. scf-bs; UHF and broken-symmetry UHF energy for molecular hydrogen. dft-grad-lr3; wB97X-D test for a large UKS molecule update ref gradient due to new BraggSlater radii. dft-grad1; DF-BP86-D2 cc-pVDZ frozen core gradient of S22 HCN update ref gradient due to new BraggSlater radii. mbis-5; MBIS calculation on ZnO. lccd-grad1; LCCD cc-pVDZ gradient for the H2O molecule. omp2-2; OMP2 cc-pVDZ energy with ROHF initial guess orbitals for the NO radical. dfomp2-grad2; OMP2 cc-pVDZ energy for the NO molecule. ci-property; CI/MCSCF cc-pvDZ properties for Potassium nitrate (rocket fuel!). fd-freq-gradient-large; SCF DZ finite difference frequencies by gradients for C4NH4. pywrap-db2; Database calculation, run in sow/reap mode. psimrcc-pt2; Mk-MRPT2 single point. \(^1A_1\) F2 state described using the Ms = 0 component of the singlet. Uses TCSCF singlet orbitals. x2c-perturb-h; Test SFX2C-1e with a static electric field on He aug-cc-pVTZ. cepa-module; routing check on lccd, lccsd, cepa(0). cc34; RHF-CCSD/cc-pVDZ energy of H2O part",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html:32414,energy,energy,32414,psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency," scheme to be applied to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in corl_basis and xtpl_highest_1() otherwise. delta_scheme (function) – \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta_basis and xtpl_highest_1() otherwise. delta2_scheme (function) – \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the second delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta2_basis and xtpl_highest_1() otherwise. delta3_scheme (function) – \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the third delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta3_basis and xtpl_highest_1() otherwise. delta4_scheme (function) – \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the fourth delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta4_basis and xtpl_highest_1() otherwise. delta5_scheme (function) – \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the fifth delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta5_basis and xtpl_highest_1() otherwise. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples:. 1; 2>>> # [1] replicates with cbs() the s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/cbs-1.html:9416,energy,energy,9416,psi4manual/1.1.0/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/cbs-1.html,3,['energy'],['energy']
Energy Efficiency," second input file to perform; the vibrational frequency analysis, being very careful to copy over the; optimized geometry from the bottom of the output file for the geometry; optimization. This geometry could be specified in either z-matrix or; Cartesian formats. However, there’s a much easier way to do this. If we; specify a vibrational frequency analysis in the same input file as the; optimization, after the optimization function has been called, then the; optimized geometry will automatically be carried over.; So, it’s easiset to do the optimization and vibrational frequency analysis; together. This can be specified as follows (see test case; tu4-h2o-freq):; #! Optimization followed by frequencies H2O HF/cc-pVDZ. memory 250 mb. molecule h2o {; O ; H 1 0.96; H 1 0.96 2 104.5; }. set basis cc-pVDZ; optimize('scf'); scf_e, scf_wfn = frequencies('scf', return_wfn=True). The program will do the same optimization as in our previous example,; but then it will follow it with some computations to obtain the Hessian; (second derivative matrix) of the electronic energy with respect to; nuclear displacements. From this, it can obtain the harmonic vibrational; frequencies, given below (roundoff errors of around 0.1 cm-1; may exist):; Irrep Harmonic Frequency; (cm-1); -----------------------------------------------; A1 1775.6480; A1 4113.3794; B2 4212.1826; -----------------------------------------------. Notice that the symmetry type of the normal modes is specified (A1, A1,; B2). The program also prints out the normal modes in terms of Cartesian; coordinates of each atom. For example, the normal mode at 1776 cm-1; is:; Frequency: 1775.65; Force constant: 0.1193; X Y Z mass; O 0.000 0.000 -0.270 15.994915; H 0.000 0.417 0.538 1.007825; H 0.000 -0.417 0.538 1.007825. where the table shows the displacements in the X, Y, and Z dimensions for; each atom along the normal mode coordinate. (This information could be used; to animate the vibrational frequency using visualization sof",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/tutorial-1.html:8028,energy,energy,8028,psi4manual/1.0.0/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/tutorial-1.html,2,['energy'],['energy']
Energy Efficiency," see the mints1 input file in the samples; folder. It is also possible to mix Cartesian and Z-matrix geometry; specifications, as demonstrated in the mints4 sample input file. Multiple Molecules¶; To facilitate more elaborate computations, it is possible to provide a name for; each molecule, and tell PSI4 which one should be used in a given; calculation. For example, consider the following input file:; molecule h2{; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; energy('scf'). Here, two separate jobs are performed on two different molecules; the first is; performed on H2, while the second is for H atom. The last molecule to be; specified is the “active” molecule by default. To explicitly activate a named; molecule, the activate keyword is provided. Using this keyword, the above input; file can be equivalently written as follows:; molecule h2{; H; H 1 0.9; }. molecule h{; H; }. activate(h2); set basis cc-pvdz; set reference rhf; energy('scf'). activate(h); set basis cc-pvdz; set reference uhf; energy('scf'). Note that whenever the molecule is changed, the basis set must be specified; again. The following section provides more details about the job control; keywords used in the above examples. Molecule Keywords¶; In addition to specifying the geometry, additional information can be provided; in the molecule block. If two integers are encountered on any line of the; molecule block, they are interpreted as the molecular charge and multiplicity; (), respectively. The symmetry can be specified by a line reading; symmetry symbol, where symbol is; the Schönflies symbol of the (Abelian) point group to use for the; computation; see Sec. Symmetry for more details. This need not be; specified, as the molecular symmetry is automatically detected by PSI4.; Certain computations require that the molecule is not reoriented; this can be; achieved by adding either no_reorient or noreorient. By default,; Ångst",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:5511,energy,energy,5511,psi4manual/4.0b2/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html,4,['energy'],['energy']
Energy Efficiency," selecting the algorithm for a CCSD gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('CC_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ/ccenergy. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy_gradient; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy_gradient. if func is None:; raise ManagedMethodError(['select_ccsd_gradient', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_fnoccsd_t_(name, **kwargs):; """"""Function selecting the algorithm for a FNO-CCSD(T) energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('CC_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only fnocc. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'FNOCC']:; func = run_fnocc; elif mtd_type == 'DF':; if module in ['', 'FNOCC']:; func = run_fnodfcc; elif mtd_type == 'CD':; if module in ['', 'FNOCC']:; func = run_fnodfcc. if func is None:; raise ManagedMethodError(['select_fnoccsd_t_', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccsd_t_(name, **kwargs):; """"""Function selecting the algorithm for a CCSD(T) energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('CC_TYPE'); module = core.get_global_option('QC",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html:20823,energy,energy,20823,psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,6,['energy'],['energy']
Energy Efficiency," self.wfn.Da(); self.basis = self.wfn.basisset(); parser = PsiMod.Gaussian94BasisSetParser(); self.ribasis = PsiMod.BasisSet.construct(parser, self.molecule, ""DF_BASIS_SCF""). fitter = PsiMod.DFChargeFitter(); fitter.setPrimary(self.basis); fitter.setAuxiliary(self.ribasis); fitter.setD(self.Da); self.da = fitter.fit(); self.da.scale(2.0). [docs] def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = PsiMod.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs] def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs] def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / physconst.psi_bohr2angstroms, y / physconst.psi_bohr2angstroms, z / physconst.psi_bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs] def populateExtern(self):; """"""Function to define a charge field external to the; molecule through point and diffuse charges. """"""; # Charges; for charge in self.charges:; self.extern.addCharge(charge[0], charge[1], charge[2], charge[3]); # Diffuses; for diffuse in s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/qmmm.html:3062,charge,charges,3062,psi4manual/4.0b2/_modules/qmmm.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/qmmm.html,3,['charge'],['charges']
Energy Efficiency," separate; input file, but because counterpoise correction is a fairly standard; procedure for intermolecular interactions, PSI4 knows about it and has; a built-in routine to perform counterpoise correction. It only needs to; know what method you want to do the counterpoise correction on (here, let’s; consider CCSD(T)), and it needs to know what’s monomer A and what’s monomer; B. This last issue of specifying the monomers separately was already dealt; with in the previous SAPT example, where we saw that two dashes in the; molecule block can be used to separate monomers.; So, we’re going to do counterpoise-corrected CCSD(T) energies for Ne2 at; a series of different interatomic distances. And let’s print out a table; of the interatomic distances we’ve considered, and the CP-corrected CCSD(T); interaction energies (in kcal mol-1) at each geometry. Doing all this; in a single input is surprisingly easy in PSI4. Here’s the input; (available as tu6-cp-ne2).; #! Example potential energy surface scan and CP-correction for Ne2. memory 250 mb. molecule dimer {; Ne; --; Ne 1 R; }. Rvals=[2.5, 3.0, 4.0]. set basis aug-cc-pVDZ; set freeze_core True. # Initialize a blank dictionary of counterpoise corrected energies; # (Need this for the syntax below to work); ecp = {}. for R in Rvals:; dimer.R = R; ecp[R] = cp('ccsd(t)'). PsiMod.print_out(""\n""); PsiMod.print_out(""CP-corrected CCSD(T)/aug-cc-pVDZ interaction energies\n\n""); PsiMod.print_out("" R (Ang) E_int (kcal/mol) \n""); PsiMod.print_out(""-----------------------------------------------------\n""); for R in Rvals:; e = ecp[R] * 627.5095; PsiMod.print_out("" %3.1f %10.6f\n"" % (R, e)). First, you can see the molecule block has a couple dashes to; separate the monomers from each other. Also note we’ve used a Z-matrix to; specify the geometry, and we’ve used a variable (R) as the; interatomic distance. We have not specified the value of R in; the molecule block like we normally would. That’s because we’re; going to vary it during the ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/tutorial-1.html:16162,energy,energy,16162,psi4manual/4.0b3/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/tutorial-1.html,4,['energy'],['energy']
Energy Efficiency," separate; input file, but because counterpoise correction is a fairly standard; procedure for intermolecular interactions, PSI4 knows about it and has; a built-in routine to perform counterpoise correction. It only needs to; know what method you want to do the counterpoise correction on (here, let’s; consider CCSD(T)), and it needs to know what’s monomer A and what’s monomer; B. This last issue of specifying the monomers separately was already dealt; with in the previous SAPT example, where we saw that two dashes in the; molecule block can be used to separate monomers.; So, we’re going to do counterpoise-corrected CCSD(T) energies for Ne2 at; a series of different interatomic distances. And let’s print out a table; of the interatomic distances we’ve considered, and the CP-corrected CCSD(T); interaction energies (in kcal mol-1) at each geometry. Doing all this; in a single input is surprisingly easy in PSI4. Here’s the input; (available as tu6-cp-ne2).; #! Example potential energy surface scan and CP-correction for Ne2. memory 250 mb. molecule dimer {; Ne; --; Ne 1 R; }. Rvals=[2.5, 3.0, 4.0]. set basis aug-cc-pVDZ; set freeze_core True. # Initialize a blank dictionary of counterpoise corrected energies; # (Need this for the syntax below to work); ecp = {}. for R in Rvals:; dimer.R = R; ecp[R] = cp('ccsd(t)'). print ""\n""; print ""CP-corrected CCSD(T)/aug-cc-pVDZ interaction energies\n\n""; print "" R (Ang) E_int (kcal/mol) \n""; print ""-----------------------------------------------------\n""; for R in Rvals:; e = ecp[R] * 627.5095; print "" %3.1f %10.6f\n"" % (R, e). First, you can see the molecule block has a couple dashes to; separate the monomers from each other. Also note we’ve used a Z-matrix to; specify the geometry, and we’ve used a variable (R) as the; interatomic distance. We have not specified the value of R in; the molecule block like we normally would. That’s because we’re; going to vary it during the scan across the potential energy surface.; Below the molecul",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/tutorial-1.html:16136,energy,energy,16136,psi4manual/4.0b2/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/tutorial-1.html,2,['energy'],['energy']
Energy Efficiency," separate; input file, but because counterpoise correction is a fairly standard; procedure for intermolecular interactions, PSI4 knows about it and has; a built-in routine to perform counterpoise correction. It only needs to; know what method you want to do the counterpoise correction on (here, let’s; consider CCSD(T)), and it needs to know what’s monomer A and what’s monomer; B. This last issue of specifying the monomers separately was already dealt; with in the previous SAPT example, where we saw that two dashes in the; molecule block can be used to separate monomers.; So, we’re going to do counterpoise-corrected CCSD(T) energies for Ne2 at; a series of different interatomic distances. And let’s print out a table; of the interatomic distances we’ve considered, and the CP-corrected CCSD(T); interaction energies (in kcal mol-1) at each geometry. Doing all this; in a single input is surprisingly easy in PSI4. Here’s the input; (available as tu6-cp-ne2).; #! Example potential energy surface scan and CP-correction for Ne2. memory 250 mb. molecule dimer {; Ne; --; Ne 1 R; }. Rvals=[2.5, 3.0, 4.0]. set basis aug-cc-pVDZ; set freeze_core True. # Initialize a blank dictionary of counterpoise corrected energies; # (Need this for the syntax below to work); ecp = {}. for R in Rvals:; dimer.R = R; ecp[R] = cp('ccsd(t)'). psi4.print_out(""\n""); psi4.print_out(""CP-corrected CCSD(T)/aug-cc-pVDZ interaction energies\n\n""); psi4.print_out("" R (Ang) E_int (kcal/mol) \n""); psi4.print_out(""-----------------------------------------------------\n""); for R in Rvals:; e = ecp[R] * 627.5095; psi4.print_out("" %3.1f %10.6f\n"" % (R, e)). First, you can see the molecule block has a couple dashes to; separate the monomers from each other. Also note we’ve used a Z-matrix to; specify the geometry, and we’ve used a variable (R) as the; interatomic distance. We have not specified the value of R in; the molecule block like we normally would. That’s because we’re; going to vary it during the scan acros",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/tutorial-1.html:16010,energy,energy,16010,psi4manual/4.0b5/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/tutorial-1.html,2,['energy'],['energy']
Energy Efficiency," separate; input file, but because counterpoise correction is a fairly standard; procedure for intermolecular interactions, PSI4 knows about it and has; a built-in routine to perform counterpoise correction. It only needs to; know what method you want to do the counterpoise correction on (here, let’s; consider CCSD(T)), and it needs to know what’s monomer A and what’s monomer; B. This last issue of specifying the monomers separately was already dealt; with in the previous SAPT example, where we saw that two dashes in the; molecule block can be used to separate monomers.; So, we’re going to do counterpoise-corrected CCSD(T) energies for Ne2 at; a series of different interatomic distances. And let’s print out a table; of the interatomic distances we’ve considered, and the CP-corrected CCSD(T); interaction energies (in kcal mol-1) at each geometry. Doing all this; in a single input is surprisingly easy in PSI4. Here’s the input; (available as tu6-cp-ne2).; #! Example potential energy surface scan and CP-correction for Ne2. molecule dimer {; Ne; --; Ne 1 R; }. Rvals=[2.5, 3.0, 4.0]. set basis aug-cc-pVDZ; set freeze_core True. # Initialize a blank dictionary of counterpoise corrected energies; # (Need this for the syntax below to work); ecp = {}. for R in Rvals:; dimer.R = R; ecp[R] = energy('ccsd(t)', bsse_type = 'cp'). psi4.print_out(""\n""); psi4.print_out(""CP-corrected CCSD(T)/aug-cc-pVDZ interaction energies\n\n""); psi4.print_out("" R [Ang] E_int [kcal/mol] \n""); psi4.print_out(""-----------------------------------------------------\n""); for R in Rvals:; e = ecp[R] * psi_hartree2kcalmol; psi4.print_out("" %3.1f %10.6f\n"" % (R, e)). First, you can see the molecule block has a couple dashes to; separate the monomers from each other. Also note we’ve used a Z-matrix to; specify the geometry, and we’ve used a variable (R) as the; interatomic distance. We have not specified the value of R in; the molecule block like we normally would. That’s because we’re; going to vary it dur",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/tutorial-1.html:18011,energy,energy,18011,psi4manual/1.1.0/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/tutorial-1.html,15,['energy'],['energy']
Energy Efficiency," separate; input file, but because counterpoise correction is a fairly standard; procedure for intermolecular interactions, Psi4 knows about it and has; a built-in routine to perform counterpoise correction. It only needs to; know what method you want to do the counterpoise correction on (here, let’s; consider CCSD(T)), and it needs to know what’s monomer A and what’s monomer; B. This last issue of specifying the monomers separately was already dealt; with in the previous SAPT example, where we saw that two dashes in the; molecule block can be used to separate monomers.; So, we’re going to do counterpoise-corrected CCSD(T) energies for Ne2 at; a series of different interatomic distances. And let’s print out a table; of the interatomic distances we’ve considered, and the CP-corrected CCSD(T); interaction energies (in kcal mol-1) at each geometry. Doing all this; in a single input is surprisingly easy in Psi4. Here’s the input; (available as tu6-cp-ne2).; #! Example potential energy surface scan and CP-correction for Ne2. memory 250 mb. molecule dimer {; Ne; --; Ne 1 R; }. Rvals=[2.5, 3.0, 4.0]. set basis aug-cc-pVDZ; set freeze_core True. # Initialize a blank dictionary of counterpoise corrected energies; # (Need this for the syntax below to work); ecp = {}. for R in Rvals:; dimer.R = R; ecp[R] = energy('ccsd(t)', bsse_type = 'cp'). psi4.print_out(""\n""); psi4.print_out(""CP-corrected CCSD(T)/aug-cc-pVDZ interaction energies\n\n""); psi4.print_out("" R [Ang] E_int [kcal/mol] \n""); psi4.print_out(""-----------------------------------------------------\n""); for R in Rvals:; e = ecp[R] * psi_hartree2kcalmol; psi4.print_out("" %3.1f %10.6f\n"" % (R, e)). First, you can see the molecule block has a couple dashes to; separate the monomers from each other. Also note we’ve used a Z-matrix to; specify the geometry, and we’ve used a variable (R) as the; interatomic distance. We have not specified the value of R in; the molecule block like we normally would. That’s because we’re; going",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/tutorial-1.html:17247,energy,energy,17247,psi4manual/1.0.0/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/tutorial-1.html,2,['energy'],['energy']
Energy Efficiency," sequence of PSI module calls for; a [FNO-](DF|CD)-CCSD[(T)] computation. >>> set cc_type df; >>> energy('fno-ccsd(t)'). """"""; kwargs = p4util.kwargs_lower(kwargs); dtl = docs_table_link(""dummy"", ""fnocc""). # stash user options; optstash = p4util.OptionsState(; ['FNOCC', 'COMPUTE_TRIPLES'],; ['FNOCC', 'DFCC'],; ['FNOCC', 'NAT_ORBS'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'DF_BASIS_CC'],; ['SCF', 'DF_BASIS_SCF'],; ['SCF', 'DF_INTS_IO']). def set_cholesky_from(type_val):; if type_val == 'CD':; core.set_local_option('FNOCC', 'DF_BASIS_CC', 'CHOLESKY'); # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; optstash.add_option(['SCF_TYPE']); core.set_global_option('SCF_TYPE', 'CD'); core.print_out("""""" SCF Algorithm Type (re)set to CD.\n""""""). elif type_val in ['DISK_DF', 'DF']:; if core.get_option('FNOCC', 'DF_BASIS_CC') == 'CHOLESKY':; core.set_local_option('FNOCC', 'DF_BASIS_CC', ''). proc_util.check_disk_df(name.upper(), optstash); else:; raise ValidationError(f""Invalid type {type_val} for FNOCC energy through `run_fnodfcc`. See Capabilities Table at {dtl}""). director = {; # Note ""nat_orbs"" not set defensively False for non-""fno"" calls; ""ccsd"": { ""dfcc"": True, ""run_cepa"": False, ""compute_triples"": False,},; ""fno-ccsd"": {""nat_orbs"": True, ""dfcc"": True, ""run_cepa"": False, ""compute_triples"": False,},. ""ccsd(t)"": { ""dfcc"": True, ""run_cepa"": False, ""compute_triples"": True, },; ""fno-ccsd(t)"": {""nat_orbs"": True, ""dfcc"": True, ""run_cepa"": False, ""compute_triples"": True, },; }. if name not in director:; raise ValidationError(f""Invalid method {name} for FNOCC energy""). # throw exception for open-shells; if (ref := core.get_option(""SCF"", ""REFERENCE"")) != ""RHF"":; raise ValidationError(f""Invalid reference type {ref} != RHF for FNOCC energy. See Capabilities Table at {dtl}.""). # throw exception for CONV (approximately). after defaulting logic, throw exception for SCF_TYPE CONV (approximately); set_cholesky_from(method_algorithm_type(name).now); if (scf_type := co",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:167543,energy,energy,167543,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,4,['energy'],['energy']
Energy Efficiency," set and auxiliary basis sets are assigned by atom type. cfour/mp2-1; All-electron MP2 6-31G** geometry optimization of water. cfour/sp-rohf-scf; single-point HF/qz2p on NH2. cfour/sp-rhf-cc3; single-point CC3/qz2p on water. cfour/sp-rhf-ccsd_t_-ao; single-point CCSD(T)/qz2p on water with aobasis. cfour/puream; Basis set spherical/Cartesian behavior in cfour. cfour/sp-rohf-ccsd_t_-ao-ecc; single-point CCSD(T)/qz2p on NH2 with ecc, aobasis. cfour/sp-rohf-mp2-sc; single-point MP2/qz2p on NH2. cfour/sp-rhf-ccsd-ao; single-point CCSD/qz2p on water with aobasis. cfour/psi-mp4; MP4 energy components. Checks that computed identically between cfour and psi4. cfour/sp-rohf-ccsd_t_-fc; single-point CCSD(T)/qz2p on NH2 with ecc, aobasis, frozen-core. cfour/sp-rhf-scf; single-point HF/qz2p on water. cfour/pywrap-db1; Database calculation, so no molecule section in input file. Portions of the full databases, restricted by subset keyword, are computed by sapt0 and dfmp2 methods. cfour/psi-rhf-mp3; MP3 energy components. Checks that computed identically between cfour and psi4. cfour/pywrap-cbs1; Various basis set extrapolation tests only in Cfour instead of Psi4. cfour/sp-rohf-mp4-sc; single-point MP4/qz2p on NH2. cfour/kw-6; Basis set spherical/Cartesian with cfour_basis and puream. cfour/kw-1; testing best practices options, part i. cfour/sp-uhf-scf; single-point HF/qz2p on NH2. cfour/kw-8; Translating psi4 options to cfour, part ii. cfour/kw-3; Basis set spherical/Cartesian with cfour_basis and cfour_spherical. cfour/opt-rhf-ccsd_t_-ecc; optimization CCSD(T)/dzp on water with ecc, aobasis. cfour/sp-rohf-ccsd_t_; single-point CCSD(T)/qz2p on NH2. cfour/sp-rhf-ccsd_t_-ecc; single-point CCSD(T)/qz2p on water with ecc module. cfour/sp-rohf-ccsd-ao; single-point CCSD/qz2p on NH2 with aobasis. cfour/kw-2; testing best practices options, part ii. cfour/sp-uhf-ccsd_t_-ecc; single-point CCSD(T)/qz2p on NH2 with ecc. cfour/scf4; RHF cc-pVDZ energy for water, automatically scanning the sy",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_cfour.html:2879,energy,energy,2879,psi4manual/1.9.x/autodoc_testsuite_cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_cfour.html,1,['energy'],['energy']
Energy Efficiency," set and computed correctly. Now also testing that CSX harvesting PSI variables correctly update ref_dft_2e/xc due to new BraggSlater radii. pywrap-align; apply linear fragmentation algorithm to a water cluster. scf-hess2; UHF STO-3G (Cartesian) and cc-pVDZ (spherical) water Hessian test, against Psi3 reference values. This test should match RHF values exactly. cc13c; Tests RHF CCSD(T)gradients. dct-grad3; Restricted DF-DCT ODC-12 gradient for ethylene with cc-pVDZ/cc-pVDZ-RI standard/auxiliary basis set. fnocc1; Test QCISD(T) for H2O/cc-pvdz Energy. sapt3; SAPT2+3(CCD) aug-cc-pVDZ+midbond computation of the water dimer interaction energy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. cc8; UHF-CCSD(T) cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Z-matrix input. fci-tdm; He2+ FCI/cc-pVDZ Transition Dipole Moment. dfmp2-grad4; DF-MP2 cc-pVDZ gradient for the NO molecule. cc9; UHF-CCSD(T) cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Z-matrix input. casscf-fzc-sp; CASSCF/6-31G** energy point. opt10; 6-31G MP2 transition-state optimization with initial, computed Hessian. fnocc6; Test method/basis with disk_df. pywrap-checkrun-uhf; This checks that all energy methods can run with a minimal input and set symmetry. scf11-freq-from-energies; Test frequencies by finite differences of energies for planar C4NH4 TS. sapt0-d; Tests SAPT0-D corrections, with a variety of damping functions/parameters. dct7; DCT calculation for the triplet O2 using ODC-06 and ODC-12 functionals. Only simultaneous algorithm is tested. cc32; CC3/cc-pVDZ H2O \(R_e\) geom from Olsen et al., JCP 104, 8007 (1996). cc15; RHF-B-CCD(T)/6-31G** H2O single-point energy (fzc, MO-basis \(\langle ab|cd \rangle\)). fci-h2o-2; 6-31G H2O Test FCI Energy Point. dct10; The multiple guesses for DCT amplitudes for ODC-12. mints-benchmark; run some BLAS benchmarks. cepa2; cc-pvdz H2O Test ACPF Energy/Properties. cc45; RHF-EOM",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html:20468,energy,energy,20468,psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency," set appropriately when return_wfn specified. Parameters:. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element of a tuple. bsse_type (str or list) – 'cp' || ['nocp', 'vmfc'] || \(\Rightarrow\) None \(\Leftarrow\) || etc.; Type of BSSE correction to compute: CP for counterpoise correction, NoCP; for plain supramolecular interaction energy, or VMFC for Valiron-Mayer; Function Counterpoise correction. If a list is provided, the first string in; the list determines which interaction or total energies/gradients/Hessians are; returned by this function. By default, many-body treatments are inactive. max_nbody (int) – 3 || etc.; Maximum n-body to compute, cannot exceed the number of fragments in the molecule. return_total_data (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); If True returns the total data (energy/gradient/Hessian) of the system,; otherwise returns interaction data. Default is 'off' for energies,; 'on' for gradients and Hessians. Note that the calculation of total; counterpoise corrected energies implies the calculation of the energies of; monomers in the monomer basis, hence specifying return_total_data = True; may carry out more computations than return_total_data = False.; For gradients and Hessians, return_total_data = False is rarely useful. levels (dict) – {1: 'ccsd(t)', 2: 'mp2', 'supersystem': 'scf'} || {1: 2, 2: 'ccsd(t)', 3: 'mp2'} || etc; Dictionary of different levels of theory for different levels of expansion; Note that method_string is not used in this case. supersystem computes; all higher order n-body effects up to the number of fragments. embedding_charges (dict) – {1: [-0.834, 0.417, 0.417], ..}; Dictionary of atom-centered point charges. keys: 1-based index of fragment, values: list of charges for each fragment.; Add atom-centered point",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/nbody.html:1694,energy,energy,1694,psi4manual/1.7.x/nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/nbody.html,4,['energy'],['energy']
Energy Efficiency," set as usual, then translates; the basis set format and writes out a GENBAS file with an entry for; each atom. The P4C4 interface sets keyword CFOUR_BASIS=SPECIAL; and CFOUR_SPHERICAL as appropriate, then writes the basis section; necessary for SPECIAL below the *CFOUR(...) block. (I’m sorry that the; name of the basis doesn’t appear in ZMAT, but the combination of the; ~14 character basis name limit and the absence of a comment line marker; rather precludes that helpful label.); The input below employs a PSI4 library basis set and also introduces; the final stage of conversion toward PSI4 format. Instead of the; generic 'cfour', the computational method is specified as the first; argument to the optimize() call. In the computational; command below, the string argument 'c4-ccsd(t)' directs that a CCSD(T); computation be run using Cfour (as opposed to 'ccsd(t)' which would; call PSI4 CC code). Specifying computational method in this manner; sets CFOUR_CALC_LEVEL from the argument and; CFOUR_DERIV_LEVEL as appropriate from the function call:; energy(), gradient(), or; optimize(). If those keywords are also set explicitly to; contradictory values, the interface will complain.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19memory 2 gb. molecule CH2F2 {; units au; C 0.0000000000 -0.0000000000 1.0890958457; F 0.0000000000 -2.1223155812 -0.4598161475; F -0.0000000000 2.1223155812 -0.4598161475; H 1.7084139850 0.0000000000 2.1841068002; H -1.7084139850 -0.0000000000 2.1841068002; }. set basis aug-cc-pvdz; set rms_force_g_convergence 6; set cfour_abcdtype aobasis; set cfour_scf_conv 12; set cfour_cc_conv 12; set cfour_lineq_conv 12. optimize('c4-ccsd(t)'). The utility of this method specification is that examination can be made; of the reference, the derivative level, the excitation level, etc. and; some options can be set according to best practices. Practically speaking,; CFOUR_CC_PROGRAM (and eventually CFOUR_ABCDTYPE) will; always be set to the fastest",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/cfour-1.html:11617,energy,energy,11617,psi4manual/1.2.1/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/cfour-1.html,6,['energy'],['energy']
Energy Efficiency," set as usual, then translates; the basis set format and writes out a GENBAS file with an entry for; each atom. The P4C4 interface sets keyword CFOUR_BASIS=SPECIAL; and CFOUR_SPHERICAL as appropriate, then writes the basis section; necessary for SPECIAL below the *CFOUR(...) block. (I’m sorry that the; name of the basis doesn’t appear in ZMAT, but the combination of the; ~14 character basis name limit and the absence of a comment line marker; rather precludes that helpful label.); The input below employs a PSI4 library basis set and also introduces; the final stage of conversion toward PSI4 format. Instead of the; generic 'cfour', the computational method is specified as the first; argument to the optimize() call. In the computational; command below, the string argument 'c4-ccsd(t)' directs that a CCSD(T); computation be run using Cfour (as opposed to 'ccsd(t)' which would; call PSI4 CC code). Specifying computational method in this manner; sets CFOUR_CALC_LEVEL from the argument and; CFOUR_DERIV_LEVEL as appropriate from the function call:; energy(), gradient(), or; optimize(). If those keywords are also set explicitly to; contradictory values, the interface will complain.; memory 2 gb. molecule CH2F2 {; units au; C 0.0000000000 -0.0000000000 1.0890958457; F 0.0000000000 -2.1223155812 -0.4598161475; F -0.0000000000 2.1223155812 -0.4598161475; H 1.7084139850 0.0000000000 2.1841068002; H -1.7084139850 -0.0000000000 2.1841068002; }. set basis aug-cc-pvdz; set rms_force_g_convergence 6; set cfour_abcdtype aobasis; set cfour_scf_conv 12; set cfour_cc_conv 12; set cfour_lineq_conv 12. optimize('c4-ccsd(t)'). The utility of this method specification is that examination can be made; of the reference, the derivative level, the excitation level, etc. and; some options can be set according to best practices. Practically speaking,; CFOUR_CC_PROGRAM (and eventually CFOUR_ABCDTYPE) will; always be set to the fastest safe value.; For example, the input above will run with CFOUR_CC",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/cfour-1.html:11377,energy,energy,11377,psi4manual/1.4.0/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/cfour-1.html,9,['energy'],['energy']
Energy Efficiency," set as usual, then translates; the basis set format and writes out a GENBAS file with an entry for; each atom. The P4C4 interface sets keyword CFOUR_BASIS=SPECIAL; and CFOUR_SPHERICAL as appropriate, then writes the basis section; necessary for SPECIAL below the *CFOUR(...) block. (I’m sorry that the; name of the basis doesn’t appear in ZMAT, but the combination of the; ~14 character basis name limit and the absence of a comment line marker; rather precludes that helpful label.); The input below employs a Psi4 library basis set and also introduces; the final stage of conversion toward Psi4 format. Instead of the; generic 'cfour', the computational method is specified as the first; argument to the optimize() call. In the computational; command below, the string argument 'c4-ccsd(t)' directs that a CCSD(T); computation be run using Cfour (as opposed to 'ccsd(t)' which would; call Psi4 CC code). Specifying computational method in this manner; sets CFOUR_CALC_LEVEL from the argument and; CFOUR_DERIV_LEVEL as appropriate from the function call:; energy(), gradient(), or; optimize(). If those keywords are also set explicitly to; contradictory values, the interface will complain.; memory 2 gb. molecule CH2F2 {; units au; C 0.0000000000 -0.0000000000 1.0890958457; F 0.0000000000 -2.1223155812 -0.4598161475; F -0.0000000000 2.1223155812 -0.4598161475; H 1.7084139850 0.0000000000 2.1841068002; H -1.7084139850 -0.0000000000 2.1841068002; }. set basis aug-cc-pvdz; set rms_force_g_convergence 6; set cfour_abcdtype aobasis; set cfour_scf_conv 12; set cfour_cc_conv 12; set cfour_lineq_conv 12. optimize('c4-ccsd(t)'). The utility of this method specification is that examination can be made; of the reference, the derivative level, the excitation level, etc. and; some options can be set according to best practices. Practically speaking,; CFOUR_CC_PROGRAM (and eventually CFOUR_ABCDTYPE) will; always be set to the fastest safe value.; For example, the input above will run with CFOUR_CC",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/cfour-1.html:11390,energy,energy,11390,psi4manual/1.0.0/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/cfour-1.html,2,['energy'],['energy']
Energy Efficiency," set by orbital basis for all df/castup parts of calc. Demonstrates that answer doesn’t depend on presence/absence of castup. Demonstrates (by comparison to castup2) that output file doesn’t depend on options (scf_type) being set global or local. This input uses local. scf-ecp2; Water-Argon complex with ECP present; check of RHF Hessian. fnocc7; Test fnocc with linear dependencies. props4; Electrostatic potential and electric field evaluated on a grid around water. scf-ecp; Water-Argon complex with ECP present; check of energies and forces. cc9; UHF-CCSD(T) cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Z-matrix input. gibbs; Test Gibbs free energies at 298 K of N2, H2O, and CH4. scf-guess-read2; Test if the the guess read in the same basis converges. nbody-he-cluster; MP2/aug-cc-pv[DT]Z many body energies of an arbitrary Helium complex Size vs cost tradeoff is rough here. omp2-grad1; OMP2 cc-pVDZ gradient for the H2O molecule. dfomp2-3; OMP2 cc-pVDZ energy for the H2O molecule. dfcasscf-sa-sp; Example of state-averaged CASSCF for the C2 molecule. dfmp2-fc; Kr–Kr nocp energies with all-electron basis set to check frozen core. dft-grad-lr3; wB97X-D test for a large UKS molecule update ref gradient due to new BraggSlater radii. fcidump; test FCIDUMP functionality for rhf/uhf. dfomp2p5-2; DF-OMP2.5 cc-pVDZ energy for the H2O+ cation. sapt4; SAPT2+(3) aug-cc-pVDZ computation of the formamide dimer interaction energy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. This example uses frozen core as well as MP2 natural orbital approximations. omp3-3; OMP3 cc-pCVDZ energy with B3LYP initial guess for the NO radical. olccd2; OLCCD cc-pVDZ energy with B3LYP initial guess for the NO radical. nbody-convergence; Convergence of many-body gradients of different BSSE schemes. sapt-dft-api; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. cc46; EOM-CC2/cc-pVDZ on H2O2 with two excited states in each irrep. p",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html:45609,energy,energy,45609,psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency," set gradient_write on; >>> G, wfn = gradient('b3lyp-d', return_wfn=True); >>> wfn.gradient().print_out(); >>> np.array(G). """"""; kwargs = p4util.kwargs_lower(kwargs). # Figure out what kind of gradient this is; if hasattr(name, '__call__'):; if name.__name__ in ['cbs', 'complete_basis_set']:; gradient_type = 'cbs_wrapper'; else:; # Bounce to name if name is non-CBS function; gradient_type = 'custom_function'; elif kwargs.get('bsse_type', None) is not None:; gradient_type = 'nbody_gufunc'; elif '/' in name:; gradient_type = 'cbs_gufunc'; else:; gradient_type = 'conventional'. # Figure out lowername, dertype, and func; # If we have analytical gradients we want to pass to our wrappers, otherwise we want to run; # finite-diference energy or cbs energies; # TODO MP5/cc-pv[DT]Z behavior unkown due to ""levels""; user_dertype = kwargs.pop('dertype', None); if gradient_type == 'custom_function':; if user_dertype is None:; dertype = 0; core.print_out(; ""\nGradient: Custom function passed in without a defined dertype, assuming fd-energy based gradient.\n""; ); else:; core.print_out(""\nGradient: Custom function passed in with a dertype of %d\n"" % user_dertype); dertype = user_dertype. if dertype == 1:; return name(gradient, kwargs.pop('label', 'custom function'), ptype='gradient', **kwargs); else:; optstash = driver_util._set_convergence_criterion('energy', 'scf', 8, 10, 8, 10, 8); lowername = name. elif gradient_type == 'nbody_gufunc':; return driver_nbody.nbody_gufunc(gradient, name, ptype='gradient', **kwargs). elif gradient_type == 'cbs_wrapper':; cbs_methods = driver_cbs._cbs_wrapper_methods(**kwargs); dertype = min([_find_derivative_type('gradient', method, user_dertype) for method in cbs_methods]); if dertype == 1:; # Bounce to CBS (directly) in pure-gradient mode if name is CBS and all parts have analytic grad. avail.; return name(gradient, kwargs.pop('label', 'custom function'), ptype='gradient', **kwargs); else:; optstash = driver_util._set_convergence_criterion('energy",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html:37806,energy,energy,37806,psi4manual/1.3.2/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html,1,['energy'],['energy']
Energy Efficiency," set reference uhf; energy('scf'). Here, two separate jobs are performed on two different molecules; the first is; performed on H2, while the second is for H atom. The last molecule to be; specified is the “active” molecule by default. To explicitly activate a named; molecule, the activate keyword is provided. Using this keyword, the above input; file can be equivalently written as follows:; molecule h2{; H; H 1 0.9; }. molecule h{; H; }. activate(h2); set basis cc-pvdz; set reference rhf; energy('scf'). activate(h); set basis cc-pvdz; set reference uhf; energy('scf'). Note that whenever the molecule is changed, the basis set must be specified; again. The following section provides more details about the job control; keywords used in the above examples. Molecule Keywords¶; In addition to specifying the geometry, additional information can be; provided in the molecule optional_molecule_name {...} block.; If two integers charge multiplicity are encountered on any; line of the molecule block, they are interpreted as the molecular charge; and multiplicity (), respectively. The symmetry; can be specified by a line reading symmetry symbol, where; symbol is the Schönflies symbol of the; (Abelian) point group to use for the computation. This need not be; specified, as the molecular symmetry is automatically detected by; PSI4. Certain computations require that the molecule is not; reoriented; this can be achieved by adding either no_reorient or; noreorient. By default, Ångström units are used; this is changed by; adding a line that reads units spec, where spec is one; of ang, angstrom, a.u., au, or bohr. Ghost Atoms¶; While many common computations, such as SAPT and counterpoise corrections, can; be greatly simplified using the notation described in Non-Covalently Bonded Molecule Fragments,; manual specification of ghost atoms is sometimes required. Either; molecule he2 {; He; Gh(He) 1 2.0; }. or; molecule he2 {; He; @He 1 2.0; }. will generate a helium dimer, with the secon",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:7657,charge,charge,7657,psi4manual/4.0b4/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html,8,['charge'],['charge']
Energy Efficiency," set. This can be done simply in the input by adding “-decontract” to the; name of the primary basis you want to use for the calculation as detailed in; Decontracted Basis Sets. Publications resulting from the use; of X2C should cite the following publication: [Verma:2015]. Theory¶; X2C is based on exact decoupling of; positive-energy ( ; ) and negative-energy ( ); blocks of the Dirac Hamiltonian (). The transformation ( ) is obtained from the solutions of the Dirac equation in kinetically balanced basis [Kutzelnigg:1984] treatment.; In the X2C treatment, the positive-energy block of the Hamiltonian ( ); is given by the sum; of a transformed kinetic () and potential energy ( ) contribution.; Relativistic kinetic energy ( ) and nuclear-electron interaction potential ( ) is given interms of non-relativisitc kinetic () energy and nuclear-electron interaction potential (), coupling matrix ( ) and renormalization matrix ( ). The coupling matrix ( ) is obtained from the large () and small () components of the positive energy solutions of the Dirac equation.; The renormalization matrix; ,; depends on the modified overlap matrix; . The integrals can be easily computed as derivatives of the nuclear-electron attraction integrals with respect to nuclear coordinates.; Existing nonrelativistic electronic structure code can be extended to include scalar relativistic effects; treated with the X2C method by replacing nonrelativistic kinetic and potential energy with the corresponding; X2C operators and . It is important to note that fully uncontracted basis in needed for the construction of X2C Hamiltonian as Foldy-Wouthuysen (FW [FW:1950]) transformation is obtained in kinetically balance basis. Keywords¶. RELATIVISTIC¶. Relativistic Hamiltonian type. Type: string; Possible Values: NO, X2C; Default: NO. REL_BASIS¶. Whether to uncontract the basis set in a dual basis calculation. Type: string; Default: No Default. Table Of Contents. Scalar relativistic Hamiltonians; A First Example",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/relativistic-1.html:3599,energy,energy,3599,psi4manual/1.0.0/relativistic-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/relativistic-1.html,2,['energy'],['energy']
Energy Efficiency," set_ghost_fragment(self: psi4.core.Molecule, arg0: int) → None¶; Sets the specified fragment arg0 to be Ghost. set_ghost_fragments(self: psi4.core.Molecule, arg0: List[int]) → None¶; Sets the specified list arg0 of fragments to be Ghost. set_input_units_to_au(self: psi4.core.Molecule, arg0: float) → None¶; Sets unit conversion to [a0] for geometry. set_mass(self: psi4.core.Molecule, atom: int, mass: float) → None¶; Sets mass of atom (0-indexed) to mass (good for isotopic substitutions). set_molecular_charge(self: psi4.core.Molecule, arg0: int) → None¶; Change the overall molecular charge. Setting in initial molecule string or constructor preferred. set_multiplicity(self: psi4.core.Molecule, arg0: int) → None¶; Change the multiplicity (defined as 2S + 1). Setting in initial molecule string or constructor preferred. set_name(self: psi4.core.Molecule, arg0: str) → None¶; Sets molecule name. set_nuclear_charge(self: psi4.core.Molecule, arg0: int, arg1: float) → None¶; Set the nuclear charge of the given atom arg0 to the value arg1 (primarily for ECP). set_point_group(self: psi4.core.Molecule, arg0: psi4.core.PointGroup) → None¶; Sets the molecular point group to the point group object arg0. set_provenance(self: psi4.core.Molecule, arg0: Dict[str, str]) → None¶; Sets molecule provenance. set_units(self: psi4.core.Molecule, arg0: psi4.core.GeometryUnits) → None¶; Sets units (Angstrom or Bohr) used to define the geometry. Imposes Psi4 physical constants conversion for input_units_to_au. set_variable(self: psi4.core.Molecule, arg0: str, arg1: float) → None¶; Sets the value arg1 to the variable arg0 in the list of structure variables, then calls update_geometry(). symbol(self: psi4.core.Molecule, atom: int) → str¶; Gets the cleaned up label of atom (C2 => C, H4 = H) (0-indexed without dummies). symmetrize(self: psi4.core.Molecule, arg0: float) → None¶; Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry. s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.molecule.html:33606,charge,charge,33606,psi4manual/1.3.2/api/psi4.core.molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.molecule.html,9,['charge'],['charge']
Energy Efficiency," set_ghost_fragment(self: psi4.core.Molecule, arg0: int) → None¶; Sets the specified fragment arg0 to be Ghost. set_ghost_fragments(self: psi4.core.Molecule, arg0: list[int]) → None¶; Sets the specified list arg0 of fragments to be Ghost. set_input_units_to_au(self: psi4.core.Molecule, arg0: float) → None¶; Sets unit conversion to [a0] for geometry. set_mass(self: psi4.core.Molecule, atom: int, mass: float) → None¶; Sets mass of atom (0-indexed) to mass (good for isotopic substitutions). set_molecular_charge(self: psi4.core.Molecule, arg0: int) → None¶; Change the overall molecular charge. Setting in initial molecule string or constructor preferred. set_multiplicity(self: psi4.core.Molecule, arg0: int) → None¶; Change the multiplicity (defined as 2S + 1). Setting in initial molecule string or constructor preferred. set_name(self: psi4.core.Molecule, arg0: str) → None¶; Sets molecule name. set_nuclear_charge(self: psi4.core.Molecule, arg0: int, arg1: float) → None¶; Set the nuclear charge of the given atom arg0 to the value arg1 (primarily for ECP). set_point_group(self: psi4.core.Molecule, arg0: psi4.core.PointGroup) → None¶; Sets the molecular point group to the point group object arg0. set_provenance(self: psi4.core.Molecule, arg0: dict[str, str]) → None¶; Sets molecule provenance. set_units(self: psi4.core.Molecule, arg0: psi4.core.GeometryUnits) → None¶; Sets units (Angstrom or Bohr) used to define the geometry. Imposes Psi4 physical constants conversion for input_units_to_au. set_variable(self: psi4.core.Molecule, arg0: str, arg1: float) → None¶; Sets the value arg1 to the variable arg0 in the list of structure variables, then calls update_geometry(). symbol(self: psi4.core.Molecule, atom: int) → str¶; Gets the cleaned up label of atom (C2 => C, H4 = H) (0-indexed without dummies). symmetrize(self: psi4.core.Molecule, arg0: float) → None¶; Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry. s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/api/psi4.core.Molecule.html:36577,charge,charge,36577,psi4manual/master/api/psi4.core.Molecule.html,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.Molecule.html,1,['charge'],['charge']
Energy Efficiency," set_xclib_description(self, arg0); Sets the LibXC version and citation string. test_functional(self, arg0, arg1, arg2, ...); Quick testing capabilities. value(self, arg0); Returns a given internal value. values(self); Return all internal values. vv10_b(self); The VV10 b parameter. vv10_c(self); The VV10 c parameter. x_alpha(self); Amount of exact HF exchange. x_beta(self); Amount of exact HF exchange. x_functional(self, arg0); Returns the desired X Functional. x_functionals(self); Returns all X Functionals. x_omega(self); Range-seperated exchange parameter. xclib_description(self); LibXC version and citation string. Methods Documentation. static XC_build(arg0: str, arg1: bool) → psi4.core.SuperFunctional¶; Builds a SuperFunctional from a XC string. add_c_functional(self: psi4.core.SuperFunctional, arg0: psi4.core.Functional) → None¶; Add a correlation Functional. add_x_functional(self: psi4.core.SuperFunctional, arg0: psi4.core.Functional) → None¶; Add a exchange Functional. allocate(self: psi4.core.SuperFunctional) → None¶; Allocates the vectors, should be called after ansatz or npoint changes. ansatz(self: psi4.core.SuperFunctional) → int¶; SuperFunctional rung. static blank() → psi4.core.SuperFunctional¶; Initialize a blank SuperFunctional. c_alpha(self: psi4.core.SuperFunctional) → float¶; Amount of MP2 correlation. c_functional(self: psi4.core.SuperFunctional, arg0: str) → psi4.core.Functional¶; Returns the desired C Functional. c_functionals(self: psi4.core.SuperFunctional) → List[psi4.core.Functional]¶; Returns all C Functionals. c_omega(self: psi4.core.SuperFunctional) → float¶; Range-seperated correlation parameter. c_os_alpha(self: psi4.core.SuperFunctional) → float¶; Amount of SS MP2 correlation. c_ss_alpha(self: psi4.core.SuperFunctional) → float¶; Amount of OS MP2 correlation. citation(self: psi4.core.SuperFunctional) → str¶; SuperFunctional citation. compute_functional(self: psi4.core.SuperFunctional, vals: Dict[str, psi4.core.Vector], npoints: int = -",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/api/psi4.core.SuperFunctional.html:4400,allocate,allocate,4400,psi4manual/1.8.x/api/psi4.core.SuperFunctional.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.SuperFunctional.html,1,['allocate'],['allocate']
Energy Efficiency," shell reference determinant, it must be zero otherwise. This becomes nsing (option #2) in fort.56. Type: integer; Default: 1. MRCC_NUM_TRIPLET_ROOTS¶. Number of triplet roots. (Strictly speaking number of of roots with \(M_s=0\) and S is odd.) See notes at option MRCC_NUM_SINGLET_ROOTS This becomes ntrip (option #3) in fort.56. Type: integer; Default: 0. Expert¶. MRCC_METHOD¶. If more than one root is requested and calc=1, LR-CC (EOM-CC) calculation is performed automatically for the excited states. This overrides all automatic determination of method and will only work with energy(). This becomes CC/CI (option #5) in fort.56. See Table MRCC_METHOD for details. Type: integer; Default: 1. MRCC_OMP_NUM_THREADS¶. Sets the OMP_NUM_THREADS environment variable before calling MRCC. If the environment variable OMP_NUM_THREADS is set prior to calling Psi4 then that value is used. When set, this option overrides everything. Be aware the -n command-line option described in section Threading does not affect MRCC. Type: integer; Default: 1. MRCC_RESTART¶. The program restarts from the previously calculated parameters if it is 1. In case it is 2, the program executes automatically the lower-level calculations of the same type consecutively (e.g., CCSD, CCSDT, and CCSDTQ if CCSDTQ is requested) and restarts each calculation from the previous one (rest=2 is available only for energy calculations). Currently, only a value of 0 and 2 are supported. This becomes rest (option #4) in fort.56. Type: integer; Default: 0. table of contents. MRCC; General; E_CONVERGENCE; INTS_TOLERANCE; MRCC_LEVEL; MRCC_NUM_DOUBLET_ROOTS; MRCC_NUM_SINGLET_ROOTS; MRCC_NUM_TRIPLET_ROOTS. Expert; MRCC_METHOD; MRCC_OMP_NUM_THREADS; MRCC_RESTART. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Appendices; Keywords by Module; MRCC. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodir_options_c/module__mrcc.html:2505,energy,energy,2505,psi4manual/1.8.x/autodir_options_c/module__mrcc.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodir_options_c/module__mrcc.html,1,['energy'],['energy']
Energy Efficiency," shell reference determinant, it must be zero otherwise. This becomes nsing (option #2) in fort.56. Type: integer; Default: 1. MRCC_NUM_TRIPLET_ROOTS¶. Number of triplet roots. (Strictly speaking number of of roots with \(M_s=0\) and S is odd.) See notes at option MRCC_NUM_SINGLET_ROOTS This becomes ntrip (option #3) in fort.56. Type: integer; Default: 0. Expert¶. MRCC_METHOD¶. If more than one root is requested and calc=1, LR-CC (EOM-CC) calculation is performed automatically for the excited states. This overrides all automatic determination of method and will only work with energy(). This becomes CC/CI (option #5) in fort.56. See Table MRCC_METHOD for details. Type: integer; Default: 1. MRCC_OMP_NUM_THREADS¶. Sets the OMP_NUM_THREADS environment variable before calling MRCC. If the environment variable OMP_NUM_THREADS is set prior to calling Psi4 then that value is used. When set, this option overrides everything. Be aware the -n command-line option described in section Threading does not affect MRCC. Type: integer; Default: 1. MRCC_RESTART¶. The program restarts from the previously calculated parameters if it is 1. In case it is 2, the program executes automatically the lower-level calculations of the same type consecutively (e.g., CCSD, CCSDT, and CCSDTQ if CCSDTQ is requested) and restarts each calculation from the previous one (rest=2 is available only for energy calculations). Currently, only a value of 0 and 2 are supported. This becomes rest (option #4) in fort.56. Type: integer; Default: 0. table of contents. MRCC; General; E_CONVERGENCE; INTS_TOLERANCE; MRCC_LEVEL; MRCC_NUM_DOUBLET_ROOTS; MRCC_NUM_SINGLET_ROOTS; MRCC_NUM_TRIPLET_ROOTS. Expert; MRCC_METHOD; MRCC_OMP_NUM_THREADS; MRCC_RESTART. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Appendices; Keywords by Module; MRCC. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodir_options_c/module__mrcc.html:2505,energy,energy,2505,psi4manual/1.9.x/autodir_options_c/module__mrcc.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodir_options_c/module__mrcc.html,1,['energy'],['energy']
Energy Efficiency," shell_pairs = Vint->shellpairs();; size_t n_pairs = shell_pairs.size();; for (size_t p = 0; p < n_pairs; ++p) {; auto P = shell_pairs[p].first;; auto Q = shell_pairs[p].second;; // do something with shells P and Q; }. Note that list considers all P,Q pairs if the two basis sets differ, but only; P>=Q if the basis sets are the same; the caller should account for this; restricted summation in the latter case. One Electron Integral Algorithm Overview¶; The following table summarizes which implementation is used; for each type of one electron integral in PSI4. Algorithms used for One Electron Integrals¶. Integral; Class; Implementation; Comment. Three-Center Overlap; ThreeCenterOverlapInt; Libint2; using libint2::Operator::delta for 4-center integrals. Angular Momentum; AngularMomentumInt; M-D. Dipole; DipoleInt; Libint2; no derivatives supported. Electric Field; ElectricFieldInt; Libint2; using first derivative of libint2::Operator::nuclear. Coulomb Potential; ElectrostaticInt; Libint2; evaluated for a single origin and unity charge. Kinetic; KineticInt; Libint2. Multipole Potential; MultipolePotentialInt; M-D; arbitrary order derivative of 1/R supported. Multipole Moments; MultipoleInt; M-D; arbitrary order multipoles supported, including nuclear gradients. Nabla Operator; NablaInt; Libint2; using first derivative of libint2::Operator::overlap. Overlap; OverlapInt; Libint2. Nuclear Coulomb Potential; PotentialInt; Libint2; assumes nuclear centers/charges as the potential. PCM Potential; PCMPotentialInt; Libint2; parallelized over charge points. Quadrupole; QuadrupoleInt; Libint2. Traceless Quadrupole; TracelessQuadrupoleInt; Libint2. Relativistic Potential; RelPotentialInt; Libint2. table of contents. Integrals in PSI4; Introduction; The older style; The new syntax; Sieving; Buffer address; Density Screening; Shell blocking; Permutational symmetry; Using bra-ket symmetry; Instantiating integral objects. One Electron Integrals in PSI4; Calling compute_shell(int P, int",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/prog_integrals.html:18063,charge,charge,18063,psi4manual/1.6.x/prog_integrals.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_integrals.html,5,['charge'],['charge']
Energy Efficiency," should be 'scf'. Overruled if stage_wfn keywords supplied. scf_wfn (string) – 'scf' || 'c4-scf' || etc.; Indicates the energy method for which the reference energy is to be; obtained. Generally unnecessary, as ‘scf’ is the scf in Psi4 but; can be used to direct lone scf components to run in Psi4 or Cfour; in a mixed-program composite method. corl_wfn (string) – 'mp2' || 'ccsd(t)' || etc.; Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with name or as the unlabeled; first argument to the function. delta_wfn (string) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. delta_wfn_lesser (string) – corl_wfn || 'mp2' || etc.; Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. delta2_wfn (string) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. delta2_wfn_lesser (string) – delta_wfn || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. delta3_wfn (string) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a third delta correction; to the correlation energy is to be obtained. delta3_wfn_lesser (string) – delta2_wfn || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a third delta correction; to the correlation energy is to be obtained. delta4_wfn (string) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a fourth delta correction; to the correlation energy is to be obtained. delta4_wfn_lesser (string) – delta3_wfn || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a fourth delta correction; to the correlation energy is to be obtained. delta5_wfn (string) – 'ccsd' || 'ccsd(t)' || etc.; Ind",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/cbs-1.html:4005,energy,energy,4005,psi4manual/1.0.0/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/cbs-1.html,4,['energy'],['energy']
Energy Efficiency," shows an example of running and analyzing a standard F-SAPT0/jun-cc-pvdz procedure for phenol dimer from the S22 database. dfccsd-grad1; DF-CCSD cc-pVDZ gradients for the H2O molecule. numpy-array-interface; Numpy interface testing. tu1-h2o-energy; Sample HF/cc-pVDZ H2O computation. dft-grad-lr3; wB97X-D test for a large UKS molecule update ref gradient due to new BraggSlater radii. mp2-def2; Test case for Binding Energy of C4H5N (Pyrrole) with CO2 using MP2/def2-TZVPP. dfomp2-grad3; Tests OMP2 gradient in the presence of a dipole field. cc31; CCSD/sto-3g optical rotation calculation (both gauges) at two frequencies on methyloxirane. cc44; Test case for some of the PSI4 out-of-core codes. The code is given only 2.0 MB of memory, which is insufficient to hold either the A1 or B2 blocks of an ovvv quantity in-core, but is sufficient to hold at least two copies of an oovv quantity in-core. omp3-3; OMP3 cc-pCVDZ energy with B3LYP initial guess for the NO radical. sapt-ecp; sapt0 of charged system in ECP basis set. dct11; Restricted DF-DCT ODC-12 energies with linearly dependent basis functions. sapt3; SAPT2+3(CCD) aug-cc-pVDZ+midbond computation of the water dimer interaction energy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. dft-grad-lr1; wB97X-D cc-pVDZ gradient of S22 HCN update df/pk_ref values due to new BraggSlater radii. opt-multi-frozen-dimer-c2h; Frozen-fragment opt of C2h methane dimer with user-combined reference points. casscf-sp; CASSCF/6-31G** energy point. mbis-3; MBIS calculation on OH radical. dfrasscf-sp; 6-31G** H2O Test RASSCF Energy Point will default to only singles and doubles in the active space. opt-multi-dimer-c1; Multi-fragment opt of C2h methane dimer with user-combined reference points. scf-hess1; RHF STO-3G (Cartesian) and cc-pVDZ (spherical) water Hessian test, against Psi3 reference values. ao-casscf-sp; CASSCF/6-31G** energy point. cisd-sp-2; 6-31G** H2O Test CISD Energy Point. omp2p5-1; OMP2.5 cc-pVDZ ene",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html:37887,charge,charged,37887,psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,2,['charge'],['charged']
Energy Efficiency," single or double. cc5a; RHF CCSD(T) STO-3G frozen-core energy of C4NH4 Anion. pywrap_cbs1; Various basis set extrapolation tests. mcscf3; RHF 6-31G** energy of water, using the MCSCF module and Z-matrix input. frac; Carbon/UHF Fractionally-Occupied SCF Test Case. psimrcc-sp1; Mk-MRCCSD single point. O2 state described using the Ms = 0 component of the triplet. Uses ROHF triplet orbitals. fd-freq-gradient; STO-3G frequencies for H2O by finite-differences of gradients. cc13; UHF-CCSD/cc-pVDZ CH2 geometry optimization via analytic gradients. cc34; RHF-CCSD/cc-pVDZ energy of H2O partitioned into pair energy contributions. cisd-opt-fd; H2O CISD/6-31G** Optimize Geometry by Energies. mrcc1; CCSDT cc-pVDZ energy for the H2O molecule using MRCC. cc49; EOM-CC3(UHF) on CH radical with user-specified basis and properties for particular root. cc41; RHF-CC2-LR/cc-pVDZ optical rotation of H2O2. gauge = both, omega = (589 355 nm). sapt1; SAPT0 cc-pVDZ computation of the ethene-ethyne interaction energy, using the cc-pVDZ-JKFIT RI basis for SCF and cc-pVDZ-RI for SAPT. Monomer geometries are specified using Cartesian coordinates. cc39; RHF-CC2-LR/cc-pVDZ dynamic polarizabilities of HOF molecule. cisd-h2o+-2; 6-31G** H2O+ Test CISD Energy Point. mints2; A test of the basis specification. A benzene atom is defined using a ZMatrix containing dummy atoms and various basis sets are assigned to different atoms. The symmetry of the molecule is automatically lowered to account for the different basis sets. pywrap_db1; Database calculation, so no molecule section in input file. Portions of the full databases, restricted by subset keyword, are computed by sapt0 and dfmp2 methods. opt2-fd; SCF DZ allene geometry optimzation, with Cartesian input. sapt2; SAPT0 aug-cc-pVDZ computation of the benzene-methane interaction energy, using the aug-pVDZ-JKFIT DF basis for SCF, the aug-cc-pVDZ-RI DF basis for SAPT0 induction and dispersion, and the aug-pVDZ-JKFIT DF basis for SAPT0 electrostatics and i",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodoc_testsuite-1.html:4752,energy,energy,4752,psi4manual/4.0b2/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodoc_testsuite-1.html,4,['energy'],['energy']
Energy Efficiency," single-point CCSD(T)/qz2p on NH2 with ecc. cfour/sp-rhf-ccsd_t_-fc; single-point CCSD(T)/qz2p on water with ecc, aobasis, and frozen-core. cfour/opt-rhf-ccsd_t_; optimization CCSD(T)/dzp on water. cfour/sp-rhf-ccsd-ao; single-point CCSD/qz2p on water with aobasis. cfour/sp-rohf-ccsd_t_-ao-ecc; single-point CCSD(T)/qz2p on NH2 with ecc, aobasis. cfour/psi-mp4; MP4 energy components. Checks that computed identically between cfour and psi4. cfour/sp-rohf-ccsd; single-point CCSD/qz2p on NH2. cfour/sp-uhf-scf; single-point HF/qz2p on NH2. cfour/sp-rhf-ccsd_t_-ao-ecc; single-point CCSD(T)/qc2p on water with ecc, aobasis. cfour/sp-rhf-ccsd_t_; single-point CCSD(T)/qz2p on water. cfour/sp-rhf-ccsd_t_-ao; single-point CCSD(T)/qz2p on water with aobasis. cfour/sp-rhf-ccsdt; single-point CCSDT/qz2p on water. cfour/puream; Basis set spherical/Cartesian behavior in cfour. cfour/sp-rohf-mp2-sc; single-point MP2/qz2p on NH2. cfour/opt-rhf-mp2; optimization MP2/cc-pvtz on water. cfour/psi-rhf-scsmp2; MP2 energy components. Checks that computed identically between cfour and psi4. cfour/sp-uhf-mp2; single-point MP2/qz2p on NH2. cfour/sp-uhf-ccsdt; single-point CCSDT/qz2p on NH2. cfour/kw-5; Basis set spherical/Cartesian with basis and cfour_spherical. cfour/sp-uhf-ccsd_t_; single-point CCSD(T)/qz2p. cfour/sp-rhf-mp2; single-point MP2/qz2p on water. cfour/sp-uhf-ccsd; single-point CCSD/qz2p on NH2. cfour/psi-a24-grad; geometry after three optimization cycles on A24 database, cfour matches psi4. cfour/psi-uhf-scsmp2; UHF MP2 energy components. Checks that computed identically between cfour and psi4. cfour/mp2-1; All-electron MP2 6-31G** geometry optimization of water. cfour/kw-7; Translating psi4 options to cfour, part i. cfour/psi-uhf-mp3; UHF MP3 energy components. Checks that converted identically between cfour and psi4. cfour/kw-2; testing best practices options, part ii. cfour/sp-rhf-scf; single-point HF/qz2p on water. cfour/opt-rhf-scf; optimization HF/svp on water. cfour/opt-rhf",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_cfour-1.html:2374,energy,energy,2374,psi4manual/1.5.0/autodoc_testsuite_cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_cfour-1.html,2,['energy'],['energy']
Energy Efficiency," singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples. >>> # [1] Coupled-cluster singles and doubles calculation with psi code; >>> energy('ccsd'). >>> # [2] Charge-transfer SAPT calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). >>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). >>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). >>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy('fci', ref_wfn=cisd_wfn). >>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""CCSD/cc-pV[DT]Z""). >>> # [7] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> energy(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. PSI4 API: Linking C++ and Python; energy. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.driver.energy.html:22019,energy,energy,22019,psi4manual/1.6.x/api/psi4.driver.energy.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.driver.energy.html,6,['energy'],['energy']
Energy Efficiency," singles carried along. doi: 10.1021/ct6002737. SCS(N)-OMP2 CORRELATION ENERGY¶. SCS(N)-OMP2 TOTAL ENERGY¶. SCSN-OMP2 CORRELATION ENERGY¶. SCSN-OMP2 TOTAL ENERGY¶; Two spellings of a discontinued QCVariable that may still appear; because the code is frozen pending an update. SCS-OMP2 TOTAL ENERGY¶. SCS-OMP2 CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the OMP2-like method formed by reweighting OMP2 DOUBLES ENERGY; by 6/5 opposite-spin and 1/3 same-spin contributions, with; any singles carried along. SCS-MP3 TOTAL ENERGY¶. SCS-MP3 CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the MP3-like method formed by reweighting the difference between; MP3 DOUBLES ENERGY and MP2 DOUBLES ENERGY; by 0.25, atop the SCS-MP2 energy, with any singles carried along. SCS-OMP3 TOTAL ENERGY¶. SCS-OMP3 CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the OMP3-like method formed by reweighting the difference between; OMP3 DOUBLES ENERGY and OMP2 DOUBLES ENERGY; by 0.25, atop the SCS-OMP2 energy, with any singles carried along. SOS-MP2 TOTAL ENERGY¶. SOS-MP2 CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the MP2-like method formed by reweighting MP2 DOUBLES ENERGY; by 1.3 opposite-spin and 0 same-spin contributions, with; any singles carried along. SOS-OMP2 TOTAL ENERGY¶. SOS-OMP2 CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the OMP2-like method formed by reweighting OMP2 DOUBLES ENERGY; by 1.2 opposite-spin and 0 same-spin contributions, with; any singles carried along. SOS-OMP3 TOTAL ENERGY¶. SOS-OMP3 CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the OMP3-like method formed by reweighting the difference between; OMP3 DOUBLES ENERGY and OMP2 DOUBLES ENERGY; by 0.25, atop the SOS-O",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html:56337,energy,energy,56337,psi4manual/1.7.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html,8,['energy'],['energy']
Energy Efficiency," sn == ""scf"" and f""{sn}_basis"" in kwargs:; # or we're at a scf stage which can be implied with a provided scf_basis; stage = {""wfn"": ""hf"", ""basis"": kwargs[f""{sn}_basis""]}; else:; # otherwise go to the next possible stage; continue; # if we made it here, stage exists - parse other keywords; if f""{sn}_scheme"" in kwargs:; stage[""scheme""] = kwargs[f""{sn}_scheme""]; if f""{sn}_wfn_lesser"" in kwargs:; stage[""wfn_lo""] = kwargs[f""{sn}_wfn_lesser""]; if f""cbs_{sn}_alpha"" in kwargs:; stage[""alpha""] = kwargs[f""cbs_{sn}_alpha""]; elif f""{sn}_alpha"" in kwargs:; stage[""alpha""] = kwargs[f""{sn}_alpha""]; cbs_metadata.append(stage); if sn == ""corl"":; possible_stages.append(""delta""); elif sn == ""delta"":; possible_stages.append(""delta2""). return _validate_cbs_inputs(cbs_metadata, molecule). ###################################; ## Start of Complete Basis Set ##; ###################################. [docs]; def cbs(func, label, **kwargs):; r""""""Function to define a multistage energy method from combinations of; basis set extrapolations and delta corrections and condense the; components into a minimum number of calculations. :aliases: complete_basis_set(). :returns: (*float*) -- Total electronic energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CBS TOTAL ENERGY`; * :psivar:`CBS REFERENCE ENERGY`; * :psivar:`CBS CORRELATION ENERGY`; * :psivar:`CURRENT ENERGY`; * :psivar:`CURRENT REFERENCE ENERGY`; * :psivar:`CURRENT CORRELATION ENERGY`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - No way to tell function to boost fitting basis size for all calculations. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in several; sequential stages (scf, corl, delta1, delta2, ... ) covering treatment; of the reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction, etc.. Each is activated by its; stage_wfn keyword, or as a fiel",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:22060,energy,energy,22060,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,3,['energy'],['energy']
Energy Efficiency," so driver auto-fragments it. Basis set and auxiliary basis sets are assigned by atom type. cc17; Single point energies of multiple excited states with EOM-CCSD. castup3; SCF with various combinations of pk/density-fitting, castup/no-castup, and spherical/cartesian settings. Demonstrates that puream setting is getting set by orbital basis for all df/castup parts of calc. Demonstrates that answer doesn’t depend on presence/absence of castup. Demonstrates (by comparison to castup2) that output file doesn’t depend on options (scf_type) being set global or local. This input uses local. scf4; RHF cc-pVDZ energy for water, automatically scanning the symmetric stretch and bending coordinates using Python’s built-in loop mechanisms. The geometry is specified using a Z-matrix with variables that are updated during the potential energy surface scan, and then the same procedure is performed using polar coordinates, converted to Cartesian coordinates. cc15; RHF-B-CCD(T)/6-31G** H2O single-point energy (fzc, MO-basis \(\langle ab|cd \rangle\)). fnocc2; Test G2 method for H2O. opt4; SCF cc-pVTZ geometry optimzation, with Z-matrix input. dfmp2-grad1; DF-MP2 cc-pVDZ gradients for the H2O molecule. props4; Electrostatic potential and electric field evaluated on a grid around water. psimrcc-ccsd_t-2; Mk-MRCCSD(T) single point. \(^1A_1\) CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. cbs-xtpl-freq; Various gradients for a strained helium dimer and water molecule. cisd-h2o-clpse; 6-31G** H2O Test CISD Energy Point with subspace collapse. rasci-h2o; RASCI/6-31G** H2O Energy Point. opt8; Various constrained energy minimizations of HOOH with cc-pvdz RHF. Cartesian-coordinate constrained optimizations of HOOH in Cartesians. opt6; Various constrained energy minimizations of HOOH with cc-pvdz RHF Internal-coordinate constraints in internal-coordinate optimizations. dfmp2-3; DF-MP2 cc-pVDZ frozen core gradient of benzene, computed at the DF-SCF cc-pV",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/testsuite-1.html:25754,energy,energy,25754,psi4manual/1.1.0/testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/testsuite-1.html,4,['energy'],['energy']
Energy Efficiency," so driver auto-fragments it. Basis set and auxiliary basis sets are assigned by atom type. cc17; Single point energies of multiple excited states with EOM-CCSD. castup3; SCF with various combinations of pk/density-fitting, castup/no-castup, and spherical/cartesian settings. Demonstrates that puream setting is getting set by orbital basis for all df/castup parts of calc. Demonstrates that answer doesn’t depend on presence/absence of castup. Demonstrates (by comparison to castup2) that output file doesn’t depend on options (scf_type) being set global or local. This input uses local. scf4; RHF cc-pVDZ energy for water, automatically scanning the symmetric stretch and bending coordinates using Python’s built-in loop mechanisms. The geometry is specified using a Z-matrix with variables that are updated during the potential energy surface scan, and then the same procedure is performed using polar coordinates, converted to Cartesian coordinates. cc15; RHF-B-CCD(T)/6-31G** H2O single-point energy (fzc, MO-basis \(\langle ab|cd \rangle\)). fnocc2; Test G2 method for H2O. opt4; SCF cc-pVTZ geometry optimzation, with Z-matrix input. dfmp2-grad1; DF-MP2 cc-pVDZ gradients for the H2O molecule. props4; Electrostatic potential and electric field evaluated on a grid around water. psimrcc-ccsd_t-2; Mk-MRCCSD(T) single point. \(^1A_1\) CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. dft-grac; Gradient regularized asymptotic correction (GRAC) test. cbs-xtpl-freq; Various gradients for a strained helium dimer and water molecule. cisd-h2o-clpse; 6-31G** H2O Test CISD Energy Point with subspace collapse. rasci-h2o; RASCI/6-31G** H2O Energy Point. opt8; Various constrained energy minimizations of HOOH with cc-pvdz RHF. Cartesian-coordinate constrained optimizations of HOOH in Cartesians. opt6; Various constrained energy minimizations of HOOH with cc-pvdz RHF Internal-coordinate constraints in internal-coordinate optimizations. dfmp2-3; DF-MP2 cc-",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html:28720,energy,energy,28720,psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency," sought, the symmetry; subspace or the symmetry apportionment of roots under which the computation is run,; or the excited state method are all likely to scramble root numberings. Alternate Implementations¶; Depending on the reference (RHF, UHF, ROHF) and the integral treatment; (conventional CONV, density-fitted DF, and Cholesky-decomposed CD),; computational methods are sometimes implemented by multiple coders or even; multiple times. PSI4 transparently selects the most efficient; implementation, so one generally needn’t consult this table. However, to; understand the details of what combinations are accessible or what; alternate implementations are available, read on.; Below, “Y” means method available in module, “D” means module is default; for that method, and “” means method not available. HF, DFT, and MP2; default to density-fitted integrals, while all higher methods default to; conventional integrals. Therefore, for a closed-shell molecule:. runs MP2 with default DF with default implementation DFMP2; energy('mp2'). runs MP2 with CONV with default implementation OCC; set mp2_type conv; energy('mp2'). runs MP2 with default DF with implementation OCC; set qc_module occ; energy('mp2'). Overlapping capabilities of PSI4. “Y” is available; “D” is default.¶. name; _; type select 1. QC_MODULE; REFERENCE; _. energy(); gradient(). RHF; UHF; ROHF; RHF; UHF; ROHF. CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD. mp2; MP2_TYPE. CCENERGY. DETCI; Y. Y. DFMP2. D 2. D 2. D. D. FNOCC; Y. OCC; D; Y; D; D; Y; Y; D; Y; D; D; Y. D; D. mp3; MP_TYPE. CCENERGY. DETCI; Y. Y 3. DFMP2. FNOCC; Y. OCC; D; D; D; D; D; D. D; D. D; D. mp2.5; MP_TYPE. CCENERGY. DETCI. DFMP2. FNOCC. OCC; D; D; D; D; D; D. D; D. D; D. mp4; MP_TYPE. CCENERGY. DETCI; Y. Y 3. DFMP2. FNOCC; D. OCC. lccd; CC_TYPE. CCENERGY. DETCI. DFMP2. FNOCC; D. OCC; Y; D; D; D; D; D. D; D. D; D. lccsd, cepa(0); CC_TYPE. CCENERGY. DETCI. DFMP2. FNOCC; D. OCC. ccsd; CC_TYPE. CCENERGY; D. D. D. D. D. D. DETCI. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/notes_c.html:3100,energy,energy,3100,psi4manual/1.6.x/notes_c.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/notes_c.html,1,['energy'],['energy']
Energy Efficiency," specification, using variables, for the benzene-hydronium complex. Atoms can be placed using ZMatrix coordinates, whether they belong to the same fragment or not. Note that the Cartesian specification must come before the ZMatrix entries because the former define absolute positions, while the latter are relative. cc4; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. After the computation, the checkpoint file is renamed, using the PSIO handler. cc30; CCSD/sto-3g optical rotation calculation (length gauge only) at two frequencies on methyloxirane. cisd-h2o+-2; 6-31G** H2O+ Test CISD Energy Point. mp3-grad2; MP3 cc-pVDZ gradient for the NO radical. dcft6; DCFT calculation for the triplet O2 using DC-06, DC-12 and CEPA0 functionals. Only two-step algorithm is tested. cc3; cc3: RHF-CCSD/6-31G** H2O geometry optimization and vibrational frequency analysis by finite-differences of gradients. sapt1; SAPT0 cc-pVDZ computation of the ethene-ethyne interaction energy, using the cc-pVDZ-JKFIT RI basis for SCF and cc-pVDZ-RI for SAPT. Monomer geometries are specified using Cartesian coordinates. castup1; Test of SAD/Cast-up (mainly not dying due to file weirdness). cc51; EOM-CC3/cc-pVTZ on H2O. dfmp2-1; Density fitted MP2 cc-PVDZ/cc-pVDZ-RI computation of formic acid dimer binding energy using automatic counterpoise correction. Monomers are specified using Cartesian coordinates. psimrcc-fd-freq1; Mk-MRCCSD single point. O2 state described using the Ms = 0 component of the triplet. Uses ROHF triplet orbitals. opt7; Various constrained energy minimizations of HOOH with cc-pvdz RHF. For “fixed” coordinates, the final value is provided by the user. fci-tdm-2; BH-H2+ FCI/cc-pVDZ Transition Dipole Moment. dft-pbe0-2; Internal match to psi4, test to match to literature values in litref.in/litref.out. opt3; SCF cc-pVDZ geometry optimzation, with Z-matrix input. pywrap-checkrun-convcrit; Advanced python example sets different sets of scf/post-scf conv cri",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html:6268,energy,energy,6268,psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency," specified, GENBAS and/or ZMAT within will be used. genbas (string) – Indicates that contents should be used for GENBAS file. GENBAS is a complicated topic. It is quite unnecessary if the; molecule is from a molecule {...} block and basis is set through; Psi4‘s BASIS keyword. In that case, a GENBAS is written from; LibMints and all is well. Otherwise, a GENBAS is looked for in; the usual places: PSIPATH, PATH, PSIDATADIR/basis. If path kwarg is; specified, also looks there preferentially for a GENBAS. Can; also specify GENBAS within an input file through a string and; setting the genbas kwarg. Note that due to the input parser’s; aggression, blank lines need to be replaced by the text blankline. Functionality¶; Through clever use of the cfour {...} block, one could run most any; Cfour computation through the P4C4 interface. In contrast, enumerated; below are tested functionalities where results from Cfour are collected; into Psi4 data objects.; Implemented. Single-point energy() commands for ground state; methods. Examples:; cfour/sp-rhf-ccsd_t_-ao-ecc, cfour/scf4,; cfour/mints5.; Analytic gradient() and optimize(); commands for ground state methods. Real and; Ghost atoms permitted (though the latter will naturally collapse after; several cycles). Examples: cfour/opt-rhf-ccsd_t_,; cfour/mp2-1, and cfour/mints5-grad. Warning; There exist molecules (e.g., allene) where the; inertial frame is not unique (planes along atoms or between; atoms). The orientation reconciling machinery currently does not; handle these cases and will fail with “Axis unreconcilable between; QC programs”. I will get to this soon. Finite difference of energy gradient() and; optimize() for methods.; Force with gradient('name', dertype=0), etc..; _nbody_gufunc() for computation of interaction energies with or; without counterpoise correction. Example: cfour/dfmp2-1.; database() for computation of a collection of molecules in a; single input, with summarization of results. Examples:; cfour/pywrap-d",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/cfour-1.html:25572,energy,energy,25572,psi4manual/1.0.0/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/cfour-1.html,2,['energy'],['energy']
Energy Efficiency," specifies the desired frequencies of the incident radiation field in CCLR calculations. If only one element is given, the units will be assumed to be atomic units. If more than one element is given, then the units must be specified as the final element of the array. Acceptable units are HZ, NM, EV, and AU. Type: string; Possible Values: POLARIZABILITY, ROTATION, ROA, ALL; Default: POLARIZABILITY. PSIMRCC (TRANSQT); TRANSQT — Do ?. Type: boolean; Default: false. PT_ENERGY (PSIMRCC); PSIMRCC — The type of perturbation theory computation to perform. Type: string; Possible Values: SECOND_ORDER, SCS_SECOND_ORDER, PSEUDO_SECOND_ORDER, SCS_PSEUDO_SECOND_ORDER; Default: SECOND_ORDER. PUREAM (GLOBALS); GLOBALS — Do use pure angular momentum basis functions? If not explicitly set, the default comes from the basis set. Type: boolean; Default: true. QRHF (TRANSQT); TRANSQT — Do ?. Type: boolean; Default: false. R4S (DETCI); DETCI (Expert) — Do restrict strings with in RAS IV? Useful to reduce the number of strings required if MIXED4=true, as in a split-virutal CISD[TQ] computation. If more than one electron is in RAS IV, then the holes in RAS I cannot exceed the number of particles in RAS III + RAS IV (i.e., EX_LEVEL), or else the string is discarded. Type: boolean; Default: false. R_CONVERGENCE (CCENERGY); CCENERGY — Convergence criterion for wavefunction (change) in CC amplitude equations. Type: conv double; Default: 1e-7. R_CONVERGENCE (CCEOM); CCEOM — Convergence criterion for norm of the residual vector in the Davidson algorithm for CC-EOM. Type: conv double; Default: 1e-6. R_CONVERGENCE (CCLAMBDA); CCLAMBDA — Convergence criterion for wavefunction (change) in CC lambda-amplitude equations. Type: conv double; Default: 1e-7. R_CONVERGENCE (CCRESPONSE); CCRESPONSE — Convergence criterion for wavefunction (change) in perturbed CC equations. Type: conv double; Default: 1e-7. R_CONVERGENCE (CIS); CIS — Convergence criterion for CIS wavefunction. Type: conv double; Default: 1e-",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodoc_glossary_options_c-1.html:76518,reduce,reduce,76518,psi4manual/4.0b2/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodoc_glossary_options_c-1.html,2,['reduce'],['reduce']
Energy Efficiency," spin multiplicity \(2S+1 = 3\)).; In this case, the default spin multiplicity (1) is not correct, so we; need to tell the program the true value (3). Like many programs, PSI4; can get the charge and multiplicity as the first two integers in the; Z-matrix. Note the line with 0 3 at the beginning of the molecule; specification below. In this example we will also specify the bond length; and bond angle as variables (\(R\) and \(A\)), whose values are given; at the end of the Z-matrix specification.; #! Sample UHF/6-31G** CH2 computation. molecule ch2 {; 0 3; C ; H 1 R; H 1 R 2 A. R = 1.075; A = 133.93; }. set basis 6-31G**; set reference uhf; energy ('scf'). This sample input can be found in; tu2-ch2-energy and as; before it can be run through the command psi4 input.dat output.dat; (actually, because psi4 by default looks for an input file named; input.dat and writes by default to a file called output.dat, in this; case one could also just type psi4). If it works, it should print; the final energy as; @UHF Final Energy: -38.92533462456894. Notice we added a new keyword, set reference uhf, to the input. For; open-shell molecules, we have a choice of unrestricted orbitals; (unrestricted Hartree–Fock, or UHF), or restricted orbitals (restricted; open-shell Hartree–Fock, or ROHF). Usually, UHF is a little easier to; converge (although it may be more susceptible to spin contamination than; ROHF). Geometry Optimization and Vibrational Frequency Analysis¶; The above examples were simple single-point energy computations; (as specified by the energy() function). Of course there are other; kinds of computations to perform, such as geometry optimizations and; vibrational frequency computations. These can be specified by replacing; energy() with optimize() or frequency(), respectively.; Here’s an example of optimizing the H2O molecule using Hartree–Fock with; a cc-pVDZ basis set (located in; tu3-h2o-opt).; #! Optimize H2O HF/cc-pVDZ. molecule h2o {; O ; H 1 0.96; H 1 0.96 2 104.5;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/tutorial-1.html:5032,energy,energy,5032,psi4manual/1.4.0/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/tutorial-1.html,9,['energy'],['energy']
Energy Efficiency," start SOSCF based on the current density RMS; SOSCF_MAX_ITER: the maximum number of SOSCF microiterations per macroiteration; SOSCF_CONV: the relative convergence tolerance of the SOSCF microiterations; SOSCF_PRINT: option to print the microiterations or not. Stability Analysis¶; SCF algorithms attempt to minimize the gradient of the energy with respect; to orbital variation parameters. At convergence, the gradient should be approximately zero; given a convergence criterion. Although this is enough to make sure the SCF converged to a; stationary point, this is not a sufficient condition for a minimal SCF solution. It may be; a sadle point or a maximum.; To ensure that a minimum has been found, the electronic Hessian, i.e. the matrix of second; derivatives of the energy with respect to orbital variation parameters, must be computed.; If one or more eigenvalues of the electronic Hessian are negative, the SCF solution is not a minimum.; In that case, orbital parameters can be varied along the lowest Hessian eigenvector to lower the energy.; Orbital variation parameters are usually constrained. For example, in RHF the; spatial parts of the and orbitals are the same. In; UHF, the orbital coefficients are usually constrained to be real. A stability analysis; can check whether a lower SCF solution exists while respecting the constraints of the original; solution; this is an internal instability. If one or more constraints have to be relaxed to reach; a lower-energy solution, there is an external instability. In Psi4, the only external instability; that can be checked at present is the RHF->UHF one.; Currently, two algorithms exist in Psi4 for stability analysis: the original; Direct Inversion and the newly implemented Davidson algorithms. We will first describe; options common to both algorithms. To request a stability analysis at the end of the SCF,; set the keyword STABILITY_ANALYSIS:; set stability_analysis check. to only compute the electronic Hessian eigenvalue and c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/scf-1.html:24088,energy,energy,24088,psi4manual/1.0.0/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/scf-1.html,2,['energy'],['energy']
Energy Efficiency," state described using the Ms = 0 component of the singlet. Uses TCSCF singlet orbitals. scf-bz2; Benzene Dimer Out-of-Core HF/cc-pVDZ. cisd-opt-fd; H2O CISD/6-31G** Optimize Geometry by Energies. rasci-ne; Ne atom RASCI/cc-pVQZ Example of split-virtual CISD[TQ] from Sherrill and Schaefer, J. Phys. Chem. XXX This uses a “primary” virtual space 3s3p (RAS 2), a “secondary” virtual space 3d4s4p4d4f (RAS 3), and a “tertiary” virtual space consisting of the remaining virtuals. First, an initial CISD computation is run to get the natural orbitals; this allows a meaningful partitioning of the virtual orbitals into groups of different importance. Next, the RASCI is run. The split-virtual CISD[TQ] takes all singles and doubles, and all triples and quadruples with no more than 2 electrons in the secondary virtual subspace (RAS 3). If any electrons are present in the tertiary virtual subspace (RAS 4), then that excitation is only allowed if it is a single or double. dcft9; UHF-ODC-12 and RHF-ODC-12 single-point energy for H2O. This performs a simultaneous update of orbitals and cumulants, using DIIS extrapolation. Four-virtual integrals are handled in the AO basis, where integral transformation is avoided. In the next RHF-ODC-12 computation, AO_BASIS=NONE is used, where four-virtual integrals are transformed into MO basis. scf-occ; force occupations in scf. scf7; Tests SCF gradient in the presence of a dipole field. omp2-4; SCS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. pywrap-all; Intercalls among python wrappers- database, cbs, optimize, energy, etc. Though each call below functions individually, running them all in sequence or mixing up the sequence is aspirational at present. Also aspirational is using the intended types of gradients. rasci-c2-active; 6-31G* C2 Test RASCI Energy Point, testing two different ways of specifying the active space, either with the ACTIVE keyword, or with RAS1, RAS2, RESTRICTED_DOCC, and RESTRICTED_UOCC. cc21; ROHF-EOM-CCSD/DZ anal",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/testsuite-1.html:32786,energy,energy,32786,psi4manual/1.1.0/testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/testsuite-1.html,4,['energy'],['energy']
Energy Efficiency," state described using the Ms = 0 component of the triplet. Uses ROHF triplet orbitals. fd-freq-gradient; STO-3G frequencies for H2O by finite-differences of gradients. dfmp2-1; Density fitted MP2 cc-PVDZ/cc-pVDZ-RI computation of formic acid dimer binding energy using automatic counterpoise correction. Monomers are specified using Cartesian coordinates. cc13; UHF-CCSD/cc-pVDZ CH2 geometry optimization via analytic gradients. cc34; RHF-CCSD/cc-pVDZ energy of H2O partitioned into pair energy contributions. cepa3; cc-pvdz H2O Test coupled-pair CISD against DETCI CISD. cisd-opt-fd; H2O CISD/6-31G** Optimize Geometry by Energies. omp2-grad2; OMP2 cc-pVDZ gradient for the NO radical. mrcc1; CCSDT cc-pVDZ energy for the H2O molecule using MRCC. cc49; EOM-CC3(UHF) on CH radical with user-specified basis and properties for particular root. cc41; RHF-CC2-LR/cc-pVDZ optical rotation of H2O2. gauge = both, omega = (589 355 nm). sapt1; SAPT0 cc-pVDZ computation of the ethene-ethyne interaction energy, using the cc-pVDZ-JKFIT RI basis for SCF and cc-pVDZ-RI for SAPT. Monomer geometries are specified using Cartesian coordinates. cc39; RHF-CC2-LR/cc-pVDZ dynamic polarizabilities of HOF molecule. cisd-h2o+-2; 6-31G** H2O+ Test CISD Energy Point. mints2; A test of the basis specification. A benzene atom is defined using a ZMatrix containing dummy atoms and various basis sets are assigned to different atoms. The symmetry of the molecule is automatically lowered to account for the different basis sets. dft-b2plyp; Double-hybrid density functional B2PYLP. Reproduces portion of Table I in S. Grimme’s J. Chem. Phys 124 034108 (2006) paper defining the functional. props3; DF-SCF cc-pVDZ multipole moments of benzene, up to 7th order and electrostatic potentials evaluated at the nuclear coordinates. opt2-fd; SCF DZ allene geometry optimzation, with Cartesian input. dcft6; DCFT calculation for the triplet O2 using DC-06, DC-12 and CEPA0 functionals. Only two-step algorithm is tested. sapt2; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_testsuite-1.html:6714,energy,energy,6714,psi4manual/4.0b4/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_testsuite-1.html,8,['energy'],['energy']
Energy Efficiency," state of the CN radical, with Cartesian input. cc15; RHF-B-CCD(T)/6-31G** H2O single-point energy (fzc, MO-basis \(\langle ab|cd \rangle\)). dfomp3-1; DF-OMP3 cc-pVDZ energy for the H2O molecule. ddd-function-kwargs; check distributed driver is correctly passing function kwargs. dct2; DC-06 calculation for the He dimer. This performs a two-step update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the MO Basis. cc13b; Tests RHF CCSD(T)gradients. cc17; Single point energies of multiple excited states with EOM-CCSD. ghosts; Density fitted MP2 cc-PVDZ/cc-pVDZ-RI computation of formic acid dimer binding energy using explicit specification of ghost atoms. This is equivalent to the dfmp2_1 sample but uses both (equivalent) specifications of ghost atoms in a manual counterpoise correction. dft-grad-lr3; wB97X-D test for a large UKS molecule update ref gradient due to new BraggSlater radii. decontract; RHF/cc-pvdz-decontract HCl single-point energy Testing the in line -decontract option for basis sets. cepa2; cc-pvdz H2O Test ACPF Energy/Properties. dct9; UHF-ODC-12 and RHF-ODC-12 single-point energy for H2O. This performs a simultaneous update of orbitals and cumulants, using DIIS extrapolation. Four-virtual integrals are handled in the AO basis, where integral transformation is avoided. In the next RHF-ODC-12 computation, AO_BASIS=NONE is used, where four-virtual integrals are transformed into MO basis. dft-freq; Frequencies for H2O B3LYP/6-31G* at optimized geometry. fsapt-terms; F-SAPT0/jun-cc-pvdz procedure for methane dimer. cc46; EOM-CC2/cc-pVDZ on H2O2 with two excited states in each irrep. scf-ecp3; Water-Argon complex with ECP present; check of UHF Hessian. mcscf1; ROHF 6-31G** energy of the \(^{3}B_1\) state of CH2, with Z-matrix input. The occupations are specified explicitly. fci-tdm-2; BH-H2+ FCI/cc-pVDZ Transition Dipole Moment. dfomp2p5-2; DF-OMP2.5 cc-pVDZ energy for the H2O+ cation. pywrap-all; Intercalls amo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html:10735,energy,energy,10735,psi4manual/master/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency," state of the CN radical, with Cartesian input. props1; RHF STO-3G dipole moment computation, performed by applying a finite electric field and numerical differentiation. cc45; RHF-EOM-CC2/cc-pVDZ lowest two states of each symmetry of H2O. fnocc4; Test FNO-DF-CCSD(T) energy. tu3-h2o-opt; Optimize H2O HF/cc-pVDZ. cc9; UHF-CCSD(T) cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Z-matrix input. mcscf3; RHF 6-31G** energy of water, using the MCSCF module and Z-matrix input. mints2; A test of the basis specification. A benzene atom is defined using a ZMatrix containing dummy atoms and various basis sets are assigned to different atoms. The symmetry of the molecule is automatically lowered to account for the different basis sets. dcft8; DCFT calculation for the NH3+ radical using the ODC-12 and ODC-13 functionals. This performs both simultaneous and QC update of the orbitals and cumulant using DIIS extrapolation. Four-virtual integrals are first handled in the MO Basis for the first two energy computations. In the next computation ao_basis=disk algorithm is used, where the transformation of integrals for four-virtual case is avoided. cc12; Single point energies of multiple excited states with EOM-CCSD. dft2; DFT Functional Test. cc8b; ROHF-CCSD cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Cartesian input. pywrap-molecule; Check that C++ Molecule class and qcdb molecule class are reading molecule input strings identically. opt1-fd; SCF STO-3G geometry optimzation, with Z-matrix input, by finite-differences. x2c2; Test of SFX2C-1e on Water cc-pVDZ-DK. In this test the Dirac equation is solved in the uncontracted cc-pVDZ-DK basis. The reference numbers are from Lan Cheng’s implementation in Cfour. cbs-xtpl-func; optimization with method defined via cbs. cubeprop; RHF orbitals and density for water. omp3-1; OMP3 cc-pVDZ energy for the H2O molecule. fd-gradient; SCF STO-3G finite-difference tests. mints5; Tests",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/testsuite-1.html:28335,energy,energy,28335,psi4manual/1.1.0/testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/testsuite-1.html,4,['energy'],['energy']
Energy Efficiency," state of the CN radical. castup3; SCF with various combinations of pk/density-fitting, castup/no-castup, and spherical/cartesian settings. Demonstrates that puream setting is getting set by orbital basis for all df/castup parts of calc. Demonstrates that answer doesn’t depend on presence/absence of castup. Demonstrates (by comparison to castup2) that output file doesn’t depend on options (scf_type) being set global or local. This input uses local. cc8c; ROHF-CCSD cc-pVDZ frozen-core energy for the state of the CN radical, with Cartesian input. scf1; RHF cc-pVQZ energy for the BH molecule, with Cartesian input. cisd-h2o+-0; 6-31G** H2O+ Test CISD Energy Point. cc43; RHF-CC2-LR/STO-3G optical rotation of (S)-methyloxirane. gauge = both, omega = (589 355 nm). cc27; Single point gradient of 1-1B2 state of H2O with EOM-CCSD. cisd-sp-2; 6-31G** H2O Test CISD Energy Point. opt1; SCF STO-3G geometry optimzation, with Z-matrix input. dft2; DFT Functional Test. cc15; RHF-B-CCD(T)/6-31G** H2O single-point energy (fzc, MO-basis ). dft1; DFT Functional Test. cc18; RHF-CCSD-LR/cc-pVDZ static polarizability of HOF. mom; Maximum Overlap Method (MOM) Test. MOM is designed to stabilize SCF convergence and to target excited Slater determinants directly. fci-h2o-fzcv; 6-31G H2O Test FCI Energy Point. pywrap-cbs1; Various basis set extrapolation tests. fd-freq-energy; SCF STO-3G finite-difference frequencies from energies. dcft5; DC-06 calculation for the O2 molecule (triplet ground state). This performs geometry optimization using two-step and simultaneous solution of the response equations for the analytic gradient. pywrap-all; Intercalls among python wrappers- database, cbs, optimize, energy, etc. Though each call below functions individually, running them all in sequence or mixing up the sequence is aspirational at present. Also aspirational is using the intended types of gradients. opt2; SCF DZ allene geometry optimzation, with Cartesian input. mp3-grad1; MP3 cc-pVDZ gradient for t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_testsuite-1.html:9495,energy,energy,9495,psi4manual/4.0b4/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_testsuite-1.html,8,['energy'],['energy']
Energy Efficiency," state of the CN radical. castup3; SCF with various combinations of pk/density-fitting, castup/no-castup, and spherical/cartesian settings. Demonstrates that puream setting is getting set by orbital basis for all df/castup parts of calc. Demonstrates that answer doesn’t depend on presence/absence of castup. Demonstrates (by comparison to castup2) that output file doesn’t depend on options (scf_type) being set global or local. This input uses local. cc8c; ROHF-CCSD cc-pVDZ frozen-core energy for the state of the CN radical, with Cartesian input. scf1; RHF cc-pVQZ energy for the BH molecule, with Cartesian input. cisd-h2o+-0; 6-31G** H2O+ Test CISD Energy Point. cc43; RHF-CC2-LR/STO-3G optical rotation of (S)-methyloxirane. gauge = both, omega = (589 355 nm). cc27; Single point gradient of 1-1B2 state of H2O with EOM-CCSD. cisd-sp-2; 6-31G** H2O Test CISD Energy Point. opt1; SCF STO-3G geometry optimzation, with Z-matrix input. dft2; DFT Functional Test. cc15; RHF-B-CCD(T)/6-31G** H2O single-point energy (fzc, MO-basis ). dft1; DFT Functional Test. cc18; RHF-CCSD-LR/cc-pVDZ static polarizability of HOF. mom; Maximum Overlap Method (MOM) Test. MOM is designed to stabilize SCF convergence and to target excited Slater determinants directly. fci-h2o-fzcv; 6-31G H2O Test FCI Energy Point. pywrap-cbs1; Various basis set extrapolation tests. fd-freq-energy; SCF STO-3G finite-difference frequencies from energies. dcft5; DCFT-06 calculation for the O2 molecule (triplet ground state). This performs geometry optimization using two-step and simultaneous solution of the response equations for the analytic gradient. pywrap-all; Intercalls among python wrappers- database, cbs, optimize, energy, etc. Though each call below functions individually, running them all in sequence or mixing up the sequence is aspirational at present. Also aspirational is using the intended types of gradients. opt2; SCF DZ allene geometry optimzation, with Cartesian input. scf11-freq-from-energies; Test freq",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_testsuite-1.html:8455,energy,energy,8455,psi4manual/4.0b3/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_testsuite-1.html,4,['energy'],['energy']
Energy Efficiency," static object to track all PSIO operations in a given PSI4 computation. IntVector; Class handling vectors with integer values. IntegralFactory; Computes integrals. IntegralTransform; IntegralTransform transforms one- and two-electron integrals within general spaces. IrreducibleRepresentation; An irreducible representation of the point group. JK; docstring. KineticInt; Computes kinetic integrals. LaplaceDenominator; Computer class for a Laplace factorization of the four-index energy denominator in MP2 and coupled-cluster. LibXCFunctional; docstring. Localizer; Class containing orbital localization procedures. MOSpace; Defines orbital spaces in which to transform integrals. MOWriter; Writes the MOs. Matrix; Class for creating and manipulating matrices. MatrixFactory; Creates Matrix objects. MemDFJK; docstring. MintsHelper; Computes integrals. MoldenWriter; Writes wavefunction information in molden format. MolecularGrid; docstring. Molecule; Class to store the elements, coordinates, fragmentation pattern, basis sets, charge, multiplicity, etc. MultipoleInt; Computes arbitrary-order multipole integrals. MultipoleSymmetry; docstring. NBOWriter; The Natural Bond Orbital Writer. NablaInt; Computes nabla integrals. NumIntHelper; Computes numerical integrals using a DFT grid. OEProp; docstring. OneBodyAOInt; Basis class for all one-electron integrals. OneBodySOInt. Options; docstring. OrbitalSpace; Contains information about the orbitals. OverlapInt; Computes overlap integrals. PMLocalizer; Performs Pipek-Mezey orbital localization. PetiteList; Handles symmetry transformations. PointFunctions; docstring. PointGroup; Contains information about the point group. PotentialInt; Computes potential integrals. PrimitiveType; May be Normalized or Unnormalized. Prop; docstring. ProtoIntVector. ProtoVector. PsiReturnType; Return status. QuadrupoleInt; Computes quadrupole integrals. RHF; docstring. RKSFunctions; docstring. ROHF; docstring. SADGuess; docstring. SOBasisSet; An SOBasis ob",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/psi4api.html:13574,charge,charge,13574,psi4manual/1.7.x/psi4api.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/psi4api.html,1,['charge'],['charge']
Energy Efficiency," static object to track all PSIO operations in a given PSI4 computation. IntVector; Class handling vectors with integer values. IntegralFactory; Computes integrals. IntegralTransform; IntegralTransform transforms one- and two-electron integrals within general spaces. IrreducibleRepresentation; An irreducible representation of the point group. JK; docstring. KineticInt; Computes kinetic integrals. LaplaceDenominator; Computer class for a Laplace factorization of the four-index energy denominator in MP2 and coupled-cluster. LibXCFunctional; docstring. Localizer; Class containing orbital localization procedures. MOSpace; Defines orbital spaces in which to transform integrals. MOWriter; Writes the MOs. Matrix; Class for creating and manipulating matrices. MatrixFactory; Creates Matrix objects. MemDFJK; docstring. MintsHelper; Computes integrals. MoldenWriter; Writes wavefunction information in molden format. MolecularGrid; docstring. Molecule; Class to store the elements, coordinates, fragmentation pattern, basis sets, charge, multiplicity, etc. MultipoleInt; Computes arbitrary-order multipole integrals. MultipoleSymmetry; docstring. NablaInt; Computes nabla integrals. NumIntHelper; Computes numerical integrals using a DFT grid. OEProp; docstring. OneBodyAOInt; Basis class for all one-electron integrals. OneBodySOInt. Options; docstring. OrbitalSpace; Contains information about the orbitals. OverlapInt; Computes overlap integrals. PMLocalizer; Performs Pipek-Mezey orbital localization. PetiteList; Handles symmetry transformations. PointFunctions; docstring. PointGroup; Contains information about the point group. PotentialInt; Computes potential integrals. PrimitiveType; May be Normalized or Unnormalized. Prop; docstring. ProtoIntVector. ProtoVector. PsiReturnType; Return status. QuadrupoleInt; Computes quadrupole integrals. RHF; docstring. RKSFunctions; docstring. ROHF; docstring. SADGuess; docstring. SOBasisSet; An SOBasis object describes the transformation from an at",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/psi4api.html:13566,charge,charge,13566,psi4manual/1.8.x/psi4api.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/psi4api.html,2,['charge'],['charge']
Energy Efficiency," step_coordinates.append(core.Matrix.from_array(optimizer.X.reshape(-1,3))); step_gradients.append(core.Matrix.from_array(optimizer.gradx.reshape(-1,3))). return_energy = optimizer.E; opt_geometry = core.Matrix.from_array(optimizer.X.reshape(-1,3)); molecule.set_geometry(opt_geometry); molecule.update_geometry(); core.print_out(f'\n Final Energy : {return_energy} \n'); core.print_out('\n Final Geometry : \n'); molecule.print_in_input_format(). if return_history:; history = {; 'energy': step_energies,; 'gradient': step_gradients,; 'coordinates': step_coordinates,; }. if return_wfn:; wfn = engine.p4_wfn. if return_wfn and return_history:; return (return_energy, wfn, history); elif return_wfn and not return_history:; return (return_energy, wfn); elif return_history and not return_wfn:; return (return_energy, history); else:; return return_energy. [docs]def optimize(name, **kwargs):; r""""""Function to perform a geometry optimization. :aliases: opt(). :returns: *float* |w--w| Total electronic energy of optimized structure in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :raises: :py:class:`psi4.OptimizationConvergenceError` if :term:`GEOM_MAXITER <GEOM_MAXITER (OPTKING)>` exceeded without reaching geometry convergence. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY`. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`psi4.energy`. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tupl",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:59265,energy,energy,59265,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,3,['energy'],['energy']
Energy Efficiency," step_coordinates.append(core.Matrix.from_array(optimizer.X.reshape(-1,3))); step_gradients.append(core.Matrix.from_array(optimizer.gradx.reshape(-1,3))). return_energy = optimizer.E; opt_geometry = core.Matrix.from_array(optimizer.X.reshape(-1,3)); molecule.set_geometry(opt_geometry); molecule.update_geometry(); core.print_out(f'\n Final Energy : {return_energy} \n'); core.print_out('\n Final Geometry : \n'); molecule.print_in_input_format(). if return_history:; history = {; 'energy': step_energies,; 'gradient': step_gradients,; 'coordinates': step_coordinates,; }. if return_wfn:; wfn = engine.p4_wfn. if return_wfn and return_history:; return (return_energy, wfn, history); elif return_wfn and not return_history:; return (return_energy, wfn); elif return_history and not return_wfn:; return (return_energy, history); else:; return return_energy. [docs]def optimize(name, **kwargs):; r""""""Function to perform a geometry optimization. :aliases: opt(). :returns: *float* |w--w| Total electronic energy of optimized structure in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :raises: :py:class:`psi4.driver.OptimizationConvergenceError` if :term:`GEOM_MAXITER <GEOM_MAXITER (OPTKING)>` exceeded without reaching geometry convergence. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY`. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`psi4.driver.energy`. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* ene",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html:61016,energy,energy,61016,psi4manual/1.7.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html,1,['energy'],['energy']
Energy Efficiency," str, mass: float, charge: float, label: str, A: int) → None¶; Adds to self Molecule an atom with atomic number Z, Cartesian coordinates in Bohr (x, y, z), atomic symbol, mass, and charge, extended atomic label, and mass number A. atom_at_position(*args, **kwargs)¶; Overloaded function. atom_at_position(self: psi4.core.Molecule, coord: float, tol: float) -> int. Returns the index of the atom inside tol radius around coord. Returns -1 for no atoms, throws an exception if more than one is found. atom_at_position(self: psi4.core.Molecule, coord: Annotated[List[float], FixedSize(3)], tol: float) -> int. Returns the index of the atom inside tol radius around coord. Returns -1 for no atoms, throws an exception if more than one is found. basis_on_atom(self: psi4.core.Molecule, arg0: int) → str¶; Gets the label of the orbital basis set on a given atom arg0. center_of_mass(self: psi4.core.Molecule) → psi4.core.Vector3¶; Computes center of mass of molecule (does not translate molecule). charge(self: psi4.core.Molecule, atom: int) → float¶; Gets charge of atom (0-indexed without dummies). clone(self: psi4.core.Molecule) → psi4.core.Molecule¶; Returns a new Molecule identical to arg1. com_fixed(self: psi4.core.Molecule) → bool¶; Gets whether or not center of mass is fixed. comment(self: psi4.core.Molecule) → str¶; Gets molecule comment. connectivity(self: psi4.core.Molecule) → List[Tuple[int, int, float]]¶; Gets molecule connectivity. create_psi4_string_from_molecule(self: psi4.core.Molecule) → str¶; Gets a string re-expressing in input format the current state of the molecule.Contains Cartesian geometry info, fragmentation, charges and multiplicities, and any frame restriction. deactivate_all_fragments(self: psi4.core.Molecule) → None¶; Sets all fragments in the molecule to be inactive. distance_matrix(self: psi4.core.Molecule) → psi4.core.Matrix¶; Returns Matrix of interatom distances. extract_subsets(*args, **kwargs)¶; Overloaded function. extract_subsets(self: psi4.core.Mole",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html:16714,charge,charge,16714,psi4manual/1.9.x/api/psi4.core.Molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html,1,['charge'],['charge']
Energy Efficiency," str, mass: float, charge: float, label: str, A: int) → None¶; Adds to self Molecule an atom with atomic number Z, Cartesian coordinates in Bohr (x, y, z), atomic symbol, mass, and charge, extended atomic label, and mass number A. atom_at_position(*args, **kwargs)¶; Overloaded function. atom_at_position(self: psi4.core.Molecule, coord: float, tol: float) -> int. Returns the index of the atom inside tol radius around coord. Returns -1 for no atoms, throws an exception if more than one is found. atom_at_position(self: psi4.core.Molecule, coord: Annotated[list[float], FixedSize(3)], tol: float) -> int. Returns the index of the atom inside tol radius around coord. Returns -1 for no atoms, throws an exception if more than one is found. basis_on_atom(self: psi4.core.Molecule, arg0: int) → str¶; Gets the label of the orbital basis set on a given atom arg0. center_of_mass(self: psi4.core.Molecule) → psi4.core.Vector3¶; Computes center of mass of molecule (does not translate molecule). charge(self: psi4.core.Molecule, atom: int) → float¶; Gets charge of atom (0-indexed without dummies). clone(self: psi4.core.Molecule) → psi4.core.Molecule¶; Returns a new Molecule identical to arg1. com_fixed(self: psi4.core.Molecule) → bool¶; Gets whether or not center of mass is fixed. comment(self: psi4.core.Molecule) → str¶; Gets molecule comment. connectivity(self: psi4.core.Molecule) → list[tuple[int, int, float]]¶; Gets molecule connectivity. create_psi4_string_from_molecule(self: psi4.core.Molecule) → str¶; Gets a string re-expressing in input format the current state of the molecule.Contains Cartesian geometry info, fragmentation, charges and multiplicities, and any frame restriction. deactivate_all_fragments(self: psi4.core.Molecule) → None¶; Sets all fragments in the molecule to be inactive. distance_matrix(self: psi4.core.Molecule) → psi4.core.Matrix¶; Returns Matrix of interatom distances. extract_subsets(*args, **kwargs)¶; Overloaded function. extract_subsets(self: psi4.core.Mole",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/api/psi4.core.Molecule.html:16715,charge,charge,16715,psi4manual/master/api/psi4.core.Molecule.html,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.Molecule.html,1,['charge'],['charge']
Energy Efficiency," stretch and bending coordinates using Python’s built-in loop mechanisms. The geometry is apecified using a Z-matrix with variables that are updated during the potential energy surface scan, and then the same procedure is performed using polar coordinates, converted to Cartesian coordinates. cisd-h2o-clpse; 6-31G** H2O Test CISD Energy Point with subspace collapse. omp2-3; OMP2 cc-pVDZ energy for the NO radical. cepa1; cc-pvdz H2O Test CEPA(1) Energy. cc24; Single point gradient of 1-2B1 state of H2O+ with EOM-CCSD. dftd3-grad; DF-BP86-D2 cc-pVDZ frozen core gradient of S22 HCN, calling Grimme’s dftd3 program for -D2 gradients. cc14; ROHF-CCSD/cc-pVDZ CH2 geometry optimization via analytic gradients. mp3-grad2; MP3 cc-pVDZ gradient for the NO radical. cc29; CCSD/cc-pVDZ optical rotation calculation (both gauges) on Cartesian H2O2. dfscf-bz2; Benzene Dimer DF-HF/cc-pVDZ. psithon1; Spectroscopic constants of H2, and the full ci cc-pVTZ level of theory. ocepa3; OCEPA cc-pVDZ energy with ROHF initial guess for the NO radical. matrix1; An example of using BLAS and LAPACK calls directly from the Psi input file, demonstrating matrix multiplication, eigendecomposition, Cholesky decomposition and LU decomposition. These operations are performed on vectors and matrices provided from the Psi library. cc36; CC2(RHF)/cc-pVDZ energy of H2O. castup2; SCF with various combinations of pk/density-fitting, castup/no-castup, and spherical/cartesian settings. Demonstrates that puream setting is getting set by orbital basis for all df/castup parts of calc. Demonstrates that answer doesn’t depend on presence/absence of castup. Demonstrates (by comparison to castup3) that output file doesn’t depend on options (scf_type) being set global or local. This input uses global. omp3-grad1; OMP3 cc-pVDZ gradient for the H2O molecule. cc37; CC2(UHF)/cc-pVDZ energy of H2O+. fnocc1; Test QCISD(T) for H2O/cc-pvdz Energy. omp2-1; OMP2 cc-pVDZ energy for the H2O molecule. cepa0-grad1; CEPA0 cc-pVDZ gradie",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_testsuite-1.html:20833,energy,energy,20833,psi4manual/4.0b4/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_testsuite-1.html,8,['energy'],['energy']
Energy Efficiency," string <apdx:basisElement>`; :param delta4_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the fourth delta correction; to the correlation energy. :type delta5_basis: :ref:`basis string <apdx:basisElement>`; :param delta5_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the fifth delta correction; to the correlation energy. * Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, ``'highest_1'``, which uses the best basis; set available. See `Extrapolation Schemes`_ for all available schemes. :type scf_scheme: function; :param scf_scheme: |dl| ``highest_1`` |dr| || ``scf_xtpl_helgaker_3`` || etc. Indicates the basis set extrapolation scheme to be applied to the reference energy. :type corl_scheme: function; :param corl_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the correlation energy. :type delta_scheme: function; :param delta_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the delta correction; to the correlation energy. :type delta2_scheme: function; :param delta2_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the second delta correction; to the correlation energy. :type delta3_scheme: function; :param delta3_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the third delta correction; to the correlation energy. :type delta4_scheme: function; :param delta4_scheme: |dl| ``highest_1`` |dr| ||",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:60327,energy,energy,60327,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,1,['energy'],['energy']
Energy Efficiency," string <apdx:basisElement>`; :param delta_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. :type delta2_basis: :ref:`basis string <apdx:basisElement>`; :param delta2_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. * Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, ``'xtpl_highest_1'``, which uses the best basis; set available. See :ref:`sec:cbs_xtpl` for all available schemes. :type scf_scheme: string; :param scf_scheme: |dl| ``'xtpl_highest_1'`` |dr| || ``'scf_xtpl_helgaker_3'`` || etc. Indicates the basis set extrapolation scheme to be applied to the reference energy.; Defaults to :py:func:`~psi4.driver.driver_cbs.scf_xtpl_helgaker_3` if three valid basis sets; present in ``psi4.driver.driver_cbs.scf_basis``, :py:func:`~psi4.driver.driver_cbs.scf_xtpl_helgaker_2` if two valid basis; sets present in ``scf_basis``, and :py:func:`~psi4.driver.driver_cbs.xtpl_highest_1` otherwise. .. hlist::; :columns: 1. * :py:func:`~psi4.driver.driver_cbs.xtpl_highest_1`; * :py:func:`~psi4.driver.driver_cbs.scf_xtpl_helgaker_3`; * :py:func:`~psi4.driver.driver_cbs.scf_xtpl_helgaker_2`; * :py:func:`~psi4.driver.driver_cbs.scf_xtpl_truhlar_2`; * :py:func:`~psi4.driver.driver_cbs.scf_xtpl_karton_2`. :type corl_scheme: string; :param corl_scheme: |dl| ``'xtpl_highest_1'`` |dr| || ``'corl_xtpl_helgaker_2'`` || etc. Indicates the basis set extrapolation scheme to be applied to the correlation energy.; Defaults to :py:func:`~psi4.driver.driver_cbs.corl_xtpl_helgaker_2` if two valid basis sets; present in ``corl_basis`` and :py:func:",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html:27268,energy,energy,27268,psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,1,['energy'],['energy']
Energy Efficiency," string; :param delta2_wfn_lesser: |dl| ``delta_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta3_wfn: string; :param delta3_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a third delta correction; to the correlation energy is to be obtained. :type delta3_wfn_lesser: string; :param delta3_wfn_lesser: |dl| ``delta2_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a third delta correction; to the correlation energy is to be obtained. :type delta4_wfn: string; :param delta4_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a fourth delta correction; to the correlation energy is to be obtained. :type delta4_wfn_lesser: string; :param delta4_wfn_lesser: |dl| ``delta3_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a fourth delta correction; to the correlation energy is to be obtained. :type delta5_wfn: string; :param delta5_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a fifth delta correction; to the correlation energy is to be obtained. :type delta5_wfn_lesser: string; :param delta5_wfn_lesser: |dl| ``delta4_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a fifth delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set set through ``set`` commands have no influence; on a cbs calculation. :type scf_basis: :ref:`basis string <apdx:basisElement>`; :param scf_basis: |dl| ``corl_basis`` |dr| || ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, ``scf_basis`` can default; to ``corl_basis``. :type corl_basis: :ref:`basis string <apdx:basisElement>`; :param corl_bas",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:22279,energy,energy,22279,psi4manual/1.0.0/_modules/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html,6,['energy'],['energy']
Energy Efficiency," string; Default: RHF. REFERENCE_SYM (DETCI); DETCI (Expert) — Irrep for CI vectors; -1 = find automatically. This option allows the user to look for CI vectors of a different irrep than the reference. This probably only makes sense for Full CI, and it would probably not work with unit vector guesses. Numbering starts from zero for the totally-symmetric irrep. Type: integer; Default: -1. REORDER (TRANSQT); TRANSQT — Do ?. Type: boolean; Default: false. REPL_OTF (DETCI); DETCI (Expert) — Do string replacements on the fly in DETCI? Can save a gigantic amount of memory (especially for truncated CI’s) but is somewhat flaky and hasn’t been tested for a while. It may work only works for certain classes of RAS calculations. The current code is very slow with this option turned on. Type: boolean; Default: false. RESPONSE_ALGORITHM (DCFT); DCFT — The algorithm to use for the solution of the response equations for the analytic gradients and properties. Two-step algorithm is generally more efficient than simultaneous and is used by default. Type: string; Possible Values: TWOSTEP, SIMULTANEOUS; Default: TWOSTEP. RESTART (CCENERGY); CCENERGY — Do restart the coupled-cluster iterations from old and amplitudes? For geometry optimizations, Brueckner calculations, etc. the iterative solution of the CC amplitude equations may benefit considerably by reusing old vectors as initial guesses. Assuming that the MO phases remain the same between updates, the CC codes will, by default, re-use old vectors, unless the user sets RESTART = false. Type: boolean; Default: true. RESTART (CCLAMBDA); CCLAMBDA — Do ?. Type: boolean; Default: false. RESTART (CCRESPONSE); CCRESPONSE — Do restart from on-disk amplitudes?. Type: boolean; Default: true. RESTART (DETCI); DETCI — Do restart a DETCI iteration that terminated prematurely? It assumes that the CI and sigma vectors are on disk; the number of vectors specified by RESTART_VECS (obsolete) is collapsed down to one vector per root. Type: boolean; Defa",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodoc_glossary_options_c-1.html:82397,efficient,efficient,82397,psi4manual/4.0b2/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodoc_glossary_options_c-1.html,2,['efficient'],['efficient']
Energy Efficiency," string; Possible Values: DF, CONV, CD; Default: CONV. CC_UPDATE_EPS (DETCI); DETCI (Expert) — Do update T amplitudes with orbital eigenvalues? (Usually would do this). Not doing this is experimental. Type: boolean; Default: true. CC_VAL_EX_LEVEL (DETCI); DETCI — The CC valence excitation level. Type: integer; Default: 0. CC_VARIATIONAL (DETCI); DETCI (Expert) — Do use variational energy expression in CC computation? Experimental. Type: boolean; Default: false. CC_VECS_READ (DETCI); DETCI — Do import a CC vector from disk?. Type: boolean; Default: false. CC_VECS_WRITE (DETCI); DETCI — Do export a CC vector to disk?. Type: boolean; Default: false. CCD_E_CONVERGENCE (SAPT); SAPT — E converge value for CCD. Type: conv double; Default: 1e-8. CCD_MAXITER (SAPT); SAPT — Max CCD iterations. Type: integer; Default: 50. CCD_T_CONVERGENCE (SAPT); SAPT — Convergence tolerance for CCD amplitudes. Type: conv double; Default: 1e-8. CCL_ENERGY (OCC); OCC — Do compute CC Lambda energy? In order to this option to be valid one should use “TPDM_ABCD_TYPE = COMPUTE” option. Type: boolean; Default: false. CEPA_LEVEL (FNOCC); FNOCC (Expert) — Which coupled-pair method is called? This parameter is used internally by the python driver. Changing its value won’t have any effect on the procedure. Type: string; Default: CEPA(0). CEPA_NO_SINGLES (FNOCC); FNOCC — Flag to exclude singly excited configurations from a coupled-pair computation. Type: boolean; Default: false. CEPA_OS_SCALE (OCC); OCC — CEPA opposite-spin scaling value from SCS-CCSD. Type: double; Default: 1.27. CEPA_SOS_SCALE (OCC); OCC — CEPA Spin-opposite scaling (SOS) value. Type: double; Default: 1.3. CEPA_SS_SCALE (OCC); OCC — CEPA same-spin scaling value from SCS-CCSD. Type: double; Default: 1.13. CEPA_TYPE (OCC); OCC — CEPA type such as CEPA0, CEPA1 etc. currently we have only CEPA0. Type: string; Possible Values: CEPA0; Default: CEPA0. CFOUR_ABCDTYPE (CFOUR); CFOUR — Specifies the way the \(\langle ab||cd \rangle\) molecular o",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html:15989,energy,energy,15989,psi4manual/1.2.1/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html,4,['energy'],['energy']
Energy Efficiency," string; Possible Values: DF, CONV, CD; Default: CONV. CC_UPDATE_EPS (DETCI); DETCI (Expert) — Do update T amplitudes with orbital eigenvalues? (Usually would do this). Not doing this is experimental. Type: boolean; Default: true. CC_VAL_EX_LEVEL (DETCI); DETCI — The CC valence excitation level. Type: integer; Default: 0. CC_VARIATIONAL (DETCI); DETCI (Expert) — Do use variational energy expression in CC computation? Experimental. Type: boolean; Default: false. CC_VECS_READ (DETCI); DETCI — Do import a CC vector from disk?. Type: boolean; Default: false. CC_VECS_WRITE (DETCI); DETCI — Do export a CC vector to disk?. Type: boolean; Default: false. CCD_E_CONVERGENCE (SAPT); SAPT — E converge value for CCD. Type: conv double; Default: 1e-8. CCD_MAXITER (SAPT); SAPT — Max CCD iterations. Type: integer; Default: 50. CCD_T_CONVERGENCE (SAPT); SAPT — Convergence tolerance for CCD amplitudes. Type: conv double; Default: 1e-8. CCL_ENERGY (OCC); OCC — Do compute CC Lambda energy? In order to this option to be valid one should use “TPDM_ABCD_TYPE = COMPUTE” option. Type: boolean; Default: false. CEPA_LEVEL (FNOCC); FNOCC (Expert) — Which coupled-pair method is called? This parameter is used internally by the python driver. Changing its value won’t have any effect on the procedure. Type: string; Default: CEPA(0). CEPA_NO_SINGLES (FNOCC); FNOCC — Flag to exclude singly excited configurations from a coupled-pair computation. Type: boolean; Default: false. CEPA_OS_SCALE (OCC); OCC — CEPA opposite-spin scaling value from SCS-CCSD. Type: double; Default: 1.27. CEPA_SOS_SCALE (OCC); OCC — CEPA Spin-opposite scaling (SOS) value. Type: double; Default: 1.3. CEPA_SS_SCALE (OCC); OCC — CEPA same-spin scaling value from SCS-CCSD. Type: double; Default: 1.13. CEPA_TYPE (OCC); OCC — CEPA type such as CEPA0, CEPA1 etc. currently we have only CEPA0. Type: string; Possible Values: CEPA0; Default: CEPA0. CFOUR_ABCDTYPE (CFOUR); CFOUR — Specifies the way the molecular orbital integrals are handle",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:16393,energy,energy,16393,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,2,['energy'],['energy']
Energy Efficiency," structure but is in a symmetry plane of the molecule. opt-irc-1; Compute the IRC for HOOH torsional rotation at the RHF/DZP level of theory. cc33; CC3(UHF)/cc-pVDZ H2O \(R_e\) geom from Olsen et al., JCP 104, 8007 (1996). sapt10; usapt example with empty beta due to frozen core. dct3; DC-06 calculation for the He dimer. This performs a simultaneous update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the AO Basis, using integrals stored on disk. props3; DF-SCF cc-pVDZ multipole moments of benzene, up to 7th order and electrostatic potentials evaluated at the nuclear coordinates. dfomp2-grad1; DF-OMP2 cc-pVDZ gradients for the H2O molecule. explicit-am-basis; Check that basis sets can be input with explicit angular momentum format. scf-guess-read2; Test if the the guess read in the same basis converges. dfmp2-4; conventional and density-fitting mp2 test of mp2 itself and setting scs-mp2. pywrap-checkrun-rhf; This checks that all energy methods can run with a minimal input and set symmetry. cbs-xtpl-nbody; RHF interaction energies using nbody and cbs parts of the driver Ne dimer with mp2/v[dt]z + d:ccsd(t)/vdz. dfep2-2; Compute three IP and 2 EA’s for the PH3 molecule. mints8; Patch of a glycine with a methyl group, to make alanine, then DF-SCF energy calculation with the cc-pVDZ basis set. cc44; Test case for some of the PSI4 out-of-core codes. The code is given only 2.0 MB of memory, which is insufficient to hold either the A1 or B2 blocks of an ovvv quantity in-core, but is sufficient to hold at least two copies of an oovv quantity in-core. cc54; CCSD dipole with user-specified basis set. dfccd-grad1; DF-CCSD cc-pVDZ gradients for the H2O molecule. mints1; Symmetry tests for a range of molecules. This doesn’t actually compute any energies, but serves as an example of the many ways to specify geometries in Psi4. fcidump; test FCIDUMP functionality for rhf/uhf. cc8c; ROHF-CCSD cc-pVDZ frozen-core energy for the \(^2\Si",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html:2947,energy,energy,2947,psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency," structure in Hartrees. Returns:(float, Wavefunction) – energy and wavefunction when return_wfn specified. Raises:psi4.OptimizationConvergenceError if GEOM_MAXITER exceeded without reaching geometry convergence. PSI variables:. CURRENT ENERGY. Parameters:; name (string) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. return_history (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (string) – 'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; Hartr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/opt-1.html:1892,energy,energy,1892,psi4manual/1.3.2/opt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/opt-1.html,2,['energy'],['energy']
Energy Efficiency," structure in Hartrees. Returns:(float, Wavefunction) – energy and wavefunction when return_wfn specified. Raises:psi4.OptimizationConvergenceError if GEOM_MAXITER exceeded without reaching geometry convergence. PSI variables:. CURRENT ENERGY. Parameters:; name (string) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. return_history (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. For maximum; flexibility, return_wfn is always on in 'reap' mode. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (string) – 'scf' || 'mp2' || etc.; Indicates the comp",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/opt-1.html:1892,energy,energy,1892,psi4manual/1.2.1/opt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/opt-1.html,2,['energy'],['energy']
Energy Efficiency," subsets of the requested database, either; 'small', a few of the smallest database members,; 'large', the largest of the database members, or; 'equilibrium', the equilibrium geometries for a database; composed of dissociation curves. 'BzBz_S' || 'FaOOFaON' || 'ArNe' || 'HB' || etc.For databases composed of dissociation curves, or otherwise; divided into subsets, individual curves and subsets can be; called by name. Consult the database python files for available; molecular systems (case insensitive). [1,2,5] || ['1','2','5'] || ['BzMe-3.5', 'MeMe-5.0'] || etc.Specify a list of database members to run. Consult the; database python files for available molecular systems. This; is the only portion of database input that is case sensitive;; choices for this keyword must match the database python file. Examples. >>> # [1] Two-stage SCF calculation on short, equilibrium, and long helium dimer; >>> db('scf','RGC10',cast_up='sto-3g',subset=['HeHe-0.85','HeHe-1.0','HeHe-1.5'], tabulate=['scf total energy','natom']). >>> # [2] Counterpoise-corrected interaction energies for three complexes in S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('mp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). Output¶; At the beginning of a database job is printed a listing of the individual system; calculations which will be performed. The output snippet below is from the example job [1]; above. It shows each reagent required for the subset of database reactions requested.; Note that this is an un-counte",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/db-1.html:5535,energy,energy,5535,psi4manual/1.4.0/db-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/db-1.html,5,['energy'],['energy']
Energy Efficiency," sum of frozen orbitals of each monomer. Prior to; this, a discrepency between these values was possible when one of the monomers was (exclusively); a charged alkali metal. Symmetry-adapted perturbation theory (SAPT) provides a means of directly; computing the noncovalent interaction between two molecules, that is, the; interaction energy is determined without computing the total energy of the; monomers or dimer. In addition, SAPT provides a decomposition of the; interaction energy into physically meaningful components: i.e.,; electrostatic, exchange, induction, and dispersion terms. In SAPT, the; Hamiltonian of the dimer is partitioned into contributions from each; monomer and the interaction. \[H=F_A+W_A+F_B+W_B+V\]; Here, the Hamiltonian is written as a sum of the usual monomer Fock; operators, \(F\), the fluctuation potential of each monomer, \(W\), and the; interaction potential, \(V\). The monomer Fock operators, \(F_A+F_B\), are; treated as the zeroth-order Hamiltonian and the interaction energy is; evaluated through a perturbative expansion of \(V\), \(W_A\), and \(W_B\).; Through first-order in \(V\), electrostatic and exchange interactions are; included; induction and dispersion first appear at second-order in \(V\). For; a complete description of SAPT, the reader is referred to the excellent; review by Jeziorski, Moszynski, and Szalewicz [Jeziorski:1994:1887].; Several truncations of the closed-shell SAPT expansion are available in the SAPT; module of PSI4. The simplest truncation of SAPT is denoted SAPT0; and defined in Eq. (1). (1)¶\[E_{SAPT0} = E_{elst}^{(10)} + E_{exch}^{(10)} + E_{ind,resp}^{(20)} +; E_{exch-ind,resp}^{(20)} + E_{disp}^{(20)} + E_{exch-disp}^{(20)} + \delta_{HF}^{(2)}\]; In this notation, \(E^{(vw)}\) defines the order in \(V\) and in \(W_A+W_B\); the; subscript, \(resp\), indicates that orbital relaxation effects are included. (2)¶\[E_{SAPT2} = E_{SAPT0} + E_{elst,resp}^{(12)} + E_{exch}^{(11)} +; E_{exch}^{(12)} + \; ^{t}\!E_{ind}^",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/sapt-1.html:2785,energy,energy,2785,psi4manual/1.5.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/sapt-1.html,2,['energy'],['energy']
Energy Efficiency," sup.set_description(' PBE0 SR-XC Functional (HJS Model)\n'); sup.set_x_omega(0.3); sup.set_x_alpha(0.25); return sup. [docs]def build_wpbesol_superfunctional(name, npoints, deriv):. # Call this first; sup = PsiMod.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('wPBEsol'); # Tab in, trailing newlines; sup.set_description(' PBEsol SR-XC Functional (HJS Model)\n'); # Tab in, trailing newlines; sup.set_citation(' Henderson et. al., J. Chem. Phys., 128, 194105, 2008\n Weintraub, Henderson, and Scuseria, J. Chem. Theory. Comput., 5, 754 (2009)\n'). # Add member functionals; sup.add_x_functional(build_functional('wPBEsol_X')); sup.add_c_functional(build_functional('PBE_C')). # Set GKS up after adding functionals; sup.set_x_omega(0.4); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_wpbesol0_superfunctional(name, npoints, deriv):. sup = build_wpbesol_superfunctional(name, npoints, deriv); sup.set_name('wPBEsol0'); sup.set_description(' PBEsol0 SR-XC Functional (HJS Model)\n'); sup.set_x_omega(0.3); sup.set_x_alpha(0.25); return sup. [docs]def build_wblyp_superfunctional(name, npoints, deriv):. # Call this first; sup = PsiMod.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('wBLYP'); # Tab in, trailing newlines; sup.set_description(' BLYP SR-XC Functional (HJS Model)\n'); # Tab in, trailing newlines; sup.set_citation(' Henderson et. al., J. Chem. Phys., 128, 194105, 2008\n Weintraub, Henderson, and Scuseria, J. Chem. Theory. Comput., 5, 754 (2009)\n'). # Add member functionals; sup.add_x_functional(build_functional('wB88_X')); sup.add_c_functional(build_functional('LYP_C')). # Set GKS up after adding functionals; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/functional.html:42891,allocate,allocate,42891,psi4manual/4.0b2/_modules/functional.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/functional.html,3,['allocate'],['allocate']
Energy Efficiency," symmetry, and then in C1. cbs-delta-energy; Extrapolated energies with delta correction. sapt-dft1; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. dfrasscf-sp; 6-31G** H2O Test RASSCF Energy Point will default to only singles and doubles in the active space. pywrap-db1; Database calculation, so no molecule section in input file. Portions of the full databases, restricted by subset keyword, are computed by sapt0 and dfmp2 methods. frac-ip-fitting; Omega optimization for LRC functional wB97 on water. dfccsdat1; DF-CCSD(AT) cc-pVDZ energy for the H2O molecule. dfomp2-grad1; DF-OMP2 cc-pVDZ gradients for the H2O molecule. tdscf-2; td-uhf test on triplet states of methylene (tda), wfn passing. opt6; Various constrained energy minimizations of HOOH with cc-pvdz RHF Internal-coordinate constraints in internal-coordinate optimizations. scf-freq1; Analytic vs. finite difference DF-SCF frequency test for water. cc51; EOM-CC3/cc-pVTZ on H2O. opt7; Various constrained energy minimizations of HOOH with cc-pvdz RHF. For “fixed” coordinates, the final value is provided by the user. nbody-freq; Vibrational and thermo analysis of water trimer (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). gibbs; Test Gibbs free energies at 298 K of N2, H2O, and CH4. mints5; Tests to determine full point group symmetry. Currently, these only matter for the rotational symmetry number in thermodynamic computations. stability2; ROHF stability analysis check for CN with cc-pVDZ. This test corresponds to the rohf-stab test from Psi3. cc27; Single point gradient of 1-1B2 state of H2O with EOM-CCSD. frac; Carbon/UHF Fractionally-Occupied SCF Test Case. cc33; CC3(UHF)/cc-pVDZ H2O \(R_e\) geom from Olsen et al., JCP 104, 8007 (1996). psimrcc-ccsd_t-1; Mk-MRCCSD(T) single point. \(^1A_1\) CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. cc54; CCSD dipole with user-specified basis set. opt1-fd; SCF STO-3G geometry optimzation, with Z-mat",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html:9872,energy,energy,9872,psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency," template; .pymol scripts to help with this process. These can be obtained by running:; >>> copy_pymol2.py. and then in PyMol:; >>> @run.pymol. This last command runs all of the individual .pymol files (e.g.,; DA.pymol), which in turn load in the molecule and cube file data; (contained in the .cube file), set up the visualization, and render a; .png image of the scene. Generally the view orientation and some specific; details of the .pymol files require some small tweaks to permit; publication-quality renderings. Adding Point Charges to F/I-SAPT Computations¶; Point charges can be added to the interacting subsystems A and B as well; as to the linking fragment C. Briefly, the interaction between the point charges in A(B); and fragment B(A) enters the SAPT0 interaction energy. It explicitly affects the electrostatics; and induction components, and implicitly affects other SAPT0 components by polarizing the orbitals.; If point charges are present in both subsystems A and B, an additional charge-charge interaction; term is also added to the electrostatic energy. When point charges are assigned to subsystem C, the point; charges in C only polarize the orbitals in both fragment A and B. However, the presence of charges in C does not; directly contribute to the SAPT0 interaction energy.; Examples fsapt-ext-abc and fsapt-ext-abc2; illustrate the use of point charges in F/I-SAPT procedure. Link Orbital Partitioning in I-SAPT¶; The assignment of the A-C and B-C linking electron pairs is controlled by the FISAPT_LINK_ASSIGNMENT; keyword. The default setting fisapt_link_assignment c assigns the entire pair to the linker C together with; a +1 nuclear charge from the connecting atoms of A/B to preserve the electrical neutrality of each fragment.; However, as already noticed in [Parrish:2015:051103], such a partitioning might result in unphysical dipole; moments at the interfragment boundaries. Imagine, for example, that I-SAPT is used to examine the interaction; of two methyl grou",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/fisapt.html:12545,charge,charges,12545,psi4manual/1.8.x/fisapt.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/fisapt.html,9,"['charge', 'energy']","['charge-charge', 'charges', 'energy']"
Energy Efficiency," test should match RHF values exactly. cc56; EOM-CCSD/6-31g excited state transition data for water cation. dfomp2p5-grad2; DF-OMP2.5 cc-pVDZ gradients for the H2O+ cation. cc44; Test case for some of the PSI4 out-of-core codes. The code is given only 2.0 MB of memory, which is insufficient to hold either the A1 or B2 blocks of an ovvv quantity in-core, but is sufficient to hold at least two copies of an oovv quantity in-core. cc31; CCSD/sto-3g optical rotation calculation (both gauges) at two frequencies on methyloxirane. dfomp2-3; OMP2 cc-pVDZ energy for the H2O molecule. nbody-he-cluster; MP2/aug-cc-pv[DT]Z many body energies of an arbitrary Helium complex Size vs cost tradeoff is rough here. psimrcc-ccsd_t-3; Mk-MRCCSD(T) single point. \(^1A_1\) CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. omp2-grad1; OMP2 cc-pVDZ gradient for the H2O molecule. fnocc3; Test FNO-QCISD(T) computation. cc8b; ROHF-CCSD cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Cartesian input. mp2-grad1; MP2 cc-pVDZ gradient for the H2O molecule. frac; Carbon/UHF Fractionally-Occupied SCF Test Case. mp3-grad2; MP3 cc-pVDZ gradient for the NO radical. aediis-2; EDIIS test case from 10.1063/1.1470195. scf-ecp3; Water-Argon complex with ECP present; check of UHF Hessian. matrix1; An example of using BLAS and LAPACK calls directly from the Psi input file, demonstrating matrix multiplication, eigendecomposition, Cholesky decomposition and LU decomposition. These operations are performed on vectors and matrices provided from the Psi library. psimrcc-ccsd_t-1; Mk-MRCCSD(T) single point. \(^1A_1\) CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. dfmp2-grad1; DF-MP2 cc-pVDZ gradients for the H2O molecule. sapt1; SAPT0 cc-pVDZ computation of the ethene-ethyne interaction energy, using the cc-pVDZ-JKFIT RI basis for SCF and cc-pVDZ-RI for SAPT. Monomer geometries are specified using Cartes",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html:24726,energy,energy,24726,psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency," testing has been done to match supplemental info of Szalewicz et. al., Phys. Rev. Lett., 103, 263201 (2009) and Szalewicz et. al., J. Phys. Chem. Lett., 1, 550-555 (2010). cc23; ROHF-EOM-CCSD/DZ analytic gradient lowest state of H2O+ (A1 excitation). cc41; RHF-CC2-LR/cc-pVDZ optical rotation of H2O2. gauge = both, omega = (589 355 nm). dfccsd1; DF-CCSD cc-pVDZ energy for the H2O molecule. cc52; CCSD Response for H2O2. zaptn-nh2; ZAPT(n)/6-31G NH2 Energy Point, with n=2-25. pywrap-checkrun-rhf; This checks that all energy methods can run with a minimal input and set symmetry. mints4; A demonstration of mixed Cartesian/ZMatrix geometry specification, using variables, for the benzene-hydronium complex. Atoms can be placed using ZMatrix coordinates, whether they belong to the same fragment or not. Note that the Cartesian specification must come before the ZMatrix entries because the former define absolute positions, while the latter are relative. cc4; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. After the computation, the checkpoint file is renamed, using the PSIO handler. cc30; CCSD/sto-3g optical rotation calculation (length gauge only) at two frequencies on methyloxirane. cisd-h2o+-2; 6-31G** H2O+ Test CISD Energy Point. mp3-grad2; MP3 cc-pVDZ gradient for the NO radical. dcft6; DCFT calculation for the triplet O2 using DC-06, DC-12 and CEPA0 functionals. Only two-step algorithm is tested. cc3; cc3: RHF-CCSD/6-31G** H2O geometry optimization and vibrational frequency analysis by finite-differences of gradients. sapt1; SAPT0 cc-pVDZ computation of the ethene-ethyne interaction energy, using the cc-pVDZ-JKFIT RI basis for SCF and cc-pVDZ-RI for SAPT. Monomer geometries are specified using Cartesian coordinates. castup1; Test of SAD/Cast-up (mainly not dying due to file weirdness). cc51; EOM-CC3/cc-pVTZ on H2O. dfmp2-1; Density fitted MP2 cc-PVDZ/cc-pVDZ-RI computation of formic acid dimer binding energy using automatic counterpoise ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html:5624,energy,energy,5624,psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency," text; else:; with open(outfile, mode='w') as handle:; handle.write(text). [docs] def pyprint_gamess(self, outfile=None):; """"""Print out the shell in Gamess format""""""; text = """"""%c %3d\n"""""" % (self.AMCHAR(), self.nprimitive()); for K in range(self.nprimitive()):; text += """"""%3d %15.8f %15.8f\n"""""" % (K + 1, self.PYexp[K], self.PYoriginal_coef[K]). if outfile is None:; return text; else:; with open(outfile, mode='w') as handle:; handle.write(text). def __str__(self):; """"""String representation of shell""""""; return self.pyprint(outfile=None). [docs] def normalize(self, l, m, n):; """"""Normalize the angular momentum component""""""; return 1.0. [docs] def function_index(self):; """"""Basis function index where this shell starts.""""""; return self.start. [docs] def set_function_index(self, i):; """"""Set basis function index where this shell starts.""""""; self.start = i. [docs]class GaussianShell(ShellInfo):; """"""Class with same information as :py:class:`ShellInfo`. In C++,; class uses more efficient data structures, but in Python differences; minimal. """""". def __init__(self, am, nprimitive, oc, c, ec, e, pure, nc, center, start):; """"""; * @param am Angular momentum.; * @param pure Pure spherical harmonics, or Cartesian.; * @param oc An array of contraction coefficients.; * @param c An array of normalized contraction coefficients.; * @param ec An array of ERD normalized contraction coefficients.; * @param e An array of exponent values.; * @param pure an enum describing whether this shell uses pure or Cartesian functions.; * @param nc The atomic center that this shell is located on. Must map back to the correct atom in the owning BasisSet molecule_. Used in integral derivatives for indexing.; * @param center The x, y, z position of the shell. This is passed to reduce the number of calls to the molecule.; * @param start The starting index of the first function this shell provides. Used to provide starting positions in matrices.; * @param pt Is the shell already normalized?. """"""; self.l = am; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsgshell.html:10194,efficient,efficient,10194,psi4manual/1.0.0/_modules/qcdb/libmintsgshell.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsgshell.html,1,['efficient'],['efficient']
Energy Efficiency," than that of default Schwarz screening. Type: string; Possible Values: SCHWARZ, CSAM; Default: CSAM. SAPT(DFT)¶. SAPT_DFT_DO_DHF¶. Compute the Delta-HF correction?. Type: boolean; Default: true. SAPT_DFT_EXCH_DISP_SCALE_SCHEME¶. Scheme for approximating exchange-dispersion for SAPT-DFT. NONE Use unscaled Exch-Disp2,u . FIXED Use a fixed factor SAPT_DFT_EXCH_DISP_FIXED_SCALE to scale Exch-Disp2,u . DISP Use the ratio of Disp2,r and Disp2,u to scale Exch-Disp2,u . Type: string; Possible Values: NONE, FIXED, DISP; Default: DISP. SAPT_DFT_GRAC_SHIFT_A¶. Monomer A GRAC shift in Hartree. Type: double; Default: 0.0. SAPT_DFT_GRAC_SHIFT_B¶. Monomer B GRAC shift in Hartree. Type: double; Default: 0.0. Expert SAPT(HF)¶. COUPLED_INDUCTION¶. Solve the CPHF equations to compute coupled induction and exchange-induction. These are not available for ROHF, and the option is automatically false in this case. In all other cases, coupled induction is strongly recommended. Only turn it off if the induction energy is not going to be used. Type: boolean; Default: true. DO_CCD_DISP¶. Do CCD dispersion correction in SAPT2+, SAPT2+(3) or SAPT2+3?. Type: boolean; Default: false. DO_DISP_EXCH_SINF¶. For SAPT(DFT) computes the \(S^{inf}\) Exchange-Dispersion terms. Type: boolean; Default: false. DO_IND_EXCH_SINF¶. For SAPT(DFT) computes the \(S^{inf}\) Exchange-Induction terms. Type: boolean; Default: false. DO_MBPT_DISP¶. Do MBPT dispersion correction in SAPT2+, SAPT2+(3) or SAPT2+3, if also doing CCD?. Type: boolean; Default: true. DO_THIRD_ORDER¶. Do compute third-order corrections?. Type: boolean; Default: false. SAPT0_E10¶. For SAPT0 only, compute only first-order electrostatics and exchange. The integrals are computed before any terms, so all integrals will be computed even if they are not needed for the requested term. Type: boolean; Default: false. SAPT0_E20DISP¶. For SAPT0 only, compute only second-order induction The integrals are computed before any terms, so all integrals will be c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodir_options_c/module__sapt-1.html:5863,energy,energy,5863,psi4manual/1.4.0/autodir_options_c/module__sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/module__sapt-1.html,2,['energy'],['energy']
Energy Efficiency," that CCSD computationally, but it retains the; \({\cal{O}}(o^2v^4)\) complexity of the original equations. Just as in; the familiar CCSD(T) method, the effects of connected triple excitations; may be included noniteratively to yield the QCISD(T) method. Both the; QCISD(T) and CCSD(T) methods are implemented for closed-shell references; in the FNOCC module. Many-body perturbation theory¶; QCI and CC methods are closely related to perturbation theory, and the; MP2, MP3, and MP4(SDQ) correlation energies can be obtained as a free; by-product of a CCSD or QCISD computation. The following is an; example of the results for a computation run with the call; energy('fno-qcisd') to energy():; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30QCISD iterations converged!. OS MP2 FNO correction: -0.000819116338; SS MP2 FNO correction: -0.000092278158; MP2 FNO correction: -0.000911394496. OS MP2 correlation energy: -0.166478414245; SS MP2 correlation energy: -0.056669079827; MP2 correlation energy: -0.223147494072; * MP2 total energy: -76.258836941658. OS MP2.5 correlation energy: -0.171225850256; SS MP2.5 correlation energy: -0.054028401038; MP2.5 correlation energy: -0.225254251294; * MP2.5 total energy: -76.260943698880. OS MP3 correlation energy: -0.175973286267; SS MP3 correlation energy: -0.051387722248; MP3 correlation energy: -0.227361008515; * MP3 total energy: -76.263050456101. OS MP4(SDQ) correlation energy: -0.180324322304; SS MP4(SDQ) correlation energy: -0.048798468084; MP4(SDQ) correlation energy: -0.230995119324; * MP4(SDQ) total energy: -76.266684566910. OS QCISD correlation energy: -0.181578117924; SS QCISD correlation energy: -0.049853548145; QCISD correlation energy: -0.231431666069; * QCISD total energy: -76.267121113654. The first set of energies printed corresponds to the second-order FNO; correction mentioned previously. Results for many-body perturbation; theory through partial fourth order are t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/fnocc-1.html:5531,energy,energy,5531,psi4manual/1.1.0/fnocc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/fnocc-1.html,6,['energy'],['energy']
Energy Efficiency," that only a few bottlenecks exist in a typical; calculation; by focusing on optimized C++ implementations of these bottlenecks; and making these C++ functions available in Python, most of the code to implement; the overall calculation can be written in simpler Python code. Python is far; better suited to management tasks such as directory navigation and retrieval,; making it a natural choice for overall calculation layout than C++. With the; emergence of NumPy as a standard tool for executing almost any; mathematical technique efficiently in Python, the transitioning of code from; C++ to Python has facilitated a much simpler work flow for prototyping and; developing methods: this is detailed in the next section. Rapid initial development using Psi4NumPy¶; The Psi4NumPy project [Smith:2018:3504] is the recommended; mechanism for developing and prototyping new methods in Psi4. Because; NumPy provides such a rich set of features for efficient linear; algebra, Fourier transforms, and general tensor manipulations, a massive number; of methods can be easily implemented very easily using that library. To; facilitate this workflow, PSI4 exports key quantities such as integrals,; densities and molecular orbitals in NumPy format. From this point, the; programmer can simply call the appropriate PSI4 functions to compute the; desired input quantities, retrieve them in NumPy format, and then write the; remaining code using standard Python and/or NumPy syntax. This approach does; not require any recompilation of code, resulting in a particularly facile; development workflow. Detailed examples and tutorials are available in the; Psi4NumPy repository. Avoiding the need to modify Psi4, using plugins¶; In the early days when PSI4 was still primarily a C++ code, development; was very cumbersome due to a lengthy build process. To expedite development, a; plugin system was developed. This plugin machinery allows developers to access; the classes defined in the innards of PSI4, with onl",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/prog_ways_to_add-1.html:2132,efficient,efficient,2132,psi4manual/1.4.0/prog_ways_to_add-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/prog_ways_to_add-1.html,9,['efficient'],['efficient']
Energy Efficiency," that orbital relaxation effects are included. (2)¶\[E_{SAPT2} = E_{SAPT0} + E_{elst,resp}^{(12)} + E_{exch}^{(11)} +; E_{exch}^{(12)} + \; ^{t}\!E_{ind}^{(22)} + \; ^{t}\!E_{exch-ind}^{(22)}\]. (3)¶\[E_{SAPT2+} = E_{SAPT2} + E_{disp}^{(21)} + E_{disp}^{(22)}\]. (4)¶\[E_{SAPT2+(3)} = E_{SAPT2+} + E_{elst,resp}^{(13)} + E_{disp}^{(30)}\]. (5)¶\[E_{SAPT2+3} = E_{SAPT2+(3)}; + E_{exch-ind}^{(30)} + E_{ind,resp}^{(30)}; + E_{exch-disp}^{(30)} + E_{ind-disp}^{(30)} + E_{exch-ind-disp}^{(30)}; - \delta_{HF}^{(2)} + \delta_{HF}^{(3)}\]; For SAPT(DFT), the SAPT expansion is truncated at the same level of SAPT0, but the zeroth-order Hamiltonian is chosen to be \(K_A+K_B\), the monomer Kohn-Sham operators, instead of the Fock operators. The dispersion term needs to be computed with orbital relaxation for the result to be reasonable, and this is possible by computing dispersion energy through coupled frequency-dependent density susceptibility (FDDS). The exchange-dispersion term is estimated by scaling the uncoupled exchange-dispersion energy. (6)¶\[E_{SAPT(DFT)} = E_{elst}^{(10)} + E_{exch}^{(10)} + E_{ind,resp}^{(20)} +; E_{exch-ind,resp}^{(20)} + E_{disp,resp}^{(20)} + E_{exch-disp,resp}^{(20)}(est.) + \delta_{HF}^{(2)}\]. \[E_{disp,resp}^{(20)} = -\frac{1}{2\pi}\int_0^\infty d\omega \int d\mathbf{r}_A d\mathbf{r}'_A d\mathbf{r}_B d\mathbf{r}'_B \frac{1}{\left|\mathbf{r}_A-\mathbf{r}_B\right|}\frac{1}{\left|\mathbf{r}'_A-\mathbf{r}'_B\right|}\chi^A_{coup}\left(\mathbf{r}_A,\mathbf{r}'_A|i\omega\right)\chi^B_{coup}\left(\mathbf{r}_B,\mathbf{r}'_B|i\omega\right)\]. \[\chi_{coup}\left(\mathbf{r},\mathbf{r}'|\omega\right) = \chi_0\left(\mathbf{r},\mathbf{r}'|\omega\right) + \int d\omega d\mathbf{r}_1 d\mathbf{r}_2 \chi_0\left(\mathbf{r},\mathbf{r}_1|\omega\right)\left[\frac{1}{r_{12}} + f_{xc}\left(\mathbf{r}_1,\mathbf{r}_2,\omega\right)\right]\chi\left(\mathbf{r}_2,\mathbf{r}'|\omega\right)\]; The \(\delta_{HF}^{(2)}\) and \(\delta_{HF}^{(3)}\) terms take into; account higher-o",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/sapt-1.html:4261,energy,energy,4261,psi4manual/1.4.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/sapt-1.html,9,['energy'],['energy']
Energy Efficiency," that stage in defining the CBS energy. The cbs() function requires, at a minimum, ``name='scf'`` and ``scf_basis``; keywords to be specified for reference-step only jobs and ``name`` and; ``corl_basis`` keywords for correlated jobs. The following energy methods have been set up for cbs(). .. hlist::; :columns: 5. * scf; * mp2; * mp2.5; * mp3; * mp4(sdq); * mp4; * omp2; * omp3; * ocepa; * cepa0; * cepa(0); * cepa(1); * cepa(3); * acpf; * aqcc; * qcisd; * cc2; * ccsd; * fno-df-ccsd; * bccd; * cc3; * qcisd(t); * ccsd(t); * fno-df-ccsd(t); * bccd(t); * cisd; * cisdt; * cisdtq; * ci\ *n*; * fci. :type name: string; :param name: ``'scf'`` || ``'ccsd'`` || etc. First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be ``'scf'``. Overruled if stage_wfn keywords supplied. :type corl_wfn: string; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: string; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: string; :param delta_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: string; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: string; :param delta2_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set se",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:54908,energy,energy,54908,psi4manual/4.0b4/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html,2,['energy'],['energy']
Energy Efficiency," that the conda distribution must be in $PATH or the; conda enviroment must be activated before compilation and execution of; plugins created using this procedure. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; Psi4 code is not necessary.; input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file.; This is usually done by manipulating PSIPATH. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection.; pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of Psi4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main Psi4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file.; __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; addit",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/plugins-1.html:6142,energy,energy,6142,psi4manual/1.0.0/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/plugins-1.html,2,['energy'],['energy']
Energy Efficiency," that you got a; high-quality calculation cheaply. Loops¶; Python provides many control structures, which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:; basis_sets=[""cc-pVDZ"",""cc-pVTZ"",""cc-pVQZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of basis_set is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that basis_set is a; Python variable, not a string, by prefixing it with a dollar sign.; The geometry specification supports delayed initialization of variable,; which permits potential energy scans. As an example, we can scan both the; angle and bond length in water:; molecule h2o{; O; H1 R; H1 R2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(102,106,2). set basis cc-pvdz; set scf e_convergence=11; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('scf'). The declarations of Rvals and Avals are both completely standard Python syntax.; Having named our molecule h2o we can then set the values of R and A within; the loops. Note that we do not need the dollar sign to access the Python; variable in this example; that is required only when using Python variables; with the set keyword. Tables of Results¶; The results of computations can be compactly tabulated with the Table() Psithon; function. For example, in the following potential energy surface scan for water; molecule h2o {; O; H 1 R; H 1 R 2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(100,102,2). table=Table(rows=[""R"",""A""], cols=[""E(SCF)"",""E(SCS)"",""E(DFMP2)""]). set basis cc-pvdz. for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('df-mp2'); escf = get_variable('SCF TOTAL ENERGY'); edfmp2 = get_variable('DF-MP2 TOTAL ENERGY'); escsmp2 = get_variable('SCS-DF-MP2 TOTAL ENERGY'); table[R][A] = [escf, escsmp2, edfmp2]. print table; relative=table.copy(); relative.absolute_to",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:25501,energy,energy,25501,psi4manual/4.0b4/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html,4,['energy'],['energy']
Energy Efficiency," the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. delta2_wfn_lesser (str) – \(\Rightarrow\) delta_wfn \(\Leftarrow\) || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. Basis SetsCurrently, the basis set set through set commands have no influence; on a cbs calculation. Parameters. scf_basis (basis string) – \(\Rightarrow\) corl_basis \(\Leftarrow\) || 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, scf_basis can default; to corl_basis. corl_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the correlation energy. delta_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. delta2_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. SchemesTransformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, 'xtpl_highest_1', which uses the best basis; set available. See Extrapolation Schemes for all available schemes. Parameters. scf_scheme (Callable) – \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || scf_xtpl_helgaker_3 || etc.; Indicates the basis set extrapolation scheme to be applied to the reference energy.; Defaults to scf_xtpl_helgaker_3() if three valid basis sets; present in psi4.driver.driver_cbs.scf_basis, scf_xtpl_helgaker_2() if two valid basis; sets present in scf_basis, and xtpl_high",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.cbs-1.html:7229,energy,energy,7229,psi4manual/1.4.0/api/psi4.driver.cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.cbs-1.html,8,['energy'],['energy']
Energy Efficiency," the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. delta2_wfn_lesser (str) – \(\Rightarrow\) delta_wfn \(\Leftarrow\) || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. Basis SetsCurrently, the basis set set through set commands have no influence; on a cbs calculation. Parameters. scf_basis (basis string) – \(\Rightarrow\) corl_basis \(\Leftarrow\) || 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, scf_basis can default; to corl_basis. corl_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the correlation energy. delta_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. delta2_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. SchemesTransformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, 'xtpl_highest_1', which uses the best basis; set available. See Extrapolation Schemes for all available schemes. Parameters. scf_scheme (string) – \(\Rightarrow\) 'xtpl_highest_1' \(\Leftarrow\) || 'scf_xtpl_helgaker_3' || etc.; Indicates the basis set extrapolation scheme to be applied to the reference energy.; Defaults to scf_xtpl_helgaker_3() if three valid basis sets; present in psi4.driver.driver_cbs.scf_basis, scf_xtpl_helgaker_2() if two valid basis; sets present in scf_basis, and xtpl_hi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.driver.cbs.html:7229,energy,energy,7229,psi4manual/1.6.x/api/psi4.driver.cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.driver.cbs.html,2,['energy'],['energy']
Energy Efficiency," the Atomic Orbital to Symmetry Orbital transformer. arrays(self: psi4.core.Wavefunction) → Dict[str, psi4.core.Matrix]¶; Returns the map of all internal arrays. atomic_point_charges(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.RHF, basis: psi4.core.BasisSet) → psi4.core.RHF; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet basis. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. cphf_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix]) → List[psi4.core.Matrix]¶; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF) → bool¶; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: List[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int=2) → List[psi4.core.Matrix]¶; Solves the CPHF equations for a given set of x vectors. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wav",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/api/psi4.core.rhf.html:3287,energy,energy,3287,psi4manual/1.2.1/api/psi4.core.rhf.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/api/psi4.core.rhf.html,1,['energy'],['energy']
Energy Efficiency," the Atomic Orbital to Symmetry Orbital transformer. arrays(self: psi4.core.Wavefunction) → Dict[str, psi4.core.Matrix]¶; Returns the map of all internal arrays. atomic_point_charges(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.UHF, basis: psi4.core.BasisSet) → psi4.core.UHF; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet basis. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. cphf_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix]) → List[psi4.core.Matrix]¶; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF) → bool¶; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: List[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int=2) → List[psi4.core.Matrix]¶; Solves the CPHF equations for a given set of x vectors. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wav",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/api/psi4.core.uhf.html:3287,energy,energy,3287,psi4manual/1.2.1/api/psi4.core.uhf.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/api/psi4.core.uhf.html,1,['energy'],['energy']
Energy Efficiency," the C++; class are: no basisset handling, no symmetry, no pubchem. This class; translated so that databases can function independently of psi4.; >>> H2OH2O = qcdb.Molecule(""""""; 0 1; O1 -1.551007 -0.114520 0.000000; H1 -1.934259 0.762503 0.000000; H2 -0.599677 0.040712 0.000000; --; 0 1; X 0.000000 0.000000 0.000000; O2 1.350625 0.111469 0.000000; H3 1.680398 -0.373741 -0.758561; H4 1.680398 -0.373741 0.758561; no_com; no_reorient; units angstrom; """"""). >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'). FullPointGroupList = ['ATOM', 'C_inf_v', 'D_inf_h', 'C1', 'Cs', 'Ci', 'Cn', 'Cnv', 'Cnh', 'Sn', 'Dn', 'Dnd', 'Dnh', 'Td', 'Oh', 'Ih']¶. Z(atom)[source]¶; Nuclear charge of atom (0-indexed); >>> print H2OH2O.Z(4); 1. activate_all_fragments()[source]¶; Sets all fragments in the molecule to be active. add_atom(Z, x, y, z, label='', mass=0.0, charge=0.0, lineno=-1)[source]¶; Add an atom to the molecule; Z atomic number; x cartesian coordinate; y cartesian coordinate; z cartesian coordinate; symb atomic symbol to use; mass mass to use if non standard; charge charge to use if non standard; lineno line number when taken from a string. atom_at_position(b, tol=0.05)[source]¶; Tests to see of an atom is at the passed position b in Bohr with a tolerance tol.; >>> print H2OH2O.atom_at_position([1.35*(1.0/psi_bohr2angstroms), 0.10*(1.0/psi_bohr2angstroms), 0.0*(1.0/psi_bohr2angstroms)]); 3. atom_entry(atom)[source]¶; Returns the CoordEntry for an atom. atom_to_unique(iatom)[source]¶; NYI Converts an atom number to the number of its generating unique atom.; The return value is in [0, nunique). atom_to_unique_offset(iatom)[source]¶; NYI Converts an atom number to the offset of this atom; in the list of generated atoms. The unique atom itself is allowed offset 0. center_of_mass()[source]¶; Computes center of mass of molecule (does not translate molecule).; >>> H2OH2O.center_of_mass(); [-0.12442647346606871, 0.00038657002584110707, 0.0]. charge(atom)[source]¶; Returns charge of atom (0",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_driver-1.html:40769,charge,charge,40769,psi4manual/4.0b3/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_driver-1.html,8,['charge'],['charge']
Energy Efficiency," the Coulomb matrix and the exchange matrix; dominate the computational effort of the SCF procedure. For; very large systems, diagonalization of the Fock matrix can also present a; significant hurdle. Minimal Input¶; Minimal input for a Hartree-Fock computation is a molecule block, basis set; option, and a call to energy('scf'):; molecule {; He; }. set basis sto-3g. energy('scf'). This will run a Restricted Hartree-Fock (RHF) on neutral singlet Helium in; spatial symmetry with a minimal STO-3G basis, 1.0E-6; energy and 1.0E-5 density convergence criteria (since single-point, see; SCF Convergence & Algorithm), a DF ERI algorithm, symmetric; orthogonalization, DIIS, and a core Hamiltonian guess. For more; information on any of these options, see the relevant section below. Spin/Symmetry Treatment¶; PSI4 implements the most popular spin specializations of Hartree-Fock; theory, including:. Restricted Hartree-Fock (RHF) [Default]; Appropriate only for closed-shell singlet systems, but twice as efficient; as the other flavors, as the alpha and beta densities are constrained to be; identical.; Unrestricted Hartree-Fock (UHF); Appropriate for most open-shell systems, and fairly easy to converge.; The spatial parts of the alpha and beta orbitals are fully independent of each; other, which allows a considerable amount of flexibility in the wavefunction.; However, this flexibility comes at the cost of spin symmetry; UHF wavefunctions; need not be eigenfunctions of the operator. The deviation of; this operator from its expectation value is printed on the output file. If the; deviation is greater than a few hundredths, it is advisable to switch to an; ROHF to avoid this “spin-contamination” problem.; Restricted Open-Shell Hartree-Fock (ROHF); Appropriate for open-shell systems where spin-contamination is problem.; Sometimes more difficult to converge, and assumes uniformly positive spin; polarization (the alpha and beta doubly-occupied orbitals are identical).; Constrained Unres",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/scf-1.html:6525,efficient,efficient,6525,psi4manual/4.0b4/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/scf-1.html,4,['efficient'],['efficient']
Energy Efficiency," the Coulomb matrix and the exchange matrix; dominate the computational effort of the SCF procedure. For; very large systems, diagonalization of the Fock matrix can also present a; significant hurdle. Minimal Input¶; Minimal input for a Hartree-Fock computation is a molecule block, basis set; option, and a call to energy('scf'):; molecule {; He; }. set basis sto-3g. energy('scf'). This will run a Restricted Hartree-Fock (RHF) on neutral singlet Helium in; spatial symmetry with a minimal STO-3G basis, 1.0E-6; energy and 1.0E-5 density convergence criteria (since single-point, see; SCF Convergence & Algorithm), a DF ERI algorithm, symmetric; orthogonalization, DIIS, and a core Hamiltonian guess. For more; information on any of these options, see the relevant section below. Spin/Symmetry Treatment¶; Psi4 implements the most popular spin specializations of Hartree-Fock; theory, including:. Restricted Hartree-Fock (RHF) [Default]; Appropriate only for closed-shell singlet systems, but twice as efficient; as the other flavors, as the alpha and beta densities are constrained to be; identical.; Unrestricted Hartree-Fock (UHF); Appropriate for most open-shell systems, and fairly easy to converge.; The spatial parts of the alpha and beta orbitals are fully independent of each; other, which allows a considerable amount of flexibility in the wavefunction.; However, this flexibility comes at the cost of spin symmetry; UHF wavefunctions; need not be eigenfunctions of the operator. The deviation of; this operator from its expectation value is printed on the output file. If the; deviation is greater than a few hundredths, it is advisable to switch to an; ROHF to avoid this “spin-contamination” problem.; Restricted Open-Shell Hartree-Fock (ROHF); Appropriate for open-shell systems where spin-contamination is problem.; Sometimes more difficult to converge, and assumes uniformly positive spin; polarization (the alpha and beta doubly-occupied orbitals are identical).; Constrained Unres",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/scf-1.html:6488,efficient,efficient,6488,psi4manual/1.0.0/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/scf-1.html,2,['efficient'],['efficient']
Energy Efficiency," the Coulomb matrix and the exchange matrix; dominate the computational effort of the SCF procedure. For; very large systems, diagonalization of the Fock matrix can also present a; significant hurdle. Minimal Input¶; Minimal input for a Hartree-Fock computation is a molecule block, basis set; option, and a call to energy('scf'):; molecule {; He; }. set basis sto-3g. energy('scf'). This will run a Restricted Hartree-Fock (RHF) on neutral singlet Helium in; spatial symmetry with a minimal STO-3G basis, 1.0E-6; energy and 1.0E-5 density convergence criteria (since single-point, see; SCF Convergence & Algorithm), a PK ERI algorithm, symmetric; orthogonalization, DIIS, and a core Hamiltonian guess. For more; information on any of these options, see the relevant section below. Spin/Symmetry Treatment¶; PSI4 implements the most popular spin specializations of Hartree-Fock; theory, including:. Restricted Hartree-Fock (RHF) [Default]; Appropriate only for closed-shell singlet systems, but twice as efficient; as the other flavors, as the alpha and beta densities are constrained to be; identical.; Unrestricted Hartree-Fock (UHF); Appropriate for most open-shell systems, and fairly easy to converge.; The spatial parts of the alpha and beta orbitals are fully independent of each; other, which allows a considerable amount of flexibility in the wavefunction.; However, this flexibility comes at the cost of spin symmetry; UHF wavefunctions; need not be eigenfunctions of the operator. The deviation of; this operator from its expectation value is printed on the output file. If the; deviation is greater than a few hundredths, it is advisable to switch to an; ROHF to avoid this “spin-contamination” problem.; Restricted Open-Shell Hartree-Fock (ROHF); Appropriate for open-shell systems where spin-contamination is problem.; Sometimes more difficult to converge, and assumes uniformly positive spin; polarization (the alpha and beta doubly-occupied orbitals are identical).; Constrained Unres",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/scf-1.html:5876,efficient,efficient,5876,psi4manual/4.0b3/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/scf-1.html,2,['efficient'],['efficient']
Energy Efficiency," the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with functions that call upon those in modules; :py:mod:`proc`, :py:mod:`driver`, and :py:mod:`wrappers`. Place in this file quickly defined procedures such as; - aliases for complex methods; - simple modifications to existing methods. """"""; from __future__ import print_function; from __future__ import absolute_import; import os; import re; import math; import warnings. from psi4.driver import driver_cbs. # Python procedures like these can be run directly from the input file or integrated; # with the energy(), etc. routines by means of lines like those at the end; # of this file. def fake_file11(wfn, filename='fake_file11.dat', **kwargs):; r""""""Function to print a file *filename* of the old file11 format; from molecule and gradient information in *wfn*. .. versionadded:: 0.6; *wfn* parameter passed explicitly. :returns: None. :type filename: string; :param filename: destination file name for file11 file. :type wfn: :py:class:`~psi4.core.Wavefunction`; :param wfn: set of molecule, gradient from which to generate file11. :examples:. >>> # [1] file11 for CISD calculation; >>> G, wfn = gradient('cisd', return_wfn=True); >>> fake_file11(wfn, 'mycalc.11'). """"""; molecule = wfn.molecule(); molecule.update_geometry(); gradient = wfn.gradient(). with open(filename, 'w') as handle:; handle.write('%d\n' % (molecule.natom())). for at in range(molecule.natom()):; handle.write('%6s %16.8f %16.8f %16.8f\n' % (molecule.symbol(; at), molecule.x(at), molecule.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/aliases.html:1588,energy,energy,1588,psi4manual/1.2.1/_modules/psi4/driver/aliases.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/aliases.html,1,['energy'],['energy']
Energy Efficiency," the H2O molecule. mp2_5-grad2; MP2.5 cc-pVDZ gradient for the NO radical. cc9a; ROHF-CCSD(T) cc-pVDZ energy for the state of the CN radical, with Z-matrix input. dfmp2-2; Density fitted MP2 energy of H2, using density fitted reference and automatic looping over cc-pVDZ and cc-pVTZ basis sets. Results are tabulated using the built in table functions by using the default options and by specifiying the format. omp2-grad1; OMP2 cc-pVDZ gradient for the H2O molecule. cc1; RHF-CCSD 6-31G** all-electron optimization of the H2O molecule. scf4; RHF cc-pVDZ energy for water, automatically scanning the symmetric stretch and bending coordinates using Python’s built-in loop mechanisms. The geometry is apecified using a Z-matrix with variables that are updated during the potential energy surface scan, and then the same procedure is performed using polar coordinates, converted to Cartesian coordinates. cisd-h2o-clpse; 6-31G** H2O Test CISD Energy Point with subspace collapse. omp2-3; OMP2 cc-pVDZ energy for the NO radical. cepa1; cc-pvdz H2O Test CEPA(1) Energy. cc24; Single point gradient of 1-2B1 state of H2O+ with EOM-CCSD. dftd3-grad; DF-BP86-D2 cc-pVDZ frozen core gradient of S22 HCN, calling Grimme’s dftd3 program for -D2 gradients. cc14; ROHF-CCSD/cc-pVDZ CH2 geometry optimization via analytic gradients. mp3-grad2; MP3 cc-pVDZ gradient for the NO radical. cc29; CCSD/cc-pVDZ optical rotation calculation (both gauges) on Cartesian H2O2. dfscf-bz2; Benzene Dimer DF-HF/cc-pVDZ. psithon1; Spectroscopic constants of H2, and the full ci cc-pVTZ level of theory. ocepa3; OCEPA cc-pVDZ energy with ROHF initial guess for the NO radical. matrix1; An example of using BLAS and LAPACK calls directly from the Psi input file, demonstrating matrix multiplication, eigendecomposition, Cholesky decomposition and LU decomposition. These operations are performed on vectors and matrices provided from the Psi library. cc36; CC2(RHF)/cc-pVDZ energy of H2O. castup2; SCF with various combinations of ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_testsuite-1.html:20235,energy,energy,20235,psi4manual/4.0b4/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_testsuite-1.html,4,['energy'],['energy']
Energy Efficiency," the HF+ using DC-06 functional. This performs both two-step and simultaneous update of the orbitals and cumulant using DIIS extrapolation. Four-virtual integrals are first handled in the MO Basis for the first two energy computations. In the next two the ao_basis=disk algorithm is used, where the transformation of integrals for four-virtual case is avoided. The computation is then repeated using the DC-12 functional with the same algorithms. dfrasscf-sp; 6-31G** H2O Test RASSCF Energy Point will default to only singles and doubles in the active space. opt6; Various constrained energy minimizations of HOOH with cc-pvdz RHF Internal-coordinate constraints in internal-coordinate optimizations. cdomp2-1; OMP2 cc-pVDZ energy for the H2O molecule. freq-isotope; Vibrational and thermo analysis of several water isotopologs. Demonstrates Hessian reuse for different temperatures and pressures but not for different isotopologs. cc36; CC2(RHF)/cc-pVDZ energy of H2O. cbs-delta-energy; Extrapolated energies with delta correction. dfccd1; DF-CCD cc-pVDZ energy for the H2O molecule. psimrcc-ccsd_t-1; Mk-MRCCSD(T) single point. CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. omp3-2; OMP3 cc-pVDZ energy with ROHF initial guess for the NO radical. dfomp3-2; DF-OMP3 cc-pVDZ energy for the H2O+ cation. ghosts; Density fitted MP2 cc-PVDZ/cc-pVDZ-RI computation of formic acid dimer binding energy using explicit specification of ghost atoms. This is equivalent to the dfmp2_1 sample but uses both (equivalent) specifications of ghost atoms in a manual counterpoise correction. cc26; Single-point gradient, analytic and via finite-differences of 2-1A1 state of H2O with EOM-CCSD. cbs-xtpl-freq; Various gradients for a strained helium dimer and water molecule. dft1-alt; DFT Functional Test. cc14; ROHF-CCSD/cc-pVDZ CH2 geometry optimization via analytic gradients. tu6-cp-ne2; Example potential energy surface scan and CP-correction for Ne2. mints2; A test o",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html:12275,energy,energy,12275,psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency," the He dimer. This performs a two-step update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the MO Basis. dft-custom-hybrid; DFT (hybrids) test of implementations in: hybrid_superfuncs.py. scf-hess4; DF SCF 6-31G UHFl vs RHF test Tests DF UHF hessian code for Ca = Cb. scf-auto-cholesky; Cholesky filter a complete basis. mom; Maximum Overlap Method (MOM) Test. MOM is designed to stabilize SCF convergence and to target excited Slater determinants directly. psithon1; Spectroscopic constants of H2, and the full ci cc-pVTZ level of theory. cisd-h2o+-2; 6-31G** H2O+ Test CISD Energy Point. cc10; ROHF-CCSD cc-pVDZ energy for the \(^2\Sigma^+\) state of the CN radical. tdscf-2; td-uhf test on triplet states of methylene (tda), wfn passing. dft-pruning; Tests all grid pruning options available and screening of small weights. Check against grid size. dfccd1; DF-CCD cc-pVDZ energy for the H2O molecule. cc15; RHF-B-CCD(T)/6-31G** H2O single-point energy (fzc, MO-basis \(\langle ab|cd \rangle\)). omp2p5-grad2; OMP2.5 cc-pVDZ gradient for the NO radical. sapt5; SAPT0 aug-cc-pVTZ computation of the charge transfer energy of the water dimer. dfccsdt1; DF-CCSD(T) cc-pVDZ energy for the H2O molecule. pywrap-checkrun-uhf; This checks that all energy methods can run with a minimal input and set symmetry. scf2; RI-SCF cc-pVTZ energy of water, with Z-matrix input and cc-pVTZ-RI auxilliary basis. mcscf3; RHF 6-31G** energy of water, using the MCSCF module and Z-matrix input. pywrap-checkrun-rohf; This checks that all energy methods can run with a minimal input and set symmetry. cc41; RHF-CC2-LR/cc-pVDZ optical rotation of H2O2. gauge = both, omega = (589 355 nm). pywrap-db1; Database calculation, so no molecule section in input file. Portions of the full databases, restricted by subset keyword, are computed by sapt0 and dfmp2 methods. cisd-sp-2; 6-31G** H2O Test CISD Energy Point. olccd3; OLCCD cc-pVDZ energy with ROHF initial guess for the",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html:4955,energy,energy,4955,psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency," the MP3 level of theory. MPn TOTAL ENERGY¶. MPn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Möller–Plesset perturbation theory level.; n is MP perturbation order. NUCLEAR REPULSION ENERGY¶; The nuclear repulsion energy contribution [H] to the total SCF energy.; Quantity in Eq. (3). (2). ONE-ELECTRON ENERGY¶; The one-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (3). SAPT DISP ENERGY¶. SAPT ELST ENERGY¶. SAPT EXCH ENERGY¶. SAPT IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [H] for the the; requested SAPT level of theory. The sum of these four components yields; SAPT ENERGY. SAPT ENERGY¶; The total electronic interaction energy [H] for the requested SAPT; level of theory. SAPT SAPT0 ENERGY¶. SAPT SAPT2 ENERGY¶. SAPT SAPT2+ ENERGY¶. SAPT SAPT2+(3) ENERGY¶. SAPT SAPT2+3 ENERGY¶; The total electronic interaction energy [H] for the labeled SAPT level; of theory. SCF DIPOLE X¶. SCF DIPOLE Y¶. SCF DIPOLE Z¶; The three components of the SCF dipole [Debye]. SCF QUADRUPOLE XX¶. SCF QUADRUPOLE XY¶. SCF QUADRUPOLE XZ¶. SCF QUADRUPOLE YY¶. SCF QUADRUPOLE YZ¶. SCF QUADRUPOLE ZZ¶; The six components of the SCF quadrupole [Debye Ang]. SCF TOTAL ENERGY¶; The total electronic energy [H] of the SCF stage of the calculation.; The CORRELATION ENERGY variables from subsequent stages of a; calculation are often the corresponding TOTAL ENERGY; variables less this quantity. Constructed from Eq. (3),; where this quantity is . (3); Unless the method includes a dispersion correction, this quantity is; equal to HF TOTAL ENERGY (for HF) or; DFT FUNCTIONAL TOTAL ENERGY (for; DFT). Unless the method is a DFT double-hybrid, this quantity is equal; to DFT TOTAL ENERGY. TWO-ELECTRON ENERGY¶; The two-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (3). UNCP-CORRECTED 2-BODY INTERACTION ENERGY¶; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:13209,energy,energy,13209,psi4manual/4.0b3/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html,2,['energy'],['energy']
Energy Efficiency," the NO radical. dfmp2-4; conventional and density-fitting mp2 test of mp2 itself and setting scs-mp2. dfccsd1; DF-CCSD cc-pVDZ energy for the H2O molecule. omp2-5; SOS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. rasci-h2o; RASCI/6-31G** H2O Energy Point. basis-ecp; check mixing ECP and non-ECP orbital/fitting basis sets in a session. cbs-xtpl-opt; Various extrapolated optimization methods for the H2 molecule. dct-grad4; Unrestricted DF-DCT ODC-12 gradient for O2 with cc-pVTZ/cc-pVTZ-RI standard/auxiliary basis set. dfomp2-grad1; DF-OMP2 cc-pVDZ gradients for the H2O molecule. dfomp2-4; OMP2 cc-pVDZ energy for the NO molecule. mbis-3; MBIS calculation on OH radical. dfccd1; DF-CCD cc-pVDZ energy for the H2O molecule. props4; Electrostatic potential and electric field evaluated on a grid around water. fnocc4; Test FNO-DF-CCSD(T) energy. omp2-grad2; OMP2 cc-pVDZ gradient for the NO radical. omp2-1; OMP2 cc-pVDZ energy for the H2O molecule. opt7; Various constrained energy minimizations of HOOH with cc-pvdz RHF. For “fixed” coordinates, the final value is provided by the user. dft-omega; Test omega is setable updated wb97x_20,wb97x_03 to account for new BraggSlater radii. mp2-grad2; MP2 cc-pVDZ gradient for the NO radical. fsapt-ext-abc2; FSAPT with external charge on dimer. sapt-dft2; SAPT(DFT) aug-cc-pVDZ computation for the water dimer interaction energy. dfmp2-grad2; DF-MP2 cc-pVDZ gradient for the NO molecule. dft-freq-analytic2; Analytic UKS SVWN frequencies, compared to finite difference values. sapt-exch-ind30-inf; SAPT2+3 with S^inf exch-ind30 Geometries taken from the S66x10 database, the shortest-range point (R = 0.7 R_e). cc7; Tests CCENERGY’s CCSD gradient in the presence of a dipole field. sapt-exch-disp-inf; SAPT0 with S^inf exch-disp20. omp2p5-grad2; OMP2.5 cc-pVDZ gradient for the NO radical. nbody-hessian; Computation of VMFC-corrected HF dimer Hessian. isapt-siao1; This test case shows an example of running the I-SAPT0/jun-cc-pVDZ computa",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html:45406,energy,energy,45406,psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency," the One-electron Overlap Matrix. X(). alpha_orbital_space(self, id, basis, subset); Creates OrbitalSpace with information about the requested alpha orbital space. aotoso(self); Returns the Atomic Orbital to Symmetry Orbital transformer. array_variable(self, arg0); Returns copy of the requested (case-insensitive) Matrix QC variable. array_variables(self); Returns the dictionary of all Matrix QC variables. arrays(). Deprecated since version 1.4. atomic_point_charges(self); Returns the set atomic point charges. basis_projection(self, arg0, arg1, arg2, arg3); Projects a orbital matrix from one basis to another. basisset(self); Returns the current orbital basis. beta_orbital_space(self, arg0, arg1, arg2); docstring. build(mol[, basis, quiet]). c1_deep_copy(self, basis); Returns a new wavefunction with internal data converted to \(C_1\) symmetry, using pre-c1-constructed basis. compute(self, arg0); Computes the density-fitted EP2 energy for the input orbitals. compute_energy(self); Computes the energy of the Wavefunction. compute_gradient(self); Computes the gradient of the Wavefunction. compute_hessian(self); Computes the Hessian of the Wavefunction. deep_copy(self, arg0); Deep copies the internal data. del_array_variable(self, arg0); Removes the requested (case-insensitive) Matrix QC variable. del_potential_variable(self, arg0); Removes the requested (case-insensitive) ExternalPotential QC variable. del_scalar_variable(self, arg0); Removes the requested (case-insensitive) double QC variable. del_variable(key); Removes scalar or array QCVariable key from cls if present. density_fitted(self); Returns whether this wavefunction was obtained using density fitting or not. doccpi(self); Returns the number of doubly occupied orbitals per irrep. efzc(self); Returns the frozen-core energy. energy(self); Returns the Wavefunction's energy. epsilon_a(self); Returns the Alpha Eigenvalues. epsilon_a_subset(self, basis, subset); Returns the requested Alpha orbital energies subset. epsi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.DFEP2Wavefunction.html:2145,energy,energy,2145,psi4manual/1.6.x/api/psi4.core.DFEP2Wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.DFEP2Wavefunction.html,1,['energy'],['energy']
Energy Efficiency," the QCISD(T) method. Both the; QCISD(T) and CCSD(T) methods are implemented for closed-shell references; in the FNOCC module. Many-body perturbation theory¶; QCI and CC methods are closely related to perturbation theory, and the; MP2, MP3, and MP4(SDQ) correlation energies can be obtained as a free; by-product of a CCSD or QCISD computation. The following is an; example of the results for a computation run with the call; energy('fno-qcisd') to energy():; QCISD iterations converged!. OS MP2 FNO correction: -0.000819116338; SS MP2 FNO correction: -0.000092278158; MP2 FNO correction: -0.000911394496. OS MP2 correlation energy: -0.166478414245; SS MP2 correlation energy: -0.056669079827; MP2 correlation energy: -0.223147494072; * MP2 total energy: -76.258836941658. OS MP2.5 correlation energy: -0.171225850256; SS MP2.5 correlation energy: -0.054028401038; MP2.5 correlation energy: -0.225254251294; * MP2.5 total energy: -76.260943698880. OS MP3 correlation energy: -0.175973286267; SS MP3 correlation energy: -0.051387722248; MP3 correlation energy: -0.227361008515; * MP3 total energy: -76.263050456101. OS MP4(SDQ) correlation energy: -0.180324322304; SS MP4(SDQ) correlation energy: -0.048798468084; MP4(SDQ) correlation energy: -0.230995119324; * MP4(SDQ) total energy: -76.266684566910. OS QCISD correlation energy: -0.181578117924; SS QCISD correlation energy: -0.049853548145; QCISD correlation energy: -0.231431666069; * QCISD total energy: -76.267121113654. The first set of energies printed corresponds to the second-order FNO; correction mentioned previously. Results for many-body perturbation; theory through partial fourth order are then provided.; The notation MP4(SDQ) indicates that we have included all contributions to; the correlation energy through fourth order, with the exception of that; from connected triple excitations.; One need not run a full QCISD or CCSD computation to obtain these; perturbation theory results. The keywords for invoking perturbation; theory",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/fnocc-1.html:5832,energy,energy,5832,psi4manual/1.4.0/fnocc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/fnocc-1.html,15,['energy'],['energy']
Energy Efficiency," the SCF finally reaches; the iterations:; Total Energy Delta E Density RMS. @UHF iter 0: -149.76856421865352 -4.69109e+01 0.00000e+00; @UHF iter 1: -149.59793338958522 1.70631e-01 5.72371e-02; @UHF iter 2: -149.62408782458331 -2.61544e-02 8.04195e-03 DIIS; @UHF iter 3: -149.62679515182390 -2.70733e-03 2.51542e-03 DIIS; @UHF iter 4: -149.62726459105770 -4.69439e-04 1.06897e-03 DIIS; @UHF iter 5: -149.62730549814114 -4.09071e-05 2.70311e-04 DIIS; @UHF iter 6: -149.62730736371790 -1.86558e-06 5.94924e-05 DIIS; @UHF iter 7: -149.62730740227752 -3.85596e-08 9.93250e-06 DIIS; @UHF iter 8: -149.62730740325136 -9.73841e-10 1.88088e-06 DIIS; @UHF iter 9: -149.62730740326214 -1.07718e-11 1.80706e-07 DIIS; @UHF iter 10: -149.62730740326231 -1.70530e-13 2.19128e-08 DIIS. The algorithm takes 10 true iterations to converge the energy and density to the; default of 1.0E-8, plus the trivial iteration due to the SAD guess.; The energy on the zero-th iteration is not variational due to the improper; idempotence properties of the SAD guess, but the first true iteration is within; 2.0E-4 relative error of the final answer, highlighting the; efficiency of the SAD guess. The energy and density then converge smoothly,; assisted by Pulay’s Direct Inversion of the Iterative Subspace (DIIS), which is; activated by default. DIIS from a high-quality guess is usually sufficient to; converge the nonlinear SCF equations, however enhanced control of DIIS; parameters and additional convergence algorithms are available and detailed; below.; After the iterations are completed, a number of one-electron properties are; printed, and some bookkeeping is performed to set up possible correlated; computations. Additional one-electron properties are available by increasing the; PRINT option. Also printed are the occupied and virtual orbital energies,; which are useful in elucidating the stability and reactivity of the system. Theory¶; The objective of Hartree-Fock (HF) Theory is to produce the optimized Mole",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/scf-1.html:2287,energy,energy,2287,psi4manual/4.0b2/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf-1.html,2,['energy'],['energy']
Energy Efficiency," the above parameters; are available, with only the ```wfn``` and ```basis``` keywords required. Other supported parameters; are:. * ```wfn_lo```: the lower method from which the delta correction is to be calculated. By default, it; is set to ```wfn``` from the previous field in the ```cbs_metadata``` array.; * ```basis_lo```: basis set to be used for the delta correction. By default, it is the same as the; ```basis``` specified above. * Others. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> energy(cbs, corl_wfn='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> energy(cbs, corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> energy(cbs, corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> energy(cbs, corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> energy(cbs, corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z',",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html:44105,energy,energy,44105,psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,2,['energy'],['energy']
Energy Efficiency," the algorithm for a MP3 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'); all_electron = (core.get_global_option('FREEZE_CORE') == ""FALSE""). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if all_electron:; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient; elif reference == 'UHF':; if mtd_type == 'CONV':; if all_electron:; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module, all_electron]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp3(name, **kwargs):; """"""Function selecting the algorithm for an OMP3 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp3_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OMP3 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODU",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:13575,energy,energy,13575,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,4,['energy'],['energy']
Energy Efficiency," the averaged quadratic coupled-cluster level of theory. BRUECKNER CONVERGED¶; Value 1 (0) when the Brueckner orbitals have (have not) converged. CBS TOTAL ENERGY¶. CBS CORRELATION ENERGY¶. CBS REFERENCE ENERGY¶; The total electronic energy [H] and its breakdown into reference total; energy [H] and correlation correction components [H] for the compound; method requested through cbs(). CC ROOT n DIPOLE X¶. CC ROOT n DIPOLE Y¶. CC ROOT n DIPOLE Z¶; The three components of the dipole [Debye] for the requested; coupled cluster level of theory and root n (number starts at GS = 0). CC ROOT n QUADRUPOLE XX¶. CC ROOT n QUADRUPOLE XY¶. CC ROOT n QUADRUPOLE XZ¶. CC ROOT n QUADRUPOLE YY¶. CC ROOT n QUADRUPOLE YZ¶. CC ROOT n QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; coupled cluster level of theory and root n (numbering starts at GS = 0). CC ROOT n TOTAL ENERGY¶. CC ROOT n CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested coupled cluster level of theory and root; n (numbering starts at GS = 0). CC TOTAL ENERGY¶. CC CORRELATION ENERGY¶. CC T1 DIAGNOSTIC¶. CC D1 DIAGNOSTIC¶. CC NEW D1 DIAGNOSTIC¶. CC D2 DIAGNOSTIC¶; Diagnostic of multireference character. CC2 TOTAL ENERGY¶. CC2 CORRELATION ENERGY¶. CC3 TOTAL ENERGY¶. CC3 CORRELATION ENERGY¶. CC4 TOTAL ENERGY¶. CC4 CORRELATION ENERGY¶. CCnn TOTAL ENERGY¶. CCnn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested approximate coupled-cluster (CC2, CC3, up to CCnn); level of theory. CC DIPOLE X¶. CC DIPOLE Y¶. CC DIPOLE Z¶; The three components of the dipole [Debye] for the requested; coupled cluster level of theory and root. CC2 DIPOLE POLARIZABILITY @ xNM¶; The dipole polarizability [au] calculated at the CC2 level; for a given (x) wavelength, (x) rounded to nearest integer. CC2 SPECIFIC ROTATION (LEN) @ xNM¶; The specific rotation [deg/(dm (g/cm^3))] calculated at the CC2 level ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/glossary_psivariables-1.html:2806,energy,energy,2806,psi4manual/1.2.1/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/glossary_psivariables-1.html,8,['energy'],['energy']
Energy Efficiency," the averaged quadratic coupled-cluster level of theory. BRUECKNER CONVERGED¶; Value 1 (0) when the Brueckner orbitals have (have not) converged. CBS TOTAL ENERGY¶. CBS CORRELATION ENERGY¶. CBS REFERENCE ENERGY¶; The total electronic energy [H] and its breakdown into reference total; energy [H] and correlation correction components [H] for the compound; method requested through cbs(). CC ROOT n DIPOLE X¶. CC ROOT n DIPOLE Y¶. CC ROOT n DIPOLE Z¶; The three components of the dipole [Debye] for the requested; coupled cluster level of theory and root n (number starts at GS = 0). CC ROOT n QUADRUPOLE XX¶. CC ROOT n QUADRUPOLE XY¶. CC ROOT n QUADRUPOLE XZ¶. CC ROOT n QUADRUPOLE YY¶. CC ROOT n QUADRUPOLE YZ¶. CC ROOT n QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; coupled cluster level of theory and root n (numbering starts at GS = 0). CC ROOT n TOTAL ENERGY¶. CC ROOT n CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested coupled cluster level of theory and root; n (numbering starts at GS = 0). CC TOTAL ENERGY¶. CC CORRELATION ENERGY¶. CC2 TOTAL ENERGY¶. CC2 CORRELATION ENERGY¶. CC3 TOTAL ENERGY¶. CC3 CORRELATION ENERGY¶. CC4 TOTAL ENERGY¶. CC4 CORRELATION ENERGY¶. CCnn TOTAL ENERGY¶. CCnn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested approximate coupled-cluster (CC2, CC3, up to CCnn); level of theory. CC DIPOLE X¶. CC DIPOLE Y¶. CC DIPOLE Z¶; The three components of the dipole [Debye] for the requested; coupled cluster level of theory and root. CC QUADRUPOLE XX¶. CC QUADRUPOLE XY¶. CC QUADRUPOLE XZ¶. CC QUADRUPOLE YY¶. CC QUADRUPOLE YZ¶. CC QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; coupled cluster level of theory and root. CCSD TOTAL ENERGY¶. CCSD CORRELATION ENERGY¶. CCSDT TOTAL ENERGY¶. CCSDT CORRELATION ENERGY¶. CCSDTQ TOTAL ENERGY¶. CCSDTQ CORRELATION ENERGY¶. CCn TOTAL EN",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/glossary_psivariables-1.html:2804,energy,energy,2804,psi4manual/1.1.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/glossary_psivariables-1.html,4,['energy'],['energy']
Energy Efficiency," the best estimate of the CI vector for the previous n iterations. Defaults to 1. Type: integer; Default: 1. COLLAPSE_WITH_LAST (CCEOM); CCEOM — Do collapse with last vector?. Type: boolean; Default: true. COMPLEX_TOLERANCE (CCEOM); CCEOM — Complex tolerance applied in CCEOM computations. Type: conv double; Default: 1e-12. COMPUTE_MP4_TRIPLES (FNOCC); FNOCC (Expert) — Do compute MP4 triples contribution?. Type: boolean; Default: false. COMPUTE_TRIPLES (FNOCC); FNOCC (Expert) — Do compute triples contribution?. Type: boolean; Default: true. CONSECUTIVE_BACKSTEPS (OPTKING); OPTKING — Set number of consecutive backward steps allowed in optimization. Type: integer; Default: 0. CORR_ANSATZ (PSIMRCC); PSIMRCC — The ansatz to use for MRCC computations. Type: string; Possible Values: SR, MK, BW, APBW; Default: MK. CORR_CCSD_T (PSIMRCC); PSIMRCC — The type of CCSD(T) computation to perform. Type: string; Possible Values: STANDARD, PITTNER; Default: STANDARD. CORR_CHARGE (PSIMRCC); PSIMRCC — The molecular charge of the target state. Type: integer; Default: 0. CORR_MULTP (PSIMRCC); PSIMRCC — The multiplicity, , of the target state. Must be specified if different from the reference . Type: integer; Default: 1. CORR_WFN (PSIMRCC); PSIMRCC — The type of correlated wavefunction. Type: string; Possible Values: PT2, CCSD, MP2-CCSD, CCSD_T; Default: CCSD. COUPLING (PSIMRCC); PSIMRCC — The order of coupling terms to include in MRCCSDT computations. Type: string; Possible Values: NONE, LINEAR, QUADRATIC, CUBIC; Default: CUBIC. COUPLING_TERMS (PSIMRCC); PSIMRCC — Do include the terms that couple the reference determinants?. Type: boolean; Default: true. COVALENT_CONNECT (OPTKING); OPTKING — When determining connectivity, a bond is assigned if interatomic distance is less than (this number) * sum of covalent radii. Type: double; Default: 1.3. CPHF_MEM_SAFETY_FACTOR (CPHF); CPHF — Memory safety factor for allocating JK. Type: double; Default: 0.75. CPHF_TASKS (CPHF); CPHF — Which tasks to ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_glossary_options_c-1.html:19479,charge,charge,19479,psi4manual/4.0b4/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_glossary_options_c-1.html,4,['charge'],['charge']
Energy Efficiency," the cfour {...}; block are for the sandwich mode, where the entire ZMAT is enclosed,; or for extra directives like %excite*, which presently have no other; specification route. Specifying the basis is perhaps the regulated piece of input. Since; basis set names differ between PSI4 and Cfour and it’s not; practical to compare exponent-to-exponent, any input file with both; BASIS and CFOUR_BASIS keywords present will halt. Once; a basis set has been requested through BASIS, overriding the; default spherical/Cartesian setting must be done through; PUREAM (as opposed to CFOUR_SPHERICAL). Specifying keywords that control geometry optimization is; straightforward. Unless the optimization is invoked in sandwich mode,; all Cfour optimization keywords (e.g., CFOUR_GEO_MAXCYC) are; ineffective, as the Cfour optimizer is never invoked. PSI4; optimization keywords (e.g., GEOM_MAXITER) instead fill; these roles. Specifying the computational method (through, for instance,; energy('c4-ccsd') instead of energy('cfour')) often; sets additional keywords consistent with best practices (e.g.,; CFOUR_CC_PROGRAM). Since those settings are implicit, any; explicit setting of those those keywords, whether contradicting or; concurring, takes priority (halts never generated). The following are; some concrete examples. For the moment, click the source button at; qcdb.cfour.muster_modelchem() for details of what keywords; get set. runs in vcc since that’s Cfour’s default for cc_program; 1; 2set cfour_calc_level ccsd; energy('cfour'). runs in ecc since Cfour’s default overwritten by keyword; 1; 2; 3set cfour_calc_level ccsd; set cfour_cc_program ecc; energy('cfour'). runs in ecc since that’s best practice for the requested ccsd; 1energy('c4-ccsd'). runs in vcc since hidden default overwritten by keyword; 1; 2set cfour_cc_program vcc; energy('c4-ccsd'). Specifying certain keywords that are nominally applicable for pure-PSI4 modules directs them to fulfil analogous roles; in the Cfour program (e.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/cfour-1.html:30635,energy,energy,30635,psi4manual/1.2.1/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/cfour-1.html,12,['energy'],['energy']
Energy Efficiency," the cfour {...}; block are for the sandwich mode, where the entire ZMAT is enclosed,; or for extra directives like %excite*, which presently have no other; specification route. Specifying the basis is perhaps the regulated piece of input. Since; basis set names differ between Psi4 and Cfour and it’s not; practical to compare exponent-to-exponent, any input file with both; BASIS and CFOUR_BASIS keywords present will halt. Once; a basis set has been requested through BASIS, overriding the; default spherical/Cartesian setting must be done through; PUREAM (as opposed to CFOUR_SPHERICAL). Specifying keywords that control geometry optimization is; straightforward. Unless the optimization is invoked in sandwich mode,; all Cfour optimization keywords (e.g., CFOUR_GEO_MAXCYC) are; ineffective, as the Cfour optimizer is never invoked. Psi4; optimization keywords (e.g., GEOM_MAXITER) instead fill; these roles. Specifying the computational method (through, for instance,; energy('c4-ccsd') instead of energy('cfour')) often; sets additional keywords consistent with best practices (e.g.,; CFOUR_CC_PROGRAM). Since those settings are implicit, any; explicit setting of those those keywords, whether contradicting or; concurring, takes priority (halts never generated). The following are; some concrete examples. For the moment, click the source button at; qcdb.cfour.muster_modelchem() for details of what keywords; get set. runs in vcc since that’s Cfour’s default for cc_program; set cfour_calc_level ccsd; energy('cfour'). runs in ecc since Cfour’s default overwritten by keyword; set cfour_calc_level ccsd; set cfour_cc_program ecc; energy('cfour'). runs in ecc since that’s best practice for the requested ccsd; energy('c4-ccsd'). runs in vcc since hidden default overwritten by keyword; set cfour_cc_program vcc; energy('c4-ccsd'). Specifying certain keywords that are nominally applicable for pure-Psi4 modules directs them to fulfil analogous roles; in the Cfour program (e.g., MAXITER is u",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/cfour-1.html:31657,energy,energy,31657,psi4manual/1.0.0/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/cfour-1.html,4,['energy'],['energy']
Energy Efficiency," the code does include an interface to; Kallay’s MRCC code.; The DETCI module is also capable of computing arbitrary-order; coupled-cluster energies, using an approach similar to that of Hirata; and Bartlett [Hirata:2000:216], or of Olsen [Olsen:2000:7140].; Notably, the approach in DETCI also allows arbitrary-order; active space coupled-cluster procedures. The general algorithm; for doing this in DETCI is inefficient compared to optimized; lower-order coupled-cluster codes and should not be used for CCSD,; where the CCENERGY module is much more efficient. For higher-order; CC (like CCSDT and beyond), the code is also not as efficient as the; MRCC code by Kállay, to which PSI4 can interface (see Section; Interface to MRCC by M. Kállay); however, it may allow certain truncations of the model; space that might not be available presently in MRCC. For very small; systems, the code can be useful for testing of, for example, CCSDTQ or; its active-space CCSDtq analog [Piecuch:1999:6103].; To perform arbitrary-order coupled-cluster, set the DETCI; option CC to TRUE, and set; CC_EX_LEVEL (note: not EX_LEVEL); to the desired coupled-cluster excitation level, and invoke; energy('detci'). Various other DETCI options have a similar; option for coupled-cluster, usually named beginning with CC. The full; list of options is given in Appendix DETCI. table of contents. CI: Configuration Interaction; Basic DETCI Keywords; REFERENCE; R_CONVERGENCE; EX_LEVEL; FCI; FROZEN_DOCC; RESTRICTED_DOCC; RESTRICTED_UOCC; FROZEN_UOCC; CI_MAXITER; NUM_ROOTS; ICORE; DIAG_METHOD; OPDM; TDM; DIPMOM; MPN. Spin Multiplicities of Higher Roots; Arbitrary Order Perturbation Theory; Arbitrary Order Coupled-Cluster Theory. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Theoretical Methods: SCF to FCI; CI: Configuration Interaction. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/detci.html:15353,energy,energy,15353,psi4manual/1.7.x/detci.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/detci.html,1,['energy'],['energy']
Energy Efficiency," the code now by default uses natural; orbital truncation to speed up the evaluation of energy terms; wherever possible, according to literature recommendations.; In early July 2016, some total sapt energy psivars were renamed. Symmetry-adapted perturbation theory (SAPT) provides a means of directly; computing the noncovalent interaction between two molecules, that is, the; interaction energy is determined without computing the total energy of the; monomers or dimer. In addition, SAPT provides a decomposition of the; interaction energy into physically meaningful components: i.e.,; electrostatic, exchange, induction, and dispersion terms. In SAPT, the; Hamiltonian of the dimer is partitioned into contributions from each; monomer and the interaction. Here, the Hamiltonian is written as a sum of the usual monomer Fock; operators, , the fluctuation potential of each monomer, , and the; interaction potential, . The monomer Fock operators, , are; treated as the zeroth-order Hamiltonian and the interaction energy is; evaluated through a perturbative expansion of , , and .; Through first-order in , electrostatic and exchange interactions are; included; induction and dispersion first appear at second-order in . For; a complete description of SAPT, the reader is referred to the excellent; review by Jeziorski, Moszynski, and Szalewicz [Jeziorski:1994:1887].; Several truncations of the SAPT expansion are available in the SAPT; module of Psi4. The simplest truncation of SAPT is denoted SAPT0; and defined in Eq. (1). (1); In this notation, defines the order in and in ; the; subscript, , indicates that orbital relaxation effects are included. (2). (3). (4). (5); The and terms take into; account higher-order induction effects and are included in the definition; of SAPT terms. They are computed from the Hartree-Fock supermolecular interaction energy; and are only available in dimer-centered basis SAPT; computations, which is the default (see below for monomer-centered basis; computa",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/sapt-1.html:2021,energy,energy,2021,psi4manual/1.0.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/sapt-1.html,2,['energy'],['energy']
Energy Efficiency," the correct symmetry, writes orbitals to disk. SCF will fail (ValidationError) otherwise. mcscf3; RHF 6-31G** energy of water, using the MCSCF module and Z-matrix input. cc53; Matches Table II a-CCSD(T)/cc-pVDZ H2O @ 2.5 * Re value from Crawford and Stanton, IJQC 98, 601-611 (1998). casscf-fzc-sp; CASSCF/6-31G** energy point. scf-coverage; Lithium test for coverage. olccd3; OLCCD cc-pVDZ energy with ROHF initial guess for the NO radical. mp2-grad1; MP2 cc-pVDZ gradient for the H2O molecule. dfmp2-2; Density fitted MP2 energy of H2, using density fitted reference and automatic looping over cc-pVDZ and cc-pVTZ basis sets. Results are tabulated using the built in table functions by using the default options and by specifiying the format. opt12; SCF cc-pVDZ geometry optimzation of ketene, starting from bent structure. dfmp2-4; conventional and density-fitting mp2 test of mp2 itself and setting scs-mp2. cisd-sp; 6-31G** H2O Test CISD Energy Point. sapt5; SAPT0 aug-cc-pVTZ computation of the charge transfer energy of the water dimer. dct4; DCT calculation for the HF+ using DC-06 functional. This performs both two-step and simultaneous update of the orbitals and cumulant using DIIS extrapolation. Four-virtual integrals are first handled in the MO Basis for the first two energy computations. In the next two the ao_basis=disk algorithm is used, where the transformation of integrals for four-virtual case is avoided. The computation is then repeated using the DC-12 functional with the same algorithms. props4; Electrostatic potential and electric field evaluated on a grid around water. sapt3; SAPT2+3(CCD) aug-cc-pVDZ+midbond computation of the water dimer interaction energy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. mp2-1; All-electron MP2 6-31G** geometry optimization of water. sapt1; SAPT0 cc-pVDZ computation of the ethene-ethyne interaction energy, using the cc-pVDZ-JKFIT RI basis for SCF and cc-pVDZ-RI for SAPT. Monomer geometries are specifi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html:24983,charge,charge,24983,psi4manual/master/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html,4,"['charge', 'energy']","['charge', 'energy']"
Energy Efficiency," the coupled cluster singles doubles (CCSD); method [Purvis:1982]. Consider the set of equations defining CCSD:. (1); where we have chosen the intermediate normalization,; , and the symbols ; and represent single and double excitation operators. The; QCISD equations can be obtained by omitting all but two terms that; are nonlinear in and :. (2); QCISD is slightly cheaper that CCSD computationally, but it retains the; complexity of the original equations. Just as in; the familiar CCSD(T) method, the effects of connected triple excitations; may be included noniteratively to yield the QCISD(T) method. Both the; QCISD(T) and CCSD(T) methods are implemented for closed-shell references; in the FNOCC module. Many-body perturbation theory¶; QCI and CC methods are closely related to perturbation theory, and the; MP2, MP3, and MP4(SDQ) correlation energies can be obtained as a free; by-product of a CCSD or QCISD computation. The following is an; example of the results for a computation run with the call; energy('fno-qcisd') to energy():; QCISD iterations converged!. OS MP2 FNO correction: -0.000819116338; SS MP2 FNO correction: -0.000092278158; MP2 FNO correction: -0.000911394496. OS MP2 correlation energy: -0.166478414245; SS MP2 correlation energy: -0.056669079827; MP2 correlation energy: -0.223147494072; * MP2 total energy: -76.258836941658. OS MP2.5 correlation energy: -0.171225850256; SS MP2.5 correlation energy: -0.054028401038; MP2.5 correlation energy: -0.225254251294; * MP2.5 total energy: -76.260943698880. OS MP3 correlation energy: -0.175973286267; SS MP3 correlation energy: -0.051387722248; MP3 correlation energy: -0.227361008515; * MP3 total energy: -76.263050456101. OS MP4(SDQ) correlation energy: -0.180324322304; SS MP4(SDQ) correlation energy: -0.048798468084; MP4(SDQ) correlation energy: -0.230995119324; * MP4(SDQ) total energy: -76.266684566910. OS QCISD correlation energy: -0.181578117924; SS QCISD correlation energy: -0.049853548145; QCISD correlation ener",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/fnocc-1.html:4412,energy,energy,4412,psi4manual/1.0.0/fnocc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/fnocc-1.html,12,['energy'],['energy']
Energy Efficiency," the coupled electron pair approximation variant 0 level of theory, (3,). CEPA(0) DIPOLE X¶. CEPA(0) DIPOLE Y¶. CEPA(0) DIPOLE Z¶; The three components of the dipole [Debye] for the; coupled electron pair approximation variant 0 level of theory.; Deprecated in favor of CEPA(0) DIPOLE. CEPA(0) QUADRUPOLE¶; Redundant quadrupole array [e a0^2] for the coupled electron pair approximation variant 0 level of theory, (3, 3). CEPA(0) QUADRUPOLE XX¶. CEPA(0) QUADRUPOLE XY¶. CEPA(0) QUADRUPOLE XZ¶. CEPA(0) QUADRUPOLE YY¶. CEPA(0) QUADRUPOLE YZ¶. CEPA(0) QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; coupled electron pair approximation variant 0 level of theory.; Deprecated in favor of CEPA(0) QUADRUPOLE. CEPA(0) TOTAL ENERGY¶. CEPA(0) CORRELATION ENERGY¶. CEPA(1) TOTAL ENERGY¶. CEPA(1) CORRELATION ENERGY¶. CEPA(2) TOTAL ENERGY¶. CEPA(2) CORRELATION ENERGY¶. CEPA(3) TOTAL ENERGY¶. CEPA(3) CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the requested variant of coupled electron pair approximation level of theory. CFOUR ERROR CODE¶; The non-zero return value from a Cfour execution. CI DIPOLE¶; Dipole array [e a0] for the requested configuration interaction level of theory, (3,). CI DIPOLE X¶. CI DIPOLE Y¶. CI DIPOLE Z¶; The three components of the dipole [Debye] for the requested; configuration interaction level of theory and root.; Deprecated in favor of CI DIPOLE. CI QUADRUPOLE¶; Redundant quadrupole array [e a0^2] for the requested configuration interaction level of theory, (3, 3). CI QUADRUPOLE XX¶. CI QUADRUPOLE XY¶. CI QUADRUPOLE XZ¶. CI QUADRUPOLE YY¶. CI QUADRUPOLE YZ¶. CI QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; configuration interaction level of theory and root.; Deprecated in favor of CI QUADRUPOLE. CI ROOT n -> ROOT m DIPOLE¶; Transition dipole array [e a0] between roots n and m for the requested configuration interaction level of theory, (3,). CI ROO",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html:10057,energy,energy,10057,psi4manual/1.4.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html,8,['energy'],['energy']
Energy Efficiency," the current calculation, energy(""hf3c/"").; A few practical examples:. HF-3c single point with default minix basis; 1energy('hf3c'). PBEh-3c optimization with default def2-mSVP basis; 1optimize('pbeh3c'). HF-3c with non-standard basis; 1; 2set basis cc-pvdz; energy('hf3c'). PBEh-3c with default basis after basis set; 1; 2set basis cc-pvdz; energy('pbeh3c/'). If only BSSE/basis set corrections (rather than total energies) are of; interest, the gcp program can be run independently of the scf; through the python function run_gcp(). (This function; is the same PSI4/gcp interface that is called during an scf job.); This route is much faster than running a HF or DFT energy.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10molecule nene {; Ne; Ne 1 2.0; }. nene.update_geometry(). >>> E, G = nene.run_gcp('hf3c'). >>> E, G = nene.run_gcp(func='HF3c', verbose=True). qcdb.interface_gcp.run_gcp(self, func=None, dertype=None, verbose=False)[source]¶; Function to call Grimme’s dftd3 program (http://toc.uni-muenster.de/DFTD3/); to compute the -D correction of level dashlvl using parameters for; the functional func. The dictionary dashparam can be used to supply; a full set of dispersion parameters in the absense of func or to supply; individual overrides in the presence of func. Returns energy if dertype is 0,; gradient if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The dftd3 executable must be independently compiled and found in; PATH or PSIPATH.; self may be either a qcdb.Molecule (sensibly) or a psi4.Molecule; (works b/c psi4.Molecule has been extended by this method py-side and; only public interface fns used) or a string that can be instantiated; into a qcdb.Molecule. table of contents. Interface to gCP by S. Grimme; Installation; Running gCP. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/gcp-1.html:3082,energy,energy,3082,psi4manual/1.1.0/gcp-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/gcp-1.html,4,['energy'],['energy']
Energy Efficiency," the elements, coordinates, fragmentation pattern, basis sets, charge, multiplicity, etc. of a molecule.; Attributes Summary. units; Units (Angstrom or Bohr) used to define the geometry. Methods Summary. BFS(); Perform a breadth-first search (BFS) on the real atoms in molecule, returning an array of atom indices of fragments. Z((self: psi4.core.Molecule, arg0: int) -> float); Nuclear charge of atom arg1 (0-indexed). activate_all_fragments(...); Sets all fragments in the molecule to be active. add_atom((self: psi4.core.Molecule, ...); Adds to Molecule arg0 an atom with atomic number arg1, Cartesian coordinates in Bohr (arg2, arg3, arg4), atomic symbol arg5, mass arg6, charge arg7 (optional), and lineno arg8 (optional). atom_at_position((self: psi4.core.Molecule, ...); Tests to see if an atom is at the position arg2 with a given tolerance arg3. center_of_mass(...); Computes center of mass of molecule (does not translate molecule). charge((self: psi4.core.Molecule, ...); Gets charge of atom arg1 (0-indexed). clone(...); Returns a new Molecule identical to arg0. create_molecule_from_string(...); Returns a new Molecule with member data from the geometry string arg0 in Psi4 format. create_psi4_string_from_molecule(...); Gets a string reexpressing in input format the current states of the molecule. deactivate_all_fragments(...); Sets all fragments in the molecule to be inactive. distance_matrix(...); Returns Matrix of interatom distances. extract_subsets(*args, **kwargs); Overloaded function. fZ((self: psi4.core.Molecule, ...); Nuclear charge of atom arg1 (0-indexed including dummies). fcharge((self: psi4.core.Molecule, ...); Gets charge of atom arg1 (0-indexed including dummies). find_point_group((self: psi4.core.Molecule, ...); Finds computational molecular point group, user can override this with the symmetry keyword. fix_com((self: psi4.core.Molecule, ...); Whether to fix the Cartesian position, or to translate to the C.O.M. fix_orientation((self: psi4.core.Molecule, .",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html:1146,charge,charge,1146,psi4manual/1.1.0/api/psi4.core.molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html,1,['charge'],['charge']
Energy Efficiency," the full MP4 level of theory. Quantity MP4 CORRELATION; ENERGY / MP4(SDTQ) CORRELATION ENERGY is left-hand term in Eq. (2). (2). MPn TOTAL ENERGY¶. MPn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Möller–Plesset perturbation theory level.; n is MP perturbation order. NUCLEAR REPULSION ENERGY¶; The nuclear repulsion energy contribution [H] to the total SCF energy.; Quantity in Eq. (4). (3). OCEPA(0) TOTAL ENERGY¶. OCEPA(0) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the orbital-optimized CEPA(0) level of theory. OMP2 TOTAL ENERGY¶. OMP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the orbital-optimized MP2 level of theory. OMP3 TOTAL ENERGY¶. OMP3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the orbital-optimized MP3 level of theory. ONE-ELECTRON ENERGY¶; The one-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (4). QCISD TOTAL ENERGY¶. QCISD CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the quadratic configuration interaction singles and doubles level; of theory. QCISD(T) TOTAL ENERGY¶. QCISD(T) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the quadratic configuration interaction singles and doubles with; perturbative triples correction level of theory. SAPT DISP ENERGY¶. SAPT ELST ENERGY¶. SAPT EXCH ENERGY¶. SAPT IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [H] for the the; requested SAPT level of theory. The sum of these four components yields; SAPT ENERGY. SAPT ENERGY¶; The total electronic interaction energy [H] for the requested SAPT; level of theory. SAPT SAPT0 ENERGY¶. SAPT SAPT2 ENERGY¶. SAPT SAPT2+ ENERGY¶. SAPT SAPT2+(3) ENERGY¶. SAP",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/glossary_psivariables-1.html:13600,energy,energy,13600,psi4manual/4.0b4/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/glossary_psivariables-1.html,8,['energy'],['energy']
Energy Efficiency," the full MP4 level of theory. Quantity MP4 CORRELATION; ENERGY / MP4(SDTQ) CORRELATION ENERGY is left-hand term in Eq. (2). (2). MPn TOTAL ENERGY¶. MPn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Möller–Plesset perturbation theory level.; n is MP perturbation order. NUCLEAR REPULSION ENERGY¶; The nuclear repulsion energy contribution [H] to the total SCF energy.; Quantity in Eq. (4). (3). OCEPA(0) TOTAL ENERGY¶. OCEPA(0) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the orbital-optimized CEPA(0) level of theory. OMP2 TOTAL ENERGY¶. OMP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the orbital-optimized MP2 level of theory. OMP3 TOTAL ENERGY¶. OMP3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the orbital-optimized MP3 level of theory. ONE-ELECTRON ENERGY¶; The one-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (4). QCISD TOTAL ENERGY¶. QCISD CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the quadratic configuration interaction singles and doubles level; of theory. QCISD(T) TOTAL ENERGY¶. QCISD(T) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the quadratic configuration interaction singles and doubles with; perturbative triples correction level of theory. SAPT DISP ENERGY¶. SAPT ELST ENERGY¶. SAPT EXCH ENERGY¶. SAPT IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [H] for the the; requested SAPT level of theory. The sum of these four components yields; SAPT TOTAL ENERGY. SAPT TOTAL ENERGY¶; The total electronic interaction energy [H] for the requested SAPT; level of theory. SAPT0 TOTAL ENERGY¶. SSAPT0 TOTAL ENERGY¶. SAPT2 TOTAL ENERGY¶. SAPT2+ TOTAL",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/glossary_psivariables-1.html:13852,energy,energy,13852,psi4manual/1.0.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/glossary_psivariables-1.html,4,['energy'],['energy']
Energy Efficiency," the geometry optimizer. CURRENT REFERENCE ENERGY¶; The total electronic energy [Eh] of the reference stage corresponding to; the CURRENT ENERGY variable. CURRENT DIPOLE¶; The total dipole [e a0] of the most recent stage of a calculation (frequently overwritten), (3,). CURRENT GRADIENT¶; The total electronic gradient [E_h/a0] of the most recent stage of a; calculation (frequently overwritten). This is the quantity tracked by; the geometry optimizer, ({nat}, 3). CURRENT DIPOLE GRADIENT¶; The derivative of the dipole with respect to nuclear perturbations [E_h a0/u] = [(e a0/a0)^2/u]; as a degree-of-freedom by dipole component array, (3 * {nat}, 3). CURRENT HESSIAN¶; The total electronic Hessian [E_h/a0/a0] of the most recent stage of a; calculation, (3 * {nat}, 3 * {nat}). CUSTOM SCS-MP2 TOTAL ENERGY¶. CUSTOM SCS-MP2 CORRELATION ENERGY¶; Changeable quantities based on options.; The total electronic energy [Eh] and correlation energy component [Eh]; for the MP2-like method formed by any reweighting of MP2 DOUBLES ENERGY; for opposite-spin and same-spin contributions, with; any singles carried along.; Depending on weights, may equal any of MP2, SCS-MP2, SCS(N)-MP2, etc. quantities.; Contrast with SCS-MP2 TOTAL ENERGY. CUSTOM SCS-MP2.5 TOTAL ENERGY¶. CUSTOM SCS-MP2.5 CORRELATION ENERGY¶. CUSTOM SCS-MP3 TOTAL ENERGY¶. CUSTOM SCS-MP3 CORRELATION ENERGY¶. CUSTOM SCS-LCCD TOTAL ENERGY¶. CUSTOM SCS-LCCD CORRELATION ENERGY¶. CUSTOM SCS-OMP2 TOTAL ENERGY¶. CUSTOM SCS-OMP2 CORRELATION ENERGY¶. CUSTOM SCS-OMP2.5 TOTAL ENERGY¶. CUSTOM SCS-OMP2.5 CORRELATION ENERGY¶. CUSTOM SCS-OMP3 TOTAL ENERGY¶. CUSTOM SCS-OMP3 CORRELATION ENERGY¶. CUSTOM SCS-OLCCD TOTAL ENERGY¶. CUSTOM SCS-OLCCD CORRELATION ENERGY¶; Changeable quantities based on options.; The total electronic energy [Eh] and correlation energy component [Eh]; for the method formed by any reweighting of the named method DOUBLES ENERGY; for opposite-spin and same-spin contributions, with; any singles carried along.; Contrast with",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html:15920,energy,energy,15920,psi4manual/1.4.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html,10,['energy'],['energy']
Energy Efficiency," the gradient calculation; func(lowername, **kwargs). # Save the gradient; G = psi4.get_gradient(); gradients.append(G). # clean may be necessary when changing irreps of displacements; psi4.clean(). psi4.fd_freq_1(gradients, irrep). print(' Computation complete.'). # Clear the ""parent"" symmetry now; psi4.set_parent_symmetry(""""). # TODO: These need to be restored to the user specified setting; psi4.get_active_molecule().fix_orientation(False); # But not this one, it always goes back to True; psi4.get_active_molecule().reinterpret_coordentry(True). optstash.restore(); # TODO: add return statement of hessian matrix; # TODO: set current energy to un-displaced energy. else:; # If not, perform finite difference of energies; print('Performing finite difference calculations by energies'). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash.restore(); if not psi4.has_option_changed('SCF', 'E_CONVERGENCE'):; if procedures['energy'][lowername] == run_scf or procedures['energy'][lowername] == run_dft:; psi4.set_local_option('SCF', 'E_CONVERGENCE', 10); else:; psi4.set_local_option('SCF', 'E_CONVERGENCE', 11); if not psi4.has_option_changed('SCF', 'D_CONVERGENCE'):; if procedures['energy'][lowername] == run_scf or procedures['energy'][lowername] == run_dft:; psi4.set_local_option('SCF', 'D_CONVERGENCE', 10); else:; psi4.set_local_option('SCF', 'D_CONVERGENCE', 11). # Set post-scf convergence criteria (global will cover all correlated modules); if not psi4.has_global_option_changed('E_CONVERGENCE'):; if not procedures['energy'][lowername] == run_scf and not procedures['energy'][lowername] == run_dft:; psi4.set_global_option('E_CONVERGENCE', 10). # Obtain list of displacements; displacements = psi4.fd_geoms_freq_0(irrep); molecule.fix_orientation(True); molecule.reinterpret_coordentry(False); # Make a note of the undisplaced molecule's symmetry; psi4.set_parent_symmetry(molecule.schoenflies_symbol()). ndisp = len(displac",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/driver.html:64769,energy,energy,64769,psi4manual/4.0b5/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/driver.html,2,['energy'],['energy']
Energy Efficiency," the header and final results are printed. For 1, (recommended for large calculations) some intermediate quantities are also printed. Type: integer; Default: 1. Advanced Keywords for Higher-order SAPT¶. INTS_TOLERANCE¶. Minimum absolute value below which all three-index DF integrals and those contributing to four-index integrals are neglected. The default is conservative, but there isn’t much to be gained from loosening it, especially for higher-order SAPT. Type: conv double; Default: 1.0e-12. SAPT_MEM_CHECK¶. Do force SAPT2 and higher to die if it thinks there isn’t enough memory? Turning this off is ill-advised. Type: boolean; Default: true. DEBUG¶. The amount of information to print to the output file. Type: integer; Default: 0. MP2 Natural Orbitals¶; One of the unique features of the SAPT module is its ability to use; MP2 natural orbitals (NOs) to speed up the evaluation of the triples; contribution to disperison. By transforming to the MP2 NO basis, we can; throw away virtual orbitals that are expected to contribute little to the; dispersion energy. Speedups in excess of are possible. In; practice, this approximation is very good and should always be applied.; Publications resulting from the use of MP2 NO-based approximations should; cite the following: [Hohenstein:2010:104107]. Basic Keywords Controlling MP2 NO Approximations¶. NAT_ORBS_T2¶. Do use MP2 natural orbital approximations for the block of two-electron integrals in the evaluation of second-order T2 amplitudes? Recommended true for all SAPT computations. Type: boolean; Default: false. OCC_TOLERANCE¶. Minimum occupation (eigenvalues of the MP2 OPDM) below which virtual natural orbitals are discarded for in each of the above three truncations. Type: conv double; Default: 1.0e-6. Advanced Keywords Controlling MP2 NO Approximations¶. Charge-Transfer in SAPT¶; It is possible to obtain the stabilization energy of a complex due to; charge-transfer effects from a SAPT computation. The charge-transfer energy; c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/sapt-1.html:11162,energy,energy,11162,psi4manual/4.0b5/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/sapt-1.html,2,['energy'],['energy']
Energy Efficiency," the header and final results are printed. For 1, (recommended for large calculations) some intermediate quantities are also printed. Type: integer; Default: 1. Advanced Keywords for Higher-order SAPT¶. INTS_TOLERANCE¶. Minimum absolute value below which all three-index DF integrals and those contributing to four-index integrals are neglected. The default is conservative, but there isn’t much to be gained from loosening it, especially for higher-order SAPT. Type: conv double; Default: 1.0e-12. SAPT_MEM_CHECK¶. Do force SAPT2 and higher to die if it thinks there isn’t enough memory? Turning this off is ill-advised. Type: boolean; Default: true. DEBUG¶. The amount of information to print to the output file. Type: integer; Default: 0. MP2 Natural Orbitals¶; One of the unique features of the SAPT module is its ability to use; MP2 natural orbitals (NOs) to speed up the evaluation of the triples; contribution to disperison. By transforming to the MP2 NO basis, we can; throw away virtual orbitals that are expected to contribute little to the; dispersion energy. Speedups in excess of are possible. In; practice, this approximation is very good and should always be applied.; Publications resulting from the use of MP2 NO-based approximations should; cite the following: [Hohenstein:2010:104107]. Basic Keywords Controlling MP2 NO Approximations¶. NAT_ORBS¶. Do natural orbitals to speed up evaluation of the triples contribution to dispersion by truncating the virtual orbital space? Recommended true for all SAPT computations. Type: boolean; Default: false. OCC_TOLERANCE¶. Minimum occupation (eigenvalues of the MP2 OPDM) below which virtual natural orbitals are discarded for evaluating the triples contribution to dispersion. Type: conv double; Default: 1.0e-6. Advanced Keywords Controlling MP2 NO Approximations¶. NAT_ORBS_T2¶. Do use MP2 natural orbital approximations for the block of two-electron integrals in the evaluation of second-order T2 amplitudes? This approximation is promi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/sapt-1.html:11015,energy,energy,11015,psi4manual/4.0b2/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt-1.html,6,['energy'],['energy']
Energy Efficiency," the list of generated atoms. The unique atom itself is allowed offset 0. center_of_mass()[source]¶; Computes center of mass of molecule (does not translate molecule).; >>> H2OH2O.center_of_mass(); [-0.12442647346606871, 0.00038657002584110707, 0.0]. charge(atom)[source]¶; Returns charge of atom (0-indexed).; Related to SAD guess in libmints version.; >>> print H2OH2O.charge(4); 1.0. charge_specified()[source]¶; Whether the charge was given by the user; >>> print H2OH2O.charge_specified(); True. clear()[source]¶; Zero it out. clone()[source]¶; Returns new, independent Molecule object.; >>> dimer = H2OH2O.clone(). create_molecule_from_string(text)[source]¶; Given a string geom of psi4-style geometry specification; (including newlines to separate lines), builds a new molecule.; Called from constructor. create_psi4_string_from_molecule()[source]¶; Regenerates a input file molecule specification string from the; current state of the Molecule. Contains geometry info,; fragmentation, charges and multiplicities, and any frame; restriction. deactivate_all_fragments()[source]¶; Sets all fragments in the molecule to be inactive. distance_matrix()[source]¶; Computes a matrix depicting distances between atoms. Prints; formatted and returns array.; >>> H2OH2O.distance_matrix(); Interatomic Distances (Angstroms); [1] [2] [3] [4] [5] [6]; [1] 0.00000; [2] 0.95711 0.00000; [3] 0.96391 1.51726 0.00000; [4] 2.91042 3.34878 1.95159 0.00000; [5] 3.32935 3.86422 2.43843 0.95895 0.00000; [6] 3.32935 3.86422 2.43843 0.95895 1.51712 0.00000. equivalent(iuniq, j)[source]¶; NYI Returns the j’th atom equivalent to iuniq. everything()[source]¶; Quick print of class data. extract_fragments(reals, ghosts=[])[source]¶; Makes a copy of the molecule, returning a new molecule with; only certain fragment atoms present as either ghost or real atoms; reals: The list or int of fragments (1-indexed) that should be present in the molecule as real atoms.; ghosts: The list or int of fragments (1-indexed) th",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodoc_driver-1.html:46143,charge,charges,46143,psi4manual/4.0b5/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodoc_driver-1.html,2,['charge'],['charges']
Energy Efficiency," the molecular plane defining the mirror plane), the above; array will be automatically interpreted as:; SOCC = [0, 1]. Some caution is required, however. The \(^2A_1\) state can be obtained with; the; SOCC = [1, 0, 0, 0]. specification, which would become; SOCC = [1, 0]. under the above-mentioned reduction in symmetry. The \(^2B_2\) state,; whose singly-occupied orbitals are; SOCC = [0, 0, 0, 1]. would be mapped to; SOCC = [1, 0]. which is the same occupation as the \(^2A_1\) state. In this case, the; \(^2A_1\) state is lower in energy, and is not problematic. The distorted; geometries for the \(^2B_2\) state are excited states that are subject to; variational collapse. One way to obtain reliable energies for these states is; to use a multi-state method; in this case it’s easier to run the entire; computation in the lowest symmetry needed during the finite difference; procedure. Non-Covalently Bonded Molecule Fragments¶; PSI4 has an extensive range of tools for treating non-covalent; intermolecular forces, including counterpoise corrections and symmetry adapted; perturbation theory methods. These require the definition of which fragments; are interacting within the complex. PSI4 provides a very simple mechanism; for doing so: simply define the complex’s geometry using the standard; Cartesian, Z-matrix, or mixture thereof, specifications and then place two; dashes between nonbonded fragments. For example, to study the interaction; energy of ethane and ethyne molecules, we can use the following molecule; block:; molecule eneyne {; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; }. In this case, the charge and multiplicity of each interacting fragment is; explicitly specified. If the charge and m",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/psithonmol-1.html:13981,adapt,adapted,13981,psi4manual/1.4.0/psithonmol-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/psithonmol-1.html,6,['adapt'],['adapted']
Energy Efficiency," the molecular plane defining the mirror plane), the above; array will be automatically interpreted as:; SOCC = [0, 1]. Some caution is required, however. The \(^2A_1\) state can be obtained with; the; SOCC = [1, 0, 0, 0]. specification, which would become; SOCC = [1, 0]. under the above-mentioned reduction in symmetry. The \(^2B_2\) state,; whose singly-occupied orbitals are; SOCC = [0, 0, 0, 1]. would be mapped to; SOCC = [1, 0]. which is the same occupation as the \(^2A_1\) state. In this case, the; \(^2A_1\) state is lower in energy, and is not problematic. The distorted; geometries for the \(^2B_2\) state are excited states that are subject to; variational collapse. One way to obtain reliable energies for these states is; to use a multi-state method; in this case it’s easier to run the entire; computation in the lowest symmetry needed during the finite difference; procedure. Non-Covalently Bonded Molecule Fragments¶; PSI4 has an extensive range of tools for treating non-covalent; intermolecular forces, including counterpoise corrections and symmetry adapted; perturbation theory methods. These require the definition of which fragments; are interacting within the complex. PSI4 provides a very simple mechanism; for doing so: simply define the complex’s geometry using the standard; Cartesian, Z-matrix, or mixture thereof, specifications and then place two; dashes between nonbonded fragments. For example, to study the interaction; energy of ethane and ethyne molecules, we can use the following molecule; block:; molecule eneyne {; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; }. This specifies that there are two neutral, spin-singlet fragments. It is; possible to further specify that the overa",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/psithonmol.html:14188,adapt,adapted,14188,psi4manual/1.8.x/psithonmol.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/psithonmol.html,3,['adapt'],['adapted']
Energy Efficiency," the molecule the user provided is the active one; molecule = mol if mol is not None else psi4.get_active_molecule(); molecule.update_geometry(). natoms = molecule.natom(); if natoms != 2:; raise Exception(""The current molecule must be a diatomic for this code to work!""); m1 = molecule.mass(0); m2 = molecule.mass(1). maxit = 30; thres = 1.0e-9; for i in range(maxit):; if (npoints == 5):; grad= first_deriv_5pt(rvals, energies, optx); secd = second_deriv_5pt(rvals, energies, optx); energy = function_5pt(rvals, energies, optx); elif (npoints == 9):; grad = first_deriv_9pt(rvals, energies, optx); secd = second_deriv_9pt(rvals, energies, optx); energy = function_9pt(rvals, energies, optx); psi4.print_out("" E = %20.14f, x = %14.7f, grad = %20.14f\n"" % (energy, optx, grad)); if abs(grad) < thres:; break; optx -= grad / secd;; psi4.print_out("" Final E = %20.14f, x = %14.7f, grad = %20.14f\n"" % (function_5pt(rvals, energies, optx), optx, grad));. if optx < min(rvals):; raise Exception(""Minimum energy point is outside range of points provided. Use a lower range of r values.""); if optx > max(rvals):; raise Exception(""Minimum energy point is outside range of points provided. Use a higher range of r values.""). if (npoints == 5):; energy = function_5pt(rvals, energies, optx); first = first_deriv_5pt(rvals, energies, optx); secd = second_deriv_5pt(rvals, energies, optx) * p4const.psi_hartree2aJ; third = third_deriv_5pt(rvals, energies, optx) * p4const.psi_hartree2aJ; fourth = fourth_deriv_5pt(rvals, energies, optx) * p4const.psi_hartree2aJ; elif (npoints == 9):; energy = function_9pt(rvals, energies, optx); first = first_deriv_9pt(rvals, energies, optx); secd = second_deriv_9pt(rvals, energies, optx) * p4const.psi_hartree2aJ; third = third_deriv_9pt(rvals, energies, optx) * p4const.psi_hartree2aJ; fourth = fourth_deriv_9pt(rvals, energies, optx) * p4const.psi_hartree2aJ. psi4.print_out(""\nEquilibrium Energy %20.14f Hartrees\n"" % energy); psi4.print_out(""Gradient %20.14f\n"" % first",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/diatomic.html:3758,energy,energy,3758,psi4manual/1.0.0/_modules/diatomic.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/diatomic.html,1,['energy'],['energy']
Energy Efficiency," the neutral for its orbitals, if requested <= #. old_df_ints_io = psi4.get_global_option(""DF_INTS_IO""); psi4.set_global_option(""DF_INTS_IO"", ""SAVE""). old_guess = psi4.get_global_option(""GUESS""); if (neutral_guess):; if (hf_guess):; psi4.set_global_option(""REFERENCE"",""UHF""); energy('scf'); psi4.set_global_option(""GUESS"", ""READ""); psi4.set_global_option(""DF_INTS_IO"", ""LOAD""). # => Run the anion first <= #. mol.set_molecular_charge(chargem); mol.set_multiplicity(multm). # => Burn the anion in with hf, if requested <= #; if (hf_guess):; psi4.set_global_option(""REFERENCE"",""UHF""); energy('scf'); psi4.set_global_option(""REFERENCE"",""UKS""); psi4.set_global_option(""GUESS"", ""READ""); psi4.set_global_option(""DF_INTS_IO"", ""SAVE""). psi4.set_global_option(""FRAC_START"", frac_start); psi4.set_global_option(""FRAC_RENORMALIZE"", True); psi4.set_global_option(""FRAC_LOAD"", False). for occ in LUMO_occs:. psi4.set_global_option(""FRAC_OCC"", [LUMO]); psi4.set_global_option(""FRAC_VAL"", [occ]). E = energy('scf'); C = 1; if (E == 0.0):; E = psi4.get_variable('SCF ITERATION ENERGY'); C = 0. if (LUMO > 0):; ref = psi4.wavefunction(); eps = ref.epsilon_a(); potentials.append(eps[int(LUMO)-1]); else:; ref = psi4.wavefunction(); eps = ref.epsilon_b(); potentials.append(eps[-int(LUMO)-1]). occs.append(occ); energies.append(E); convs.append(C). psi4.set_global_option(""FRAC_START"", 2); psi4.set_global_option(""FRAC_LOAD"", True); psi4.set_global_option(""GUESS"", ""READ""); psi4.set_global_option(""FRAC_DIIS"", frac_diis); psi4.set_global_option(""DF_INTS_IO"", ""LOAD""). # => Run the neutral next <= #. mol.set_molecular_charge(charge0); mol.set_multiplicity(mult0). # Burn the neutral in with hf, if requested <= #. if (not continuous_guess):; psi4.set_global_option(""GUESS"", old_guess); if (hf_guess):; psi4.set_global_option(""FRAC_START"", 0); psi4.set_global_option(""REFERENCE"",""UHF""); energy('scf'); psi4.set_global_option(""REFERENCE"",""UKS""); psi4.set_global_option(""GUESS"", ""READ""); psi4.set_global_option(""FRAC_LOAD",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/frac.html:4356,energy,energy,4356,psi4manual/4.0b5/_modules/frac.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/frac.html,1,['energy'],['energy']
Energy Efficiency," the number of options to; a minimum and to allow all options to be used in the presence of all other; options. Below are some rough words of advice about using the SCF code for; practical calculations:. For GUESS, the SAD guess is usually your; friend, even for open-shell systems (at the very least, it gets the right; number of electrons, unlike some other programs). For instance, we have found; that a simple SAD guess is often as good as doing a full SCF in a 3-21G basis; and then performing a cast-up, at a fraction of the cost. However, SAD and; DOCC/SOCC arrays do not play very well together at the moment.; For wall time, DF may be a factor of ten or more faster than the exact; integral technologies available in PSI4.; Use DF unless you need absolute accuracy or do not; have a -JKFIT auxiliary set for your orbital basis/atom type. Then use; DIRECT.; Don’t mess with the DIIS convergence options unless convergence is a problem.; We have optimized the parameters for efficiency over a wide array of system; types.; Buy a developer a beer!. The “best-practice” input file for HF is:; memory 1 GB # As much as you've got, the DF algorithm can use. molecule {; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; basis cc-pvdz; scf_type df; guess sad; ints_tolerance 1.0E-10 # Even this is epically tight, 1.0E-8 is OK; }. energy('scf'). table of contents. HF: Hartree–Fock Theory; Introduction; Theory; Minimal Input; Spin/Symmetry Treatment; Broken Symmetry; Orthogonalization; Initial Guess; Restarting the SCF; Convergence Stabilization; ERI Algorithms; Second-order Convergence; Stability Analysis; Effective core potentials (ECPs); External potentials and QM/MM; Convergence and Algorithm Defaults; Recommendations. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Theoretical Methods: SCF to FCI; HF: Hartree–Fock Theory. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/scf-1.html:42877,energy,energy,42877,psi4manual/1.4.0/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/scf-1.html,2,['energy'],['energy']
Energy Efficiency," the number of options to; a minimum and to allow all options to be used in the presence of all other; options. Below are some rough words of advice about using the SCF code for; practical calculations:. For GUESS, the SAD guess is usually your; friend, even for open-shell systems (at the very least, it gets the right; number of electrons, unlike some other programs). For instance, we have found; that a simple SAD guess is often as good as doing a full SCF in a 3-21G basis; and then performing a cast-up, at a fraction of the cost. However, SAD and; DOCC/SOCC arrays do not play very well together at the moment.; For wall time, DF may be a factor of ten or more faster than the exact; integral technologies available in PSI4.; Use DF unless you need absolute accuracy or do not; have a -JKFIT auxiliary set for your orbital basis/atom type. Then use; DIRECT.; Don’t mess with the DIIS convergence options unless convergence is a problem.; We have optimized the parameters for efficiency over a wide array of system; types.; Buy a developer a beer!. The “best-practice” input file for HF is:; memory 1 GB # As much as you've got, the DF algorithm can use. molecule {; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; basis cc-pvdz; scf_type df; guess sad; ints_tolerance 1.0E-10 # Even this is epically tight, 1.0E-8 is OK; }. energy('scf'). table of contents. HF: Hartree–Fock Theory; Introduction; Theory; Minimal Input; Spin/Symmetry Treatment; Broken Symmetry; Orthogonalization; Initial Guess; Restarting the SCF; Convergence Stabilization; ERI Algorithms; Second-order Convergence; Stability Analysis; Effective core potentials (ECPs); External potentials and QM/MM; Convergence and Algorithm Defaults; Recommendations. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Theoretical Methods: SCF to FCI; HF: Hartree–Fock Theory. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/scf-1.html:43910,energy,energy,43910,psi4manual/1.5.0/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/scf-1.html,2,['energy'],['energy']
Energy Efficiency," the number of virtual; orbitals retained after the FNO truncation.; The general outline for the FNO procedure in PSI4 is:. construct the virtual-virtual block of the unrelaxed MP2 one-particle density matrix (OPDM); diagonalize this block of the OPDM to obtain a set of natural virtual orbitals; based on some occupancy threshold, determine which orbitals are unimportant and may be discarded; project the virtual-virtual block of the Fock matrix onto the truncated space; construct semicanonical orbitals by diagonalizing the virtual-virtual block of the Fock matrix; proceed with the QCISD(T) / CCSD(T) / MP4 computation in the reduced virtual space. A second-order correction based upon the MP2 energies in the full and; truncated spaces captures much of the missing correlation effects. More; details on the implementation and numerical accuracy of FNO methods in; PSI4 can be found in [DePrince:2013:293]. FNO computations; are controlled through the keywords NAT_ORBS and; OCC_TOLERANCE, or by prepending a valid method name with “fno” in; the energy call as; 1energy('fno-ccsd(t)'). If you wish to specify the number of active natural orbitals manually, use; the keyword ACTIVE_NAT_ORBS. This keyword will override the; keyword OCC_TOLERANCE. QCISD(T), CCSD(T), MP4, and CEPA¶; The FNOCC module in PSI4 supports several related many-body quantum; chemistry methods, including the CCSD(T) and QCISD(T) methods, several; orders of many-body perturbation theory (MP2-MP4), and a family methods; related to the coupled electron pair approximation (CEPA). Quadratic configuration interaction and coupled cluster¶; The quadratic configuration interaction singles doubles (QCISD) method of; Pople, Head-Gordon, and Raghavachari [Pople:1987:5968] was originally; presented as a size-consistent extension of configuration interaction; singles doubles (CISD). The method can also be obtained as a; simplified version of the coupled cluster singles doubles (CCSD); method [Purvis:1982]. Consider the set ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/fnocc-1.html:2565,energy,energy,2565,psi4manual/1.1.0/fnocc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/fnocc-1.html,6,['energy'],['energy']
Energy Efficiency," the number of virtual; orbitals retained after the FNO truncation.; The general outline for the FNO procedure in PSI4 is:. construct the virtual-virtual block of the unrelaxed MP2 one-particle density matrix (OPDM); diagonalize this block of the OPDM to obtain a set of natural virtual orbitals; based on some occupancy threshold, determine which orbitals are unimportant and may be discarded; project the virtual-virtual block of the Fock matrix onto the truncated space; construct semicanonical orbitals by diagonalizing the virtual-virtual block of the Fock matrix; proceed with the QCISD(T) / CCSD(T) / MP4 computation in the reduced virtual space. A second-order correction based upon the MP2 energies in the full and; truncated spaces captures much of the missing correlation effects. More; details on the implementation and numerical accuracy of FNO methods in; PSI4 can be found in [DePrince:2013:293]. FNO computations; are controlled through the keywords NAT_ORBS and; OCC_TOLERANCE, or by prepending a valid method name with “fno” in; the energy call as; energy('fno-ccsd(t)'). If you wish to specify the number of active natural orbitals manually, use; the keyword ACTIVE_NAT_ORBS. This keyword will override the; keyword OCC_TOLERANCE. QCISD(T), CCSD(T), MP4, and CEPA¶; The FNOCC module in PSI4 supports several related many-body quantum; chemistry methods, including the CCSD(T) and QCISD(T) methods, several; orders of many-body perturbation theory (MP2-MP4), and a family methods; related to the coupled electron pair approximation (CEPA). Quadratic configuration interaction and coupled cluster¶; The quadratic configuration interaction singles doubles (QCISD) method of; Pople, Head-Gordon, and Raghavachari [Pople:1987:5968] was originally; presented as a size-consistent extension of configuration interaction; singles doubles (CISD). The method can also be obtained as a; simplified version of the coupled cluster singles doubles (CCSD); method [Purvis:1982]. Consider the set ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/fnocc-1.html:2634,energy,energy,2634,psi4manual/1.4.0/fnocc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/fnocc-1.html,18,['energy'],['energy']
Energy Efficiency," the one-particle electronic density and B) there exists a set of; noninteracting quasiparticles with the same density as the true set of; electrons, with the quasiparticle states determined as eigenvectors of an; effective one-body potential encapsulating the true -body quantum; effects. The former idea allows the electronic density to be dealt with instead; of the much more complicated wavefunction, while the latter allows for the; treatment of the troublesome kinetic energy term via the implicit one-body; Kohn-Sham orbitals. KS-DFT borrows much of the machinery of Hartree-Fock, as is; evident by looking at the energy expression,. Here is the noninteracting quasiparticle kinetic energy operator,; is the nucleus-electron attraction potential, ; is the total electron density matrix, and is the (potentially nonlocal) exchange, correlation, and residual; kinetic energy functional. The residual kinetic energy term is usually quite; small, and is often ignored, hence is often referred to; as simply the exchange-correlation functional (exchange and correlation, not; just exchange-type correlation).; In practice, the first few generations of KS-DFT functionals were chosen to be; local, meaning that the form of the exchange correlation energy is an integral; over all of space of a function depending only on local information in the; density, such as the density value or derivatives. The simplest variants are; Local Spin-Density Approximations (LSDA), which depend only on the spin density; or ,. The most popular variants are Generalized Gradient Approximation (GGA); functionals which use the norm of the density gradient; , or; to build an inhomogeneity; parameter. where,. GGA functionals are essentially the same cost as LSDA functionals, and are often; considerably more accurate.; Another local variant which has gained some popularity (though perhaps not as; much as GGA functionals) is the meta approximation, in which information about; the second derivative of the density i",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/dft-1.html:1792,energy,energy,1792,psi4manual/1.0.0/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/dft-1.html,10,['energy'],['energy']
Energy Efficiency," the primary basis set. Fortunately, PSI4 is usually smart; enough to figure out what auxiliary basis sets are needed for a given; computation. In this case, jun-cc-pVDZ is a standard enough basis set; (just a simple truncation of the very popular aug-cc-pVDZ basis set); that PSI4 correctly guesses that we want the jun-cc-pVDZ-JKFIT; auxiliary basis for the Hartree–Fock, and the jun-cc-pVDZ-RI basis set; for the SAPT procedure.; To speed up the computation a little, we also tell the SAPT procedure to; freeze the core electrons with freeze_core True. The SAPT; procedure is invoked with the simple call, energy('sapt0'). This; call knows to automatically run two monomer computations and a dimer; computation and then use these results to perform the SAPT analysis. The; various energy components are printed at the end of the output, in addition; to the total SAPT0 interaction energy. An explanation of the various; energy components can be found in the review by Jeziorski, Moszynski, and; Szalewicz [Jeziorski:1994:1887], and this is discussed in more detail; in the SAPT section later in this manual. For now, we’ll note that most of; the SAPT energy components are negative; this means those are attractive; contributions (the zero of energy in a SAPT computation is defined as; non-interacting monomers). The exchange contributions are positive; (repulsive). In this example, the most attractive contribution between; ethylene and acetylene is an electrostatic term of -2.12 kcal mol-1; (Elst10,r where the 1 indicates the first-order; perturbation theory result with respect to the intermolecular interaction,; and the 0 indicates zeroth-order with respect to intramolecular electron; correlation). The next most attractive contribution is the Disp20; term (2nd order intermolecular dispersion, which looks like an MP2 in which; one excitation is placed on each monomer), contributing an attraction of; -1.21 kcal mol-1. It is not surprising that the electrostatic; contribution is domina",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/tutorial-1.html:13918,energy,energy,13918,psi4manual/1.1.0/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/tutorial-1.html,21,['energy'],['energy']
Energy Efficiency," the primary basis set. Fortunately, Psi4 is usually smart; enough to figure out what auxiliary basis sets are needed for a given; computation. In this case, jun-cc-pVDZ is a standard enough basis set; (just a simple truncation of the very popular aug-cc-pVDZ basis set); that Psi4 correctly guesses that we want the jun-cc-pVDZ-JKFIT; auxiliary basis for the Hartree–Fock, and the jun-cc-pVDZ-RI basis set; for the SAPT procedure.; To speed up the computation a little, we also tell the SAPT procedure to; freeze the core electrons with freeze_core True. The SAPT; procedure is invoked with the simple call, energy('sapt0'). This; call knows to automatically run two monomer computations and a dimer; computation and then use these results to perform the SAPT analysis. The; various energy components are printed at the end of the output, in addition; to the total SAPT0 interaction energy. An explanation of the various; energy components can be found in the review by Jeziorski, Moszynski, and; Szalewicz [Jeziorski:1994:1887], and this is discussed in more detail; in the SAPT section later in this manual. For now, we’ll note that most of; the SAPT energy components are negative; this means those are attractive; contributions (the zero of energy in a SAPT computation is defined as; non-interacting monomers). The exchange contributions are positive; (repulsive). In this example, the most attractive contribution between; ethylene and acetylene is an electrostatic term of -2.12 kcal mol-1; (Elst10,r where the 1 indicates the first-order; perturbation theory result with respect to the intermolecular interaction,; and the 0 indicates zeroth-order with respect to intramolecular electron; correlation). The next most attractive contribution is the Disp20; term (2nd order intermolecular dispersion, which looks like an MP2 in which; one excitation is placed on each monomer), contributing an attraction of; -1.21 kcal mol-1. It is not surprising that the electrostatic; contribution is domina",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/tutorial-1.html:13178,energy,energy,13178,psi4manual/1.0.0/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/tutorial-1.html,2,['energy'],['energy']
Energy Efficiency," the process number, name the name of the molecule,; and filenumber is listed in content.; For those modules providing restart capabilities, the previous file can; be provided through the``restart_file`` option; energy('scf',restart_file='./psi.PID.name.filenumber'). Only the filenumber is necessary for the driver to appropriately rename the; file and copy it to the scratch directory where PSI4 will expect it.; The restart capabilities of a specific method (if any) are found in that method’s documentation.; To provide multiple files, pass them as arguments of a Python list; energy('scf',restart_file=['./file1.filenumber','./file2.filenumber']). Note that the restart_file options is only available for energy procedures as of now.; Executing PSI4 with the psi4 -m (for; messy) flag will prevent files being deleted at the end of the run:; psi4 -m. The mechanism for restarting HF/DFT calculations is described in details here. Saving the Wavefunction¶; A core object of PSI4 is the Wavefunction (short wfn) object; energy, wfn = energy('scf',return_wfn=True). This C++/Python object (psi4.core.Wavefunction) contains orbital; data, basis set information, result variables and more.; It can be saved either to a numpy file or converted to a python dictionary; # write the wavefunction to file; wfn.to_file('my_wfn'). # alternatively store the dict representation of the wavefunction in memory; wfn_dict = wfn.to_file(). In either form, its attributes can be set and edited.; This is an expert-level feature, though.; In general, let PSI4 create the Wavefunction, then treat it as read-only.; The back conversion to a Wavefunction object uses the .from_file() functionality; # read wavefunction from file; wfn_from_file = psi4.core.Wavefunction.from_file('my_wfn'). # make a wavefunction from the dict; wfn_from_dict = psi4.core.Wavefunction.from_file(wfn_dict). ~/.psi4rc File¶. Caution; The ~/.psi4rc file is only read for Psithon input, not PsiAPI.; It does nothing that can’t be done in othe",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/external-1.html:8418,energy,energy,8418,psi4manual/1.4.0/external-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/external-1.html,18,['energy'],['energy']
Energy Efficiency," the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'corl', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'corl', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; zHI = NEED['HI']['f_zeta']; eLO = NEED['LO']['f_energy']; zLO = NEED['LO']['f_zeta']. # Compute extrapolated energy; energypiece = (eHI * zHI ** 3 - eLO * zLO ** 3) / (zHI ** 3 - zLO ** 3); beta = (eHI - eLO) / (zHI ** (-3) - zLO ** (-3)). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); PsiMod.print_out(cbsscheme). return energypiece. [docs]def scf_xtpl_helgaker_3(**largs):; r""""""Extrapolation scheme for reference energies with three adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 3):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'tot', BSET[2], ZSET[2], 0.0])),; 'MD': dict(zip(f_fields, [wfnname, 'tot', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'tot', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:80522,energy,energypiece,80522,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,3,['energy'],['energypiece']
Energy Efficiency," the same between updates, the CC codes will, by default, re-use old vectors, unless the user sets RESTART = false. Type: boolean; Default: true. ROOTS_PER_IRREP¶. The number of electronic states to computed, per irreducible// representation. Type: array; Default: No Default. R_CONVERGENCE¶. Convergence criterion for T2 amplitudes (RMS change). Type: conv double; Default: 1e-5. SCREEN_INTS¶. Do screen integrals?. Type: boolean; Default: false. SCS¶. Do spin-component-scaled MP2 (SCS-MP2)?. Type: boolean; Default: false. SCSN_MP2¶. Do SCS-MP2 with parameters optimized for nucleic acids?. Type: boolean; Default: false. SCS_CCSD¶. Do spin-component-scaled CCSD. Type: boolean; Default: false. SCS_MP2¶. Do spin-component-scaled MP2 (SCS-MP2)?. Type: boolean; Default: false. SCS_N¶. Do SCS-MP2 with parameters optimized for nucleic acids?. Type: boolean; Default: false. SEMICANONICAL¶. Convert ROHF MOs to semicanonical MOs. Type: boolean; Default: true. SPINADAPT_ENERGIES¶. Do print spin-adapted pair energies?. Type: boolean; Default: false. T2_COUPLED¶. Type: boolean; Default: false. T3_WS_INCORE¶. Do build W intermediates required for cc3 in core memory?. Type: boolean; Default: false. Expert¶. AO_BASIS¶. The algorithm to use for the terms If AO_BASIS is NONE, the MO-basis integrals will be used; if AO_BASIS is DISK, the AO-basis integrals stored on disk will be used; if AO_BASIS is DIRECT, the AO-basis integrals will be computed on the fly as necessary. NB: The DIRECT option is not fully implemented and should only be used by experts. Default is NONE. Note: The developers recommend use of this keyword only as a last resort because it significantly slows the calculation. The current algorithms for handling the MO-basis four-virtual-index integrals have been significantly improved and are preferable to the AO-based approach. Type: string; Possible Values: NONE, DISK, DIRECT; Default: NONE. FORCE_RESTART¶. Do restart the coupled-cluster iterations even if MO phases are scr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodir_options_c/module__ccenergy-1.html:6895,adapt,adapted,6895,psi4manual/4.0b5/autodir_options_c/module__ccenergy-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/module__ccenergy-1.html,2,['adapt'],['adapted']
Energy Efficiency," the same keys as dashcoeff[dashlvl][‘default’]; used to override any or all values initialized by func.; Extra parameters will error.; dertype (int or str, optional) – Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int, optional) – Amount of printing. Returns:; energy (float) – When dertype=0, energy [Eh].; gradient (ndarray) – When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray) – When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. run_gcp(func=None, dertype=None, verbose=False)¶; Function to call Grimme’s GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to self for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, func. Returns energy if dertype is 0, gradient; if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The gcp executable must be independently compiled and; found in PATH or PSIPATH. self may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.Molecule. save_string_xyz(self: psi4.core.Molecule) → str¶; Saves the string of an XYZ file to arg2. save_string_xyz_file(self: psi4.core.Molecule) → str¶; Saves an XYZ file to arg2. save_xyz_file(self: psi4.core.Molecule, arg0: str, arg1: bool) → None¶; Saves an XYZ file to arg0. schoenflies_symbol(self: psi4.core.Molecule) → str¶; Returns the Schoenflies symbol. scramble(do_shift=True, do_rotate=True, do_resort=True, deflection=1.0, do_mirror=False, do_plot=False, run_to_completion=False, run_resorting=False, verbose=1)[source]¶; Tester for B787 by shifting, rotating, and atom shuffling ref_mol and; checking that the aligner retur",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.molecule.html:28981,energy,energy,28981,psi4manual/1.3.2/api/psi4.core.molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.molecule.html,6,['energy'],['energy']
Energy Efficiency," the second orbital (1-based) to rotate. Type: integer; Default: 2. ROTATIONAL_SYMMETRY_NUMBER (THERMO); THERMO — Rotational symmetry number for thermodynamic analysis. Default is set from the full point group (e.g., Td for methane) as opposed to the computational point group (e.g., C2v for methane). Default takes into account symmetry reduction through asymmetric isotopic substitution and is unaffected by user-set symmetry on molecule, so this option is the sole way to influence the symmetry-dependent aspects of the thermodynamic analysis. Type: integer; Default: 1. RSRFO_ALPHA_MAX (OPTKING); OPTKING — Absolute maximum value of RS-RFO. Type: double; Default: 1e8. RUN_CCSD (FNOCC); FNOCC (Expert) — do ccsd rather than qcisd?. Type: boolean; Default: false. RUN_CEPA (FNOCC); FNOCC (Expert) — Is this a CEPA job? This parameter is used internally by the pythond driver. Changing its value won’t have any effect on the procedure. Type: boolean; Default: false. RUN_MP2 (FNOCC); FNOCC (Expert) — do only evaluate mp2 energy?. Type: boolean; Default: false. RUN_MP3 (FNOCC); FNOCC (Expert) — do only evaluate mp3 energy?. Type: boolean; Default: false. RUN_MP4 (FNOCC); FNOCC (Expert) — do only evaluate mp4 energy?. Type: boolean; Default: false. S (DETCI); DETCI — The value of the spin quantum number is given by this option. The default is determined by the value of the multiplicity. This is used for two things: (1) determining the phase of the redundant half of the CI vector when the component is used (i.e., MS0 = TRUE), and (2) making sure the guess vector has the desired value of (if CALC_S_SQUARED is TRUE and ICORE = 1). Type: double; Default: 0.0. S_ORTHOGONALIZATION (SCF); SCF — SO orthogonalization: symmetric or canonical?. Type: string; Possible Values: SYMMETRIC, CANONICAL; Default: SYMMETRIC. S_TOLERANCE (SCF); SCF — Minimum S matrix eigenvalue to be used before compensating for linear dependencies. Type: conv double; Default: 1e-7. SAD_CHOL_TOLERANCE (SCF); SCF (Expe",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:199766,energy,energy,199766,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,2,['energy'],['energy']
Energy Efficiency," the spin contamination of the true electrons. These are set in the REFERENCE option.; Note that there are not equivalents to ROHF or CUHF, e.g., no ROKS or CUKS. This; is because ROHF is implicitly assumed to be followed by a correlated method; which can break the positive definiteness of the spin polarization. KS-DFT with; the true functional is expected to be the final step, thus restricting the; solution to positive definite spin polarization is not physical. See the; section in Szabo on methyl radical for an example. Functional Selection¶; PSI4 features an extensive list of LSDA, GGA, Meta, Hybrid, LRC, and -D; functionals. These can be specified by a variety of means. Perhaps the simplest; is to use the functional name as the energy procedure call:; energy('b3lyp'). Note that if you are running an unrestricted computation, you should set the; REFERENCE option before the call to energy:; set reference uks; energy('b3lyp'). The functional may also be manually specified by the DFT_FUNCTIONAL; option:; set dft_functional b3lyp; energy('scf'). For hybrid functionals, the fraction of exact exchange is controlled by the; DFT_ALPHA option. For the LRC functionals, the fraction of long-range; Hartree-Fock and short-range DFA is controlled by the DFT_OMEGA option.; Changing these will override the default behavior of the requested functional.; A brief summary of some of the more notable functionals in PSI4, and links; to the complete listing of all functionals of each class are presented below:. All Functionals; All functionals, including LSDA-only functionals. Note that here and; throughout, functionals which end in _X or _C are exchange or; correlation only, and should not be used for most production-level; computations. Examples include PBE_X and PBE_C, which contain the; separate definitions of the PBE exchange and correlation holes. In most cases,; the united PBE functional should be used instead.; GGA Functionals; Many common GGA functionals. BLYP and PBE are proba",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/dft-1.html:11127,energy,energy,11127,psi4manual/4.0b2/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/dft-1.html,8,['energy'],['energy']
Energy Efficiency," the spin contamination of the true electrons. These are set in the REFERENCE option.; Note that there are not equivalents to ROHF or CUHF, e.g., no ROKS or CUKS. This; is because ROHF is implicitly assumed to be followed by a correlated method; which can break the positive definiteness of the spin polarization. KS-DFT with; the true functional is expected to be the final step, thus restricting the; solution to positive definite spin polarization is not physical. See the; section in Szabo on methyl radical for an example. Functional Selection¶; Psi4 features an extensive list of LSDA, GGA, Meta, Hybrid, LRC, and -D; functionals. These can be specified by a variety of means. Perhaps the simplest; is to use the functional name as the energy procedure call:; energy('b3lyp'). Note that if you are running an unrestricted computation, you should set the; REFERENCE option before the call to energy:; set reference uks; energy('b3lyp'). The functional may also be manually specified by the DFT_FUNCTIONAL; option:; set dft_functional b3lyp; energy('scf'). For hybrid functionals, the fraction of exact exchange is controlled by the; DFT_ALPHA option. For the LRC functionals, the fraction of long-range; Hartree-Fock and short-range DFA is controlled by the DFT_OMEGA option.; Changing these will override the default behavior of the requested functional.; A brief summary of some of the more notable functionals in Psi4, and links; to the complete listing of all functionals of each class are presented below:. All Functionals; All functionals, including LSDA-only functionals. Note that here and; throughout, functionals which end in _X or _C are exchange or; correlation only, and should not be used for most production-level; computations. Examples include PBE_X and PBE_C, which contain the; separate definitions of the PBE exchange and correlation holes. In most cases,; the united PBE functional should be used instead.; GGA Functionals; Many common GGA functionals. BLYP and PBE are proba",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/dft-1.html:11237,energy,energy,11237,psi4manual/1.0.0/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/dft-1.html,2,['energy'],['energy']
Energy Efficiency," the spin polarization. KS-DFT with; the true functional is expected to be the final step, thus restricting the; solution to positive definite spin polarization is not physical. See the; section in [Szabo:1982] on methyl radical for an example. Functional Selection¶; PSI4 features an extensive list of LSDA, GGA, Meta, Hybrid, LRC, and -D; functionals. These can be specified by a variety of means. Perhaps the simplest; is to use the functional name as the energy procedure call:; energy('b3lyp'). Note that if you are running an unrestricted computation, you should set the; REFERENCE option before the call to energy:; set reference uks; energy('b3lyp'). The functional may also be manually specified by calling energy (or any driver function); with a dft_functional argument:; energy('scf', dft_functional = 'b3lyp'). Another alternative is providing a specially crafted dict-ionary to the dft_functional; argument:; custom_functional = { ""name"": ""my_unique_name"", ... }; energy('scf', dft_functional = custom_functional). For further details about this so called dict_func syntax, see; Advanced Functional Use and Manipulation.; For hybrid functionals, the fraction of exact exchange is controlled by the; DFT_ALPHA option. For the LRC functionals, the fraction of long-range; Hartree–Fock and short-range DFA is controlled by the DFT_OMEGA option.; Changing these will override the default behavior of the requested functional.; A brief summary of some of the more notable functionals in PSI4, and links; to the complete listing of all functionals of each class are presented below:. All FunctionalsAll functionals, including LSDA-only functionals. Note that here and; throughout, functionals which end in _X or _C are exchange or; correlation only, and should not be used for most production-level; computations. Examples include PBE_X and PBE_C, which contain the; separate definitions of the PBE exchange and correlation holes. In most cases,; the united PBE functional should be used inste",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/dft-1.html:15679,energy,energy,15679,psi4manual/1.4.0/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/dft-1.html,9,['energy'],['energy']
Energy Efficiency," the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. DF-MP2 TOTAL ENERGY¶. DF-MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the density-fitted MP2 level of theory. DFT FUNCTIONAL TOTAL ENERGY¶; The total electronic energy [H] for the underlying functional of the; requested DFT method, without any dispersion correction; the first four; terms in Eq. (3) or (1). Quantity; in Eqs. (3) and (1).; Unless the method includes a dispersion correction, this quantity is; equal to SCF TOTAL ENERGY. DFT TOTAL ENERGY¶; The total electronic energy [H] for the requested DFT method,; in Eq. (1). (1); Unless the method is a DFT double-hybrid, this quantity is equal to; SCF TOTAL ENERGY. If the method is neither a; double-hybrid, nor dispersion corrected, this quantity is equal to; DFT FUNCTIONAL TOTAL ENERGY. DFT XC ENERGY¶; The functional energy contribution [H] to the total SCF energy (DFT only).; Quantity in Eqs. (3) and (1). DISPERSION CORRECTION ENERGY¶; The dispersion correction [H] appended to an underlying functional; when a DFT-D method is requested. Quantity ; in Eqs. (3) and (1). DOUBLE-HYBRID CORRECTION ENERGY¶; The scaled MP2 correlation energy correction [H] appended to an; underlying functional when a DH-DFT method is requested.; Quantity in Eq. (1). FCI TOTAL ENERGY¶. FCI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the full configuration interaction level of theory. HF TOTAL ENERGY¶; The total electronic energy [H] for the Hartree–Fock method, without; any dispersion correction; the first three (or four, since; ) terms in Eq. (3). Quantity ; in Eq. (3). LCC2 (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CC2 level of theory. LCCSD (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CCSD level of theory. MP2 TOTAL ENERGY¶. MP2 CORR",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:10809,energy,energy,10809,psi4manual/4.0b3/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html,4,['energy'],['energy']
Energy Efficiency," the term; “exact-exchange” refers to the Hartree-Fock being the exact exchange energy of; the noninteracting quasiparticles, not the true electrons. Therefore, adding; 100% exact exchange is not physically reasonable, and will often lead to; extremely poor results. The fraction of exact-exchange, denoted ,; is often determined by adiabatic or heuristic arguments, and is typically around; 25%. The addition of exact exchange borrows another piece from an existing; Hartree-Fock code, with the caveat that Hartree-Fock exchange is often much more; costly to obtain than the Coulomb matrix. The global hybrid ansatz has become; exceedingly popular, with functionals such as the ubiquitous B3LYP often; producing absurdly accurate results.; A more advanced GKS functional technology which has developed enormous; popularity in recent years is the Long-Range Corrected (LRC) ansatz. LRC; recognizes that the local DFA is potentially exact at short range in the; exchange hole, and that the hybrid-exchange energy of the noninteracting; quasiparticles is also exact for true electrons at long range in the exchange; hole. Therefore LRC switches from DFA at short range to hybrid exchange at long; range, typically using the function as a; partition function.; Tying all these pieces together, a full LRC-hybrid GKS functional has the; generic form,. For LRC functionals, the choice of range-separtion parameter has; been the subject of considerable activity since the inception of LRC; functionals. Some authors advocate a static range-separation parameter; determined by optimization over a test set of chemical systems. However, a more; physically-motivated and often more accurate approach is the idea of “gap; fitting” or “optimal tuning” or simply “tuning.” The most popular tuned-LRC; approach is IP-fitting, in which the is varied until the; Koopman’s IP (the opposite of the HOMO energy) matches the true IP (the; difference between -electron and -electron total; energies), within the LRC func",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/dft-1.html:6474,energy,energy,6474,psi4manual/1.0.0/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/dft-1.html,10,['energy'],['energy']
Energy Efficiency," the test suite. :returns: a dictionary of energies computed from the MO integrals.; - 'NUCLEAR REPULSION ENERGY' : nuclear repulsion plus frozen core energy; - 'ONE-ELECTRON ENERGY' : SCF one-electron energy; - 'TWO-ELECTRON ENERGY' : SCF two-electron energy; - 'SCF TOTAL ENERGY' : SCF total energy; - 'MP2 CORRELATION ENERGY' : MP2 correlation energy. :param expected: reference FCIDUMP file; :param computed: computed FCIDUMP file; :param label: string labelling the test; """""". # Grab expected header and integrals; ref_intdump = fcidump_from_file(expected); intdump = fcidump_from_file(computed). # Compare headers; compare_recursive(; ref_intdump,; intdump,; 'FCIDUMP header',; forgive=['enuc', 'hcore', 'eri', 'epsilon']). ref_energies = energies_from_fcidump(ref_intdump); energies = energies_from_fcidump(intdump). pass_1el = compare_values(ref_energies['ONE-ELECTRON ENERGY'], energies['ONE-ELECTRON ENERGY'], 7,; label + '. 1-electron energy'); pass_2el = compare_values(ref_energies['TWO-ELECTRON ENERGY'], energies['TWO-ELECTRON ENERGY'], 7,; label + '. 2-electron energy'); pass_scf = compare_values(ref_energies['SCF TOTAL ENERGY'], energies['SCF TOTAL ENERGY'], 10,; label + '. SCF total energy'); pass_mp2 = compare_values(ref_energies['MP2 CORRELATION ENERGY'], energies['MP2 CORRELATION ENERGY'], 10,; label + '. MP2 correlation energy'). compare_integers(True, (pass_1el and pass_2el and pass_scf and pass_mp2), label). [docs]def energies_from_fcidump(intdump):; energies = {}; energies['NUCLEAR REPULSION ENERGY'] = intdump['enuc']; epsilon = intdump['epsilon']; Hcore = intdump['hcore']; eri = intdump['eri']. # Compute SCF energy; energies['ONE-ELECTRON ENERGY'], energies['TWO-ELECTRON ENERGY'] = _scf_energy(Hcore, eri,; np.where(epsilon < 0)[0],; intdump['uhf']); # yapf: disable; energies['SCF TOTAL ENERGY'] = energies['ONE-ELECTRON ENERGY'] + energies['TWO-ELECTRON ENERGY'] + energies['NUCLEAR REPULSION ENERGY']; # yapf: enable. # Compute MP2 energy; energies['MP2 CORR",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/fcidump.html:13062,energy,energy,13062,psi4manual/1.4.0/_modules/psi4/driver/p4util/fcidump.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/fcidump.html,2,['energy'],['energy']
Energy Efficiency," the user provided is the active one; if ('molecule' in kwargs):; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); PsiMod.set_global_option('BASIS', PsiMod.get_global_option('BASIS')). # S/R: Mode of operation- whether finite difference opt run in one job or files farmed out; opt_mode = 'continuous'; if ('mode' in kwargs) and (dertype == 0):; opt_mode = kwargs['mode']. if (opt_mode.lower() == 'continuous'):; pass; elif (opt_mode.lower() == 'sow'):; pass; elif (opt_mode.lower() == 'reap'):; if('linkage' in kwargs):; opt_linkage = kwargs['linkage']; else:; raise ValidationError('Optimize execution mode \'reap\' requires a linkage option.'); else:; raise ValidationError('Optimize execution mode \'%s\' not valid.' % (opt_mode)). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); if not PsiMod.has_option_changed('SCF', 'E_CONVERGENCE'):; if procedures['energy'][lowername] == run_scf or procedures['energy'][lowername] == run_dft:; PsiMod.set_local_option('SCF', 'E_CONVERGENCE', 8); else:; PsiMod.set_local_option('SCF', 'E_CONVERGENCE', 10); if not PsiMod.has_option_changed('SCF', 'D_CONVERGENCE'):; if procedures['energy'][lowername] == run_scf or procedures['energy'][lowername] == run_dft:; PsiMod.set_local_option('SCF', 'D_CONVERGENCE', 8); else:; PsiMod.set_local_option('SCF', 'D_CONVERGENCE', 10). # Set post-scf convergence criteria (global will cover all correlated modules); if not PsiMod.has_global_option_changed('E_CONVERGENCE'):; if not procedures['energy'][lowername] == run_scf and not procedures['energy'][lowername] == run_dft:; PsiMod.set_global_option('E_CONVERGENCE', 8). # Does dertype indicate an analytic procedure both exists and is wanted?; if (dertype == 1):; # Nothing to it but to do it. Gradient information is saved; # into the current reference wavefunction; procedures['gradient'][lowername](lowername, **kwargs). if 'mode' in kw",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/driver.html:33175,energy,energy,33175,psi4manual/4.0b4/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/driver.html,2,['energy'],['energy']
Energy Efficiency," the v1.1 release), PSI4; switched from hand- (+Matlab) coded functionals to Libxc. Thus; many DFT results will be slightly different. Functionals more than; slightly different are B97-D, wB97X (note, not wB97X-D), SOGGA,; DFDL, and M05. Theory¶; Generalized Kohn–Sham Density Functional Theory (KS-DFT) [Kohn:1965:A1133] [Parr:1989] is one of the primary; workhorses of modern computational chemistry due to its phenomenal accuracy/cost; ratio.; Pure Kohn–Sham DFT is built on the Hohenberg–Kohn theorems [Hohenberg:1964:136] which states: A) the energy is a universal; functional of the one-particle electronic density and B) there exists a set of; noninteracting quasiparticles with the same density as the true set of; electrons, with the quasiparticle states determined as eigenvectors of an; effective one-body potential encapsulating the true \(N\)-body quantum; effects. The former idea allows the electronic density to be dealt with instead; of the much more complicated wavefunction, while the latter allows for the; treatment of the troublesome kinetic energy term via the implicit one-body; Kohn–Sham orbitals. KS-DFT borrows much of the machinery of Hartree–Fock, as is; evident by looking at the energy expression,. \[\begin{split}E_{\mathrm{KS}}; &= \sum_{i} \langle i | \hat h | i \rangle; + \frac 1 2 \sum_{i,j} [ii|jj] + E_{\mathrm{xc}} [\rho_\alpha, \rho_\beta] \\; &= D_{\mu\nu}^{\mathrm{T}}\left(T_{\mu\nu} +; V_{\mu\nu}\right) + \frac{1}{2} D_{\mu\nu}^{\mathrm{T}}; D_{\lambda\sigma}^{\mathrm{T}} (\mu\nu|\lambda\sigma) + E_{\mathrm{xc}} [\rho_\alpha, \rho_\beta]\end{split}\]; Here, \(T\) is the noninteracting quasiparticle kinetic energy operator,; \(V\) is the nucleus-electron attraction potential, \(D^{\mathrm{T}}\); is the total electron density matrix, and \(E_{\mathrm{xc}} [\rho_\alpha,; \rho_\beta]\) is the (potentially nonlocal) exchange, correlation, and residual; kinetic energy functional. The residual kinetic energy term is usually quite; small, and is often ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/dft-1.html:1582,energy,energy,1582,psi4manual/1.2.1/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/dft-1.html,13,['energy'],['energy']
Energy Efficiency," the value of an option. Before the function exits, this command is called on the option so that has_changed reflects whether the user (not the program) has touched the option.; ; C++ signature :; void revoke_global_option_changed(Ss); ; revoke_local_option_changed(...); revoke_local_option_changed( (str)arg1, (str)arg2) -> None :; Given a string of a keyword name *arg2* and a particular module *arg1*, sets the has_changed attribute in the module options scope to false. Used in python driver when a function sets the value of an option. Before the function exits, this command is called on the option so that has_changed reflects whether the user (not the program) has touched the option.; ; C++ signature :; void revoke_local_option_changed(Ss,Ss); ; run_gdma(...); run_gdma( (Wavefunction)arg1, (str)arg2) -> float :; Runs the GDMA code.; ; C++ signature :; d run_gdma(N5boost10shared_ptrIN3psi12WavefunctionEEE,Ss); ; sapt(...); sapt( (Wavefunction)arg1, (Wavefunction)arg2, (Wavefunction)arg3) -> float :; Runs the symmetry adapted perturbation theory code.; ; C++ signature :; d sapt(N5boost10shared_ptrIN3psi12WavefunctionEEE,N5boost10shared_ptrIN3psi12WavefunctionEEE,N5boost10shared_ptrIN3psi12WavefunctionEEE); ; scatter(...); scatter( (Molecule)arg1, (float)arg2, (list)arg3, (list)arg4, (list)arg5) -> None :; New Scatter function.; ; C++ signature :; void scatter(N5boost10shared_ptrIN3psi8MoleculeEEE,d,N5boost6python4listE,N5boost6python4listE,N5boost6python4listE); ; scf(...); scf( (Wavefunction)arg1, (object)arg2, (object)arg3) -> Wavefunction :; Runs the SCF code.; ; C++ signature :; N5boost10shared_ptrIN3psi12WavefunctionEEE scf(N5boost10shared_ptrIN3psi12WavefunctionEEE,P7_object,P7_object); ; scfgrad(...); scfgrad( (Wavefunction)arg1) -> Matrix :; Run scfgrad, which is a specialized DF-SCF gradient program.; ; C++ signature :; N5boost10shared_ptrIN3psi6MatrixEEE scfgrad(N5boost10shared_ptrIN3psi12WavefunctionEEE); ; scfhess(...); scfhess( (Wavefunction)arg1) -> Mat",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:693104,adapt,adapted,693104,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['adapt'],['adapted']
Energy Efficiency," the; \({\cal{O}}(o^2v^4)\) complexity of the original equations. Just as in; the familiar CCSD(T) method, the effects of connected triple excitations; may be included noniteratively to yield the QCISD(T) method. Both the; QCISD(T) and CCSD(T) methods are implemented for closed-shell references; in the FNOCC module. Many-body perturbation theory¶; QCI and CC methods are closely related to perturbation theory, and the; MP2, MP3, and MP4(SDQ) correlation energies can be obtained as a free; by-product of a CCSD or QCISD computation. The following is an; example of the results for a computation run with the call; energy('fno-qcisd') to energy():; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30QCISD iterations converged!. OS MP2 FNO correction: -0.000819116338; SS MP2 FNO correction: -0.000092278158; MP2 FNO correction: -0.000911394496. OS MP2 correlation energy: -0.166478414245; SS MP2 correlation energy: -0.056669079827; MP2 correlation energy: -0.223147494072; * MP2 total energy: -76.258836941658. OS MP2.5 correlation energy: -0.171225850256; SS MP2.5 correlation energy: -0.054028401038; MP2.5 correlation energy: -0.225254251294; * MP2.5 total energy: -76.260943698880. OS MP3 correlation energy: -0.175973286267; SS MP3 correlation energy: -0.051387722248; MP3 correlation energy: -0.227361008515; * MP3 total energy: -76.263050456101. OS MP4(SDQ) correlation energy: -0.180324322304; SS MP4(SDQ) correlation energy: -0.048798468084; MP4(SDQ) correlation energy: -0.230995119324; * MP4(SDQ) total energy: -76.266684566910. OS QCISD correlation energy: -0.181578117924; SS QCISD correlation energy: -0.049853548145; QCISD correlation energy: -0.231431666069; * QCISD total energy: -76.267121113654. The first set of energies printed corresponds to the second-order FNO; correction mentioned previously. Results for many-body perturbation; theory through partial fourth order are then provided.; The notation MP4(SDQ) indica",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/fnocc-1.html:5572,energy,energy,5572,psi4manual/1.1.0/fnocc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/fnocc-1.html,6,['energy'],['energy']
Energy Efficiency," the; analytic gradients are not yet available, one has to use numerical gradients to; perform the geometry optimizations. Minimal Input¶; Minimal input for the DCFT single-point computation looks like this:; molecule {; H; H 1 1.0; }. set basis 3-21G. energy('dcft'). The energy('dcft') call to energy() executes the DCFT module, which will first call the SCF module and perform the SCF computation with UHF reference to obtain the guess for the DCFT orbitals. After the SCF is converged, the program will perform the energy computation using the DC-06 method. By default, the two-step algorithm will be used for the solution of the equations. Note that while the default value for the option REFERENCE is RHF, this option is set to UHF before the DCFT module is executed. For the DC-06 method one can also request to perform the geometry optimization following the example below:; molecule {; H; H 1 1.0; }. set basis 3-21G. optimize('dcft'). The optimize('dcft') call will first perform all of the procedures; described above to obtain the DC-06 energy. After that the DC-06 analytic; gradients code will be executed to perform the solution of the DCFT response; equations, compute the analytic gradients of the DCFT energy and perform the; geometry optimization. Recommendations¶; Here is the list of the recommendations for the DCFT module:. For the computations of small systems (less than 150 basis; functions and high symmetry) the use of the default parameters is recommended,; including the choice of the two-step algorithm.; For large systems (more than 150 basis functions) the simultaneous algorithm; is preferred and can be significantly faster than two-step, as the result of; smaller number of the expensive steps. In addition,; significant savings can be achieved if one sets AO_BASIS option to; DISK together with simultaneous algorithm. It should be noted, however, that; the analytic gradients of the DC-06 method are currently not implemented for; AOBASIS DISK option.; In the ca",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/dcft-1.html:10869,energy,energy,10869,psi4manual/4.0b4/dcft-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/dcft-1.html,2,['energy'],['energy']
Energy Efficiency," the; analytic gradients are not yet available, one has to use numerical gradients to; perform the geometry optimizations. Minimal Input¶; Minimal input for the DCFT single-point computation looks like this:; molecule {; H; H 1 1.0; }. set basis 3-21G. energy('dcft'). The energy('dcft') call to energy() executes the DCFT module, which will first call the SCF module and perform the SCF computation with UHF reference to obtain the guess for the DCFT orbitals. After the SCF is converged, the program will perform the energy computation using the DC-06 method. By default, the two-step algorithm will be used for the solution of the equations. Note that while the default value for the option REFERENCE is RHF, this option is set to UHF before the DCFT module is executed. For the DC-06 method one can also request to perform the geometry optimization following the example below:; molecule {; H; H 1 1.0; }. set basis 3-21G. optimize('dcft'). The optimize('dcft') call will first perform all of the procedures; described above to obtain the DC-06 energy. After that the DC-06 analytic; gradients code will be executed to perform the solution of the DCFT response; equations, compute the analytic gradients of the DCFT energy and perform the; geometry optimization. Recommendations¶; Here is the list of the recommendations for the DCFT module:. For the computations of small systems (less than 150 basis; functions and high symmetry) the use of the default parameters is recommended,; including the choice of the two-step algorithm.; For large systems (more than 150 basis functions) the simultaneous algorithm; is preferred and can be significantly faster than two-step, as the result of; smaller number of the expensive steps. In addition,; significant savings can be achieved if one sets AO_BASIS option to; DISK together with simultaneous algorithm.; In the case when insufficient memory is available, set AO_BASIS option; to DISK. This will significantly reduce the memory requirements. Howeve",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/dcft-1.html:10808,energy,energy,10808,psi4manual/4.0b5/dcft-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/dcft-1.html,2,['energy'],['energy']
Energy Efficiency," the; database python files for available molecular systems. This; is the only portion of database input that is case sensitive;; choices for this keyword must match the database python file. :examples:. >>> # [1] Two-stage SCF calculation on short, equilibrium, and long helium dimer; >>> db('scf','RGC10',cast_up='sto-3g',subset=['HeHe-0.85','HeHe-1.0','HeHe-1.5'], tabulate=['scf total energy','natom']). >>> # [2] Counterpoise-corrected interaction energies for three complexes in S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('df-mp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish function to call; if not('db_func' in kwargs):; if ('func' in kwargs):; kwargs['db_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['db_func'] = energy; func = kwargs['db_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper database.' % (func.__name__)); if (func is cp):; raise ValidationError('Wrapper database is unhappy to be calling function \'%s\'. Use the cp keyword within database instead.' % (func.__name__)). # Define path and load module for requested database; sys.path.append('%sdatabases' % (PsiMod.Process.environment[""PSIDATADIR""])); sys.path.append",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:29130,energy,energy,29130,psi4manual/4.0b4/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html,2,['energy'],['energy']
Energy Efficiency," the; database python files for available molecular systems. This; is the only portion of database input that is case sensitive;; choices for this keyword must match the database python file. :examples:. >>> # [1] Two-stage SCF calculation on short, equilibrium, and long helium dimer; >>> db('scf','RGC10',cast_up='sto-3g',subset=['HeHe-0.85','HeHe-1.0','HeHe-1.5'], tabulate=['scf total energy','natom']). >>> # [2] Counterpoise-corrected interaction energies for three complexes in S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('df-mp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). """"""; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish function to call; if not('db_func' in kwargs):; if ('func' in kwargs):; kwargs['db_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['db_func'] = energy; func = kwargs['db_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper database.' % (func.__name__)); if (func is cp):; raise ValidationError('Wrapper database is unhappy to be calling function \'%s\'. Use the cp keyword within database instead.' % (func.__name__)). # Define path and load module for requested database; sys.path.append('%sdatabases' % (psi4.Process.environment[""PSIDATADIR""])); sys.path.a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:29757,energy,energy,29757,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,2,['energy'],['energy']
Energy Efficiency," the; database python files for available molecular systems. This; is the only portion of database input that is case sensitive;; choices for this keyword must match the database python file. Examples :. >>> # [1] Two-stage SCF calculation on short, equilibrium, and long helium dimer; >>> db('scf','RGC10',cast_up='sto-3g',subset=['HeHe-0.85','HeHe-1.0','HeHe-1.5'], tabulate=['scf total energy','natom']). >>> # [2] Counterpoise-corrected interaction energies for three complexes in S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('df-mp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). Output¶; At the beginning of a database job is printed a listing of the individual system; calculations which will be performed. The output snippet below is from the example job [1]; above. It shows each reagent required for the subset of database reactions requested.; Note that this is an un-counterpoise-corrected example, and the wrapper is smart enough; to compute only once the monomer whose energy will be subtracted from each of the three dimers.; RGC1-HeHe-0.85-dimer; RGC1-He-mono-unCP; RGC1-HeHe-1.0-dimer; RGC1-HeHe-1.5-dimer. At the end of the job, the Requested Energy table is printed that gives the total; energies for the requested model chemistry for each reagent and each reaction, as; well as the stoichoimetric weights by which the reagent energies are transfromed; into the reaction energy. In this case, the dimer is +1 and the monomer is -2,; indicating the the interaction energy is comp",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/db-1.html:5925,energy,energy,5925,psi4manual/4.0b4/db-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/db-1.html,8,['energy'],['energy']
Energy Efficiency," the; linear decay rate of the atomic density. MBIS VOLUME RATIOS¶; Per-atom ratio between the atomic volume (<R^3>) and the free-atomic; volume, unitless. MCSCF TOTAL ENERGY¶; Multiconfigurational self-consistent-field energy [E_h] in the course of; a configuration interaction computation. May be single-root or state-averaged. mtd DIPOLE¶; Dipole array [e a0] for the named method, (3,). mtd QUADRUPOLE¶; Redundant quadrupole array [e a0^2] for the named method, (3, 3). mtd OCTUPOLE¶; Redundant octupole array [e a0^3] for the named method, (3, 3, 3). mtd HEXADECAPOLE¶; Redundant hexadecapole array [e a0^4] for the named method, (3, 3, 3, 3). mtd 32-POLE¶; Redundant 32-pole array [e a0^5] for the named method, (3, 3, 3, 3, 3). mtd 64-POLE¶; Redundant 64-pole array [e a0^6] for the named method, (3, 3, 3, 3, 3, 3). mtd 128-POLE¶; Redundant 128-pole array [e a0^7] for the named method, (3, 3, 3, 3, 3, 3, 3). MP2 TOTAL ENERGY¶. MP2 CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the MP2 level of theory. MP2 TOTAL GRADIENT¶. The total electronic gradient [E_h/a0] of the MP2 level of theory, ({nat}, 3).¶. MP2 DIPOLE GRADIENT¶; The derivative of the MP2 level of theory dipole [E_h a0/u] = [(e a0/a0)^2/u] with respect to nuclear perturbations; as a degree-of-freedom by dipole component array, (3 * {nat}, 3). MP2 TOTAL HESSIAN¶; The total electronic second derivative [E_h/a0/a0] for the MP2 level of theory, (3 * {nat}, 3 * {nat}). MP2.5 TOTAL ENERGY¶. MP2.5 CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the MP2.5 level of theory. MP3 TOTAL ENERGY¶. MP3 CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the MP3 level of theory. MP4(T) CORRECTION ENERGY¶; The MP4 triples component [E_h]. Quantity is second right-hand term in; Eq. (2). MP4(SDQ) TOTAL ENERGY¶. MP4(SDQ) CORRELATION ENERGY¶; The total electronic energy [E_h] and corr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html:35900,energy,energy,35900,psi4manual/1.7.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html,8,['energy'],['energy']
Energy Efficiency," then be deduced. Using nullptr also makes the code more; readable, especially if auto is used consistently throughout.; Reference: Item 8 in [Effective Modern C++]. Prefer std::make_shared to direct use of new¶; Using std::make_shared:. Reduces code verbosity, especially when coupled with auto:; 1; 2; 3std::shared_ptr<Matrix> F = std::shared_ptr<Matrix>(new Matrix(""Fock matrix"", nso, nso)); // Type information written down 3 TIMES!!!; std::shared_ptr<Matrix> F = std::make_shared<Matrix>(""Fock matrix"", nso, nso); // So much typing...; auto F = std::make_shared<Matrix>(""Fock matrix"", nso, nso); // Much better!!!!. Ensures exception safety and prevents resource leaks. Improves efficiency:; 1; 2; 3; 4// Performs TWO allocations; std::shared_ptr<Matrix> F = std::shared_ptr<Matrix>(new Matrix(""Fock matrix"", nso, nso));; // Performs ONE allocation; auto F = std::make_shared<Matrix>(""Fock matrix"", nso, nso);. Reference: Item 21 in [Effective Modern C++]. Prefer auto to explicit type declarations¶; Using auto reduces and/or avoids:. Verbosity in variable declarations:; 1; 2std::shared_ptr<Matrix> F = std::make_shared<Matrix>(""Fock matrix"", nso, nso); // So much typing...; auto F = std::make_shared<Matrix>(""Fock matrix"", nso, nso); // Much better!. Problems with uninitialized variables. auto works like template type; deduction, hence the right-hand side of the declaration needs to have an; initializer:; 1; 2; 3int x1; // fine, but uninitialized :(; auto x2; // WON'T COMPILE!!!; auto x3 = 1; // fine and initialized. Problems with unintended type casts and type mismatches that are hard; to impossible to catch:; 1; 2; 3; 4std::vector<int> v;; // !!! The size of a vector is of type std::vector<int>::size_type and is compiler- AND architecture-DEPENDENT; unsigned sz = v.size(); // might not be correct on some compiler/machines; auto size = v.size(); // size is ALWAYS of the correct type. Reference: Items 2 and 5 in [Effective Modern C++]. table of contents. C++ Style; Prefer nullp",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/style_c-1.html:1482,reduce,reduces,1482,psi4manual/1.2.1/style_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/style_c-1.html,2,['reduce'],['reduces']
Energy Efficiency," theory, (3, 3). ACPF TOTAL ENERGY¶. ACPF CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the averaged coupled-pair functional level of theory. ADC ROOT 0 -> ROOT n EXCITATION ENERGY¶. TD-fctl ROOT 0 -> ROOT n EXCITATION ENERGY¶; The excitation energy [Eh} from ground state to root n.; DFT functional labeled if canonical. ADC ROOT 0 (IN h) -> ROOT n (IN i) EXCITATION ENERGY¶. TD-fctl ROOT 0 (IN h) -> ROOT n (IN i) EXCITATION ENERGY¶; The excitation energy [Eh] from the ground state (which is of irrep h); to root n within irrep i.; DFT functional labeled if canonical. ADC ROOT 0 (h) -> ROOT n (i) EXCITATION ENERGY¶. TD-fctl ROOT 0 (h) -> ROOT n (i) EXCITATION ENERGY¶; The excitation energy [Eh] from the ground state (which is of irrep h); to root n (which is of irrep i).; DFT functional labeled if canonical. ADC ROOT 0 -> ROOT n EXCITATION ENERGY - h TRANSITION¶. TD-fctl ROOT 0 -> ROOT n EXCITATION ENERGY - h TRANSITION¶; The excitation energy [Eh] from the ground state to root n, and the; transition is of irrep h.; DFT functional labeled if canonical. ADC ROOT 0 -> ROOT n ELECTRIC TRANSITION DIPOLE MOMENT (LEN)¶. TD-fctl ROOT 0 -> ROOT n ELECTRIC TRANSITION DIPOLE MOMENT (LEN)¶; The electric transition dipole moment [e a0] in length gauge, for the transition; from the ground state to root n.; DFT functional labeled if canonical. ADC ROOT 0 (IN h) -> ROOT n (IN i) ELECTRIC TRANSITION DIPOLE MOMENT (LEN)¶. TD-fctl ROOT 0 (IN h) -> ROOT n (IN i) ELECTRIC TRANSITION DIPOLE MOMENT (LEN)¶; The electric transition dipole moment [e a0] in length gauge, for the transition; from the ground state, which is of irrep h, to root n within irrep i.; DFT functional labeled if canonical. ADC ROOT 0 (h) -> ROOT n (i) ELECTRIC TRANSITION DIPOLE MOMENT (LEN)¶. TD-fctl ROOT 0 (h) -> ROOT n (i) ELECTRIC TRANSITION DIPOLE MOMENT (LEN)¶; The electric transition dipole moment [e a0] in length gauge, for the transition; from the ground state, wh",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/glossary_psivariables.html:2018,energy,energy,2018,psi4manual/1.6.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/glossary_psivariables.html,1,['energy'],['energy']
Energy Efficiency," theory, (3, 3). CISD TOTAL ENERGY¶. CISD CORRELATION ENERGY¶. CISDT TOTAL ENERGY¶. CISDT CORRELATION ENERGY¶. CISDTQ CORRELATION ENERGY¶. CISDTQ TOTAL ENERGY¶. CIn CORRELATION ENERGY¶. CIn TOTAL ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the labeled configuration interaction level of theory and root.; n is CI order for n > 4. CP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [Eh] considering only two-body interactions,; computed with counterpoise correction.; Related variable UNCP-CORRECTED 2-BODY INTERACTION ENERGY. \[E_{\text{IE}} = E_{dimer} - \sum_{monomer}^{n}{E_{monomer}^{\text{CP}}}\]. CURRENT CORRELATION ENERGY¶; The correlation energy [Eh] corresponding to the CURRENT ENERGY variable. CURRENT ENERGY¶; The total electronic energy [Eh] of the most recent stage of a; calculation (frequently overwritten). This is the quantity tracked by; the geometry optimizer. CURRENT REFERENCE ENERGY¶; The total electronic energy [Eh] of the reference stage corresponding to; the CURRENT ENERGY variable. CURRENT DIPOLE¶; The total dipole [e a0] of the most recent stage of a calculation (frequently overwritten), (3,). CURRENT GRADIENT¶; The total electronic gradient [E_h/a0] of the most recent stage of a; calculation (frequently overwritten). This is the quantity tracked by; the geometry optimizer, ({nat}, 3). CURRENT DIPOLE GRADIENT¶; The derivative of the dipole with respect to nuclear perturbations [E_h a0/u] = [(e a0/a0)^2/u]; as a degree-of-freedom by dipole component array, (3 * {nat}, 3). CURRENT HESSIAN¶; The total electronic Hessian [E_h/a0/a0] of the most recent stage of a; calculation, (3 * {nat}, 3 * {nat}). CUSTOM SCS-MP2 TOTAL ENERGY¶. CUSTOM SCS-MP2 CORRELATION ENERGY¶; Changeable quantities based on options.; The total electronic energy [Eh] and correlation energy component [Eh]; for the MP2-like method formed by any reweighting of MP2 DOUBLES ENERGY; for opposite-spin and same-spin contributions, with; an",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/glossary_psivariables.html:23612,energy,energy,23612,psi4manual/1.6.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/glossary_psivariables.html,1,['energy'],['energy']
Energy Efficiency," theory. LCC2 (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CC2 level of theory. LCCSD (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CCSD level of theory. MP2 TOTAL ENERGY¶. MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2 level of theory. MP2.5 TOTAL ENERGY¶. MP2.5 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2.5 level of theory. MP3 TOTAL ENERGY¶. MP3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP3 level of theory. MPn TOTAL ENERGY¶. MPn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Möller–Plesset perturbation theory level.; n is MP perturbation order. NUCLEAR REPULSION ENERGY¶; The nuclear repulsion energy contribution [H] to the total SCF energy.; Quantity in Eq. (2). ONE-ELECTRON ENERGY¶; The one-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (2). SAPT DISP ENERGY¶. SAPT ELST ENERGY¶. SAPT EXCH ENERGY¶. SAPT IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [H] for the the; requested SAPT level of theory. The sum of these four components yields; SAPT ENERGY. SAPT ENERGY¶; The total electronic interaction energy [H] for the requested SAPT; level of theory. SAPT SAPT0 ENERGY¶. SAPT SAPT2 ENERGY¶. SAPT SAPT2+ ENERGY¶. SAPT SAPT2+(3) ENERGY¶. SAPT SAPT2+3 ENERGY¶; The total electronic interaction energy [H] for the labeled SAPT level; of theory. SCF TOTAL ENERGY¶; The total electronic energy [H] of the SCF stage of the calculation.; The CORRELATION ENERGY variables from subsequent stages of a; calculation are often the corresponding TOTAL ENERGY variables; less this quantity. Constructed from Eq. (2). (2). TWO-ELECTRON ENERGY¶; The two-electron energy contribution [H] to the total",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/glossary_psivariables-1.html:7652,energy,energy,7652,psi4manual/4.0b2/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/glossary_psivariables-1.html,4,['energy'],['energy']
Energy Efficiency," theory. cc44; Test case for some of the PSI4 out-of-core codes. The code is given only 2.0 MB of memory, which is insufficient to hold either the A1 or B2 blocks of an ovvv quantity in-core, but is sufficient to hold at least two copies of an oovv quantity in-core. cc35; CC3(ROHF)/cc-pVDZ H2O geom from Olsen et al., JCP 104, 8007 (1996). omp2-4; SCS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. mp2_5-grad2; MP2.5 cc-pVDZ gradient for the NO radical. cc9a; ROHF-CCSD(T) cc-pVDZ energy for the state of the CN radical, with Z-matrix input. dfmp2-2; Density fitted MP2 energy of H2, using density fitted reference and automatic looping over cc-pVDZ and cc-pVTZ basis sets. Results are tabulated using the built in table functions by using the default options and by specifiying the format. omp2-grad1; OMP2 cc-pVDZ gradient for the H2O molecule. cc1; RHF-CCSD 6-31G** all-electron optimization of the H2O molecule. scf4; RHF cc-pVDZ energy for water, automatically scanning the symmetric stretch and bending coordinates using Python’s built-in loop mechanisms. The geometry is apecified using a Z-matrix with variables that are updated during the potential energy surface scan, and then the same procedure is performed using polar coordinates, converted to Cartesian coordinates. cisd-h2o-clpse; 6-31G** H2O Test CISD Energy Point with subspace collapse. omp2-3; OMP2 cc-pVDZ energy for the NO radical. cepa1; cc-pvdz H2O Test CEPA(1) Energy. cc24; Single point gradient of 1-2B1 state of H2O+ with EOM-CCSD. dftd3-grad; DF-BP86-D2 cc-pVDZ frozen core gradient of S22 HCN, calling Grimme’s dftd3 program for -D2 gradients. cc14; ROHF-CCSD/cc-pVDZ CH2 geometry optimization via analytic gradients. mp3-grad2; MP3 cc-pVDZ gradient for the NO radical. cc29; CCSD/cc-pVDZ optical rotation calculation (both gauges) on Cartesian H2O2. dfscf-bz2; Benzene Dimer DF-HF/cc-pVDZ. psithon1; Spectroscopic constants of H2, and the full ci cc-pVTZ level of theory. ocepa3; OCEPA cc-pVDZ energy with R",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_testsuite-1.html:19792,energy,energy,19792,psi4manual/4.0b4/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_testsuite-1.html,4,['energy'],['energy']
Energy Efficiency," this could conceivably eliminate the entire H0 block; the program should print warnings if this occurs. Type: integer; Default: 1000. H0_GUESS_SIZE (DETCI)¶DETCI (Expert) — size of H0 block for initial guess. Type: integer; Default: 1000. H_BOND_CONNECT (OPTKING)¶OPTKING — For now, this is a general maximum distance for the definition of H-bonds. Type: double; Default: 4.3. H_GUESS_EVERY (OPTKING)¶OPTKING — Re-estimate the Hessian at every step, i.e., ignore the currently stored Hessian. Type: boolean; Default: false. H_UPDATE_DEN_TOL (OPTKING)¶OPTKING — Denominator check for hessian update. Type: conv double; Default: 1e-7. HD_AVG (DETCI)¶DETCI (Expert) — How to average H diag energies over spin coupling sets. HD_EXACT uses the exact diagonal energies which results in expansion vectors which break spin symmetry. HD_KAVE averages the diagonal energies over a spin-coupling set yielding spin pure expansion vectors. ORB_ENER employs the sum of orbital energy approximation giving spin pure expansion vectors but usually doubles the number of Davidson iterations. EVANGELISTI uses the sums and differences of orbital energies with the SCF reference energy to produce spin pure expansion vectors. LEININGER approximation which subtracts the one-electron contribution from the orbital energies, multiplies by 0.5, and adds the one-electron contribution back in, producing spin pure expansion vectors and developed by Matt Leininger and works as well as EVANGELISTI. Type: string; Possible Values: EVANGELISTI, HD_EXACT, HD_KAVE, ORB_ENER, LEININGER, Z_KAVE; Default: EVANGELISTI. HD_OTF (DETCI)¶DETCI (Expert) — Do compute the diagonal elements of the Hamiltonian matrix on-the-fly? Otherwise, a diagonal element vector is written to a separate file on disk. Type: boolean; Default: true. HEFF4 (PSIMRCC)¶PSIMRCC — Do include the fourth-order contributions to the effective Hamiltonian?. Type: boolean; Default: true. HEFF_PRINT (PSIMRCC)¶PSIMRCC — Do print the effective Hamiltonian?. Type: ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:142449,energy,energy,142449,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,9,['energy'],['energy']
Energy Efficiency," this last; sup.allocate(); return sup. [docs]def build_b3lyp_superfunctional(name, npoints, deriv):. # Call this first; sup = PsiMod.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('B3LYP'); # Tab in, trailing newlines; sup.set_description(' B3LYP Hybrid-GGA Exchange-Correlation Functional\n'); # Tab in, trailing newlines; sup.set_citation(' P.J. Stephens et. al., J. Phys. Chem., 98, 11623-11627, 1994\n'). # Add member functionals; b3 = build_functional('B3_X'); b3.set_alpha(1.0); sup.add_x_functional(b3); lyp = build_functional('LYP_C'); lyp.set_alpha(0.81); vwn = build_functional('VWN3RPA_C'); vwn.set_alpha(0.19); sup.add_c_functional(vwn); sup.add_c_functional(lyp). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.2); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_b3lyp5_superfunctional(name, npoints, deriv):. # Call this first; sup = PsiMod.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('B3LYP5'); # Tab in, trailing newlines; sup.set_description(' B3LYP5 Hybrid-GGA Exchange-Correlation Functional\n'); # Tab in, trailing newlines; sup.set_citation(' P.J. Stephens et. al., J. Phys. Chem., 98, 11623-11627, 1994\n'). # Add member functionals; b3 = build_functional('B3_X'); b3.set_alpha(1.0); sup.add_x_functional(b3); lyp = build_functional('LYP_C'); lyp.set_alpha(0.81); vwn = build_functional('VWN5RPA_C'); vwn.set_alpha(0.19); sup.add_c_functional(lyp); sup.add_c_functional(vwn). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.2); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def bu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/functional.html:29208,allocate,allocate,29208,psi4manual/4.0b3/_modules/functional.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/functional.html,2,['allocate'],['allocate']
Energy Efficiency," this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; #@END LICENSE; #; from __future__ import absolute_import; from __future__ import print_function; import os; import re; import copy; import math; try:; from collections import OrderedDict; except ImportError:; from .oldpymodules import OrderedDict; from .periodictable import *; from .physconst import *; from .vecutil import *; from .exceptions import *; #from libmintscoordentry import *; from .libmintscoordentry import NumberValue, VariableValue, CartesianEntry, ZMatrixEntry; from .libmintspointgrp import SymmOps, similar, SymmetryOperation, PointGroup. #from libmintspointgrp import PointGroups; #print PointGroups. LINEAR_A_TOL = 1.0E-2 # When sin(a) is below this, we consider the angle to be linear; DEFAULT_SYM_TOL = 1.0E-8; FULL_PG_TOL = 1.0e-8; ZERO = 1.0E-14; NOISY_ZERO = 1.0E-8. [docs]class LibmintsMolecule(object):; """"""Class to store the elements, coordinates, fragmentation pattern,; charge, multiplicity of a molecule. Largely replicates psi4's libmints; Molecule class, developed by Justin M. Turney and Andy M. Simmonett; with incremental improvements by other psi4 developers. Major; differences from the C++ class are: no basisset handling, no symmetry,; no pubchem, no efp, no discarding dummies. This class translated so; that databases can function independently of psi4. >>> H2OH2O = qcdb.Molecule(\""\""\""; 0 1; O1 -1.551007 -0.114520 0.000000; H1 -1.934259 0.762503 0.000000; H2 -0.599677 0.040712 0.000000; --; 0 1; X 0.000000 0.000000 0.000000; O2 1.350625 0.111469 0.000000; H3 1.680398 -0.373741 -0.758561; H4 1.680398 -0.373741 0.758561; no_com; no_reorient; units angstrom; \""\""\""). >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'); """"""; FullPointGroupList = [""ATOM"", ""C_inf_v"", ""D_inf_h"", ""C1"", ""Cs"", ""Ci"", \; ""Cn"", ""Cnv"", ""Cnh"", ""Sn"", ""Dn"", ""Dnd"", ""Dnh"", ""Td"", ""Oh"", ""Ih""]. def __init__(self, psi4molstr=None):; """"""Initialize Mole",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:1878,charge,charge,1878,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,1,['charge'],['charge']
Energy Efficiency," this will be a large; and nonsensical value. db_name DATABASE ROOT-MEAN-SQUARE SIGNED DEVIATION¶; The rms deviation [kcal mol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. DFT FUNCTIONAL TOTAL ENERGY¶; The total electronic energy [H] for the underlying functional of the; requested DFT method, without any dispersion correction; the first four; terms in Eq. (4) or (1). Quantity; in Eqs. (4) and (1).; Unless the method includes a dispersion correction, this quantity is; equal to SCF TOTAL ENERGY. DFT TOTAL ENERGY¶; The total electronic energy [H] for the requested DFT method,; in Eq. (1). (1); Unless the method is a DFT double-hybrid, this quantity is equal to; SCF TOTAL ENERGY. If the method is neither a; double-hybrid, nor dispersion corrected, this quantity is equal to; DFT FUNCTIONAL TOTAL ENERGY. DFT XC ENERGY¶; The functional energy contribution [H] to the total SCF energy (DFT only).; Quantity in Eqs. (4) and (1). DISPERSION CORRECTION ENERGY¶; The dispersion correction [H] appended to an underlying functional; when a DFT-D method is requested. Quantity ; in Eqs. (4) and (1). DOUBLE-HYBRID CORRECTION ENERGY¶; The scaled MP2 correlation energy correction [H] appended to an; underlying functional when a DH-DFT method is requested.; Quantity in Eq. (1). FCI TOTAL ENERGY¶. FCI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the full configuration interaction level of theory. HF TOTAL ENERGY¶; The total electronic energy [H] for the Hartree–Fock method, without; any dispersion correction; the first three (or four, since; ) terms in Eq. (4). Quantity ; in Eq. (4). LCC2 (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CC2 level of theory. LCCSD (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CCSD level of theory. MP2 TOTAL ENERGY¶. MP2 CORR",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/glossary_psivariables-1.html:11003,energy,energy,11003,psi4manual/1.0.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/glossary_psivariables-1.html,12,['energy'],['energy']
Energy Efficiency," tight; # tolerance to force canonical; basis aug-cc-pv5z # This diffuse basis will have; # small-ish eigenvalues for even H2O; print 3; }. energy('scf'). Output:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18==> Pre-Iterations <==. -------------------------------------------------------; Irrep Nso Nmo Nalpha Nbeta Ndocc Nsocc; -------------------------------------------------------; A 145 145 0 0 0 0; B 142 142 0 0 0 0; -------------------------------------------------------; Total 287 287 5 5 5 0; -------------------------------------------------------. ... Minimum eigenvalue in the overlap matrix is 1.6888063568E-05.; Using Canonical Orthogonalization with cutoff of 1.0000000000E-04.; Irrep 0, 1 of 145 possible MOs eliminated.; Irrep 1, 2 of 142 possible MOs eliminated.; Overall, 3 of 287 possible MOs eliminated. In this example, there are 287 AO basis functions after spherical harmonics are; applied. These are used to produce 287 symmetry adapted USOs, 145 of which are; assigned to irrep A, and 142 of which are assigned to irrep B. Within irrep A,; 144 OSOs fall above the eigenvalue cutoff, and within irrep B 140 OSOs fall; above the eigenvalue cutoff. In total, 284 molecular orbitals are chosen from; 287 AOs/USOs. Initial Guess¶; In each step of the SCF procedure, a new Fock or Kohn–Sham potential is built; according to the previous density, following which the potential is diagonalized; to produce new molecular orbitals, from which a new density is computed. This; procedure is continued until either convergence is reached or a preset maximum; number of iterations is exceeded. Convergence is determined by both change in; energy and root-mean-square change in density matrix values, which must be below; the user-specified E_CONVERGENCE and D_CONVERGENCE, respectively.; The maximum number of iterations is specified by the MAXITER option. It; should be noted that SCF is a chaotic process, and, as such, often requires; careful selection of initial or",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/scf-1.html:14816,adapt,adapted,14816,psi4manual/1.1.0/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/scf-1.html,6,['adapt'],['adapted']
Energy Efficiency," time each cc diagram?. Type: boolean; Default: false. CC_UPDATE_EPS (DETCI); DETCI (Expert) — Do update T amplitudes with orbital eigenvalues? (Usually would do this). Not doing this is experimental. Type: boolean; Default: true. CC_VAL_EX_LEVEL (DETCI); DETCI — The CC valence excitation level. Type: integer; Default: 0. CC_VARIATIONAL (DETCI); DETCI (Expert) — Do use variational energy expression in CC computation? Experimental. Type: boolean; Default: false. CC_VECS_READ (DETCI); DETCI — Do import a CC vector from disk?. Type: boolean; Default: false. CC_VECS_WRITE (DETCI); DETCI — Do export a CC vector to disk?. Type: boolean; Default: false. CCD_E_CONVERGENCE (SAPT); SAPT — E converge value for CCD. Type: conv double; Default: 1e-8. CCD_MAXITER (SAPT); SAPT — Max CCD iterations. Type: integer; Default: 50. CCD_T_CONVERGENCE (SAPT); SAPT — Convergence tolerance for CCD amplitudes. Type: conv double; Default: 1e-8. CCL_ENERGY (OCC); OCC — Do compute CC Lambda energy? In order to this option to be valid one should use “TPDM_ABCD_TYPE = COMPUTE” option. Type: boolean; Default: false. CEPA_LEVEL (FNOCC); FNOCC (Expert) — Which coupled-pair method is called? This parameter is used internally by the python driver. Changing its value won’t have any effect on the procedure. Type: string; Default: CEPA(0). CEPA_NO_SINGLES (FNOCC); FNOCC — Flag to exclude singly excited configurations from a coupled-pair computation. Type: boolean; Default: false. CEPA_OS_SCALE (OCC); OCC — CEPA opposite-spin scaling value from SCS-CCSD. Type: double; Default: 1.27. CEPA_SOS_SCALE (OCC); OCC — CEPA Spin-opposite scaling (SOS) value. Type: double; Default: 1.3. CEPA_SS_SCALE (OCC); OCC — CEPA same-spin scaling value from SCS-CCSD. Type: double; Default: 1.13. CEPA_TYPE (OCC); OCC — CEPA type such as CEPA0, CEPA1 etc. currently we have only CEPA0. Type: string; Possible Values: CEPA0; Default: CEPA0. CHECK_C_ORTHONORM (TRANSQT); TRANSQT — Do check MO orthogonality condition?. Type: boolean; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_glossary_options_c-1.html:15808,energy,energy,15808,psi4manual/4.0b4/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_glossary_options_c-1.html,4,['energy'],['energy']
Energy Efficiency," time, the dispersion interaction should be smaller because the perpendicular geometry does not allow much overlap between the monomers. Hence, the SAPT analysis helps clarify (and quantify) our physical understanding about the; interaction between the two monomers. V. Potential Surface Scans and Counterpoise Correction Made Easy¶; Finally, let’s consider an example which highlights the advantages of being able to interact with Psi4 directly with Python.; Suppose you want to do a limited potential energy surface scan, such as computing the interaction energy between two neon atoms at various interatomic distances. One simple but unappealing way to do this is to generate separate geometries for each distance to be studied. Instead, we can leverage Python loops and string formatting to make our lives simpler. Additionally, let’s suppose you want to do counterpoise (CP) correction to compute interaction energies. Counterpoise correction involves; computing the dimer energy and then subtracting out the energies of the two monomers, each evaluated in the dimer basis. Again, each of these computations could be run in a separate input file, but because counterpoise correction is a fairly standard procedure for intermolecular interactions, Psi4 knows about it and has a built-in routine to perform counterpoise correction. It only needs to know what method you want to do the couterpoise correction on (here, let’s consider CCSD(T)), and it needs; to know what’s monomer A and what’s monomer B. This last issue of specifying the monomers separately was already dealt with in the previous SAPT example, where we saw that two dashes in the psi4.geometry() string can be used to separate monomers.; So, we’re going to do counterpoise-corrected CCSD(T) energies for Ne\(_2\) at a series of different interatomic distances. And let’s print out a table of the interatomic distances we’ve considered, and the CP-corrected CCSD(T) interaction energies (in kcal/mol) at each geometry:. [9]:. #! Exa",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psiapi-1.html:17659,energy,energy,17659,psi4manual/1.3.2/psiapi-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psiapi-1.html,11,['energy'],['energy']
Energy Efficiency," title='H3O+ SCF'). """"""; oe = core.OEProp(wfn); if 'title' in kwargs:; oe.set_title(kwargs['title']); for prop in args:; oe.add(prop.upper()). # If we're doing MBIS, we want the free-atom volumes; # in order to compute volume ratios,; # but only if we're calling oeprop as the whole molecule; free_atom = kwargs.get('free_atom',False); if ""MBIS_VOLUME_RATIOS"" in prop.upper() and not free_atom:; core.print_out("" Computing free-atom volumes\n""); free_atom_volumes(wfn). oe.compute(). [docs]; def cubeprop(wfn: core.Wavefunction, **kwargs):; """"""Evaluate properties on a grid and generate cube files. .. versionadded:: 0.5; *wfn* parameter passed explicitly. :returns: None. :param wfn: set of molecule, basis, orbitals from which to generate cube files. :examples:. >>> # [1] Cube files for all orbitals; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> cubeprop(wfn). >>> # [2] Cube files for density (alpha, beta, total, spin) and four orbitals; >>> # (two alpha, two beta); >>> set cubeprop_tasks ['orbitals', 'density']; >>> set cubeprop_orbitals [5, 6, -5, -6]; >>> E, wfn = energy('scf', return_wfn=True); >>> cubeprop(wfn). """"""; # By default compute the orbitals; if not core.has_global_option_changed('CUBEPROP_TASKS'):; core.set_global_option('CUBEPROP_TASKS', ['ORBITALS']). cp = core.CubeProperties(wfn); cp.compute_properties(). [docs]; def set_memory(inputval: Union[str, int, float], execute: bool = True, quiet: bool = False) -> int:; """"""Reset the total memory allocation. Parameters; ----------; inputval; Memory value. An Integer or float is taken literally as bytes to be set.; A string is taken as a unit-containing value (e.g., 30 mb), which is; case-insensitive.; execute; When False, interpret *inputval* without setting in Psi4 core.; quiet; When True, do not print to the output file. Returns; -------; int; Number of bytes of memory set. Raises; ------; ValidationError; When <500MiB or disallowed type or misformatted. Examples; --------. >>> # [1] Passing absolute number ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/_modules/psi4/driver/p4util/util.html:3126,energy,energy,3126,psi4manual/master/_modules/psi4/driver/p4util/util.html,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/p4util/util.html,1,['energy'],['energy']
Energy Efficiency," title='H3O+ SCF'). """"""; oe = core.OEProp(wfn); if 'title' in kwargs:; oe.set_title(kwargs['title']); for prop in args:; oe.add(prop.upper()). # If we're doing MBIS, we want the free-atom volumes; # in order to compute volume ratios,; # but only if we're calling oeprop as the whole molecule; free_atom = kwargs.get('free_atom',False); if ""MBIS_VOLUME_RATIOS"" in prop.upper() and not free_atom:; core.print_out("" Computing free-atom volumes\n""); free_atom_volumes(wfn). oe.compute(). [docs]; def cubeprop(wfn: core.Wavefunction, **kwargs):; """"""Evaluate properties on a grid and generate cube files. .. versionadded:: 0.5; *wfn* parameter passed explicitly. :returns: None. :param wfn: set of molecule, basis, orbitals from which to generate cube files. :examples:. >>> # [1] Cube files for all orbitals; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> cubeprop(wfn). >>> # [2] Cube files for density (alpha, beta, total, spin) and four orbitals; >>> # (two alpha, two beta); >>> set cubeprop_tasks ['orbitals', 'density']; >>> set cubeprop_orbitals [5, 6, -5, -6]; >>> E, wfn = energy('scf', return_wfn=True); >>> cubeprop(wfn). """"""; # By default compute the orbitals; if not core.has_global_option_changed('CUBEPROP_TASKS'):; core.set_global_option('CUBEPROP_TASKS', ['ORBITALS']). if ((core.get_global_option('INTEGRAL_PACKAGE') == 'ERD') and ('ESP' in core.get_global_option('CUBEPROP_TASKS'))):; raise ValidationError('INTEGRAL_PACKAGE ERD does not play nicely with electrostatic potential, so stopping.'). cp = core.CubeProperties(wfn); cp.compute_properties(). [docs]; def set_memory(inputval: Union[str, int, float], execute: bool = True, quiet: bool = False) -> int:; """"""Reset the total memory allocation. Parameters; ----------; inputval; Memory value. An Integer or float is taken literally as bytes to be set.; A string is taken as a unit-containing value (e.g., 30 mb), which is; case-insensitive.; execute; When False, interpret *inputval* without setting in Psi4 core.; quiet; When T",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/util.html:3119,energy,energy,3119,psi4manual/1.9.x/_modules/psi4/driver/p4util/util.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/util.html,1,['energy'],['energy']
Energy Efficiency," to NONABELIAN (=0), maximum advantage will be taken of symmetry and the full set of cubic force constants will be generated from a skeleton set by application of the totally symmetric projection operator. If set to ABELIAN (=1), only the operations of the abelian subgroup will be exploited. Note: It is important to point out that the symmetrization currently works only for cubic constants. Therefore, if you require quartic force constants (for frequency calculations), you must use the ABELIAN option. Moreover, the latter work for only asymmetric tops and linear molecules. Type: string; Possible Values: ABELIAN, NONABELIAN; Default: ABELIAN. CFOUR_AO_LADDERS¶. Can be used to control the algorithm used by CFOUR when terms involving molecular orbital integrals are calculated in the atomic orbital basis (see CFOUR_ABCDTYPE . MULTIPASS (= 0) uses an approach where the AO integral file is read a number of times in order to ensure maximal vectorization and is usually the optimal strategy on supercomputers; SINGLEPASS (= 1) determines the contributions with only a single pass through the AO integrals, but at the cost of significantly reduced vectorization. In general, however, SINGLEPASS is definitely preferable on workstations with RISC architectures. (Default : MULTIPASS on all 64-bit machines (e.g., CRAY-YMP) ; SINGLEPASS on all 32-bit machines (e.g., IBM-RS6000, HP-735, SGI-Indigo, DEC alphastations)). SPARSE_AO (=2) uses a sparse matrix algorithm which first rearranges the integral matrix in order to get “well-occupied” and “very sparse” blocks. “Well-occupied” blocks will be multiplied by matrix multiplication while in “very sparse” blocks only the non-zero elements are considered. The computational time is further reduced using symmetrized and anti-symmetrized integral and amplitude matrices in the multiplication. Substantial saving is assumed if SPARSE_AO (=2) is used. Type: string; Possible Values: MULTIPASS, SINGLEPASS; Default: SINGLEPASS. CFOUR_AV_SCF¶. Experim",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__cfour-1.html:5620,reduce,reduced,5620,psi4manual/1.0.0/autodir_options_c/module__cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__cfour-1.html,2,['reduce'],['reduced']
Energy Efficiency," to all atoms with symbol (e.g., H) arg0. set_comment(self, arg0); Sets molecule comment. set_connectivity(self, arg0, int, float]]); Sets molecule connectivity. set_full_geometry(self, arg0); Sets the geometry, given a (Natom X 3) matrix arg0 of coordinates (in Bohr) (including dummies. set_geometry(self, arg0); Sets the geometry, given a (Natom X 3) matrix arg0 of coordinates [a0] (excluding dummies). set_ghost_fragment(self, arg0); Sets the specified fragment arg0 to be Ghost. set_ghost_fragments(self, arg0); Sets the specified list arg0 of fragments to be Ghost. set_input_units_to_au(self, arg0); Sets unit conversion to [a0] for geometry. set_mass(self, atom, mass); Sets mass of atom (0-indexed) to mass (good for isotopic substitutions). set_molecular_charge(self, arg0); Change the overall molecular charge. set_multiplicity(self, arg0); Change the multiplicity (defined as 2S + 1). set_name(self, arg0); Sets molecule name. set_nuclear_charge(self, arg0, arg1); Set the nuclear charge of the given atom arg0 to the value arg1 (primarily for ECP). set_point_group(self, arg0); Sets the molecular point group to the point group object arg0. set_provenance(self, arg0, str]); Sets molecule provenance. set_units(self, arg0); Sets units (Angstrom or Bohr) used to define the geometry. set_variable(self, arg0, arg1); Sets the value arg1 to the variable arg0 in the list of structure variables, then calls update_geometry(). symbol(self, atom); Gets the cleaned up label of atom (C2 => C, H4 = H) (0-indexed without dummies). symmetrize(self, arg0); Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry. symmetry_from_input(self); Returns the symmetry specified in the input. to_arrays([dummy, ghost_as_dummy]); Exports coordinate info into NumPy arrays. to_dict([force_c1, force_units, np_out]); Serializes instance into Molecule dictionary. to_schema(dtype[, units]); Serializes instance into dictionary according to sc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.molecule.html:9310,charge,charge,9310,psi4manual/1.3.2/api/psi4.core.molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.molecule.html,2,['charge'],['charge']
Energy Efficiency," to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or “alias” or; “formal” to one.; param_tweaks (list or dict, optional) – Values for the same keys as dashcoeff[dashlevel][‘default’]; (and same order if list) used to override any or all values; initialized by name_hint. Extra parameters will error.; engine (str, optional) – Override which code computes dispersion. See above for allowed; values. Really only relevant for -D2, which can be computed by; libdisp or dftd3. Methods Summary. compute_energy(molecule); Compute dispersion energy based on engine, dispersion level, and parameters in self. compute_gradient(molecule); Compute dispersion gradient based on engine, dispersion level, and parameters in self. compute_hessian(molecule); Compute dispersion Hessian based on engine, dispersion level, and parameters in self. print_out(); Format dispersion parameters of self for output file. Methods Documentation. compute_energy(molecule)[source]¶; Compute dispersion energy based on engine, dispersion level, and parameters in self. Parameters:molecule (psi4.core.Molecule) – System for which to compute empirical dispersion correction. Returns:Dispersion energy [Eh]. Return type:float. Notes. DISPERSION CORRECTION ENERGY; Disp always set. Overridden in SCF finalization, but that only changes for “-3C” methods.; self.fctldash + DISPERSION CORRECTION ENERGY; Set if fctldash nonempty. compute_gradient(molecule)[source]¶; Compute dispersion gradient based on engine, dispersion level, and parameters in self. Parameters:molecule (psi4.core.Molecule) – System for which to compute empirical dispersion correction. Returns:(nat, 3) dispersion gradient [Eh/a0]. Return type:psi4.core.Matrix. compute_hessian(molecule)[source]¶; Compute dispersion Hessian based on engine, dispersion level, and parameters in self.; Uses finite difference, as no dispersion engine has analytic second derivatives. Parameters:molecule (psi4.core.Molecule) – System for which to compute empir",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.driver.empiricaldispersion.html:3603,energy,energy,3603,psi4manual/1.3.2/api/psi4.driver.empiricaldispersion.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.driver.empiricaldispersion.html,1,['energy'],['energy']
Energy Efficiency," to be gained from loosening it, especially for higher-order SAPT. Type: conv double; Default: 1.0e-12. MAXITER¶. Maxmum number of CPHF iterations. Type: integer; Default: 50. MAX_CCD_DIISVECS¶. Maximum number of vectors used in CCD-DIIS. Type: integer; Default: 10. MIN_CCD_DIISVECS¶. Minimumnumber of vectors used in CCD-DIIS. Type: integer; Default: 4. NAT_ORBS¶. Do natural orbitals to speed up evaluation of the triples contribution to dispersion by truncating the virtual orbital space? Recommended true for all SAPT computations. Type: boolean; Default: false. NAT_ORBS_T2¶. Do use MP2 natural orbital approximations for the block of two-electron integrals in the evaluation of second-order T2 amplitudes? This approximation is promising for accuracy and computational savings, but it has not been rigorously tested. Type: boolean; Default: false. NO_RESPONSE¶. Don’t solve the CPHF equations? Evaluate and instead of their response-including coupterparts. Only turn on this option if the induction energy is not going to be used. Type: boolean; Default: false. OCC_TOLERANCE¶. Minimum occupation (eigenvalues of the MP2 OPDM) below which virtual natural orbitals are discarded for evaluating the triples contribution to dispersion. Type: conv double; Default: 1.0e-6. PRINT¶. The amount of information to print to the output file for the sapt module. For 0, only the header and final results are printed. For 1, (recommended for large calculations) some intermediate quantities are also printed. Type: integer; Default: 1. SAPT_LEVEL¶. The level of theory for SAPT. Type: string; Possible Values: SAPT0, SAPT2, SAPT2+, SAPT2+3; Default: SAPT0. SAPT_MEM_CHECK¶. Do force SAPT2 and higher to die if it thinks there isn’t enough memory? Turning this off is ill-advised. Type: boolean; Default: true. SAPT_MEM_SAFETY¶. Memory safety. Type: double; Default: 0.9. SAPT_OS_SCALE¶. The scale factor used for opposite-spin pairs in SCS computations. SS/OS decomposition performed for and terms. Type: ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodir_options_c/module__sapt-1.html:3492,energy,energy,3492,psi4manual/4.0b4/autodir_options_c/module__sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodir_options_c/module__sapt-1.html,2,['energy'],['energy']
Energy Efficiency," to be projected out of the displacements. project_rotations : bool; Whether rotations are to be projected out of the displacements. molecule : dict; The reference molecule, in MolSSI schema. See; https://molssi-qc-schema.readthedocs.io/en/latest/auto_topology.html. displacements : dict; A dictionary mapping labels specifying the displacement to data about; the geometry. Labels are of the form ""A: a, B: b"" where A and B index the; basis vector in displacement space and A < B, and a and b index the step; magnitude. For instance, ""0: 1, 1: -1"" specifies displacing +1 in; displacement vector 0 and -1 in displacement vector 1. ""1: -1, 0: 1"" is; forbidden for breaking ordering. Generalizes to arbitrary numbers of; simultaneous displacements in the obvious way. The possible geometry data is as follows:. geometry: list of floats; (3 * nat) The molecular geometry as a flat list in bohr. All coordinates; are given for one atom before proceeding to the next atom. energy: int; The last computed electronic energy at the geometry. gradient: list of floats; (3 * nat) The last computed gradient of energy with respect to changes in; geometry at the geometry, as a flat list. All coordinates are given for; displacing one atom before proceeding to the next atom. reference : dict; A geometry data dict, as described above, for the reference geometry.; """""". msg_dict = {; ""1_0"":; ""energies to determine gradients"",; ""2_1"":; ""gradients to determine vibrational frequencies and \n""; "" normal modes. Resulting frequencies are only valid at stationary points"",; ""2_0"":; ""gradients to determine vibrational frequencies and \n""; "" normal modes. Resulting frequencies are only valid at stationary points""; }. try:; print_msg = msg_dict[mode]; except KeyError:; raise ValidationError(""FINDIF: Mode {} not recognized."".format(mode)). def init_string(data):; return f"""""" Using finite-differences of {print_msg}.; Generating geometries for use with {data[""stencil_size""]}-point formula.; Displacement size will ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html:15516,energy,energy,15516,psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html,8,['energy'],['energy']
Energy Efficiency," to be used in diagonalizing the Hamiltonian. The valid options are: RSP, to form the entire H matrix and diagonalize using libciomr to obtain all eigenvalues (n.b. requires HUGE memory); OLSEN, to use Olsen’s preconditioned inverse subspace method (1990); MITRUSHENKOV, to use a 2x2 Olsen/Davidson method; and DAVIDSON (or SEM) to use Liu’s Simultaneous Expansion Method, which is identical to the Davidson method if only one root is to be found. There also exists a SEM debugging mode, SEMTEST. The SEM method is the most robust, but it also requires CI vectors on disk, where is the maximum number of iterations and is the number of roots. Type: string; Possible Values: RSP, OLSEN, MITRUSHENKOV, DAVIDSON, SEM, SEMTEST; Default: SEM. LSE¶. Do use least-squares extrapolation in iterative solution of CI vector?. Type: boolean; Default: false. LSE_COLLAPSE¶. Number of iterations between least-squares extrapolations. Type: integer; Default: 3. LSE_TOLERANCE¶. Minimum converged energy for least-squares extrapolation to be performed. Type: conv double; Default: 3. PRECONDITIONER¶. This specifies the type of preconditioner to use in the selected diagonalization method. The valid options are: DAVIDSON which approximates the Hamiltonian matrix by the diagonal elements; H0BLOCK_INV which uses an exact Hamiltonian of H0_BLOCKSIZE and explicitly inverts it; GEN_DAVIDSON which does a spectral decomposition of H0BLOCK; ITER_INV using an iterative approach to obtain the correction vector of H0BLOCK. The H0BLOCK_INV, GEN_DAVIDSON, and ITER_INV approaches are all formally equivalent but the ITER_INV is less computationally expensive. Default is DAVIDSON. Type: string; Possible Values: LANCZOS, DAVIDSON, GEN_DAVIDSON, H0BLOCK, H0BLOCK_INV, ITER_INV, H0BLOCK_COUPLING, EVANGELISTI; Default: DAVIDSON. UPDATE¶. The update or correction vector formula, either DAVIDSON (default) or OLSEN. Type: string; Possible Values: DAVIDSON, OLSEN; Default: DAVIDSON. Density Matrices¶. DIPMOM¶. Do compute th",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodir_options_c/module__detci-1.html:5346,energy,energy,5346,psi4manual/4.0b2/autodir_options_c/module__detci-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodir_options_c/module__detci-1.html,10,['energy'],['energy']
Energy Efficiency," to checkpoint?. Type: boolean; Default: true. FRAC_START (SCF); SCF — The iteration to start fractionally occupying orbitals (or 0 for no fractional occupation). Type: integer; Default: 0. FRAC_VAL (SCF); SCF — The occupations of the orbital indices specified above (\(0.0\ge occ \ge 1.0\)). Type: array; Default: No Default. FRAG_MODE (OPTKING); OPTKING — For multi-fragment molecules, treat as single bonded molecule or via interfragment coordinates. A primary difference is that in MULTI mode, the interfragment coordinates are not redundant. Type: string; Possible Values: SINGLE, MULTI; Default: SINGLE. FRAG_REF_ATOMS (OPTKING); OPTKING — Which atoms define the reference points for interfragment coordinates?. Type: array; Default: No Default. FREEZE_CORE (GLOBALS); GLOBALS — Specifies how many core orbitals to freeze in correlated computations. TRUE or 1 will default to freezing the previous noble gas shell on each atom. In case of positive charges on fragments, an additional shell may be unfrozen, to ensure there are valence electrons in each fragment. With FALSE or 0, no electrons are frozen (with the exception of electrons treated by an ECP). With -1, -2, and -3, the user might request strict freezing of the previous first/second/third noble gas shell on every atom. In this case, when there are no valence electrons, the code raises an exception. More precise control over the number of frozen orbitals can be attained by using the keywords NUM_FROZEN_DOCC (gives the total number of orbitals to freeze, program picks the lowest-energy orbitals) or FROZEN_DOCC (gives the number of orbitals to freeze per irreducible representation). Type: string; Possible Values: FALSE, TRUE, 1, 0, -1, -2, -3; Default: FALSE. FREEZE_CORE (SAPT); SAPT — The scope of core orbitals to freeze in evaluation of SAPT \(E_{disp}^{(20)}\) and \(E_{exch-disp}^{(20)}\) terms. Recommended true for all SAPT computations. Type: string; Possible Values: FALSE, TRUE; Default: FALSE. FREEZE_INTERFRAG (OP",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodoc_glossary_options_c-1.html:130937,charge,charges,130937,psi4manual/1.3.2/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodoc_glossary_options_c-1.html,2,['charge'],['charges']
Energy Efficiency," to decontracted orbital basis. Type: string; Default: No Default. BENCH¶. Some codes (DFT) can dump benchmarking data to separate output files. Type: integer; Default: 0. BRIANQC_ENABLE¶. Whether to enable using the BrianQC GPU module. Type: boolean; Default: false. CC_TYPE¶. Algorithm to use for CC or CEPA computation (e.g., CCD, CCSD(T), CEPA(3), ACPF, REMP). See Cross-module Redundancies for details. Type: string; Possible Values: DF, CONV, CD; Default: CONV. CI_TYPE¶. Algorithm to use for CI computation (e.g., CID or CISD). See Cross-module Redundancies for details. Type: string; Possible Values: CONV; Default: CONV. CUBEPROP_BASIS_FUNCTIONS¶. List of basis function indices for which cube files are generated (1-based). All basis functions computed if empty. Type: array; Default: No Default. CUBEPROP_FILEPATH¶. Directory to which to write cube files. Default is the input file directory. Type: string; Default: No Default. CUBEPROP_ISOCONTOUR_THRESHOLD¶. Fraction of density captured by adaptive isocontour values. Type: double; Default: 0.85. CUBEPROP_ORBITALS¶. List of orbital indices for which cube files are generated (1-based, \(+\) for alpha, \(-\) for beta). All orbitals computed if empty. Type: array; Default: No Default. CUBEPROP_TASKS¶. Properties to compute. Valid tasks include: DENSITY - Da, Db, Dt, Ds; ESP - Dt, ESP; ORBITALS - Psi_a_N, Psi_b_N; BASIS_FUNCTIONS - Phi_N; LOL - LOLa, LOLb; ELF - ELFa, ELFb; FRONTIER_ORBITALS - Psi_a_N_HOMO + Psi_a_N_LUMO; DUAL_DESCRIPTOR - DUAL_N_HOMO-M_LUMO. Type: array; Default: No Default. CUBIC_GRID_OVERAGE¶. CubicScalarGrid spatial extent in bohr [O_X, O_Y, O_Z]. Defaults to 4.0 bohr each. Type: array; Default: No Default. CUBIC_GRID_SPACING¶. CubicScalarGrid grid spacing in bohr [D_X, D_Y, D_Z]. Defaults to 0.2 bohr each. Type: array; Default: No Default. DDX¶. DDX boolean for ddx module. Type: boolean; Default: false. DF_BASIS_CC¶. The density fitting basis to use in coupled cluster computations. Type: string; Possi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodir_options_c/module__globals.html:1444,adapt,adaptive,1444,psi4manual/1.7.x/autodir_options_c/module__globals.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodir_options_c/module__globals.html,4,['adapt'],['adaptive']
Energy Efficiency," to dispersion by truncating the virtual orbital space? Recommended true for all SAPT computations. Type: boolean; Default: true. NAT_ORBS_V4¶. Do use MP2 natural orbital approximations for the \(v^4\) block of two-electron integrals in the evaluation of CCD T2 amplitudes? Recommended true for all SAPT computations. Type: boolean; Default: true. OCC_TOLERANCE¶. Minimum occupation (eigenvalues of the MP2 OPDM) below which virtual natural orbitals are discarded for in each of the above three truncations. Type: conv double; Default: 1.0e-6. Charge-Transfer in SAPT¶; It is possible to obtain the stabilization energy of a complex due to; charge-transfer effects from a SAPT computation. The charge-transfer energy; can be computed with the SAPT module as described by Stone; and Misquitta [Misquitta:2009:201].; Charge-transfer energies can be obtained from the following calls to the; energy function.; energy('sapt0-ct'); energy('sapt2-ct'); energy('sapt2+-ct'); energy('sapt2+(3)-ct'); energy('sapt2+3-ct'); energy('sapt2+(ccd)-ct'); energy('sapt2+(3)(ccd)-ct'); energy('sapt2+3(ccd)-ct'). For now, charge transfer computations are not available with open-shell SAPT0.; A SAPT charge-transfer analysis will perform 5 HF computations: the dimer; in the dimer basis, monomer A in the dimer basis, monomer B in the dimer; basis, monomer A in the monomer A basis, and monomer B in the monomer B; basis. Next, it performs two SAPT computations, one in the dimer basis and; one in the monomer basis. Finally, it will print a summary of the; charge-transfer results:; SAPT Charge Transfer Analysis; ------------------------------------------------------------------------------------------------; SAPT Induction (Dimer Basis) -2.0970 [mEh] -1.3159 [kcal/mol] -5.5057 [kJ/mol]; SAPT Induction (Monomer Basis) -1.1396 [mEh] -0.7151 [kcal/mol] -2.9920 [kJ/mol]; SAPT Charge Transfer -0.9574 [mEh] -0.6008 [kcal/mol] -2.5137 [kJ/mol]. These results are for the water dimer geometry shown above computed wi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/sapt-1.html:30618,energy,energy,30618,psi4manual/1.4.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/sapt-1.html,72,['energy'],['energy']
Energy Efficiency," to filename in; molden format. Will write natural orbitals from density (MO basis) if supplied.; Warning! most post-SCF wavefunctions do not build the density as this is often; much more costly than the energy. In addition, the wavefunction density attributes; (Da and Db) return the SO density and must be transformed to the MO basis; to use with this function. Added in version 0.5: wfn parameter passed explicitly. Returns:; None. Parameters:. filename (Optional[str]) – Destination file name for MOLDEN file. If unspecified (None), a file; name will be generated from the molecule name.; do_virtual (Optional[bool]) – Do write all the MOs to the MOLDEN file (True) or discard the unoccupied; MOs (False). Not valid for NO’s. If unspecified (None), value taken from; MOLDEN_WITH_VIRTUAL.; use_natural (bool) – Write natural orbitals determined from density on wavefunction.; self (Wavefunction). Examples:. Molden file with the Kohn-Sham orbitals of a DFT calculation.; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> wfn.molden('mycalc.molden'). Molden file with the natural orbitals of a CCSD computation. For correlated methods, an energy call will not compute the density.; “properties” or “gradient” must be called.; >>> E, wfn = properties('ccsd', return_wfn=True); >>> wfn.molden('ccsd_no.molden', use_natural=True). To supply a custom density matrix, manually set the Da and Db of the wavefunction.; This is used, for example, to write natural orbitals coming from a root computed; by a CIWavefunction computation, e.g., detci, fci, casscf.; The first two arguments of get_opdm(); can be set to n, n where n => 0 selects the root to; write out, provided these roots were computed, see NUM_ROOTS. The; third argument controls the spin (""A"", ""B"" or ""SUM"") and the final; boolean option determines whether inactive orbitals are included.; >>> E, wfn = energy('detci', return_wfn=True); >>> wfn.Da() = wfn.get_opdm(0, 0, ""A"", True); >>> wfn.Db() = wfn.get_opdm(0, 0, ""B"", True); >>> molden(",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/api/psi4.core.Wavefunction.html:28255,energy,energy,28255,psi4manual/master/api/psi4.core.Wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.Wavefunction.html,1,['energy'],['energy']
Energy Efficiency," to force this to spherical regardless of any user or other demands.; optstash = p4util.OptionsState(['PUREAM']); core.set_global_option('PUREAM', True); sad_fitting_list = core.BasisSet.build(wfn.molecule(), ""DF_BASIS_SAD"",; core.get_option(""SCF"", ""DF_BASIS_SAD""),; puream=True,; return_atomlist=True); wfn.set_sad_fitting_basissets(sad_fitting_list); optstash.restore(). if hasattr(core, ""EXTERN"") and 'external_potentials' in kwargs: ; core.print_out(""\n Warning! Both an external potential EXTERN object and the external_potential"" +; "" keyword argument are specified. The external_potentials keyword argument will be ignored.\n""); raise ValidationError(""double extern""). ep = kwargs.get(""external_potentials"", None); if ep is not None:; _set_external_potentials_to_wavefunction(ep, wfn). return wfn. def _set_external_potentials_to_wavefunction(external_potential: Union[List, Dict[str, List]], wfn: ""core.Wavefunction""):; """"""Initialize :py:class:`psi4.core.ExternalPotential` object(s) from charges and locations and set on **wfn**. Parameters; ----------; external_potential; List-like structure where each row corresponds to a charge. Lines can be composed of ``q, [x, y, z]`` or; ``q, x, y, z``. Locations are in [a0].; Or, dictionary where keys are FI-SAPT fragments A, B, or C and values are as above. """"""; from psi4.driver.qmmm import QMMMbohr. def validate_qxyz(qxyz):; if len(qxyz) == 2:; return qxyz[0], qxyz[1][0], qxyz[1][1], qxyz[1][2]; elif len(qxyz) == 4:; return qxyz[0], qxyz[1], qxyz[2], qxyz[3]; else:; raise ValidationError(f""Point charge '{qxyz}' not mapping into 'chg, [x, y, z]' or 'chg, x, y, z'""). if isinstance(external_potential, dict):; # For FSAPT, we can take a dictionary of external potentials, e.g.,; # external_potentials={'A': potA, 'B': potB, 'C': potC} (any optional); # For the dimer SAPT calculation, we need to account for the external potential; # in all of the subsystems A, B, C. So we add them all in total_external_potential; # and set the external po",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:36171,charge,charges,36171,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,1,['charge'],['charges']
Energy Efficiency," to proceed."""""" % (cbs_delta2_wfn)). cbs_delta2_wfn_lesser = kwargs.get('delta2_wfn_lesser', cbs_delta_wfn).lower(); if cbs_delta2_wfn_lesser not in VARH.keys():; raise ValidationError(""""""Requested DELTA2 method lesser '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta2_wfn_lesser)). # # Establish method for third delta correction energy; # if 'delta3_wfn' in kwargs:; # do_delta3 = True; # cbs_delta3_wfn = kwargs['delta3_wfn'].lower(); # if cbs_delta3_wfn not in VARH.keys():; # raise ValidationError(""""""Requested DELTA3 method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta3_wfn)); #; # cbs_delta3_wfn_lesser = kwargs.get('delta3_wfn_lesser', cbs_delta2_wfn).lower(); # if not (cbs_delta3_wfn_lesser in VARH.keys()):; # raise ValidationError(""""""Requested DELTA3 method lesser '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta3_wfn_lesser)); #; # # Establish method for fourth delta correction energy; # if 'delta4_wfn' in kwargs:; # do_delta4 = True; # cbs_delta4_wfn = kwargs['delta4_wfn'].lower(); # if not (cbs_delta4_wfn in VARH.keys()):; # raise ValidationError('Requested DELTA4 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta4_wfn)); #; # if 'delta4_wfn_lesser' in kwargs:; # cbs_delta4_wfn_lesser = kwargs['delta4_wfn_lesser'].lower(); # else:; # cbs_delta4_wfn_lesser = cbs_delta3_wfn; # if not (cbs_delta4_wfn_lesser in VARH.keys()):; # raise ValidationError('Requested DELTA4 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta4_wfn_lesser)); #; # # Establish method for fifth delta correction energy; # if 'delta5_wfn' in kwargs:; # do_delta5 = True; # cbs_delta5_wfn = kwargs['delta5_wfn'].lower(); # if not (cbs_delta5_wfn in VARH.keys()):; # raise ValidationError('Requested DELTA5 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta5_wfn)); #; # if 'delta5_wfn_less",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:33388,energy,energy,33388,psi4manual/1.0.0/_modules/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html,3,['energy'],['energy']
Energy Efficiency," to the correlation energy. :type delta2_basis: :ref:`basis string <apdx:basisElement>`; :param delta2_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. * Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, ``'highest_1'``, which uses the best basis; set available. See `Extrapolation Schemes`_ for all available schemes. :type scf_scheme: function; :param scf_scheme: |dl| ``highest_1`` |dr| || ``scf_xtpl_helgaker_3`` || etc. Indicates the basis set extrapolation scheme to be applied to the reference energy. :type corl_scheme: function; :param corl_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the correlation energy. :type delta_scheme: function; :param delta_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the delta correction; to the correlation energy. :type delta2_scheme: function; :param delta2_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the second delta correction; to the correlation energy. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> cbs('scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> cbs('mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:56394,energy,energy,56394,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,3,['energy'],['energy']
Energy Efficiency," to the fourth delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta4_basis and xtpl_highest_1() otherwise. delta5_scheme (function) – \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the fifth delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta5_basis and xtpl_highest_1() otherwise. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples:. 1; 2>>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> cbs(name='scf', scf_basis='cc-pVDZ'). 1; 2>>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> cbs(name='mp2', corl_basis='jun-cc-pVDZ'). 1; 2>>> # [3] DTQ-zeta extrapolated scf reference energy; >>> cbs(name='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). 1; 2>>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> cbs(corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). 1; 2; 3>>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> cbs(corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> cbs(energy, wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). 1; 2>>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs(name='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xt",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/cbs-1.html:10901,energy,energy,10901,psi4manual/1.2.1/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/cbs-1.html,7,['energy'],['energy']
Energy Efficiency," to the output file. salc_name(self: psi4.core.CdSalcList, i: int) → str¶; Return the name of SALC #i. class psi4.core.CorrelationFactor¶; Bases: pybind11_builtins.pybind11_object; docstring. set_params(self: psi4.core.CorrelationFactor, coeff: psi4.core.Vector, exponent: psi4.core.Vector) → None¶; Set coefficient and exponent. class psi4.core.CorrelationTable¶; Bases: pybind11_builtins.pybind11_object; Provides a correlation table between two point groups. degen(self: psi4.core.CorrelationTable, arg0: int) → int¶; Returns the degenercy of the irrep. group(*args, **kwargs)¶; Overloaded function. group(self: psi4.core.CorrelationTable) -> psi4.core.PointGroup. Returns higher order point group. group(self: psi4.core.CorrelationTable, arg0: int, arg1: int) -> int. Returns the higher order point group. n(self: psi4.core.CorrelationTable) → int¶; Returns the number of irreps in high order group. ngamma(self: psi4.core.CorrelationTable, arg0: int) → int¶; Returns the number of irreps in the low order group that an irrep from the high order group can be reduced to. subdegen(self: psi4.core.CorrelationTable, arg0: int) → int¶; Returns the degeneracy of the subgroup irrep. subgroup(self: psi4.core.CorrelationTable) → psi4.core.PointGroup¶; Returns lower order pointgroup. subn(self: psi4.core.CorrelationTable) → int¶; Returns number of irreps in subgroup. class psi4.core.CubeProperties¶; Bases: pybind11_builtins.pybind11_object; docstring. compute_properties(self: psi4.core.CubeProperties) → None¶; docstring. psi4.core.DASUM(arg0: int, arg1: int, arg2: psi::Vector, arg3: int) → float¶; docstring. psi4.core.DAXPY(arg0: int, arg1: int, arg2: float, arg3: psi::Vector, arg4: int, arg5: psi::Vector, arg6: int) → None¶; docstring. psi4.core.DCOPY(arg0: int, arg1: int, arg2: psi::Vector, arg3: int, arg4: psi::Vector, arg5: int) → None¶; docstring. psi4.core.DDOT(arg0: int, arg1: int, arg2: psi::Vector, arg3: int, arg4: psi::Vector, arg5: int) → float¶; docstring. class psi4.core.DFEP",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psi4api-1.html:34045,reduce,reduced,34045,psi4manual/1.2.1/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html,2,['reduce'],['reduced']
Energy Efficiency," tol radius around coord. Returns -1 for no atoms, throws an exception if more than one is found. basis_on_atom(self: psi4.core.Molecule, arg0: int) → str¶; Gets the label of the orbital basis set on a given atom arg0. center_of_mass(self: psi4.core.Molecule) → psi4.core.Vector3¶; Computes center of mass of molecule (does not translate molecule). charge(self: psi4.core.Molecule, atom: int) → float¶; Gets charge of atom (0-indexed without dummies). clone(self: psi4.core.Molecule) → psi4.core.Molecule¶; Returns a new Molecule identical to arg1. com_fixed(self: psi4.core.Molecule) → bool¶; Gets whether or not center of mass is fixed. comment(self: psi4.core.Molecule) → str¶; Gets molecule comment. connectivity(self: psi4.core.Molecule) → List[Tuple[int, int, float]]¶; Gets molecule connectivity. create_psi4_string_from_molecule(self: psi4.core.Molecule) → str¶; Gets a string re-expressing in input format the current state of the molecule.Contains Cartesian geometry info, fragmentation, charges and multiplicities, and any frame restriction. deactivate_all_fragments(self: psi4.core.Molecule) → None¶; Sets all fragments in the molecule to be inactive. distance_matrix(self: psi4.core.Molecule) → psi4.core.Matrix¶; Returns Matrix of interatom distances. extract_subsets(*args, **kwargs)¶; Overloaded function. extract_subsets(self: psi4.core.Molecule, arg0: List[int], arg1: List[int]) -> psi4.core.Molecule. Returns copy of self with arg0 fragments Real and arg1 fragments Ghost. extract_subsets(self: psi4.core.Molecule, arg0: List[int], arg1: int) -> psi4.core.Molecule. Returns copy of self with arg0 fragments Real and arg1 fragment Ghost. extract_subsets(self: psi4.core.Molecule, arg0: int, arg1: List[int]) -> psi4.core.Molecule. Returns copy of self with arg0 fragment Real and arg1 fragments Ghost. extract_subsets(self: psi4.core.Molecule, arg0: int, arg1: int) -> psi4.core.Molecule. Returns copy of self with arg0 fragment Real and arg1 fragment Ghost. extract_subsets(self: p",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.Molecule.html:17193,charge,charges,17193,psi4manual/1.6.x/api/psi4.core.Molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.Molecule.html,4,['charge'],['charges']
Energy Efficiency," tol radius around coord. Returns -1 for no atoms, throws an exception if more than one is found. basis_on_atom(self: psi4.core.Molecule, arg0: int) → str¶; Gets the label of the orbital basis set on a given atom arg0. center_of_mass(self: psi4.core.Molecule) → psi4.core.Vector3¶; Computes center of mass of molecule (does not translate molecule). charge(self: psi4.core.Molecule, atom: int) → float¶; Gets charge of atom (0-indexed without dummies). clone(self: psi4.core.Molecule) → psi4.core.Molecule¶; Returns a new Molecule identical to arg1. com_fixed(self: psi4.core.Molecule) → bool¶; Gets whether or not center of mass is fixed. comment(self: psi4.core.Molecule) → str¶; Gets molecule comment. connectivity(self: psi4.core.Molecule) → list[tuple[int, int, float]]¶; Gets molecule connectivity. create_psi4_string_from_molecule(self: psi4.core.Molecule) → str¶; Gets a string re-expressing in input format the current state of the molecule.Contains Cartesian geometry info, fragmentation, charges and multiplicities, and any frame restriction. deactivate_all_fragments(self: psi4.core.Molecule) → None¶; Sets all fragments in the molecule to be inactive. distance_matrix(self: psi4.core.Molecule) → psi4.core.Matrix¶; Returns Matrix of interatom distances. extract_subsets(*args, **kwargs)¶; Overloaded function. extract_subsets(self: psi4.core.Molecule, arg0: list[int], arg1: list[int]) -> psi4.core.Molecule. Returns copy of self with arg0 fragments Real and arg1 fragments Ghost. extract_subsets(self: psi4.core.Molecule, arg0: list[int], arg1: int) -> psi4.core.Molecule. Returns copy of self with arg0 fragments Real and arg1 fragment Ghost. extract_subsets(self: psi4.core.Molecule, arg0: int, arg1: list[int]) -> psi4.core.Molecule. Returns copy of self with arg0 fragment Real and arg1 fragments Ghost. extract_subsets(self: psi4.core.Molecule, arg0: int, arg1: int) -> psi4.core.Molecule. Returns copy of self with arg0 fragment Real and arg1 fragment Ghost. extract_subsets(self: p",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/api/psi4.core.Molecule.html:17364,charge,charges,17364,psi4manual/master/api/psi4.core.Molecule.html,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.Molecule.html,1,['charge'],['charges']
Energy Efficiency," tol: float) -> int. Tests to see if an atom is at the position coord with a given tolerance tol. basis_on_atom(self: psi4.core.Molecule, arg0: int) → str¶; Gets the label of the orbital basis set on a given atom arg0. center_of_mass(self: psi4.core.Molecule) → psi4.core.Vector3¶; Computes center of mass of molecule (does not translate molecule). charge(self: psi4.core.Molecule, atom: int) → float¶; Gets charge of atom (0-indexed without dummies). clone(self: psi4.core.Molecule) → psi4.core.Molecule¶; Returns a new Molecule identical to arg1. com_fixed(self: psi4.core.Molecule) → bool¶; Gets whether or not center of mass is fixed. comment(self: psi4.core.Molecule) → str¶; Gets molecule comment. connectivity(self: psi4.core.Molecule) → List[Tuple[int, int, float]]¶; Gets molecule connectivity. create_psi4_string_from_molecule(self: psi4.core.Molecule) → str¶; Gets a string re-expressing in input format the current state of the molecule.Contains Cartesian geometry info, fragmentation, charges and multiplicities, and any frame restriction. deactivate_all_fragments(self: psi4.core.Molecule) → None¶; Sets all fragments in the molecule to be inactive. distance_matrix(self: psi4.core.Molecule) → psi4.core.Matrix¶; Returns Matrix of interatom distances. extract_subsets(*args, **kwargs)¶; Overloaded function. extract_subsets(self: psi4.core.Molecule, arg0: List[int], arg1: List[int]) -> psi4.core.Molecule. Returns copy of self with arg0 fragments Real and arg1 fragments Ghost. extract_subsets(self: psi4.core.Molecule, arg0: List[int], arg1: int) -> psi4.core.Molecule. Returns copy of self with arg0 fragments Real and arg1 fragment Ghost. extract_subsets(self: psi4.core.Molecule, arg0: int, arg1: List[int]) -> psi4.core.Molecule. Returns copy of self with arg0 fragment Real and arg1 fragments Ghost. extract_subsets(self: psi4.core.Molecule, arg0: int, arg1: int) -> psi4.core.Molecule. Returns copy of self with arg0 fragment Real and arg1 fragment Ghost. extract_subsets(self: p",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.molecule.html:17128,charge,charges,17128,psi4manual/1.3.2/api/psi4.core.molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.molecule.html,5,['charge'],['charges']
Energy Efficiency," trial cases, keywords nominally directed at non-Cfour modules; are translated into their Cfour counterparts. For example, setting; REFERENCE will appropriately set CFOUR_REFERENCE. For a; list of applicable keywords, see source of; qcdb.cfour.muster_psi4options().; Consult Functionality for information on what Cfour; functionality is accessible through Psi4. Psi4 for Cfour Users¶; In the simplest use of the Psi4/Cfour interface, a Psi4 input file; can simply “wrap” a ZMAT file and execute xcfour. This is; illustrated in the following example:; cfour {; UHF-SCF energy calculation; N; H 1 R; H 1 R 2 A. R=1.008; A=105.0. *ACES2(CALC=HF,BASIS=qz2p; MULT=2,REF=UHF; OCCUPATION=3-1-1-0/3-0-1-0; SCF_CONV=12; MEMORY=20000000); }. energy('cfour'). Here, the contents of the cfour {...} block are written directly to a; ZMAT file. This is joined by a default GENBAS file; (psi4/share/basis/GENBAS). To preferentially use your own GENBAS,; place it in PATH or PSIPATH. The line calling; energy() with argument 'cfour' invokes; xcfour.; After execution of the energy('cfour') line completes, Cfour results; are read back into Psi4 format and are thereafter accessible for; further processing in the input file. See Output for; details. This storage of results in variables and arrays in memory for; the duration of the Psi4 instance (as opposed to solely in files); is the only advantage thus far incurred by the P4C4 interface. We’ll call; this mode of basic utility the “sandwich” mode.; Molecule specification in Psi4 allows Cartesians, Z-matrices, mixed; Cartesian/Z-matrix, negation of variables, delayed specification of; variables, specification of fragments, etc., all in a whitespace-tolerant; format. See Molecule and Geometry Specification for details and; cfour/mints5 for examples. When a Psi4-style molecule is; supplied, its geometry is written to ZMAT in Cartesian form and the; CFOUR_COORDINATES=CARTESIAN, CFOUR_UNITS=ANGSTROM,; CFOUR_CHARGE, and CFOUR_MULTIPLICITY keywords are set; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/cfour-1.html:3525,energy,energy,3525,psi4manual/1.0.0/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/cfour-1.html,2,['energy'],['energy']
Energy Efficiency," trimer (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). gibbs; Test Gibbs free energies at 298 K of N2, H2O, and CH4. mints5; Tests to determine full point group symmetry. Currently, these only matter for the rotational symmetry number in thermodynamic computations. stability2; ROHF stability analysis check for CN with cc-pVDZ. This test corresponds to the rohf-stab test from Psi3. cc27; Single point gradient of 1-1B2 state of H2O with EOM-CCSD. frac; Carbon/UHF Fractionally-Occupied SCF Test Case. cc33; CC3(UHF)/cc-pVDZ H2O \(R_e\) geom from Olsen et al., JCP 104, 8007 (1996). psimrcc-ccsd_t-1; Mk-MRCCSD(T) single point. \(^1A_1\) CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. cc54; CCSD dipole with user-specified basis set. opt1-fd; SCF STO-3G geometry optimzation, with Z-matrix input, by finite-differences. sapt-dft-api; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. cbs-xtpl-wrapper; RHF aug-cc-pVQZ energy for the BH molecule, with Cartesian input. Various gradients for a strained helium dimer and water molecule. scf-coverage; Lithium test for coverage. sad1; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. cc1; RHF-CCSD 6-31G** all-electron optimization of the H2O molecule. dft-grac; Gradient regularized asymptotic correction (GRAC) test. cdomp2-1; OMP2 cc-pVDZ energy for the H2O molecule. tdscf-1; td-uhf test on triplet states of methylene (rpa). dfccd1; DF-CCD cc-pVDZ energy for the H2O molecule. soscf-large; Second-order SCF convergnece: Benzene. opt-irc-2; Compute the IRC for HCN <-> NCH interconversion at the RHF/DZP level of theory. x2c3; Test of SFX2C-1e on Water uncontracted cc-pVDZ The reference numbers ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html:11030,energy,energy,11030,psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency," triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). psi4.gradient(name[, molecule, return_wfn, func, dertype])[source]; Function complementary to optimize(). Carries out one gradient pass,; deciding analytic or finite difference. Returns:; Matrix – Total electronic gradient in Hartrees/Bohr. Returns:; (Matrix, Wavefunction) – gradient and wavefunction when return_wfn specified. Examples:. >>> # [1] Single-point dft gradient getting the gradient; >>> # in file, core.Matrix, and np.array forms; >>> set gradient_write on; >>> G, wfn = gradient('b3lyp-d', return_wfn=True); >>> wfn.gradient().print_out(); >>> np.array(G). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Psithon Functions: Invoking a Calculation; Geometry Optimi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/opt.html:17796,energy,energy,17796,psi4manual/master/opt.html,https://psicode.org,https://psicode.org/psi4manual/master/opt.html,1,['energy'],['energy']
Energy Efficiency," triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). psi4.gradient(name[, molecule, return_wfn, func, dertype])[source]; Function complementary to optimize(). Carries out one gradient pass,; deciding analytic or finite difference. Returns:; Matrix – Total electronic gradient in Hartrees/Bohr. Returns:; (Matrix, Wavefunction) – gradient and wavefunction when return_wfn specified. Examples:. >>> # [1] Single-point dft gradient getting the gradient; >>> # in file, core.Matrix, and np.array forms; >>> set gradient_write on; >>> G, wfn = gradient('b3lyp-d', return_wfn=True); >>> wfn.gradient().print_out(); >>> np.array(G). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Psithon Functions: Invoking a Calculation; Geometry Optimization — ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/opt.html:17147,energy,energy,17147,psi4manual/1.7.x/opt.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/opt.html,1,['energy'],['energy']
Energy Efficiency," triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). psi4.gradient(name[, molecule, return_wfn, func, dertype])[source]; Function complementary to optimize(). Carries out one gradient pass,; deciding analytic or finite difference. Returns:; Matrix – Total electronic gradient in Hartrees/Bohr. Returns:; (Matrix, Wavefunction) – gradient and wavefunction when return_wfn specified. Examples:. >>> # [1] Single-point dft gradient getting the gradient; >>> # in file, core.Matrix, and np.array forms; >>> set gradient_write on; >>> G, wfn = gradient('b3lyp-d', return_wfn=True); >>> wfn.gradient().print_out(); >>> np.array(G). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Psithon Functions: Invoking a Calculation; Geometry Optimization ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/opt.html:17353,energy,energy,17353,psi4manual/1.8.x/opt.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/opt.html,1,['energy'],['energy']
Energy Efficiency," triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). psi4.gradient(name[, molecule, return_wfn, func, dertype])[source]; Function complementary to optimize(). Carries out one gradient pass,; deciding analytic or finite difference. Returns:; Matrix – Total electronic gradient in Hartrees/Bohr. Returns:; (Matrix, Wavefunction) – gradient and wavefunction when return_wfn specified. Examples:. >>> # [1] Single-point dft gradient getting the gradient; >>> # in file, core.Matrix, and np.array forms; >>> set gradient_write on; >>> G, wfn = gradient('b3lyp-d', return_wfn=True); >>> wfn.gradient().print_out(); >>> np.array(G). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Psithon Functions: Invoking a Calculation; Geometry Optimization ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/opt.html:17789,energy,energy,17789,psi4manual/1.9.x/opt.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/opt.html,1,['energy'],['energy']
Energy Efficiency," triples with iterative quadruples (cheapest terms). mrccsdtqp-1a; CC through quadruples with iterative quintuples (cheapest terms). mrccsdtqph-1a; CC through quintuples with iterative sextuples (cheapest terms). mrccsdt-1b; CC through doubles with iterative triples (cheaper terms). mrccsdtq-1b; CC through triples with iterative quadruples (cheaper terms). mrccsdtqp-1b; CC through quadruples with iterative quintuples (cheaper terms). mrccsdtqph-1b; CC through quintuples with iterative sextuples (cheaper terms). mrcc2; approximate CC through doubles. mrcc3; approximate CC through triples. mrcc4; approximate CC through quadruples. mrcc5; approximate CC through quintuples. mrcc6; approximate CC through sextuples. mrccsdt-3; CC through doubles with iterative triples (all but the most expensive terms). mrccsdtq-3; CC through triples with iterative quadruples (all but the most expensive terms). mrccsdtqp-3; CC through quadruples with iterative quintuples (all but the most expensive terms). mrccsdtqph-3; CC through quintuples with iterative sextuples (all but the most expensive terms). Frozen-core approximation is also supported in the MRCC interface.; To optimize CH4 with CCSDT freezing the 1s on carbon, run:; molecule H2O {; O; H 1 r; H 1 r 2 104.5. r = 1.0; }. set {; basis cc-pVDZ; freeze_core true; }. optimize('mrccsdt'). Interface Details¶. MRCC methods¶. MRCC_METHOD; Method; Description. 1; CC. 2; CC(n-1)[n]. 3; CC(n-1)(n); (CC(n-1)[n] energy is also calculated). 4; CC(n-1)(n)_L; (CC(n-1)[n] and CC(n-1)(n) energies are also calculated). 5; CC(n)-1a. 6; CC(n)-1b. 7; CCn. 8; CC(n)-3. table of contents. Interface to MRCC by M. Kállay; Installation; Running MRCC; Interface Details. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to MRCC by M. Kállay. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/mrcc-1.html:4212,energy,energy,4212,psi4manual/1.4.0/mrcc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/mrcc-1.html,2,['energy'],['energy']
Energy Efficiency," triples with iterative quadruples (cheapest terms). mrccsdtqp-1a; CC through quadruples with iterative quintuples (cheapest terms). mrccsdtqph-1a; CC through quintuples with iterative sextuples (cheapest terms). mrccsdt-1b; CC through doubles with iterative triples (cheaper terms). mrccsdtq-1b; CC through triples with iterative quadruples (cheaper terms). mrccsdtqp-1b; CC through quadruples with iterative quintuples (cheaper terms). mrccsdtqph-1b; CC through quintuples with iterative sextuples (cheaper terms). mrcc2; approximate CC through doubles. mrcc3; approximate CC through triples. mrcc4; approximate CC through quadruples. mrcc5; approximate CC through quintuples. mrcc6; approximate CC through sextuples. mrccsdt-3; CC through doubles with iterative triples (all but the most expensive terms). mrccsdtq-3; CC through triples with iterative quadruples (all but the most expensive terms). mrccsdtqp-3; CC through quadruples with iterative quintuples (all but the most expensive terms). mrccsdtqph-3; CC through quintuples with iterative sextuples (all but the most expensive terms). Frozen-core approximation is also supported in the MRCC interface.; To optimize CH4 with CCSDT freezing the 1s on carbon, run:; molecule H2O {; O; H 1 r; H 1 r 2 104.5. r = 1.0; }. set {; basis cc-pVDZ; freeze_core true; }. optimize('mrccsdt'). Interface Details¶. MRCC methods¶. MRCC_METHOD; Method; Description. 1; CC. 2; CC(n-1)[n]. 3; CC(n-1)(n); (CC(n-1)[n] energy is also calculated). 4; CC(n-1)(n)_L; (CC(n-1)[n] and CC(n-1)(n) energies are also calculated). 5; CC(n)-1a. 6; CC(n)-1b. 7; CCn. 8; CC(n)-3. table of contents. Interface to MRCC by M. Kállay; Installation; Running MRCC; Interface Details. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to MRCC by M. Kállay. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/mrcc-1.html:4212,energy,energy,4212,psi4manual/1.5.0/mrcc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/mrcc-1.html,2,['energy'],['energy']
Energy Efficiency," true electrons. These are set in the REFERENCE option.; Note that there are not equivalents to ROHF or CUHF, e.g., no ROKS or CUKS. This; is because ROHF is implicitly assumed to be followed by a correlated method; which can break the positive definiteness of the spin polarization. KS-DFT with; the true functional is expected to be the final step, thus restricting the; solution to positive definite spin polarization is not physical. See the; section in [Szabo:1982] on methyl radical for an example. Functional Selection¶; PSI4 features an extensive list of LSDA, GGA, Meta, Hybrid, LRC, and -D; functionals. These can be specified by a variety of means. Perhaps the simplest; is to use the functional name as the energy procedure call:; energy('b3lyp'). Note that if you are running an unrestricted computation, you should set the; REFERENCE option before the call to energy:; set reference uks; energy('b3lyp'). The functional may also be manually specified by calling energy (or any driver function); with a dft_functional argument:; energy('scf', dft_functional = 'b3lyp'). Another alternative is providing a specially crafted dict-ionary to the dft_functional; argument:; custom_functional = { ""name"": ""my_unique_name"", ... }; energy('scf', dft_functional = custom_functional). For further details about this so called dict_func syntax, see; Advanced Functional Use and Manipulation.; For hybrid functionals, the fraction of exact exchange is controlled by the; DFT_ALPHA option. For the LRC functionals, the fraction of long-range; Hartree–Fock and short-range DFA is controlled by the DFT_OMEGA option.; Changing these will override the default behavior of the requested functional.; A brief summary of some of the more notable functionals in PSI4, and links; to the complete listing of all functionals of each class are presented below:. All FunctionalsAll functionals, including LSDA-only functionals. Note that here and; throughout, functionals which end in _X or _C are exchange or; c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/dft-1.html:15418,energy,energy,15418,psi4manual/1.4.0/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/dft-1.html,18,['energy'],['energy']
Energy Efficiency," ttype is 1 for; tables comparing the computed values to the reference or 2 for simple tabulation; and sum of the computed values. validate_bracketed_basis(basisstring)[source]¶; Function to transform and validate basis sets for cbs(). A basis set with no; paired square brackets is passed through with zeta level 0 (e.g., ‘6-31+G(d,p)’; is returned as [6-31+G(d,p)] and [0]). A basis set with square brackets is; checked for sensible sequence and Dunning-ness and returned as separate basis; sets (e.g., ‘cc-pV[Q5]Z’ is returned as [cc-pVQZ, cc-pV5Z] and [4, 5]). Note; that this function has no communication with the basis set library to check; if the basis actually exists. Used by complete_basis_set(). validate_scheme_args(functionname, **largs)[source]¶; Function called by each extrapolation scheme in complete_basis_set().; Checks that all the input arguments are present and suitable so that; the scheme function can focus on defining the extrapolation. qmmm¶; Module with classes to integrate MM charges into; a QM calculation. class Diffuse(molecule, basisname, ribasisname)[source]¶. fitGeneral()[source]¶; Function to perform a general fit of diffuse charges; to wavefunction density. fitScf()[source]¶; Function to run scf and fit a system of diffuse charges to; resulting density. populateExtern(extern)[source]¶. class QMMM[source]¶. addChargeAngstrom(Q, x, y, z)[source]¶; Function to add a point charge of magnitude Q at; position (x, y, z) Angstroms. addChargeBohr(Q, x, y, z)[source]¶; Function to add a point charge of magnitude Q at; position (x, y, z) Bohr. addDiffuse(diffuse)[source]¶; Function to add a diffuse charge field diffuse. populateExtern()[source]¶; Function to define a charge field external to the; molecule through point and diffuse charges. basislistother¶; Module with commands building BasisFamily objects; for Pople and other non-Dunning orbital basis sets. Some; plausible fitting basis sets are supplied as defaults. load_basfam_other()[source]¶. diatomic",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_driver-1.html:21785,charge,charges,21785,psi4manual/4.0b3/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_driver-1.html,4,['charge'],['charges']
Energy Efficiency," ttype is 1 for; tables comparing the computed values to the reference or 2 for simple tabulation; and sum of the computed values. validate_bracketed_basis(basisstring)[source]¶; Function to transform and validate basis sets for cbs(). A basis set with no; paired square brackets is passed through with zeta level 0 (e.g., ‘6-31+G(d,p)’; is returned as [6-31+G(d,p)] and [0]). A basis set with square brackets is; checked for sensible sequence and Dunning-ness and returned as separate basis; sets (e.g., ‘cc-pV[Q5]Z’ is returned as [cc-pVQZ, cc-pV5Z] and [4, 5]). Note; that this function has no communication with the basis set library to check; if the basis actually exists. Used by complete_basis_set(). validate_scheme_args(functionname, **largs)[source]¶; Function called by each extrapolation scheme in complete_basis_set().; Checks that all the input arguments are present and suitable so that; the scheme function can focus on defining the extrapolation. qmmm¶; Module with classes to integrate MM charges into; a QM calculation. class Diffuse(molecule, basisname, ribasisname)[source]¶. fitGeneral()[source]¶; Function to perform a general fit of diffuse charges; to wavefunction density. fitScf()[source]¶; Function to run scf and fit a system of diffuse charges to; resulting density. populateExtern(extern)[source]¶. class QMMM[source]¶. addChargeAngstrom(Q, x, y, z)[source]¶; Function to add a point charge of magnitude Q at; position (x, y, z) Angstroms. addChargeBohr(Q, x, y, z)[source]¶; Function to add a point charge of magnitude Q at; position (x, y, z) Bohr. addDiffuse(diffuse)[source]¶; Function to add a diffuse charge field diffuse. populateExtern()[source]¶; Function to define a charge field external to the; molecule through point and diffuse charges. diatomic¶. functional¶; Module to provide lightweight definitions of functionals and; SuperFunctionals. build_b2plyp_superfunctional(name, npoints, deriv)[source]¶. build_b2plypd2gr_superfunctional(name, npoints, deriv)",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodoc_driver-1.html:19310,charge,charges,19310,psi4manual/4.0b5/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodoc_driver-1.html,2,['charge'],['charges']
Energy Efficiency," ttype is 1 for; tables comparing the computed values to the reference or 2 for simple tabulation; and sum of the computed values. validate_bracketed_basis(basisstring)[source]¶; Function to transform and validate basis sets for cbs(). A basis set with no; paired square brackets is passed through with zeta level 0 (e.g., ‘6-31+G(d,p)’; is returned as [6-31+G(d,p)] and [0]). A basis set with square brackets is; checked for sensible sequence and Dunning-ness and returned as separate basis; sets (e.g., ‘cc-pV[Q5]Z’ is returned as [cc-pVQZ, cc-pV5Z] and [4, 5]). Note; that this function has no communication with the basis set library to check; if the basis actually exists. Used by complete_basis_set(). validate_scheme_args(functionname, **largs)[source]¶; Function called by each extrapolation scheme in complete_basis_set().; Checks that all the input arguments are present and suitable so that; the scheme function can focus on defining the extrapolation. qmmm¶; Module with classes to integrate MM charges into; a QM calculation. class Diffuse(molecule, basisname, ribasisname)[source]¶. fitGeneral()[source]¶; Function to perform a general fit of diffuse charges; to wavefunction density. fitScf()[source]¶; Function to run scf and fit a system of diffuse charges to; resulting density. populateExtern(extern)[source]¶. class QMMM[source]¶. addChargeAngstrom(Q, x, y, z)[source]¶; Function to add a point charge of magnitude Q at; position (x, y, z) Angstroms. addChargeBohr(Q, x, y, z)[source]¶; Function to add a point charge of magnitude Q at; position (x, y, z) Bohr. addDiffuse(diffuse)[source]¶; Function to add a diffuse charge field diffuse. populateExtern()[source]¶; Function to define a charge field external to the; molecule through point and diffuse charges. functional¶; Module to provide lightweight definitions of functionals and; SuperFunctionals. build_b3_x_functional(name)[source]¶. build_b3lyp5_superfunctional(name, npoints, deriv)[source]¶. build_b3lyp5d_superfunction",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodoc_driver-1.html:13800,charge,charges,13800,psi4manual/4.0b2/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodoc_driver-1.html,2,['charge'],['charges']
Energy Efficiency," two energy computations. In the next computation ao_basis=disk algorithm is used, where the transformation of integrals for four-virtual case is avoided. opt1-fd; SCF STO-3G geometry optimzation, with Z-matrix input, by finite-differences. fd-freq-energy; SCF STO-3G finite-difference frequencies from energies for H2O. cc30; CCSD/sto-3g optical rotation calculation (length gauge only) at two frequencies on methyloxirane. dfccsd-grad2; DF-CCSD cc-pVDZ gradient for the NH molecule. dft-pruning; Tests all grid pruning options available and screening of small weights. Check against grid size. cc51; EOM-CC3/cc-pVTZ on H2O. opt7; Various constrained energy minimizations of HOOH with cc-pvdz RHF. For “fixed” coordinates, the final value is provided by the user. cbs-xtpl-gradient; Various gradients for a strained helium dimer and water molecule. sapt9; usapt example with empty beta. cc7; Tests CCENERGY’s CCSD gradient in the presence of a dipole field. mcscf2; TCSCF cc-pVDZ energy of asymmetrically displaced ozone, with Z-matrix input. dct5; DC-06 calculation for the O2 molecule (triplet ground state). This performs geometry optimization using two-step and simultaneous solution of the response equations for the analytic gradient. dfscf-bz2; Benzene Dimer DF-HF/cc-pVDZ. cepa1; cc-pvdz H2O Test CEPA(1) Energy. tu1-h2o-energy; Sample HF/cc-pVDZ H2O computation. cc56; EOM-CCSD/6-31g excited state transition data for water cation. cc3; cc3: RHF-CCSD/6-31G** H2O geometry optimization and vibrational frequency analysis by finite-differences of gradients. dfmp2-grad1; DF-MP2 cc-pVDZ gradients for the H2O molecule. opt-irc-2; Compute the IRC for HCN <-> NCH interconversion at the RHF/DZP level of theory. dft-ghost; DFT Functional Test for Range-Seperated Hybrids and Ghost atoms. freq-isotope2; Vibrational and thermo analysis of several water isotopologs. Demonstrates Hessian reuse for different temperatures, pressures, and isotopologs. scf-hess1; RHF STO-3G (Cartesian) and cc-pVDZ (s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html:5939,energy,energy,5939,psi4manual/master/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency," uconv = np.asarray([constants.hartree2kcalmol, constants.hartree2kJmol, 1.]). # TODO rot_const, rotor_type; text = ''; text += """"""\n ==> Thermochemistry Components <=="""""". text += """"""\n\n Entropy, S""""""; for term in terms:; text += format_S_Cv_Cp.format(terms[term] + ' S', *sm[('S', term)] * uconv); if term == 'elec':; text += """""" (multiplicity = {})"""""".format(multiplicity); elif term == 'trans':; text += """""" (mol. weight = {:.4f} [u], P = {:.2f} [Pa])"""""".format(molecular_mass, P); elif term == 'rot':; text += """""" (symmetry no. = {})"""""".format(sigma). text += """"""\n\n Constant volume heat capacity, Cv""""""; for term in terms:; text += format_S_Cv_Cp.format(terms[term] + ' Cv', *sm[('Cv', term)] * uconv). text += """"""\n\n Constant pressure heat capacity, Cp""""""; for term in terms:; text += format_S_Cv_Cp.format(terms[term] + ' Cp', *sm[('Cp', term)] * uconv). del terms['tot']; terms['corr'] = 'Correction'. text += """"""\n\n ==> Thermochemistry Energy Analysis <==""""""; text += """"""\n\n Raw electronic energy, E_e""""""; text += f""""""\n Total E_e, Electronic energy at well bottom {E0:15.8f} [Eh]"""""". text += """"""\n\n Zero-point vibrational energy, ZPVE = Sum_i omega_i / 2, E_0 = E_e + ZPVE""""""; ; for term in terms:; if term in ['vib']:; text += format_ZPE_E_H_G.format(terms[term] + ' ZPVE', *sm[('ZPE', term)] * uconv); text += """""" {:15.3f} [cm^-1]"""""".format(sm[('ZPE', term)] * constants.hartree2wavenumbers); elif term in ['corr']:; text += format_ZPE_E_H_G.format(terms[term] + ' ZPVE to E_e', *sm[('ZPE', term)] * uconv); text += """""" {:15.3f} [cm^-1]"""""".format(sm[('ZPE', term)] * constants.hartree2wavenumbers); text += """"""\n Total E_0, Enthalpy at 0 [K] {:15.8f} [Eh]"""""".format(; sm[('ZPE', 'tot')]) ; text += """"""\n *** Absolute enthalpy, not an enthalpy of formation ***""""""; ; text += """"""\n\n Thermal (internal) energy, E (includes ZPVE and finite-temperature corrections)""""""; for term in terms:; if term in ['elec']:; text += format_ZPE_E_H_G.format(terms[term] + ' contrib to E beyond E_e',",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/qcdb/vib.html:36890,energy,energy,36890,psi4manual/1.9.x/_modules/qcdb/vib.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/qcdb/vib.html,8,['energy'],['energy']
Energy Efficiency," unaffected by user-set symmetry on molecule, so this option is the sole way to influence the symmetry-dependent aspects of the thermodynamic analysis. Note that this factor is handled differently among quantum chemistry software. Type: integer; Default: 1. RSRFO_ALPHA_MAX (OPTKING)¶OPTKING — Absolute maximum value of RS-RFO. Type: double; Default: 1e8. RUN_CCSD (FNOCC)¶FNOCC (Expert) — do ccsd rather than qcisd?. Type: boolean; Default: false. RUN_CCTRANSORT (CCTRANSORT)¶CCTRANSORT — Use cctransort module NOTE: Turning this option off requires separate installation of ccsort and transqt2 modules, see http://github.com/psi4/psi4pasture. Type: boolean; Default: true. RUN_CEPA (FNOCC)¶FNOCC (Expert) — Is this a CEPA job? This parameter is used internally by the pythond driver. Changing its value won’t have any effect on the procedure. Type: boolean; Default: false. RUN_MP2 (FNOCC)¶FNOCC (Expert) — do only evaluate mp2 energy?. Type: boolean; Default: false. RUN_MP3 (FNOCC)¶FNOCC (Expert) — do only evaluate mp3 energy?. Type: boolean; Default: false. RUN_MP4 (FNOCC)¶FNOCC (Expert) — do only evaluate mp4 energy?. Type: boolean; Default: false. S (DETCI)¶DETCI — The value of the spin quantum number \(S\) is given by this option. The default is determined by the value of the multiplicity. This is used for two things: (1) determining the phase of the redundant half of the CI vector when the \(M_s = 0\) component is used (i.e., MS0 = TRUE), and (2) making sure the guess vector has the desired value of \(\langle S^2\rangle\) (if CALC_S_SQUARED is TRUE and ICORE = 1). Type: double; Default: 0.0. S_CHOLESKY_TOLERANCE (SCF)¶SCF — Tolerance for partial Cholesky decomposition of overlap matrix. Type: conv double; Default: 1e-8. S_CUT (DLPNO)¶DLPNO (Expert) — Overlap matrix threshold for removing linear dependencies. Type: double; Default: 1e-8. S_ORTHOGONALIZATION (SCF)¶SCF — SO orthogonalization: automatic, symmetric, or canonical?. Type: string; Possible Values: AUTO, SYMMETRIC,",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_glossary_options_c-1.html:208283,energy,energy,208283,psi4manual/1.5.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_glossary_options_c-1.html,7,['energy'],['energy']
Energy Efficiency," unaffected by user-set symmetry on molecule, so this option is the sole way to influence the symmetry-dependent aspects of the thermodynamic analysis. Note that this factor is handled differently among quantum chemistry software. Type: integer; Default: 1. RSRFO_ALPHA_MAX (OPTKING)¶OPTKING — Absolute maximum value of RS-RFO. Type: double; Default: 1e8. RUN_CCSD (FNOCC)¶FNOCC (Expert) — do ccsd rather than qcisd?. Type: boolean; Default: false. RUN_CCTRANSORT (CCTRANSORT)¶CCTRANSORT — Use cctransort module NOTE: Turning this option off requires separate installation of ccsort and transqt2 modules, see http://github.com/psi4/psi4pasture. Type: boolean; Default: true. RUN_CEPA (FNOCC)¶FNOCC (Expert) — Is this a CEPA job? This parameter is used internally by the pythond driver. Changing its value won’t have any effect on the procedure. Type: boolean; Default: false. RUN_MP2 (FNOCC)¶FNOCC (Expert) — do only evaluate mp2 energy?. Type: boolean; Default: false. RUN_MP3 (FNOCC)¶FNOCC (Expert) — do only evaluate mp3 energy?. Type: boolean; Default: false. RUN_MP4 (FNOCC)¶FNOCC (Expert) — do only evaluate mp4 energy?. Type: boolean; Default: false. S (DETCI)¶DETCI — The value of the spin quantum number \(S\) is given by this option. The default is determined by the value of the multiplicity. This is used for two things: (1) determining the phase of the redundant half of the CI vector when the \(M_s = 0\) component is used (i.e., MS0 = TRUE), and (2) making sure the guess vector has the desired value of \(\langle S^2\rangle\) (if CALC_S_SQUARED is TRUE and ICORE = 1). Type: double; Default: 0.0. S_CHOLESKY_TOLERANCE (SCF)¶SCF — Tolerance for partial Cholesky decomposition of overlap matrix. Type: conv double; Default: 1e-8. S_ORTHOGONALIZATION (SCF)¶SCF — SO orthogonalization: automatic, symmetric, or canonical?. Type: string; Possible Values: AUTO, SYMMETRIC, CANONICAL, PARTIALCHOLESKY; Default: AUTO. S_TOLERANCE (SCF)¶SCF — Minimum S matrix eigenvalue to allow before linear ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:207043,energy,energy,207043,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,2,['energy'],['energy']
Energy Efficiency, uncertainty=0.000 000 000 000 52. electron_gyromag_ratio; 1.760859644E+11; electron gyromag. ratio [s^{-1} T^{-1}] uncertainty=0.000 000 011 e11. electron_gyromag_ratio_over_2_pi; 28024.95164; electron gyromag. ratio over 2 pi [MHz T^{-1}] uncertainty=0.000 17. electron_helion_mass_ratio; 0.0001819543074854; electron-helion mass ratio [] uncertainty=0.000 000 000 088 e-4. electron_mag_mom; -9.284764620E-24; electron mag. mom. [J T^{-1}] uncertainty=0.000 0057 e-26. electron_mag_mom_anomaly; 0.00115965218091; electron mag. mom. anomaly [] uncertainty=0.000 000 000 26 e-3. electron_mag_mom_to_Bohr_magneton_ratio; -1.00115965218091; electron mag. mom. to Bohr magneton ratio [] uncertainty=0.000 000 000 000 26. electron_mag_mom_to_nuclear_magneton_ratio; -1838.28197234; electron mag. mom. to nuclear magneton ratio [] uncertainty=0.000 000 17. electron_mass; 9.10938356E-31; electron mass [kg] uncertainty=0.000 000 11 e-31. electron_mass_energy_equivalent; 8.18710565E-14; electron mass energy equivalent [J] uncertainty=0.000 000 10 e-14. electron_mass_energy_equivalent_in_MeV; 0.5109989461; electron mass energy equivalent in MeV [MeV] uncertainty=0.000 000 0031. electron_mass_in_u; 0.000548579909070; electron mass in u [u] uncertainty=0.000 000 000 16 e-4. electron_molar_mass; 5.48579909070E-7; electron molar mass [kg mol^{-1}] uncertainty=0.000 000 000 16 e-7. electron_muon_mag_mom_ratio; 206.7669880; electron-muon mag. mom. ratio [] uncertainty=0.000 0046. electron_muon_mass_ratio; 0.00483633170; electron-muon mass ratio [] uncertainty=0.000 000 11 e-3. electron_neutron_mag_mom_ratio; 960.92050; electron-neutron mag. mom. ratio [] uncertainty=0.000 23. electron_neutron_mass_ratio; 0.00054386734428; electron-neutron mass ratio [] uncertainty=0.000 000 0027 e-4. electron_proton_mag_mom_ratio; -658.2106866; electron-proton mag. mom. ratio [] uncertainty=0.000 0020. electron_proton_mass_ratio; 0.000544617021352; electron-proton mass ratio [] uncertainty=0.000 000 000 52 e-,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodoc_physconst-1.html:10254,energy,energy,10254,psi4manual/1.3.2/autodoc_physconst-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodoc_physconst-1.html,11,['energy'],['energy']
Energy Efficiency," units, [Eh a0/u] or [(e a0/a0)^2/u]; project_trans (bool) – Idealized translations projected out of final vibrational analysis.; project_rot (bool) – Idealized rotations projected out of final vibrational analysis. Returns:; Returns dictionary of vibration Datum objects (fields: label units data comment).; Also returns text suitable for printing. Return type:; dict, str. Notes. key; description (label & comment); units; data (real/imaginary modes). omega; frequency; cm^-1; ndarray(ndof) complex (real/imag). q; normal mode, normalized mass-weighted; a0 u^1/2; ndarray(ndof, ndof) float. w; normal mode, un-mass-weighted; a0; ndarray(ndof, ndof) float. x; normal mode, normalized un-mass-weighted; a0; ndarray(ndof, ndof) float. degeneracy; degree of degeneracy. ndarray(ndof) int. TRV; translation/rotation/vibration. ndarray(ndof) str ‘TR’ or ‘V’ or ‘-’ for partial. gamma; irreducible representation. ndarray(ndof) str irrep or None if unclassifiable. mu; reduced mass; u; ndarray(ndof) float (+/+). k; force constant; mDyne/A; ndarray(ndof) float (+/-). DQ0; RMS deviation v=0; a0 u^1/2; ndarray(ndof) float (+/0). Qtp0; Turning point v=0; a0 u^1/2; ndarray(ndof) float (+/0). Xtp0; Turning point v=0; a0; ndarray(ndof) float (+/0). theta_vib; char temp; K; ndarray(ndof) float (+/0). IR_intensity; infrared intensity; km/mol; ndarray(ndof) float (+/+). Examples; >>> # displacement of first atom in highest energy mode; >>> vibinfo['x'].data[:, -1].reshape(nat, 3)[0]. >>> # remove translations & rotations; >>> vibonly = filter_nonvib(vibinfo). table of contents. harmonic_analysis; harmonic_analysis(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Psithon Functions: Invoking a Calculation; Harmonic Vibrational Analysis and Visualization of Normal Modes — frequency() and hessian(); harmonic_analysis. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.qcdb.vib.harmonic_analysis.html:2380,energy,energy,2380,psi4manual/1.8.x/api/psi4.driver.qcdb.vib.harmonic_analysis.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.qcdb.vib.harmonic_analysis.html,1,['energy'],['energy']
Energy Efficiency," units, [Eh a0/u] or [(e a0/a0)^2/u]; project_trans (bool) – Idealized translations projected out of final vibrational analysis.; project_rot (bool) – Idealized rotations projected out of final vibrational analysis. Returns:; Returns dictionary of vibration Datum objects (fields: label units data comment).; Also returns text suitable for printing. Return type:; dict, str. Notes. key; description (label & comment); units; data (real/imaginary modes). omega; frequency; cm^-1; ndarray(ndof) complex (real/imag). q; normal mode, normalized mass-weighted; a0 u^1/2; ndarray(ndof, ndof) float. w; normal mode, un-mass-weighted; a0; ndarray(ndof, ndof) float. x; normal mode, normalized un-mass-weighted; a0; ndarray(ndof, ndof) float. degeneracy; degree of degeneracy. ndarray(ndof) int. TRV; translation/rotation/vibration. ndarray(ndof) str ‘TR’ or ‘V’ or ‘-’ for partial. gamma; irreducible representation. ndarray(ndof) str irrep or None if unclassifiable. mu; reduced mass; u; ndarray(ndof) float (+/+). k; force constant; mDyne/A; ndarray(ndof) float (+/-). DQ0; RMS deviation v=0; a0 u^1/2; ndarray(ndof) float (+/0). Qtp0; Turning point v=0; a0 u^1/2; ndarray(ndof) float (+/0). Xtp0; Turning point v=0; a0; ndarray(ndof) float (+/0). theta_vib; char temp; K; ndarray(ndof) float (+/0). IR_intensity; infrared intensity; km/mol; ndarray(ndof) float (+/+). Examples; >>> # displacement of first atom in highest energy mode; >>> vibinfo['x'].data[:, -1].reshape(nat, 3)[0]. >>> # remove translations & rotations; >>> vibonly = filter_nonvib(vibinfo). table of contents. harmonic_analysis; harmonic_analysis(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Psithon Functions: Invoking a Calculation; Harmonic Vibrational Analysis and Visualization of Normal Modes — frequency() and hessian(); harmonic_analysis. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/api/psi4.driver.qcdb.vib.harmonic_analysis.html:2390,energy,energy,2390,psi4manual/1.9.x/api/psi4.driver.qcdb.vib.harmonic_analysis.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.driver.qcdb.vib.harmonic_analysis.html,1,['energy'],['energy']
Energy Efficiency," unless extreme accuracy is required; or a fitting basis is not defined for the primary basis and atom type; encountered. In particular, we have found excellent efficiency and tractability; gains when using DF-MP2 in concert with a DF-SCF reference. An efficient,; threaded, disk-based DF-MP2 code is available in PSI4 for all single; reference types available in the SCF module.; MP2 defaults in PSI4 to the density-fitted code. See; MP2_TYPE for performing a MP2 with conventional integrals.; An example utilization of the code is:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set basis cc-pvdz; set scf_type df; set freeze_core True. energy('mp2'). The energy('mp2') call to energy() executes; the predefined DF-MP2 procedure, first calling; the SCF module with a default RHF reference and DF algorithm for the; two-electron integrals. When the orbitals are converged, the DF-MP2 module is; launched, which forms the density-fitted \((Q|ov)\) integrals and then builds the; full \((ov|ov)\) tensor in blocks, evaluating the contributions to the MP2 energy; as it goes. A RHF-MP2 wavefunction is selected automatically due to the RHF; reference. In this example, we freeze the core, both for efficiency and; because split-valence bases like cc-pVDZ do not contain core correlation; functions. The result looks something like:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19-----------------------------------------------------------; ==================> DF-MP2 Energies <====================; -----------------------------------------------------------; Reference Energy = -76.0213974638823942 [Eh]; Singles Energy = -0.0000000000000001 [Eh]; Same-Spin Energy = -0.0512503270216563 [Eh]; Opposite-Spin Energy = -0.1534098175176923 [Eh]; Correlation Energy = -0.2046601445393486 [Eh]; Total Energy = -76.2260576084217405 [Eh]; -----------------------------------------------------------; ================> DF-SCS-MP2 Energies <========",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/dfmp2-1.html:2421,energy,energy,2421,psi4manual/1.2.1/dfmp2-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/dfmp2-1.html,6,['energy'],['energy']
Energy Efficiency," updated dldf reference to new BraggSlater radii Dispersionless density functional (dlDF+D) internal match to Psi4 Extensive testing has been done to match supplemental info of Szalewicz et. al., Phys. Rev. Lett., 103, 263201 (2009) and Szalewicz et. al., J. Phys. Chem. Lett., 1, 550-555 (2010). dfmp2-grad2; DF-MP2 cc-pVDZ gradient for the NO molecule. cc26; Single-point gradient, analytic and via finite-differences of 2-1A1 state of H2O with EOM-CCSD. mp2p5-grad1; MP2.5 cc-pVDZ gradient for the H2O molecule. sapt-exch-ind-inf; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. adc1; ADC(2)/6-31G** on H2O using builtin ADC module. stability1; UHF->UHF stability analysis test for BH with cc-pVDZ Test direct SCF with and without symmetry, test PK without symmetry. cisd-h2o+-0; 6-31G** H2O+ Test CISD Energy Point. cc2; 6-31G** H2O CCSD optimization by energies, with Z-Matrix input. dfep2-2; Compute three IP and 2 EA’s for the PH3 molecule. omp2p5-2; OMP2.5 cc-pVDZ energy for the H2O molecule. sad-scf-type; Test SAD SCF guesses on noble gas atom. dfmp2-1; Density fitted MP2 cc-PVDZ/cc-pVDZ-RI computation of formic acid dimer binding energy using automatic counterpoise correction. Monomers are specified using Cartesian coordinates. fsapt2; A very quick correctness test of F-SAPT (see fsapt1 for a real example). cepa3; cc-pvdz H2O Test coupled-pair CISD against DETCI CISD. dfomp2-3; OMP2 cc-pVDZ energy for the H2O molecule. cc19; CCSD/cc-pVDZ dipole polarizability at two frequencies. opt12; SCF cc-pVDZ geometry optimzation of ketene, starting from bent structure. cc17; Single point energies of multiple excited states with EOM-CCSD. props2; DF-SCF cc-pVDZ of benzene-hydronium ion, scanning the dissociation coordinate with Python’s built-in loop mechanism. The geometry is specified by a Z-matrix with dummy atoms, fixed parameters, updated parameters, and separate charge/multiplicity specifiers for each monomer. One-electron properties computed for dimer and o",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html:24542,energy,energy,24542,psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency," use the; cp kwarg and/or the extended method syntax like; 'mp3/aug-cc-pv[dt]z' to energy(), opt(), etc., respectively.; For many of the PSI4 Python functions described above, it makes scientific; sense that they could be called in combination. For instance, one could; optimize all the reagents in a database or compute a; counterpoise-corrected interaction energy with an extrapolated method. The; table below outlines permitted intercalls between functions, showing that; db(opt(cbs(energy()))) is allowed, while db(cp(energy())) is not. This; table is not yet validated for calls with cp(). Permitted nesting of Psithon functions¶. Caller; Callee. cp; db; opt; cbs; energy. Basis Set Superposition Corrections. —; Y; Y; Y. Database — database(); —. Y; Y; Y. Geometry Optimization — optimize() and gradient(); —; —. Y; Y. Complete Basis Set; —; —; —. Y. Single-Point Energy — energy(); —; —; —; —. The command db(opt(cbs(energy()))) is actually expressed as db(...,; db_func=opt, opt_func=cbs). The perhaps expected final argument of; cbs_func=energy is not necessary since energy() is always the function; called by default. Also, the outermost internal function call (db_func; above can be called as just func. Several examples of intercalls; between Python functions can be found in sample input pywrap-all.; All keyword arguments are passed along to each function traversed in the; Python driver, so there should be no concern for separating them, grouping; them, or designating them for a particular function when undertaking a; nested calculation. Where the same keyword is used by multiple functions,; prefixes are added, e.g., db_mode and opt_mode.; Function intercalls should not be used in sow/reap mode. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Psithon Functions: Invoking a Calculation; Function Intercalls. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/intercalls.html:1352,energy,energy,1352,psi4manual/1.6.x/intercalls.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/intercalls.html,2,['energy'],['energy']
Energy Efficiency," use the; cp kwarg and/or the extended method syntax like; 'mp3/aug-cc-pv[dt]z' to energy(), opt(), etc., respectively.; For many of the PSI4 Python functions described above, it makes scientific; sense that they could be called in combination. For instance, one could; optimize all the reagents in a database or compute a; counterpoise-corrected interaction energy with an extrapolated method. The; table below outlines permitted intercalls between functions, showing that; db(opt(cbs(energy()))) is allowed, while db(cp(energy())) is not. This; table is not yet validated for calls with cp(). Permitted nesting of Psithon functions¶. Caller; Callee.  ; cp; db; opt; cbs; energy. Basis Set Superposition Corrections;  ; —; Y; Y; Y. Database — database(); —;  ; Y; Y; Y. Geometry Optimization — optimize() and gradient(); —; —;  ; Y; Y. Complete Basis Set; —; —; —;  ; Y. Single-Point Energy — energy(); —; —; —; —;  . The command db(opt(cbs(energy()))) is actually expressed as db(...,; db_func=opt, opt_func=cbs). The perhaps expected final argument of; cbs_func=energy is not necessary since energy() is always the function; called by default. Also, the outermost internal function call (db_func; above can be called as just func. Several examples of intercalls; between Python functions can be found in sample input pywrap-all.; All keyword arguments are passed along to each function traversed in the; Python driver, so there should be no concern for separating them, grouping; them, or designating them for a particular function when undertaking a; nested calculation. Where the same keyword is used by multiple functions,; prefixes are added, e.g., db_mode and opt_mode.; Function intercalls should not be used in sow/reap mode. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Psithon Functions: Invoking a Calculation. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/intercalls-1.html:1351,energy,energy,1351,psi4manual/1.3.2/intercalls-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/intercalls-1.html,4,['energy'],['energy']
Energy Efficiency," use; Libint from conda without thinking, consult sec:condapsi4dev. To remove a conda installation, conda remove chemps2. Source. If using PSI4 built from source and you want CheMPS2 built from; from source also,; enable it as a feature with ENABLE_CheMPS2,; and let the build system fetch and build it and activate dependent code. Methods¶. Density matrix renormalization group capabilities of PSI4 through CheMPS2¶. name; calls method; Energy; Gradient. dmrg-ci; DMRG configuration interaction (CI); RHF/ROHF; —. dmrg-scf; DMRG complete active space SCF (CASSCF); RHF/ROHF; —. dmrg-caspt2; DMRG CAS with 2nd-order perturbation theory (CASPT2); RHF/ROHF; —. DMRG Keywords¶. DMRG_CASPT2_CALC¶. Do calculate the DMRG-CASPT2 energy after the DMRGSCF calculations are done?. Type: boolean; Default: false. DMRG_CASPT2_IMAG¶. CASPT2 Imaginary shift. Type: double; Default: 0.0. DMRG_CASPT2_IPEA¶. CASPT2 IPEA shift. Type: double; Default: 0.0. DMRG_CASPT2_ORBS¶. Whether to calculate the DMRG-CASPT2 energy after the DMRGSCF calculations are done. Type: string; Possible Values: PSEUDOCANONICAL, ACTIVE; Default: PSEUDOCANONICAL. DMRG_DIIS¶. Whether or not to use DIIS for DMRG. Type: boolean; Default: false. DMRG_DIIS_WRITE¶. Whether or not to store the DIIS checkpoint on disk (convenient for restarting). Type: boolean; Default: true. DMRG_EXCITATION¶. Which root is targeted: 0 means ground state, 1 first excited state, etc. Type: integer; Default: 0. DMRG_IRREP¶. The DMRG wavefunction irrep uses the same conventions as PSI4. How convenient :-). Just to avoid confusion, it’s copied here. It can also be found on http://sebwouters.github.io/CheMPS2/doxygen/classCheMPS2_1_1Irreps.html . Symmetry Conventions Irrep Number & Name Group Number & Name 0 1 2 3 4 5 6 7 0: c1 A 1: ci Ag Au 2: c2 A B 3: cs A’ A’’ 4: d2 A B1 B2 B3 5: c2v A1 A2 B1 B2 6: c2h Ag Bg Au Bu 7: d2h Ag B1g B2g B3g Au B1u B2u B3u. Type: integer; Default: -1. DMRG_LOCAL_INIT¶. Whether to start the active space localization proc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/chemps2-1.html:2258,energy,energy,2258,psi4manual/1.2.1/chemps2-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/chemps2-1.html,4,['energy'],['energy']
Energy Efficiency," used in SAPT(DFT) need to be asymptotically; corrected with Gradient Regulated Asymptotic Correction scheme (GRAC),; in order to recover the correct long-range asymptotic behavior; (approaching \(-1/r\) as \(r\) approaches infinity). The program; requires manual input of GRAC shift parameter for each monomer through; keywords SAPT_DFT_GRAC_SHIFT_A and SAPT_DFT_GRAC_SHIFT_B,; which should be equal to the difference of the actual ionization; potential and the corresponding Kohn-Sham HOMO energy. The dispersion; term needs to be computed with orbital response for good accuracy,; and it is recommended to enable SAPT_DFT_DO_HYBRID (set to; True by default). The coupled exchange-dispersion energy is usually; estimated by scaling from the uncoupled value either by a fitted fixed; value as suggested by [Hesselmann:2014:094107], or by the ratio of; coupled and uncoupled dispersion energy. This can be controlled by; keyword SAPT_DFT_EXCH_DISP_SCALE_SCHEME, with FIXED being; the former approach, DISP being the latter and NONE for not; scaling and use the uncoupled exchange-dispersion energy directly. Basic Keywords for SAPT(DFT)¶. SAPT_DFT_GRAC_SHIFT_A¶. Monomer A GRAC shift in Hartree. Type: double; Default: 0.0. SAPT_DFT_GRAC_SHIFT_B¶. Monomer B GRAC shift in Hartree. Type: double; Default: 0.0. SAPT_DFT_DO_DHF¶. Compute the Delta-HF correction?. Type: boolean; Default: true. SAPT_DFT_EXCH_DISP_SCALE_SCHEME¶. Scheme for approximating exchange-dispersion for SAPT-DFT. NONE Use unscaled Exch-Disp2,u . FIXED Use a fixed factor SAPT_DFT_EXCH_DISP_FIXED_SCALE to scale Exch-Disp2,u . DISP Use the ratio of Disp2,r and Disp2,u to scale Exch-Disp2,u . Type: string; Possible Values: NONE, FIXED, DISP; Default: DISP. Advanced Keywords for SAPT(DFT)¶. SAPT_DFT_FUNCTIONAL¶. Underlying funcitonal to use for SAPT(DFT). Type: string; Default: PBE0. SAPT_DFT_DO_HYBRID¶. Enables the hybrid xc kernel in dispersion?. Type: boolean; Default: true. SAPT_DFT_EXCH_DISP_FIXED_SCALE¶. Exch-disp scal",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/sapt-1.html:22788,energy,energy,22788,psi4manual/1.4.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/sapt-1.html,5,['energy'],['energy']
Energy Efficiency," used in several; coupled-pair methods are given in Table CEPA Shifts. Note that these shifts are defined in a spin-free; formalism for closed-shell references only. method. cisd. cepa(0); 0; 0. cepa(1). cepa(3). acpf. aqcc. The pair correlation energy, , is simply a partial; sum of the correlation energy. In a spin-free formalism, the pair energy; is given by. (7); Methods whose shifts ( and ) do not; explicitly depend on orbitals or (CISD, CEPA(0), ACPF,; and AQCC) have solutions that render the energy stationary with respect; variations in the amplitudes. This convenient property allows density; matrices and 1-electron properties to be evaluated without any additional; effort. Note, however, that 1-electron properties are currently; unavailable when coupling these stationary CEPA-like methods with frozen; natural orbitals. Density-fitted coupled cluster¶; Density fitting (DF) [or the resolution of the identity (RI)] and Cholesky; decomposition (CD) techniques are popular in quantum chemistry to avoid; the computation and storage of the 4-index electron repulsion integral; (ERI) tensor and even to reduce the computational scaling of some terms.; DF/CD-CCSD(T) computations are available in Psi4, with or without the; use of FNOs, through the FNOCC module. The implementation and accuracy of; the DF/CD-CCSD(T) method are described in Ref. [DePrince:2013:2687].; The DF-CCSD(T) procedure uses two auxiliary basis sets. The first set is; that used in the SCF procedure, defined by the DF_BASIS_SCF; keyword. If this keyword is not specified, an appropriate -JKFIT set is; automatically selected. This auxiliary set defines the ERI’s used to; build the Fock matrix used in the DF-CCSD(T) procedure. The second; auxiliary set is used to approximate all other ERI’s in the DF-CCSD(T); procedure. The choice of auxiliary basis is controlled by the keyword; DF_BASIS_CC. By default, DF_BASIS_CC is the RI set; (optimized for DFMP2) most appropriate for use with the primary basis.; For ex",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/fnocc-1.html:8558,reduce,reduce,8558,psi4manual/1.0.0/fnocc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/fnocc-1.html,2,['reduce'],['reduce']
Energy Efficiency," user_dertype is None:; dertype = 0; core.print_out(""\nGradient: Custom function passed in without a defined dertype, assuming fd-energy based gradient.\n""); else:; core.print_out(""\nGradient: Custom function passed in with a dertype of %d\n"" % user_dertype); dertype = user_dertype. if dertype == 1:; return name(gradient, kwargs.pop('label', 'custom function'), ptype='gradient', **kwargs); else:; optstash = driver_util._set_convergence_criterion('energy', 'scf', 8, 10, 8, 10, 8); lowername = name. elif gradient_type == 'cbs_wrapper':; cbs_methods = driver_cbs._cbs_wrapper_methods(**kwargs); dertype = min([_find_derivative_type('gradient', method, user_dertype) for method in cbs_methods]); if dertype == 1:; # Bounce to CBS (directly) in pure-gradient mode if name is CBS and all parts have analytic grad. avail.; return name(gradient, kwargs.pop('label', 'custom function'), ptype='gradient', **kwargs); else:; optstash = driver_util._set_convergence_criterion('energy', cbs_methods[0], 8, 10, 8, 10, 8); lowername = name; # Pass through to G by E. elif gradient_type == 'cbs_gufunc':; cbs_methods = driver_cbs._parse_cbs_gufunc_string(name.lower())[0]; dertype = min([_find_derivative_type('gradient', method, user_dertype) for method in cbs_methods]); lowername = name.lower(); if dertype == 1:; # Bounce to CBS in pure-gradient mode if ""method/basis"" name and all parts have analytic grad. avail.; return driver_cbs._cbs_gufunc(gradient, name, ptype='gradient', **kwargs); else:; # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash = driver_util._set_convergence_criterion('energy', cbs_methods[0], 8, 10, 8, 10, 8). else:; # Allow specification of methods to arbitrary order; lowername = name.lower(); lowername, level = driver_util.parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. # Prevent methods that do not have associated gradients; if lowername in energy_only_methods:; raise ValidationError(""gradi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html:35331,energy,energy,35331,psi4manual/1.1.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html,2,['energy'],['energy']
Energy Efficiency," user_dertype is None:; dertype = 0; psi4.print_out(""\nGradient: Custom function passed in without a defined dertype, assuming fd-energy based gradient.\n""); else:; psi4.print_out(""\nGradient: Custom function passed in with a dertype of %d\n"" % user_dertype); dertype = user_dertype. if dertype == 1:; return name(gradient, kwargs.pop('label', 'custom function'), ptype='gradient', **kwargs); else:; optstash = driver_util._set_convergence_criterion('energy', 'scf', 8, 10, 8, 10, 8); lowername = name. elif gradient_type == 'cbs_wrapper':; cbs_methods = driver_cbs._cbs_wrapper_methods(**kwargs); dertype = min([_find_derivative_type('gradient', method, user_dertype) for method in cbs_methods]); if dertype == 1:; # Bounce to CBS (directly) in pure-gradient mode if name is CBS and all parts have analytic grad. avail.; return name(gradient, kwargs.pop('label', 'custom function'), ptype='gradient', **kwargs); else:; optstash = driver_util._set_convergence_criterion('energy', cbs_methods[0], 8, 10, 8, 10, 8); lowername = name; # Pass through to G by E. elif gradient_type == 'cbs_gufunc':; cbs_methods = driver_cbs._parse_cbs_gufunc_string(name.lower())[0]; dertype = min([_find_derivative_type('gradient', method, user_dertype) for method in cbs_methods]); lowername = name.lower(); if dertype == 1:; # Bounce to CBS in pure-gradient mode if ""method/basis"" name and all parts have analytic grad. avail.; return driver_cbs._cbs_gufunc(gradient, name, ptype='gradient', **kwargs); else:; # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash = driver_util._set_convergence_criterion('energy', cbs_methods[0], 8, 10, 8, 10, 8). else:; # Allow specification of methods to arbitrary order; lowername = name.lower(); lowername, level = driver_util.parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. # Prevent methods that do not have associated gradients; if lowername in energy_only_methods:; raise ValidationError(""gradi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver.html:34100,energy,energy,34100,psi4manual/1.0.0/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver.html,1,['energy'],['energy']
Energy Efficiency," user_dertype) for method in cbs_methods]); if dertype == 1:; # Bounce to CBS (directly) in pure-gradient mode if name is CBS and all parts have analytic grad. avail.; return name(gradient, kwargs.pop('label', 'custom function'), ptype='gradient', **kwargs); else:; optstash = driver_util._set_convergence_criterion('energy', cbs_methods[0], 8, 10, 8, 10, 8); lowername = name; # Pass through to G by E. elif gradient_type == 'cbs_gufunc':; cbs_methods = driver_cbs._parse_cbs_gufunc_string(name.lower())[0]; dertype = min([_find_derivative_type('gradient', method, user_dertype) for method in cbs_methods]); lowername = name.lower(); if dertype == 1:; # Bounce to CBS in pure-gradient mode if ""method/basis"" name and all parts have analytic grad. avail.; return driver_cbs._cbs_gufunc(gradient, name, ptype='gradient', **kwargs); else:; # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash = driver_util._set_convergence_criterion('energy', cbs_methods[0], 8, 10, 8, 10, 8). else:; # Allow specification of methods to arbitrary order; lowername = name.lower(); lowername, level = driver_util.parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. # Prevent methods that do not have associated gradients; if lowername in energy_only_methods:; raise ValidationError(""gradient('%s') does not have an associated gradient"" % name). dertype = _find_derivative_type('gradient', lowername, user_dertype). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash = driver_util._set_convergence_criterion('energy', lowername, 8, 10, 8, 10, 8). # Commit to procedures[] call hereafter; return_wfn = kwargs.pop('return_wfn', False); core.clean_variables(). # no analytic derivatives for scf_type cd; if core.get_global_option('SCF_TYPE') == 'CD':; if (dertype == 1):; raise ValidationError(""""""No analytic derivatives for SCF_TYPE CD.""""""). # Make sure the molecule the user provide",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html:39442,energy,energy,39442,psi4manual/1.3.2/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html,2,['energy'],['energy']
Energy Efficiency," user_dertype) for method in cbs_methods]); if dertype == 1:; # Bounce to CBS (directly) in pure-gradient mode if name is CBS and all parts have analytic grad. avail.; return name(gradient, kwargs.pop('label', 'custom function'), ptype='gradient', **kwargs); else:; optstash = driver_util._set_convergence_criterion('energy', cbs_methods[0], 8, 10, 8, 10, 8); lowername = name; # Pass through to G by E. elif gradient_type == 'cbs_gufunc':; cbs_methods = driver_cbs._parse_cbs_gufunc_string(name.lower())[0]; dertype = min([_find_derivative_type('gradient', method, user_dertype) for method in cbs_methods]); lowername = name.lower(); if dertype == 1:; # Bounce to CBS in pure-gradient mode if ""method/basis"" name and all parts have analytic grad. avail.; return driver_cbs._cbs_gufunc(gradient, name, ptype='gradient', **kwargs); else:; # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash = driver_util._set_convergence_criterion('energy', cbs_methods[0], 8, 10, 8, 10, 8). else:; # Allow specification of methods to arbitrary order; lowername = name.lower(); lowername, level = driver_util.parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. # Prevent methods that do not have associated gradients; if lowername in energy_only_methods:; raise ValidationError(""gradient('%s') does not have an associated gradient"" % name). dertype = _find_derivative_type('gradient', lowername, user_dertype). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash = driver_util._set_convergence_criterion('energy', lowername, 8, 10, 8, 10, 8). # Commit to procedures[] call hereafter; return_wfn = kwargs.pop('return_wfn', False); core.clean_variables(). # no analytic derivatives for scf_type cd; if core.get_option('SCF', 'SCF_TYPE') == 'CD':; if (dertype == 1):; raise ValidationError(""""""No analytic derivatives for SCF_TYPE CD.""""""). # Make sure the molecule the user provide",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html:36007,energy,energy,36007,psi4manual/1.1.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html,1,['energy'],['energy']
Energy Efficiency," user_dertype) for method in cbs_methods]); if dertype == 1:; # Bounce to CBS (directly) in pure-gradient mode if name is CBS and all parts have analytic grad. avail.; return name(gradient, kwargs.pop('label', 'custom function'), ptype='gradient', **kwargs); else:; optstash = driver_util._set_convergence_criterion('energy', cbs_methods[0], 8, 10, 8, 10, 8); lowername = name; # Pass through to G by E. elif gradient_type == 'cbs_gufunc':; cbs_methods = driver_cbs._parse_cbs_gufunc_string(name.lower())[0]; dertype = min([_find_derivative_type('gradient', method, user_dertype) for method in cbs_methods]); lowername = name.lower(); if dertype == 1:; # Bounce to CBS in pure-gradient mode if ""method/basis"" name and all parts have analytic grad. avail.; return driver_cbs._cbs_gufunc(gradient, name, ptype='gradient', **kwargs); else:; # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash = driver_util._set_convergence_criterion('energy', cbs_methods[0], 8, 10, 8, 10, 8). else:; # Allow specification of methods to arbitrary order; lowername = name.lower(); lowername, level = driver_util.parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. # Prevent methods that do not have associated gradients; if lowername in energy_only_methods:; raise ValidationError(""gradient('%s') does not have an associated gradient"" % name). dertype = _find_derivative_type('gradient', lowername, user_dertype). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash = driver_util._set_convergence_criterion('energy', lowername, 8, 10, 8, 10, 8). # Commit to procedures[] call hereafter; return_wfn = kwargs.pop('return_wfn', False); psi4.clean_variables(). # no analytic derivatives for scf_type cd; if psi4.get_option('SCF', 'SCF_TYPE') == 'CD':; if (dertype == 1):; raise ValidationError(""""""No analytic derivatives for SCF_TYPE CD.""""""). # Make sure the molecule the user provide",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver.html:34776,energy,energy,34776,psi4manual/1.0.0/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver.html,1,['energy'],['energy']
Energy Efficiency," using a Z-matrix with variables that are updated during the potential energy surface scan, and then the same procedure is performed using polar coordinates, converted to Cartesian coordinates. cfour/kw-4; Basis set spherical/Cartesian with basis and puream. cfour/mp2-1; All-electron MP2 6-31G** geometry optimization of water. cfour/psi-rhf-mp3; MP3 energy components. Checks that computed identically between cfour and psi4. cfour/sp-rohf-ccsd_t_-fc; single-point CCSD(T)/qz2p on NH2 with ecc, aobasis, frozen-core. cfour/sp-rhf-mp2; single-point MP2/qz2p on water. cfour/pywrap-cbs1; Various basis set extrapolation tests only in Cfour instead of Psi4. cfour/sp-rohf-mp2-sc; single-point MP2/qz2p on NH2. cfour/kw-3; Basis set spherical/Cartesian with cfour_basis and cfour_spherical. cfour/opt-rhf-ccsd_t_-ecc; optimization CCSD(T)/dzp on water with ecc, aobasis. cfour/sp-rhf-ccsd_t_-ao; single-point CCSD(T)/qz2p on water with aobasis. cfour/dfmp2-1; MP2/cc-PVDZ computation of formic acid dimer binding energy using automatic counterpoise correction. Monomers are specified using Cartesian coordinates. cfour/sp-rhf-ccsd_t_; single-point CCSD(T)/qz2p on water. cfour/sp-rohf-ccsd_t_-ao; single-point CCSD(T)/qz2p on NH2 with aobasis. cfour/sp-rhf-cc3; single-point CC3/qz2p on water. cfour/sp-rhf-ccsd_t_-ao-ecc; single-point CCSD(T)/qc2p on water with ecc, aobasis. cfour/psi-rhf-scsmp2; MP2 energy components. Checks that computed identically between cfour and psi4. cfour/sp-rhf-ccsdt; single-point CCSDT/qz2p on water. cfour/sp-rohf-ccsdt; single-point CCSDT/qz2p on NH2. cfour/psi-mp4; MP4 energy components. Checks that computed identically between cfour and psi4. cfour/sp-rhf-ccsd_t_-fc; single-point CCSD(T)/qz2p on water with ecc, aobasis, and frozen-core. cfour/psi-ghost-grad; MP2 optimization of dimers with one momomer ghosted. Gradients after three opt cycles are compared with those from psi4. cfour/sp-rohf-scf; single-point HF/qz2p on NH2. cfour/psi-rohf-scsmp2; ROHF MP2 en",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_cfour.html:1718,energy,energy,1718,psi4manual/1.6.x/autodoc_testsuite_cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_cfour.html,1,['energy'],['energy']
Energy Efficiency," using integrals stored on disk. mp2-def2; Test case for Binding Energy of C4H5N (Pyrrole) with CO2 using MP2/def2-TZVPP. dcft-grad3; Restricted DF-DCFT ODC-12 gradient for ethylene with cc-pVDZ/cc-pVDZ-RI standard/auxiliary basis set. cepa0-grad1; CEPA0 cc-pVDZ gradient for the H2O molecule. mp3-grad1; MP3 cc-pVDZ gradient for the H2O molecule. nbody-he-cluster; MP2/aug-cc-pv[DT]Z many body energies of an arbitrary Helium complex Size vs cost tradeoff is rough here. cc13d; Tests analytic CC2 gradients. scf5; Test of all different algorithms and reference types for SCF, on singlet and triplet O2, using the cc-pVTZ basis set. omp2-3; OMP2 cc-pVDZ energy for the NO radical. scf2; RI-SCF cc-pVTZ energy of water, with Z-matrix input and cc-pVTZ-RI auxilliary basis. cc36; CC2(RHF)/cc-pVDZ energy of H2O. mints3; Test individual integral objects for correctness. options1; check all variety of options parsing. cc5a; RHF CCSD(T) STO-3G frozen-core energy of C4NH4 Anion. omp2-1; OMP2 cc-pVDZ energy for the H2O molecule. cc19; CCSD/cc-pVDZ dipole polarizability at two frequencies. ocepa-grad1; OCEPA cc-pVDZ gradient for the H2O molecule. dfccsdat1; DF-CCSD(AT) cc-pVDZ energy for the H2O molecule. dcft4; DCFT calculation for the HF+ using DC-06 functional. This performs both two-step and simultaneous update of the orbitals and cumulant using DIIS extrapolation. Four-virtual integrals are first handled in the MO Basis for the first two energy computations. In the next two the ao_basis=disk algorithm is used, where the transformation of integrals for four-virtual case is avoided. The computation is then repeated using the DC-12 functional with the same algorithms. mp2-module; OMP2 cc-pVDZ energy for the H2O molecule. cc28; CCSD/cc-pVDZ optical rotation calculation (length gauge only) on Z-mat H2O2. fnocc1; Test QCISD(T) for H2O/cc-pvdz Energy. dfccd1; DF-CCD cc-pVDZ energy for the H2O molecule. opt2-fd; SCF DZ allene geometry optimzation, with Cartesian input. dfomp2-2; OMP2 cc-p",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/testsuite-1.html:5987,energy,energy,5987,psi4manual/1.1.0/testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/testsuite-1.html,8,['energy'],['energy']
Energy Efficiency," using integrals stored on disk. mp2-def2; Test case for Binding Energy of C4H5N (Pyrrole) with CO2 using MP2/def2-TZVPP. dcft-grad3; Restricted DF-DCFT ODC-12 gradient for ethylene with cc-pVDZ/cc-pVDZ-RI standard/auxiliary basis set. cepa0-grad1; CEPA0 cc-pVDZ gradient for the H2O molecule. mp3-grad1; MP3 cc-pVDZ gradient for the H2O molecule. nbody-he-cluster; MP2/aug-cc-pv[DT]Z many body energies of an arbitrary Helium complex Size vs cost tradeoff is rough here. cc13d; Tests analytic CC2 gradients. scf5; Test of all different algorithms and reference types for SCF, on singlet and triplet O2, using the cc-pVTZ basis set. omp2-3; OMP2 cc-pVDZ energy for the NO radical. scf2; RI-SCF cc-pVTZ energy of water, with Z-matrix input and cc-pVTZ-RI auxilliary basis. cc36; CC2(RHF)/cc-pVDZ energy of H2O. mints3; Test individual integral objects for correctness. options1; check all variety of options parsing. cc5a; RHF CCSD(T) STO-3G frozen-core energy of C4NH4 Anion. omp2-1; OMP2 cc-pVDZ energy for the H2O molecule. cc19; CCSD/cc-pVDZ dipole polarizability at two frequencies. ocepa-grad1; OCEPA cc-pVDZ gradient for the H2O molecule. dfccsdat1; DF-CCSD(AT) cc-pVDZ energy for the H2O molecule. dcft4; DCFT calculation for the HF+ using DC-06 functional. This performs both two-step and simultaneous update of the orbitals and cumulant using DIIS extrapolation. Four-virtual integrals are first handled in the MO Basis for the first two energy computations. In the next two the ao_basis=disk algorithm is used, where the transformation of integrals for four-virtual case is avoided. The computation is then repeated using the DC-12 functional with the same algorithms. mp2-module; OMP2 cc-pVDZ energy for the H2O molecule. cc28; CCSD/cc-pVDZ optical rotation calculation (length gauge only) on Z-mat H2O2. fnocc1; Test QCISD(T) for H2O/cc-pvdz Energy. dft-bench-interaction; functionals + DFTD3 interaction energies vs. other programs. dfccd1; DF-CCD cc-pVDZ energy for the H2O molecule. op",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html:5948,energy,energy,5948,psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency," value from SCS-CCSD. Type: double; Default: 1.13. CEPA_TYPE¶. CEPA type such as CEPA0, CEPA1 etc. currently we have only CEPA0. Type: string; Possible Values: CEPA0; Default: CEPA0. CUTOFF¶. Cutoff value for numerical procedures. Type: integer; Default: 14. DO_DIIS¶. Do apply DIIS extrapolation?. Type: boolean; Default: true. DO_LEVEL_SHIFT¶. Do apply level shifting?. Type: boolean; Default: true. DO_SCS¶. Do perform spin-component-scaled OMP2 (SCS-OMP2)? In all computation, SCS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SCS-OMP2, one needs to set ‘DO_SCS’ to true. Type: boolean; Default: false. DO_SOS¶. Do perform spin-opposite-scaled OMP2 (SOS-OMP2)? In all computation, SOS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SOS-OMP2, one needs to set ‘DO_SOS’ to true. Type: boolean; Default: false. E3_SCALE¶. Scaling value for 3rd order energy correction (S. Grimme, Vol. 24, pp. 1529, J. Comput. Chem.). Type: double; Default: 0.25. EA_POLES¶. Do compute OCC poles for electron affinities? Only valid for OMP2. Type: boolean; Default: false. EKT_EA¶. Do compute virtual orbital energies based on extended Koopmans’ theorem?. Type: boolean; Default: false. EKT_IP¶. Do compute occupied orbital energies based on extended Koopmans’ theorem?. Type: boolean; Default: false. EP_EA_POLES¶. Do compute EP-OCC poles for electron affinities? Only valid for OMP2. Type: boolean; Default: false. EP_IP_POLES¶. Do compute EP-OCC poles for ionization potentials? Only valid OMP2. Type: boolean; Default: false. EP_MAXITER¶. Maximum number of electron propagator iterations. Type: integer; Default: 30. E_CONVERGENCE¶. Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. IP_POLES¶. Do compute OCC poles for ionization potentials? On",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__occ-1.html:2413,energy,energy,2413,psi4manual/1.3.2/autodir_options_c/module__occ-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__occ-1.html,10,['energy'],['energy']
Energy Efficiency," value from SCS-CCSD. Type: double; Default: 1.13. CEPA_TYPE¶. CEPA type such as CEPA0, CEPA1 etc. currently we have only CEPA0. Type: string; Possible Values: CEPA0; Default: CEPA0. CUTOFF¶. Cutoff value for numerical procedures. Type: integer; Default: 14. DO_DIIS¶. Do apply DIIS extrapolation?. Type: boolean; Default: true. DO_LEVEL_SHIFT¶. Do apply level shifting?. Type: boolean; Default: true. DO_SCS¶. Do perform spin-component-scaled OMP2 (SCS-OMP2)? In all computation, SCS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SCS-OMP2, one needs to set ‘DO_SCS’ to true. Type: boolean; Default: false. DO_SOS¶. Do perform spin-opposite-scaled OMP2 (SOS-OMP2)? In all computation, SOS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SOS-OMP2, one needs to set ‘DO_SOS’ to true. Type: boolean; Default: false. E3_SCALE¶. Scaling value for 3rd order energy correction (S. Grimme, Vol. 24, pp. 1529, J. Comput. Chem.). Type: double; Default: 0.25. EA_POLES¶. Do compute OCC poles for electron affinities? Only valid for OMP2. Type: boolean; Default: false. EKT_EA¶. Do compute virtual orbital energies based on extended Koopmans’ theorem?. Type: boolean; Default: false. EKT_IP¶. Do compute occupied orbital energies based on extended Koopmans’ theorem?. Type: boolean; Default: false. EP_EA_POLES¶. Do compute EP-OCC poles for electron affinities? Only valid for OMP2. Type: boolean; Default: false. EP_IP_POLES¶. Do compute EP-OCC poles for ionization potentials? Only valid OMP2. Type: boolean; Default: false. EP_MAXITER¶. Maximum number of electron propagator iterations. Type: integer; Default: 30. E_CONVERGENCE¶. Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-8. IP_POLES¶. Do compute OCC poles for ionization potentials? On",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodir_options_c/module__occ-1.html:2428,energy,energy,2428,psi4manual/4.0b4/autodir_options_c/module__occ-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodir_options_c/module__occ-1.html,2,['energy'],['energy']
Energy Efficiency," valueHI.clone(); beta.name = 'Truhlar SCF (%s, %s) beta' % (zLO, zHI); beta.subtract(valueLO); beta.scale(beta_division); beta.scale(beta_mult). value = valueHI.clone(); value.subtract(beta); value.name = 'Truhlar SCF (%s, %s) data' % (zLO, zHI). if verbose > 2:; core.print_out(""""""\n ==> Truhlar 2-point power from SCF extrapolation for method: %s <==\n\n"""""" % (functionname.upper())); core.print_out("""""" LO-zeta (%s)"""""" % str(zLO)); core.print_out("""""" LO-zeta Data""""""); valueLO.print_out(); core.print_out("""""" HI-zeta (%s)"""""" % str(zHI)); core.print_out("""""" HI-zeta Data""""""); valueHI.print_out(); core.print_out("""""" Extrapolated Data:\n""""""); value.print_out(); core.print_out("""""" Alpha (exponent) Value: %16.8f\n"""""" % (alpha)); core.print_out("""""" Beta Data:\n""""""); beta.print_out(). return value. else:; raise ValidationError(""scf_xtpl_truhlar_2: datatype is not recognized '%s'."" % type(valueLO)). def scf_xtpl_karton_2(functionname, zLO, valueLO, zHI, valueHI, verbose=True, alpha=None):; r""""""Extrapolation scheme using root-power form for reference energies with two adjacent zeta-level bases.; Used by :py:func:`~psi4.cbs`.; Karton, Martin, Theor. Chem. Acc. 115 (2006) 330-333, DOI: 10.1007/s00214-005-0028-6. .. math:: E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha\sqrt{X}}, \alpha = 6.3. """""". if type(valueLO) != type(valueHI):; raise ValidationError(""scf_xtpl_karton_2: Inputs must be of the same datatype! (%s, %s)""; % (type(valueLO), type(valueHI))). if alpha is None:; alpha = 6.30. beta_division = 1 / (math.exp(-1 * alpha) * (math.exp(math.sqrt(zHI)) - math.exp(math.sqrt(zLO)))); beta_mult = math.exp(-1 * alpha * math.sqrt(zHI)). if isinstance(valueLO, float):; beta = (valueHI - valueLO) * beta_division; value = valueHI - beta * beta_mult. if verbose:; # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> Karton 2-point power form SCF extrapolation for method: %s <==\n\n"""""" % (functionname.upper()); cbsscheme += """""" LO-zeta (%s) Energy: %",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html:11315,power,power,11315,psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html,1,['power'],['power']
Energy Efficiency," values. IntegralFactory; Computes integrals. IntegralTransform; IntegralTransform transforms one- and two-electron integrals within general spaces. IrreducibleRepresentation; An irreducible representation of the point group. JK; docstring. KineticInt; Computes kinetic integrals. LS_THC_Computer; Computer class for grid-based tensor hypercontraction (THC) of two-electron integrals (Parrish 2012). LaplaceDenominator; Computer class for a Laplace factorization of the four-index energy denominator in MP2 and coupled-cluster. LibXCFunctional; docstring. Localizer; Class containing orbital localization procedures. MOSpace; Defines orbital spaces in which to transform integrals. MOWriter; Writes the MOs. Matrix; Class for creating and manipulating matrices. MatrixFactory; Creates Matrix objects. MemDFJK; docstring. MintsHelper; Computes integrals. MoldenWriter; Writes wavefunction information in molden format. MolecularGrid; docstring. Molecule; Class to store the elements, coordinates, fragmentation pattern, basis sets, charge, multiplicity, etc. MultipoleInt; Computes arbitrary-order multipole integrals. MultipoleSymmetry; docstring. NablaInt; Computes nabla integrals. NumIntHelper; Computes numerical integrals using a DFT grid. OEProp; docstring. OneBodyAOInt; Basis class for all one-electron integrals. OneBodySOInt. Options; docstring. OrbitalSpace; Contains information about the orbitals. OverlapInt; Computes overlap integrals. PMLocalizer; Performs Pipek-Mezey orbital localization. PetiteList; Handles symmetry transformations. PointFunctions; docstring. PointGroup; Contains information about the point group. PotentialInt; Computes potential integrals. PrimitiveType; May be Normalized or Unnormalized. Prop; docstring. ProtoIntVector. ProtoVector. PsiReturnType; Return status. QuadrupoleInt; Computes quadrupole integrals. RHF; docstring. RKSFunctions; docstring. ROHF; docstring. SADGuess; docstring. SOBasisSet; An SOBasis object describes the transformation from an at",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/psi4api.html:13629,charge,charge,13629,psi4manual/master/psi4api.html,https://psicode.org,https://psicode.org/psi4manual/master/psi4api.html,1,['charge'],['charge']
Energy Efficiency," values; should be of correct type, strings for strings, floats for floats like; convergences. The function ~psi4.core.clean_options that reinitializes; all options may also be useful to separate calculations in a PsiAPI; session.; 1; 2; 3; 4; 5; 6; 7; 8; 9psi4.set_options({; 'scf_type': 'pk',; 'e_convergence': 1.e-5,; 'soscf': True; }). psi4.set_module_options({; 'geom_maxiter': 50; }). Basis Sets¶. Basis Sets; Built-In Basis Sets; Mixing Basis Sets; Decontracted Basis Sets; User-Defined Basis Sets; Inputting effective core potentials (ECPs). PSI Variables¶; To harness the power of Python, PSI4 makes the most pertinent results; of each computation available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of; H2 and H atom:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19molecule h2 {; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h {; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol * (2*h_energy - h2_energy); print ""De=%f"" % D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module, and PSI Variables by Alpha defines them. These can be; accessed through the get_variable() function. For example, after; performing a density fitted MP2 computation, both the spin component; scaled energy and the unscaled MP2 energy are made available:; 1; 2e_mp2 = get_variable('MP2 TOTAL ENERGY'); e_scs_mp2 = get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the ou",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:9737,energy,energy,9737,psi4manual/1.2.1/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html,4,['energy'],['energy']
Energy Efficiency," variables:. CBS TOTAL ENERGY; CBS REFERENCE ENERGY; CBS CORRELATION ENERGY; CURRENT ENERGY; CURRENT REFERENCE ENERGY; CURRENT CORRELATION ENERGY. Caution; Some features are not yet implemented. Buy a developer a coffee. Not all methods hooked in through PSI variables, configuration interaction and arbitrary order MP in particular.; No scheme defaults for given basis zeta number, so scheme must be specified explicitly.; No way to tell function to boost fitting basis size for all calculations.; No way to extrapolate def2 family basis sets; Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in four; sequential stages (scf, corl, delta, delta2) covering treatment of the; reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction. Each is activated by its; stage_wfn keyword and is only allowed if all preceding stages are active. Here, is an energy or energy extrapolation scheme, and the following also hold. A translation of this ungainly equation to example [5] below is as; follows. In words, this is a double- and triple-zeta 2-point; Helgaker-extrapolated CCSD(T) coupled-cluster correlation correction; appended to a triple- and quadruple-zeta 2-point; Helgaker-extrapolated MP2 correlation energy appended to a SCF/aug-cc-pVQZ; reference energy. Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy.; The cbs() function requires, at a minimum, name='scf' and scf_basis; keywords to be specified for reference-step only jobs and name and; corl_basis keywords for correlated jobs.; The following energy methods have been set up for cbs(). scf; df-scf. mp2; df-mp2. cc2; ccsd. bccd; cc3. ccsd(t); fci. Parameters:; name (string) – 'scf' || 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/cbs-1.html:1685,energy,energy,1685,psi4manual/4.0b2/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/cbs-1.html,4,['energy'],['energy']
Energy Efficiency," variables:. CBS TOTAL ENERGY; CBS REFERENCE ENERGY; CBS CORRELATION ENERGY; CURRENT ENERGY; CURRENT REFERENCE ENERGY; CURRENT CORRELATION ENERGY. Caution; Some features are not yet implemented. Buy a developer a coffee. Not all methods hooked in through PSI variables, configuration interaction and arbitrary order MP in particular.; No scheme defaults for given basis zeta number, so scheme must be specified explicitly.; No way to tell function to boost fitting basis size for all calculations.; No way to extrapolate def2 family basis sets; Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in four; sequential stages (scf, corl, delta, delta2) covering treatment of the; reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction. Each is activated by its; stage_wfn keyword and is only allowed if all preceding stages are active. Here, is an energy or energy extrapolation scheme, and the following also hold. A translation of this ungainly equation to example [5] below is as; follows. In words, this is a double- and triple-zeta 2-point; Helgaker-extrapolated CCSD(T) coupled-cluster correlation correction; appended to a triple- and quadruple-zeta 2-point; Helgaker-extrapolated MP2 correlation energy appended to a SCF/aug-cc-pVQZ; reference energy. Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy.; The cbs() function requires, at a minimum, name='scf' and scf_basis; keywords to be specified for reference-step only jobs and name and; corl_basis keywords for correlated jobs.; The following energy methods have been set up for cbs(). scf; mp2; mp2.5; mp3; mp4(sdq); mp4. omp2; omp3; ocepa; cepa0; cepa(0); cepa(1). cepa(3); acpf; aqcc; qcisd; cc2; ccsd. fno-df-ccsd; bccd; cc3; qcisd(t); ccsd(t); fno-df-ccsd(t). bccd(t);",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/cbs-1.html:1700,energy,energy,1700,psi4manual/4.0b4/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/cbs-1.html,4,['energy'],['energy']
Energy Efficiency," variety of options parsing. cc5a; RHF CCSD(T) STO-3G frozen-core energy of C4NH4 Anion. omp2-1; OMP2 cc-pVDZ energy for the H2O molecule. cc19; CCSD/cc-pVDZ dipole polarizability at two frequencies. ocepa-grad1; OCEPA cc-pVDZ gradient for the H2O molecule. dfccsdat1; DF-CCSD(AT) cc-pVDZ energy for the H2O molecule. dcft4; DCFT calculation for the HF+ using DC-06 functional. This performs both two-step and simultaneous update of the orbitals and cumulant using DIIS extrapolation. Four-virtual integrals are first handled in the MO Basis for the first two energy computations. In the next two the ao_basis=disk algorithm is used, where the transformation of integrals for four-virtual case is avoided. The computation is then repeated using the DC-12 functional with the same algorithms. mp2-module; OMP2 cc-pVDZ energy for the H2O molecule. cc28; CCSD/cc-pVDZ optical rotation calculation (length gauge only) on Z-mat H2O2. fnocc1; Test QCISD(T) for H2O/cc-pvdz Energy. dfccd1; DF-CCD cc-pVDZ energy for the H2O molecule. opt2-fd; SCF DZ allene geometry optimzation, with Cartesian input. dfomp2-2; OMP2 cc-pVDZ energy for the NO molecule. dcft6; DCFT calculation for the triplet O2 using DC-06, DC-12 and CEPA0 functionals. Only two-step algorithm is tested. dfep2-2; Compute three IP and 2 EA’s for the PH3 molecule. pywrap-bfs; apply linear fragmentation algorithm to a water cluster. omp3-grad1; OMP3 cc-pVDZ gradient for the H2O molecule. pywrap-freq-g-sowreap; Finite difference of gradients frequency, run in sow/reap mode. dfmp2-ecp; Ne-Xe dimer MP2 energies with ECP, with electrons correlated then frozen. scf-dipder; Test SCF dipole derivatives against old Psi3 reference values. cc48; reproduces dipole moments in J.F. Stanton’s “biorthogonal” JCP paper. dfccd-grad1; DF-CCSD cc-pVDZ gradients for the H2O molecule. mints9; A test of the basis specification. Various basis sets are specified outright and in blocks, both orbital and auxiliary. Constructs libmints BasisSet objects th",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html:7461,energy,energy,7461,psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency," variety of options parsing. cc5a; RHF CCSD(T) STO-3G frozen-core energy of C4NH4 Anion. omp2-1; OMP2 cc-pVDZ energy for the H2O molecule. cc19; CCSD/cc-pVDZ dipole polarizability at two frequencies. ocepa-grad1; OCEPA cc-pVDZ gradient for the H2O molecule. dfccsdat1; DF-CCSD(AT) cc-pVDZ energy for the H2O molecule. dcft4; DCFT calculation for the HF+ using DC-06 functional. This performs both two-step and simultaneous update of the orbitals and cumulant using DIIS extrapolation. Four-virtual integrals are first handled in the MO Basis for the first two energy computations. In the next two the ao_basis=disk algorithm is used, where the transformation of integrals for four-virtual case is avoided. The computation is then repeated using the DC-12 functional with the same algorithms. mp2-module; OMP2 cc-pVDZ energy for the H2O molecule. cc28; CCSD/cc-pVDZ optical rotation calculation (length gauge only) on Z-mat H2O2. fnocc1; Test QCISD(T) for H2O/cc-pvdz Energy. dfccd1; DF-CCD cc-pVDZ energy for the H2O molecule. opt2-fd; SCF DZ allene geometry optimzation, with Cartesian input. dfomp2-2; OMP2 cc-pVDZ energy for the NO molecule. dcft6; DCFT calculation for the triplet O2 using DC-06, DC-12 and CEPA0 functionals. Only two-step algorithm is tested. omp3-grad1; OMP3 cc-pVDZ gradient for the H2O molecule. pywrap-freq-g-sowreap; Finite difference of gradients frequency, run in sow/reap mode. cc48; reproduces dipole moments in J.F. Stanton’s “biorthogonal” JCP paper. dfccd-grad1; DF-CCSD cc-pVDZ gradients for the H2O molecule. mints9; A test of the basis specification. Various basis sets are specified outright and in blocks, both orbital and auxiliary. Constructs libmints BasisSet objects through the constructor that calls qcdb.BasisSet infrastructure. Checks that the resulting bases are of the right size and checks that symmetry of the Molecule observes the basis assignment to atoms. cc31; CCSD/sto-3g optical rotation calculation (both gauges) at two frequencies on methylo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/testsuite-1.html:6875,energy,energy,6875,psi4manual/1.1.0/testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/testsuite-1.html,4,['energy'],['energy']
Energy Efficiency," via analytic gradients. cbs-xtpl-func; optimization with method defined via cbs. omp3-2; OMP3 cc-pCVDZ energy with ROHF initial guess for the NO radical. dfmp2-fc; Kr–Kr nocp energies with all-electron basis set to check frozen core. scf-occ; force occupations in scf. cdoremp-energy2; density fitted OO-REMP/cc-pVDZ engrad single points for the H2O+ molecule. dft-b2plyp; Double-hybrid density functional B2PYLP. Reproduces portion of Table I in S. Grimme’s J. Chem. Phys 124 034108 (2006) paper defining the functional. cc5; RHF CCSD(T) cc-pVDZ frozen-core energy of C4NH4 Anion. aediis-2; EDIIS test case from 10.1063/1.1470195. sapt7; SAPT0 open-shell computation of H2O-HO2 interaction energy First with cc-pVDZ and density fitted integrals with UHF Then with 6-31g and direct integrals, except for dispersion that is computed with cc-pVDZ-ri density fitting with UHF. isapt2; This is a shorter version if isapt1 - does not do cube plots. See isapt1 for full details. dfccsd1; DF-CCSD cc-pVDZ energy for the H2O molecule. nbody-freq; Vibrational and thermo analysis of water trimer (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). fci-coverage; 6-31G H2O Test for coverage. dlpnomp2-1; comparison of DF-MP2 and DLPNO-MP2. opt5; 6-31G** UHF CH2 3B1 optimization. Uses a Z-Matrix with dummy atoms, just for demo and testing purposes. dfmp2-ecp; Ne-Xe dimer MP2 energies with ECP, with electrons correlated then frozen. sapt-exch-ind-inf; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. mbis-4; MBIS calculation on NaCl. cisd-opt-fd; H2O CISD/6-31G** Optimize Geometry by Energies. dfmp2-grad2; DF-MP2 cc-pVDZ gradient for the NO molecule. dfomp3-grad1; DF-OMP3 cc-pVDZ gradients for the H2O molecule. dfomp2-3; OMP2 cc-pVDZ energy for the H2O molecule. pywrap-cbs1; Various basis set extrapolation tests. dct-grad1; Various DCT analytic gradients for the O2 molecule with 6-31G basis set. opt-full-hess-every; SCF/sto-3g optimization with a hessian every step. dct1",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html:35590,energy,energy,35590,psi4manual/master/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency," vscf). # Load the iface file; iface = open('iface', 'r'); iface_contents = iface.read(). # Delete mrcc tempdir; os.chdir('..'); try:; # Delete unless we're told not to; if (keep == False and not('path' in kwargs)):; shutil.rmtree(mrcc_tmpdir); except OSError as e:; print('Unable to remove MRCC temporary directory %s' % e, file=sys.stderr); exit(1). # Revert to previous current directory location; os.chdir(current_directory). # Reopen output file; psi4.reopen_outfile(). # If we're told to keep the files or the user provided a path, do nothing.; if (keep != False or ('path' in kwargs)):; psi4.print_out('\nMRCC scratch files have been kept.\n'); psi4.print_out('They can be found in ' + mrcc_tmpdir). # Dump iface contents to output; psi4.print_out('\n'); p4util.banner('Full results from MRCC'); psi4.print_out('\n'); psi4.print_out(iface_contents). return e. [docs]def run_fnodfcc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a DF-CCSD(T) computation. >>> energy('df-ccsd(t)'). """"""; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs). # stash user options; optstash = p4util.OptionsState(; ['FNOCC','COMPUTE_TRIPLES'],; ['FNOCC','DFCC'],; ['FNOCC','NAT_ORBS'],; ['FNOCC','RUN_CEPA'],; ['SCF','DF_BASIS_SCF'],; ['SCF','DF_INTS_IO'],; ['SCF','SCF_TYPE']). psi4.set_local_option('FNOCC', 'DFCC', True); psi4.set_local_option('FNOCC', 'RUN_CEPA', False). # throw an exception for open-shells; if (psi4.get_option('SCF','REFERENCE') != 'RHF' ):; raise ValidationError(""Error: %s requires \""reference rhf\""."" % lowername). # override symmetry:; molecule = psi4.get_active_molecule(); user_pg = molecule.schoenflies_symbol(); molecule.reset_point_group('c1'); molecule.fix_orientation(1); molecule.update_geometry(); if user_pg != 'c1':; psi4.print_out(' FNOCC does not make use of molecular symmetry, further calculations in C1 point group.\n'). # hack to ensure puream (or not) throughout; psi4.set_global_option('PUREAM', psi4.MintsHelper().basisset().has_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/proc.html:63671,energy,energy,63671,psi4manual/4.0b5/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html,1,['energy'],['energy']
Energy Efficiency," water energies - conventional integrals version. x2c3; Test of SFX2C-1e on Water uncontracted cc-pVDZ The reference numbers are from Lan Cheng’s implementation in Cfour. nbody-nocp-gradient; Computation of NoCP-corrected water trimer gradient (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). scf-response1; Compute the dipole, quadrupole, and traceless quadrupoles for water. rasci-c2-active; 6-31G* C2 Test RASCI Energy Point, testing two different ways of specifying the active space, either with the ACTIVE keyword, or with RAS1, RAS2, RESTRICTED_DOCC, and RESTRICTED_UOCC. cc53; Matches Table II a-CCSD(T)/cc-pVDZ H2O @ 2.5 * Re value from Crawford and Stanton, IJQC 98, 601-611 (1998). opt1-fd; SCF STO-3G geometry optimzation, with Z-matrix input, by finite-differences. scf-hess1; RHF STO-3G (Cartesian) and cc-pVDZ (spherical) water Hessian test, against Psi3 reference values. olccd-grad1; OLCCD cc-pVDZ gradient for the H2O molecule. cc4a; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. This version tests the FROZEN_DOCC option explicitly. cc55; EOM-CCSD/6-31g excited state transition data for water with two excited states per irrep. cc46; EOM-CC2/cc-pVDZ on H2O2 with two excited states in each irrep. dft2; DFT Functional Test. scf6; Tests RHF/ROHF/UHF SCF gradients. scf-guess-read3; Test if the the guess read in the same basis converges. opt2; SCF DZ allene geometry optimization, with Cartesian input, first in c2v symmetry, then in Cs symmetry from a starting point with a non-linear central bond angle. tdscf-1; td-uhf test on triplet states of methylene (rpa). mbis-4; MBIS calculation on NaCl. tu6-cp-ne2; Example potential energy surface scan and CP-correction for Ne2. mints5; Tests to determine full point group symmetry. Currently, these only matter for the rotational symmetry number in thermodynamic computations. gibbs; Test Gibbs free energies at 298 K of N2, H2O, and CH4. opt2-fd; SCF DZ allene geometry optimzation, wit",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html:14259,energy,energy,14259,psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency," we do a stability analysis for the open-shell monomer only; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; 35; 36; 37; 38; 39; 40; 41; 42; 43; 44; 45; 46; 47; 48; 49; 50; 51; 52; 53molecule {; 0 2; O 0.000000 0.000000 0.000000; O 0.000000 2.503900 0.000000; H 0.000000 -0.424700 -1.839500; --; 0 1; O 0.000000 0.000000 6.000000; H 0.000000 1.431500 4.890600; H 0.000000 -1.431500 4.890600; units bohr; symmetry c1; no_reorient; no_com; }. dimer = psi4.get_active_molecule(). set {; reference uhf; scf_type df; basis cc-pVDZ; df_basis_sapt cc-pVDZ-ri; guess sad; }. dimer = psi4.get_active_molecule(). set df_ints_io save; psi4.IO.set_default_namespace('dimer'); Edim, wfn_dimer = energy('scf',molecule=dimer,return_wfn=True); set df_ints_io load. monomerA = dimer.extract_subsets(1,2); psi4.IO.change_file_namespace(97, 'dimer', 'monomerA'); psi4.IO.set_default_namespace('monomerA'); set {; stability_analysis follow; }; EmonA, wfn_monA = energy('scf',molecule=monomerA,return_wfn=True). monomerB = dimer.extract_subsets(2,1); psi4.IO.change_file_namespace(97, 'monomerA', 'monomerB'); psi4.IO.set_default_namespace('monomerB'); set {; stability_analysis none; }; EmonB, wfn_monB = energy('scf',molecule=monomerB,return_wfn=True). psi4.IO.change_file_namespace(97, 'monomerB', 'dimer'); psi4.IO.set_default_namespace('dimer'). psi4.sapt(wfn_dimer,wfn_monA,wfn_monB). In this way, any of the SCF options can be tweaked for individual fragments.; For optimal efficiency, the example uses set df_ints_io save to keep file 97,; which contains the three-index integrals for density fitting. set df_ints_io load; then instructs the program to read these integrals from disk instead of recomputing; them. For each SCF computation, we use psi4.IO.set_default_namespace to uniquely; name scratch files. In the following SCF step, only file 97 is renamed using; psi4.IO.change_file_namespace so that integrals can be read from i",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/sapt-1.html:12229,energy,energy,12229,psi4manual/1.1.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/sapt-1.html,2,['energy'],['energy']
Energy Efficiency," weightings 'Wt', as for the REQUESTED ENERGY below.\n""""""; tables += """""" Depending on the nature of the variable, this may or may not make any physical sense.\n""""""; for envv in db_tabulate:; tables += """"""\n ==> %s <==\n\n"""""" % (envv.title()); tables += tblhead(maxrgt, table_delimit, 2). for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); VRXN[db_rxn] = {}. if FAIL[rxn]:; tables += """"""\n%23s %8s %8s %8s"""""" % (db_rxn, '', '****', ''); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (VRGT[ACTV[db_rxn][i]][envv], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; VRXN[db_rxn][envv] = 0.0; for i in range(len(ACTV[db_rxn])):; VRXN[db_rxn][envv] += VRGT[ACTV[db_rxn][i]][envv] * RXNM[db_rxn][ACTV[db_rxn][i]]. tables += """"""\n%23s %16.8f """""" % (db_rxn, VRXN[db_rxn][envv]); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (VRGT[ACTV[db_rxn][i]][envv], RXNM[db_rxn][ACTV[db_rxn][i]]); tables += """"""\n %s\n"""""" % (table_delimit). # tabulate primary requested energy variable with statistics; count_rxn = 0; minDerror = 100000.0; maxDerror = 0.0; MSDerror = 0.0; MADerror = 0.0; RMSDerror = 0.0. tables += """"""\n ==> %s <==\n\n"""""" % ('Requested Energy'); tables += tblhead(maxrgt, table_delimit, 1); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn). if FAIL[rxn]:; tables += """"""\n%23s %8.4f %8s %8s"""""" % (db_rxn, BIND[db_rxn], '****', '****'); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; ERXN[db_rxn] = 0.0; for i in range(len(ACTV[db_rxn])):; ERXN[db_rxn] += ERGT[ACTV[db_rxn][i]] * RXNM[db_rxn][ACTV[db_rxn][i]]; error = physconst.psi_hartree2kcalmol * ERXN[db_rxn] - BIND[db_rxn]. tables += """"""\n%23s %8.4f %8.4f %8.4f"""""" % (db_rxn, BIND[db_rxn], physconst.psi_hartree2kcalmol * ERXN[db_rxn], error); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). if abs(error) < abs(minDerror):; minDerror = error; if abs(error)",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:47427,energy,energy,47427,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,1,['energy'],['energy']
Energy Efficiency," weirdness). omp3-5; SOS-OMP3 cc-pVDZ geometry optimization for the H2O molecule. adc1; ADC/6-31G** on H2O. cc9; UHF-CCSD(T) cc-pVDZ frozen-core energy for the state of the CN radical, with Z-matrix input. pubchem1; Benzene vertical singlet-triplet energy difference computation, using the PubChem database to obtain the initial geometry, at the UHF an ROHF levels of theory. cc44; Test case for some of the PSI4 out-of-core codes. The code is given only 2.0 MB of memory, which is insufficient to hold either the A1 or B2 blocks of an ovvv quantity in-core, but is sufficient to hold at least two copies of an oovv quantity in-core. cc35; CC3(ROHF)/cc-pVDZ H2O geom from Olsen et al., JCP 104, 8007 (1996). omp2-4; SCS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. mp2_5-grad2; MP2.5 cc-pVDZ gradient for the NO radical. mints8; Patch of a glycine with a methyl group, to make alanine, then DF-SCF energy calculation with the cc-pVDZ basis set. cc9a; ROHF-CCSD(T) cc-pVDZ energy for the state of the CN radical, with Z-matrix input. dfmp2-2; Density fitted MP2 energy of H2, using density fitted reference and automatic looping over cc-pVDZ and cc-pVTZ basis sets. Results are tabulated using the built in table functions by using the default options and by specifiying the format. omp2-grad1; OMP2 cc-pVDZ gradient for the H2O molecule. cc1; RHF-CCSD 6-31G** all-electron optimization of the H2O molecule. scf4; RHF cc-pVDZ energy for water, automatically scanning the symmetric stretch and bending coordinates using Python’s built-in loop mechanisms. The geometry is apecified using a Z-matrix with variables that are updated during the potential energy surface scan, and then the same procedure is performed using polar coordinates, converted to Cartesian coordinates. cisd-h2o-clpse; 6-31G** H2O Test CISD Energy Point with subspace collapse. omp2-3; OMP2 cc-pVDZ energy for the NO radical. cepa1; cc-pvdz H2O Test CEPA(1) Energy. cc24; Single point gradient of 1-2B1 state of H2O+ wi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodoc_testsuite-1.html:19849,energy,energy,19849,psi4manual/4.0b5/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodoc_testsuite-1.html,4,['energy'],['energy']
Energy Efficiency," well, by specifying the SCF_TYPE as CD. The; accuracy of the decomposition can be controlled through the keyword; CHOLESKY_TOLERANCE.; The following input file sets up a DF-CCSD(T); computation using CD integrals; molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; scf_type cd; cc_type cd; basis aug-cc-pvdz; freeze_core true; }; energy('ccsd(t)'). The resulting CCSD(T) correlation energy will be equivalent to that; obtained from a conventional computation if CHOLESKY_TOLERANCE is; sufficiently small (e.g. 1e-9). Gn theory¶; The FNOCC module contains all the components that comprise the Gn family; of composite methods. Currently, only the G2 method is supported; [Curtiss:1991:7221]. The G2 procedure may be called through the; energy() wrapper:; energy('gaussian-2'). Supported methods¶; The various methods supported by the FNOCC module in PSI4 are detailed; in Table FNOCC Methods. Note that these methods; are implemented for closed-shell references only. For open-shell references,; the calls energy('mp2.5'), energy('mp3'), and energy('mp4') will; default to implementations of these methods in other modules. name; calls method; type select. qcisd; quadratic configuration interaction singles doubles; CI_TYPE CONV. qcisd(t); qcisd with perturbative triples; CI_TYPE CONV. mp2.5; average of second- and third-order perturbation theories; MP_TYPE CONV. mp3; third-order perturbation theory; MP_TYPE CONV. mp4(sdq); fourth-order perturbation theory, minus triples contribution; MP_TYPE CONV. mp4; full fourth-order perturbation theory; MP_TYPE CONV. lccd; linear ccd; CC_TYPE CONV. cepa(0), lccsd; coupled electron pair approximation, variant 0; CC_TYPE CONV. cepa(1); coupled electron pair approximation, variant 1; CC_TYPE CONV. cepa(3); coupled electron pair approximation, variant 3; CC_TYPE CONV. acpf; averaged coupled-pair functional; CC_TYPE CONV. aqcc; averaged quadratic coupled-cluster; CC_TYPE CONV. cisd; configuration interaction with single and double excitations; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/fnocc-1.html:12805,energy,energy,12805,psi4manual/1.4.0/fnocc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/fnocc-1.html,5,['energy'],['energy']
Energy Efficiency," when selectively omitting diffuse; functions to make computations more tractable.; In the above example the basis sets have been assigned asymmetrically, reducing; the effective symmetry from \(D_{6h}\) to \(C_{2v}\); PSI4 will detect this; automatically and run in the appropriate point group.; Basis blocks can also be named, e.g., basis; optional_basis_name {...} and the basis defined by it later; applied to another molecule.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32# sets basis keyword; basis mybas {; assign aug-cc-pvtz; assign f cc-pvtz; }. # re-sets basis keyword; set basis aug-cc-pvtz. molecule hf {; H; F 1 1.0; }. molecule h2o {; O; H 1 1.0; H 1 1.0 2 90.0; }. # runs HF and H2O with aug-cc-pvtz; energy('hf', molecule=hf); energy('hf', molecule=h2o). # re-re-sets basis keyword; set basis mybas. # runs HF with cc-pvtz on F and aug-cc-pvtz on H; energy('hf', molecule=hf). # runs H2O with aug-cc-pvtz, effectively; energy('hf', molecule=h2o). Finally, we note that the basis {...} block may also be used; for defining basis sets, as detailed in User-Defined Basis Sets.; Calculations requesting density fitting (on by default for many methods); require auxiliary fitting basis set(s) in addition to the primary; orbital one associated with the BASIS keyword.; When most popular basis sets are being used, including Dunning and; Pople-style, the SCF, DF-MP2, and SAPT codes will chose the appropriate; auxiliary basis set automatically according to Auxiliary Basis Sets,; unless instructed otherwise by setting the auxiliary basis set in the; input.; Should needed elements be missing from the best; auxiliary basis or should the orbital basis be unknown to PSI4,; the auxiliary basis will fall back on def2 quad-zeta fitting bases.; Note that if BASIS is known to be larger than quad-zeta,; PSI4 will not attempt to fall back on the def2 fitting bases.; The same basis “block” syntax can be; used to specify",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/basissets-1.html:4625,energy,energy,4625,psi4manual/1.2.1/basissets-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/basissets-1.html,6,['energy'],['energy']
Energy Efficiency," where case structure must match the database file. Note; Boolean options can be specified by yes, on, true, or 1; for affirmative and no, off, false, or 0 for negative,; all insensitive to case. Note; Certain convergence and tolerance keywords, of type double (real numbers),; may be specified using either a real number or an integer; and integer X is then; treated as the number of converged decimal digits required. For example, to request; as energy converged to \(10^{-6} E_h\), the user may set the e_convergence; keyword to 0.000001, 1.0e-6, or 6. Notes on PSI Variables¶. Note; Starting in 1.6, there are three standard ways to access an excited state; property. We give examples below, but the method name and property name may change. method ROOT 0 -> ROOT m property to get root m.; method ROOT 0 -> ROOT m property - h TRANSITION to get root m and; independently specify that the total transition symmetry is h, e.g., A2.; method ROOT 0 (h) -> ROOT m (i) property to get the transition; between two roots, specifying the symmetry of both states and the index of the target; roots among states of their own symmetry. For example, to target the second excited-state, which is also the lowest energy state; of its irrep, the first two calls will take m = 2, while the last takes m = 0.; Methods that use this interface are: TD-fctl.; Note that numberings are associated with the calculation much more strongly than; with the molecular system. Changing the number of roots sought, the symmetry; subspace or the symmetry apportionment of roots under which the computation is run,; or the excited state method are all likely to scramble root numberings. table of contents. Notes on Options; Notes on PSI Variables. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Theoretical Methods: SCF to FCI; Notes on Options. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/notes_c.html:1805,energy,energy,1805,psi4manual/1.7.x/notes_c.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/notes_c.html,1,['energy'],['energy']
Energy Efficiency," where oscillatory convergence is observed. Type: double; Default: 0.0. DCFT_GUESS¶. Whether to read the orbitals from a previous computation, or to compute an MP2 guess. Type: string; Possible Values: CC, BCC, MP2; Default: MP2. DIIS_MAX_VECS¶. Maximum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 6. DIIS_MIN_VECS¶. Minimum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 3. IGNORE_TAU¶. Controls whether to ignore terms containing non-idempotent contribution to OPDM or not (for debug puproses only). For practical applications only the default must be used. Type: boolean; Default: false. INTS_TOLERANCE¶. Minimum absolute value below which integrals are neglected. Type: conv double; Default: 1e-14. LOCK_OCC¶. Controls whether to force the occupation to be that of the SCF guess. For practical applications only the default must be used. Type: boolean; Default: true. MO_RELAX¶. Controls whether to relax the orbitals during the energy computation or not (for debug puproses only). For practical applications only the default must be used. Type: boolean; Default: true. RELAX_GUESS_ORBITALS¶. Controls whether to relax the guess orbitals by taking the guess density cumulant and performing orbital update on the first macroiteration (for ALOGRITHM = TWOSTEP only). Type: boolean; Default: false. RELAX_TAU¶. Controls whether to relax tau during the cumulant updates or not. Type: boolean; Default: true. STABILITY_ADD_VECTORS¶. The number of vectors that can be added simultaneously into the subspace for Davidson’s diagonalization in stability check. Type: integer; Default: 20. STABILITY_AUGMENT_SPACE_TOL¶. The value of the rms of the residual in Schmidt orthogonalization which is used as a threshold for augmenting the vector subspace in stability check. Type: conv double; Default: 0.1. STABILITY_CHECK¶. Performs stability analysis of the DCFT energy. Type: boolean; Default: false. STABILITY_CONVERGENCE¶. Controls the con",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodir_options_c/module__dcft-1.html:4491,energy,energy,4491,psi4manual/4.0b4/autodir_options_c/module__dcft-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodir_options_c/module__dcft-1.html,4,['energy'],['energy']
Energy Efficiency," whether db run in one job or files farmed out; db_mode = kwargs.pop('db_mode', kwargs.pop('mode', 'continuous')).lower(); kwargs['db_mode'] = db_mode. if db_mode == 'continuous':; pass; elif db_mode == 'sow':; pass; elif db_mode == 'reap':; db_linkage = kwargs.get('linkage', None); if db_linkage is None:; raise ValidationError(""""""Database execution mode 'reap' requires a linkage option.""""""); else:; raise ValidationError(""""""Database execution mode '%s' not valid."""""" % (db_mode)). # Option counterpoise- whether for interaction energy databases run in bsse-corrected or not; db_cp = kwargs.get('cp', False). if db_cp is True:; try:; database.ACTV_CP; except AttributeError:; raise ValidationError(""""""Counterpoise correction mode 'yes' invalid for database %s."""""" % (db_name)); else:; ACTV = database.ACTV_CP; elif db_cp is False:; pass; else:; raise ValidationError(""""""Counterpoise correction mode '%s' not valid."""""" % (db_cp)). # Option relaxed- whether for non-frozen-monomer interaction energy databases include deformation correction or not?; db_rlxd = kwargs.get('rlxd', False). if db_rlxd is True:; if db_cp is True:; try:; database.ACTV_CPRLX; database.RXNM_CPRLX; except AttributeError:; raise ValidationError('Deformation and counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CPRLX; RXNM = database.RXNM_CPRLX; elif db_cp is False:; try:; database.ACTV_RLX; except AttributeError:; raise ValidationError('Deformation correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_RLX; elif db_rlxd is False:; #elif no.match(str(db_rlxd)):; pass; else:; raise ValidationError('Deformation correction mode \'%s\' not valid.' % (db_rlxd)). # Option zero-point-correction- whether for thermochem databases jobs are corrected by zpe; db_zpe = kwargs.get('zpe', False). if db_zpe is True:; raise ValidationError('Zero-point-correction mode \'yes\' not yet implemented.'); elif db_zpe is False:; pass; else:; r",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html:12230,energy,energy,12230,psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html,11,['energy'],['energy']
Energy Efficiency," which can be found in; psi4/tests. After building the source code, these can automatically be; run by running make tests in the compilation directory. Sample input; files can be found in the the psi4/samples subdirectory of the top-level Psi; directory. The samples and a brief description are provided below. Input File; Description. scf2; RI-SCF cc-pVTZ energy of water, with Z-matrix input and cc-pVTZ-RI auxilliary basis. cc22; ROHF-EOM-CCSD/DZ on the lowest two states of each irrep in CH2. mcscf2; TCSCF cc-pVDZ energy of asymmetrically displaced ozone, with Z-matrix input. min_input; This checks that all energy methods can run with a minimal input and set symmetry. cc25; Single point gradient of 1-2B2 state of H2O+ with EOM-CCSD. fd-gradient; SCF STO-3G finite-difference tests. scf6; Tests RHF/ROHF/UHF SCF gradients. psimrcc-ccsd_t-3; Mk-MRCCSD(T) single point. CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. mcscf1; ROHF 6-31G** energy of the state of CH2, with Z-matrix input. The occupations are specified explicitly. sapt5; SAPT0 aug-cc-pVTZ computation of the charge transfer energy of the water dimer. adc2; ADC/aug-cc-pVDZ on two water molecules that are distant from 1000 angstroms from each other. cc40; RHF-CC2-LR/cc-pVDZ optical rotation of H2O2. gauge = length, omega = (589 355 nm). dcft2; DCFT-06 calculation for the He dimer. This performs a two-step update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the MO Basis. cc32; CC3/cc-pVDZ H2O geom from Olsen et al., JCP 104, 8007 (1996). tu1-h2o-energy; Sample HF/cc-pVDZ H2O computation. dcft4; DCFT calculation for the HF+ using DCFT-06 functional. This performs both two-step and simultaneous update of the orbitals and cumulant using DIIS extrapolation. Four-virtual integrals are first handled in the MO Basis for the first two energy computations. In the next two the ao_basis=disk algorithm is used, where the transformation ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/testsuite-1.html:1210,energy,energy,1210,psi4manual/4.0b2/testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/testsuite-1.html,2,['energy'],['energy']
Energy Efficiency," which is important for the evaluation of the molecular properties. The additive; separability of the density cumulant guarantees that all of the DCT methods; are size-extensive and size-consistent. Furthermore, the N-representability; problem is now greatly simplified, because the idempotent part of \(\boldsymbol{\gamma_1}\) is; N-representable by construction. One only needs to worry about the; N-representability of the density cumulant, which is a relatively small part of; \(\boldsymbol{\gamma_2}\).; In order to obtain the DCT energy, two conditions must be satisfied:. The energy must be stationary with respect to a set of orbitals. This can be done by; diagonalizing the generalized Fock operator (as in the DC-06 and DC-12 methods, see below),; which introduces partial orbital relaxation, or by fully relaxing the orbitals and minimizing the entire energy expression; (as in the ODC-06 and ODC-12 methods).; The energy must be stationary with respect to the variation of the density; cumulant \(\boldsymbol{\lambda_2}\), constrained to N-representability conditions. Making the energy stationary requires solution of two sets of coupled; equations for orbitals and density cumulant, respectively (also known as; residual equations). At the present moment, three different algorithms for the; solution of the system of coupled equations are available (see; Iterative Algorithms for details).; Publications resulting from the use of the DCT code should cite contributions; listed here. Methods¶; Currently five DCT methods (functionals) are available: DC-06, DC-12, ODC-06, ODC-12, and ODC-13. The first four; methods use approximate N-representability conditions derived from; second-order perturbation theory and differ in the description of the; correlated (non-idempotent) part \(\boldsymbol{\tau}\) of the one-particle density; matrix and orbital optimization. While in the DC-06 and ODC-06 methods \(\boldsymbol{\tau}\) is derived from the density cumulant; in an approximate way (l",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/dct-1.html:4045,energy,energy,4045,psi4manual/1.4.0/dct-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/dct-1.html,9,['energy'],['energy']
Energy Efficiency," which the reference energy is to be; obtained. Generally unnecessary, as 'scf' is *the* scf in |PSIfour| but; can be used to direct lone scf components to run in |PSIfour| or Cfour; in a mixed-program composite method. :type corl_wfn: str; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: str; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: str; :param delta_wfn_lesser: |dl| ``corl_wfn`` |dr| || ``'mp2'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: str; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: str; :param delta2_wfn_lesser: |dl| ``delta_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set set through ``set`` commands have no influence; on a cbs calculation. :type scf_basis: :ref:`basis string <apdx:basisElement>`; :param scf_basis: |dl| ``corl_basis`` |dr| || ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, ``scf_basis`` can default; to ``corl_basis``. :type corl_basis: :ref:`basis string <apdx:basisElement>`; :param corl_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the correlation energy. :type delta_basis: :ref:`basis string <apdx:basisElement>`;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html:37189,energy,energy,37189,psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,16,['energy'],['energy']
Energy Efficiency," while True:. step = step + 1;. # Regula Falsi (modified); if (repeat_l > 1):; delta_l = delta_l / 2.0;; if (repeat_r > 1):; delta_r = delta_r / 2.0;; omega = - (omega_r - omega_l) / (delta_r - delta_l) * delta_l + omega_l;; psi4.set_global_option('DFT_OMEGA',omega). # Neutral; psi4.IO.change_file_namespace(180,""neutral"",""ot""); mol.set_molecular_charge(charge0); mol.set_multiplicity(mult0); psi4.print_out('\n\t==> IP Fitting SCF: Neutral, Omega = %11.3E <==\n' % omega); E0 = energy('scf'); ref = psi4.wavefunction(); eps_a = ref.epsilon_a(); eps_b = ref.epsilon_b(); E_HOMO = 0.0;; if (Nb == 0):; E_HOMO = eps_a[int(Na-1)]; else:; E_a = eps_a[int(Na - 1)]; E_b = eps_b[int(Nb - 1)]; if (E_a >= E_b):; E_HOMO = E_a;; else:; E_HOMO = E_b;; psi4.IO.change_file_namespace(180,""ot"",""neutral""). # Cation; psi4.IO.change_file_namespace(180,""cation"",""ot""); mol.set_molecular_charge(charge1); mol.set_multiplicity(mult1); psi4.print_out('\n\t==> IP Fitting SCF: Cation, Omega = %11.3E <==\n' % omega); E1 = energy('scf'); psi4.IO.change_file_namespace(180,""ot"",""cation""). IP = E1 - E0;; kIP = -E_HOMO;; delta = IP - kIP;. if (kIP > IP):; omega_r = omega; E0r = E0; E1r = E1; IPr = IP; kIPr = kIP; delta_r = delta; repeat_r = 0;; repeat_l = repeat_l + 1;; else:; omega_l = omega; E0l = E0; E1l = E1; IPl = IP; kIPl = kIP; delta_l = delta; repeat_l = 0;; repeat_r = repeat_r + 1;. omegas.append(omega); types.append('Regula-Falsi'); E0s.append(E0); E1s.append(E1); IPs.append(IP); kIPs.append(kIP). # Termination; if (abs(omega_l - omega_r) < omega_tol or step > maxiter):; converged = True;; break. psi4.IO.set_default_namespace(""""). psi4.print_out('\n\t==> IP Fitting Results <==\n\n'). psi4.print_out('\t => Occupation Determination <= \n\n'); psi4.print_out('\t %6s %6s %6s %6s %6s %6s\n' %('N', 'Na', 'Nb', 'Charge', 'Mult', 'HOMO')); psi4.print_out('\t Neutral: %6d %6d %6d %6d %6d %6d\n' %(N, Na, Nb, charge0, mult0, HOMO)); psi4.print_out('\t Cation: %6d %6d %6d %6d %6d\n\n' %(N-1, Na1, Nb1, charge",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/frac.html:16787,energy,energy,16787,psi4manual/4.0b5/_modules/frac.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/frac.html,1,['energy'],['energy']
Energy Efficiency," while fB.dat contains:; OH 14 15; PH 16 17 18 19 20 21 22 23 24 25 26. At this point, the user should run the fsapt.py post-processing script in; the fsapt directory as:; >>> fsapt.py. This will generate, among other files, the desired functional-group partition in; fsapt.dat. For our problem, the bottom of this file contains the finished; partition:; Frag1 Frag2 Elst Exch IndAB IndBA Disp Total; OH OH -8.425 6.216 -0.583 -1.512 -1.249 -5.553; OH PH 1.392 0.716 0.222 -0.348 -0.792 1.189; PH OH -2.742 0.749 -0.147 -0.227 -0.674 -3.040; PH PH 0.680 2.187 0.007 -0.208 -2.400 0.266; OH All -7.033 6.931 -0.362 -1.860 -2.040 -4.364; PH All -2.062 2.936 -0.140 -0.435 -3.074 -2.774; All OH -11.167 6.965 -0.730 -1.739 -1.923 -8.594; All PH 2.072 2.903 0.229 -0.556 -3.191 1.456; All All -9.095 9.867 -0.501 -2.295 -5.114 -7.138. Note that the assignment of linking sigma bond contributions is a small point of; ambiguity in F-SAPT. The fsapt.dat file presents the “links-by-charge”; assignment at the top and the “links by 50-50” assignment at the bottom. We; generally prefer the latter, but both generally give qualitatively identical; energetic partitions.; Users should check the files fragA.dat and fragB.dat to ensure that; there is not too much charge delocalization from one fragment to another. This; is presented in the “Orbital Check” section in these files – a value larger than; 0.1 docc is an indication that the picture of localizable functional groups may; be breaking down. We also strongly discourage the cutting of double,; triple, or aromatic bonding motifs when partitioning the molecule into fragments; – cuts across only simple sigma bonds are encouraged. Caution; November 2022, previous to QCEngine v0.26.0 and Psi4; v1.7.0, there was a scaling inconsistency in the pairwise analysis; such that 2-BODY PAIRWISE DISPERSION CORRECTION ANALYSIS; was doubled when generated from dftd3 compared to the output from other; programs (s-dftd3 and dftd4). This shows up in the QCVaria",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/fisapt.html:6172,charge,charge,6172,psi4manual/1.7.x/fisapt.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/fisapt.html,4,['charge'],['charge']
Energy Efficiency," while fB.dat contains:; OH 14 15; PH 16 17 18 19 20 21 22 23 24 25 26. At this point, the user should run the fsapt.py post-processing script in; the fsapt directory as:; >>> fsapt.py. This will generate, among other files, the desired functional-group partition in; fsapt.dat. For our problem, the bottom of this file contains the finished; partition:; Frag1 Frag2 Elst Exch IndAB IndBA Disp Total; OH OH -8.425 6.216 -0.583 -1.512 -1.249 -5.553; OH PH 1.392 0.716 0.222 -0.348 -0.792 1.189; PH OH -2.742 0.749 -0.147 -0.227 -0.674 -3.040; PH PH 0.680 2.187 0.007 -0.208 -2.400 0.266; OH All -7.033 6.931 -0.362 -1.860 -2.040 -4.364; PH All -2.062 2.936 -0.140 -0.435 -3.074 -2.774; All OH -11.167 6.965 -0.730 -1.739 -1.923 -8.594; All PH 2.072 2.903 0.229 -0.556 -3.191 1.456; All All -9.095 9.867 -0.501 -2.295 -5.114 -7.138. Note that the assignment of linking sigma bond contributions is a small point of; ambiguity in F-SAPT. The fsapt.dat file presents the “links-by-charge”; assignment at the top and the “links by 50-50” assignment at the bottom. We; generally prefer the latter, but both generally give qualitatively identical; energetic partitions.; Users should check the files fragA.dat and fragB.dat to ensure that; there is not too much charge delocalization from one fragment to another. This; is presented in the “Orbital Check” section in these files – a value larger than; 0.1 docc is an indication that the picture of localizable functional groups may; be breaking down. We also strongly discourage the cutting of double,; triple, or aromatic bonding motifs when partitioning the molecule into fragments; – cuts across only simple sigma bonds are encouraged. Order-1 Visualization with PyMol¶; The fsapt.py script above also generates a number of order-1 .pdb files; that can be used to get a quick qualitative picture of the F-SAPT partition. The; preferred way to do this is to use PyMol to make plots of the molecular geometry; with the atoms colored according to their order-",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/fisapt-1.html:6172,charge,charge,6172,psi4manual/1.4.0/fisapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/fisapt-1.html,5,['charge'],['charge']
Energy Efficiency," while; optimize perfoms a geometry optimization on each reagent, and; cbs performs a compound single-point energy. If a nested series; of python functions is intended (see Function Intercalls), use; keyword db_func instead of func. mode (str) – \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; Indicates whether the calculations required to complete the; database are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. cp (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicates whether counterpoise correction is employed in computing; interaction energies. Use this option and NOT the bsse_type=""cp""; function for BSSE correction in database(). Option available; (See Available Databases) only for databases of bimolecular complexes. rlxd (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicates whether correction for deformation energy is; employed in computing interaction energies. Option available; (See Available Databases) only for databases of bimolecular complexes; with non-frozen monomers, e.g., HBC6. symm (boolean) – \(\Rightarrow\) 'on' \(\Leftarrow\) || 'off'; Indicates whether the native symmetry of the database reagents is; employed ('on') or whether it is forced to \(C_1\) symmetry; ('off'). Some computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). zpe (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. benchmark (str) – \(\Rightarrow\) 'default' \(\Leftarrow\) || 'S22A' || etc.; Indicates whether a non-default set of reference energies, if; available (See Available Databases), are employed for the; calculation of error statistics. tabulate (List[st",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/db-1.html:3031,energy,energy,3031,psi4manual/1.4.0/db-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/db-1.html,9,['energy'],['energy']
Energy Efficiency," will consider a Hartree-Fock SCF computation; for the water molecule using a cc-pVDZ basis set. First, we will set the; available memory for Psi4 to use with the psi4.set_memory(); API; function, which takes either a string like '30 GB' (with units!) or; an integer number of bytes of memory as its argument. Next, our; molecular geometry is passed as a string into psi4.geometry(); API.; We may input this geometry in either Z-matrix or Cartesian format; to; allow the string to break over multiple lines, use Python’s triple-quote; """"""string"""""" syntax. Finally, we will compute the Hartree-Fock SCF; energy with the cc-pVDZ basis set by passing the method/basis set as a; string ('scf/cc-pvdz') into the function psi4.energy(); API:. In [3]:. #! Sample HF/cc-pVDZ H2O Computation. psi4.set_memory('500 MB'). h2o = psi4.geometry(""""""; O; H 1 0.96; H 1 0.96 2 104.5; """"""). psi4.energy('scf/cc-pvdz'). Out[3]:. -76.02663273488399. If everything goes well, the computation should complete and should; report a final restricted Hartree-Fock energy in the output file; output.dat in a section like this:; Energy converged. @DF-RHF Final Energy: -76.02663273486682. By default, the energy should be converged to about; \(1.0\times 10^{-6}\), so agreement is only expected for about the; first 6 digits after the decimal. If the computation does not complete,; there is probably a problem with the compilation or installation of the; program (see the installation instructions in the main Psi4 manual; section Compiling and Installing from; Source).; This very simple input is sufficient to run the requested information.; Notice we didn’t tell the program some otherwise useful information like; the charge of the molecule (0, it’s neutral), the spin multiplicity (1; for a closed-shell molecule with all electrons paired), or the reference; wavefunction to use (restricted Hartree-Fock, or RHF, is usually; appropriate for a closed-shell molecule). The program correctly guessed; all of these options for ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psiapi-1.html:3646,energy,energy,3646,psi4manual/1.1.0/psiapi-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psiapi-1.html,4,['energy'],['energy']
Energy Efficiency," with ECP present; check of energies and forces. nbody-freq; Vibrational and thermo analysis of water trimer (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). molden1; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. psimrcc-ccsd_t-3; Mk-MRCCSD(T) single point. \(^1A_1\) CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. cc5; RHF CCSD(T) aug-cc-pvtz frozen-core energy of C4NH4 Anion. mints8; Patch of a glycine with a methyl group, to make alanine, then DF-SCF energy calculation with the cc-pVDZ basis set. psimrcc-fd-freq2; Mk-MRCCSD frequencies. \(^1A_1\) O$_3` state described using the Ms = 0 component of the singlet. Uses TCSCF orbitals. dft-grad2; DF-BP86-D2 cc-pVDZ frozen core gradient of S22 HCN. cepa0-grad2; CEPA cc-pVDZ gradient for the NO radical. tu6-cp-ne2; Example potential energy surface scan and CP-correction for Ne2. sapt7; SAPT0 open-shell computation of H2O-HO2 interaction energy First with cc-pVDZ and density fitted integrals with UHF Then with 6-31g and direct integrals, except for dispersion that is computed with cc-pVDZ-ri density fitting with UHF. mints-benchmark; run some BLAS benchmarks. scf-bs; UHF and broken-symmetry UHF energy for molecular hydrogen. fci-tdm; He2+ FCI/cc-pVDZ Transition Dipole Moment. omp2p5-grad2; OMP2.5 cc-pVDZ gradient for the NO radical. fci-h2o-fzcv; 6-31G H2O Test FCI Energy Point. sapt-dft2; SAPT(DFT) aug-cc-pVDZ computation for the water dimer interaction energy. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Appendices. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/testsuite-1.html:41456,energy,energy,41456,psi4manual/1.3.2/testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/testsuite-1.html,8,['energy'],['energy']
Energy Efficiency," with cc-pVDZ and direct integrals, except for dispersion that is computed with cc-pVDZ-ri density fitting with ROHF. cc28; CCSD/cc-pVDZ optical rotation calculation (length gauge only) on Z-mat H2O2. fd-freq-gradient; SCF STO-3G finite-differences frequencies from gradients for H2O. dct-grad4; Unrestricted DF-DCT ODC-12 gradient for O2 with cc-pVTZ/cc-pVTZ-RI standard/auxiliary basis set. density-screen-1; RHF Density Matrix based-Integral Screening Test for water. cdomp2-2; OMP2 cc-pVDZ energy for the NO molecule. matrix1; An example of using BLAS and LAPACK calls directly from the Psi input file, demonstrating matrix multiplication, eigendecomposition, Cholesky decomposition and LU decomposition. These operations are performed on vectors and matrices provided from the Psi library. fci-coverage; 6-31G H2O Test for coverage. psithon1; Spectroscopic constants of H2, and the full ci cc-pVTZ level of theory. cc18; RHF-CCSD-LR/cc-pVDZ static polarizability of HOF. omp3-1; OMP3 cc-pVDZ energy for the H2O molecule. tdscf-1; td-uhf test on triplet states of methylene (rpa). sad-scf-type; Test SAD SCF guesses on noble gas atom. dft-custom-hybrid; DFT (hybrids) test of implementations in: hybrid_superfuncs.py. props4; Electrostatic potential and electric field evaluated on a grid around water. cc31; CCSD/sto-3g optical rotation calculation (both gauges) at two frequencies on methyloxirane. cc3; cc3: RHF-CCSD/6-31G** H2O geometry optimization and vibrational frequency analysis by finite-differences of gradients. x2c1; Test of SFX2C-1e on water uncontracted cc-pVDZ-DK The reference numbers are from Lan Cheng’s implementation in Cfour. scf-bz2; Benzene Dimer Out-of-Core HF/cc-pVDZ. pywrap-checkrun-uhf; This checks that all energy methods can run with a minimal input and set symmetry. psimrcc-ccsd_t-1; Mk-MRCCSD(T) single point. \(^1A_1\) CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. tdscf-2; td-uhf test on triplet states of methylene",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html:25000,energy,energy,25000,psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency," with closed shell reference determinant, it must be zero otherwise. This becomes nsing (option #2) in fort.56. Type: integer; Default: 1. MRCC_NUM_TRIPLET_ROOTS¶. Number of triplet roots. (Strictly speaking number of of roots with \(M_s=0\) and S is odd.) See notes at option MRCC_NUM_SINGLET_ROOTS This becomes ntrip (option #3) in fort.56. Type: integer; Default: 0. Expert¶. MRCC_METHOD¶. If more than one root is requested and calc=1, LR-CC (EOM-CC) calculation is performed automatically for the excited states. This overrides all automatic determination of method and will only work with energy(). This becomes CC/CI (option #5) in fort.56. See Table MRCC_METHOD for details. Type: integer; Default: 1. MRCC_OMP_NUM_THREADS¶. Sets the OMP_NUM_THREADS environment variable before calling MRCC. If the environment variable OMP_NUM_THREADS is set prior to calling Psi4 then that value is used. When set, this option overrides everything. Be aware the -n command-line option described in section Threading does not affect MRCC. Type: integer; Default: 1. MRCC_RESTART¶. The program restarts from the previously calculated parameters if it is 1. In case it is 2, the program executes automatically the lower-level calculations of the same type consecutively (e.g., CCSD, CCSDT, and CCSDTQ if CCSDTQ is requested) and restarts each calculation from the previous one (rest=2 is available only for energy calculations). Currently, only a value of 0 and 2 are supported. This becomes rest (option #4) in fort.56. Type: integer; Default: 0. table of contents. MRCC; General; E_CONVERGENCE; INTS_TOLERANCE; MRCC_LEVEL; MRCC_NUM_DOUBLET_ROOTS; MRCC_NUM_SINGLET_ROOTS; MRCC_NUM_TRIPLET_ROOTS. Expert; MRCC_METHOD; MRCC_OMP_NUM_THREADS; MRCC_RESTART. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Appendices; Keywords by Module; MRCC. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodir_options_c/module__mrcc.html:2503,energy,energy,2503,psi4manual/1.6.x/autodir_options_c/module__mrcc.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodir_options_c/module__mrcc.html,1,['energy'],['energy']
Energy Efficiency," with converging an iterative method. Parameters; ----------; eqn_description : str; Type of QC routine that has failed (e.g., SCF); iteration : int; What iteration we failed on. """""". def __init__(self, eqn_description, iteration, additional_info=None):; msg = f""Could not converge {eqn_description:s} in {iteration:d} iterations.""; if additional_info is not None:; msg += f""\n\n{additional_info}""; PsiException.__init__(self, msg); self.iteration = iteration; self.message = msg; core.print_out(f'\nPsiException: {msg:s}\n\n'). [docs]class OptimizationConvergenceError(ConvergenceError):; """"""Error called for problems with geometry optimizer."""""". def __init__(self, eqn_description, iteration, wfn):; ConvergenceError.__init__(self, eqn_description, iteration); self.wfn = wfn. [docs]class SCFConvergenceError(ConvergenceError):; """"""Error called for problems with SCF iterations. Parameters; ----------; wfn : psi4.core.Wavefunction; Wavefunction at time of exception; e_conv : float; Change in energy for last iteration; d_conv : float; RMS change in density for last iteration. """""". def __init__(self, eqn_description, iteration, wfn, e_conv, d_conv):; ConvergenceError.__init__(self, eqn_description, iteration); self.e_conv = e_conv; self.d_conv = d_conv; self.wfn = wfn. [docs]class TDSCFConvergenceError(ConvergenceError):; """"""Error called for problems with TDSCF iterations. Parameters; ----------; wfn : psi4.core.Wavefunction; Wavefunction at time of exception; what : str; What we were trying to solve for (singlets/triplets, irrep) when we failed to converge; stats : Dict; Dictionary of convergence statistics of last iteration.; Keys are:. count : int, iteration number; res_norm : np.ndarray (nroots, ), the norm of residual vector for each roots; val : np.ndarray (nroots, ), the eigenvalue corresponding to each root; delta_val : np.ndarray (nroots, ), the change in eigenvalue from the last iteration to this ones; collapse : bool, if a subspace collapse was performed; product_count",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html:4194,energy,energy,4194,psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html,3,['energy'],['energy']
Energy Efficiency," with keyword key under handle name. cbs(func, label, **kwargs); Function to define a multistage energy method from combinations of basis set extrapolations and delta corrections and condense the components into a minimum number of calculations. check_iwl_file_from_scf_type(scf_type, wfn); Ensures that a IWL file has been written based on input SCF type. compare_fchkfiles(expected, computed, …). compare_fcidumps(expected, computed, label); Function to compare two FCIDUMP files. copy_file_from_scratch(filename, prefix, …); Function to move file out of scratch with correct naming convention. copy_file_to_scratch(filename, prefix, …); Function to move file into scratch with correct naming convention. create_plugin(name, template). rtype; None. cubeprop(wfn, **kwargs); Evaluate properties on a grid and generate cube files. dynamic_variable_bind(cls); Function to dynamically add extra members to the core.Molecule class. energies_from_fcidump(intdump). energy(name, **kwargs); Function to compute the single-point electronic energy. fchk(wfn, filename, *[, debug, strict_label]); Function to write wavefunction information in wfn to filename in Gaussian FCHK format. fchkfile_to_string(fname); Load FCHK file into a string. fcidump(wfn[, fname, oe_ints]); Save integrals to file in FCIDUMP format as defined in Comp. fcidump_from_file(fname); Function to read in a FCIDUMP file. find_approximate_string_matches(seq1, …); Find list of approximate (within max_distance) matches to string seq1 among options. free_atom_volumes(wfn, **kwargs); Computes free-atom volumes using MBIS density partitioning. freq(name, **kwargs); Function to compute harmonic vibrational frequencies. frequencies(name, **kwargs); Function to compute harmonic vibrational frequencies. frequency(name, **kwargs); Function to compute harmonic vibrational frequencies. gdma(wfn[, datafile]); Function to use wavefunction information in wfn and, if specified, additional commands in filename to run GDMA analysis. geometry",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/psi4api-1.html:17621,energy,energy,17621,psi4manual/1.4.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/psi4api-1.html,4,['energy'],['energy']
Energy Efficiency," with no; paired square brackets is passed through with zeta level 0 (e.g., ‘6-31+G(d,p)’; is returned as [6-31+G(d,p)] and [0]). A basis set with square brackets is; checked for sensible sequence and Dunning-ness and returned as separate basis; sets (e.g., ‘cc-pV[Q5]Z’ is returned as [cc-pVQZ, cc-pV5Z] and [4, 5]). Note; that this function has no communication with the basis set library to check; if the basis actually exists. Used by complete_basis_set(). validate_scheme_args(functionname, **largs)[source]¶; Function called by each extrapolation scheme in complete_basis_set().; Checks that all the input arguments are present and suitable so that; the scheme function can focus on defining the extrapolation. qmmm¶; Module with classes to integrate MM charges into; a QM calculation. class Diffuse(molecule, basisname, ribasisname)[source]¶. fitGeneral()[source]¶; Function to perform a general fit of diffuse charges; to wavefunction density. fitScf()[source]¶; Function to run scf and fit a system of diffuse charges to; resulting density. populateExtern(extern)[source]¶. class QMMM[source]¶. addChargeAngstrom(Q, x, y, z)[source]¶; Function to add a point charge of magnitude Q at; position (x, y, z) Angstroms. addChargeBohr(Q, x, y, z)[source]¶; Function to add a point charge of magnitude Q at; position (x, y, z) Bohr. addDiffuse(diffuse)[source]¶; Function to add a diffuse charge field diffuse. populateExtern()[source]¶; Function to define a charge field external to the; molecule through point and diffuse charges. basislistother¶; Module with commands building BasisFamily objects; for Pople and other non-Dunning orbital basis sets. Some; plausible fitting basis sets are supplied as defaults. load_basfam_other()[source]¶. diatomic¶. functional¶; Module to provide lightweight definitions of functionals and; SuperFunctionals. build_b2plyp_superfunctional(name, npoints, deriv)[source]¶. build_b2plypd2gr_superfunctional(name, npoints, deriv)[source]¶. build_b2plypd2p4_superfu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_driver-1.html:24216,charge,charges,24216,psi4manual/4.0b4/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_driver-1.html,2,['charge'],['charges']
Energy Efficiency," with no; paired square brackets is passed through with zeta level 0 (e.g., ‘6-31+G(d,p)’; is returned as [6-31+G(d,p)] and [0]). A basis set with square brackets is; checked for sensible sequence and Dunning-ness and returned as separate basis; sets (e.g., ‘cc-pV[Q5]Z’ is returned as [cc-pVQZ, cc-pV5Z] and [4, 5]). Note; that this function has no communication with the basis set library to check; if the basis actually exists. Used by complete_basis_set(). validate_scheme_args(functionname, **largs)[source]¶; Function called by each extrapolation scheme in complete_basis_set().; Checks that all the input arguments are present and suitable so that; the scheme function can focus on defining the extrapolation. qmmm¶; Module with classes to integrate MM charges into; a QM calculation. class Diffuse(molecule, basisname, ribasisname)[source]¶. fitGeneral()[source]¶; Function to perform a general fit of diffuse charges; to wavefunction density. fitScf()[source]¶; Function to run scf and fit a system of diffuse charges to; resulting density. populateExtern(extern)[source]¶. class QMMM[source]¶. addChargeAngstrom(Q, x, y, z)[source]¶; Function to add a point charge of magnitude Q at; position (x, y, z) Angstroms. addChargeBohr(Q, x, y, z)[source]¶; Function to add a point charge of magnitude Q at; position (x, y, z) Bohr. addDiffuse(diffuse)[source]¶; Function to add a diffuse charge field diffuse. populateExtern()[source]¶; Function to define a charge field external to the; molecule through point and diffuse charges. basislistother¶; Module with commands building BasisFamily objects; for Pople and other non-Dunning orbital basis sets. Some; plausible fitting basis sets are supplied as defaults. load_basfam_other()[source]¶. diatomic¶. functional¶; Module to provide lightweight definitions of functionals and; SuperFunctionals. build_b2plyp_superfunctional(name, npoints, deriv)[source]¶. build_b2plypd2gr_superfunctional(name, npoints, deriv)¶. build_b2plypd2p4_superfunctional",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_driver-1.html:22044,charge,charges,22044,psi4manual/4.0b3/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_driver-1.html,2,['charge'],['charges']
Energy Efficiency," with no; paired square brackets is passed through with zeta level 0 (e.g., ‘6-31+G(d,p)’; is returned as [6-31+G(d,p)] and [0]). A basis set with square brackets is; checked for sensible sequence and Dunning-ness and returned as separate basis; sets (e.g., ‘cc-pV[Q5]Z’ is returned as [cc-pVQZ, cc-pV5Z] and [4, 5]). Note; that this function has no communication with the basis set library to check; if the basis actually exists. Used by complete_basis_set(). validate_scheme_args(functionname, **largs)[source]¶; Function called by each extrapolation scheme in complete_basis_set().; Checks that all the input arguments are present and suitable so that; the scheme function can focus on defining the extrapolation. qmmm¶; Module with classes to integrate MM charges into; a QM calculation. class Diffuse(molecule, basisname, ribasisname)[source]¶. fitGeneral()[source]¶; Function to perform a general fit of diffuse charges; to wavefunction density. fitScf()[source]¶; Function to run scf and fit a system of diffuse charges to; resulting density. populateExtern(extern)[source]¶. class QMMM[source]¶. addChargeAngstrom(Q, x, y, z)[source]¶; Function to add a point charge of magnitude Q at; position (x, y, z) Angstroms. addChargeBohr(Q, x, y, z)[source]¶; Function to add a point charge of magnitude Q at; position (x, y, z) Bohr. addDiffuse(diffuse)[source]¶; Function to add a diffuse charge field diffuse. populateExtern()[source]¶; Function to define a charge field external to the; molecule through point and diffuse charges. diatomic¶. functional¶; Module to provide lightweight definitions of functionals and; SuperFunctionals. build_b2plyp_superfunctional(name, npoints, deriv)[source]¶. build_b2plypd2gr_superfunctional(name, npoints, deriv)[source]¶. build_b2plypd2p4_superfunctional(name, npoints, deriv)[source]¶. build_b2plypd3bj_superfunctional(name, npoints, deriv)[source]¶. build_b2plypd3zero_superfunctional(name, npoints, deriv)[source]¶. build_b3_x_functional(name)[source]¶. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodoc_driver-1.html:19569,charge,charges,19569,psi4manual/4.0b5/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodoc_driver-1.html,2,['charge'],['charges']
Energy Efficiency," with no; paired square brackets is passed through with zeta level 0 (e.g., ‘6-31+G(d,p)’; is returned as [6-31+G(d,p)] and [0]). A basis set with square brackets is; checked for sensible sequence and Dunning-ness and returned as separate basis; sets (e.g., ‘cc-pV[Q5]Z’ is returned as [cc-pVQZ, cc-pV5Z] and [4, 5]). Note; that this function has no communication with the basis set library to check; if the basis actually exists. Used by complete_basis_set(). validate_scheme_args(functionname, **largs)[source]¶; Function called by each extrapolation scheme in complete_basis_set().; Checks that all the input arguments are present and suitable so that; the scheme function can focus on defining the extrapolation. qmmm¶; Module with classes to integrate MM charges into; a QM calculation. class Diffuse(molecule, basisname, ribasisname)[source]¶. fitGeneral()[source]¶; Function to perform a general fit of diffuse charges; to wavefunction density. fitScf()[source]¶; Function to run scf and fit a system of diffuse charges to; resulting density. populateExtern(extern)[source]¶. class QMMM[source]¶. addChargeAngstrom(Q, x, y, z)[source]¶; Function to add a point charge of magnitude Q at; position (x, y, z) Angstroms. addChargeBohr(Q, x, y, z)[source]¶; Function to add a point charge of magnitude Q at; position (x, y, z) Bohr. addDiffuse(diffuse)[source]¶; Function to add a diffuse charge field diffuse. populateExtern()[source]¶; Function to define a charge field external to the; molecule through point and diffuse charges. functional¶; Module to provide lightweight definitions of functionals and; SuperFunctionals. build_b3_x_functional(name)[source]¶. build_b3lyp5_superfunctional(name, npoints, deriv)[source]¶. build_b3lyp5d_superfunctional(name, npoints, deriv)[source]¶. build_b3lyp_superfunctional(name, npoints, deriv)[source]¶. build_b3lypd_superfunctional(name, npoints, deriv)[source]¶. build_b88_x_functional(name)[source]¶. build_b970_superfunctional(name, npoints, deriv)[so",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodoc_driver-1.html:14059,charge,charges,14059,psi4manual/4.0b2/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodoc_driver-1.html,2,['charge'],['charges']
Energy Efficiency," with oscillatory convergence. Type: double; Default: 100.0. DCFT_GUESS (DCFT); DCFT (Expert) — Whether to read the orbitals from a previous computation, or to compute an MP2 guess. Type: string; Possible Values: CC, BCC, MP2; Default: MP2. DEBUG (CPHF); CPHF — The amount of debug information printed to the output file. Type: integer; Default: 0. DEBUG (GLOBALS); GLOBALS (Expert) — The amount of information to print to the output file. Type: integer; Default: 0. DELETE_AO (TRANSQT); TRANSQT — Do delete AO integral files?. Type: boolean; Default: true. DELETE_RESTR_DOCC (TRANSQT); TRANSQT — Do delete restricted doubly occupieds?. Type: boolean; Default: true. DELETE_TEI (TRANSQT2); TRANSQT2 — Boolean to delete the SO-basis two-electron integral file after the transformation. Type: boolean; Default: true. DELETE_TPDM (TRANSQT); TRANSQT — Do delete TPDM file?. Type: boolean; Default: true. DENOMINATOR_ALGORITHM (SAPT); SAPT — Denominator algorithm for PT methods. Laplace transformations are slightly more efficient. Type: string; Possible Values: LAPLACE, CHOLESKY; Default: LAPLACE. DENOMINATOR_DELTA (SAPT); SAPT — Maximum error allowed (Max error norm in Delta tensor) in the approximate energy denominators employed for most of the and evaluation. Type: double; Default: 1.0e-6. DERTYPE (GLOBALS); GLOBALS (Expert) — Derivative level. Type: string; Possible Values: NONE, FIRST, SECOND, RESPONSE; Default: NONE. DETCI_FREEZE_CORE (DETCI); DETCI — Do freeze core orbitals?. Type: boolean; Default: true. DF_BASIS_ELST (SAPT); SAPT — Auxiliary basis set for SAPT Elst10 and Exch10 density fitting computations, may be important if heavier elements are involved. Defaults to DF_BASIS_SAPT. Type: string; Possible Values: basis string; Default: No Default. DF_BASIS_GUESS (SCF); SCF — When BASIS_GUESS is active, run the preliminary scf in density-fitted mode with this as fitting basis for the small basis set. A value of TRUE turns on density fitting with the cc-pVDZ-RI basis set (when ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html:22771,efficient,efficient,22771,psi4manual/4.0b3/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html,2,['efficient'],['efficient']
Energy Efficiency," with symbol (e.g., H) arg2. set_geometry(self: psi4.core.Molecule, arg0: psi4.core.Matrix) → None¶; Sets the geometry, given a (Natom X 3) matrix arg2 of coordinates (in Bohr). set_ghost_fragment(self: psi4.core.Molecule, arg0: int) → None¶; Sets the specified fragment arg2 to be Ghost. set_ghost_fragments(self: psi4.core.Molecule, arg0: List[int]) → None¶; Sets the specified list arg2 of fragments to be Ghost. set_input_units_to_au(self: psi4.core.Molecule, arg0: float) → None¶; Sets unit conversion to [a0] for geometry. set_mass(self: psi4.core.Molecule, atom: int, mass: float) → None¶; Sets mass of atom (0-indexed) to mass. set_molecular_charge(self: psi4.core.Molecule, arg0: int) → None¶; Sets the molecular charge. set_multiplicity(self: psi4.core.Molecule, arg0: int) → None¶; Sets the multiplicity (defined as 2Ms + 1). set_name(self: psi4.core.Molecule, arg0: str) → None¶; Sets molecule name. set_nuclear_charge(self: psi4.core.Molecule, arg0: int, arg1: float) → None¶; Set the nuclear charge of the given atom to the value provided. set_point_group(self: psi4.core.Molecule, arg0: psi4.core.PointGroup) → None¶; Sets the molecular point group to the point group object arg2. set_units(self: psi4.core.Molecule, arg0: psi4.core.GeometryUnits) → None¶; Sets units (Angstrom or Bohr) used to define the geometry. set_variable(self: psi4.core.Molecule, arg0: str, arg1: float) → None¶; Assigns the value arg3 to the variable arg2 in the list of geometry variables, then calls update_geometry(). symbol(self: psi4.core.Molecule, arg0: int) → str¶; Gets the cleaned up label of atom arg2 (C2 => C, H4 = H). symmetrize(self: psi4.core.Molecule, arg0: float) → None¶; Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry. symmetry_from_input(self: psi4.core.Molecule) → str¶; Returns the symmetry specified in the input. to_arrays()¶; Exports coordinate info into NumPy arrays. Returns:; geom, mass, elem, elez, uniq (",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psi4api-1.html:145363,charge,charge,145363,psi4manual/1.2.1/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html,3,['charge'],['charge']
Energy Efficiency," with these extensions (e.g., wB97X-D) that,; not being Grimme corrections, won’t follow this table exactly. [2]; [Grimme:2004:1463]. [3]; [Grimme:2006:1787]. [4]; (1,2); [Grimme:2010:154104]. [5]; (1,2); [Grimme:2011:1456]. [6]; (1,2,3,4); [Smith:2016:2197]. [7]; [Hujo:2011:3866]. [8]; [Chai:2010:6615]. [9]; [Pernal:2009:263201]. [10]; [Podeszwa:2010:550]. [11]; Keyword not used for user-defined functionals where the dft_dict[""dispersion""][""params""]; is easily editable for this purpose. See Advanced Functional Use and Manipulation. [12]; [Caldeweyher:2019:154122]. A few practical examples:. DFT-D2 single point with default parameters (dftd3 not called); energy('bp86-d'). DFT-D3BJ optimization with default parameters; optimize('pbe-d3bj'). DFT-D2 optimization with custom s6 parameter; set dft_dispersion_parameters [1.20]; optimize('b3lyp-d2'). DFT-D3ZERO single point (b3lyp) with custom s8 parameter (reset all four values); set dft_dispersion_parameters [1.0, 2.0, 1.261, 14.0]; energy('b3lyp-d3'). DFT-D2 single point with dftd3 instead of PSI4‘s libdisp; energy('pbe-d2', engine='dftd3'). If only dispersion corrections (rather than total energies) are of; interest, the dispersion programs can be run independently of the scf; through the python function run_dftd3() or run_dftd4(). (These functions; call QCEngine, which is the same PSI4 + dftd3/dftd4 interface that is called during an scf job.); This “D-only” route is much faster than running a DFT-D energy.; This route is NOT available for s-dftd3. File an issue if a definite need arises.; Note that in a DFT+D energy or gradient calculation, user-specified; dispersion parameters override any information provided about the; functional. The same holds true for a dftd3 “D-only” calculation. But; in a dftd4 “D-only” calculation, functional information overrides; any user-specified dispersion parameters. Some set-up:; molecule nene {; Ne; Ne 1 2.0; }. nene.update_geometry(). The same four dispersion corrections/gradients as",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/dftd3.html:12042,energy,energy,12042,psi4manual/1.7.x/dftd3.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/dftd3.html,4,['energy'],['energy']
Energy Efficiency," with various combinations of pk/density-fitting, castup/no-castup, and spherical/cartesian settings. Demonstrates that puream setting is getting set by orbital basis for all df/castup parts of calc. Demonstrates that answer doesn’t depend on presence/absence of castup. Demonstrates (by comparison to castup3) that output file doesn’t depend on options (scf_type) being set global or local. This input uses global. mints3; Test individual integral objects for correctness. fci-tdm; He2+ FCI/cc-pVDZ Transition Dipole Moment. cc38; RHF-CC2-LR/cc-pVDZ static polarizabilities of HOF molecule. pywrap-db2; Database calculation, run in sow/reap mode. cbs-xtpl-func; optimization with method defined via cbs. cisd-h2o+-0; 6-31G** H2O+ Test CISD Energy Point. opt13; B3LYP cc-pVDZ geometry optimzation of phenylacetylene, starting from not quite linear structure. tu5-sapt; Example SAPT computation for ethene*ethine (i.e., ethylene*acetylene), test case 16 from the S22 database. ocepa1; OCEPA cc-pVDZ energy for the H2O molecule. props1; RHF STO-3G dipole moment computation, performed by applying a finite electric field and numerical differentiation. cc55; EOM-CCSD/6-31g excited state transition data for water with two excited states per irrep. omp2-grad2; OMP2 cc-pVDZ gradient for the NO radical. dft-freq; Frequencies for H2O B3LYP/6-31G* at optimized geometry. cc22; ROHF-EOM-CCSD/DZ on the lowest two states of each irrep in CH2. stability1; UHF->UHF stability analysis test for BH with cc-pVDZ Test direct SCF with and without symmetry, test PK without symmetry. dfomp2-2; OMP2 cc-pVDZ energy for the NO molecule. dfcasscf-sa-sp; Example of state-averaged CASSCF for the C2 molecule. cc9; UHF-CCSD(T) cc-pVDZ frozen-core energy for the state of the CN radical, with Z-matrix input. adc1; ADC/6-31G** on H2O. cc37; CC2(UHF)/cc-pVDZ energy of H2O+. omp2p5-grad1; OMP2.5 cc-pVDZ gradient for the H2O molecule. rasscf-sp; 6-31G** H2O Test RASSCF Energy Point will default to only singles and double",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html:29053,energy,energy,29053,psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency," without a module in; OptionsState.; # include if necessary as globals; PsiMod.set_global_option('BASIS', guessbasis); PsiMod.set_global_option('DF_BASIS_SCF', guessbasisdf). # include if necessary as locals; PsiMod.set_local_option('TRANSQT2', 'WFN', 'MP2'); PsiMod.set_local_option('CCSORT', 'WFN', 'MP2'); PsiMod.set_local_option('MP2', 'WFN', 'MP2'). If the regular scf module is to be run, run it through; scf_helper() so that cast-up can be used. Also, add the; option to bypass it by pre-running scf, then running the module with this; bypass_scf kwarg. Also, if the full two-electron integrals are; necessary for the post-scf, compute them if only the df integrals were run; previously.; # include if scf module is to be run. # Bypass routine scf if user did something special to get it to converge; if not (('bypass_scf' in kwargs) and yes.match(str(kwargs['bypass_scf']))):; scf_helper(name, **kwargs). # include if TEI are needed beyond scf. # If the scf type is DF, then the AO integrals were never generated; if PsiMod.get_option('SCF', 'SCF_TYPE') == 'DF':; mints = PsiMod.MintsHelper(); mints.integrals(). Direct any post-scf modules to be run.; # include if further post-scf modules are needed; PsiMod.transqt2(); PsiMod.ccsort(); PsiMod.mp2(). If an OptionsState object was set up, those options; need to be returned to the original user state with the following.; # include if optstash = OptionsState( was set up previously; optstash.restore(). No function should return anything. CURRENT ENERGY will be set by; energy(), etc.; # never include; return returnvalue. Previous topic; LibOptions: globals, locals, has_changed and all that; Next topic; Python Driver; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Programming: Using the Core Libraries ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/proc_py-1.html:3658,energy,energy,3658,psi4manual/4.0b4/proc_py-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/proc_py-1.html,2,['energy'],['energy']
Energy Efficiency," words of advice about using the SCF code for; practical calculations:. For GUESS, the SAD guess is usually your; friend, even for open-shell systems (at the very least, it gets the right; number of electrons, unlike some other programs). For instance, we have found; that a simple SAD guess is often as good as doing a full SCF in a 3-21G basis; and then performing a cast-up, at a fraction of the cost. However, SAD and; DOCC/SOCC arrays do not play very well together at the moment.; For wall time, DF may be a factor of ten or more faster than the exact; integral technologies available in PSI4.; Use DF unless you need absolute accuracy or do not; have a -JKFIT auxiliary set for your orbital basis/atom type. Then use; DIRECT.; Don’t mess with the DIIS convergence options unless convergence is a problem.; We have optimized the parameters for efficiency over a wide array of system; types.; Buy a developer a beer!. The “best-practice” input file for HF is:; memory 1 GB # As much as you've got, the DF algorithm can use. molecule {; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; basis cc-pvdz; scf_type df; guess sad; ints_tolerance 1.0E-10 # Even this is epically tight, 1.0E-8 is OK; }. energy('scf'). table of contents. HF: Hartree–Fock Theory; Introduction; Theory; Minimal Input; Spin/Symmetry Treatment; Broken Symmetry; Orthogonalization; Initial Guess; Restarting the SCF; Convergence Stabilization; ERI Algorithms; Integral-Direct Density-Fitted Coulomb Construction; COSX Exchange; Linear Exchange; Seminumerical Linear Exchange; Second-order Convergence; Stability Analysis; Effective core potentials (ECPs); External potentials and QM/MM; Convergence and Algorithm Defaults; Recommendations. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Theoretical Methods: SCF to FCI; HF: Hartree–Fock Theory. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/scf.html:59574,energy,energy,59574,psi4manual/master/scf.html,https://psicode.org,https://psicode.org/psi4manual/master/scf.html,1,['energy'],['energy']
Energy Efficiency," working directory) to the function psi4.set_output_file() API, as a string:. [3]:. psi4.set_output_file('output.dat', False). Additionally, output may be suppressed by instead setting psi4.core.be_quiet() API . II. Running a Basic Hartree-Fock Calculation¶; In our first example, we will consider a Hartree-Fock SCF computation for the water molecule using a cc-pVDZ basis set. First, we will set the available memory for Psi4 to use with the psi4.set_memory() API function, which takes either a string like '30 GB' (with units!) or an integer number of bytes of memory as its argument. Next, our molecular geometry is passed as a string into; psi4.geometry() API. We may input this geometry in either Z-matrix or Cartesian format; to allow the string to break over multiple lines, use Python’s triple-quote """"""string"""""" syntax. Finally, we will compute the Hartree-Fock SCF energy with the cc-pVDZ basis set by passing the method/basis set as a string ('scf/cc-pvdz') into the function psi4.energy(); API:. [3]:. #! Sample HF/cc-pVDZ H2O Computation. psi4.set_memory('500 MB'). h2o = psi4.geometry(""""""; O; H 1 0.96; H 1 0.96 2 104.5; """"""). psi4.energy('scf/cc-pvdz'). [3]:. -76.02663273488399. If everything goes well, the computation should complete and should report a final restricted Hartree-Fock energy in the output file output.dat in a section like this:; Energy converged. @DF-RHF Final Energy: -76.02663273486682. By default, the energy should be converged to about \(1.0\times 10^{-6}\), so agreement is only expected for about the first 6 digits after the decimal. If the computation does not complete, there is probably a problem with the compilation or installation of the program (see the installation instructions in the main Psi4 manual section Compiling and Installing from Source.; This very simple input is sufficient to run the requested information. Notice we didn’t tell the program some otherwise useful information like the charge of the molecule (0, it’s neutral), the spin ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/psiapi.html:3289,energy,energy,3289,psi4manual/1.9.x/psiapi.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/psiapi.html,2,['energy'],['energy']
Energy Efficiency," would do for an open-shell molecule, where not; all the electrons are paired. For example, let’s run a computation on; methylene (\(\text{CH}_2\)), whose ground electronic state has two; unpaired electrons (triplet electronic state, or a spin multiplicity; \(2S + 1 = 3\)). In this case, the default spin multiplicity (1) is; not correct, so we need to tell the program the true value (3). Like; many programs, Psi4 can get the charge and multiplicity as the first two; integers in the Z-matrix (note the line with 0 3 at the beginning of; the molecule specification below). In this example, we will also specify; the bond length and bond angle as variables (\(R\) and \(A\)),; whose values are first stored and then inserted into the geometry; specification using Python 3 string; formatting. In [4]:. #! Sample UHF/6-31G** CH2 Computation. R = 1.075; A = 133.93. ch2 = psi4.geometry(""""""; 0 3; C; H 1 {0}; H 1 {0} 2 {1}; """""".format(R, A); ). psi4.set_options({'reference': 'uhf'}); psi4.energy('scf/6-31g**'). Out[4]:. -38.925334628859886. Executing this cell should yield the final energy as; @DF-UHF Final Energy: -38.92533462887677. Notice the new command, psi4.set_options(); API,; to the input. This function takes a Python; dictionary; as its argument, which is a key-value list which associates a Psi4; keyword; with its user-defined value. For open shell molecules, we have a choice; of unrestricted orbitals (unrestricted Hartree-Fock, or UHF) or; restricted orbitals (restricted open-shell Hartree-Fock, or ROHF).; Usually, UHF is a little easier to converge (although it may be more; susceptible to spin contamination than ROHF). III. Geometry Optimization and Vibrational Frequency Analysis¶; The above examples were simple single-point energy computations (as; specified by the psi4.energy(); API; function). Of course there are other kinds of computations to perform,; such as geometry optimizations and vibrational frequency computations.; These can be specified by replacing psi4.en",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psiapi-1.html:5690,energy,energy,5690,psi4manual/1.1.0/psiapi-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psiapi-1.html,4,['energy'],['energy']
Energy Efficiency," wrapper directly""). method_list = []; basis_list = []; for num, method_str in enumerate(method_name_list):; if (method_str.count(""["") > 1) or (method_str.count(""]"") > 1):; raise ValidationError(f""""""CBS gufunc: Too many brackets given! {method_str}""""""). if method_str.count('/') != 1:; raise ValidationError(f""""""CBS gufunc: All methods must specify a basis with '/'. {method_str}""""""). if num > 0:; method_str = method_str.strip(); if method_str[:2].lower() != 'd:':; raise ValidationError(""""""CBS gufunc: Delta method must start with 'D:'.""""""); else:; method_str = method_str[2:]; method, basis = method_str.split('/'); method_list.append(method); basis_list.append(basis); return method_list, basis_list. def _cbs_gufunc(func, total_method_name, **kwargs):; """"""; A text based parser of the CBS method string. Provided to handle ""method/basis""; specification of the requested calculations. Also handles ""simple"" (i.e.; one-method and one-basis) calls. Parameters; ----------; func : function; Function to be called (energy, gradient, frequency or cbs).; total_method_name : str; String in a ``""method/basis""`` syntax. Simple calls (e.g. ``""blyp/sto-3g""``) are; bounced out of CBS. More complex calls (e.g. ``""mp2/cc-pv[tq]z""`` or; ``""mp2/cc-pv[tq]z+D:ccsd(t)/cc-pvtz""``) are expanded by `_parse_cbs_gufunc_string()`; and pushed through :py:func:`~psi4.cbs`. Returns; -------; tuple or float; Float, or if ``return_wfn`` is specified, a tuple of ``(value, wavefunction)``.; """""". # Catch kwarg issues for all methods; kwargs = p4util.kwargs_lower(kwargs); return_wfn = kwargs.pop('return_wfn', False); core.clean_variables(); ptype = kwargs.pop('ptype', None). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # Sanitize total_method_name; label = total_method_name; total_method_name = total_method_name.lower(); total_method_name = total_method_name.replace(' ', ''). # Split into components; metho",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:64768,energy,energy,64768,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,2,['energy'],['energy']
Energy Efficiency," xyzfilename, text[i + 2])); except IndexError:; raise ValidationError(""Molecule::init_with_xyz: Expected atom in file at line %d.\n%s"" % (i + 3,; text[i + 2])). # We need to make 1 fragment with all atoms; instance.fragments.append([0, fileNatom - 1]); instance.fragment_types.append('Real'); instance.fragment_charges.append(instance.molecular_charge()); instance.fragment_multiplicities.append(instance.multiplicity()); # Set the units properly; instance.PYunits = fileUnits; if fileUnits == 'Bohr':; instance.PYinput_units_to_au = 1.0; elif fileUnits == 'Angstrom':; instance.PYinput_units_to_au = 1.0 / psi_bohr2angstroms. instance.update_geometry(); return instance. @classmethod; def init_with_mol2(cls, xyzfilename, no_com=False, no_reorient=False, contentsNotFilename=False):; """"""Pull information from a MOl2 file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *no_reorient* can be used to turn off shift and; rotation. If *xyzfilename* is a string of the contents of an XYZ; file, rather than the name of a file, set *contentsNotFilename*; to ``True``. NOTE: chg/mult NYI. >>> H2O = qcdb.Molecule.init_with_mol2('h2o.mol2'). """"""; instance = cls(); instance.lock_frame = False; instance.PYmove_to_com = not no_com; instance.PYfix_orientation = no_reorient. if contentsNotFilename:; text = xyzfilename.splitlines(); else:; try:; infile = open(xyzfilename, 'r'); except IOError:; raise ValidationError(""""""Molecule::init_with_mol2: given filename '%s' does not exist."""""" %; (xyzfilename)); if os.stat(xyzfilename).st_size == 0:; raise ValidationError(""""""Molecule::init_with_mol2: given filename '%s' is blank."""""" % (xyzfilename)); text = infile.readlines(). # fixed-width regex ((?=[ ]*-?\d+)[ -\d]{5}); v2000 = re.compile(r'^((?=[ ]*\d+)[ \d]{3})((?=[ ]*\d+)[ \d]{3})(.*)V2000\s*$'); vend = re.compile(r'^\s*M",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/qcdb/molecule.html:9197,charge,charge,9197,psi4manual/1.2.1/_modules/psi4/driver/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/qcdb/molecule.html,1,['charge'],['charge']
Energy Efficiency," y, z, basis=None, shells=None)[source]¶; Class to hold all information about an atom, including its; coordinate specification as three Cartesians. clone()[source]¶; Returns new, independent CartesianEntry object. compute()[source]¶; Computes the values of the coordinates (in whichever units; were inputted), returning them in a Vector. everything()[source]¶. invalidate()[source]¶; Flags the current coordinates as being outdated. print_in_input_format()[source]¶; Prints the updated geometry, in the format provided by the user. print_in_input_format_cfour()[source]¶; Prints the updated geometry, in the format provided by the user.; This, for Cfour, not different from regular version. set_coordinates(x, y, z)[source]¶; Given the current set of coordinates, updates the values of this; atom’s coordinates and any variables that may depend on it. type()[source]¶; The type of CoordEntry specialization. class CoordEntry(entry_number, Z, charge, mass, symbol, label='', basis=None, shells=None)[source]¶; Class to store all the attributes associated with an atom, not the; larger Molecule. Specialized into CartesianEntry and ZMatrixEntry. Z()[source]¶; The nuclear charge of the current atom (0 if ghosted). static a(a1, a2, a3)[source]¶; Computes the angle (in rad.) between three sets of coordinates. basisset(role='BASIS')[source]¶; Returns the basis name for the provided type.; * @param type Keyword from input file.; * @returns the value from input. basissets()[source]¶; Returns basisset to atom map. charge()[source]¶; The “atomic charge” of the current atom (for SAD purposes). static d(a1, a2, a3, a4)[source]¶; Computes the dihedral (in rad.) between four sets of coordinates. entry_number()[source]¶; The order in which this appears in the full atom list. everything()[source]¶. is_computed()[source]¶; Whether the current atom’s coordinates are up-to-date. is_equivalent_to(other)[source]¶; Whether this atom has the same mass and ghost status as atom other.; Also compares basis se",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:114181,charge,charge,114181,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,2,['charge'],['charge']
Energy Efficiency," yields; the SAPT Level TOTAL ENERGY. SAPT0 TOTAL ENERGY¶. SSAPT0 TOTAL ENERGY¶. SAPT2 TOTAL ENERGY¶. SAPT2+ TOTAL ENERGY¶. SAPT2+(3) TOTAL ENERGY¶. SAPT2+3 TOTAL ENERGY¶; The total electronic interaction energy [E_h] for the labeled SAPT level; of theory. SAPT2+(CCD) DISP ENERGY¶. SAPT2+(CCD) ELST ENERGY¶. SAPT2+(CCD) EXCH ENERGY¶. SAPT2+(CCD) IND ENERGY¶. SAPT2+(3)(CCD) DISP ENERGY¶. SAPT2+(3)(CCD) ELST ENERGY¶. SAPT2+(3)(CCD) EXCH ENERGY¶. SAPT2+(3)(CCD) IND ENERGY¶. SAPT2+3(CCD) DISP ENERGY¶. SAPT2+3(CCD) ELST ENERGY¶. SAPT2+3(CCD) EXCH ENERGY¶. SAPT2+3(CCD) IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [E_h] for the; given SAPT level of theory that incorporates coupled-cluster dispersion.; The sum of these four components yields the SAPT Level TOTAL ENERGY. SAPT2+(CCD) TOTAL ENERGY¶. SAPT2+(3)(CCD) TOTAL ENERGY¶. SAPT2+3(CCD) TOTAL ENERGY¶; The total electronic interaction energy [E_h] for the labeled SAPT level; of theory that incorporates coupled-cluster dispersion. SAPT2+DMP2 DISP ENERGY¶. SAPT2+DMP2 ELST ENERGY¶. SAPT2+DMP2 EXCH ENERGY¶. SAPT2+DMP2 IND ENERGY¶. SAPT2+(3)DMP2 DISP ENERGY¶. SAPT2+(3)DMP2 ELST ENERGY¶. SAPT2+(3)DMP2 EXCH ENERGY¶. SAPT2+(3)DMP2 IND ENERGY¶. SAPT2+3DMP2 DISP ENERGY¶. SAPT2+3DMP2 ELST ENERGY¶. SAPT2+3DMP2 EXCH ENERGY¶. SAPT2+3DMP2 IND ENERGY¶. SAPT2+(CCD)DMP2 DISP ENERGY¶. SAPT2+(CCD)DMP2 ELST ENERGY¶. SAPT2+(CCD)DMP2 EXCH ENERGY¶. SAPT2+(CCD)DMP2 IND ENERGY¶. SAPT2+(3)(CCD)DMP2 DISP ENERGY¶. SAPT2+(3)(CCD)DMP2 ELST ENERGY¶. SAPT2+(3)(CCD)DMP2 EXCH ENERGY¶. SAPT2+(3)(CCD)DMP2 IND ENERGY¶. SAPT2+3(CCD)DMP2 DISP ENERGY¶. SAPT2+3(CCD)DMP2 ELST ENERGY¶. SAPT2+3(CCD)DMP2 EXCH ENERGY¶. SAPT2+3(CCD)DMP2 IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [E_h] for the; given SAPT level of theory that incorporates MP2 induction correction.; The sum of these four ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html:51380,energy,energy,51380,psi4manual/1.7.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html,4,['energy'],['energy']
Energy Efficiency," you’re determined to; have dashes and dots, they must be replaced by other characters in the; process_input line, then translated back in the GEOS section; see; NBC10.py for an example. The first line for each xyz file should be the number of atoms in the system.; The second line for each xyz file can be blank (interpreted as no comment), anything (interpreted as a comment), or two integers and anything (interpreted as charge, multiplicity, and remainder as comment).; The third and subsequent lines have four fields: the element symbol and the three cartesian coordinates in angstroms. The atom lines should not contain any dummy atoms (what’s the use in cartesian form). For dimer systems, an algorithm is used to apportion the atoms into two fragments; thus the atoms need not be arranged with all fragmentA atoms before all fragmentB atoms. The algorithm will fail for very closely arranged fragments. For dimers, any charge and multiplicity from the second line will be applied to fragmentA (python); charge and multiplicity may need to be redistributed later in the editing step. Run script psi4/lib/scripts/ixyz2database.pl. Move into the directory where all your xyz files are located. Run the; script in place, probably as; $PSIDATADIR/scripts/ixyz2database.pl. It will ask a number of; questions about your intended database and generate a python file; named for your database. Uppercase is preferable for database names; (according to Sherrill lab convention). Note your choice for the route; variable for the next step. Edit file database.py. According to your responses in to questions in the ixyz2database.pl script,; several bullets will be printed of edits you necessarily or optionally; should make. Copy your new database into psi4/lib/databases. Previous topic; Defining a Method Alias; Next topic; Contributions: Intro to Programming in PSI4; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/quickadddatabase-1.html:2951,charge,charge,2951,psi4manual/4.0b2/quickadddatabase-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/quickadddatabase-1.html,4,['charge'],['charge']
Energy Efficiency," you’re determined to; have dashes and dots, they must be replaced by other characters in the; process_input line, then translated back in the GEOS section; see; NBC10.py for an example. The first line for each xyz file should be the number of atoms in the system.; The second line for each xyz file can be blank (interpreted as no comment), anything (interpreted as a comment), or two integers and anything (interpreted as charge, multiplicity, and remainder as comment).; The third and subsequent lines have four fields: the element symbol and the three cartesian coordinates in angstroms. The atom lines should not contain any dummy atoms (what’s the use in cartesian form). For dimer systems, an algorithm is used to apportion the atoms into two fragments; thus the atoms need not be arranged with all fragmentA atoms before all fragmentB atoms. The algorithm will fail for very closely arranged fragments. For dimers, any charge and multiplicity from the second line will be applied to fragmentA (python); charge and multiplicity may need to be redistributed later in the editing step. Run script psi4/lib/scripts/ixyz2database.py. Move into the directory where all your xyz files are located. Run the; script, probably as $PSIDATADIR/scripts/ixyz2database.py. (If you; run it in place, there won’t be any path problems. It will ask a number of; questions about your intended database and generate a python file; named for your database. Uppercase is preferable for database names; (according to Sherrill lab convention). Note your choice for the route; variable for the next step. Edit file database.py. According to your responses in to questions in the ixyz2database.py script,; several bullets will be printed of edits you necessarily or optionally; should make. Copy your new database into psi4/lib/databases. Previous topic; Defining a Method Alias; Next topic; Contributions: Intro to Programming in PSI4; This Page. Show Source. Quick search. Enter search terms or a module, class or fun",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/quickadddatabase-1.html:2966,charge,charge,2966,psi4manual/4.0b3/quickadddatabase-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/quickadddatabase-1.html,12,['charge'],['charge']
Energy Efficiency," you’re determined to; have dashes and dots, they must be replaced by other characters in the; process_input line, then translated back in the GEOS section; see; NBC10.py for an example. The first line for each xyz file should be the number of atoms in the system.; The second line for each xyz file can be blank (interpreted as no comment), anything (interpreted as a comment), or two integers and anything (interpreted as charge, multiplicity, and remainder as comment).; The third and subsequent lines have four fields: the element symbol and the three cartesian coordinates in angstroms. The atom lines should not contain any dummy atoms (what’s the use in cartesian form). For dimer systems, an algorithm is used to apportion the atoms into two fragments; thus the atoms need not be arranged with all fragmentA atoms before all fragmentB atoms. The algorithm will fail for very closely arranged fragments. For dimers, any charge and multiplicity from the second line will be applied to fragmentA (python); charge and multiplicity may need to be redistributed later in the editing step. Run script psi4/psi4/share/psi4/scripts/ixyz2database.py. Move into the directory where all your xyz files are located. Run the; script. It will ask a number of; questions about your intended database and generate a python file; named for your database. Uppercase is preferable for database names; (according to Sherrill lab convention). Note your choice for the route; variable for the next step. Edit file database.py. According to your responses in to questions in the ixyz2database.py script,; several bullets will be printed of edits you necessarily or optionally; should make. Copy your new database into psi4/psi4/share/psi4/databases.; Alternately, append the directory containing your new database into; PSIPATH. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Customization: Adding Simple Extensions; Creating a Database. © Copyright 20",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/quickadddatabase.html:2949,charge,charge,2949,psi4manual/master/quickadddatabase.html,https://psicode.org,https://psicode.org/psi4manual/master/quickadddatabase.html,2,['charge'],['charge']
Energy Efficiency," you’re determined to; have dashes and dots, they must be replaced by other characters in the; process_input line, then translated back in the GEOS section; see; NBC10.py for an example. The first line for each xyz file should be the number of atoms in the system.; The second line for each xyz file can be blank (interpreted as no comment), anything (interpreted as a comment), or two integers and anything (interpreted as charge, multiplicity, and remainder as comment).; The third and subsequent lines have four fields: the element symbol and the three cartesian coordinates in angstroms. The atom lines should not contain any dummy atoms (what’s the use in cartesian form). For dimer systems, an algorithm is used to apportion the atoms into two fragments; thus the atoms need not be arranged with all fragmentA atoms before all fragmentB atoms. The algorithm will fail for very closely arranged fragments. For dimers, any charge and multiplicity from the second line will be applied to fragmentA (python); charge and multiplicity may need to be redistributed later in the editing step. Run script psi4/psi4/share/psi4/scripts/ixyz2database.py. Move into the directory where all your xyz files are located. Run the; script. It will ask a number of; questions about your intended database and generate a python file; named for your database. Uppercase is preferable for database names; (according to Sherrill lab convention). Note your choice for the route; variable for the next step. Edit file database.py. According to your responses in to questions in the ixyz2database.py script,; several bullets will be printed of edits you necessarily or optionally; should make. Copy your new database into psi4/psi4/share/psi4/databases.; Alternately, append the directory containing your new database into; PSIPATH. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Customization: Adding Simple Extensions; Creating a Database. © Copyright 2021, The P",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/quickadddatabase-1.html:2940,charge,charge,2940,psi4manual/1.4.0/quickadddatabase-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/quickadddatabase-1.html,4,['charge'],['charge']
Energy Efficiency," you’re determined to; have dashes and dots, they must be replaced by other characters in the; process_input line, then translated back in the GEOS section; see; NBC10.py for an example. The first line for each xyz file should be the number of atoms in the system.; The second line for each xyz file can be blank (interpreted as no comment), anything (interpreted as a comment), or two integers and anything (interpreted as charge, multiplicity, and remainder as comment).; The third and subsequent lines have four fields: the element symbol and the three cartesian coordinates in angstroms. The atom lines should not contain any dummy atoms (what’s the use in cartesian form). For dimer systems, an algorithm is used to apportion the atoms into two fragments; thus the atoms need not be arranged with all fragmentA atoms before all fragmentB atoms. The algorithm will fail for very closely arranged fragments. For dimers, any charge and multiplicity from the second line will be applied to fragmentA (python); charge and multiplicity may need to be redistributed later in the editing step. Run script psi4/psi4/share/psi4/scripts/ixyz2database.py. Move into the directory where all your xyz files are located. Run the; script. It will ask a number of; questions about your intended database and generate a python file; named for your database. Uppercase is preferable for database names; (according to Sherrill lab convention). Note your choice for the route; variable for the next step. Edit file database.py. According to your responses in to questions in the ixyz2database.py script,; several bullets will be printed of edits you necessarily or optionally; should make. Copy your new database into psi4/psi4/share/psi4/databases.; Alternately, append the directory containing your new database into; PSIPATH. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Customization: Adding Simple Extensions; Creating a Database. © Copyright 2021, The P",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/quickadddatabase-1.html:2940,charge,charge,2940,psi4manual/1.5.0/quickadddatabase-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/quickadddatabase-1.html,4,['charge'],['charge']
Energy Efficiency," you’re determined to; have dashes and dots, they must be replaced by other characters in the; process_input line, then translated back in the GEOS section; see; NBC10.py for an example. The first line for each xyz file should be the number of atoms in the system.; The second line for each xyz file can be blank (interpreted as no comment), anything (interpreted as a comment), or two integers and anything (interpreted as charge, multiplicity, and remainder as comment).; The third and subsequent lines have four fields: the element symbol and the three cartesian coordinates in angstroms. The atom lines should not contain any dummy atoms (what’s the use in cartesian form). For dimer systems, an algorithm is used to apportion the atoms into two fragments; thus the atoms need not be arranged with all fragmentA atoms before all fragmentB atoms. The algorithm will fail for very closely arranged fragments. For dimers, any charge and multiplicity from the second line will be applied to fragmentA (python); charge and multiplicity may need to be redistributed later in the editing step. Run script psi4/psi4/share/psi4/scripts/ixyz2database.py. Move into the directory where all your xyz files are located. Run the; script. It will ask a number of; questions about your intended database and generate a python file; named for your database. Uppercase is preferable for database names; (according to Sherrill lab convention). Note your choice for the route; variable for the next step. Edit file database.py. According to your responses in to questions in the ixyz2database.py script,; several bullets will be printed of edits you necessarily or optionally; should make. Copy your new database into psi4/psi4/share/psi4/databases.; Alternately, append the directory containing your new database into; PSIPATH. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Customization: Adding Simple Extensions; Creating a Database. © Copyright 2022, The P",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/quickadddatabase.html:2940,charge,charge,2940,psi4manual/1.6.x/quickadddatabase.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/quickadddatabase.html,2,['charge'],['charge']
Energy Efficiency," you’re determined to; have dashes and dots, they must be replaced by other characters in the; process_input line, then translated back in the GEOS section; see; NBC10.py for an example. The first line for each xyz file should be the number of atoms in the system.; The second line for each xyz file can be blank (interpreted as no comment), anything (interpreted as a comment), or two integers and anything (interpreted as charge, multiplicity, and remainder as comment).; The third and subsequent lines have four fields: the element symbol and the three cartesian coordinates in angstroms. The atom lines should not contain any dummy atoms (what’s the use in cartesian form). For dimer systems, an algorithm is used to apportion the atoms into two fragments; thus the atoms need not be arranged with all fragmentA atoms before all fragmentB atoms. The algorithm will fail for very closely arranged fragments. For dimers, any charge and multiplicity from the second line will be applied to fragmentA (python); charge and multiplicity may need to be redistributed later in the editing step. Run script psi4/psi4/share/psi4/scripts/ixyz2database.py. Move into the directory where all your xyz files are located. Run the; script. It will ask a number of; questions about your intended database and generate a python file; named for your database. Uppercase is preferable for database names; (according to Sherrill lab convention). Note your choice for the route; variable for the next step. Edit file database.py. According to your responses in to questions in the ixyz2database.py script,; several bullets will be printed of edits you necessarily or optionally; should make. Copy your new database into psi4/psi4/share/psi4/databases.; Alternately, append the directory containing your new database into; PSIPATH. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Customization: Adding Simple Extensions; Creating a Database. © Copyright 2007-2022, ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/quickadddatabase.html:2940,charge,charge,2940,psi4manual/1.7.x/quickadddatabase.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/quickadddatabase.html,2,['charge'],['charge']
Energy Efficiency," you’re determined to; have dashes and dots, they must be replaced by other characters in the; process_input line, then translated back in the GEOS section; see; NBC10.py for an example. The first line for each xyz file should be the number of atoms in the system.; The second line for each xyz file can be blank (interpreted as no comment), anything (interpreted as a comment), or two integers and anything (interpreted as charge, multiplicity, and remainder as comment).; The third and subsequent lines have four fields: the element symbol and the three cartesian coordinates in angstroms. The atom lines should not contain any dummy atoms (what’s the use in cartesian form). For dimer systems, an algorithm is used to apportion the atoms into two fragments; thus the atoms need not be arranged with all fragmentA atoms before all fragmentB atoms. The algorithm will fail for very closely arranged fragments. For dimers, any charge and multiplicity from the second line will be applied to fragmentA (python); charge and multiplicity may need to be redistributed later in the editing step. Run script psi4/psi4/share/psi4/scripts/ixyz2database.py. Move into the directory where all your xyz files are located. Run the; script. It will ask a number of; questions about your intended database and generate a python file; named for your database. Uppercase is preferable for database names; (according to Sherrill lab convention). Note your choice for the route; variable for the next step. Edit file database.py. According to your responses in to questions in the ixyz2database.py script,; several bullets will be printed of edits you necessarily or optionally; should make. Copy your new database into psi4/psi4/share/psi4/databases.; Alternately, append the directory containing your new database into; PSIPATH. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Customization: Adding Simple Extensions; Creating a Database. © Copyright 2007-2023",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/quickadddatabase.html:2942,charge,charge,2942,psi4manual/1.8.x/quickadddatabase.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/quickadddatabase.html,2,['charge'],['charge']
Energy Efficiency," you’re determined to; have dashes and dots, they must be replaced by other characters in the; process_input line, then translated back in the GEOS section; see; NBC10.py for an example. The first line for each xyz file should be the number of atoms in the system.; The second line for each xyz file can be blank (interpreted as no comment), anything (interpreted as a comment), or two integers and anything (interpreted as charge, multiplicity, and remainder as comment).; The third and subsequent lines have four fields: the element symbol and the three cartesian coordinates in angstroms. The atom lines should not contain any dummy atoms (what’s the use in cartesian form). For dimer systems, an algorithm is used to apportion the atoms into two fragments; thus the atoms need not be arranged with all fragmentA atoms before all fragmentB atoms. The algorithm will fail for very closely arranged fragments. For dimers, any charge and multiplicity from the second line will be applied to fragmentA (python); charge and multiplicity may need to be redistributed later in the editing step. Run script psi4/psi4/share/psi4/scripts/ixyz2database.py. Move into the directory where all your xyz files are located. Run the; script. It will ask a number of; questions about your intended database and generate a python file; named for your database. Uppercase is preferable for database names; (according to Sherrill lab convention). Note your choice for the route; variable for the next step. Edit file database.py. According to your responses in to questions in the ixyz2database.py script,; several bullets will be printed of edits you necessarily or optionally; should make. Copy your new database into psi4/psi4/share/psi4/databases.; Alternately, append the directory containing your new database into; PSIPATH. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Customization: Adding Simple Extensions; Creating a Database. © Copyright 2007-2024",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/quickadddatabase.html:2942,charge,charge,2942,psi4manual/1.9.x/quickadddatabase.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/quickadddatabase.html,2,['charge'],['charge']
Energy Efficiency," you’re determined to; have dashes and dots, they must be replaced by other characters in the; process_input line, then translated back in the GEOS section; see; NBC10.py for an example. The first line for each xyz file should be the number of atoms in the system.; The second line for each xyz file can be blank (interpreted as no comment), anything (interpreted as a comment), or two integers and anything (interpreted as charge, multiplicity, and remainder as comment).; The third and subsequent lines have four fields: the element symbol and the three cartesian coordinates in angstroms. The atom lines should not contain any dummy atoms (what’s the use in cartesian form). For dimer systems, an algorithm is used to apportion the atoms into two fragments; thus the atoms need not be arranged with all fragmentA atoms before all fragmentB atoms. The algorithm will fail for very closely arranged fragments. For dimers, any charge and multiplicity from the second line will be applied to fragmentA (python); charge and multiplicity may need to be redistributed later in the editing step. Run script psi4/share/scripts/ixyz2database.py. Move into the directory where all your xyz files are located. Run the; script, probably as $PSIDATADIR/scripts/ixyz2database.py. (If you; run it in place, there won’t be any path problems. It will ask a number of; questions about your intended database and generate a python file; named for your database. Uppercase is preferable for database names; (according to Sherrill lab convention). Note your choice for the route; variable for the next step. Edit file database.py. According to your responses in to questions in the ixyz2database.py script,; several bullets will be printed of edits you necessarily or optionally; should make. Copy your new database into psi4/share/databases.; Alternately, append the directory containing your new database into; PSIPATH. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Customization: Adding Simple ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/quickadddatabase-1.html:2921,charge,charge,2921,psi4manual/1.1.0/quickadddatabase-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/quickadddatabase-1.html,4,['charge'],['charge']
Energy Efficiency," you’re determined to; have dashes and dots, they must be replaced by other characters in the; process_input line, then translated back in the GEOS section; see; NBC10.py for an example. The first line for each xyz file should be the number of atoms in the system.; The second line for each xyz file can be blank (interpreted as no comment), anything (interpreted as a comment), or two integers and anything (interpreted as charge, multiplicity, and remainder as comment).; The third and subsequent lines have four fields: the element symbol and the three cartesian coordinates in angstroms. The atom lines should not contain any dummy atoms (what’s the use in cartesian form). For dimer systems, an algorithm is used to apportion the atoms into two fragments; thus the atoms need not be arranged with all fragmentA atoms before all fragmentB atoms. The algorithm will fail for very closely arranged fragments. For dimers, any charge and multiplicity from the second line will be applied to fragmentA (python); charge and multiplicity may need to be redistributed later in the editing step. Run script psi4/share/scripts/ixyz2database.py. Move into the directory where all your xyz files are located. Run the; script, probably as $PSIDATADIR/scripts/ixyz2database.py. (If you; run it in place, there won’t be any path problems. It will ask a number of; questions about your intended database and generate a python file; named for your database. Uppercase is preferable for database names; (according to Sherrill lab convention). Note your choice for the route; variable for the next step. Edit file database.py. According to your responses in to questions in the ixyz2database.py script,; several bullets will be printed of edits you necessarily or optionally; should make. Copy your new database into psi4/share/databases.; Alternately, append the directory containing your new database into; PSIPATH. Previous topic; Defining a Method Alias; Next topic; Appendices. This Page. Show Source. Quick se",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/quickadddatabase-1.html:2973,charge,charge,2973,psi4manual/1.0.0/quickadddatabase-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/quickadddatabase-1.html,4,['charge'],['charge']
Energy Efficiency," you’re determined to; have dashes and dots, they must be replaced by other characters in the; process_input line, then translated back in the GEOS section; see; NBC10.py for an example. The first line for each xyz file should be the number of atoms in the system.; The second line for each xyz file can be blank (interpreted as no comment), anything (interpreted as a comment), or two integers and anything (interpreted as charge, multiplicity, and remainder as comment).; The third and subsequent lines have four fields: the element symbol and the three cartesian coordinates in angstroms. The atom lines should not contain any dummy atoms (what’s the use in cartesian form). For dimer systems, an algorithm is used to apportion the atoms into two fragments; thus the atoms need not be arranged with all fragmentA atoms before all fragmentB atoms. The algorithm will fail for very closely arranged fragments. For dimers, any charge and multiplicity from the second line will be applied to fragmentA (python); charge and multiplicity may need to be redistributed later in the editing step. Run script psi4/share/scripts/ixyz2database.py. Move into the directory where all your xyz files are located. Run the; script, probably as $PSIDATADIR/scripts/ixyz2database.py. (If you; run it in place, there won’t be any path problems. It will ask a number of; questions about your intended database and generate a python file; named for your database. Uppercase is preferable for database names; (according to Sherrill lab convention). Note your choice for the route; variable for the next step. Edit file database.py. According to your responses in to questions in the ixyz2database.py script,; several bullets will be printed of edits you necessarily or optionally; should make. Copy your new database into psi4/share/databases.; Alternately, append the directory containing your new database into; PSIPATH. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · .",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/quickadddatabase-1.html:2923,charge,charge,2923,psi4manual/1.2.1/quickadddatabase-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/quickadddatabase-1.html,4,['charge'],['charge']
Energy Efficiency," you’re determined to; have dashes and dots, they must be replaced by other characters in the; process_input line, then translated back in the GEOS section; see; NBC10.py for an example. The first line for each xyz file should be the number of atoms in the system.; The second line for each xyz file can be blank (interpreted as no comment), anything (interpreted as a comment), or two integers and anything (interpreted as charge, multiplicity, and remainder as comment).; The third and subsequent lines have four fields: the element symbol and the three cartesian coordinates in angstroms. The atom lines should not contain any dummy atoms (what’s the use in cartesian form). For dimer systems, an algorithm is used to apportion the atoms into two fragments; thus the atoms need not be arranged with all fragmentA atoms before all fragmentB atoms. The algorithm will fail for very closely arranged fragments. For dimers, any charge and multiplicity from the second line will be applied to fragmentA (python); charge and multiplicity may need to be redistributed later in the editing step. Run script psi4/share/scripts/ixyz2database.py. Move into the directory where all your xyz files are located. Run the; script, probably as $PSIDATADIR/scripts/ixyz2database.py. (If you; run it in place, there won’t be any path problems. It will ask a number of; questions about your intended database and generate a python file; named for your database. Uppercase is preferable for database names; (according to Sherrill lab convention). Note your choice for the route; variable for the next step. Edit file database.py. According to your responses in to questions in the ixyz2database.py script,; several bullets will be printed of edits you necessarily or optionally; should make. Copy your new database into psi4/share/databases.; Alternately, append the directory containing your new database into; PSIPATH. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · .",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/quickadddatabase-1.html:2923,charge,charge,2923,psi4manual/1.3.2/quickadddatabase-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/quickadddatabase-1.html,4,['charge'],['charge']
Energy Efficiency," {; Ne; Ne 1 2.0; }. nene.update_geometry(). >>> E, G = nene.run_gcp('hf3c'). >>> E, G = nene.run_gcp(func='HF3c', verbose=True). qcdb.Molecule.run_gcp(self, func=None, dertype=None, verbose=1)¶; Compute geometrical BSSE correction via Grimme’s GCP program.; Function to call Grimme’s GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to self for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, func. Returns energy if dertype is 0, gradient; if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The gcp executable must be independently compiled and; found in PATH or PSIPATH. self may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.Molecule. Parameters. func (str, optional) – Name of method/basis combination or composite method for which to compute the correction; (e.g., HF/cc-pVDZ, DFT/def2-SVP, HF3c, PBEh3c).; dertype (int or str, optional) – Maximum derivative level at which to run GCP. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int, optional) – Amount of printing. Unused at present. Returns. energy (float) – When dertype=0, energy [Eh].; gradient (ndarray) – When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray) – When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. table of contents. Interface to gCP by S. Grimme; Installation; Running gCP. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to gCP by S. Grimme. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/gcp.html:3910,energy,energy-only,3910,psi4manual/1.6.x/gcp.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/gcp.html,6,"['efficient', 'energy']","['efficient', 'energy', 'energy-only']"
Energy Efficiency," | ; | C++ signature :; | i molecular_charge(N3psi8MoleculeE {lvalue}); | ; | move_to_com(...); | move_to_com( (Molecule)arg1) -> None :; | Moves molecule to center of mass; | ; | C++ signature :; | void move_to_com(N3psi8MoleculeE {lvalue}); | ; | multiplicity(...); | multiplicity( (Molecule)arg1) -> int :; | Gets the multiplicity (defined as 2Ms + 1); | ; | C++ signature :; | i multiplicity(N3psi8MoleculeE {lvalue}); | ; | name(...); | name( (Molecule)arg1) -> str :; | Gets molecule name; | ; | C++ signature :; | Ss name(N3psi8MoleculeE {lvalue}); | ; | natom(...); | natom( (Molecule)arg1) -> int :; | Number of real atoms; | ; | C++ signature :; | i natom(N3psi8MoleculeE {lvalue}); | ; | nfragments(...); | nfragments( (Molecule)arg1) -> int :; | Gets the number of fragments in the molecule; | ; | C++ signature :; | i nfragments(N3psi8MoleculeE {lvalue}); | ; | nuclear_repulsion_energy(...); | nuclear_repulsion_energy( (Molecule)arg1) -> float :; | Computes nuclear repulsion energy; | ; | C++ signature :; | d nuclear_repulsion_energy(N3psi8MoleculeE {lvalue}); | ; | point_group(...); | point_group( (Molecule)arg1) -> PointGroup :; | Returns the current point group object; | ; | C++ signature :; | N5boost10shared_ptrIN3psi10PointGroupEEE point_group(N3psi8MoleculeE {lvalue}); | ; | print_cluster(...); | print_cluster( (Molecule)arg1) -> None :; | Prints the molecule in Cartesians in input units adding fragment separators; | ; | C++ signature :; | void print_cluster(N3psi8MoleculeE {lvalue}); | ; | print_in_input_format(...); | print_in_input_format( (Molecule)arg1) -> None :; | Prints the molecule as Cartesian or ZMatrix entries, just as inputted.; | ; | C++ signature :; | void print_in_input_format(N3psi8MoleculeE {lvalue}); | ; | print_out(...); | print_out( (Molecule)arg1) -> None :; | Prints the molecule in Cartesians in input units; | ; | C++ signature :; | void print_out(N3psi8MoleculeE {lvalue}); | ; | print_out_in_angstrom(...); | print_out_in_angstrom( (Mol",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:550473,energy,energy,550473,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['energy'],['energy']
Energy Efficiency," | ; | Cb(...); | Cb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Da(...); | Da( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Db(...); | Db( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fa(...); | Fa( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fb(...); | Fb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | add_postiteration_callback(...); | add_postiteration_callback( (Wavefunction)arg1, (object)arg2) -> None :; | docstring; | ; | add_preiteration_callback(...); | add_preiteration_callback( (Wavefunction)arg1, (object)arg2) -> None :; | docstring; | ; | alpha_orbital_space(...); | alpha_orbital_space( (Wavefunction)arg1, (str)arg2, (str)arg3, (str)arg4) -> OrbitalSpace :; | docstring; | ; | basisset(...); | basisset( (Wavefunction)arg1) -> BasisSet :; | docstring; | ; | beta_orbital_space(...); | beta_orbital_space( (Wavefunction)arg1, (str)arg2, (str)arg3, (str)arg4) -> OrbitalSpace :; | docstring; | ; | energy(...); | energy( (Wavefunction)arg1) -> float :; | docstring; | ; | epsilon_a(...); | epsilon_a( (Wavefunction)arg1) -> Vector :; | docstring; | ; | epsilon_b(...); | epsilon_b( (Wavefunction)arg1) -> Vector :; | docstring; | ; | frequencies(...); | frequencies( (Wavefunction)arg1) -> Vector :; | docstring; | ; | gradient(...); | gradient( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | molecule(...); | molecule( (Wavefunction)arg1) -> Molecule :; | docstring; | ; | nirrep(...); | nirrep( (Wavefunction)arg1) -> int :; | docstring; | ; | nmo(...); | nmo( (Wavefunction)arg1) -> int :; | docstring; | ; | nso(...); | nso( (Wavefunction)arg1) -> int :; | docstring; | ; | sobasisset(...); | sobasisset( (Wavefunction)arg1) -> SOBasisSet :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inher",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/psimod-1.html:28693,energy,energy,28693,psi4manual/4.0b2/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html,4,['energy'],['energy']
Energy Efficiency," | \Phi_i^a \rangle \\; {\hat T}_2 | \Phi_0 \rangle &= \sum_{i<j}^{\rm occ} \sum_{a<b}^{\rm vir} t_{ij}^{ab} | \Phi_{ij}^{ab} \rangle,\end{split}\]; etc. The popular coupled cluster singles and doubles (CCSD) model; [Purvis:1982] truncates the expansion at \({\hat{T}} = {\hat{T}_1}; + {\hat{T}_2}\). This model has the same number of parameters as; configuration interaction singles and doubles (CISD) but improves upon; it by approximately accounting for higher-order terms using products; of lower-order terms (e.g., the term \({\hat{T}_2}^2\) approximately; accounts for quadruple excitations). The inclusion of such products; makes coupled-cluster methods size extensive, meaning that the; quality of the computation should not degrade for larger molecules.; The computational cost for CCSD scales as \({\cal{O}}(o^2 v^4)\), where; \(o\) is the number of occupied orbitals and \(v\) is the number of virtual; orbitals.; Improving upon CCSD, the CCSD(T) method [Raghavachari:1989] includes; a perturbative estimate of the energy contributed by the \({\hat{T}_3}\); operator. The computational cost of this additional term scales as; \({\cal{O}}(o^3 v^4)\), making it rather expensive for molecules with more than; a dozen heavy atoms or so. However, when this method is affordable, it; provides very high quality results in most cases.; PSI4 is capable of computing energies and analytic gradients for a; number of coupled cluster models. It can also compute linear response; properties (such as static or frequency-dependent polarizability,; or optical rotation angles) for some models. Excited states can; also be computed by the CC2 and CC3 models, or by EOM-CCSD. Table; CC Methods summarizes these capabilities. This section; describes how to carry out coupled cluster calculations within PSI4.; For higher-order coupled-cluster methods like CCSDT and CCSDTQ, PSI4; can interface to Kállay’s MRCC code (see MRCC).; Solvent effects on energies can be taken into account using the polarizable; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/cc-1.html:2352,energy,energy,2352,psi4manual/1.2.1/cc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/cc-1.html,15,['energy'],['energy']
Energy Efficiency," | ndarray(ndof) float (+/0) |; +---------------+--------------------------------------------+-----------+------------------------------------------------------+; | Qtp0 | Turning point v=0 | a0 u^1/2 | ndarray(ndof) float (+/0) |; +---------------+--------------------------------------------+-----------+------------------------------------------------------+; | Xtp0 | Turning point v=0 | a0 | ndarray(ndof) float (+/0) |; +---------------+--------------------------------------------+-----------+------------------------------------------------------+; | theta_vib | char temp | K | ndarray(ndof) float (+/0) |; +---------------+--------------------------------------------+-----------+------------------------------------------------------+; | IR_intensity | infrared intensity | km/mol | ndarray(ndof) float (+/+) |; +---------------+--------------------------------------------+-----------+------------------------------------------------------+. Examples; --------; >>> # displacement of first atom in highest energy mode; >>> vibinfo['x'].data[:, -1].reshape(nat, 3)[0]. >>> # remove translations & rotations; >>> vibonly = filter_nonvib(vibinfo). """"""; if (mass.shape[0] == geom.shape[0] == (hess.shape[0] // 3) == (hess.shape[1] // 3)) and (geom.shape[1] == 3):; pass; else:; raise ValidationError(; f""""""Dimension mismatch among mass ({mass.shape}), geometry ({geom.shape}), and Hessian ({hess.shape})""""""). def mat_symm_info(a, atol=1e-14, lbl='array', stol=None):; symm = np.allclose(a, a.T, atol=atol); herm = np.allclose(a, a.conj().T, atol=atol); ivrt = a.shape[0] - np.linalg.matrix_rank(a, tol=stol); return """""" {:32} Symmetric? {} Hermitian? {} Lin Dep Dim? {:2}"""""".format(lbl + ':', symm, herm, ivrt). def vec_in_space(vec, space, tol=1.0e-4):; merged = np.vstack((space, vec)); u, s, v = np.linalg.svd(merged); return (s[-1] < tol). vibinfo = {}; text = []. nat = len(mass); text.append(""""""\n\n ==> Harmonic Vibrational Analysis <==\n""""""). if nat == 1:; nrt_expected = 3; elif np.li",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/qcdb/vib.html:15637,energy,energy,15637,psi4manual/1.4.0/_modules/psi4/driver/qcdb/vib.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/qcdb/vib.html,12,['energy'],['energy']
Energy Efficiency," |dl| ``'off'`` |dr|. If True returns the total data (energy/gradient/Hessian) of the system,; otherwise returns interaction data. Default is ``'off'`` for energies,; ``'on'`` for gradients and Hessians. Note that the calculation of total; counterpoise corrected energies implies the calculation of the energies of; monomers in the monomer basis, hence specifying ``return_total_data = True``; may carry out more computations than ``return_total_data = False``.; For gradients and Hessians, ``return_total_data = False`` is rarely useful. :type levels: dict; :param levels: ``{1: 'ccsd(t)', 2: 'mp2', 'supersystem': 'scf'}`` || ``{1: 2, 2: 'ccsd(t)', 3: 'mp2'}`` || etc. Dictionary of different levels of theory for different levels of expansion; Note that method_string is not used in this case. ``supersystem`` computes; all higher order n-body effects up to the number of fragments. :type embedding_charges: dict; :param embedding_charges: ``{1: [-0.834, 0.417, 0.417], ..}``. Dictionary of atom-centered point charges. keys: 1-based index of fragment, values: list of charges for each fragment.; Add atom-centered point charges for fragments whose basis sets are not included in the computation. """""". [docs]; class BsseEnum(str, Enum):; """"""Available basis-set superposition error (BSSE) treatments."""""". nocp = ""nocp"" # plain supramolecular interaction energy; cp = ""cp"" # counterpoise correction; vmfc = ""vmfc"" # Valiron-Mayer function counterpoise. def _sum_cluster_ptype_data(; ptype: DriverEnum,; ptype_dict: Dict,; compute_list: Set[FragBasIndex],; fragment_slice_dict: Dict[int, Sequence],; fragment_size_dict: Dict[int, int],; mc_level_lbl: int,; vmfc: bool = False,; nb: int = 0,; ) -> Union[float, np.ndarray]:; """"""; Sum arrays from n-body computations to obtain the BSSE corrected or uncorrected scalar or array. Parameters; ----------; ptype; Hint to shape of array data to sum.; ptype_dict; Dictionary containing computed energy, gradient, or Hessian obtained from each subsystem comput",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/driver_nbody.html:10602,charge,charges,10602,psi4manual/1.9.x/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/driver_nbody.html,2,['charge'],['charges']
Energy Efficiency," |dl| ``'off'`` |dr|. If True returns the total data (energy/gradient/Hessian) of the system,; otherwise returns interaction data. Default is ``'off'`` for energies,; ``'on'`` for gradients and Hessians. Note that the calculation of total; counterpoise corrected energies implies the calculation of the energies of; monomers in the monomer basis, hence specifying ``return_total_data = True``; may carry out more computations than ``return_total_data = False``.; For gradients and Hessians, ``return_total_data = False`` is rarely useful. :type levels: dict; :param levels: ``{1: 'ccsd(t)', 2: 'mp2', 'supersystem': 'scf'}`` || ``{1: 2, 2: 'ccsd(t)', 3: 'mp2'}`` || etc. Dictionary of different levels of theory for different levels of expansion; Note that method_string is not used in this case. ``supersystem`` computes; all higher order n-body effects up to the number of fragments. :type embedding_charges: dict; :param embedding_charges: ``{1: [-0.834, 0.417, 0.417], ..}``. Dictionary of atom-centered point charges. keys: 1-based index of fragment, values: list of charges for each fragment.; Add atom-centered point charges for fragments whose basis sets are not included in the computation. """"""; pass. [docs]; class BsseEnum(str, Enum):; """"""Available basis-set superposition error (BSSE) treatments."""""". nocp = ""nocp"" # plain supramolecular interaction energy; cp = ""cp"" # counterpoise correction; vmfc = ""vmfc"" # Valiron-Mayer function counterpoise. def _sum_cluster_ptype_data(; ptype: DriverEnum,; ptype_dict: Dict,; compute_list: Set[FragBasIndex],; fragment_slice_dict: Dict[int, Sequence],; fragment_size_dict: Dict[int, int],; mc_level_lbl: int,; vmfc: bool = False,; nb: int = 0,; ) -> Union[float, np.ndarray]:; """"""; Sum arrays from n-body computations to obtain the BSSE corrected or uncorrected scalar or array. Parameters; ----------; ptype; Hint to shape of array data to sum.; ptype_dict; Dictionary containing computed energy, gradient, or Hessian obtained from each subsystem ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:10716,charge,charges,10716,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,1,['charge'],['charges']
Energy Efficiency," |dl| ``'off'`` |dr|. If True returns the total data (energy/gradient/Hessian) of the system,; otherwise returns interaction data. Default is ``'off'`` for energies,; ``'on'`` for gradients and Hessians. Note that the calculation of total; counterpoise corrected energies implies the calculation of the energies of; monomers in the monomer basis, hence specifying ``return_total_data = True``; may carry out more computations than ``return_total_data = False``.; For gradients and Hessians, ``return_total_data = False`` is rarely useful. :type levels: dict; :param levels: ``{1: 'ccsd(t)', 2: 'mp2', 'supersystem': 'scf'}`` || ``{1: 2, 2: 'ccsd(t)', 3: 'mp2'}`` || etc. Dictionary of different levels of theory for different levels of expansion; Note that method_string is not used in this case. ``supersystem`` computes; all higher order n-body effects up to the number of fragments. :type embedding_charges: dict; :param embedding_charges: ``{1: [-0.834, 0.417, 0.417], ..}``. Dictionary of atom-centered point charges. keys: 1-based index of fragment, values: list of charges for each fragment.; Add atom-centered point charges for fragments whose basis sets are not included in the computation. """"""; pass. [docs]class BsseEnum(str, Enum):; """"""Available basis-set superposition error (BSSE) treatments."""""". nocp = ""nocp"" # plain supramolecular interaction energy; cp = ""cp"" # counterpoise correction; vmfc = ""vmfc"" # Valiron-Mayer function counterpoise. def _sum_cluster_ptype_data(; ptype: DriverEnum,; ptype_dict: Dict,; compute_list: Set[FragBasIndex],; fragment_slice_dict: Dict[int, Sequence],; fragment_size_dict: Dict[int, int],; mc_level_lbl: int,; vmfc: bool = False,; nb: int = 0,; ) -> Union[float, np.ndarray]:; """"""; Sum arrays from n-body computations to obtain the BSSE corrected or uncorrected scalar or array. Parameters; ----------; ptype; Hint to shape of array data to sum.; ptype_dict; Dictionary containing computed energy, gradient, or Hessian obtained from each subsystem co",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_nbody.html:10643,charge,charges,10643,psi4manual/1.7.x/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_nbody.html,1,['charge'],['charges']
Energy Efficiency," |dl| ``'off'`` |dr|. If True returns the total data (energy/gradient/Hessian) of the system,; otherwise returns interaction data. Default is ``'off'`` for energies,; ``'on'`` for gradients and Hessians. Note that the calculation of total; counterpoise corrected energies implies the calculation of the energies of; monomers in the monomer basis, hence specifying ``return_total_data = True``; may carry out more computations than ``return_total_data = False``.; For gradients and Hessians, ``return_total_data = False`` is rarely useful. :type levels: dict; :param levels: ``{1: 'ccsd(t)', 2: 'mp2', 'supersystem': 'scf'}`` || ``{1: 2, 2: 'ccsd(t)', 3: 'mp2'}`` || etc. Dictionary of different levels of theory for different levels of expansion; Note that method_string is not used in this case. ``supersystem`` computes; all higher order n-body effects up to the number of fragments. :type embedding_charges: dict; :param embedding_charges: ``{1: [-0.834, 0.417, 0.417], ..}``. Dictionary of atom-centered point charges. keys: 1-based index of fragment, values: list of charges for each fragment.; Add atom-centered point charges for fragments whose basis sets are not included in the computation. """"""; pass. class BsseEnum(str, Enum):; """"""Available basis-set superposition error (BSSE) treatments."""""". nocp = ""nocp"" # plain supramolecular interaction energy; cp = ""cp"" # counterpoise correction; vmfc = ""vmfc"" # Valiron-Mayer function counterpoise. def _sum_cluster_ptype_data(; ptype: DriverEnum,; ptype_dict: Dict,; compute_list: Set[FragBasIndex],; fragment_slice_dict: Dict[int, Sequence],; fragment_size_dict: Dict[int, int],; mc_level_lbl: int,; vmfc: bool = False,; nb: int = 0,; ) -> Union[float, np.ndarray]:; """"""; Sum arrays from n-body computations to obtain the BSSE corrected or uncorrected scalar or array. Parameters; ----------; ptype; Hint to shape of array data to sum.; ptype_dict; Dictionary containing computed energy, gradient, or Hessian obtained from each subsystem computat",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html:10441,charge,charges,10441,psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html,1,['charge'],['charges']
Energy Efficiency," |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set set through ``set`` commands have no influence; on a cbs calculation. :type scf_basis: :ref:`basis string <apdx:basisElement>`; :param scf_basis: |dl| ``corl_basis`` |dr| || ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, ``scf_basis`` can default; to ``corl_basis``. :type corl_basis: :ref:`basis string <apdx:basisElement>`; :param corl_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the correlation energy. :type delta_basis: :ref:`basis string <apdx:basisElement>`; :param delta_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. :type delta2_basis: :ref:`basis string <apdx:basisElement>`; :param delta2_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. * Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, ``'highest_1'``, which uses the best basis; set available. See `Extrapolation Schemes`_ for all available schemes. :type scf_scheme: function; :param scf_scheme: |dl| ``highest_1`` |dr| || ``scf_xtpl_helgaker_3`` || etc. Indicates the basis set extrapolation scheme to be applied to the reference energy. :type corl_scheme: function; :param corl_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:55378,energy,energy,55378,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,3,['energy'],['energy']
Energy Efficiency," |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set set through ``set`` commands have no influence; on a cbs calculation. :type scf_basis: :ref:`basis string <apdx:basisElement>`; :param scf_basis: |dl| ``corl_basis`` |dr| || ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, ``scf_basis`` can default; to ``corl_basis``. :type corl_basis: :ref:`basis string <apdx:basisElement>`; :param corl_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the correlation energy. :type delta_basis: :ref:`basis string <apdx:basisElement>`; :param delta_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. :type delta2_basis: :ref:`basis string <apdx:basisElement>`; :param delta2_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. * Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, ``'xtpl_highest_1'``, which uses the best basis; set available. See :ref:`sec:cbs_xtpl` for all available schemes. :type scf_scheme: Callable; :param scf_scheme: |dl| ``xtpl_highest_1`` |dr| || ``scf_xtpl_helgaker_3`` || etc. Indicates the basis set extrapolation scheme to be applied to the reference energy.; Defaults to :py:func:`~psi4.driver.driver_cbs.scf_xtpl_helgaker_3` if three valid basis sets; present in ``psi4.driver.driv",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:38657,energy,energy,38657,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,2,['energy'],['energy']
Energy Efficiency," |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set set through ``set`` commands have no influence; on a cbs calculation. :type scf_basis: :ref:`basis string <apdx:basisElement>`; :param scf_basis: |dl| ``corl_basis`` |dr| || ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, ``scf_basis`` can default; to ``corl_basis``. :type corl_basis: :ref:`basis string <apdx:basisElement>`; :param corl_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the correlation energy. :type delta_basis: :ref:`basis string <apdx:basisElement>`; :param delta_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. :type delta2_basis: :ref:`basis string <apdx:basisElement>`; :param delta2_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. * Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, ``'xtpl_highest_1'``, which uses the best basis; set available. See :ref:`sec:cbs_xtpl` for all available schemes. :type scf_scheme: function; :param scf_scheme: |dl| ``xtpl_highest_1`` |dr| || ``scf_xtpl_helgaker_3`` || etc. Indicates the basis set extrapolation scheme to be applied to the reference energy.; Defaults to :py:func:`~scf_xtpl_helgaker_3` if three valid basis sets; present in ``scf_basis``, :py:func:`~scf_xtpl_helgak",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html:38402,energy,energy,38402,psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,1,['energy'],['energy']
Energy Efficiency," |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set set through ``set`` commands have no influence; on a cbs calculation. :type scf_basis: :ref:`basis string <apdx:basisElement>`; :param scf_basis: |dl| ``corl_basis`` |dr| || ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, ``scf_basis`` can default; to ``corl_basis``. :type corl_basis: :ref:`basis string <apdx:basisElement>`; :param corl_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the correlation energy. :type delta_basis: :ref:`basis string <apdx:basisElement>`; :param delta_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. :type delta2_basis: :ref:`basis string <apdx:basisElement>`; :param delta2_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. * Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, ``'xtpl_highest_1'``, which uses the best basis; set available. See :ref:`sec:cbs_xtpl` for all available schemes. :type scf_scheme: str; :param scf_scheme: |dl| ``'xtpl_highest_1'`` |dr| || ``'scf_xtpl_helgaker_3'`` || etc. Indicates the basis set extrapolation scheme to be applied to the reference energy.; Defaults to :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_helgaker_3` if three valid basis sets; present in ``psi4.drive",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_cbs.html:26441,energy,energy,26441,psi4manual/1.7.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_cbs.html,4,['energy'],['energy']
Energy Efficiency," |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set set through ``set`` commands have no influence; on a cbs calculation. :type scf_basis: :ref:`basis string <apdx:basisElement>`; :param scf_basis: |dl| ``corl_basis`` |dr| || ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, ``scf_basis`` can default; to ``corl_basis``. :type corl_basis: :ref:`basis string <apdx:basisElement>`; :param corl_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the correlation energy. :type delta_basis: :ref:`basis string <apdx:basisElement>`; :param delta_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. :type delta2_basis: :ref:`basis string <apdx:basisElement>`; :param delta2_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. * Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, ``'xtpl_highest_1'``, which uses the best basis; set available. See :ref:`sec:cbs_xtpl` for all available schemes. :type scf_scheme: string; :param scf_scheme: |dl| ``'xtpl_highest_1'`` |dr| || ``'scf_xtpl_helgaker_3'`` || etc. Indicates the basis set extrapolation scheme to be applied to the reference energy.; Defaults to :py:func:`~psi4.driver.driver_cbs.scf_xtpl_helgaker_3` if three valid basis sets; present in ``psi4.driver.dr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html:26440,energy,energy,26440,psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,1,['energy'],['energy']
Energy Efficiency," }\]. db_name DATABASE MEAN SIGNED DEVIATION¶; The mean deviation [kcal mol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. \[\frac{1}{n}\sum_{rxn}^{n}{\textsf{\textsl{name}}_{rxn}-\text{REF}_{rxn}}\]. db_name DATABASE ROOT-MEAN-SQUARE DEVIATION¶; The rms deviation [kcal mol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. \[\sqrt{\frac{1}{n}\sum_{rxn}^{n}{(\textsf{\textsl{name}}_{rxn}-\text{REF}_{rxn})^2}}\]. DCT LAMBDA ENERGY¶; An energy term in density cumulant theory [Eh]. This term is the; 2-electron cumulant’s contribution contribution to the reduced; density matrix energy expression. Not recommended for interpretative; use except by reduced density matrix specialists. DCT SCF ENERGY¶; An energy term in density cumulant theory [Eh]. This term is the; 1-electron reduced density matrix (1RDM) contribution to the reduced; density matrix energy expression, plus the contribution of the; antisymmetrized product of 1RDMs. Not recommended for interpretative; use except by reduced density matrix specialists. DCT THREE-PARTICLE ENERGY¶; The three-particle correlation energy correction [Eh] in density cumulant; theory, akin to (T) CORRECTION ENERGY in coupled-cluster. DCT TOTAL ENERGY¶; Total energy [Eh] in density cumulant theory. Sum of DCT SCF ENERGY,; DCT LAMBDA ENERGY, and DCT THREE-PARTICLE ENERGY when present. DETCI AVG DVEC NORM¶; A measure of configuration interaction convergence. DFT FUNCTIONAL TOTAL ENERGY¶; The total electronic energy [Eh] for the underlying functional of the; requested DFT method, without any dispersion correction; the first four; terms in Eq. (4) or (1). Quantity; \(E_{\text{FCTL}}\) in Eqs. (4) and (1).; Unless the method includes a dispersion correction, this ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html:18383,energy,energy,18383,psi4manual/1.4.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html,5,['energy'],['energy']
Energy Efficiency,"    .    .    .    .  · ; 1.4;  · . PSI4. Psithon Functions: Invoking a Calculation; Single-Point Energy — energy(). Single-Point Energy — energy()¶. Psi4 Native Energy Methods; Psi4 Native DFT Energy Methods; MRCC Interfaced Energy Methods; CFOUR Interfaced Energy Methods. psi4.energy(name[, molecule, return_wfn, restart_file])[source]; Function to compute the single-point electronic energy. Returns; float – Total electronic energy in Hartrees. SAPT & EFP return interaction energy. Returns; (float, Wavefunction) – energy and wavefunction when return_wfn specified. PSI variables. CURRENT ENERGY; CURRENT REFERENCE ENERGY; CURRENT CORRELATION ENERGY. Parameters. name (str) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. write_orbitals (str, boolean) – filename || \(\Rightarrow\) 'on' \(\Leftarrow\) || 'off'; (str) Save wfn containing current orbitals to the given file name after each SCF iteration; and retain after PSI4 finishes.; (boolean) Turns writing the orbitals after the converged SCF on/off.; Orbital file will be deleted unless PSI4 is called with -m flag. restart_file (str) – ['file.1, file.32] || ./file || etc.; Existing files to be renamed and copied for calculation restart, e.g. a serialized wfn or module-specific binary data. name; calls method. efp; effective fragment potential (EFP) [manual]. scf; Hartree–Fock (HF) or density functional theory (DFT) [manual]. hf; HF self consistent field (SCF) [manual]. hf3c; HF with dispersion, BSSE, and basis set corrections [manual]. pbeh3c; PBEh with dispersion, BSSE, and basis set corrections [manual]. dct; density cumulant (functional) theory [manual]. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/energy-1.html:1139,energy,energy,1139,psi4manual/1.4.0/energy-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/energy-1.html,2,['energy'],['energy']
Energy Efficiency,"    .    .    .    .  · ; 1.5;  · . PSI4. Psithon Functions: Invoking a Calculation; Single-Point Energy — energy(). Single-Point Energy — energy()¶. Psi4 Native Energy Methods; Psi4 Native DFT Energy Methods; MRCC Interfaced Energy Methods; CFOUR Interfaced Energy Methods. psi4.energy(name[, molecule, return_wfn, restart_file])[source]; Function to compute the single-point electronic energy. Returns; float – Total electronic energy in Hartrees. SAPT & EFP return interaction energy. Returns; (float, Wavefunction) – energy and wavefunction when return_wfn specified. PSI variables. CURRENT ENERGY; CURRENT REFERENCE ENERGY; CURRENT CORRELATION ENERGY. Parameters. name (str) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. write_orbitals (str, boolean) – filename || \(\Rightarrow\) 'on' \(\Leftarrow\) || 'off'; (str) Save wfn containing current orbitals to the given file name after each SCF iteration; and retain after PSI4 finishes.; (boolean) Turns writing the orbitals after the converged SCF on/off.; Orbital file will be deleted unless PSI4 is called with -m flag. restart_file (str) – ['file.1, file.32] || ./file || etc.; Existing files to be renamed and copied for calculation restart, e.g. a serialized wfn or module-specific binary data. name; calls method. efp; effective fragment potential (EFP) [manual]. scf; Hartree–Fock (HF) or density functional theory (DFT) [manual]. hf; HF self consistent field (SCF) [manual]. hf3c; HF with dispersion, BSSE, and basis set corrections [manual]. pbeh3c; PBEh with dispersion, BSSE, and basis set corrections [manual]. dct; density cumulant (functional) theory [manual]. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/energy-1.html:1139,energy,energy,1139,psi4manual/1.5.0/energy-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/energy-1.html,2,['energy'],['energy']
Energy Efficiency,"    .    .    .    .  · ; 1.6;  · . PSI4. Psithon Functions: Invoking a Calculation; Single-Point Energy — energy(). Single-Point Energy — energy()¶. Psi4 Native Energy Methods; Psi4 Native DFT Energy Methods; MRCC Interfaced Energy Methods; CFOUR Interfaced Energy Methods. psi4.energy(name[, molecule, return_wfn, restart_file])[source]; Function to compute the single-point electronic energy. Returns; float – Total electronic energy in Hartrees. SAPT & EFP return interaction energy. Returns; (float, Wavefunction) – energy and wavefunction when return_wfn specified. PSI variables. CURRENT ENERGY; CURRENT REFERENCE ENERGY; CURRENT CORRELATION ENERGY. Parameters. name (str) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. write_orbitals (str, boolean) – filename || \(\Rightarrow\) 'on' \(\Leftarrow\) || 'off'; (str) Save wfn containing current orbitals to the given file name after each SCF iteration; and retain after PSI4 finishes.; (boolean) Turns writing the orbitals after the converged SCF on/off.; Orbital file will be deleted unless PSI4 is called with -m flag. restart_file (str) – ['file.1, file.32] || ./file || etc.; Existing files to be renamed and copied for calculation restart, e.g. a serialized wfn or module-specific binary data. name; calls method. efp; effective fragment potential (EFP) [manual]. scf; Hartree–Fock (HF) or density functional theory (DFT) [manual]. hf; HF self consistent field (SCF) [manual]. hf3c; HF with dispersion, BSSE, and basis set corrections [manual]. pbeh3c; PBEh with dispersion, BSSE, and basis set corrections [manual]. dct; density cumulant (functional) theory [manual]. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/energy.html:1139,energy,energy,1139,psi4manual/1.6.x/energy.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/energy.html,1,['energy'],['energy']
Energy Efficiency,"    .    .  · ; 1.1;  · . PSI4. Customization: Adding Simple Extensions. Defining a Method Alias¶. Note; No recompile of the PSI4 program is necessary for changes made to; files in $PSIDATADIR aka psi4/psi4/share/psi4, including those described below. Caution; As of 1.0, the below, while essentially still correct, is so aged; as to be difficult to follow. Since quantum chemical methods in PSI4 are accessed through Python functions, and; most important quantities are available as PSI variables, it is straightforward; to create aliases to commonly run calculations or to define hybrid methods. The; psi4/psi4/driver/aliases.py file is intended for editing by the user for; this purpose.; As an example, the MP2.5 method; (which admittedly is already built in to PSI4); is the average of MP2 and MP3. The latter is; available through the arbitrary order MPn code and returns all lower energies; along with it in PSI variables. The following is basic code that will compute; and return the MP2.5 energy.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14def run_mp2_5(name, **kwargs):. energy('mp3', **kwargs); e_scf = psi4.get_variable('SCF TOTAL ENERGY'); ce_mp2 = psi4.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = psi4.get_variable('MP3 CORRELATION ENERGY'). ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25. print """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); print """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25). return e_mp25. Compare the above to the method that resides in psi4/psi4/driver/aliases.py.; The rationale for the changes is indicated in the comments below.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; 35; 36; 37; 38def run_mp2_5(name, **kwargs):; lowername = name.lower() # handy variable with name keyword in lowercase; kwargs = kwargs_lower(kwargs) # removes case sensitivity in keyword names. # Run detci calculation and collect conventional quantities; energy('mp3', **kw",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/quickaddalias-1.html:1062,energy,energy,1062,psi4manual/1.1.0/quickaddalias-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/quickaddalias-1.html,2,['energy'],['energy']
Energy Efficiency,"    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; CFOUR. CFOUR¶; Interface to CFOUR program written by Stanton and Gauss. Keyword descriptions taken from the CFOUR Website and extended by interface comments. Psi4 Control of CFOUR¶. TRANSLATE_PSI4¶. Do translate set Psi4 options to their cfour counterparts. Type: boolean; Default: true. CFOUR Internal¶. CFOUR_ABCDTYPE¶. Specifies the way the \(\langle ab||cd \rangle\) molecular orbital integrals are handled in post-MP2 calculations. STANDARD (= 0) uses directly the corresponding MO integrals and thus results in an algorithm which in particular for large-scale calculations results in excessive use of disk space (storage of all \(\langle ab||cd\rangle\) integrals. AOBASIS (=2) uses an AO-based algorithm to evaluate all terms involving the \(\langle ab||cd\rangle\) integrals and significantly reduces the amount of disk storage. The use of ABCDTYPE=AOBASIS is strongly recommended for all CC calculations up to CCSD(T) and has been implemented for energy, gradient, second-derivative, and excitation energy calculations. Type: string; Possible Values: STANDARD, AOBASIS; Default: STANDARD. CFOUR_ACTIVE_ORBI¶. Specifies the active orbitals used in a TCSCF calculation and has to be used in combination with the keyword CFOUR_CORE_ORBITALS The active orbitals are specified by either NIRREP or 2*NIRREP integers specifying the number of active orbitals of each symmetry type, where NIRREP is the number of irreducible representations in the computational point group. If there are no orbitals of a particular symmetry type a zero must be entered. For more information and an example see CFOUR_OCCUPATION . Type: array; Default: No Default. CFOUR_ANHARMONIC¶. Specifies treatment of anharmonic effects by calculating cubic and/or quartic force fields. VIBROT (=3) requests calculation of only those cubic constants of the form \(\phi_{nij}\), where n is a totally symmetric coordinate. These are sufficient to determine the vi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodir_options_c/module__cfour.html:1075,energy,energy,1075,psi4manual/master/autodir_options_c/module__cfour.html,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/module__cfour.html,2,['energy'],['energy']
Energy Efficiency,"    .  · ; 1.2.1;  · . PSI4. Theoretical Methods: SCF to FCI. Notes on Options¶. Note; The options referred to in the Theoretical Methods: SCF to FCI section below; and indexed in Keywords by Module are placed in set blocks as; described in Job Control Keywords, not as arguments to a Python function; (like energy()). Note; All PSI4 keyword names and values are insensitive to case, both; those that are placed in set blocks and as Python function arguments.; The few exceptions are documented for the database() function,; where case structure must match the database file. Note; Boolean options can be specified by yes, on, true, or 1; for affirmative and no, off, false, or 0 for negative,; all insensitive to case. Note; Certain convergence and tolerance keywords, of type double (real numbers),; may be specified using either a real number or an integer; and integer X is then; treated as the number of converged decimal digits required. For example, to request; as energy converged to \(10^{-6} E_h\), the user may set the e_convergence; keyword to 0.000001, 1.0e-6, or 6. Alternate Implementations¶; Depending on the reference (RHF, UHF, ROHF) and the integral treatment; (conventional CONV, density-fitted DF, and Cholesky-decomposed CD),; computational methods are sometimes implemented by multiple coders or even; multiple times. PSI4 transparently selects the most efficient; implementation, so one generally needn’t consult this table. However, to; understand the details of what combinations are accessible or what; alternate implementations are available, read on.; Below, “Y” means method available in module, “D” means module is default; for that method, and “” means method not available. HF, DFT, and MP2; default to density-fitted integrals, while all higher methods default to; conventional integrals. Therefore, for a closed-shell molecule:. runs MP2 with default DF with default implementation DFMP2; 1energy('mp2'). runs MP2 with CONV with default implementation OCC; 1; 2set m",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/notes_c-1.html:1034,energy,energy,1034,psi4manual/1.2.1/notes_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/notes_c-1.html,2,['energy'],['energy']
Energy Efficiency,"    .  · ; 1.3.2;  · . PSI4. Theoretical Methods: SCF to FCI. Notes on Options¶. Note; The options referred to in the Theoretical Methods: SCF to FCI section below; and indexed in Keywords by Module are placed in set blocks as; described in Job Control Keywords, not as arguments to a Python function; (like energy()). Note; All PSI4 keyword names and values are insensitive to case, both; those that are placed in set blocks and as Python function arguments.; The few exceptions are documented for the database() function,; where case structure must match the database file. Note; Boolean options can be specified by yes, on, true, or 1; for affirmative and no, off, false, or 0 for negative,; all insensitive to case. Note; Certain convergence and tolerance keywords, of type double (real numbers),; may be specified using either a real number or an integer; and integer X is then; treated as the number of converged decimal digits required. For example, to request; as energy converged to \(10^{-6} E_h\), the user may set the e_convergence; keyword to 0.000001, 1.0e-6, or 6. Alternate Implementations¶; Depending on the reference (RHF, UHF, ROHF) and the integral treatment; (conventional CONV, density-fitted DF, and Cholesky-decomposed CD),; computational methods are sometimes implemented by multiple coders or even; multiple times. PSI4 transparently selects the most efficient; implementation, so one generally needn’t consult this table. However, to; understand the details of what combinations are accessible or what; alternate implementations are available, read on.; Below, “Y” means method available in module, “D” means module is default; for that method, and “” means method not available. HF, DFT, and MP2; default to density-fitted integrals, while all higher methods default to; conventional integrals. Therefore, for a closed-shell molecule:. runs MP2 with default DF with default implementation DFMP2; 1energy('mp2'). runs MP2 with CONV with default implementation OCC; 1; 2set m",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/notes_c-1.html:1034,energy,energy,1034,psi4manual/1.3.2/notes_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/notes_c-1.html,2,['energy'],['energy']
Energy Efficiency,"    ; Psi4 [1.0.0 6a9a71b] » ; Theoretical Methods: SCF to FCI ». HF: Hartree–Fock Theory¶; Code author: Justin M. Turney, Robert M. Parrish, and Andrew C. Simmonett; Section author: Robert M. Parrish and Jerome F. Gonthier; Module: Keywords, PSI Variables, LIBSCF_SOLVER, LIBMINTS, LIBFOCK, LIBDIIS. Introduction¶; Self-Consistent-Field (SCF) theory forms the cornerstone of ab initio quantum; chemistry. Here SCF refers both to conventional Hartree–Fock (HF) molecular; orbital theory and also to generalized Kohn–Sham Density Functional Theory; (KS-DFT). Psi4 contains a wholly rewritten SCF code, including many of the; most popular spin specializations, several efficient numerical methods for; treating Fock Matrix construction, and a brand new KS-DFT code featuring many of; the most popular DFT functional technologies.; An illustrative example of using the SCF module is as follows:; molecule {; 0 3; O; O 1 1.21; }. set {; basis cc-pvdz; guess sad; reference uhf; scf_type direct; }. energy('scf'). This will run a UHF computation for triplet molecular oxygen (the ground state); using a Direct algorithm for the Electron Repulsion Integrals (ERI) and starting; from a Superposition of Atomic Densities (SAD) guess. DF integrals are; automatically used to converge the DF-SCF solution before the Direct algorithm is; activated. After printing all manner of titles, geometries, sizings, and; algorithm choices, the SCF finally reaches the iterations:; Total Energy Delta E RMS |[F,P]|. @UHF iter 0: -149.76816019169962 -1.49768e+02 1.36000e-01; @UHF iter 1: -149.59759112756984 1.70569e-01 2.42437e-02; @UHF iter 2: -149.62372414554761 -2.61330e-02 6.10239e-03 DIIS; @UHF iter 3: -149.62643112722810 -2.70698e-03 2.17299e-03 DIIS; @UHF iter 4: -149.62690062294968 -4.69496e-04 5.66895e-04 DIIS; @UHF iter 5: -149.62694151409750 -4.08911e-05 1.26359e-04 DIIS; @UHF iter 6: -149.62694337042228 -1.85632e-06 1.84114e-05 DIIS; @UHF iter 7: -149.62694340901407 -3.85918e-08 2.91692e-06 DIIS; @UHF ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/scf-1.html:1109,energy,energy,1109,psi4manual/1.0.0/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/scf-1.html,2,['energy'],['energy']
Energy Efficiency,"  .    .    .  · ; 1.8.2;  · . PSI4. Appendices; Test Suite and Sample Inputs; <no title>. Input File; Description. scf5; Test of all different algorithms and reference types for SCF, on singlet and triplet O2, using the cc-pVTZ basis set. cc13; UHF-CCSD/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. mints9; A test of the basis specification. Various basis sets are specified outright and in blocks, both orbital and auxiliary. Constructs libmints BasisSet objects through the constructor that calls qcdb.BasisSet infrastructure. Checks that the resulting bases are of the right size and checks that symmetry of the Molecule observes the basis assignment to atoms. fci-h2o-2; 6-31G H2O Test FCI Energy Point. fd-gradient; SCF STO-3G finite-difference tests. omp2-grad2; OMP2 cc-pVDZ gradient for the NO radical. dfep2-2; Compute three IP and 2 EA’s for the PH3 molecule. phi-ao; Test computing values of basis functions (puream and non-puream) at points. dfcasscf-sp; CASSCF/6-31G** energy point. mints6; Patch of a glycine with a methyl group, to make alanine, then DF-SCF energy calculation with the cc-pVDZ basis set. dfmp2-grad1; DF-MP2 cc-pVDZ gradients for the H2O molecule. sapt-dft2; SAPT(DFT) aug-cc-pVDZ computation for the water dimer interaction energy. dfomp2p5-1; DF-OMP2.5 cc-pVDZ energy for the H2O molecule. freq-masses; check nonphysical masses possible. cc17; Single point energies of multiple excited states with EOM-CCSD. fci-coverage; 6-31G H2O Test for coverage. cdoremp-energy1; Cholesky decomposed OO-REMP/cc-pVDZ energy for the H2O molecule. sapt2; SAPT0 aug-cc-pVDZ computation of the benzene-methane interaction energy, using the aug-pVDZ-JKFIT DF basis for SCF, the aug-cc-pVDZ-RI DF basis for SAPT0 induction and dispersion, and the aug-pVDZ-JKFIT DF basis for SAPT0 electrostatics and induction. This example uses frozen core as well as asyncronous I/O while forming the DF integrals and CPHF coefficients. zaptn-nh2; ZAPT(n)/6-31G NH2 Energy P",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html:1056,energy,energy,1056,psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,1,['energy'],['energy']
Energy Efficiency,"  .    .  · ; 1.2.1;  · . PSI4. Customization: Adding Simple Extensions. Defining a Method Alias¶. Note; No recompile of the PSI4 program is necessary for changes made to; files in $PSIDATADIR aka psi4/psi4/share/psi4, including those described below. Caution; As of 1.0, the below, while essentially still correct, is so aged; as to be difficult to follow. Since quantum chemical methods in PSI4 are accessed through Python functions, and; most important quantities are available as PSI variables, it is straightforward; to create aliases to commonly run calculations or to define hybrid methods. The; psi4/psi4/driver/aliases.py file is intended for editing by the user for; this purpose.; As an example, the MP2.5 method; (which admittedly is already built in to PSI4); is the average of MP2 and MP3. The latter is; available through the arbitrary order MPn code and returns all lower energies; along with it in PSI variables. The following is basic code that will compute; and return the MP2.5 energy.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14def run_mp2_5(name, **kwargs):. energy('mp3', **kwargs); e_scf = psi4.get_variable('SCF TOTAL ENERGY'); ce_mp2 = psi4.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = psi4.get_variable('MP3 CORRELATION ENERGY'). ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25. print """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); print """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25). return e_mp25. Compare the above to the method that resides in psi4/psi4/driver/aliases.py.; The rationale for the changes is indicated in the comments below.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; 35; 36; 37; 38def run_mp2_5(name, **kwargs):; lowername = name.lower() # handy variable with name keyword in lowercase; kwargs = kwargs_lower(kwargs) # removes case sensitivity in keyword names. # Run detci calculation and collect conventional quantities; energy('mp3', **kw",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/quickaddalias-1.html:1064,energy,energy,1064,psi4manual/1.2.1/quickaddalias-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/quickaddalias-1.html,2,['energy'],['energy']
Energy Efficiency,"  .    .  · ; 1.3.2;  · . PSI4. Customization: Adding Simple Extensions. Defining a Method Alias¶. Note; No recompile of the PSI4 program is necessary for changes made to; files in $PSIDATADIR aka psi4/psi4/share/psi4, including those described below. Caution; As of 1.0, the below, while essentially still correct, is so aged; as to be difficult to follow. Since quantum chemical methods in PSI4 are accessed through Python functions, and; most important quantities are available as PSI variables, it is straightforward; to create aliases to commonly run calculations or to define hybrid methods. The; psi4/psi4/driver/aliases.py file is intended for editing by the user for; this purpose.; As an example, the MP2.5 method; (which admittedly is already built in to PSI4); is the average of MP2 and MP3. The latter is; available through the arbitrary order MPn code and returns all lower energies; along with it in PSI variables. The following is basic code that will compute; and return the MP2.5 energy.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14def run_mp2_5(name, **kwargs):. energy('mp3', **kwargs); e_scf = psi4.get_variable('SCF TOTAL ENERGY'); ce_mp2 = psi4.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = psi4.get_variable('MP3 CORRELATION ENERGY'). ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25. print """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); print """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25). return e_mp25. Compare the above to the method that resides in psi4/psi4/driver/aliases.py.; The rationale for the changes is indicated in the comments below.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; 35; 36; 37; 38def run_mp2_5(name, **kwargs):; lowername = name.lower() # handy variable with name keyword in lowercase; kwargs = kwargs_lower(kwargs) # removes case sensitivity in keyword names. # Run detci calculation and collect conventional quantities; energy('mp3', **kw",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/quickaddalias-1.html:1064,energy,energy,1064,psi4manual/1.3.2/quickaddalias-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/quickaddalias-1.html,2,['energy'],['energy']
Energy Efficiency,"  · . PSI4. PSI4 API: Linking C++ and Python; CCWavefunction. CCWavefunction¶. class psi4.core.CCWavefunction¶; Bases: Wavefunction; Specialized Wavefunction used by the ccenergy, cceom, ccgradient, etc. modules.; Methods Summary. get_amplitudes(self); Get dict of converged T amplitudes. total_index(self, i, h); Map an index (i) within irrep (h) to its energy-sorted index among all roots. Methods Documentation. get_amplitudes(self: psi4.core.CCWavefunction) → dict[str, psi4.core.Matrix]¶; Get dict of converged T amplitudes. Returns:. amps (dict (spacestr, SharedMatrix)) – spacestr is a description of the amplitude set using the following conventions. I,J,K -> alpha occupied; i,j,k -> beta occupied; A,B,C -> alpha virtual; a,b,c -> beta virtual. The following entries are stored in the amps, depending on the reference type; RHF (tIA, tIjAb); UHF (tIA, tia, tIjAb, tIJAB, tijab); ROHF (tIA, tia, tIjAb, tIJAB, tijab). Examples; RHF T1 diagnostic = sqrt(sum_ia (T_ia * T_ia)/nelec); >>> mol = “””; … 0 1; … Ne 0.0 0.0 0.0; … symmetry c1”””; >>> e, wfn = psi4.energy(“CCSD/cc-pvdz”, return_wfn=True); >>> t1 = wfn.get_amplitudes()[‘tia’].to_array(); >>> t1_diagnostic = np.sqrt(np.dot(t1.ravel(),t1.ravel())/ (2 * wfn.nalpha()); >>> t1_diagnostic == psi4.variable(“CC T1 DIAGNOSTIC”); True. Warning; Symmetry free calculations only (nirreps > 1 will cause error). Warning; No checks that the amplitudes will fit in core. Do not use for proteins. total_index(self: psi4.core.CCWavefunction, i: int, h: int) → int¶; Map an index (i) within irrep (h) to its energy-sorted index among all roots. table of contents. CCWavefunction; CCWavefunction; CCWavefunction.get_amplitudes(); CCWavefunction.total_index(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. PSI4 API: Linking C++ and Python; CCWavefunction. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/api/psi4.core.CCWavefunction.html:1151,energy,energy,1151,psi4manual/master/api/psi4.core.CCWavefunction.html,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.CCWavefunction.html,2,['energy'],"['energy', 'energy-sorted']"
Energy Efficiency,"  · ; 1.6;  · . PSI4. Appendices; Test Suite and Sample Inputs; CFOUR. CFOUR¶. Input File; Description. cfour/sp-rohf-mp4-sc; single-point MP4/qz2p on NH2. cfour/kw-6; Basis set spherical/Cartesian with cfour_basis and puream. cfour/sp-rohf-ccsd-ao; single-point CCSD/qz2p on NH2 with aobasis. cfour/sp-rhf-ccsd_t_-ecc; single-point CCSD(T)/qz2p on water with ecc module. cfour/sp-uhf-ccsd; single-point CCSD/qz2p on NH2. cfour/sp-rhf-ccsd; single point CCSD/qz2p on water. cfour/scf4; RHF cc-pVDZ energy for water, automatically scanning the symmetric stretch and bending coordinates using Python’s built-in loop mechanisms. The geometry is apecified using a Z-matrix with variables that are updated during the potential energy surface scan, and then the same procedure is performed using polar coordinates, converted to Cartesian coordinates. cfour/kw-4; Basis set spherical/Cartesian with basis and puream. cfour/mp2-1; All-electron MP2 6-31G** geometry optimization of water. cfour/psi-rhf-mp3; MP3 energy components. Checks that computed identically between cfour and psi4. cfour/sp-rohf-ccsd_t_-fc; single-point CCSD(T)/qz2p on NH2 with ecc, aobasis, frozen-core. cfour/sp-rhf-mp2; single-point MP2/qz2p on water. cfour/pywrap-cbs1; Various basis set extrapolation tests only in Cfour instead of Psi4. cfour/sp-rohf-mp2-sc; single-point MP2/qz2p on NH2. cfour/kw-3; Basis set spherical/Cartesian with cfour_basis and cfour_spherical. cfour/opt-rhf-ccsd_t_-ecc; optimization CCSD(T)/dzp on water with ecc, aobasis. cfour/sp-rhf-ccsd_t_-ao; single-point CCSD(T)/qz2p on water with aobasis. cfour/dfmp2-1; MP2/cc-PVDZ computation of formic acid dimer binding energy using automatic counterpoise correction. Monomers are specified using Cartesian coordinates. cfour/sp-rhf-ccsd_t_; single-point CCSD(T)/qz2p on water. cfour/sp-rohf-ccsd_t_-ao; single-point CCSD(T)/qz2p on NH2 with aobasis. cfour/sp-rhf-cc3; single-point CC3/qz2p on water. cfour/sp-rhf-ccsd_t_-ao-ecc; single-point CCSD(T)/qc2p on",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_cfour.html:1059,energy,energy,1059,psi4manual/1.6.x/autodoc_testsuite_cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_cfour.html,1,['energy'],['energy']
Energy Efficiency,   CP-CORRECTED 2-BODY CONTRIBUTION TO ENERGY;   1; when cp in bsse_type & max_nbody>=2; 2-body total data less (2-1)-body total data for partial IE; inputs are total energies w/ cp treatment.   CP-CORRECTED {nb}-BODY CONTRIBUTION TO ENERGY;   1; when cp in bsse_type; {max_nbody}-body total data less ({max_nbody}-1)-body data for partial IE; inputs are total energies w/ cp treat.   NOCP-CORRECTED TOTAL ENERGY THROUGH 1-BODY;   1; when nocp in bsse_type; MBE sum of subsystems of 1-body. summed are total energies without cp treatment.   NOCP-CORRECTED TOTAL ENERGY THROUGH 2-BODY;   1; when nocp in bsse_type & max_nbody>=2; MBE sum of subsystems of 2-body or fewer (cumulative); summed are total energies without cp treatment.   NOCP-CORRECTED TOTAL ENERGY THROUGH {nb}-BODY;   1; when nocp in bsse_type; MBE sum of subsystems of {max_nbody}-body or fewer (cumulative); summed are total energies w/o cp treatment.   NOCP-CORRECTED TOTAL ENERGY;   1; when nocp in bsse_type; best available total energy without cp treatment: NOCP-CORRECTED TOTAL ENERGY THROUGH {max_nbody}-BODY.   NOCP-CORRECTED INTERACTION ENERGY THROUGH 2-BODY;   1; when nocp in bsse_type & max_nbody>=2; 2-body total data less 1-body total data for cumulative IE; inputs are total energies w/o cp treatment.   NOCP-CORRECTED INTERACTION ENERGY THROUGH {nb}-BODY;   1; when nocp in bsse_type; {max_nbody}-body total data less 1-body total data for cumulative IE; inputs are total energies w/o cp treatment.   NOCP-CORRECTED INTERACTION ENERGY;   1; when nocp in bsse_type; best available interaction energy without cp treatment: NOCP-CORRECTED INTERACTION ENERGY THROUGH {max_nbody}-BODY.   NOCP-CORRECTED 2-BODY CONTRIBUTION TO ENERGY;   1; when nocp in bsse_type & max_nbody>=2; 2-body total data less (2-1)-body total data for partial IE; inputs are total energies w/o cp treatment.   NOCP-CORRECTED {nb}-BODY CONTRIBUTION TO ENERGY;   1; when nocp in bsse_type; {max_nbody}-body total data less ({max_nbody}-1)-body data f,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/nbody.html:12794,energy,energy,12794,psi4manual/1.6.x/nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/nbody.html,5,['energy'],['energy']
Energy Efficiency," – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element of a tuple. bsse_type (str or list) – 'cp' || ['nocp', 'vmfc'] || \(\Rightarrow\) None \(\Leftarrow\) || etc.; Type of BSSE correction to compute: CP for counterpoise correction, NoCP; for plain supramolecular interaction energy, or VMFC for Valiron-Mayer; Function Counterpoise correction. If a list is provided, the first string in; the list determines which interaction or total energies/gradients/Hessians are; returned by this function. By default, this function is not called. max_nbody (int) – 3 || etc.; Maximum n-body to compute, cannot exceed the number of fragments in the molecule. ptype (str) – 'energy' || 'gradient' || 'hessian'; Type of the procedure passed in. return_total_data (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); If True returns the total data (energy/gradient/Hessian) of the system,; otherwise returns interaction data. Default is 'off' for energies,; 'on' for gradients and Hessians. Note that the calculation of total; counterpoise corrected energies implies the calculation of the energies of; monomers in the monomer basis, hence specifying return_total_data = True; may carry out more computations than return_total_data = False. levels (dict) – {1: 'ccsd(t)', 2: 'mp2', 'supersystem': 'scf'} || {1: 2, 2: 'ccsd(t)', 3: 'mp2'} || etc; Dictionary of different levels of theory for different levels of expansion; Note that method_string is not used in this case. supersystem computes; all higher order n-body effects up to the number of fragments. embedding_charges (dict) – {1: [-0.834, 0.417, 0.417], ..}; Dictionary of atom-centered point charges. keys: 1-based index of fragment, values: list of charges for each fragment. charge_method (str) – scf/6-31g || b3lyp/6-31g* || etc; Method to compute point charges for monom",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/nbody-1.html:2047,energy,energy,2047,psi4manual/1.4.0/nbody-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/nbody-1.html,4,['energy'],['energy']
Energy Efficiency," — Do perform spin-opposite-scaled OMP3 (SOS-OMP3)? In all computation, SOS-OMP3 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SOS-OMP3, one needs to set ‘DO_SOS’ to true. Type: boolean; Default: false. DO_THIRD_ORDER (SAPT); SAPT (Expert) — Do compute third-order corrections?. Type: boolean; Default: false. DO_TRIPLETS (CPHF); CPHF — Do triplet states? Default true. Type: boolean; Default: true. DOCC (GLOBALS); GLOBALS — An array containing the number of doubly-occupied orbitals per irrep (in Cotton order). Type: array; Default: No Default. DOCC (MCSCF); MCSCF — The number of doubly occupied orbitals, per irrep. Type: array; Default: No Default. DOMAIN_PRINT (CIS); CIS — Do print the domains?. Type: boolean; Default: false. DOMAIN_PRINT_EXIT (LMP2); LMP2 — Do exit after printing the domains?. Type: boolean; Default: false. DOMAINS (CIS); CIS —. Type: array; Default: No Default. E3_SCALE (OMP3); OMP3 — Scaling value for 3rd order energy correction (S. Grimme, Vol. 24, pp. 1529, J. Comput. Chem.). Type: double; Default: 0.25. E_CONVERGENCE (CCEOM); CCEOM — Convergence criterion for excitation energy (change) in the Davidson algorithm for CC-EOM. Type: conv double; Default: 1e-8. E_CONVERGENCE (DETCI); DETCI — Convergence criterion for energy. Type: conv double; Default: 1e-6. E_CONVERGENCE (LMP2); LMP2 — Convergence criterion for energy (change). Type: conv double; Default: 1e-7. E_CONVERGENCE (MCSCF); MCSCF — Convergence criterion for energy. Type: conv double; Default: 1e-8. E_CONVERGENCE (MRCC); MRCC — This becomes tol (option #16) in fort.56. Type: conv double; Default: 1e-8. E_CONVERGENCE (OMP2); OMP2 — Convergence criterion for energy. Type: conv double; Default: 1e-8. E_CONVERGENCE (OMP3); OMP3 — Convergence criterion for energy. Type: conv double; Default: 1e-8. E_CONVERGENCE (PSIMRCC); PSIMRCC — Convergence criterion for energy. Type: conv double; Default: 1e-9. E_CONVERGENCE (SAPT); SAP",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html:35464,energy,energy,35464,psi4manual/4.0b3/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html,2,['energy'],['energy']
Energy Efficiency," — Removed in 1.4. Will raise an error in 1.5. Type: double; Default: 1.0. MP2_TYPE (GLOBALS)¶GLOBALS — Algorithm to use for MP2 computation. See Cross-module Redundancies for details. Type: string; Possible Values: DF, CONV, CD; Default: DF. MP_TYPE (GLOBALS)¶GLOBALS — Algorithm to use for MPn ( \(n>2\) ) computation (e.g., MP3 or MP2.5 or MP4(SDQ)). See Cross-module Redundancies for details. Since v1.4, default for non-orbital-optimized MP2.5 and MP3 is DF. Type: string; Possible Values: DF, CONV, CD; Default: CONV. MPN (DETCI)¶DETCI — Do compute the MPn series out to kth order where k is determined by MAX_NUM_VECS ? For open-shell systems (REFERENCE is ROHF, WFN is ZAPTN), DETCI will compute the ZAPTn series. GUESS_VECTOR must be set to UNIT, HD_OTF must be set to TRUE, and HD_AVG must be set to orb_ener; these should happen by default for MPN = TRUE. Type: boolean; Default: false. MPN_ORDER_SAVE (DETCI)¶DETCI (Expert) — If 0, save the MPn energy; if 1, save the MP(2n-1) energy (if available from MPN_WIGNER = true); if 2, save the MP(2n-2) energy (if available from MPN_WIGNER = true). Type: integer; Default: 0. MPN_SCHMIDT (DETCI)¶DETCI (Expert) — Do employ an orthonormal vector space rather than storing the kth order wavefunction?. Type: boolean; Default: false. MPN_WIGNER (DETCI)¶DETCI (Expert) — Do use Wigner formulas in the \(E_{text{mp}n}\) series?. Type: boolean; Default: true. MRCC_LEVEL (MRCC)¶MRCC — Maximum excitation level. This is used ONLY if it is explicitly set by the user. Single-reference case: all excitations up to this level are included, e.g., 2 for CCSD, 3 for CCSDT, 4 for CCSDTQ, etc. This becomes ex.lev (option #1) in fort.56. Type: integer; Default: 2. MRCC_METHOD (MRCC)¶MRCC (Expert) — If more than one root is requested and calc=1, LR-CC (EOM-CC) calculation is performed automatically for the excited states. This overrides all automatic determination of method and will only work with energy(). This becomes CC/CI (option #5) in fort.56. See ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:171462,energy,energy,171462,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,27,['energy'],['energy']
Energy Efficiency," — Specifies the threshold used in converging CC-LR/EOM-CC calculations. The iterative diagonalization is continued until the RMS residual falls below \(10^{-N}\) with \(N\) as the value specified with this keyword. Type: integer; Default: 5. CFOUR_ESTATE_MAXCYC (CFOUR); CFOUR — The maximum number of expansion vectors used in the solution of EOMCC equations (Default: 20, hard-coded to 4 in triples calculations). Type: integer; Default: 20. CFOUR_ESTATE_PROP (CFOUR); CFOUR — This keyword applies only to EOM-CC calculations and specifies whether any excited or ionized state one-electron properties are to be calculated. Proper use of this keyword requires a relatively advanced knowledge of quantum chemistry and the available options are discussed here. The options are: OFF (=0) [no properties or transition moments are calculated]; EXPECTATION (=1) [transition moments and dipole strengths are calculated along with selected one-electron properties which are evaluated as expectation values]; UNRELAXED (=2) [selected one-electron properties are calculated in an approximation that neglects relaxation of molecular orbitals]; RESPONSE (=3) [selected one-electron properties are calculated as analytic first derivatives of the energy]. Except for EOMCC calculations on two-electron systems (which are exact), properties obtained by the three approaches will not be equivalent. The default value for this keyword is slightly complicated. For TDA calculations, the default is EXPECTATION since the evaluation of transition moments involves only a negligible amount of additional computation relative to the evaluation of the excitation energies. For EOMCC, the default is OFF since evaluation of any transition moments or properties requires approximately twice the computational time. Transition moments and dipole strengths are evaluated by default for all values of ESTATE_PROP other than OFF. Type: string; Possible Values: OFF, EXPECTATION, UNRELAXED, RESPONSE; Default: No Default. CFOUR_ES",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html:36072,energy,energy,36072,psi4manual/1.2.1/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html,6,['energy'],['energy']
Energy Efficiency," —; threaded (pthreads);  ;  . ACPF/AQCC; RHF; CONV; —; —; threaded [3];  ; E. CISD; RHF/ROHF; CONV; —; —; partially threaded;  ; E. QCISD; RHF; CONV; —; —; threaded [3];  ; E. QCISD(T); RHF; CONV; —; —; threaded [3];  ; E. CI(n); RHF/ROHF; CONV; —; —; partially threaded;  ;  . FCI; RHF/ROHF; CONV; —; —; partially threaded;  ;  . Mk-MRPT2; RHF/ROHF/TCSCF; CONV; —; —; threaded [3];  ;  . Mk-MRCCSD; RHF/ROHF/TCSCF; CONV; —; —; threaded [3];  ;  . Mk-MRCCSD(T); RHF/ROHF/TCSCF; CONV; —; —; threaded [3];  ;  . RAS-CI; RHF/ROHF; CONV; —; —; partially threaded;  ;  . CASSCF, RASSCF; RHF/ROHF; CONV/DF; —; —; partially threaded;  ;  . SAPT; RHF; CONV; —; —; threaded;  ;  . ADC(2); RHF; CONV; —; —; threaded [3];  ;  . EOM-CC2; RHF; CONV; —; —; threaded [3];  ;  . EOM-CCSD; RHF/UHF/ROHF; CONV; RHF/UHF/ROHF; CONV; threaded [3];  ;  . EOM-CC3; RHF/UHF/ROHF; CONV; —; —; threaded [3];  ;  . DMRG-CI; Y; CONV; —; —;  ;  ;  . DMRG-SCF; Y; CONV; —; —;  ;  ;  . Geometry optimization can be performed using either analytic gradients; or energy points. Likewise, vibrational frequencies can be; computed by analytic second derivatives, by finite; differences of analytic gradients, or by finite differences of energies.; Psi4 can also compute an extensive list of one-electron properties. Technical Support¶; The Psi4 package is distributed for free and without any guarantee of; reliability, accuracy, or suitability for any particular purpose. No; obligation to provide technical support is expressed or implied. As time; allows, the developers will attempt to answer inquiries on the forum or GitHub. For bug reports,; specific and detailed information, with example inputs, would be; appreciated.; Where-to-post summary:[6]. How do I? – ask the forum; I got this error, why? – ask the forum; I got this error and I’m sure it’s a bug – file a GitHub issue; Can I open a discussion on this bit of code? – file a GitHub issue; I have an idea/request and a plan – file a GitHub issue; I have an idea/request",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/introduction-1.html:19467,energy,energy,19467,psi4manual/1.0.0/introduction-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/introduction-1.html,2,['energy'],['energy']
Energy Efficiency," ‘’, 32, True):; -mv /tmp/temp /scratch/parrish/psi.12345.32. get_memory()[source]¶; Function to return the total memory allocation. get_num_threads()[source]¶; Function to return the number of threads to parallelize across. set_memory(bytes)[source]¶; Function to reset the total memory allocation. set_num_threads(nthread)[source]¶; Function to reset the number of threads to parallelize across. success(label)[source]¶; Function to print a ‘label...PASSED’ line to screen.; Used by util.compare_values() family when functions pass. aliases¶; Module with functions that call upon those in modules; proc, driver, and wrappers. Place in this file quickly defined procedures such as. aliases for complex methods; simple modifications to existing methods. run_mp2_5(name, **kwargs)[source]¶; Function that computes MP2.5 energy from results of a DETCI; MP3 calculation. Psi variables:. MP2.5 TOTAL ENERGY; MP2.5 CORRELATION ENERGY. >>> energy('mp2.5'). run_plugin_omega(name, **kwargs)[source]¶; Function encoding sequence of PSI module and plugin calls, as well; as typical options, to access Rob Parrish’s omega plugin.; >>> energy('plugin_omega'). sherrillgroup_gold_standard(name='mp2', **kwargs)[source]¶; Function to call the quantum chemical method known as ‘Gold Standard’; in the Sherrill group. Uses complete_basis_set() to evaluateo; the following expression. Two-point extrapolation of the correlation energy; performed according to corl_xtpl_helgaker_2(). >>> energy('sherrillgroup_gold_standard'). Table Of Contents. Python Driver; input; pubchem; psiexceptions; frac; molutil; proc; procutil; driver; physconst; wrappers; qmmm; functional; text; util; aliases. Previous topic; PRINT; Next topic; PsiMod: Linking C++ and Python; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » . © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodoc_driver-1.html:23197,energy,energy,23197,psi4manual/4.0b2/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodoc_driver-1.html,6,['energy'],['energy']
Energy Efficiency," ”.in” or ”.dat” suffix),; plus a ”.out” suffix. Sample Input Files¶; Below, we will provide a few simple input files as examples. A large; number of sample input files, covering everything from single-point energies; using density-functional theory to response properties from coupled-cluster; theory, can be found in the psi4/samples directory. Running a Basic Hartree–Fock Calculation¶; In our first example, we will consider a Hartree–Fock SCF computation; for the water molecule using a cc-pVDZ basis set. We will specify the; geometry of our water molecule using a standard Z-matrix.; # Any line starting with the # character is a comment line; #! Sample HF/cc-pVDZ H2O computation. memory 250 mb. molecule h2o {; O ; H 1 0.96; H 1 0.96 2 104.5; }. set basis cc-pVDZ; energy('scf'). Note; The memory and basis set specifications are placed before the; energy function is called. Any user options need to; be set before the procedure they are meant to affect. For your convenience, the above example can be found in; tu1-h2o-energy.; You can run it if you wish.; Once Psi4 is in your path (see the; User Configuration; section of the installation instructions), you can run this computation by typing; >>> psi4 input.dat output.dat. If everything goes well, the computation should complete and should report; a final restricted Hartree–Fock energy in a section like this:; Energy converged. @RHF Final Energy: -76.02663273410671. By default, the energy should be converged to about , so agreement; is only expected for about the first 6 digits after the decimal. If the; computation does not complete, there is probably a problem with the; compilation or installation of the program (see the installation; instructions in Sec. Compiling and Installing from Source).; This very simple input is sufficient to run the requested information.; Notice that we didn’t tell the program some otherwise useful information; like the charge on the molecule (0, it’s neutral), the spin multiplicity; (1 for a ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/tutorial-1.html:1874,energy,energy,1874,psi4manual/1.0.0/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/tutorial-1.html,2,['energy'],['energy']
Energy Efficiency," → List[psi4.core.Matrix]; Solves the CPHF equations for a given set of x vectors. damping_update(self: psi4.core.HF, arg0: float) → None; docstring. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. del_array_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) Matrix QC variable. del_scalar_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) double QC variable. del_variable(key)¶. density_fitted(self: psi4.core.Wavefunction) → bool¶; Returns whether this wavefunction was obtained using density fitting or not. diis(self: psi4.core.HF) → bool; docstring. diis_enabled_; docstring. diis_manager(self: psi4.core.HF) → psi4.core.DIISManager; docstring. diis_start_; docstring. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. efzc(self: psi4.core.Wavefunction) → float¶; Returns the frozen-core energy. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunction’s energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Beta Eigenvalues subset. esp_at_nuclei(self: psi4.core.Wavefunction) → psi4.core.Vector¶; returns electrostatic potentials at nuclei. finalize(self: psi4.core.HF) → None; Cleans up the the Wavefunction’s temporary data. finalize_energy(); Performs stability analysis and calls back SCF with new guess; if needed, Returns the SCF energy. This function should be called; once orbitals are ready for energy/property computations, usually; after iterations() is",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.hf.html:15267,energy,energy,15267,psi4manual/1.3.2/api/psi4.core.hf.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.hf.html,1,['energy'],['energy']
Energy Efficiency," → None; Sets all fragments in the molecule to be active. add_atom(self: psi4.core.Molecule, Z: float, x: float, y: float, z: float, symbol: str, mass: float, charge: float, label: str, A: int) → None; Adds to self Molecule an atom with atomic number Z, Cartesian coordinates in Bohr (x, y, z), atomic symbol, mass, and charge, extended atomic label, and mass number A. atom_at_position(*args, **kwargs); Overloaded function. atom_at_position(self: psi4.core.Molecule, coord: float, tol: float) -> int. Tests to see if an atom is at the position coord with a given tolerance tol. atom_at_position(self: psi4.core.Molecule, coord: List[float[3]], tol: float) -> int. Tests to see if an atom is at the position coord with a given tolerance tol. basis_on_atom(self: psi4.core.Molecule, arg0: int) → str; Gets the label of the orbital basis set on a given atom arg0. center_of_mass(self: psi4.core.Molecule) → psi4.core.Vector3; Computes center of mass of molecule (does not translate molecule). charge(self: psi4.core.Molecule, atom: int) → float; Gets charge of atom (0-indexed without dummies). clone(self: psi4.core.Molecule) → psi4.core.Molecule; Returns a new Molecule identical to arg1. com_fixed(self: psi4.core.Molecule) → bool; Gets whether or not center of mass is fixed. comment(self: psi4.core.Molecule) → str; Gets molecule comment. connectivity(self: psi4.core.Molecule) → List[Tuple[int, int, float]]; Gets molecule connectivity. create_psi4_string_from_molecule(self: psi4.core.Molecule) → str; Gets a string re-expressing in input format the current state of the molecule.Contains Cartesian geometry info, fragmentation, charges and multiplicities, and any frame restriction. deactivate_all_fragments(self: psi4.core.Molecule) → None; Sets all fragments in the molecule to be inactive. distance_matrix(self: psi4.core.Molecule) → psi4.core.Matrix; Returns Matrix of interatom distances. extract_subsets(*args, **kwargs); Overloaded function. extract_subsets(self: psi4.core.Molecule, arg",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.molecule.html:42227,charge,charge,42227,psi4manual/1.3.2/api/psi4.core.molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.molecule.html,1,['charge'],['charge']
Energy Efficiency," → None¶; Build the overlap integrals S. partition(self: psi4.core.FISAPT) → None¶; Partition the nuclei and electrons. print_header(self: psi4.core.FISAPT) → None¶; Print header, bases, sizes, etc. print_trailer(self: psi4.core.FISAPT) → None¶; Print SAPT results. raw_plot(self: psi4.core.FISAPT, arg0: str) → None¶; Plot some analysis files. scalars(self: psi4.core.FISAPT) → Dict[str, float]¶; Return the interally computed scalars (not copied). scf(self: psi4.core.FISAPT) → None¶; Solve the relaxed SCF equations for A0 and B0. unify(self: psi4.core.FISAPT) → None¶; Produce unified matrices for A’, B’, and C’. vectors(self: psi4.core.FISAPT) → Dict[str, psi4.core.Vector]¶; Return the interally computed vectors (not copied). coulomb(self: psi4.core.FISAPT) → None; Build the J/K potentials for C, D, and E. dHF(self: psi4.core.FISAPT) → None; SAPT0 delta HF. disp(self: psi4.core.FISAPT, arg0: Dict[str, psi4.core.Matrix], arg1: Dict[str, psi4.core.Vector], arg2: bool) → None; Computes the MP2-based DispE20 and Exch-DispE20 energy. elst(self: psi4.core.FISAPT) → None; SAPT0 electrostatics. exch(self: psi4.core.FISAPT) → None; SAPT0 exchange. fdisp(self: psi4.core.FISAPT) → None; F-SAPT0 dispersion. felst(self: psi4.core.FISAPT) → None; F-SAPT0 electrostatics. fexch(self: psi4.core.FISAPT) → None; F-SAPT0 exchange. find(self: psi4.core.FISAPT) → None; F-SAPT0 induction. flocalize(self: psi4.core.FISAPT) → None; F-SAPT0 localize. freeze_core(self: psi4.core.FISAPT) → None; Freeze the core orbitals. ind(self: psi4.core.FISAPT) → None; SAPT0 induction. kinetic(self: psi4.core.FISAPT) → None; Build the kinetic integrals T. localize(self: psi4.core.FISAPT) → None; Localize the active occupied orbitals via IBO2. matrices(self: psi4.core.FISAPT) → Dict[str, psi4.core.Matrix]; Return the interally computed matrices (not copied). molecule(self: psi4.core.FISAPT) → psi4.core.Molecule; Returns the FISAPT’s molecule. nuclear(self: psi4.core.FISAPT) → None; Build the nuclear potential",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.fisapt.html:3917,energy,energy,3917,psi4manual/1.3.2/api/psi4.core.fisapt.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.fisapt.html,1,['energy'],['energy']
Energy Efficiency," → None¶; F-SAPT0 exchange. find(self: psi4.core.FISAPT) → None¶; F-SAPT0 induction. flocalize(self: psi4.core.FISAPT) → None¶; F-SAPT0 localize. freeze_core(self: psi4.core.FISAPT) → None¶; Freeze the core orbitals. ind(self: psi4.core.FISAPT) → None¶; SAPT0 induction. kinetic(self: psi4.core.FISAPT) → None¶; Build the kinetic integrals T. localize(self: psi4.core.FISAPT) → None¶; Localize the active occupied orbitals via IBO2. matrices(self: psi4.core.FISAPT) → Dict[str, psi4.core.Matrix]¶; Return the interally computed matrices (not copied). molecule(self: psi4.core.FISAPT) → psi4.core.Molecule¶; Returns the FISAPT’s molecule. nuclear(self: psi4.core.FISAPT) → None¶; Build the nuclear potentials V and interaction energies. overlap(self: psi4.core.FISAPT) → None¶; Build the overlap integrals S. partition(self: psi4.core.FISAPT) → None¶; Partition the nuclei and electrons. plot()¶; Filesystem wrapper for FISAPT::plot. print_header(self: psi4.core.FISAPT) → None¶; Print header, bases, sizes, etc. print_trailer(self: psi4.core.FISAPT) → None¶; Print SAPT results. raw_plot(self: psi4.core.FISAPT, arg0: str) → None¶; Plot some analysis files. scalars(self: psi4.core.FISAPT) → Dict[str, float]¶; Return the interally computed scalars (not copied). scf(self: psi4.core.FISAPT) → None¶; Solve the relaxed SCF equations for A0 and B0. sinf_disp(self: psi4.core.FISAPT, arg0: Dict[str, psi4.core.Matrix], arg1: Dict[str, psi4.core.Vector], arg2: bool) → None¶; Computes the MP2-based DispE20 and Exch-DispE20 energy without S^2. unify(self: psi4.core.FISAPT) → None¶; Produce unified matrices for A’, B’, and C’. vectors(self: psi4.core.FISAPT) → Dict[str, psi4.core.Vector]¶; Return the interally computed vectors (not copied). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. PSI4 API: Linking C++ and Python; FISAPT. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.FISAPT.html:4096,energy,energy,4096,psi4manual/1.6.x/api/psi4.core.FISAPT.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.FISAPT.html,1,['energy'],['energy']
Energy Efficiency," → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.Wavefunction, basis: psi4.core.BasisSet) → psi4.core.Wavefunction¶; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet *basis. compute(self: psi4.core.DFEP2Wavefunction, arg0: List[List[int]]) → List[List[Tuple[float, float]]]; Computes the density-fitted EP2 energy for the input orbitals. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Beta Eigenvalues subset. esp_at_nuclei(self: psi4.core.Wavefunction) → psi4.core.Vector¶; returns electrostatic potentials at nuclei. force_doccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use only. Sets the number of doubly occupied oribtals per irrep. Note that this results in inconsistent Wavefunction objects for SCF, so caution is advised. force_soccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use only",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/api/psi4.core.dfep2wavefunction.html:3700,energy,energy,3700,psi4manual/1.2.1/api/psi4.core.dfep2wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/api/psi4.core.dfep2wavefunction.html,1,['energy'],['energy']
Energy Efficiency," → psi::Wavefunction¶; Runs the DF-MP2 code. psi4.core.dfocc(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the density-fitted orbital optimized CC codes. psi4.core.dmrg(arg0: psi::Wavefunction) → float¶; Runs the DMRG code. psi4.core.doublet(A: psi4.core.Matrix, B: psi4.core.Matrix, transA: bool=False, transB: bool=False) → psi4.core.Matrix¶; Returns the multiplication of two matrices A and B, with options to transpose each beforehand. psi4.core.fcidump_tei_helper(nirrep: int, restricted: bool, DPD_info: Dict[str, int], ints_tolerance: float, fname: str='INTDUMP') → None¶; Write integrals to file in FCIDUMP format. psi4.core.finalize() → None¶. psi4.core.flush_outfile() → None¶; Flushes the output file. psi4.core.fnocc(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the fno-ccsd(t)/qcisd(t)/mp4/cepa energy code. psi4.core.get_active_molecule() → psi::Molecule¶; Returns the currently active molecule object. psi4.core.get_atomic_point_charges() → psi::Vector¶; Returns the most recently computed atomic point charges, as a double * object. psi4.core.get_datadir() → str¶; Sets the path to shared text resources, PSIDATADIR. psi4.core.get_global_option(arg0: str) → object¶; Given a string of a keyword name arg1, returns the value associated with the keyword from the global options. Returns error if keyword is not recognized. psi4.core.get_global_option_list() → List[str]¶; Returns a list of all global options. psi4.core.get_legacy_gradient() → psi::Matrix¶; Returns the global gradient as a (nat, 3) Matrix object. FOR INTERNAL OPTKING USE ONLY. psi4.core.get_legacy_molecule() → psi::Molecule¶; Returns the currently active molecule object. psi4.core.get_local_option(arg0: str, arg1: str) → object¶; Given a string of a keyword name arg2 and a particular module arg1, returns the value associated with the keyword in the module options scope. Returns error if keyword is not recognized for the module. psi4.core.get_memory() → int¶; Returns the amount of memory available ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psi4api-1.html:280473,charge,charges,280473,psi4manual/1.3.2/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psi4api-1.html,2,['charge'],['charges']
Energy Efficiency," ◻. ◻; REFERENCE →; ◻; type[1] ↓ →; FREEZE_CORE[2]→. QC_MODULE=DFMP2 Capabilities. Restricted (RHF); Unrestricted (UHF); Restricted Open (ROHF). energy(); gradient()[3]; energy(); gradient()[3]; energy(); gradient()[3]. CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD. A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F. mp2[4]; MP2_TYPE. ✓̳; ✓̳. ✓̳; ✓̳. ✓̳; ✓̳. ✓̳; ✓̳. [1]; Algorithm type selection keyword below. Values to the right: conventional CV, density-fitted DF, and Cholesky-decomposed CD. [2]; Active orbital values to the right: all-electron A and frozen-core F. [3]; (1,2,3); Finite difference gradients are not marked explicitly by “∷”, but the capability can be gleaned from the energy availability. [4]; Also available for DFT references RKS/UKS. An example utilization of the code is:; molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set basis cc-pvdz; set scf_type df; set freeze_core True. energy('mp2'). The energy('mp2') call to energy() executes; the predefined DF-MP2 procedure, first calling; the SCF module with a default RHF reference and DF algorithm for the; two-electron integrals. When the orbitals are converged, the DF-MP2 module is; launched, which forms the density-fitted \((Q|ov)\) integrals and then builds the; full \((ov|ov)\) tensor in blocks, evaluating the contributions to the MP2 energy; as it goes. A RHF-MP2 wavefunction is selected automatically due to the RHF; reference. In this example, we freeze the core, both for efficiency and; because split-valence bases like cc-pVDZ do not contain core correlation; functions. The result looks something like:; -----------------------------------------------------------; ==================> DF-MP2 Energies <====================; -----------------------------------------------------------; Reference Energy = -76.0213974638823942 [Eh]; Singles Energy = -0.0000000000000001 [Eh]; Same-Spin Energy = -0.0512503270216563 [Eh]; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/dfmp2.html:3358,energy,energy,3358,psi4manual/1.7.x/dfmp2.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/dfmp2.html,4,['energy'],['energy']
Energy Efficiency,"!= 0) and (s[0:3] == ['GRADIENT', 'RESULT:', 'computation']):; if int(s[3]) != opt_linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (rfile, str(s[3]), str(opt_linkage))); if s[6] != str(n + 1):; raise ValidationError('Output file \'%s.out\' has nominal affiliation %s incompatible with item %s.'; % (rfile, s[6], str(n + 1))); if (s[8:10] == ['electronic', 'energy']):; E = float(s[10]); PsiMod.print_out('%s RESULT: electronic energy = %20.12f\n' % ('GRADIENT', E)); freagent.close(); energies.append(E). # S/R: Quit sow after writing files; if (opt_mode.lower() == 'sow'):; return 0.0. if (opt_mode.lower() == 'reap'):; PsiMod.set_variable('CURRENT ENERGY', energies[-1]). # Obtain the gradient; PsiMod.fd_1_0(energies). # The last item in the list is the reference energy, return it; return energies[-1]. [docs]def property(name, **kwargs):; r""""""Function to compute various properties. :aliases: prop(). :returns: (*float*) Total electronic energy in Hartrees. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - This function at present handles property functions only for CC methods.; Consult the keywords sections for other modules for further property capabilities. - Check that energy is actually being returned. - Check if some PSI variables ought to be set. +-------------------------+---------------------------------------------------------------------------------------+; | name | calls method |; +=========================+=======================================================================================+; | scf | Self-consistent field method(s) |; +-------------------------+---------------------------------------------------------------------------------------+; | cc2 | 2nd-order approximate CCSD |; +-------------------------+---------------------------------------------------------------------------------------+; | ccsd | coupled cluster singles and doubles (CCSD) |; +---------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/driver.html:30072,energy,energy,30072,psi4manual/4.0b2/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/driver.html,1,['energy'],['energy']
Energy Efficiency,"!= 3 or len(a3) != 3 or len(a4) != 3:; raise ValidationError('ERROR: d() only defined for Vector3\n'); eBA = sub(a2, a1); eDC = sub(a4, a3); eCB = sub(a3, a2); CBNorm = norm(eCB); DCxCB = cross(eDC, eCB); CBxBA = cross(eCB, eBA); return -1.0 * math.atan2(CBNorm * dot(eDC, CBxBA), dot(DCxCB, CBxBA)). [docs] def is_computed(self):; """"""Whether the current atom's coordinates are up-to-date.""""""; return self.computed. [docs] def is_equivalent_to(self, other):; """"""Whether this atom has the same mass and ghost status as atom *other*.; Unlike the libmints version, this does not compare basisset assignment. """"""; if other.PYZ != self.PYZ:; return False; if other.PYmass != self.PYmass:; return False; if other.ghosted != self.ghosted:; return False; return True. [docs] def is_ghosted(self):; """"""Whether the current atom is ghosted or not.""""""; return self.ghosted. [docs] def set_ghosted(self, gh):; """"""Flag the atom as either ghost or real.""""""; self.ghosted = gh. [docs] def Z(self):; """"""The nuclear charge of the current atom (0 if ghosted).""""""; if self.ghosted:; return 0.0; else:; return self.PYZ. [docs] def charge(self):; """"""The ""atomic charge"" of the current atom (for SAD purposes).""""""; return self.PYcharge. [docs] def mass(self):; """"""The atomic mass of the current atom.""""""; return self.PYmass. [docs] def symbol(self):; """"""The atomic symbol.""""""; return self.PYsymbol. [docs] def label(self):; """"""The atom label.""""""; return self.PYlabel. [docs] def entry_number(self):; """"""The order in which this appears in the full atom list.""""""; return self.PYentry_number. [docs] def everything(self):; print '\nCoordEntry\n Entry Number = %d\n Computed = %s\n Z = %d\n Charge = %f\n Mass = %f\n Symbol = %s\n Label = %s\n Ghosted = %s\n Coordinates = %s\n\n' % \; (self.entry_number(), self.is_computed(), self.Z(), self.charge(), self.mass(), self.symbol(), self.label(), self.is_ghosted(), self.coordinates). [docs]class CartesianEntry(CoordEntry):; """"""Class to hold all information about an atom, includ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintscoordentry.html:6841,charge,charge,6841,psi4manual/4.0b3/_modules/qcdb/libmintscoordentry.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintscoordentry.html,3,['charge'],['charge']
Energy Efficiency,""" % (self.full_point_group()) TODO symmetry; text += """""" Geometry (in %s), charge = %d, multiplicity = %d:\n\n"""""" % \; ('Bohr', self.molecular_charge(), self.multiplicity()); text += """""" Center X Y Z \n""""""; text += """""" ------------ ----------------- ----------------- -----------------\n"""""". for i in range(self.natom()):; text += """""" %8s%4s """""" % (self.symbol(i), """" if self.Z(i) else ""(Gh)""); for j in range(3):; text += """""" %17.12f"""""" % (self.xyz(i, j)); text += ""\n""; text += ""\n""; else:; text += "" No atoms in this molecule.\n""; print text; # TODO outfile. [docs] def print_out_in_angstrom(self):; """"""Print the molecule in Angstroms. Same as :py:func:`print_out` only always in Angstroms.; (method name in libmints is print_in_angstrom). """"""; text = """"; if self.natom():; if self.pg:; text += """""" Molecular point group: %s\n"""""" % (self.pg.symbol()); # if self.full_pg: TODO symmetry; # text += """""" Full point group: %s\n\n"""""" % (self.full_point_group()) TODO symmetry; text += """""" Geometry (in %s), charge = %d, multiplicity = %d:\n\n"""""" % \; ('Bohr', self.molecular_charge(), self.multiplicity()); text += """""" Center X Y Z \n""""""; text += """""" ------------ ----------------- ----------------- -----------------\n"""""". for i in range(self.natom()):; text += """""" %8s%4s """""" % (self.symbol(i), """" if self.Z(i) else ""(Gh)""); for j in range(3):; text += """""" %17.12f"""""" % (self.xyz(i, j) * psi_bohr2angstroms); text += ""\n""; text += ""\n""; else:; text += "" No atoms in this molecule.\n""; print text; # TODO outfile. [docs] def print_full(self):; """"""Print full atom list. Same as :py:func:`print_out` only displays dummy atoms. """"""; text = """"; if self.natom():; if self.pg:; text += """""" Molecular point group: %s\n"""""" % (self.pg.symbol()); # if self.full_pg: TODO symmetry; # text += """""" Full point group: %s\n\n"""""" % (self.full_point_group()) TODO symmetry; text += """""" Geometry (in %s), charge = %d, multiplicity = %d:\n\n"""""" % \; (self.units(), self.molecular_charge(), self.multiplicity()); text += """"""",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html:25985,charge,charge,25985,psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html,2,['charge'],['charge']
Energy Efficiency,""" % value; core.print_out(cbsscheme); logger.debug(cbsscheme). return value. elif isinstance(valueLO, np.ndarray):. beta = (valueHI - valueLO) * beta_division; value = valueHI - beta * beta_mult. if verbose > 2:; cbsscheme = f""""""\n ==> Helgaker 2-point exponential SCF extrapolation for method: {functionname.upper()} <==\n""""""; cbsscheme += f""""""\n LO-zeta ({zLO}) Data\n""""""; cbsscheme += nppp(valueLO); cbsscheme += f""""""\n HI-zeta ({zHI}) Data\n""""""; cbsscheme += nppp(valueHI). cbsscheme += f""""""\n Alpha (exponent) Value: {alpha:16.8f}""""""; cbsscheme += f""""""\n Beta Data\n""""""; cbsscheme += nppp(beta); cbsscheme += f""""""\n Extrapolated Data\n""""""; cbsscheme += nppp(value); cbsscheme += ""\n""; core.print_out(cbsscheme); logger.debug(cbsscheme). return value. else:; raise ValidationError(f""scf_xtpl_helgaker_2: datatype is not recognized '{type(valueLO)}'.""). [docs]def scf_xtpl_truhlar_2(functionname: str, zLO: int, valueLO: Extrapolatable, zHI: int, valueHI: Extrapolatable, verbose: int = 1, alpha: Optional[float] = None) -> Extrapolatable:; r""""""Extrapolation scheme using power form for reference energies with two adjacent; zeta-level bases. Used by :py:func:`~psi4.cbs`. Parameters; ----------; functionname; Name of the CBS component (e.g., 'HF') used in summary printing.; zLO; Zeta number of the smaller basis set in 2-point extrapolation.; valueLO; Energy, gradient, or Hessian value at the smaller basis set in 2-point; extrapolation.; zHI; Zeta number of the larger basis set in 2-point extrapolation; Must be `zLO + 1`.; valueHI; Energy, gradient, or Hessian value at the larger basis set in 2-point; extrapolation.; verbose; Controls volume of printing.; alpha; Overrides the default :math:`\alpha = 3.4`. Returns; -------; float or ndarray; Eponymous function applied to input zetas and values; type from `valueLO`. Notes; -----; The extrapolation is calculated according to [2]_:; :math:`E_{total}^X = E_{total}^{\infty} + \beta X^{-\alpha}, \alpha = 3.4`. References; ----------. .. [2",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs_helper.html:6843,power,power,6843,psi4manual/1.6.x/_modules/psi4/driver/driver_cbs_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs_helper.html,1,['power'],['power']
Energy Efficiency,""" % value; core.print_out(cbsscheme); logger.debug(cbsscheme). return value. elif isinstance(valueLO, np.ndarray):. beta = (valueHI - valueLO) * beta_division; value = valueHI - beta * beta_mult. if verbose > 2:; cbsscheme = f""""""\n ==> Helgaker 2-point exponential SCF extrapolation for method: {functionname.upper()} <==\n""""""; cbsscheme += f""""""\n LO-zeta ({zLO}) Data\n""""""; cbsscheme += nppp(valueLO); cbsscheme += f""""""\n HI-zeta ({zHI}) Data\n""""""; cbsscheme += nppp(valueHI). cbsscheme += f""""""\n Alpha (exponent) Value: {alpha:16.8f}""""""; cbsscheme += f""""""\n Beta Data\n""""""; cbsscheme += nppp(beta); cbsscheme += f""""""\n Extrapolated Data\n""""""; cbsscheme += nppp(value); cbsscheme += ""\n""; core.print_out(cbsscheme); logger.debug(cbsscheme). return value. else:; raise ValidationError(f""scf_xtpl_helgaker_2: datatype is not recognized '{type(valueLO)}'.""). [docs]def scf_xtpl_truhlar_2(functionname: str, zLO: int, valueLO: Extrapolatable, zHI: int, valueHI: Extrapolatable, verbose: int = 1, alpha: Optional[float] = None) -> Extrapolatable:; r""""""Extrapolation scheme using power form for reference energies with two adjacent; zeta-level bases. Used by :py:func:`~psi4.driver.cbs`. Parameters; ----------; functionname; Name of the CBS component (e.g., 'HF') used in summary printing.; zLO; Zeta number of the smaller basis set in 2-point extrapolation.; valueLO; Energy, gradient, or Hessian value at the smaller basis set in 2-point; extrapolation.; zHI; Zeta number of the larger basis set in 2-point extrapolation; Must be `zLO + 1`.; valueHI; Energy, gradient, or Hessian value at the larger basis set in 2-point; extrapolation.; verbose; Controls volume of printing.; alpha; Overrides the default :math:`\alpha = 3.4`. Returns; -------; float or ~numpy.ndarray; Eponymous function applied to input zetas and values; type from `valueLO`. Notes; -----; The extrapolation is calculated according to [2]_:; :math:`E_{total}^X = E_{total}^{\infty} + \beta X^{-\alpha}, \alpha = 3.4`. References; ---",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_cbs_helper.html:6871,power,power,6871,psi4manual/1.7.x/_modules/psi4/driver/driver_cbs_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_cbs_helper.html,1,['power'],['power']
Energy Efficiency,""" Depending on the nature of the variable, this may or may not make any physical sense.\n""""""; for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); VRXN[db_rxn] = {}. for envv in db_tabulate:; envv = envv.upper(); tables += """"""\n ==> %s <==\n\n"""""" % (envv.title()); tables += tblhead(maxrgt, table_delimit, 2). for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn). if FAIL[rxn]:; tables += """"""\n%23s %8s %8s %8s"""""" % (db_rxn, '', '****', ''); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (VRGT[ACTV[db_rxn][i]][envv], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; VRXN[db_rxn][envv] = 0.0; for i in range(len(ACTV[db_rxn])):; VRXN[db_rxn][envv] += VRGT[ACTV[db_rxn][i]][envv] * RXNM[db_rxn][ACTV[db_rxn][i]]. tables += """"""\n%23s %16.8f """""" % (db_rxn, VRXN[db_rxn][envv]); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (VRGT[ACTV[db_rxn][i]][envv], RXNM[db_rxn][ACTV[db_rxn][i]]); tables += """"""\n %s\n"""""" % (table_delimit). # tabulate primary requested energy variable with statistics; count_rxn = 0; minDerror = 100000.0; maxDerror = 0.0; MSDerror = 0.0; MADerror = 0.0; RMSDerror = 0.0. tables += """"""\n ==> %s <==\n\n"""""" % ('Requested Energy'); tables += tblhead(maxrgt, table_delimit, 1); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn). if FAIL[rxn]:; tables += """"""\n%23s %8.4f %8s %8s"""""" % (db_rxn, BIND[db_rxn], '****', '****'); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; ERXN[db_rxn] = 0.0; for i in range(len(ACTV[db_rxn])):; ERXN[db_rxn] += ERGT[ACTV[db_rxn][i]] * RXNM[db_rxn][ACTV[db_rxn][i]]; error = p4const.psi_hartree2kcalmol * ERXN[db_rxn] - BIND[db_rxn]. tables += """"""\n%23s %8.4f %8.4f %8.4f"""""" % (db_rxn, BIND[db_rxn], p4const.psi_hartree2kcalmol * ERXN[db_rxn], error); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). if abs(error) < abs(minDerror):; minDerror = error; if abs(error) > a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:49112,energy,energy,49112,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,1,['energy'],['energy']
Energy Efficiency,""" Depending on the nature of the variable, this may or may not make any physical sense.\n""""""; for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); VRXN[db_rxn] = {}. for envv in db_tabulate:; envv = envv.upper(); tables += """"""\n ==> %s <==\n\n"""""" % (envv.title()); tables += tblhead(maxrgt, table_delimit, 2). for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn). if FAIL[rxn]:; tables += """"""\n%23s %8s %8s %8s"""""" % (db_rxn, '', '****', ''); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (VRGT[ACTV[db_rxn][i]][envv], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; VRXN[db_rxn][envv] = 0.0; for i in range(len(ACTV[db_rxn])):; VRXN[db_rxn][envv] += VRGT[ACTV[db_rxn][i]][envv] * RXNM[db_rxn][ACTV[db_rxn][i]]. tables += """"""\n%23s %16.8f """""" % (db_rxn, VRXN[db_rxn][envv]); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (VRGT[ACTV[db_rxn][i]][envv], RXNM[db_rxn][ACTV[db_rxn][i]]); tables += """"""\n %s\n"""""" % (table_delimit). # tabulate primary requested energy variable with statistics; count_rxn = 0; minDerror = 100000.0; maxDerror = 0.0; MSDerror = 0.0; MADerror = 0.0; RMSDerror = 0.0. tables += """"""\n ==> %s <==\n\n"""""" % ('Requested Energy'); tables += tblhead(maxrgt, table_delimit, 1); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn). if FAIL[rxn]:; tables += """"""\n%23s %8.4f %8s %8s"""""" % (db_rxn, BIND[db_rxn], '****', '****'); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; ERXN[db_rxn] = 0.0; for i in range(len(ACTV[db_rxn])):; ERXN[db_rxn] += ERGT[ACTV[db_rxn][i]] * RXNM[db_rxn][ACTV[db_rxn][i]]; error = physconst.psi_hartree2kcalmol * ERXN[db_rxn] - BIND[db_rxn]. tables += """"""\n%23s %8.4f %8.4f %8.4f"""""" % (db_rxn, BIND[db_rxn], physconst.psi_hartree2kcalmol * ERXN[db_rxn], error); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). if abs(error) < abs(minDerror):; minDerror = error; if abs(error)",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html:48253,energy,energy,48253,psi4manual/4.0b3/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html,2,['energy'],['energy']
Energy Efficiency,""" has been regularized to ""a-ccsd(t)"" for QCVariables.""""""); name = ""a-ccsd(t)"". if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_cisd(name, **kwargs):; """"""Function selecting the algorithm for a CISD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('CI_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only detci/fnocc. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module in ['', 'FNOCC']:; func = run_cepa; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['', 'DETCI']:; func = run_detci. if func is None:; raise ManagedMethodError(['select_cisd', name, 'CI_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp4(name, **kwargs):; """"""Function selecting the algorithm for a MP4 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only detci/fnocc. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module in ['', 'FNOCC']:; func = run_fnocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'DETCI': # no default for this case; func = run_detci; elif module in ['']:; core.print_out(""""""\nThis method is available inefficiently as a """"""; """"""byproduct of a CISDT computation.\n Add ""set """"""; """"""qc_module detci"" to input to access this route.\n""""""). if func is None:; raise ManagedMethodError(['select_mp4', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_adc2(name, **kwargs):; """"""Function selecting the algorithm for ADC(2) excited ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:28611,energy,energy,28611,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,3,['energy'],['energy']
Energy Efficiency,""""" % (self.pg.symbol()); if self.full_pg:; text += """""" Full point group: %s\n\n"""""" % (self.get_full_point_group()); text += """""" Geometry (in %s), charge = %d, multiplicity = %d:\n\n"""""" % \; ('Angstrom', self.molecular_charge(), self.multiplicity()); text += """""" Center X Y Z \n""""""; text += """""" ------------ ----------------- ----------------- -----------------\n"""""". for i in range(self.natom()):; text += """""" %8s%4s """""" % (self.symbol(i), """" if self.Z(i) else ""(Gh)""); for j in range(3):; text += """""" %17.12f"""""" % (self.xyz(i, j) * psi_bohr2angstroms); text += ""\n""; text += ""\n""; else:; text += "" No atoms in this molecule.\n""; print(text); # TODO outfile. [docs] def print_full(self):; """"""Print full atom list. Same as :py:func:`print_out` only displays dummy atoms. """"""; text = """"; if self.natom():; if self.pg:; text += """""" Molecular point group: %s\n"""""" % (self.pg.symbol()); if self.full_pg:; text += """""" Full point group: %s\n\n"""""" % (self.get_full_point_group()); text += """""" Geometry (in %s), charge = %d, multiplicity = %d:\n\n"""""" % \; (self.units(), self.molecular_charge(), self.multiplicity()); text += """""" Center X Y Z \n""""""; text += """""" ------------ ----------------- ----------------- -----------------\n"""""". for i in range(self.nallatom()):; geom = self.full_atoms[i].compute(); text += """""" %8s%4s """""" % (self.fsymbol(i), """" if self.fZ(i) else ""(Gh)""); for j in range(3):; text += """""" %17.12f"""""" % (geom[j]); text += ""\n""; text += ""\n""; else:; text += "" No atoms in this molecule.\n""; print(text); # TODO outfile. [docs] def print_in_input_format(self):; """"""Print the molecule in the same format that the user provided.; """"""; text = """"; if self.nallatom():; text += "" Geometry (in %s), charge = %d, multiplicity = %d:\n\n"" % \; (""Angstrom"" if self.units() == 'Angstrom' else ""Bohr"",; self.molecular_charge(), self.multiplicity()); for i in range(self.nallatom()):; if self.fZ(i) or self.fsymbol(i) == ""X"":; text += "" %-8s"" % (self.fsymbol(i)); else:; text += "" %-8s"" % (""Gh("" + self.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:29336,charge,charge,29336,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,1,['charge'],['charge']
Energy Efficiency,""""" Initialize an MDIEngine object for communication with MDI (MolSSI driver interface). Parameters; ----------; scf_method; Method (SCF or post-SCF) used when calculating energies or gradients.; molecule; The target molecule, if not the last molecule defined.; kwargs; Any additional arguments to pass to :func:`psi4.driver.energy` or; :func:`psi4.driver.gradient` computation. """""". # Method used when the SCF command is received; self.scf_method = scf_method. # Additional arguments for energy, gradient, or optimization calculations; self.kwargs = kwargs. # Molecule all MDI operations are performed on; input_molecule = kwargs.pop('molecule', psi4.core.get_active_molecule()); self.molecule = input_molecule.clone(); psi4.core.set_active_molecule(self.molecule). # Most recent SCF energy; self.energy = 0.0. # Variables used when MDI sets a lattice of point charges; self.nlattice = 0 # number of lattice point charges; self.clattice = [] # list of lattice coordinates; self.lattice = [] # list of lattice charges; self.lattice_field = psi4.QMMMbohr() # Psi4 chargefield. # MPI variables; self.mpi_world = None; self.world_rank = 0. # Flag for if a lattice of point charges has been set; self.set_lattice = False. # Get correct intra-code MPI communicator; if use_mpi4py:; self.mpi_world = MDI_MPI_get_world_comm(); self.world_rank = self.mpi_world.Get_rank(). # Psi4 does not currently support multiple MPI ranks; if self.mpi_world.Get_size() != 1:; MPI.COMM_WORLD.Abort(). # Accept a communicator to the driver code; self.comm = MDI_Accept_Communicator(). # Ensure that the molecule is using c1 symmetry; self.molecule.reset_point_group('c1'); self.molecule.fix_orientation(True); self.molecule.fix_com(True); self.molecule.reinterpret_coordentry(False); self.molecule.update_geometry(). # Flag to stop listening for MDI commands; self.stop_listening = False. # Dictionary of all supported MDI commands; self.commands = {; ""<NATOMS"": self.send_natoms,; ""<COORDS"": self.send_coords,; ""<CHARGES"": s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/mdi_engine.html:2771,charge,charges,2771,psi4manual/1.7.x/_modules/psi4/driver/mdi_engine.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/mdi_engine.html,1,['charge'],['charges']
Energy Efficiency,""""""" % (occs[k], energies[k], potentials[k], convs[k])); fh.close(). # Properly, should clone molecule but since not returned and easy to unblemish,; molecule.set_molecular_charge(charge0); molecule.set_multiplicity(mult0). return E. # Pull all the electrons out, one at a time; [docs]def frac_nuke(molecule, **kwargs):; kwargs = p4util.kwargs_lower(kwargs). # The molecule is required, and should be the neutral species; molecule.update_geometry(); charge0 = molecule.molecular_charge(); mult0 = molecule.multiplicity(). # By default, we start the frac procedure on the 25th iteration; # when not reading a previous guess; frac_start = kwargs.get('frac_start', 25). # By default, we occupy by tenths of electrons; foccs = kwargs.get('foccs', [1.0, 0.9, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2, 0.1, 0.0]). # By default, HOMO and LUMO are both in alpha; N = 0;; for A in range(molecule.natom()):; N += molecule.Z(A); N -= charge0; N = int(N); Nb = int((N - mult0 + 1) / 2); Na = int(N - Nb). charge = charge0; mult = mult0. # By default, nuke all the electrons; Nmin = 0;; if ('nmax' in kwargs):; Nmin = N - int(kwargs['nmax']). # By default, DIIS in FRAC (1.0 occupation is always DIIS'd); frac_diis = kwargs.get('frac_diis', True). # By default, drop the files to the molecule's name; root = kwargs.get('filename', molecule.name()); traverse_filename = root + '.traverse.dat'; stats_filename = root + '.stats.dat'. # => Traverse <= #; psi4.set_global_option(""DF_INTS_IO"", ""SAVE""). Ns = []; energies = []; potentials = []; convs = []; stats = []. # Run one SCF to burn things in; E, wfn= energy('scf', return_wfn=True, molecule=molecule, **kwargs). # Determine HOMO; eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); if Na == Nb:; HOMO = -Nb; elif Nb == 0:; HOMO = Na; else:; E_a = eps_a[int(Na - 1)]; E_b = eps_b[int(Nb - 1)]; if E_a >= E_b:; HOMO = Na; else:; HOMO = -Nb. stats.append(""""""\t%6d %6d %6d %6d %6d %6d\n"""""" % (N, Na, Nb, charge, mult, HOMO)). if HOMO > 0:; Na = Na - 1; else:; Nb = Nb - 1; ch",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/frac.html:7799,charge,charge,7799,psi4manual/1.0.0/_modules/frac.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/frac.html,1,['charge'],['charge']
Energy Efficiency,""""""" DOcom? %s\t\tDONTreorient? %s\n"""""" % (self.PYmove_to_com, self.orientation_fixed()); text += """""" reinterpret? %s\t\tlock_frame? %s\n"""""" % (self.PYreinterpret_coordentries, self.lock_frame); text += """""" input symm %s\n"""""" % (self.symmetry_from_input()); text += """""" Nfragments %d\t\tNactive %d\n"""""" % (self.nfragments(), self.nactive_fragments()); text += """""" zmat? %s\n"""""" % (self.has_zmatrix()); print(text). [docs] def create_psi4_string_from_molecule(self):; """"""Regenerates a input file molecule specification string from the; current state of the Molecule. Contains geometry info,; fragmentation, charges and multiplicities, and any frame; restriction.; """"""; text = """"; if self.nallatom():. # append units and any other non-default molecule keywords; text += "" units %-s\n"" % (""Angstrom"" if self.units() == 'Angstrom' else ""Bohr""); if not self.PYmove_to_com:; text += "" no_com\n""; if self.PYfix_orientation:; text += "" no_reorient\n"". # append atoms and coordentries and fragment separators with charge and multiplicity; Pfr = 0; for fr in range(self.nfragments()):; if self.fragment_types[fr] == 'Absent' and not self.has_zmatrix():; continue; text += ""%s %s%d %d\n"" % (; """" if Pfr == 0 else "" --\n"",; ""#"" if self.fragment_types[fr] == 'Ghost' or self.fragment_types[fr] == 'Absent' else """",; self.fragment_charges[fr], self.fragment_multiplicities[fr]); Pfr += 1; for at in range(self.fragments[fr][0], self.fragments[fr][1] + 1):; if self.fragment_types[fr] == 'Absent':; text += "" %-8s"" % (""X""); elif self.fZ(at) or self.fsymbol(at) == ""X"":; text += "" %-8s"" % (self.flabel(at)); else:; text += "" %-8s"" % (""Gh("" + self.flabel(at) + "")""); text += "" %s"" % (self.full_atoms[at].print_in_input_format()); text += ""\n"". # append any coordinate variables; if len(self.geometry_variables):; for vb, val in self.geometry_variables.items():; text += """""" %-10s=%16.10f\n"""""" % (vb, val); text += ""\n"". return text. # <<< Involved Methods for Coordinates >>>. [docs] def get_coord_value(self, vstr):; """,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:32087,charge,charge,32087,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,1,['charge'],['charge']
Energy Efficiency,""""""" Full point group: %s\n\n"""""" % (self.get_full_point_group()); text += """""" Geometry (in %s), charge = %d, multiplicity = %d:\n\n"""""" % \; ('Bohr', self.molecular_charge(), self.multiplicity()); text += """""" Center X Y Z \n""""""; text += """""" ------------ ----------------- ----------------- -----------------\n"""""". for i in range(self.natom()):; text += """""" %8s%4s """""" % (self.symbol(i), """" if self.Z(i) else ""(Gh)""); for j in range(3):; text += """""" %17.12f"""""" % (self.xyz(i, j)); text += ""\n""; text += ""\n""; else:; text += "" No atoms in this molecule.\n""; print(text); # TODO outfile. [docs] def print_out_in_angstrom(self):; """"""Print the molecule in Angstroms. Same as :py:func:`print_out` only always in Angstroms.; (method name in libmints is print_in_angstrom). """"""; text = """"; if self.natom():; if self.pg:; text += """""" Molecular point group: %s\n"""""" % (self.pg.symbol()); if self.full_pg:; text += """""" Full point group: %s\n\n"""""" % (self.get_full_point_group()); text += """""" Geometry (in %s), charge = %d, multiplicity = %d:\n\n"""""" % \; ('Angstrom', self.molecular_charge(), self.multiplicity()); text += """""" Center X Y Z \n""""""; text += """""" ------------ ----------------- ----------------- -----------------\n"""""". for i in range(self.natom()):; text += """""" %8s%4s """""" % (self.symbol(i), """" if self.Z(i) else ""(Gh)""); for j in range(3):; text += """""" %17.12f"""""" % (self.xyz(i, j) * psi_bohr2angstroms); text += ""\n""; text += ""\n""; else:; text += "" No atoms in this molecule.\n""; print(text); # TODO outfile. [docs] def print_full(self):; """"""Print full atom list. Same as :py:func:`print_out` only displays dummy atoms. """"""; text = """"; if self.natom():; if self.pg:; text += """""" Molecular point group: %s\n"""""" % (self.pg.symbol()); if self.full_pg:; text += """""" Full point group: %s\n\n"""""" % (self.get_full_point_group()); text += """""" Geometry (in %s), charge = %d, multiplicity = %d:\n\n"""""" % \; (self.units(), self.molecular_charge(), self.multiplicity()); text += """""" Center X Y Z \n""""""; text += """,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:28479,charge,charge,28479,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,1,['charge'],['charge']
Energy Efficiency,""""""".format(engine, self.dashlevel)). if self.engine == 'libdisp':; self.disp = core.Dispersion.build(self.dashlevel, **resolved['dashparams']). [docs] def print_out(self):; """"""Format dispersion parameters of `self` for output file."""""". text = []; text.append("" => %s: Empirical Dispersion <="" % (self.fctldash.upper() if self.fctldash.upper() else 'Custom')); text.append(''); text.append(self.description); text.append(self.dashlevel_citation.rstrip()); if self.dashparams_citation:; text.append("" Parametrisation from:{}"".format(self.dashparams_citation.rstrip())); text.append(''); for op in self.ordered_params:; text.append("" %6s = %14.6f"" % (op, self.dashparams[op])); text.append('\n'). core.print_out('\n'.join(text)). [docs] def compute_energy(self, molecule):; """"""Compute dispersion energy based on engine, dispersion level, and parameters in `self`. Parameters; ----------; molecule : psi4.core.Molecule; System for which to compute empirical dispersion correction. Returns; -------; float; Dispersion energy [Eh]. Notes; -----; DISPERSION CORRECTION ENERGY; Disp always set. Overridden in SCF finalization, but that only changes for ""-3C"" methods.; self.fctldash + DISPERSION CORRECTION ENERGY; Set if `fctldash` nonempty. """"""; if self.engine == 'dftd3':; jobrec = intf_dftd3.run_dftd3_from_arrays(; molrec=molecule.to_dict(np_out=False),; name_hint=self.fctldash,; level_hint=self.dashlevel,; param_tweaks=self.dashparams,; dashcoeff_supplement=self.dashcoeff_supplement,; ptype='energy',; verbose=1). dashd_part = float(jobrec['qcvars']['DISPERSION CORRECTION ENERGY'].data); for k, qca in jobrec['qcvars'].items():; if not isinstance(qca.data, np.ndarray):; core.set_variable(k, qca.data). if self.fctldash in ['hf3c', 'pbeh3c']:; gcp_part = gcp.run_gcp(molecule, self.fctldash, verbose=False, dertype=0); dashd_part += gcp_part. return dashd_part; else:; ene = self.disp.compute_energy(molecule); core.set_variable('DISPERSION CORRECTION ENERGY', ene); if self.fctldash:; core.set_vari",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/empirical_dispersion.html:6694,energy,energy,6694,psi4manual/1.3.2/_modules/psi4/driver/procrouting/empirical_dispersion.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/empirical_dispersion.html,1,['energy'],['energy']
Energy Efficiency,"""""""; basisChanged = PsiMod.has_option_changed(""BASIS""); ribasisChanged = PsiMod.has_option_changed(""DF_BASIS_SCF""); scftypeChanged = PsiMod.has_option_changed(""SCF_TYPE""). basis = PsiMod.get_option(""BASIS""); ribasis = PsiMod.get_option(""DF_BASIS_SCF""); scftype = PsiMod.get_option(""SCF_TYPE""). PsiMod.print_out("" => Diffuse SCF (Determines Da) <=\n\n""); activate(self.molecule). PsiMod.set_global_option(""BASIS"", self.basisname); PsiMod.set_global_option(""DF_BASIS_SCF"", self.ribasisname); PsiMod.set_global_option(""SCF_TYPE"", ""DF""); energy('scf'); PsiMod.print_out(""\n""). self.fitGeneral(). PsiMod.clean(). PsiMod.set_global_option(""BASIS"", basis); PsiMod.set_global_option(""DF_BASIS_SCF"", ribasis); PsiMod.set_global_option(""SCF_TYPE"", scftype). if not basisChanged:; PsiMod.revoke_option_changed(""BASIS""); if not ribasisChanged:; PsiMod.revoke_option_changed(""DF_BASIS_SCF""); if not scftypeChanged:; PsiMod.revoke_option_changed(""SCF_TYPE""). [docs] def fitGeneral(self):; """"""Function to perform a general fit of diffuse charges; to wavefunction density. """"""; PsiMod.print_out("" => Diffuse Charge Fitting (Determines da) <=\n\n""); self.wfn = PsiMod.reference_wavefunction(); self.Da = self.wfn.Da(); self.basis = self.wfn.basisset(); parser = PsiMod.Gaussian94BasisSetParser(); self.ribasis = PsiMod.BasisSet.construct(parser, self.molecule, ""DF_BASIS_SCF""). fitter = PsiMod.DFChargeFitter(); fitter.setPrimary(self.basis); fitter.setAuxiliary(self.ribasis); fitter.setD(self.Da); self.da = fitter.fit(); self.da.scale(2.0). [docs] def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = PsiMod.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diff",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/qmmm.html:1903,charge,charges,1903,psi4manual/4.0b2/_modules/qmmm.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/qmmm.html,2,['charge'],['charges']
Energy Efficiency,"""""""; basisChanged = PsiMod.has_option_changed(""BASIS""); ribasisChanged = PsiMod.has_option_changed(""DF_BASIS_SCF""); scftypeChanged = PsiMod.has_option_changed(""SCF_TYPE""). basis = PsiMod.get_option(""BASIS""); ribasis = PsiMod.get_option(""DF_BASIS_SCF""); scftype = PsiMod.get_option(""SCF_TYPE""). PsiMod.print_out("" => Diffuse SCF (Determines Da) <=\n\n""); activate(self.molecule). PsiMod.set_global_option(""BASIS"", self.basisname); PsiMod.set_global_option(""DF_BASIS_SCF"", self.ribasisname); PsiMod.set_global_option(""SCF_TYPE"", ""DF""); energy('scf'); PsiMod.print_out(""\n""). self.fitGeneral(). PsiMod.clean(). PsiMod.set_global_option(""BASIS"", basis); PsiMod.set_global_option(""DF_BASIS_SCF"", ribasis); PsiMod.set_global_option(""SCF_TYPE"", scftype). if not basisChanged:; PsiMod.revoke_option_changed(""BASIS""); if not ribasisChanged:; PsiMod.revoke_option_changed(""DF_BASIS_SCF""); if not scftypeChanged:; PsiMod.revoke_option_changed(""SCF_TYPE""). [docs] def fitGeneral(self):; """"""Function to perform a general fit of diffuse charges; to wavefunction density. """"""; PsiMod.print_out("" => Diffuse Charge Fitting (Determines da) <=\n\n""); self.wfn = PsiMod.wavefunction(); self.Da = self.wfn.Da(); self.basis = self.wfn.basisset(); parser = PsiMod.Gaussian94BasisSetParser(); self.ribasis = PsiMod.BasisSet.construct(parser, self.molecule, ""DF_BASIS_SCF""). fitter = PsiMod.DFChargeFitter(); fitter.setPrimary(self.basis); fitter.setAuxiliary(self.ribasis); fitter.setD(self.Da); self.da = fitter.fit(); self.da.scale(2.0). [docs] def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = PsiMod.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/qmmm.html:1900,charge,charges,1900,psi4manual/4.0b4/_modules/qmmm.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qmmm.html,1,['charge'],['charges']
Energy Efficiency,"""""""Parses the contents of the Cfour ZMAT file into array and; coordinate information. The coordinate info is converted into a; rather dinky Molecule (no fragment, but does read charge, mult,; unit). Return qcdb.Molecule. Written for findif zmat* where; geometry always Cartesian and Bohr. """"""; zmat = zmat.splitlines()[1:] # skip comment line; Nat = 0; readCoord = True; isBohr = ''; charge = 0; mult = 1; molxyz = ''; cgeom = []; for line in zmat:; if line.strip() == '':; readCoord = False; elif readCoord:; lline = line.split(); molxyz += line + '\n'; Nat += 1; else:; if line.find('CHARGE') > -1:; idx = line.find('CHARGE'); charge = line[idx + 7:]; idxc = charge.find(','); if idxc > -1:; charge = charge[:idxc]; charge = int(charge); if line.find('MULTIPLICITY') > -1:; idx = line.find('MULTIPLICITY'); mult = line[idx + 13:]; idxc = mult.find(','); if idxc > -1:; mult = mult[:idxc]; mult = int(mult); if line.find('UNITS=BOHR') > -1:; isBohr = ' bohr'. molxyz = '%d%s\n%d %d\n' % (Nat, isBohr, charge, mult) + molxyz; mol = Molecule.init_with_xyz(molxyz, no_com=True, no_reorient=True, contentsNotFilename=True). return mol. [docs]def harvest_FCM(fcm):; """"""Parses the contents *fcm* of the Cfour FCMFINAL file into a hessian array. """"""; fcm = fcm.splitlines(); Nat = int(fcm[0].split()[0]); Ndof = int(fcm[0].split()[1]). empty = True; hess = []; for df in range(Ndof):; for at in range(Nat):; lline = fcm[Ndof * at + at + 1].split(); if empty:; if (abs(float(lline[0])) > 1.0e-8) or \; (abs(float(lline[1])) > 1.0e-8) or \; (abs(float(lline[2])) > 1.0e-8):; empty = False; fcm.append([float(lline[0]), float(lline[1]), float(lline[2])]). return None if empty else hess. [docs]def harvest_DIPOL(dipol):; """"""Parses the contents *dipol* of the Cfour DIPOL file into a dipol vector. """"""; dipol = dipol.splitlines(); lline = dipol[0].split(); dip = [float(lline[0]), float(lline[1]), float(lline[2])]. #return None if empty else dip; return dip. [docs]def muster_memory(mem):; """"""Transform input *",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html:25752,charge,charge,25752,psi4manual/1.0.0/_modules/qcdb/cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html,1,['charge'],['charge']
Energy Efficiency,"""""""Returns basisset to atom map""""""; return self.PYbasissets. [docs] def set_shell(self, bshash, key='BASIS'):; """"""Set the hash for this atom; * @param key Keyword from input file, basis, ri_basis, etc.; * @param bshash hash string of one-atom BasisSet. """"""; self.PYshells[key] = bshash. [docs] def shell(self, key='BASIS'):; """"""Returns the hash for the provided type.; * @param type Keyword from input file.; * @returns the hash string for basis. """"""; try:; return self.PYshells[key]; except (ValueError, KeyError):; raise ValidationError('CoordEntry::shells: Shells not set for %s and type of %s' % \; (self.PYlabel, key)). [docs] def shells(self):; """"""Returns shells sets to atom map""""""; return self.PYshells. [docs] def everything(self):; print('\nCoordEntry\n Entry Number = %d\n Computed = %s\n Z = %d\n Charge = %f\n Mass = %f\n Symbol = %s\n Label = %s\n Ghosted = %s\n Coordinates = %s\n Basissets = %s\n\n Shells = %s\n\n' %; (self.entry_number(), self.is_computed(), self.Z(), self.charge(),; self.mass(), self.symbol(), self.label(), self.is_ghosted(),; self.coordinates, self.PYbasissets, self.PYshells)). [docs]class CartesianEntry(CoordEntry):; """"""Class to hold all information about an atom, including its; coordinate specification as three Cartesians. """""". def __init__(self, entry_number, Z, charge, mass, symbol, label, x, y, z, basis=None, shells=None):; CoordEntry.__init__(self, entry_number, Z, charge, mass, symbol, label, basis, shells); self.x = x; self.y = y; self.z = z. [docs] def compute(self):; """"""Computes the values of the coordinates (in whichever units; were inputted), returning them in a Vector. """"""; if self.computed:; return self.coordinates; self.coordinates[0] = self.x.compute(); self.coordinates[1] = self.y.compute(); self.coordinates[2] = self.z.compute(); self.computed = True; return self.coordinates. [docs] def set_coordinates(self, x, y, z):; """"""Given the current set of coordinates, updates the values of this; atom's coordinates and any variables th",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html:11343,charge,charge,11343,psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html,1,['charge'],['charge']
Energy Efficiency,"""""""input, such as DOCC, is correct."""""" % (current_sym, initial_sym)); kwargs['opt_iter'] = n; core.set_variable('GEOMETRY ITERATIONS', n). # Use orbitals from previous iteration as a guess; # set within loop so that can be influenced by fns to optimize (e.g., cbs); if (n > 1) and (not core.get_option('SCF', 'GUESS_PERSIST')):; core.set_local_option('SCF', 'GUESS', 'READ'). # Before computing gradient, save previous molecule and wavefunction if this is an IRC optimization; if (n > 1) and (core.get_option('OPTKING', 'OPT_TYPE') == 'IRC'):; old_thisenergy = core.variable('CURRENT ENERGY'). # Compute the gradient - preserve opt data despite core.clean calls in gradient; core.IOManager.shared_object().set_specific_retention(1, True); G, wfn = gradient(lowername, return_wfn=True, molecule=moleculeclone, **kwargs); thisenergy = core.variable('CURRENT ENERGY'). # above, used to be getting energy as last of energy list from gradient(); # thisenergy below should ultimately be testing on wfn.energy(). # Record optimization steps; # Add wavefunctions later; if return_history:; step_energies.append(thisenergy); step_coordinates.append(moleculeclone.geometry()); step_gradients.append(G.clone()). core.set_legacy_gradient(G). # opt_func = kwargs.get('opt_func', kwargs.get('func', energy)); # if opt_func.__name__ == 'complete_basis_set':; # core.IOManager.shared_object().set_specific_retention(1, True). if full_hess_every > -1:; core.set_global_option('HESSIAN_WRITE', True). # compute Hessian as requested; frequency wipes out gradient so stash it; if ((full_hess_every > -1) and (n == 1)) or (steps_since_last_hessian + 1 == full_hess_every):; G = core.get_legacy_gradient() # TODO; core.IOManager.shared_object().set_specific_retention(1, True); core.IOManager.shared_object().set_specific_path(1, './'); frequencies(hessian_with_method, molecule=moleculeclone, ref_gradient=G, **kwargs); steps_since_last_hessian = 0; core.set_legacy_gradient(G); core.set_global_option('CART_HESS_READ', Tr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html:65663,energy,energy,65663,psi4manual/1.6.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html,1,['energy'],['energy']
Energy Efficiency,"""""""{; ""Natoms per frag"": [12, 16],; ""A Frag"": 1,; ""A Ref Atoms"": [[1, 3, 4, 6, 8], [8], [11]],; ""A Label"": ""methylthiophene"",; ""B Frag"": 2,; ""B Ref Atoms"": [[13, 14, 15, 16, 17, 18], [13], [15]],; ""B Label"": ""tyrosine"",; ""Frozen"": [""theta_A"", ""theta_B"", ""tau"", ""phi_A"", ""phi_B""],; }"""""". set {; basis 6-31+G; frag_mode MULTI; interfrag_coords $MTdimer; }. optimize(""mp2""). Dealing with problematic optimizations¶; Although optking is continuously improved with robustness in mind, some; attempted optimizations will inevitably fail to converge to the desired minima.; For difficult cases, the following suggestions are made. As for any optimizer, computing the Hessian and limiting the step size will; successfully converge a higher percentage of cases. The default settings have; been chosen because they perform efficiently for common, representative test sets.; More restrictive, cautious steps are sometimes necessary.; DYNAMIC_LEVEL allows optking to change the method of optimization; toward algorithms that, while often less efficient, may help to converge difficult; cases. If this is initially set to 1, then optking, as poor steps are detected,; will increase the dynamic level through several forms of more robust and cautious algorithms.; The changes will reduce the trust radius, allow backward steps (partial line; searching), add cartesian coordinates, switch to cartesian coordinates, and take; steepest-descent steps.; The developers have found the OPT_COORDINATES set to “BOTH” which; includes both the redundant internal coordinate set, as well as cartesian coordinates,; works well for systems with long ‘arms’ or floppy portions of a molecule poorly; described by local internals.; Optking does support the specification of ghost atoms. Certain internal coordinates such; as torsions become poorly defined when they contain near-linear bends.; An internal error AlgError may be raised in such cases. Optking will avoid such; coordinates when choosing an initial coordinate system; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/optking.html:16511,efficient,efficient,16511,psi4manual/1.7.x/optking.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/optking.html,4,['efficient'],['efficient']
Energy Efficiency,"""""). if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_remp2(name, **kwargs):; """"""Function selecting the algorithm for a REMP2 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in [""RHF"", ""UHF""]:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccd(name, **kwargs):; """"""Function selecting the algorithm for a CCD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option(""SCF"", ""REFERENCE""); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option(""QC_MODULE""). func = None; if reference in [""RHF"", ""UHF""]:; if mtd_type == ""CONV"":; if module in [""""]:; core.print_out(""""""\nThis method is not available with conventional integrals. Add ""set """"""; """"""cc_type df"" or ""set cc_type cd"" to input to access this method.\n""""""); elif mtd_type == ""DF"":; if module in ["""", ""OCC""]:; func = run_dfocc; elif mtd_type == ""CD"":; if module in ["""", ""OCC""]:; func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccd_gradient(name, **kwargs):; """"""Function selecting the algorithm for a CCD gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_opti",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:31894,energy,energy,31894,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,4,['energy'],['energy']
Energy Efficiency,""""". text += """"""\n\n Entropy, S""""""; for term in terms:; text += format_S_Cv_Cp.format(terms[term] + ' S', *sm[('S', term)] * uconv); if term == 'elec':; text += """""" (multiplicity = {})"""""".format(multiplicity); elif term == 'trans':; text += """""" (mol. weight = {:.4f} [u], P = {:.2f} [Pa])"""""".format(molecular_mass, P); elif term == 'rot':; text += """""" (symmetry no. = {})"""""".format(sigma). text += """"""\n\n Constant volume heat capacity, Cv""""""; for term in terms:; text += format_S_Cv_Cp.format(terms[term] + ' Cv', *sm[('Cv', term)] * uconv). text += """"""\n\n Constant pressure heat capacity, Cp""""""; for term in terms:; text += format_S_Cv_Cp.format(terms[term] + ' Cp', *sm[('Cp', term)] * uconv). del terms['tot']; terms['corr'] = 'Correction'. text += """"""\n\n ==> Thermochemistry Energy Analysis <=="""""". text += """"""\n\n Raw electronic energy, E0""""""; text += """"""\n Total E0, Electronic energy at well bottom at 0 [K] {:15.8f} [Eh]"""""".format(E0). text += """"""\n\n Zero-point energy, ZPE_vib = Sum_i nu_i / 2""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' ZPE', *sm[('ZPE', term)] * uconv); if term in ['vib', 'corr']:; text += """""" {:15.3f} [cm^-1]"""""".format(sm[('ZPE', term)] * qcel.constants.hartree2wavenumbers); text += """"""\n Total ZPE, Electronic energy at 0 [K] {:15.8f} [Eh]"""""".format(; sm[('ZPE', 'tot')]). text += """"""\n\n Thermal Energy, E (includes ZPE)""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' E', *sm[('E', term)] * uconv); text += """"""\n Total E, Electronic energy at {:7.2f} [K] {:15.8f} [Eh]"""""".format(; T, sm[('E', 'tot')]). text += """"""\n\n Enthalpy, H_trans = E_trans + k_B * T""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' H', *sm[('H', term)] * uconv); text += """"""\n Total H, Enthalpy at {:7.2f} [K] {:15.8f} [Eh]"""""".format(; T, sm[('H', 'tot')]). text += """"""\n\n Gibbs free energy, G = H - T * S""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' G', *sm[('G', term)] * uconv); tex",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/qcdb/vib.html:37293,energy,energy,37293,psi4manual/1.4.0/_modules/psi4/driver/qcdb/vib.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/qcdb/vib.html,8,['energy'],['energy']
Energy Efficiency,""""". try:; from deepdiff import DeepDiff; except ImportError:; raise ImportError(""""""Install deepdiff. `conda install deepdiff -c conda-forge` or `pip install deepdiff`""""""). # Grab expected header and integrals; ref_intdump = fcidump_from_file(expected); intdump = fcidump_from_file(computed). # Compare headers; header_diff = DeepDiff(; ref_intdump,; intdump,; ignore_order=True,; exclude_paths={""root['enuc']"", ""root['hcore']"", ""root['eri']"", ""root['epsilon']""}); if header_diff:; message = (""\tComputed FCIDUMP file header does not match expected header.\n""); raise TestComparisonError(header_diff). ref_energies = _energies_from_fcidump(ref_intdump); energies = _energies_from_fcidump(intdump). pass_1el = compare_values(ref_energies['ONE-ELECTRON ENERGY'], energies['ONE-ELECTRON ENERGY'], 7, label + '. 1-electron energy'); pass_2el = compare_values(ref_energies['TWO-ELECTRON ENERGY'], energies['TWO-ELECTRON ENERGY'], 7, label + '. 2-electron energy'); pass_scf = compare_values(ref_energies['SCF TOTAL ENERGY'], energies['SCF TOTAL ENERGY'], 10, label + '. SCF total energy'); pass_mp2 = compare_values(ref_energies['MP2 CORRELATION ENERGY'], energies['MP2 CORRELATION ENERGY'], 10, label + '. MP2 correlation energy'). if (pass_1el and pass_2el and pass_scf and pass_mp2):; success(label). return True. def _energies_from_fcidump(intdump):; energies = {}; energies['NUCLEAR REPULSION ENERGY'] = intdump['enuc']; epsilon = intdump['epsilon']; Hcore = intdump['hcore']; eri = intdump['eri']. # Compute SCF energy; energies['ONE-ELECTRON ENERGY'], energies['TWO-ELECTRON ENERGY'] = _scf_energy(Hcore, eri,; np.where(epsilon < 0)[0],; intdump['uhf']); # yapf: disable; energies['SCF TOTAL ENERGY'] = energies['ONE-ELECTRON ENERGY'] + energies['TWO-ELECTRON ENERGY'] + energies['NUCLEAR REPULSION ENERGY']; # yapf: enable. # Compute MP2 energy; energies['MP2 CORRELATION ENERGY'] = _mp2_energy(eri, epsilon, intdump['uhf']). return energies. def _scf_energy(Hcore, ERI, occ_sl, unrestricted):; scf",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/p4util/fcidump.html:12864,energy,energy,12864,psi4manual/1.2.1/_modules/psi4/driver/p4util/fcidump.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/p4util/fcidump.html,1,['energy'],['energy']
Energy Efficiency,"""""; basisChanged = core.has_option_changed(""BASIS""); ribasisChanged = core.has_option_changed(""DF_BASIS_SCF""); scftypeChanged = core.has_option_changed(""SCF_TYPE""). basis = core.get_option(""BASIS""); ribasis = core.get_option(""DF_BASIS_SCF""); scftype = core.get_option(""SCF_TYPE""). core.print_out("" => Diffuse SCF (Determines Da) <=\n\n""). core.set_global_option(""BASIS"", self.basisname); core.set_global_option(""DF_BASIS_SCF"", self.ribasisname); core.set_global_option(""SCF_TYPE"", ""DF""); E, ref = energy('scf', return_wfn=True, molecule=self.molecule); self.wfn = ref; core.print_out(""\n""). self.fitGeneral(). core.clean(). core.set_global_option(""BASIS"", basis); core.set_global_option(""DF_BASIS_SCF"", ribasis); core.set_global_option(""SCF_TYPE"", scftype). if not basisChanged:; core.revoke_option_changed(""BASIS""); if not ribasisChanged:; core.revoke_option_changed(""DF_BASIS_SCF""); if not scftypeChanged:; core.revoke_option_changed(""SCF_TYPE""). def fitGeneral(self):; """"""Function to perform a general fit of diffuse charges; to wavefunction density. """"""; core.print_out("" => Diffuse Charge Fitting (Determines da) <=\n\n""); self.Da = self.wfn.Da(); self.basis = self.wfn.basisset(); parser = core.Gaussian94BasisSetParser(); self.ribasis = core.BasisSet.construct(parser, self.molecule, ""DF_BASIS_SCF""). fitter = core.DFChargeFitter(); fitter.setPrimary(self.basis); fitter.setAuxiliary(self.ribasis); fitter.setD(self.Da); self.da = fitter.fit(); self.da.scale(2.0). def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = core.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs] def addChargeBohr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/qmmm.html:2806,charge,charges,2806,psi4manual/1.1.0/_modules/psi4/driver/qmmm.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/qmmm.html,1,['charge'],['charges']
Energy Efficiency,"""""; natom = self.molecule.natom(); charges = [self.molecule.charge(iatom) for iatom in range(natom)]; MDI_Send(charges, natom, MDI_DOUBLE, self.comm); return charges. # Respond to the <MASSES command; def send_masses(self):; """""" Send the nuclear masses through MDI. :returns: *masses* Atomic masses; """"""; natom = self.molecule.natom(); molecule_dict = self.molecule.to_dict(); masses = molecule_dict['mass']; MDI_Send(masses, natom, MDI_DOUBLE, self.comm); return masses. # Respond to the <ELEMENTS command; def send_elements(self):; """""" Send the atomic number of each nucleus through MDI. :returns: *elements* Element of each atom; """"""; natom = self.molecule.natom(); elements = [self.molecule.true_atomic_number(iatom) for iatom in range(natom)]; MDI_Send(elements, natom, MDI_INT, self.comm); return elements. # Respond to the <ENERGY command; def send_energy(self):; """""" Send the total energy through MDI. :returns: *energy* Energy of the system; """"""; self.run_scf(); MDI_Send(self.energy, 1, MDI_DOUBLE, self.comm); return self.energy. # Respond to the <FORCES command; def send_forces(self):; """""" Send the nuclear forces through MDI. :returns: *forces* Atomic forces; """"""; force_matrix = psi4.driver.gradient(self.scf_method, **self.kwargs); forces = force_matrix.np.ravel(); MDI_Send(forces, len(forces), MDI_DOUBLE, self.comm); return forces. # Respond to the >CHARGES command; def recv_charges(self, charges=None):; """""" Receive a set of nuclear charges through MDI and assign them to the atoms in the current molecule. Arguments:; charges: New nuclear charges. If None, receive through MDI.; """"""; natom = self.molecule.natom(); if charges is None:; charges = MDI_Recv(natom, MDI_DOUBLE, self.comm). # Assign the charge of all atoms, taking care to avoid ghost atoms; jatom = 0; for iatom in range(natom):; while self.molecule.fZ(jatom) == 0 and jatom < self.molecule.nallatom():; jatom = jatom + 1; if jatom >= self.molecule.nallatom():; raise Exception('Unexpected number of ghost atoms whe",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html:6138,energy,energy,6138,psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html,7,['energy'],['energy']
Energy Efficiency,"""""Wrapper complete_basis_set is unhappy to be calling function '%s' instead of 'energy'."""""" % ptype). optstash = p4util.OptionsState(; ['BASIS'],; ['WFN'],; ['WRITER_FILE_LABEL']). # Define some quantum chemical knowledge, namely what methods are subsumed in others. do_scf = True; do_corl = False; do_delta = False; do_delta2 = False; do_delta3 = False; do_delta4 = False; do_delta5 = False. user_writer_file_label = core.get_global_option('WRITER_FILE_LABEL'). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(); molstr = molecule.create_psi4_string_from_molecule(); natom = molecule.natom(). # Establish method for reference energy; cbs_scf_wfn = kwargs.pop('scf_wfn', 'hf').lower(). if do_scf:; if cbs_scf_wfn not in VARH.keys():; raise ValidationError(""""""Requested SCF method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_scf_wfn)). # Establish method for correlation energy; cbs_corl_wfn = kwargs.pop('corl_wfn', '').lower(); if cbs_corl_wfn:; do_corl = True. if do_corl:; if cbs_corl_wfn not in VARH.keys():; raise ValidationError(""""""Requested CORL method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_corl_wfn)). cbs_corl_wfn_lesser = kwargs.get('corl_wfn_lesser', cbs_scf_wfn).lower(); if cbs_corl_wfn_lesser not in VARH.keys():; raise ValidationError(""""""Requested CORL method lesser '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta_wfn_lesser)). # Establish method for delta correction energy; if 'delta_wfn' in kwargs:; do_delta = True; cbs_delta_wfn = kwargs['delta_wfn'].lower(); if cbs_delta_wfn not in VARH.keys():; raise ValidationError(""""""Requested DELTA method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta_wfn)). cbs_delta_wfn_lesser = kwargs.get('delta_wfn_lesser', cbs_corl_wfn).lower(); if cbs_delta_wfn_lesser not in VARH.keys():; raise ValidationErro",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver_cbs.html:31333,energy,energy,31333,psi4manual/1.1.0/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver_cbs.html,1,['energy'],['energy']
Energy Efficiency,"""""Wrapper complete_basis_set is unhappy to be calling function '%s' instead of 'energy'."""""" % ptype). optstash = p4util.OptionsState(; ['BASIS'],; ['WFN'],; ['WRITER_FILE_LABEL']). # Define some quantum chemical knowledge, namely what methods are subsumed in others. do_scf = True; do_corl = False; do_delta = False; do_delta2 = False; do_delta3 = False; do_delta4 = False; do_delta5 = False. user_writer_file_label = psi4.get_global_option('WRITER_FILE_LABEL'). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', psi4.get_active_molecule()); molecule.update_geometry(); molstr = molecule.create_psi4_string_from_molecule(); natom = molecule.natom(). # Establish method for reference energy; cbs_scf_wfn = kwargs.pop('scf_wfn', 'hf').lower(). if do_scf:; if cbs_scf_wfn not in VARH.keys():; raise ValidationError(""""""Requested SCF method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_scf_wfn)). # Establish method for correlation energy; cbs_corl_wfn = kwargs.pop('corl_wfn', '').lower(); if cbs_corl_wfn:; do_corl = True. if do_corl:; if cbs_corl_wfn not in VARH.keys():; raise ValidationError(""""""Requested CORL method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_corl_wfn)). cbs_corl_wfn_lesser = kwargs.get('corl_wfn_lesser', cbs_scf_wfn).lower(); if cbs_corl_wfn_lesser not in VARH.keys():; raise ValidationError(""""""Requested CORL method lesser '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta_wfn_lesser)). # Establish method for delta correction energy; if 'delta_wfn' in kwargs:; do_delta = True; cbs_delta_wfn = kwargs['delta_wfn'].lower(); if cbs_delta_wfn not in VARH.keys():; raise ValidationError(""""""Requested DELTA method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta_wfn)). cbs_delta_wfn_lesser = kwargs.get('delta_wfn_lesser', cbs_corl_wfn).lower(); if cbs_delta_wfn_lesser not in VARH.keys():; raise ValidationErro",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:30980,energy,energy,30980,psi4manual/1.0.0/_modules/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html,1,['energy'],['energy']
Energy Efficiency,""", [HOMO]); PsiMod.set_global_option(""FRAC_VAL"", [occ]) . E = energy('scf'); C = 1; if (E == 0.0):; E = PsiMod.get_variable('SCF ITERATION ENERGY'); C = 0. if (HOMO > 0):; ref = PsiMod.wavefunction(); eps = ref.epsilon_a(); potentials.append(eps[HOMO-1]); else:; ref = PsiMod.wavefunction(); eps = ref.epsilon_b(); potentials.append(eps[-HOMO-1]). Ns.append(Nintegral + occ - 1.0); energies.append(E); convs.append(C). PsiMod.set_global_option(""FRAC_START"", 2); PsiMod.set_global_option(""FRAC_LOAD"", True); PsiMod.set_global_option(""FRAC_DIIS"", frac_diis); PsiMod.set_global_option(""GUESS"", ""READ""). # Set the next charge/mult; mol.set_molecular_charge(charge) ; mol.set_multiplicity(mult). # Determine HOMO; ref = PsiMod.wavefunction(); eps_a = ref.epsilon_a(); eps_b = ref.epsilon_b(); if (Na == Nb):; HOMO = -Nb; elif (Nb == 0):; HOMO = Na; else:; E_a = eps_a[int(Na - 1)] ; E_b = eps_b[int(Nb - 1)] ; if (E_a >= E_b):; HOMO = Na; else: ; HOMO = -Nb. stats.append('\t%6d %6d %6d %6d %6d %6d\n' %(Nintegral-1, Na, Nb, charge, mult, HOMO)). if (HOMO > 0):; Na = Na - 1; else:; Nb = Nb - 1; charge = charge + 1; mult = Na - Nb + 1; ; PsiMod.set_global_option(""DF_INTS_IO"", ""NONE""). # => Print the results out <= #; E = {}; PsiMod.print_out('\n ==> Fractional Occupation Nuke Results <==\n\n'); PsiMod.print_out('\t%-11s %-24s %-24s %11s\n' %('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(len(Ns)):; PsiMod.print_out('\t%11.3E %24.16E %24.16E %11d\n' % (Ns[k], energies[k], potentials[k], convs[k])); E[Ns[k]] = energies[k]. PsiMod.print_out('\n'); PsiMod.print_out('\t%6s %6s %6s %6s %6s %6s\n' %('N', 'Na', 'Nb', 'Charge', 'Mult', 'HOMO')); for line in stats: ; PsiMod.print_out(line). PsiMod.print_out('\n\t""You shoot a nuke down a bug hole, you got a lot of dead bugs""\n'); PsiMod.print_out('\t\t\t-Starship Troopers\n'). # Drop the files out; fh = open(traverse_filename, 'w'); fh.write('\t%-11s %-24s %-24s %11s\n' %('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(len(N",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/frac.html:9586,charge,charge,9586,psi4manual/4.0b4/_modules/frac.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/frac.html,1,['charge'],['charge']
Energy Efficiency,""": ""boolean""; },; ""error_correction"": {; ""title"": ""Error Correction"",; ""description"": ""Policies for error correction"",; ""allOf"": [; {; ""$ref"": ""#/definitions/ErrorCorrectionProtocol""; }; ]; },; ""native_files"": {; ""description"": ""Policies for keeping processed files from the computation"",; ""default"": ""none"",; ""allOf"": [; {; ""$ref"": ""#/definitions/NativeFilesProtocolEnum""; }; ]; }; },; ""additionalProperties"": false; },; ""AtomicComputer"": {; ""title"": ""AtomicComputer"",; ""description"": ""Computer for analytic single-geometry computations."",; ""type"": ""object"",; ""properties"": {; ""molecule"": {; ""title"": ""Molecule"",; ""description"": ""The molecule to use in the computation.""; },; ""basis"": {; ""title"": ""Basis"",; ""description"": ""The quantum chemistry basis set to evaluate (e.g., 6-31g, cc-pVDZ, ...)."",; ""type"": ""string""; },; ""method"": {; ""title"": ""Method"",; ""description"": ""The quantum chemistry method to evaluate (e.g., B3LYP, MP2, ...)."",; ""type"": ""string""; },; ""driver"": {; ""description"": ""The resulting type of computation: energy, gradient, hessian, properties.Note for finite difference that this should be the target driver, not the means driver."",; ""allOf"": [; {; ""$ref"": ""#/definitions/DriverEnum""; }; ]; },; ""keywords"": {; ""title"": ""Keywords"",; ""description"": ""The keywords to use in the computation."",; ""type"": ""object""; },; ""protocols"": {; ""title"": ""Protocols"",; ""description"": ""Output modifications."",; ""default"": {; ""stdout"": true; },; ""anyOf"": [; {; ""$ref"": ""#/definitions/AtomicResultProtocols""; },; {; ""type"": ""object""; }; ]; },; ""tag"": {; ""title"": ""Tag"",; ""description"": ""The tags to pass along to compute managers."",; ""default"": ""*"",; ""type"": ""string""; },; ""priority"": {; ""title"": ""Priority"",; ""description"": ""The priority of a Task; higher priority will be pulled first. {high:2, normal:1, low:0}"",; ""default"": 1,; ""type"": ""string""; },; ""owner_group"": {; ""title"": ""Owner Group"",; ""description"": ""group in the chown sense."",; ""type"": ""string""; },; ""computed"": {; ""title"": ""Computed"",",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/cbs.html:37339,energy,energy,37339,psi4manual/1.8.x/cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/cbs.html,6,['energy'],['energy']
Energy Efficiency,"""; # lowername = name.lower(); # kwargs = kwargs_lower(kwargs); #; # # Run detci calculation and collect conventional quantities; # energy('mp3', **kwargs); # e_scf = psi4.get_variable('SCF TOTAL ENERGY'); # ce_mp2 = psi4.get_variable('MP2 CORRELATION ENERGY'); # ce_mp3 = psi4.get_variable('MP3 CORRELATION ENERGY'); # e_mp2 = e_scf + ce_mp2; # e_mp3 = e_scf + ce_mp3; #; # # Compute quantities particular to MP2.5; # ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); # e_mp25 = e_scf + ce_mp25; # psi4.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25); # psi4.set_variable('MP2.5 TOTAL ENERGY', e_mp25); # psi4.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); # psi4.set_variable('CURRENT ENERGY', e_mp25); #; # # build string of title banner and print results; # banners = ''; # banners += """"""psi4.print_out('\\n')\n""""""; # banners += """"""banner(' MP2.5 ')\n""""""; # banners += """"""psi4.print_out('\\n')\n\n""""""; # exec(banners); #; # tables = ''; # tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); # tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); # tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); # tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); # tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); # tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); # tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); # psi4.print_out(tables); #; # return e_mp25. # A direct translation of a plugin input file into a function call. Function calls are the only; # way to call plugins in sow/reap mode for db(), opt(), etc. This isn't best practices; # but is an example of what to do for a more complicated procedure where different options; # are set for different qc steps.; #def run_plugin_omega(name, **kwargs):; # r""""""Function encoding sequence of PSI module and plugin calls, as well; # as typical options, to access Rob Parrish's omega plugin.; #; # >>> energy('plugin_omega'); #; # """"""; # lowername = name.lower(); # kwargs = p4util.kwargs_lower(kwar",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/aliases.html:7801,energy,energy,7801,psi4manual/4.0b5/_modules/aliases.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/aliases.html,1,['energy'],['energy']
Energy Efficiency,"""; f""running adcc: '{ex}' ({type(ex).__name__})""); core.print_out(""\n""). # TODO Should a non-converged calculation throw?. #; # Interpret results; #; # Note: This wavefunction is not consistent ... the density; # is e.g. not the proper one (i.e. not the MP(n) one); adc_wfn = core.Wavefunction(ref_wfn.molecule(), ref_wfn.basisset()); adc_wfn.shallow_copy(ref_wfn); adc_wfn.set_reference_wavefunction(ref_wfn); adc_wfn.set_name(name); adc_wfn.set_module(""adcc""). # MP(3) energy for CVS-ADC(3) calculations is still a missing feature in adcc; # ... we store this variant here to be able to fall back to MP(2) energies.; is_cvs_adc3 = state.method.level >= 3 and state.ground_state.has_core_occupied_space. # Ground-state energies; mp = state.ground_state; mp_energy = mp.energy(state.method.level if not is_cvs_adc3 else 2); mp_corr = 0.0; if state.method.level > 1:; core.print_out(""Ground state energy breakdown:\n""); core.print_out("" Energy SCF {0:15.8g} [Eh]\n"".format(ref_wfn.energy())); for level in range(2, state.method.level + 1):; if level >= 3 and is_cvs_adc3:; continue; energy = mp.energy_correction(level); mp_corr += energy; adc_wfn.set_variable(f""MP{level} CORRELATION ENERGY"", energy); adc_wfn.set_variable(f""MP{level} TOTAL ENERGY"", mp.energy(level)); core.print_out(f"" Energy correlation MP{level} {energy:15.8g} [Eh]\n""); core.print_out("" Energy total {0:15.8g} [Eh]\n"".format(mp_energy)); adc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", mp_corr) # P::e ADC; adc_wfn.set_variable(""CURRENT ENERGY"", mp_energy) # P::e ADC. # Set results of excited-states computation; # TODO Does not work: Can't use strings; # adc_wfn.set_variable(""excitation kind"", state.kind); adc_wfn.set_variable(""number of excited states"", len(state.excitation_energy)); adc_wfn.set_variable(""ADC ITERATIONS"", state.n_iter) # P::e ADC; methods = [name.upper(), 'ADC']; for excitation in state.excitations:; root_index = excitation.index + 1; for method in methods:; adc_wfn.set_variable(f""{method} ROOT 0 (A",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:117947,energy,energy,117947,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,5,['energy'],['energy']
Energy Efficiency,"""; oe = core.OEProp(wfn); if 'title' in kwargs:; oe.set_title(kwargs['title']); for prop in args:; oe.add(prop); ; # If we're doing MBIS, we want the free-atom volumes; # in order to compute volume ratios,; # but only if we're calling oeprop as the whole molecule; free_atom = kwargs.get('free_atom',False); if ""MBIS_VOLUME_RATIOS"" in prop.upper() and not free_atom:; core.print_out("" Computing free-atom volumes\n""); free_atom_volumes(wfn) . oe.compute(). [docs]def cubeprop(wfn, **kwargs):; """"""Evaluate properties on a grid and generate cube files. .. versionadded:: 0.5; *wfn* parameter passed explicitly. :returns: None. :type wfn: :py:class:`~psi4.core.Wavefunction`; :param wfn: set of molecule, basis, orbitals from which to generate cube files. :examples:. >>> # [1] Cube files for all orbitals; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> cubeprop(wfn). >>> # [2] Cube files for density (alpha, beta, total, spin) and four orbitals; >>> # (two alpha, two beta); >>> set cubeprop_tasks ['orbitals', 'density']; >>> set cubeprop_orbitals [5, 6, -5, -6]; >>> E, wfn = energy('scf', return_wfn=True); >>> cubeprop(wfn). """"""; # By default compute the orbitals; if not core.has_global_option_changed('CUBEPROP_TASKS'):; core.set_global_option('CUBEPROP_TASKS', ['ORBITALS']). if ((core.get_global_option('INTEGRAL_PACKAGE') == 'ERD') and ('ESP' in core.get_global_option('CUBEPROP_TASKS'))):; raise ValidationError('INTEGRAL_PACKAGE ERD does not play nicely with electrostatic potential, so stopping.'). cp = core.CubeProperties(wfn); cp.compute_properties(). [docs]def set_memory(inputval: Union[str, int, float], execute: bool = True, quiet: bool = False) -> int:; """"""Function to reset the total memory allocation. Takes memory value; *inputval* as type int, float, or str; int and float are taken literally; as bytes to be set, string taken as a unit-containing value (e.g., 30 mb); which is case-insensitive. Set *execute* to False to interpret *inputval*; without setting in Psi4 core.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/util.html:2933,energy,energy,2933,psi4manual/1.6.x/_modules/psi4/driver/p4util/util.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/util.html,1,['energy'],['energy']
Energy Efficiency,"""De=%f"" % D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module, and PSI Variables by Alpha defines them. These can be; accessed through the get_variable() function. For example, after; performing a density fitted MP2 computation, both the spin component; scaled energy and the unscaled MP2 energy are made available:; 1; 2e_mp2 = get_variable('MP2 TOTAL ENERGY'); e_scs_mp2 = get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; are cleared at the start of each energy(), etc. in an input; file by clean_variables().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the; last will include SCF TOTAL ENERGY but not; FCI TOTAL ENERGY.; The entire dictionary of PSI variables can be obtained through; get_variables(). Return Values¶; Most of the usual user computation functions (i.e.,; energy(), optimize(), and; frequency()) return simply the current total energy.; Consult the descriptions of other functions in Psithon Functions: Invoking a Calculation for; what quantities they return and for what data structures they make; available for post-processing. Many users need only deal with the simple return; form for the computation functions.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11# E is total energy float; # G is gradient array; # H is hessian array; # wfn is class instance with many computational details. # simple returns; E = energy(...); E = optimize(...); E = f",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psithoninput-1.html:9983,energy,energy,9983,psi4manual/1.1.0/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psithoninput-1.html,6,['energy'],['energy']
Energy Efficiency,"""Derivative method 'name' %s and derivative level 'dertype' %s are not available.%s""""""; % (method_name, str(dertype), alternatives)). return dertype. def _energy_is_invariant(gradient, stationary_criterion=1.e-2):; """"""Polls options and probes `gradient` to return whether current method; and system expected to be invariant to translations and rotations of; the coordinate system. """"""; stationary_point = gradient.rms() < stationary_criterion # 1.e-2 pulled out of a hat. efp = core.get_active_efp(); efp_present = efp.nfragments() > 0. translations_projection_sound = (not core.get_option('SCF', 'EXTERN') and; not core.get_option('SCF', 'PERTURB_H') and; not efp_present); rotations_projection_sound = (translations_projection_sound and; stationary_point). return translations_projection_sound, rotations_projection_sound. [docs]def energy(name, **kwargs):; r""""""Function to compute the single-point electronic energy. :returns: *float* |w--w| Total electronic energy in Hartrees. SAPT & EFP return interaction energy. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY <CURRENTENERGY>`; * :psivar:`CURRENT REFERENCE ENERGY <CURRENTREFERENCEENERGY>`; * :psivar:`CURRENT CORRELATION ENERGY <CURRENTCORRELATIONENERGY>`. :type name: string; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type restart_file: string; :param restart_file: ``['file.1, file.32]`` || ``./",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html:4819,energy,energy,4819,psi4manual/1.2.1/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html,1,['energy'],['energy']
Energy Efficiency,"""GUESS"", ""READ""); p4util.copy_file_to_scratch(read180, 'psi', 'ot', 180). molecule.set_molecular_charge(charge1); molecule.set_multiplicity(mult1); psi4.print_out(""""""\n\t==> IP Fitting SCF: Cation, Right Endpoint <==\n""""""); E1r = energy('scf', molecule=molecule, **kwargs); psi4.IO.change_file_namespace(180, ""ot"", ""cation""). IPr = E1r - E0r;; kIPr = -E_HOMOr;; delta_r = IPr - kIPr;. if IPr > kIPr:; message = (""""""\n***IP Fitting Error: Right Omega limit should have kIP > IP""""""); raise ValidationError(message). omegas.append(omega_r); types.append('Right Limit'); E0s.append(E0r); E1s.append(E1r); IPs.append(IPr); kIPs.append(kIPr). # Use previous orbitals from here out; psi4.set_global_option(""GUESS"", ""READ""). # Left endpoint; psi4.set_global_option('DFT_OMEGA', omega_l). # Neutral; psi4.IO.change_file_namespace(180, ""neutral"", ""ot""); molecule.set_molecular_charge(charge0); molecule.set_multiplicity(mult0); psi4.print_out(""""""\n\t==> IP Fitting SCF: Neutral, Left Endpoint <==\n""""""); E0l, wfn = energy('scf', return_wfn=True, molecule=molecule, **kwargs); eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); E_HOMO = 0.0; if Nb == 0:; E_HOMO = eps_a[int(Na - 1)]; else:; E_a = eps_a[int(Na - 1)]; E_b = eps_b[int(Nb - 1)]; if E_a >= E_b:; E_HOMO = E_a; else:; E_HOMO = E_b; E_HOMOl = E_HOMO; psi4.IO.change_file_namespace(180, ""ot"", ""neutral""). # Cation; psi4.IO.change_file_namespace(180, ""cation"", ""ot""); molecule.set_molecular_charge(charge1); molecule.set_multiplicity(mult1); psi4.print_out(""""""\n\t==> IP Fitting SCF: Cation, Left Endpoint <==\n""""""); E1l = energy('scf', molecule=molecule, **kwargs); psi4.IO.change_file_namespace(180, ""ot"", ""cation""). IPl = E1l - E0l; kIPl = -E_HOMOl; delta_l = IPl - kIPl. if IPl < kIPl:; message = (""""""\n***IP Fitting Error: Left Omega limit should have kIP < IP""""""); raise ValidationError(message). omegas.append(omega_l); types.append('Left Limit'); E0s.append(E0l); E1s.append(E1l); IPs.append(IPl); kIPs.append(kIPl). converged = False; repeat_l =",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/frac.html:15038,energy,energy,15038,psi4manual/1.0.0/_modules/frac.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/frac.html,1,['energy'],['energy']
Energy Efficiency,"""_find_derivative_type: ptype must either be gradient or hessian.""). dertype = ""(auto)"". # If user type is None, try to find the highest derivative; if user_dertype is None:; if (ptype == 'hessian') and (method_name in procedures['hessian']):; dertype = 2; # Will need special logic if we ever have managed Hessians; elif method_name in procedures['gradient']:; dertype = 1; if procedures['gradient'][method_name].__name__.startswith('select_'):; try:; procedures['gradient'][method_name](method_name, probe=True); except ManagedMethodError:; dertype = 0; elif method_name in procedures['energy']:; dertype = 0; else:; # Quick sanity check. Only *should* be able to be None or int, but hey, kids today...; if not isinstance(user_dertype, int):; raise ValidationError(""_find_derivative_type: user_dertype should only be None or int!""); dertype = user_dertype. # Summary validation; if (dertype == 2) and (method_name in procedures['hessian']):; pass; elif (dertype == 1) and (method_name in procedures['gradient']):; pass; elif (dertype == 0) and (method_name in procedures['energy']):; pass; else:; alternatives = ''; alt_method_name = p4util.text.find_approximate_string_matches(method_name, procedures['energy'].keys(), 2); if len(alt_method_name) > 0:; alternatives = """""" Did you mean? %s"""""" % (' '.join(alt_method_name)). raise ValidationError(""""""Derivative method 'name' %s and derivative level 'dertype' %s are not available.%s""""""; % (method_name, str(dertype), alternatives)). return dertype. [docs]def energy(name, **kwargs):; r""""""Function to compute the single-point electronic energy. :returns: *float* |w--w| Total electronic energy in Hartrees. SAPT & EFP return interaction energy. :returns: (*float*, :ref:`Wavefunction<sec:psimod_Wavefunction>`) |w--w| energy and wavefunction when **return_wfn** specified. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY <CURRENTENERGY>`; * :psivar:`CURRENT REFERENCE ENERGY <CURRENTREFERENCEENERGY>`; * :psivar:`CURRENT CORRELATIO",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver.html:3121,energy,energy,3121,psi4manual/1.0.0/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver.html,1,['energy'],['energy']
Energy Efficiency,"""delta2""). return _validate_cbs_inputs(cbs_metadata, molecule). ###################################; ## Start of Complete Basis Set ##; ###################################. [docs]; def cbs(func, label, **kwargs):; r""""""Function to define a multistage energy method from combinations of; basis set extrapolations and delta corrections and condense the; components into a minimum number of calculations. :aliases: complete_basis_set(). :returns: (*float*) -- Total electronic energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CBS TOTAL ENERGY`; * :psivar:`CBS REFERENCE ENERGY`; * :psivar:`CBS CORRELATION ENERGY`; * :psivar:`CURRENT ENERGY`; * :psivar:`CURRENT REFERENCE ENERGY`; * :psivar:`CURRENT CORRELATION ENERGY`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - No way to tell function to boost fitting basis size for all calculations. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in several; sequential stages (scf, corl, delta1, delta2, ... ) covering treatment; of the reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction, etc.. Each is activated by its; stage_wfn keyword, or as a field in the ```cbs_metadata``` list, and is only; allowed if all preceding stages are active. .. include:: /cbs_eqn.rst. * Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy. The cbs() function requires, at a minimum, ``name='scf'`` and ``scf_basis``; keywords to be specified for reference-step only jobs and ``name`` and; ``corl_basis`` keywords for correlated jobs. The following energy methods have been set up for cbs(). .. hlist::; :columns: 5. * scf; * hf; * mp2; * mp2.5; * mp3; * mp4(sdq); * mp4; * mp\ *n*; * omp2; * omp2.5; * omp3; * olccd; * lccd; * lccsd; * cepa(0);",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:22791,energy,energy,22791,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,3,['energy'],['energy']
Energy Efficiency,"""displacements""]) + 1. print("""""" %d displacements needed."""""" % ndisp). wfn = _process_displacement(gradient, lowername, molecule, findif_meta_dict[""reference""], 1, ndisp,; **kwargs); var_dict = core.variables(); # ensure displacement calculations do not use restart_file orbitals.; kwargs.pop('restart_file', None). for n, displacement in enumerate(findif_meta_dict[""displacements""].values(), start=2):; _process_displacement(; gradient, lowername, molecule, displacement, n, ndisp, write_orbitals=False, **kwargs). # Reset variables; for key, val in var_dict.items():; core.set_variable(key, val). # Assemble Hessian from gradients; # Final disp is undisp, so wfn has mol, G, H general to freq calc; H = driver_findif.assemble_hessian_from_gradients(findif_meta_dict, irrep); wfn.set_hessian(core.Matrix.from_array(H)); wfn.set_gradient(G0). # Explicitly set the current energy..; core.set_variable('CURRENT ENERGY', findif_meta_dict[""reference""][""energy""]); wfn.set_variable('CURRENT ENERGY', findif_meta_dict[""reference""][""energy""]). core.set_global_option(""PARENT_SYMMETRY"", """"); optstash.restore(); optstash_conv.restore(). else:; core.print_out(""""""hessian() will perform frequency computation by finite difference of analytic energies.\n""""""). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash.restore(); optstash_conv.restore(); optstash_conv = driver_util._set_convergence_criterion('energy', lowername, 10, 11, 10, 11, 10). # Obtain list of displacements; findif_meta_dict = driver_findif.hessian_from_energies_geometries(molecule, irrep). # Record undisplaced symmetry for projection of diplaced point groups; core.set_global_option(""PARENT_SYMMETRY"", molecule.schoenflies_symbol()). ndisp = len(findif_meta_dict[""displacements""]) + 1. print(' %d displacements needed.' % ndisp). wfn = _process_displacement(energy, lowername, molecule, findif_meta_dict[""reference""], 1, ndisp,; **kwargs); var_dict = core.variables(). for n, di",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:80071,energy,energy,80071,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,1,['energy'],['energy']
Energy Efficiency,"""mdi_run"",; ""MDIEngine"",; ]. import numpy as np; import qcelemental as qcel. import psi4. _have_mdi = False; try:; from mdi import MDI_Init, MDI_MPI_get_world_comm, MDI_Accept_Communicator, \; MDI_Send, MDI_Recv, MDI_Recv_Command, MDI_INT, MDI_DOUBLE, \; MDI_Register_Node, MDI_Register_Command; _have_mdi = True; except ImportError:; pass. try:; from mpi4py import MPI; use_mpi4py = True; except ImportError:; use_mpi4py = False. class MDIEngine():; def __init__(self, scf_method: str, **kwargs):; """""" Initialize an MDIEngine object for communication with MDI (MolSSI driver interface). Parameters; ----------; scf_method; Method (SCF or post-SCF) used when calculating energies or gradients.; molecule; The target molecule, if not the last molecule defined.; kwargs; Any additional arguments to pass to :func:`psi4.driver.energy` or; :func:`psi4.driver.gradient` computation. """""". # Method used when the SCF command is received; self.scf_method = scf_method. # Additional arguments for energy, gradient, or optimization calculations; self.kwargs = kwargs. # Molecule all MDI operations are performed on; input_molecule = kwargs.pop('molecule', psi4.core.get_active_molecule()); _ini_cart = getattr(input_molecule, ""_initial_cartesian"", None); self.molecule = input_molecule.clone(); if _ini_cart:; self.molecule._initial_cartesian = _ini_cart; psi4.core.set_active_molecule(self.molecule). # Most recent SCF energy; self.energy = 0.0. # Variables used when MDI sets a lattice of point charges; self.nlattice = 0 # number of lattice point charges; self.clattice = [] # list of lattice coordinates; self.lattice = [] # list of lattice charges; self.lattice_field = psi4.QMMMbohr() # Psi4 chargefield. # MPI variables; self.mpi_world = None; self.world_rank = 0. # Flag for if a lattice of point charges has been set; self.set_lattice = False. # Get correct intra-code MPI communicator; if use_mpi4py:; self.mpi_world = MDI_MPI_get_world_comm(); self.world_rank = self.mpi_world.Get_rank(). # Psi4 does",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html:2252,energy,energy,2252,psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html,1,['energy'],['energy']
Energy Efficiency,"""mdi_run"",; ""MDIEngine"",; ]. import numpy as np; import qcelemental as qcel. import psi4. _have_mdi = False; try:; from mdi import MDI_Init, MDI_MPI_get_world_comm, MDI_Accept_Communicator, \; MDI_Send, MDI_Recv, MDI_Recv_Command, MDI_INT, MDI_DOUBLE, \; MDI_Register_Node, MDI_Register_Command; _have_mdi = True; except ImportError:; pass. try:; from mpi4py import MPI; use_mpi4py = True; except ImportError:; use_mpi4py = False. class MDIEngine():; def __init__(self, scf_method: str, **kwargs):; """""" Initialize an MDIEngine object for communication with MDI (MolSSI driver interface). Parameters; ----------; scf_method; Method (SCF or post-SCF) used when calculating energies or gradients.; molecule; The target molecule, if not the last molecule defined.; kwargs; Any additional arguments to pass to :func:`psi4.driver.energy` or; :func:`psi4.driver.gradient` computation. """""". # Method used when the SCF command is received; self.scf_method = scf_method. # Additional arguments for energy, gradient, or optimization calculations; self.kwargs = kwargs. # Molecule all MDI operations are performed on; input_molecule = kwargs.pop('molecule', psi4.core.get_active_molecule()); self.molecule = input_molecule.clone(); psi4.core.set_active_molecule(self.molecule). # Most recent SCF energy; self.energy = 0.0. # Variables used when MDI sets a lattice of point charges; self.nlattice = 0 # number of lattice point charges; self.clattice = [] # list of lattice coordinates; self.lattice = [] # list of lattice charges; self.lattice_field = psi4.QMMMbohr() # Psi4 chargefield. # MPI variables; self.mpi_world = None; self.world_rank = 0. # Flag for if a lattice of point charges has been set; self.set_lattice = False. # Get correct intra-code MPI communicator; if use_mpi4py:; self.mpi_world = MDI_MPI_get_world_comm(); self.world_rank = self.mpi_world.Get_rank(). # Psi4 does not currently support multiple MPI ranks; if self.mpi_world.Get_size() != 1:; MPI.COMM_WORLD.Abort(). # Accept a communicator",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/mdi_engine.html:2250,energy,energy,2250,psi4manual/1.7.x/_modules/psi4/driver/mdi_engine.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/mdi_engine.html,1,['energy'],['energy']
Energy Efficiency,"""ret_{ptype}""]. return results. [docs]class ManyBodyComputer(BaseComputer):; # user kwargs (all but levels become fields); # ------------------------------------------; # * bsse_type; # * levels; # * max_nbody; # * molecule -- general; # * return_total_data; # * return_wfn -- general. # fields set in construction; # --------------------------; # * nfragments (<- max_frag) -- from molecule. # fields set in task_planner; # --------------------------; # * max_nbody -- from levels; # * nbodies_per_mc_level -- from levels. # TODO perhaps rework levels kwarg so that it's processed in class init into nbodies_per_mc_level. Right now, levels resets max_nbody.; # TODO also, perhaps change nbodies_per_mc_level into dict of lists so that pos'n/label indexing coincides. molecule: Any = Field(..., description=""The target molecule, if not the last molecule defined.""); basis: str = ""(auto)""; method: str = ""(auto)""; driver: DriverEnum = Field(..., description=""The computation driver; i.e., energy, gradient, hessian.""); keywords: Dict[str, Any] = Field({}, description=""The computation keywords/options.""). bsse_type: List[BsseEnum] = Field([BsseEnum.cp], description=""Requested BSSE treatments. First in list determines which interaction or total energy/gradient/Hessian returned.""); nfragments: int = Field(-1, description=""Number of distinct fragments comprising full molecular supersystem."") # formerly max_frag; max_nbody: int = Field(-1, description=""Maximum number of bodies to include in the many-body treatment. Possible: max_nbody <= nfragments. Default: max_nbody = nfragments.""). nbodies_per_mc_level: List[List[Union[int, Literal[""supersystem""]]]] = Field([], description=""Distribution of active n-body levels among model chemistry levels. All bodies in range [1, self.max_nbody] must be present exactly once. Number of items in outer list is how many different modelchems. Each inner list specifies what n-bodies to be run at the corresponding modelchem (e.g., `[[1, 2]]` has max_nbody=2 ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html:31944,energy,energy,31944,psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html,2,['energy'],['energy']
Energy Efficiency,"# * return_total_data; # * return_wfn -- general. # fields set in construction; # --------------------------; # * nfragments (<- max_frag) -- from molecule. # fields set in task_planner; # --------------------------; # * max_nbody -- from levels; # * nbodies_per_mc_level -- from levels. # TODO perhaps rework levels kwarg so that it's processed in class init into nbodies_per_mc_level. Right now, levels resets max_nbody.; # TODO also, perhaps change nbodies_per_mc_level into dict of lists so that pos'n/label indexing coincides. molecule: Any = Field(..., description=""The target molecule, if not the last molecule defined.""); basis: str = ""(auto)""; method: str = ""(auto)""; driver: DriverEnum = Field(..., description=""The computation driver; i.e., energy, gradient, hessian.""); keywords: Dict[str, Any] = Field({}, description=""The computation keywords/options.""). bsse_type: List[BsseEnum] = Field([BsseEnum.cp], description=""Requested BSSE treatments. First in list determines which interaction or total energy/gradient/Hessian returned.""); nfragments: int = Field(-1, description=""Number of distinct fragments comprising full molecular supersystem."") # formerly max_frag; max_nbody: int = Field(-1, description=""Maximum number of bodies to include in the many-body treatment. Possible: max_nbody <= nfragments. Default: max_nbody = nfragments.""). nbodies_per_mc_level: List[List[Union[int, Literal[""supersystem""]]]] = Field([], description=""Distribution of active n-body levels among model chemistry levels. All bodies in range [1, self.max_nbody] must be present exactly once. Number of items in outer list is how many different modelchems. Each inner list specifies what n-bodies to be run at the corresponding modelchem (e.g., `[[1, 2]]` has max_nbody=2 and 1-body and 2-body contributions computed at the same level of theory; `[[1], [2]]` has max_nbody=2 and 1-body and 2-body contributions computed at different levels of theory. An entry 'supersystem' means all higher order n-body effe",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html:32202,energy,energy,32202,psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html,5,['energy'],['energy']
Energy Efficiency,"# Number of equivalent atoms per unique atom (length nunique); self.nequiv = 0; # Equivalent atom mapping array (length 1st dim nunique); self.equiv = 0; # Atom to unique atom mapping array (length natom); self.PYatom_to_unique = 0. if psi4molstr:; self.create_molecule_from_string(psi4molstr). # <<< Simple Methods for Basic Molecule Information >>>. [docs] def name(self):; """"""Get molecule name. >>> print H2OH2O.name(); water_dimer. """"""; return self.PYname. [docs] def set_name(self, name):; """"""Set molecule name. >>> H2OH2O.set_name('water_dimer'). """"""; self.PYname = name. [docs] def natom(self):; """"""Number of atoms. >>> print H2OH2O.natom(); 6. """"""; return len(self.atoms). [docs] def nallatom(self):; """"""Number of all atoms (includes dummies). >>> print H2OH2O.nallatom(); 7. """"""; return len(self.full_atoms). [docs] def molecular_charge(self):; """"""Gets the molecular charge. >>> print H2OH2O.molecular_charge(); -2. """"""; return self.PYmolecular_charge. [docs] def set_molecular_charge(self, charge):; """"""Sets the molecular charge. >>> H2OH2O.set_molecular_charge(-2). """"""; self.PYcharge_specified = True; self.PYmolecular_charge = charge. [docs] def charge_specified(self):; """"""Whether the charge was given by the user. >>> print H2OH2O.charge_specified(); True. """"""; return self.PYcharge_specified. [docs] def multiplicity(self):; """"""Get the multiplicity (defined as 2Ms + 1). >>> print H2OH2O.multiplicity(). """"""; return self.PYmultiplicity. [docs] def set_multiplicity(self, mult):; """"""Sets the multiplicity (defined as 2Ms + 1). >>> H2OH2O.set_multiplicity(3). """"""; self.PYmultiplicity_specified = True; self.PYmultiplicity = mult. [docs] def multiplicity_specified(self):; """"""Whether the multiplicity was given by the user. >>> print H2OH2O.multiplicity_specified(); True. """"""; return self.PYmultiplicity_specified. [docs] def units(self):; """"""Gets the geometry units. >>> print H2OH2O.units(); Angstrom. """"""; return self.PYunits. [docs] def set_units(self, units):; """"""Sets the geometr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:5902,charge,charge,5902,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,2,['charge'],['charge']
Energy Efficiency,"# [2] Frequency calculation for b2 modes through finite difference of gradients; >>> frequencies('scf', dertype=1, irrep=4). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Make sure the molecule the user provided is the active one; if ('molecule' in kwargs):; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); PsiMod.set_global_option('BASIS', PsiMod.get_global_option('BASIS')). types = ['energy', 'gradient', 'hessian']. dertype = 2; if ('dertype' in kwargs):; dertype = kwargs['dertype']; if not (lowername in procedures[types[dertype]]):; print('Frequencies: dertype = %d for frequencies is not available, switching to automatic determination.' % dertype); dertype = -1. if 'irrep' in kwargs:; irrep = parse_cotton_irreps(kwargs['irrep']) - 1 # externally, A1 irrep is 1, internally 0; else:; irrep = -1 # -1 implies do all irreps. # By default, set func to the energy function; func = energy; func_existed = False; if 'func' in kwargs:; func = kwargs['func']; func_existed = True. if (not('dertype' in kwargs) or dertype == -1):; if lowername in procedures['hessian']:; dertype = 2; elif lowername in procedures['gradient']:; dertype = 1; else:; dertype = 0. # Does an analytic procedure exist for the requested method?; if (dertype == 2 and func_existed == False):; # We have the desired method. Do it.; procedures['hessian'][lowername](lowername, **kwargs); return PsiMod.reference_wavefunction().energy(); elif (dertype == 1 and func_existed == False):; # Ok, we're doing frequencies by gradients; info = 'Performing finite difference by gradient calculations'; print(info). func = procedures['gradient'][lowername]. # Obtain list of displacements; displacements = PsiMod.fd_geoms_freq_1(irrep). molecule.reinterpret_coordentry(False); molecule.fix_orientation(True); # Make a note of the undisplaced molecule's symmetry; PsiMod.set_parent_symmetry(molecule.schoenflies_symbol()). ndisp = len(displacem",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/driver.html:47585,energy,energy,47585,psi4manual/4.0b3/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/driver.html,2,['energy'],['energy']
Energy Efficiency,"# [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy('fci', ref_wfn=cisd_wfn). >>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""CCSD/cc-pV[DT]Z""). >>> # [7] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> energy(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). """"""; kwargs = p4util.kwargs_lower(kwargs). # Bounce to MDI if mdi kwarg; use_mdi = kwargs.pop('mdi', False); if use_mdi:; return mdi_run(name, **kwargs). core.print_out(""\nScratch directory: %s\n"" % core.IOManager.shared_object().get_default_path()). # Bounce to CP if bsse kwarg; if kwargs.get('bsse_type', None) is not None:; return driver_nbody.nbody_gufunc(energy, name, ptype='energy', **kwargs). # Bounce if name is function; if hasattr(name, '__call__'):; return name(energy, kwargs.pop('label', 'custom function'), ptype='energy', **kwargs). # Allow specification of methods to arbitrary order; lowername = name.lower(); lowername, level = driver_util.parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. # Bounce to CBS if ""method/basis"" name; if ""/"" in lowername:; return driver_cbs._cbs_gufunc(energy, name, ptype='energy', **kwargs). _filter_renamed_methods(""energy"", lowername). # Commit to procedures['energy'] call hereafter; return_wfn = kwargs.pop('return_wfn', False); core.clean_variables(). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). #for precallback in hooks['energy']['pre']:; # precallback(lowername, **kwargs). optstash = driver_util._set_convergence_criterion('energy', lowername, 6, 8, 6, 8, 6); optstash2 = p4util.Options",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:34230,energy,energy,34230,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,4,['energy'],['energy']
Energy Efficiency,"##########################. [docs]def cbs(func, label, **kwargs):; r""""""Function to define a multistage energy method from combinations of; basis set extrapolations and delta corrections and condense the; components into a minimum number of calculations. :aliases: complete_basis_set(). :returns: (*float*) -- Total electronic energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CBS TOTAL ENERGY`; * :psivar:`CBS REFERENCE ENERGY`; * :psivar:`CBS CORRELATION ENERGY`; * :psivar:`CURRENT ENERGY`; * :psivar:`CURRENT REFERENCE ENERGY`; * :psivar:`CURRENT CORRELATION ENERGY`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - No way to tell function to boost fitting basis size for all calculations. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in several; sequential stages (scf, corl, delta1, delta2, ... ) covering treatment; of the reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction, etc.. Each is activated by its; stage_wfn keyword, or as a field in the ```cbs_metadata``` list, and is only; allowed if all preceding stages are active. .. include:: /cbs_eqn.rst. * Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy. The cbs() function requires, at a minimum, ``name='scf'`` and ``scf_basis``; keywords to be specified for reference-step only jobs and ``name`` and; ``corl_basis`` keywords for correlated jobs. The following energy methods have been set up for cbs(). .. hlist::; :columns: 5. * scf; * hf; * mp2; * mp2.5; * mp3; * mp4(sdq); * mp4; * mp\ *n*; * omp2; * omp2.5; * omp3; * olccd; * lccd; * lccsd; * cepa(0); * cepa(1); * cepa(3); * acpf; * aqcc; * qcisd; * cc2; * ccsd; * fno-ccsd; * bccd; * cc3; * qcisd(t); * ccsd(t); * fno-ccsd(t); * bccd(t); * cisd;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:34964,energy,energy,34964,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,12,['energy'],['energy']
Energy Efficiency,"########################. [docs]; def cbs(func, label, **kwargs):; r""""""Function to define a multistage energy method from combinations of; basis set extrapolations and delta corrections and condense the; components into a minimum number of calculations. :aliases: complete_basis_set(). :returns: (*float*) -- Total electronic energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CBS TOTAL ENERGY`; * :psivar:`CBS REFERENCE ENERGY`; * :psivar:`CBS CORRELATION ENERGY`; * :psivar:`CURRENT ENERGY`; * :psivar:`CURRENT REFERENCE ENERGY`; * :psivar:`CURRENT CORRELATION ENERGY`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - No way to tell function to boost fitting basis size for all calculations. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in several; sequential stages (scf, corl, delta1, delta2, ... ) covering treatment; of the reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction, etc.. Each is activated by its; stage_wfn keyword, or as a field in the ```cbs_metadata``` list, and is only; allowed if all preceding stages are active. .. include:: /cbs_eqn.rst. * Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy. The cbs() function requires, at a minimum, ``name='scf'`` and ``scf_basis``; keywords to be specified for reference-step only jobs and ``name`` and; ``corl_basis`` keywords for correlated jobs. The following energy methods have been set up for cbs(). .. hlist::; :columns: 5. * scf; * hf; * mp2; * mp2.5; * mp3; * mp4(sdq); * mp4; * mp\ *n*; * omp2; * omp2.5; * omp3; * olccd; * lccd; * lccsd; * cepa(0); * cepa(1); * cepa(3); * acpf; * aqcc; * qcisd; * cc2; * ccsd; * fno-ccsd; * bccd; * cc3; * qcisd(t); * ccsd(t); * fno-ccsd(t); * bccd(t); * cisd;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:22923,energy,energy,22923,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,9,['energy'],['energy']
Energy Efficiency,"#; """"""Support for using Psi4 as an MDI engine.; For details regarding MDI, see https://molssi.github.io/MDI_Library/html/index.html. """""". __all__ = [; ""mdi_init"",; ""mdi_run"",; ""MDIEngine"",; ]. import numpy as np; import qcelemental as qcel. import psi4. _have_mdi = False; try:; from mdi import MDI_Init, MDI_MPI_get_world_comm, MDI_Accept_Communicator, \; MDI_Send, MDI_Recv, MDI_Recv_Command, MDI_INT, MDI_DOUBLE, \; MDI_Register_Node, MDI_Register_Command; _have_mdi = True; except ImportError:; pass. try:; from mpi4py import MPI; use_mpi4py = True; except ImportError:; use_mpi4py = False. class MDIEngine():; def __init__(self, scf_method: str, **kwargs):; """""" Initialize an MDIEngine object for communication with MDI (MolSSI driver interface). Parameters; ----------; scf_method; Method (SCF or post-SCF) used when calculating energies or gradients.; molecule; The target molecule, if not the last molecule defined.; kwargs; Any additional arguments to pass to :func:`psi4.driver.energy` or; :func:`psi4.driver.gradient` computation. """""". # Method used when the SCF command is received; self.scf_method = scf_method. # Additional arguments for energy, gradient, or optimization calculations; self.kwargs = kwargs. # Molecule all MDI operations are performed on; input_molecule = kwargs.pop('molecule', psi4.core.get_active_molecule()); _ini_cart = getattr(input_molecule, ""_initial_cartesian"", None); self.molecule = input_molecule.clone(); if _ini_cart:; self.molecule._initial_cartesian = _ini_cart; psi4.core.set_active_molecule(self.molecule). # Most recent SCF energy; self.energy = 0.0. # Variables used when MDI sets a lattice of point charges; self.nlattice = 0 # number of lattice point charges; self.clattice = [] # list of lattice coordinates; self.lattice = [] # list of lattice charges; self.lattice_field = psi4.QMMMbohr() # Psi4 chargefield. # MPI variables; self.mpi_world = None; self.world_rank = 0. # Flag for if a lattice of point charges has been set; self.set_lattice = ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html:2088,energy,energy,2088,psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html,1,['energy'],['energy']
Energy Efficiency,"#; """"""Support for using Psi4 as an MDI engine.; For details regarding MDI, see https://molssi.github.io/MDI_Library/html/index.html. """""". __all__ = [; ""mdi_init"",; ""mdi_run"",; ""MDIEngine"",; ]. import numpy as np; import qcelemental as qcel. import psi4. _have_mdi = False; try:; from mdi import MDI_Init, MDI_MPI_get_world_comm, MDI_Accept_Communicator, \; MDI_Send, MDI_Recv, MDI_Recv_Command, MDI_INT, MDI_DOUBLE, \; MDI_Register_Node, MDI_Register_Command; _have_mdi = True; except ImportError:; pass. try:; from mpi4py import MPI; use_mpi4py = True; except ImportError:; use_mpi4py = False. class MDIEngine():; def __init__(self, scf_method: str, **kwargs):; """""" Initialize an MDIEngine object for communication with MDI (MolSSI driver interface). Parameters; ----------; scf_method; Method (SCF or post-SCF) used when calculating energies or gradients.; molecule; The target molecule, if not the last molecule defined.; kwargs; Any additional arguments to pass to :func:`psi4.driver.energy` or; :func:`psi4.driver.gradient` computation. """""". # Method used when the SCF command is received; self.scf_method = scf_method. # Additional arguments for energy, gradient, or optimization calculations; self.kwargs = kwargs. # Molecule all MDI operations are performed on; input_molecule = kwargs.pop('molecule', psi4.core.get_active_molecule()); self.molecule = input_molecule.clone(); psi4.core.set_active_molecule(self.molecule). # Most recent SCF energy; self.energy = 0.0. # Variables used when MDI sets a lattice of point charges; self.nlattice = 0 # number of lattice point charges; self.clattice = [] # list of lattice coordinates; self.lattice = [] # list of lattice charges; self.lattice_field = psi4.QMMMbohr() # Psi4 chargefield. # MPI variables; self.mpi_world = None; self.world_rank = 0. # Flag for if a lattice of point charges has been set; self.set_lattice = False. # Get correct intra-code MPI communicator; if use_mpi4py:; self.mpi_world = MDI_MPI_get_world_comm(); self.world_rank =",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/mdi_engine.html:2086,energy,energy,2086,psi4manual/1.7.x/_modules/psi4/driver/mdi_engine.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/mdi_engine.html,1,['energy'],['energy']
Energy Efficiency,"#print opt, val['value']; #print molpro_basissets.altbasis.keys(); if not text:; text += """"""basis={\n""""""; try:; # jaxz, maxz, etc.; for line in molpro_basissets.altbasis[val['value']]:; text += """"""%s\n"""""" % (line); text += '\n'; except KeyError:; # haxz; if val['value'].startswith('heavy-aug-'):; text += """"""set,%s; default,%s,H=%s\n"""""" % (opt.lower(), self.augbasis, self.unaugbasis); # xz, axz, 6-31g*; else:; text += """"""set,%s; default,%s\n"""""" % (opt.lower(), val['value']); ; if text:; text += """"""}\n\n"""""". return text. [docs] def format_infile_string(self):; """""". """"""; # Handle memory and comment; memcmd, _memkw = """"""***, %s\nmemory,%d,m\n"""""" % (self.molecule.tagline, int(math.ceil(self.memory / 8.0))), {}. # Handle molecule and basis set; molcmd, _molkw = self.molecule.format_molecule_for_molpro(), {}. # format global convergence directions; # text += self.format_global_parameters(); _cdscmd, cdskw = muster_cdsgroup_options(self.method). # Handle calc type and quantum chemical method; mdccmd, mdckw, mdcls = procedures['energy'][self.method](self.method, self.dertype, self.molecule); _bascmd, baskw = self.muster_basis_options(). # # format options; # optcmd = qcdb.options.prepare_options_for_psi4(mdckw). # make options from imdb only user options (currently non-existent). set basis and castup from here.; # Handle driver vs input/default keyword reconciliation; userkw = self.options; # userkw = p4util.prepare_options_for_modules(); #userkw = qcdb.options.reconcile_options(userkw, memkw); #userkw = qcdb.options.reconcile_options(userkw, molkw); userkw = options.reconcile_options2(userkw, cdskw); userkw = options.reconcile_options2(userkw, baskw); #userkw = qcdb.options.reconcile_options(userkw, psikw); userkw = options.reconcile_options2(userkw, mdckw). # Handle conversion of psi4 keyword structure into cfour format; #optcmdB = options.prepare_options_for_psi4(userkw); optcmd = prepare_options_for_molpro(userkw, mdcls); bascmd, _baskw = self.prepare_basis_for_molpro(),",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro2.html:17619,energy,energy,17619,psi4manual/1.0.0/_modules/qcdb/molpro2.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro2.html,1,['energy'],['energy']
Energy Efficiency,"$PATH; >>> export PYTHONPATH=/path/to/dir/of/psi4/core-dot-so:$PYTHONPATH. >>> python -c ""import psi4"". How to run Psi4 as Python module after compilation¶; Substituting the full installation directory prefix and a; suitable scratch directory, issue the following commands directly in your; terminal or place them into your “rc” file and open a new terminal. (To; use a staged installation directory, substitute; objdir/stage for prefix.); # csh, tcsh: add to shell or ~/.tcshrc file; setenv PYTHONPATH {prefix}/lib:$PYTHONPATH; setenv PSI_SCRATCH /path/to/existing/writable/local-not-network/directory/for/scratch/files. # sh, bash: add to shell or ~/.bashrc (Linux/Windows) or ~/.bash_profile (Mac) file; export PYTHONPATH={prefix}/lib:$PYTHONPATH; export PSI_SCRATCH=/path/to/existing/writable/local-not-network/directory/for/scratch/files. How to configure paths for PsiAPI. Run PSI4.; 1; 2; 3; 4; 5; 6; 7; 8; 9>>> cat sample.py; import psi4; mol = psi4.geometry(""""""; He; """"""); psi4.energy('hf/cc-pvdz'); psi4.compare_values(-2.85518839, psi4.core.get_variable('current energy'), 5, 'SCF E'); >>> python sample.py; SCF E.............................................................PASSED. How to run Psi4 as executable or Python module from conda installation¶; The configuration commands below are generic versions of the ones printed; to your screen as advice upon installing PSI4 into a Anaconda,; Miniconda, or Psi4conda distribution, condadist =; ana|mini|psi4conda. To see the message again after initial installation,; with the conda environment active, run .psi4-post-link.sh.; If which conda python psi4 points to your; condadist and echo $PSI_SCRATCH is set, skip ahead to the; “Run PSI4” commands below. Otherwise, issue the following; commands directly in your terminal or place them into your “rc” file and; open a new terminal.; If you installed the Psi4conda distribution or installed the PSI4; conda package into the main environment of an Anaconda or Miniconda; distribution and a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/build_planning-1.html:25495,energy,energy,25495,psi4manual/1.3.2/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/build_planning-1.html,2,['energy'],['energy']
Energy Efficiency,"$asyB eq '') ) {; # print ""ERROR: asymptotic correction not defined for one or more monomers in index $system.\n"";; # close(DIOUT);; # unlink(""$pathDIOUT"");; # }; #; # print $handle ""gdirect\n"";; # print $handle ""ca=2101.2; cb=2102.2\n\n"";; #; # $spin = $cgmp{MLPmol1} - 1;; # print $handle ""SET,CHARGE=$cgmp{CHGmol1}\nSET,SPIN=$spin\ndummy"";; # foreach $at (@monoBreal) { print $handle "",$at""; }; # print $handle ""\n{df-ks,pbex,pw91c,lhf,df_basis=dflhf,basis_coul=jkfitb,basis_exch=jkfitb; dftfac,0.75,1.0,0.25; asymp,$asyA; save,\$ca}\n"";; # print $handle ""eehfa=energy; sapt; monomerA\n\n"";; #; # $spin = $cgmp{MLPmol2} - 1;; # print $handle ""SET,CHARGE=$cgmp{CHGmol2}\nSET,SPIN=$spin\ndummy"";; # foreach $at (@monoAreal) { print $handle "",$at""; }; # print $handle ""\n{df-ks,pbex,pw91c,lhf,df_basis=dflhf,basis_coul=jkfitb,basis_exch=jkfitb; dftfac,0.75,1.0,0.25; asymp,$asyB; save,\$cb}\n"";; # print $handle ""eehfb=energy; sapt; monomerB\n\n"";; #; # $spin = $cgmp{MLPsyst} - 1;; # print $handle ""SET,CHARGE=$cgmp{CHGsyst}\nSET,SPIN=$spin\n"";; # print $handle ""{sapt,sapt_level=3; intermol,ca=\$ca,cb=\$cb,icpks=0,fitlevel=3,nlexfac=0.0\n"";; # print $handle ""dfit,basis_coul=jkfit,basis_exch=jkfit,basis_mp2=mp2fit,cfit_scf=3}\n"";; # print $handle ""eeelst=E1pol\n"";; # print $handle ""eeexch=E1ex\n"";; # print $handle ""eeind=E2ind\n"";; # print $handle ""eeexind=E2exind\n"";; # print $handle ""eedisp=E2disp\n"";; # print $handle ""eeexdisp=E2exdisp\n\n"";; #; # ]; #'dft-sapt-pbe0ac': [; #; # if ( ($asyA eq '') || ($asyB eq '') ) {; # print ""ERROR: asymptotic correction not defined for one or more monomers in index $system.\n"";; # close(DIOUT);; # unlink(""$pathDIOUT"");; # }; #; # print $handle ""ca=2101.2; cb=2102.2\n\n"";; #; # $spin = $cgmp{MLPmol1} - 1;; # print $handle ""SET,CHARGE=$cgmp{CHGmol1}\nSET,SPIN=$spin\ndummy"";; # foreach $at (@monoBreal) { print $handle "",$at""; }; # print $handle ""\n{ks,pbe0; asymp,$asyA; save,\$ca}\n"";; # print $handle ""eehfa=energy; sapt; monomerA\n\n"";; #; # $spi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro.html:9238,energy,energy,9238,psi4manual/1.0.0/_modules/qcdb/molpro.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro.html,1,['energy'],['energy']
Energy Efficiency,"$freeze_list. To optimize toward a value of 0.95 Angstroms for the distance between; atoms 1 and 3, as well as that between 2 and 4; 1; 2; 3; 4; 5; 6set optking {; fixed_distance = (""; 1 3 0.95; 2 4 0.95; ""); }. Note that the effect of the frozen and fixed keywords is independent of; how the geometry of the molecule was input (whether Z-matrix or cartesian, etc.).. To scan the potential energy surface by optimizing at several fixed values; of the dihedral angle of HOOH.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25molecule hooh {; 0 1; H 0.850718 0.772960 0.563468; O 0.120432 0.684669 -0.035503; O -0.120432 -0.684669 -0.035503; H -0.850718 -0.772960 0.563468; }. set {; basis cc-pvdz; intrafrag_step_limit 0.1; }. dihedrals = [100,110,120,130,140,150]; PES = []. for phi in dihedrals:; my_string = ""1 2 3 4 "" + str(phi); set optking fixed_dihedral = $my_string; E = optimize('scf'); PES.append((phi, E)). print ""\n\tcc-pVDZ SCF energy as a function of phi\n""; for point in PES:; print ""\t%5.1f%20.10f"" % (point[0], point[1]). Dealing with problematic optimizations¶; Although optking is continuously improved with robustness in mind, some; attempted optimizations will inevitably fail to converge to the desired minima.; For difficult cases, the following suggestions are made. As for any optimizer, computing the Hessian and limiting the step size will; successfully converge a higher percentage of cases. The default settings have; been chosen because they perform efficiently for common, representative test sets.; More restrictive, cautious steps are sometimes necessary.; DYNAMIC_LEVEL allows optking to change the method of optimization; toward algorithms that, while often less efficient, may help to converge difficult; cases. If this is initially set to 1, then optking, as poor steps are detected,; will increase the level through several forms of more robust and cautious algorithms.; The changes will reduce the trust radius, allow back",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/optking-1.html:7947,energy,energy,7947,psi4manual/1.1.0/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/optking-1.html,6,['energy'],['energy']
Energy Efficiency,"% (N, Na, Nb, charge, mult, HOMO)). if HOMO > 0:; Na = Na - 1; else:; Nb = Nb - 1; charge = charge + 1; mult = Na - Nb + 1. psi4.set_global_option(""DF_INTS_IO"", ""LOAD""); psi4.set_global_option(""FRAC_START"", frac_start); psi4.set_global_option(""FRAC_RENORMALIZE"", True). # Nuke 'em Rico!; for Nintegral in range(N, Nmin, -1):. # Nuke the current HOMO; for occ in foccs:. psi4.set_global_option(""FRAC_OCC"", [HOMO]); psi4.set_global_option(""FRAC_VAL"", [occ]). E, wfn = energy('scf', return_wfn=True, molecule=molecule, **kwargs); C = 1; if E == 0.0:; E = psi4.get_variable('SCF ITERATION ENERGY'); C = 0. if HOMO > 0:; eps = wfn.epsilon_a(); potentials.append(eps[HOMO - 1]); else:; eps = wfn.epsilon_b(); potentials.append(eps[-HOMO - 1]). Ns.append(Nintegral + occ - 1.0); energies.append(E); convs.append(C). psi4.set_global_option(""FRAC_START"", 2); psi4.set_global_option(""FRAC_LOAD"", True); psi4.set_global_option(""FRAC_DIIS"", frac_diis); psi4.set_global_option(""GUESS"", ""READ""). # Set the next charge/mult; molecule.set_molecular_charge(charge); molecule.set_multiplicity(mult). # Determine HOMO; print('DGAS: What ref should this point to?'); #ref = psi4.legacy_wavefunction(); eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); if Na == Nb:; HOMO = -Nb; elif Nb == 0:; HOMO = Na; else:; E_a = eps_a[int(Na - 1)]; E_b = eps_b[int(Nb - 1)]; if E_a >= E_b:; HOMO = Na; else:; HOMO = -Nb. stats.append(""""""\t%6d %6d %6d %6d %6d %6d\n"""""" % (Nintegral-1, Na, Nb, charge, mult, HOMO)). if HOMO > 0:; Na = Na - 1; else:; Nb = Nb - 1; charge = charge + 1; mult = Na - Nb + 1. psi4.set_global_option(""DF_INTS_IO"", ""NONE""). # => Print the results out <= #; E = {}; psi4.print_out(""""""\n ==> Fractional Occupation Nuke Results <==\n\n""""""); psi4.print_out(""""""\t%-11s %-24s %-24s %11s\n"""""" % ('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(len(Ns)):; psi4.print_out(""""""\t%11.3E %24.16E %24.16E %11d\n"""""" % (Ns[k], energies[k], potentials[k], convs[k])); E[Ns[k]] = energies[k]. psi4.print_out('\n');",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/frac.html:9726,charge,charge,9726,psi4manual/1.0.0/_modules/frac.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/frac.html,1,['charge'],['charge']
Energy Efficiency,"% (float(origin[0]), float(origin[1]), float(origin[2]))); except:; raise ValidationError(""The GDMA origin array should contain three entries: x, y, and z.""); f.write(""Switch %f\n"" % psi4.get_option('GDMA', 'GDMA_SWITCH')); if radii:; f.write(""Radius %s\n"" % "" "".join([str(r) for r in radii])); f.write(""Limit %d\n"" % psi4.get_option('GDMA', 'GDMA_LIMIT')); f.write(""Start\n""); f.write(""Finish\n""); psi4.run_gdma(wfn, commands). os.remove(fchkfile); # If we generated the DMA control file, we should clean up here; if not datafile:; os.remove(commands). [docs]def fchk(wfn, filename):; """"""Function to write wavefunction information in *wfn* to *filename* in; Gaussian FCHK format. .. versionadded:: 0.6. :returns: None. :type filename: string; :param filename: destination file name for FCHK file. :type wfn: :ref:`Wavefunction<sec:psimod_Wavefunction>`; :param wfn: set of molecule, basis, orbitals from which to generate fchk file. :examples:. >>> # [1] FCHK file for DFT calculation; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> fchk(wfn, 'mycalc.fchk'). """"""; fw = psi4.FCHKWriter(wfn); fw.write(filename). [docs]def molden(wfn, filename, density_a=None, density_b=None):; """"""Function to write wavefunction information in *wfn* to *filename* in; molden format. Will write natural orbitals from *density* (MO basis) if supplied. .. versionadded:: 0.5; *wfn* parameter passed explicitly. :returns: None. :type wfn: :ref:`Wavefunction<sec:psimod_Wavefunction>`; :param wfn: set of molecule, basis, orbitals from which to generate cube files. :type filename: string; :param filename: destination file name for MOLDEN file. :type density_a: psi4.Matrix; :param density_a: density in the MO basis to build alpha NO's from (optional). :type density_b: psi4.Matrix; :param density_b: density in the MO basis to build beta NO's from, assumes restricted if not supplied (optional). :examples:. >>> # [1] Molden file for DFT calculation; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> molden(wfn, 'm",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver.html:86221,energy,energy,86221,psi4manual/1.0.0/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver.html,1,['energy'],['energy']
Energy Efficiency,"% (self.full_point_group()) TODO symmetry; text += """""" Geometry (in %s), charge = %d, multiplicity = %d:\n\n"""""" % \; ('Bohr', self.molecular_charge(), self.multiplicity()); text += """""" Center X Y Z \n""""""; text += """""" ------------ ----------------- ----------------- -----------------\n"""""". for i in range(self.natom()):; text += """""" %8s%4s """""" % (self.symbol(i), """" if self.Z(i) else ""(Gh)""); for j in range(3):; text += """""" %17.12f"""""" % (self.xyz(i, j)); text += ""\n""; text += ""\n""; else:; text += "" No atoms in this molecule.\n""; print text; # TODO outfile. [docs] def print_out_in_angstrom(self):; """"""Print the molecule in Angstroms. Same as :py:func:`print_out` only always in Angstroms.; (method name in libmints is print_in_angstrom). """"""; text = """"; if self.natom():; if self.pg:; text += """""" Molecular point group: %s\n"""""" % (self.pg.symbol()); # if self.full_pg: TODO symmetry; # text += """""" Full point group: %s\n\n"""""" % (self.full_point_group()) TODO symmetry; text += """""" Geometry (in %s), charge = %d, multiplicity = %d:\n\n"""""" % \; ('Angstrom', self.molecular_charge(), self.multiplicity()); text += """""" Center X Y Z \n""""""; text += """""" ------------ ----------------- ----------------- -----------------\n"""""". for i in range(self.natom()):; text += """""" %8s%4s """""" % (self.symbol(i), """" if self.Z(i) else ""(Gh)""); for j in range(3):; text += """""" %17.12f"""""" % (self.xyz(i, j) * psi_bohr2angstroms); text += ""\n""; text += ""\n""; else:; text += "" No atoms in this molecule.\n""; print text; # TODO outfile. [docs] def print_full(self):; """"""Print full atom list. Same as :py:func:`print_out` only displays dummy atoms. """"""; text = """"; if self.natom():; if self.pg:; text += """""" Molecular point group: %s\n"""""" % (self.pg.symbol()); # if self.full_pg: TODO symmetry; # text += """""" Full point group: %s\n\n"""""" % (self.full_point_group()) TODO symmetry; text += """""" Geometry (in %s), charge = %d, multiplicity = %d:\n\n"""""" % \; (self.units(), self.molecular_charge(), self.multiplicity()); text += """,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:27319,charge,charge,27319,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,1,['charge'],['charge']
Energy Efficiency,"% (self.name()); text += """""" Natom %d\t\tNallatom %d\n"""""" % (self.natom(), self.nallatom()); text += """""" charge %d\t\tspecified? %s\n"""""" % (self.molecular_charge(), self.charge_specified()); text += """""" multiplicity %d\t\tspecified? %s\n"""""" % (self.multiplicity(), self.multiplicity_specified()); text += """""" units %s\tconversion %f\n"""""" % (self.units(), self.input_units_to_au); text += """""" DOcom? %s\t\tDONTreorient? %s\n"""""" % (self.PYmove_to_com, self.orientation_fixed()); text += """""" reinterpret? %s\t\tlock_frame? %s\n"""""" % (self.PYreinterpret_coordentries, self.lock_frame); text += """""" input symm %s\n"""""" % (self.symmetry_from_input()); text += """""" Nfragments %d\t\tNactive %d\n"""""" % (self.nfragments(), self.nactive_fragments()); text += """""" zmat? %s\n"""""" % (self.has_zmatrix()); print(text). [docs] def create_psi4_string_from_molecule(self):; """"""Regenerates a input file molecule specification string from the; current state of the Molecule. Contains geometry info,; fragmentation, charges and multiplicities, and any frame; restriction.; """"""; text = """"; if self.nallatom():. # append units and any other non-default molecule keywords; text += "" units %-s\n"" % (""Angstrom"" if self.units() == 'Angstrom' else ""Bohr""); if not self.PYmove_to_com:; text += "" no_com\n""; if self.PYfix_orientation:; text += "" no_reorient\n"". # append atoms and coordentries and fragment separators with charge and multiplicity; Pfr = 0; for fr in range(self.nfragments()):; if self.fragment_types[fr] == 'Absent' and not self.has_zmatrix():; continue; text += ""%s %s%d %d\n"" % (; """" if Pfr == 0 else "" --\n"",; ""#"" if self.fragment_types[fr] == 'Ghost' or self.fragment_types[fr] == 'Absent' else """",; self.fragment_charges[fr], self.fragment_multiplicities[fr]); Pfr += 1; for at in range(self.fragments[fr][0], self.fragments[fr][1] + 1):; if self.fragment_types[fr] == 'Absent':; text += "" %-8s"" % (""X""); elif self.fZ(at) or self.fsymbol(at) == ""X"":; text += "" %-8s"" % (self.flabel(at)); else:; text += "" %-8s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:31688,charge,charges,31688,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,1,['charge'],['charges']
Energy Efficiency,"%f %f\n"" % (float(origin[0]), float(origin[1]), float(origin[2]))); except:; raise ValidationError(""The GDMA origin array should contain three entries: x, y, and z.""); f.write(""Switch %f\n"" % core.get_option('GDMA', 'GDMA_SWITCH')); if radii:; f.write(""Radius %s\n"" % "" "".join([str(r) for r in radii])); f.write(""Limit %d\n"" % core.get_option('GDMA', 'GDMA_LIMIT')); f.write(""Start\n""); f.write(""Finish\n""); core.run_gdma(wfn, commands). os.remove(fchkfile); # If we generated the DMA control file, we should clean up here; if not datafile:; os.remove(commands). [docs]def fchk(wfn, filename):; """"""Function to write wavefunction information in *wfn* to *filename* in; Gaussian FCHK format. .. versionadded:: 0.6. :returns: None. :type filename: string; :param filename: destination file name for FCHK file. :type wfn: :py:class:`~psi4.core.Wavefunction`; :param wfn: set of molecule, basis, orbitals from which to generate fchk file. :examples:. >>> # [1] FCHK file for DFT calculation; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> fchk(wfn, 'mycalc.fchk'). """"""; fw = core.FCHKWriter(wfn); fw.write(filename). [docs]def molden(wfn, filename=None, density_a=None, density_b=None, dovirtual=None):; """"""Function to write wavefunction information in *wfn* to *filename* in; molden format. Will write natural orbitals from *density* (MO basis) if supplied.; Warning! Most post-SCF Wavefunctions do not build the density as this is often; much more costly than the energy. In addition, the Wavefunction density attributes; (Da and Db) return the SO density and must be transformed to the MO basis; to use with this function. .. versionadded:: 0.5; *wfn* parameter passed explicitly. :returns: None. :type wfn: :py:class:`~psi4.core.Wavefunction`; :param wfn: set of molecule, basis, orbitals from which to generate cube files. :type filename: string; :param filename: destination file name for MOLDEN file (optional). :type density_a: :py:class:`~psi4.core.Matrix`; :param density_a: density in the MO",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html:88749,energy,energy,88749,psi4manual/1.1.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html,2,['energy'],['energy']
Energy Efficiency,"& Algorithm for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. EA_POLES (OCC); OCC — Do compute OCC poles for electron affinities? Only valid for OMP2. Type: boolean; Default: false. EFP_DISP (EFP); EFP — Do include dispersion energy term in EFP computation?. Type: boolean; Default: true. EFP_DISP_DAMPING (EFP); EFP — Fragment-fragment dispersion damping type. TT is a damping formula by Tang and Toennies. OVERLAP is overlap-based dispersion damping. Type: string; Possible Values: TT, OVERLAP, OFF; Default: OVERLAP. EFP_ELST (EFP); EFP — Do include electrostatics energy term in EFP computation?. Type: boolean; Default: true. EFP_ELST_DAMPING (EFP); EFP — Fragment-fragment electrostatic damping type. SCREEN is a damping formula based on screen group in the EFP potential. OVERLAP is damping that computes charge penetration energy. Type: string; Possible Values: SCREEN, OVERLAP, OFF; Default: SCREEN. EFP_EXCH (EFP); EFP — Do include exchange repulsion energy term in EFP computation?. Type: boolean; Default: true. EFP_IND (EFP); EFP — Do include polarization energy term in EFP computation? (EFP_POL c. v1.1). Type: boolean; Default: true. EFP_IND_DAMPING (EFP); EFP — Fragment-fragment polarization damping type. TT is a damping formula like Tang and Toennies. (EFP_POL_DAMPING c. v1.1). Type: string; Possible Values: TT, OFF; Default: TT. EFP_QM_ELST (EFP); EFP — Do include electrostatics energy term in QM/EFP computation? (QMEFP_ELST c. v1.1). Type: boolean; Default: true. EFP_QM_IND (EFP); EFP — Do include polarization energy term in QM/EFP computation? (QMEFP_POL c. v1.1). Type: boolean; Default: true. EKT_EA (OCC); OCC — Do compute virtual orbital energies based on extended Koopmans’ theorem?. Type: boolean; Default: false. EKT_IP (DFOCC); DFOCC — Do compute ionization potentials based on the extended Koopmans’ theorem?. Type: boolean; Default: false. EKT_IP (OCC); OCC — Do compute occupied orbital energies based on extend",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html:118686,energy,energy,118686,psi4manual/1.2.1/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html,4,['energy'],['energy']
Energy Efficiency,"& Algorithm for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. EA_POLES (OCC); OCC — Do compute OCC poles for electron affinities? Only valid for OMP2. Type: boolean; Default: false. EFP_DISP (EFP); EFP — Do include dispersion energy term in EFP computation?. Type: boolean; Default: true. EFP_DISP_DAMPING (EFP); EFP — Fragment-fragment dispersion damping type. TT is a damping formula by Tang and Toennies. OVERLAP is overlap-based dispersion damping. Type: string; Possible Values: TT, OVERLAP, OFF; Default: OVERLAP. EFP_ELST (EFP); EFP — Do include electrostatics energy term in EFP computation?. Type: boolean; Default: true. EFP_ELST_DAMPING (EFP); EFP — Fragment-fragment electrostatic damping type. SCREEN is a damping formula based on screen group in the EFP potential. OVERLAP is damping that computes charge penetration energy. Type: string; Possible Values: SCREEN, OVERLAP, OFF; Default: SCREEN. EFP_EXCH (EFP); EFP — Do include exchange repulsion energy term in EFP computation?. Type: boolean; Default: true. EFP_POL (EFP); EFP — Do include polarization energy term in EFP computation?. Type: boolean; Default: true. EFP_POL_DAMPING (EFP); EFP — Fragment-fragment polarization damping type. TT is a damping formula like Tang and Toennies. Type: string; Possible Values: TT, OFF; Default: TT. EKT_EA (OCC); OCC — Do compute virtual orbital energies based on extended Koopmans’ theorem?. Type: boolean; Default: false. EKT_IP (DFOCC); DFOCC — Do compute ionization potentials based on the extended Koopmans’ theorem?. Type: boolean; Default: false. EKT_IP (OCC); OCC — Do compute occupied orbital energies based on extended Koopmans’ theorem?. Type: boolean; Default: false. ENERGY_LEVEL_SHIFT (DCFT); DCFT (Expert) — Level shift applied to the diagonal of the density-weighted Fock operator. While this shift can improve convergence, it does change the DCFT energy. Type: double; Default: 0.0. ENSURE_BT_CONVERGENCE (OPTKING); OPTKING — ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:116248,energy,energy,116248,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,4,['energy'],['energy']
Energy Efficiency,"& disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Any or all parameters initialized; from dashcoeff[dashlvl][func] can be overwritten via; dashparam.; dashlvl (Optional[str]) – Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or “alias” or; “formal” to run.; dashparam (Optional[Dict]) – Values for the same keys as dashcoeff[dashlvl][‘default’]; used to override any or all values initialized by func.; Extra parameters will error.; dertype (Union[int, str, None]) – Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int) – Amount of printing. Returns:. energy (float) – When dertype=0, energy [Eh].; gradient (~numpy.ndarray) – When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ~numpy.ndarray) – When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. qcdb.Molecule.run_dftd4(self, func=None, dashlvl=None, dashparam=None, dertype=None, verbose=1)¶; Compute dispersion correction via Grimme’s DFTD4 program. Parameters:. func (Optional[str]) – Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Unlike run_dftd3, func overwrites any; parameter initialized via dashparam.; dashlvl (Optional[str]) – Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or “alias” or; “formal” to run.; dashparam (Optional[Dict]) – Values for the same keys as dashcoeff[dashlvl][‘default’]; used to provide custom values. Unlike run_dftd3, will not have; effect if func given. Must provide all parameters.; Extra parameters will error.; dertype (Union[int, str, None]) – Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly mo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/dftd3.html:14693,energy,energy,14693,psi4manual/1.7.x/dftd3.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/dftd3.html,4,['energy'],['energy']
Energy Efficiency,"& disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Any or all parameters initialized; from dashcoeff[dashlvl][func] can be overwritten via; dashparam.; dashlvl (Optional[str]) – Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or “alias” or; “formal” to run.; dashparam (Optional[Dict]) – Values for the same keys as dashcoeff[dashlvl][‘default’]; used to override any or all values initialized by func.; Extra parameters will error.; dertype (Union[int, str, None]) – Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int) – Amount of printing. Returns:. energy (float) – When dertype=0, energy [Eh].; gradient (~numpy.ndarray) – When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ~numpy.ndarray) – When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. run_dftd4(func=None, dashlvl=None, dashparam=None, dertype=None, verbose=1)[source]¶; Compute dispersion correction via Grimme’s DFTD4 program. Parameters:. func (Optional[str]) – Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Unlike run_dftd3, func overwrites any; parameter initialized via dashparam.; dashlvl (Optional[str]) – Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or “alias” or; “formal” to run.; dashparam (Optional[Dict]) – Values for the same keys as dashcoeff[dashlvl][‘default’]; used to provide custom values. Unlike run_dftd3, will not have; effect if func given. Must provide all parameters.; Extra parameters will error.; dertype (Union[int, str, None]) – Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficien",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:29009,energy,energy,29009,psi4manual/1.7.x/api/psi4.core.Molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html,4,['energy'],['energy']
Energy Efficiency,"' % (n + 1, ndisp)). # Print information to the screen; print(' %d' % (n + 1), end=""""); if (n + 1) == ndisp:; print('\n', end=""""); sys.stdout.flush(). # Load in displacement into the active molecule (xyz coordinates only); molecule.set_geometry(displacement). # Perform the gradient calculation; func(lowername, **kwargs). # Save the gradient; G = PsiMod.get_gradient(); gradients.append(G). # clean may be necessary when changing irreps of displacements; PsiMod.clean(). PsiMod.fd_freq_1(gradients, irrep). print(' Computation complete.'). # Clear the ""parent"" symmetry now; PsiMod.set_parent_symmetry(""""). # TODO: These need to be restored to the user specified setting; PsiMod.get_active_molecule().fix_orientation(False); # But not this one, it always goes back to True; PsiMod.get_active_molecule().reinterpret_coordentry(True). # call thermo module; PsiMod.thermo(). optstash.restore(); # TODO: add return statement. else: # Assume energy points; # If not, perform finite difference of energies; info = 'Performing finite difference calculations by energies'; print(info). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash.restore(); if not PsiMod.has_option_changed('SCF', 'E_CONVERGENCE'):; if procedures['energy'][lowername] == run_scf or procedures['energy'][lowername] == run_dft:; PsiMod.set_local_option('SCF', 'E_CONVERGENCE', 10); else:; PsiMod.set_local_option('SCF', 'E_CONVERGENCE', 11); if not PsiMod.has_option_changed('SCF', 'D_CONVERGENCE'):; if procedures['energy'][lowername] == run_scf or procedures['energy'][lowername] == run_dft:; PsiMod.set_local_option('SCF', 'D_CONVERGENCE', 10); else:; PsiMod.set_local_option('SCF', 'D_CONVERGENCE', 11). # Set post-scf convergence criteria (global will cover all correlated modules); if not PsiMod.has_global_option_changed('E_CONVERGENCE'):; if not procedures['energy'][lowername] == run_scf and not procedures['energy'][lowername] == run_dft:; PsiMod.set_global_optio",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/driver.html:64730,energy,energy,64730,psi4manual/4.0b4/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/driver.html,1,['energy'],['energy']
Energy Efficiency,"' %6s %24s %24s\n' % (""N-Body"", ""Delta E [H]"", ""Delta E [kcal mol^-1]"")); for k in range(len(Ns)):; n = Ns[k]; if n == 1:; continue; E = energies_n_bsse[Ns[k]] - energies_n_bsse[Ns[k + 1]]; PsiMod.print_out(' %6s %24.16E %24.16E\n' % (n, E, physconst.psi_hartree2kcalmol * E)); PsiMod.print_out('\n'). # Put everything back the way it was; PsiMod.set_global_option('DF_INTS_IO', ri_ints_io); psioh.set_specific_retention(97, False); PsiMod.clean(); activate(molecule). if bsse == 'on' or bsse == 'both':; return energies_n_full[Ns[0]]; else:; return energies_n_mon[Ns[0]]. ## Aliases ##; nbody = n_body. #####################; ## End of n_body ##; #####################. ###################; ## Start of cp ##; ###################. [docs]def cp(name, **kwargs):; r""""""The cp function computes counterpoise-corrected two-body interaction energies; for complexes composed of arbitrary numbers of monomers. :aliases: counterpoise_correct(), counterpoise_correction(). :returns: (*float*) Counterpoise-corrected interaction energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CP-CORRECTED 2-BODY INTERACTION ENERGY <CP-CORRECTED2-BODYINTERACTIONENERGY>`; * :psivar:`UNCP-CORRECTED 2-BODY INTERACTION ENERGY <UNCP-CORRECTED2-BODYINTERACTIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - No values of func besides energy have been tested. - Table print-out needs improving. Add some PSI variables. :type name: string; :param name: ``'scf'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the molecule. May be any valid argument to; :py:func:`~driver.energy`; however, SAPT is not appropriate. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on the molecule; and each of its monomers. The default performs a single-point; ``energy('name')``, while ``optimize`` perfoms ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html:16562,energy,energy,16562,psi4manual/4.0b3/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html,2,['energy'],['energy']
Energy Efficiency,"' %6s %24s %24s\n' % (""N-Body"", ""Delta E [H]"", ""Delta E [kcal mol^-1]"")); for k in range(len(Ns)):; n = Ns[k]; if n == 1:; continue; E = energies_n_bsse[Ns[k]] - energies_n_bsse[Ns[k + 1]]; PsiMod.print_out(' %6s %24.16E %24.16E\n' % (n, E, physconst.psi_hartree2kcalmol * E)); PsiMod.print_out('\n'). # Put everything back the way it was; PsiMod.set_global_option('DF_INTS_IO', ri_ints_io); psioh.set_specific_retention(97, False); PsiMod.clean(); activate(molecule). if bsse == 'on' or bsse == 'both':; return energies_n_full[Ns[0]]; else:; return energies_n_mon[Ns[0]]. ## Aliases ##; nbody = n_body. #####################; ## End of n_body ##; #####################. ###################; ## Start of cp ##; ###################. [docs]def cp(name, **kwargs):; r""""""The cp function computes counterpoise-corrected two-body interaction energies; for complexes composed of arbitrary numbers of monomers. :aliases: counterpoise_correct(), counterpoise_correction(). :returns: (*float*) Counterpoise-corrected interaction energy in kcal/mol. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CP-CORRECTED 2-BODY INTERACTION ENERGY <CP-CORRECTED2-BODYINTERACTIONENERGY>`; * :psivar:`UNCP-CORRECTED 2-BODY INTERACTION ENERGY <UNCP-CORRECTED2-BODYINTERACTIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - No values of func besides energy have been tested. - Table print-out needs improving. Add some PSI variables. :type name: string; :param name: ``'scf'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the molecule. May be any valid argument to; :py:func:`~driver.energy`; however, SAPT is not appropriate. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on the molecule; and each of its monomers. The default performs a single-point; ``energy('name')``, while ``optimize`` perfoms ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:16555,energy,energy,16555,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,1,['energy'],['energy']
Energy Efficiency,"' %s and derivative level \'dertype\' %s are not available.'; % (lowername, dertype)). # Make sure the molecule the user provided is the active one; if ('molecule' in kwargs):; activate(kwargs['molecule']); del kwargs['molecule']; molecule = psi4.get_active_molecule(); molecule.update_geometry(); psi4.set_global_option('BASIS', psi4.get_global_option('BASIS')). # S/R: Mode of operation- whether finite difference opt run in one job or files farmed out; freq_mode = 'continuous'; if ('mode' in kwargs) and ((dertype == 0) or (dertype == 1)):; freq_mode = kwargs['mode']. if (freq_mode.lower() == 'continuous'):; pass; elif (freq_mode.lower() == 'sow'):; pass; elif (freq_mode.lower() == 'reap'):; if('linkage' in kwargs):; freq_linkage = kwargs['linkage']; else:; raise ValidationError('Frequency execution mode \'reap\' requires a linkage option.'); else:; raise ValidationError('Frequency execution mode \'%s\' not valid.' % (freq_mode)). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); if not psi4.has_option_changed('SCF', 'E_CONVERGENCE'):; if procedures['energy'][lowername] == run_scf or procedures['energy'][lowername] == run_dft:; psi4.set_local_option('SCF', 'E_CONVERGENCE', 8); else:; psi4.set_local_option('SCF', 'E_CONVERGENCE', 10); if not psi4.has_option_changed('SCF', 'D_CONVERGENCE'):; if procedures['energy'][lowername] == run_scf or procedures['energy'][lowername] == run_dft:; psi4.set_local_option('SCF', 'D_CONVERGENCE', 8); else:; psi4.set_local_option('SCF', 'D_CONVERGENCE', 10). # Set post-scf convergence criteria (global will cover all correlated modules); if not psi4.has_global_option_changed('E_CONVERGENCE'):; if not procedures['energy'][lowername] == run_scf and not procedures['energy'][lowername] == run_dft:; psi4.set_global_option('E_CONVERGENCE', 8). # Select certain irreps; if 'irrep' in kwargs:; irrep = parse_cotton_irreps(kwargs['irrep']) - 1 # externally, A1 irrep is 1, internally 0; else:; irrep",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/driver.html:60954,energy,energy,60954,psi4manual/4.0b5/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/driver.html,1,['energy'],['energy']
Energy Efficiency,"' : MP2 correlation energy. :param expected: Reference FCIDUMP file against which `computed` is compared.; :param computed: Input FCIDUMP file to compare against `expected`.; :param label: string labeling the test; """""". # Grab expected header and integrals; ref_intdump = fcidump_from_file(expected); intdump = fcidump_from_file(computed). # Compare headers; compare_recursive(; ref_intdump,; intdump,; 'FCIDUMP header',; forgive=['enuc', 'hcore', 'eri', 'epsilon']). ref_energies = energies_from_fcidump(ref_intdump); energies = energies_from_fcidump(intdump). pass_1el = compare_values(ref_energies['ONE-ELECTRON ENERGY'], energies['ONE-ELECTRON ENERGY'], 7,; label + '. 1-electron energy'); pass_2el = compare_values(ref_energies['TWO-ELECTRON ENERGY'], energies['TWO-ELECTRON ENERGY'], 7,; label + '. 2-electron energy'); pass_scf = compare_values(ref_energies['SCF TOTAL ENERGY'], energies['SCF TOTAL ENERGY'], 10,; label + '. SCF total energy'); pass_mp2 = compare_values(ref_energies['MP2 CORRELATION ENERGY'], energies['MP2 CORRELATION ENERGY'], 10,; label + '. MP2 correlation energy'). compare_integers(True, (pass_1el and pass_2el and pass_scf and pass_mp2), label). [docs]; def energies_from_fcidump(intdump) -> Dict[str, float]:; """"""From integrals dictionary generated from :py:func:`fcidump_from_file`,; compute energies. :returns: a dictionary with energies. - 'NUCLEAR REPULSION ENERGY'; - 'ONE-ELECTRON ENERGY'; - 'TWO-ELECTRON ENERGY'; - 'SCF TOTAL ENERGY'; - 'MP2 CORRELATION ENERGY'. """"""; energies = {}; energies['NUCLEAR REPULSION ENERGY'] = intdump['enuc']; epsilon = intdump['epsilon']; Hcore = intdump['hcore']; eri = intdump['eri']. # Compute SCF energy; energies['ONE-ELECTRON ENERGY'], energies['TWO-ELECTRON ENERGY'] = _scf_energy(Hcore, eri,; np.where(epsilon < 0)[0],; intdump['uhf']); # yapf: disable; energies['SCF TOTAL ENERGY'] = energies['ONE-ELECTRON ENERGY'] + energies['TWO-ELECTRON ENERGY'] + energies['NUCLEAR REPULSION ENERGY']; # yapf: enable. # Compute MP2 ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fcidump.html:13727,energy,energy,13727,psi4manual/1.8.x/_modules/psi4/driver/p4util/fcidump.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fcidump.html,3,['energy'],['energy']
Energy Efficiency,"' : MP2 correlation energy. :param expected: Reference FCIDUMP file against which `computed` is compared.; :param computed: Input FCIDUMP file to compare against `expected`.; :param label: string labeling the test; """""". # Grab expected header and integrals; ref_intdump = fcidump_from_file(expected); intdump = fcidump_from_file(computed). # Compare headers; compare_recursive(; ref_intdump,; intdump,; 'FCIDUMP header',; forgive=['enuc', 'hcore', 'eri', 'epsilon']). ref_energies = energies_from_fcidump(ref_intdump); energies = energies_from_fcidump(intdump). pass_1el = compare_values(ref_energies['ONE-ELECTRON ENERGY'], energies['ONE-ELECTRON ENERGY'], 7,; label + '. 1-electron energy'); pass_2el = compare_values(ref_energies['TWO-ELECTRON ENERGY'], energies['TWO-ELECTRON ENERGY'], 7,; label + '. 2-electron energy'); pass_scf = compare_values(ref_energies['SCF TOTAL ENERGY'], energies['SCF TOTAL ENERGY'], 10,; label + '. SCF total energy'); pass_mp2 = compare_values(ref_energies['MP2 CORRELATION ENERGY'], energies['MP2 CORRELATION ENERGY'], 10,; label + '. MP2 correlation energy'). compare_integers(True, (pass_1el and pass_2el and pass_scf and pass_mp2), label). [docs]def energies_from_fcidump(intdump) -> Dict[str, float]:; """"""From integrals dictionary generated from :py:func:`fcidump_from_file`,; compute energies. :returns: a dictionary with energies. - 'NUCLEAR REPULSION ENERGY'; - 'ONE-ELECTRON ENERGY'; - 'TWO-ELECTRON ENERGY'; - 'SCF TOTAL ENERGY'; - 'MP2 CORRELATION ENERGY'. """"""; energies = {}; energies['NUCLEAR REPULSION ENERGY'] = intdump['enuc']; epsilon = intdump['epsilon']; Hcore = intdump['hcore']; eri = intdump['eri']. # Compute SCF energy; energies['ONE-ELECTRON ENERGY'], energies['TWO-ELECTRON ENERGY'] = _scf_energy(Hcore, eri,; np.where(epsilon < 0)[0],; intdump['uhf']); # yapf: disable; energies['SCF TOTAL ENERGY'] = energies['ONE-ELECTRON ENERGY'] + energies['TWO-ELECTRON ENERGY'] + energies['NUCLEAR REPULSION ENERGY']; # yapf: enable. # Compute MP2 en",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/fcidump.html:13719,energy,energy,13719,psi4manual/1.7.x/_modules/psi4/driver/p4util/fcidump.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/fcidump.html,1,['energy'],['energy']
Energy Efficiency,"' : MP2 correlation energy. :param expected: Reference FCIDUMP file against which `computed` is compared.; :param computed: Input FCIDUMP file to compare against `expected`.; :param label: string labeling the test; """""". # Grab expected header and integrals; ref_intdump = fcidump_from_file(expected); intdump = fcidump_from_file(computed). # Compare headers; compare_recursive(; ref_intdump,; intdump,; 'FCIDUMP header',; forgive=['enuc', 'hcore', 'eri', 'epsilon']). ref_energies = energies_from_fcidump(ref_intdump); energies = energies_from_fcidump(intdump). pass_1el = compare_values(ref_energies['ONE-ELECTRON ENERGY'], energies['ONE-ELECTRON ENERGY'], 7,; label + '. 1-electron energy'); pass_2el = compare_values(ref_energies['TWO-ELECTRON ENERGY'], energies['TWO-ELECTRON ENERGY'], 7,; label + '. 2-electron energy'); pass_scf = compare_values(ref_energies['SCF TOTAL ENERGY'], energies['SCF TOTAL ENERGY'], 10,; label + '. SCF total energy'); pass_mp2 = compare_values(ref_energies['MP2 CORRELATION ENERGY'], energies['MP2 CORRELATION ENERGY'], 10,; label + '. MP2 correlation energy'). compare_integers(True, (pass_1el and pass_2el and pass_scf and pass_mp2), label). [docs]def energies_from_fcidump(intdump):; energies = {}; energies['NUCLEAR REPULSION ENERGY'] = intdump['enuc']; epsilon = intdump['epsilon']; Hcore = intdump['hcore']; eri = intdump['eri']. # Compute SCF energy; energies['ONE-ELECTRON ENERGY'], energies['TWO-ELECTRON ENERGY'] = _scf_energy(Hcore, eri,; np.where(epsilon < 0)[0],; intdump['uhf']); # yapf: disable; energies['SCF TOTAL ENERGY'] = energies['ONE-ELECTRON ENERGY'] + energies['TWO-ELECTRON ENERGY'] + energies['NUCLEAR REPULSION ENERGY']; # yapf: enable. # Compute MP2 energy; energies['MP2 CORRELATION ENERGY'] = _mp2_energy(eri, epsilon, intdump['uhf']). return energies. def _scf_energy(Hcore, ERI, occ_sl, unrestricted):; scf_1el_e = np.einsum('ii->', Hcore[np.ix_(occ_sl, occ_sl)]); if not unrestricted:; scf_1el_e *= 2; coulomb = np.einsum('iijj->', E",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/fcidump.html:13491,energy,energy,13491,psi4manual/1.6.x/_modules/psi4/driver/p4util/fcidump.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/fcidump.html,1,['energy'],['energy']
Energy Efficiency,"' || etc.; First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be 'scf'. Overruled if stage_wfn keywords supplied. scf_wfn (string) – 'scf' || 'c4-scf' || etc.; Indicates the energy method for which the reference energy is to be; obtained. Generally unnecessary, as ‘scf’ is the scf in Psi4 but; can be used to direct lone scf components to run in Psi4 or Cfour; in a mixed-program composite method. corl_wfn (string) – 'mp2' || 'ccsd(t)' || etc.; Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with name or as the unlabeled; first argument to the function. delta_wfn (string) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. delta_wfn_lesser (string) – corl_wfn || 'mp2' || etc.; Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. delta2_wfn (string) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. delta2_wfn_lesser (string) – delta_wfn || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. delta3_wfn (string) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a third delta correction; to the correlation energy is to be obtained. delta3_wfn_lesser (string) – delta2_wfn || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a third delta correction; to the correlation energy is to be obtained. delta4_wfn (string) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a fourth delta correction; to the correlation energy is to be obtained. delta4_wfn_lesser (string) – delta3_wfn || 'ccsd(t)' || etc.; Indica",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/cbs-1.html:3840,energy,energy,3840,psi4manual/1.0.0/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/cbs-1.html,4,['energy'],['energy']
Energy Efficiency,"' || etc.; Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. Basis Sets; Currently, the basis set set through set commands have no influence; on a cbs calculation. Parameters:; scf_basis (basis string) – \(\Rightarrow\) corl_basis \(\Leftarrow\) || 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, scf_basis can default; to corl_basis. corl_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the correlation energy. delta_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. delta2_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, 'xtpl_highest_1', which uses the best basis; set available. See sec:cbs_xtpl for all available schemes. Parameters:; scf_scheme (function) – \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || scf_xtpl_helgaker_3 || etc.; Indicates the basis set extrapolation scheme to be applied to the reference energy.; Defaults to scf_xtpl_helgaker_3() if three valid basis sets; present in scf_basis, scf_xtpl_helgaker_2() if two valid basis; sets present in scf_basis, and xtpl_highest_1() otherwise. xtpl_highest_1; scf_xtpl_helgaker_3; scf_xtpl_helgaker_2; scf_xtpl_truhlar_2; scf_xtpl_karton_2. corl_scheme (function) – \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || corl_xtpl_helgaker_2 || etc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.driver.cbs-1.html:7422,energy,energy,7422,psi4manual/1.3.2/api/psi4.driver.cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.driver.cbs-1.html,4,['energy'],['energy']
Energy Efficiency,"') to energy():; QCISD iterations converged!. OS MP2 FNO correction: -0.000819116338; SS MP2 FNO correction: -0.000092278158; MP2 FNO correction: -0.000911394496. OS MP2 correlation energy: -0.166478414245; SS MP2 correlation energy: -0.056669079827; MP2 correlation energy: -0.223147494072; * MP2 total energy: -76.258836941658. OS MP2.5 correlation energy: -0.171225850256; SS MP2.5 correlation energy: -0.054028401038; MP2.5 correlation energy: -0.225254251294; * MP2.5 total energy: -76.260943698880. OS MP3 correlation energy: -0.175973286267; SS MP3 correlation energy: -0.051387722248; MP3 correlation energy: -0.227361008515; * MP3 total energy: -76.263050456101. OS MP4(SDQ) correlation energy: -0.180324322304; SS MP4(SDQ) correlation energy: -0.048798468084; MP4(SDQ) correlation energy: -0.230995119324; * MP4(SDQ) total energy: -76.266684566910. OS QCISD correlation energy: -0.181578117924; SS QCISD correlation energy: -0.049853548145; QCISD correlation energy: -0.231431666069; * QCISD total energy: -76.267121113654. The first set of energies printed corresponds to the second-order FNO; correction mentioned previously. Results for many-body perturbation; theory through partial fourth order are then provided.; The notation MP4(SDQ) indicates that we have included all contributions to; the correlation energy through fourth order, with the exception of that; from connected triple excitations.; One need not run a full QCISD or CCSD computation to obtain these; perturbation theory results. The keywords for invoking perturbation; theory computations are given below in; Table FNOCC Methods. Full MP4 correlation; energies are also available. Coupled electron pair approximation¶; Coupled-pair methods can be viewed as approximations to CCSD or as; size-extensive modifications of CISD. The methods have the same; complexity as CISD, and solving the CISD or coupled-pair equations; requires fewer floating point operations than solving the CCSD. CISD,; CCSD, and the coupled-pair ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/fnocc-1.html:6272,energy,energy,6272,psi4manual/1.4.0/fnocc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/fnocc-1.html,15,['energy'],['energy']
Energy Efficiency,"')). # Set GKS up after adding functionals; sup.set_x_omega(0.3); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_svwn_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('SVWN'); # Tab in, trailing newlines; sup.set_description(' SVWN3 (RPA) LSDA Functional\n'); # Tab in, trailing newlines; sup.set_citation(' Adamson et. al., J. Comput. Chem., 20(9), 921-927, 1999\n'). # Add member functionals; sup.add_x_functional(build_functional('S_X')); sup.add_c_functional(build_functional('VWN3RPA_C')). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_blyp_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('BLYP'); # Tab in, trailing newlines; sup.set_description(' BLYP GGA Exchange-Correlation Functional\n'); # Tab in, trailing newlines; sup.set_citation(' P.J. Stephens et. al., J. Phys. Chem., 98, 11623-11627, 1994\n B. Miehlich et. al., Chem. Phys. Lett., 157(3), 200-206 1989\n'). # Add member functionals; sup.add_x_functional(build_functional('B88_X')); sup.add_c_functional(build_functional('LYP_C')). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_pw91_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.b",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/functional.html:23763,allocate,allocate,23763,psi4manual/4.0b5/_modules/functional.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/functional.html,2,['allocate'],['allocate']
Energy Efficiency,"'). >>> # [2] Charge-transfer SAPT calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). >>> # [3] Arbitrary-order MPn calculation; >>> energy('mp4'). >>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> molecule H2 {\\n0 1\\nH\\nH 1 0.74\\n}; >>> energy('scf'); >>> H2.set_multiplicity(3); >>> energy('detci', bypass_scf=True). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(). # Allow specification of methods to arbitrary order; lowername, level = parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. try:; return procedures['energy'][lowername](lowername, **kwargs); except KeyError:; raise ValidationError('Energy method %s not available.' % (lowername)). [docs]def gradient(name, **kwargs):; r""""""Function complementary to optimize(). Carries out one gradient pass,; deciding analytic or finite difference. """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs); dertype = 1. # Order of precedence:; # 1. Default for wavefunction; # 2. Value obtained from kwargs, if user changed it; # 3. If user provides a custom 'func' use that. # Allow specification of methods to arbitrary order; lowername, level = parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. # 1. set the default to that of the provided name; if lowername in procedures['gradient']:; dertype = 1; elif lowername in procedures['energy']:; dertype = 0; func = energy. # 2. Check if the user passes dertype into this function; if 'dertype' in kwargs:; opt_dertype = kwargs['dertype']. if der0th.match(str(opt_dertype)):; dertype = 0; func = energy; elif der1st.match(str(opt_dertype)",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/driver.html:22850,energy,energy,22850,psi4manual/4.0b3/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/driver.html,1,['energy'],['energy']
Energy Efficiency,"'). PBEh-3c with default basis after basis set; set basis cc-pvdz; energy('pbeh3c/'). If only BSSE/basis set corrections (rather than total energies) are of; interest, the gcp program can be run independently of the scf; through the python function run_gcp(). (This function; is the same PSI4/gcp interface that is called during an scf job.); This route is much faster than running a HF or DFT energy.; molecule nene {; Ne; Ne 1 2.0; }. nene.update_geometry(). >>> E, G = nene.run_gcp('hf3c'). >>> E, G = nene.run_gcp(func='HF3c', verbose=True). qcdb.Molecule.run_gcp(self, func=None, dertype=None, verbose=1)¶; Compute geometrical BSSE correction via Grimme’s GCP program.; Function to call Grimme’s GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to self for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, func. Returns energy if dertype is 0, gradient; if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The gcp executable must be independently compiled and; found in PATH or PSIPATH. self may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.Molecule. Parameters. func (str, optional) – Name of method/basis combination or composite method for which to compute the correction; (e.g., HF/cc-pVDZ, DFT/def2-SVP, HF3c, PBEh3c).; dertype (int or str, optional) – Maximum derivative level at which to run GCP. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int, optional) – Amount of printing. Unused at present. Returns. energy (float) – When dertype=0, energy [Eh].; gradient (ndarray) – When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray) – When dertype=None,",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/gcp-1.html:3215,energy,energy,3215,psi4manual/1.4.0/gcp-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/gcp-1.html,10,['energy'],['energy']
Energy Efficiency,"'). PBEh-3c with default basis after basis set; set basis cc-pvdz; energy('pbeh3c/'). If only BSSE/basis set corrections (rather than total energies) are of; interest, the gcp program can be run independently of the scf; through the python function run_gcp(). (This function; is the same PSI4/gcp interface that is called during an scf job.); This route is much faster than running a HF or DFT energy.; molecule nene {; Ne; Ne 1 2.0; }. nene.update_geometry(). >>> E, G = nene.run_gcp('hf3c'). >>> E, G = nene.run_gcp(func='HF3c', verbose=True). qcdb.Molecule.run_gcp(self, func=None, dertype=None, verbose=1)¶; Compute geometrical BSSE correction via Grimme’s GCP program.; Function to call Grimme’s GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to self for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, func. Returns energy if dertype is 0, gradient; if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The gcp executable must be independently compiled and; found in PATH or PSIPATH. self may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.Molecule. Parameters:. func (Optional[str]) – Name of method/basis combination or composite method for which to compute the correction; (e.g., HF/cc-pVDZ, DFT/def2-SVP, HF3c, PBEh3c).; dertype (Union[int, str, None]) – Maximum derivative level at which to run GCP. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int) – Amount of printing. Unused at present. Returns:. energy (float) – When dertype=0, energy [Eh].; gradient (ndarray) – When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray) – When dertype=None, both e",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/gcp.html:3755,energy,energy,3755,psi4manual/1.7.x/gcp.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/gcp.html,4,['energy'],['energy']
Energy Efficiency,"'). run_fnodfcc(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a DF-CCSD(T) computation.; >>> energy('df-ccsd(t)'). run_libfock(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a calculation through libfock, namely RCPHF,; RCIS, RTDHF, RTDA, and RTDDFT. run_mcscf(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a multiconfigurational self-consistent-field calculation. run_mp2(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a MP2 calculation. run_mp2_5(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a MP2.5 calculation. run_mp2_5_gradient(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a MP3 gradient calculation. run_mp2_gradient(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a MP2 gradient calculation. run_mp2_select(name, **kwargs)[source]¶; Function selecting the algorithm for a MP2 energy call; and directing toward the OCC (conv MP2) or the DFMP2 modules. run_mp2_select_gradient(name, **kwargs)[source]¶; Function selecting the algorithm for a MP2 gradient call; and directing toward the OCC (conv MP2) or the DFMP2 modules. run_mp2c(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a coupled MP2 calculation. run_mp3(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a MP3 calculation. run_mp3_gradient(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a MP3 gradient calculation. run_mrcc(name, **kwargs)[source]¶; Function that prepares environment and input files; for a calculation calling Kallay’s MRCC code. run_ocepa(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; an orbital-optimized CEPA computation. run_ocepa_gradient(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; OCEPA gradient calculation. run_oldmp2(name, **kwar",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodoc_driver-1.html:9220,energy,energy,9220,psi4manual/4.0b5/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodoc_driver-1.html,2,['energy'],['energy']
Energy Efficiency,"'); psi4_io.set_specific_retention(PSIF_CHKPT, True). A guide to the contents of individual scratch files may be found at PSIOH Intermediate Files.; To circumvent difficulties with running multiple jobs in the same scratch, the; process ID (PID) of the Psi4 instance is incorporated into the full file; name; therefore, it is safe to use the same scratch directory for calculations; running simultaneously. This also means that if the user wants Psi4 to use; information from a previous file, like molecular orbitals, he needs to provide the; name of the file. This can be done through the restart_file option; energy('scf',restart_file='./psi.PID.name.filenumber'). where by default, PID is the process number, name the name of the molecule,; and filenumber is listed in content. Only the filenumber; is necessary for the driver to appropriately rename the file for the next Psi4; job, and if none is found it defaults to 32, a checkpoint file. If two or more files; are to be read, they need to be provided as a Python list; energy('scf',restart_file=['./file1.filenumber','./file2.filenumber']). Note that the restart_file options is only available for energy procedures as of now.; Executing Psi4 with the psi4 -m (for; messy) flag will prevent files being deleted at the end of the run:; psi4 -m. ~/.psi4rc File¶; If using the environment variable PSI_SCRATCH is inconvenient,; or if some psi4_io commands must be present in all input files,; the ~/.psi4rc resource file can be used (example psi4/samples/example_psi4rc_file).; All the commands mentioned in section Scratch Files and Elementary Restart can be used in this file,; namely:; psi4_io.set_default_path('/scratch/user'). to set up the scratch path,; import os; scratch_dir = os.environ.get('MYSCRATCH'); if scratch_dir:; psi4_io.set_default_path(scratch_dir + '/'). to set up the scratch path from a variable $MYSCRATCH,; psi4_io.set_specific_path(32, './'); psi4_io.set_specific_retention(32, True). which is equivalent to; psi4_io.se",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/external-1.html:4815,energy,energy,4815,psi4manual/1.0.0/external-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/external-1.html,2,['energy'],['energy']
Energy Efficiency,"')[source]¶; NYI Assigns basis name to all symbol atoms. set_com_fixed(_fix=True)[source]¶; NYI Fix the center of mass at its current frame.; Not used in libmints so not implemented. set_full_geometry(geom)[source]¶; Sets the full geometry (dummies included), given a N X 3 array of coordinates geom in Bohr.; >>> H2OH2O.set_full geometry([[1,2,3],[4,5,6],[7,8,9],[0,0,0],[-1,-2,-3],[-4,-5,-6],[-7,-8,-9]]). set_full_point_group(tol=1e-08)[source]¶; NYI Determine and set FULL point group. set_geometry(geom)[source]¶; Sets the geometry, given a N X 3 array of coordinates geom in Bohr.; >>> H2OH2O.set_geometry([[1,2,3],[4,5,6],[7,8,9],[-1,-2,-3],[-4,-5,-6],[-7,-8,-9]]). set_ghost_fragment(fr)[source]¶; Tags fragment index fr as composed of ghost atoms. set_ghost_fragments(ghosts)[source]¶; Tags the fragments in array ghosts as composed of ghost atoms. set_has_zmatrix(tf)[source]¶; Sets the presence of any zmatrix entry; >>> H2OH2O.set_has_zmatrix(True). set_molecular_charge(charge)[source]¶; Sets the molecular charge; >>> H2OH2O.set_molecular_charge(-2). set_multiplicity(mult)[source]¶; Sets the multiplicity (defined as 2Ms + 1); >>> H2OH2O.set_multiplicity(3). set_name(name)[source]¶; Set molecule name; >>> H2OH2O.set_name('water_dimer'). set_point_group(pg)[source]¶; NYI Set the point group to object pg. set_units(units)[source]¶; Sets the geometry units; >>> H2OH2O.set_units('Angstom'). set_variable(vstr, val)[source]¶; Assigns the value val to the variable labelled string in the; list of geometry variables. Also calls update_geometry(). sym_label()[source]¶; NYI Returns the symmetry label. symbol(atom)[source]¶; Returns the cleaned up label of the atom (C2 => C, H4 = H) (0-indexed); >>> print H2OH2O.symbol(4); H. symmetrize()[source]¶; NYI Force the molecule to have the symmetry specified in pg.; This is to handle noise coming in from optking. symmetry_frame(tol=1e-08)[source]¶; Determine symmetry reference frame. If noreorient is not set,; this is the rotation matrix",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodoc_driver-1.html:60315,charge,charge,60315,psi4manual/4.0b5/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodoc_driver-1.html,4,['charge'],['charge']
Energy Efficiency,"', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError(['select_omp2_gradient', name, 'MP2_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_omp2_property(name, **kwargs):; """"""Function selecting the algorithm for an OMP2 property call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP2_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_property. if func is None:; raise ManagedMethodError(['select_omp2_property', name, 'MP2_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_mp3(name, **kwargs):; """"""Function selecting the algorithm for a MP3 energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ/fnocc/detci. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'DETCI': # no default for this case; func = run_detci; elif module in ['']:; psi4.print_out(""""""\nThis method ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:7835,energy,energy,7835,psi4manual/1.0.0/_modules/procedures/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html,1,['energy'],['energy']
Energy Efficiency,"', corl_scheme='corl_xtpl_helgaker_2', func=cbs). Note; As of October 2018, only two explicit `deltaN_[wfn,basis,scheme]` sets of options are active; if more delta functions are required, use the `cbs_metadata` interface. Also, temporarily extrapolations are performed on differences of target and scf total energies, rather than on correlation energies directly. This doesn’t affect the extrapolated values of the particular formulas defined here (though it does affect the betas, which are commented out), but it is sloppy and temporary and could affect any user-defined corl extrapolations. Output¶; At the beginning of a cbs() job is printed a listing of the individual; energy calculations which will be performed. The output snippet below is; from the example job [2] above. It shows first each model chemistry needed; to compute the aggregate model chemistry requested through cbs(). Then,; since, for example, an energy('ccsd(t)') yields CCSD(T), CCSD, MP2,; and SCF energy values, the wrapper condenses this task list into the second; list of minimum number of calculations which will actually be run.; Naive listing of computations required.; scf / aug-cc-pvqz for SCF TOTAL ENERGY; mp2 / aug-cc-pvtz for MP2 CORRELATION ENERGY; mp2 / aug-cc-pvqz for MP2 CORRELATION ENERGY; ccsd(t) / aug-cc-pvdz for CCSD(T) CORRELATION ENERGY; ccsd(t) / aug-cc-pvtz for CCSD(T) CORRELATION ENERGY; mp2 / aug-cc-pvdz for MP2 CORRELATION ENERGY; mp2 / aug-cc-pvtz for MP2 CORRELATION ENERGY. Enlightened listing of computations required.; mp2 / aug-cc-pvqz for MP2 CORRELATION ENERGY; ccsd(t) / aug-cc-pvdz for CCSD(T) CORRELATION ENERGY; ccsd(t) / aug-cc-pvtz for CCSD(T) CORRELATION ENERGY. At the end of a cbs() job is printed a summary section like the one below. First,; in the components section, are listed the results for each model chemistry available, whether; required for the cbs job (*) or not. Next, in the stages section, are listed the results for; each extrapolation. The energies of this s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/cbs.html:17869,energy,energy,17869,psi4manual/1.6.x/cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/cbs.html,10,['energy'],['energy']
Energy Efficiency,"', item); if ""npz"" in item:; fname = os.path.split(os.path.abspath(core.get_writer_file_prefix(molecule.name())))[1]; psi_scratch = core.IOManager.shared_object().get_default_path(); file_num = item.split('.')[-2]; targetfile = os.path.join(psi_scratch, fname + ""."" + file_num + "".npz""); else:; filenum = name_split[-1]; try:; filenum = int(filenum); except ValueError:; filenum = 32 # Default file number is the checkpoint one; psioh = core.IOManager.shared_object(); psio = core.IO.shared_object(); filepath = psioh.get_file_path(filenum); namespace = psio.get_default_namespace(); pid = str(os.getpid()); prefix = 'psi'; targetfile = filepath + prefix + '.' + pid + '.' + namespace + '.' + str(filenum); shutil.copy(item, targetfile). wfn = procedures['energy'][lowername](lowername, molecule=molecule, **kwargs). for postcallback in hooks['energy']['post']:; postcallback(lowername, wfn=wfn, **kwargs). optstash.restore(); if return_wfn: # TODO current energy safer than wfn.energy() for now, but should be revisited. # TODO place this with the associated call, very awkward to call this in other areas at the moment; if lowername in ['efp', 'mrcc', 'dmrg', 'psimrcc']:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the incoming reference wavefunction.\n\n""); elif 'sapt' in lowername:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the dimer SCF wavefunction.\n\n""). return (core.get_variable('CURRENT ENERGY'), wfn); else:; return core.get_variable('CURRENT ENERGY'). [docs]def gradient(name, **kwargs):; r""""""Function complementary to :py:func:~driver.optimize(). Carries out one gradient pass,; deciding analytic or finite difference. :returns: :py:class:`~psi4.core.Matrix` |w--w| Total electronic gradient in Hartrees/Bohr. :returns: (:py:class:`~psi4.core.Matrix`, :py:class:`~psi4.core.Wavefunction`) |w--w",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html:33345,energy,energy,33345,psi4manual/1.2.1/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html,1,['energy'],['energy']
Energy Efficiency,"', item); if ""npz"" in item:; fname = os.path.split(os.path.abspath(core.get_writer_file_prefix(molecule.name())))[1]; psi_scratch = core.IOManager.shared_object().get_default_path(); file_num = item.split('.')[-2]; targetfile = os.path.join(psi_scratch, fname + ""."" + file_num + "".npz""); else:; filenum = name_split[-1]; try:; filenum = int(filenum); except ValueError:; filenum = 32 # Default file number is the checkpoint one; psioh = core.IOManager.shared_object(); psio = core.IO.shared_object(); filepath = psioh.get_file_path(filenum); namespace = psio.get_default_namespace(); pid = str(os.getpid()); prefix = 'psi'; targetfile = filepath + prefix + '.' + pid + '.' + namespace + '.' + str(filenum); shutil.copy(item, targetfile). wfn = procedures['energy'][lowername](lowername, molecule=molecule, **kwargs). for postcallback in hooks['energy']['post']:; postcallback(lowername, wfn=wfn, **kwargs). optstash.restore(); if return_wfn: # TODO current energy safer than wfn.energy() for now, but should be revisited. # TODO place this with the associated call, very awkward to call this in other areas at the moment; if lowername in ['efp', 'mrcc', 'dmrg', 'psimrcc']:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the incoming reference wavefunction.\n\n""); elif 'sapt' in lowername:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the dimer SCF wavefunction.\n\n""). return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]def gradient(name, **kwargs):; r""""""Function complementary to :py:func:~driver.optimize(). Carries out one gradient pass,; deciding analytic or finite difference. :returns: :py:class:`~psi4.core.Matrix` |w--w| Total electronic gradient in Hartrees/Bohr. :returns: (:py:class:`~psi4.core.Matrix`, :py:class:`~psi4.core.Wavefunction`) |w--w| gradie",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html:35579,energy,energy,35579,psi4manual/1.3.2/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html,1,['energy'],['energy']
Energy Efficiency,"', lowername, kwargs.pop('freq_dertype', kwargs.pop('dertype', None))). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # S/R: Mode of operation- whether finite difference freq run in one job or files farmed out; freq_mode = kwargs.pop('mode', 'continuous').lower(); if freq_mode == 'continuous':; pass; elif freq_mode == 'sow':; if dertype == 2:; raise ValidationError(""""""Frequency execution mode 'sow' not valid for analytic Hessian calculation.""""""); elif freq_mode == 'reap':; freq_linkage = kwargs.get('linkage', None); if freq_linkage is None:; raise ValidationError(""""""Frequency execution mode 'reap' requires a linkage option.""""""); else:; raise ValidationError(""""""Frequency execution mode '%s' not valid."""""" % (freq_mode)). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash_conv = driver_util._set_convergence_criterion('energy', lowername, 8, 10, 8, 10, 8). # Select certain irreps; irrep = kwargs.get('irrep', -1); if irrep == -1:; pass # do all irreps; else:; irrep = driver_util.parse_cotton_irreps(irrep, molecule.schoenflies_symbol()); irrep -= 1 # A1 irrep is externally 1, internally 0; if dertype == 2:; core.print_out(""""""hessian() switching to finite difference by gradients for partial Hessian calculation.\n""""""); dertype = 1. # At stationary point?; if 'ref_gradient' in kwargs:; core.print_out(""""""hessian() using ref_gradient to assess stationary point.\n""""""); G0 = kwargs['ref_gradient']; else:; G0 = gradient(lowername, molecule=molecule, **kwargs); translations_projection_sound, rotations_projection_sound = _energy_is_invariant(G0); core.print_out('\n Based on options and gradient (rms={:.2E}), recommend {}projecting translations and {}projecting rotations.\n'.; format(G0.rms(), '' if translations_projection_sound else 'not ',; '' if rotations_projection_sound else 'not ')); if not core.has_option_chang",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html:69460,energy,energy,69460,psi4manual/1.2.1/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html,1,['energy'],['energy']
Energy Efficiency,"', lowername, kwargs.pop('freq_dertype', kwargs.pop('dertype', None))). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # S/R: Mode of operation- whether finite difference freq run in one job or files farmed out; freq_mode = kwargs.pop('mode', 'continuous').lower(); if freq_mode == 'continuous':; pass; elif freq_mode == 'sow':; if dertype == 2:; raise ValidationError(""""""Frequency execution mode 'sow' not valid for analytic Hessian calculation.""""""); elif freq_mode == 'reap':; freq_linkage = kwargs.get('linkage', None); if freq_linkage is None:; raise ValidationError(""""""Frequency execution mode 'reap' requires a linkage option.""""""); else:; raise ValidationError(""""""Frequency execution mode '%s' not valid."""""" % (freq_mode)). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash_conv = driver_util._set_convergence_criterion('energy', lowername, 8, 10, 8, 10, 8). # Select certain irreps; irrep = kwargs.get('irrep', -1); if irrep == -1:; pass # do all irreps; else:; irrep = driver_util.parse_cotton_irreps(irrep, molecule.schoenflies_symbol()); irrep -= 1 # A1 irrep is externally 1, internally 0; if dertype == 2:; core.print_out(""""""hessian() switching to finite difference by gradients for partial Hessian calculation.\n""""""); dertype = 1. # Does an analytic procedure exist for the requested method?; if dertype == 2:; core.print_out(""""""hessian() will perform analytic frequency computation.\n""""""). # We have the desired method. Do it.; wfn = procedures['hessian'][lowername](lowername, molecule=molecule, **kwargs); optstash.restore(); optstash_conv.restore(). # TODO: check that current energy's being set to the right figure when this code is actually used; core.set_variable('CURRENT ENERGY', wfn.energy()). if return_wfn:; return (wfn.hessian(), wfn); else:; return wfn.hessian(). elif dertype == 1:; core.print_out(""""""hes",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html:66661,energy,energy,66661,psi4manual/1.1.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html,1,['energy'],['energy']
Energy Efficiency,"', lowername, kwargs.pop('freq_dertype', kwargs.pop('dertype', None))). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', psi4.get_active_molecule()); molecule.update_geometry(). # S/R: Mode of operation- whether finite difference freq run in one job or files farmed out; freq_mode = kwargs.pop('mode', 'continuous').lower(); if freq_mode == 'continuous':; pass; elif freq_mode == 'sow':; if dertype == 2:; raise ValidationError(""""""Frequency execution mode 'sow' not valid for analytic Hessian calculation.""""""); elif freq_mode == 'reap':; freq_linkage = kwargs.get('linkage', None); if freq_linkage is None:; raise ValidationError(""""""Frequency execution mode 'reap' requires a linkage option.""""""); else:; raise ValidationError(""""""Frequency execution mode '%s' not valid."""""" % (freq_mode)). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash_conv = driver_util._set_convergence_criterion('energy', lowername, 8, 10, 8, 10, 8). # Select certain irreps; irrep = kwargs.get('irrep', -1); if irrep == -1:; pass # do all irreps; else:; irrep = driver_util.parse_cotton_irreps(irrep, molecule.schoenflies_symbol()); irrep -= 1 # A1 irrep is externally 1, internally 0. # Does an analytic procedure exist for the requested method?; if dertype == 2:; psi4.print_out(""""""hessian() will perform analytic frequency computation.\n""""""). # We have the desired method. Do it.; wfn = procedures['hessian'][lowername](lowername, molecule=molecule, **kwargs); optstash.restore(); optstash_conv.restore(). # TODO: check that current energy's being set to the right figure when this code is actually used; psi4.set_variable('CURRENT ENERGY', wfn.energy()). if return_wfn:; return (wfn.hessian(), wfn); else:; return wfn.hessian(). elif dertype == 1:; psi4.print_out(""""""hessian() will perform frequency computation by finite difference of analytic gradients.\n""""""). # Shifting the geometry so need to copy the active",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver.html:64824,energy,energy,64824,psi4manual/1.0.0/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver.html,1,['energy'],['energy']
Energy Efficiency,"', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_omp3_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OMP3 gradient call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError(['select_omp3_gradient', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_mp2p5(name, **kwargs):; """"""Function selecting the algorithm for a MP2.5 energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError(['select_mp2p5', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_mp2p5_gradient(name, **kwargs):; """"""Function selecting the algorithm for a MP2.5 gradient call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:11716,energy,energy,11716,psi4manual/1.0.0/_modules/procedures/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html,1,['energy'],['energy']
Energy Efficiency,"', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_mp2p5_gradient(name, **kwargs):; """"""Function selecting the algorithm for a MP2.5 gradient call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError(['select_mp2p5_gradient', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_omp2p5(name, **kwargs):; """"""Function selecting the algorithm for an OMP2.5 energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError(['select_omp2p5', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_omp2p5_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OMP2.5 gradient call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP_TYPE'); module = psi4.get_global_option('QC_MODULE'); # ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:13238,energy,energy,13238,psi4manual/1.0.0/_modules/procedures/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html,1,['energy'],['energy']
Energy Efficiency,"',; 'mp2',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'temp2=emp2_trip'],. 'hf-df-mp2': [; 'gdirect',; 'rhf',; 'eehf=energy',; '{df-mp2,basis_mp2=mp2fit}',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'temp2=emp2_trip'],. 'hf': [; 'rhf',; 'eehf=energy'],. 'mp2-f12': [; 'gdirect',; 'rhf',; 'eehf=energy',; 'mp2-f12',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'temp2=emp2_trip'],. 'df-mp2-f12': [; 'gdirect',; #'rhf',; '{df-hf,basis=jkfit}',; 'eehf=energy',; #'{df-mp2-f12,df_basis=mp2fit,df_basis_exch=jkfit,ri_basis=optrib}',; '{df-mp2-f12,df_basis=mp2fit,df_basis_exch=jkfitb,ri_basis=jkfitb}',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'temp2=emp2_trip'],. 'df-mp2': [; 'gdirect',; '{df-hf,basis=jkfit}',; 'eehf=energy',; '{df-mp2,basis_mp2=mp2fit}',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'temp2=emp2_trip'],. 'df-hf': [; 'gdirect',; '{df-hf,basis=jkfit}',; 'eehf=energy'],. 'b3lyp-d': [; 'gdirect',; 'rks,b3lyp3',; 'eehf=energy',; 'dispcorr',; 'eehfd=eehf+edisp'],. 'df-b3lyp-d': [; 'gdirect',; '{df-rks,b3lyp3,basis=jkfit}',; 'eehf=energy',; 'dispcorr',; 'eehfd=eehf+edisp'],. 'b3lyp': [; 'gdirect',; 'rks,b3lyp3',; 'eehf=energy'],. 'df-b3lyp': [; 'gdirect',; '{df-rks,b3lyp3,basis=jkfit}',; 'eehf=energy'],. #'mp2c': [ # this job computes one part [E_disp(TDDFT)] of the three parts of a MP2C calculation; # # check that nfrag = 2; # 'gdirect',; # 'ga=1101.2; gb=1102.2',; # 'ca=2101.2; cb=2102.2\n',; #; # $spin = $cgmp{MLPmol1} - 1;; # 'SET,CHARGE=$cgmp{CHGmol1}',; # 'SET,SPIN=$spin',; # 'dummy',; # foreach $at (@monoBreal) { print $handle "",$at""; }; # ''; # '{df-hf,basis=jkfit,locorb=0; start,atdens; save,$ga}',; # '{df-ks,lhf,df_basis=dflhf,basis_coul=jkfitb,basis_exch=jkfitb; dftfac,1.0; start,$ga; save,$ca}',; # 'eehfa=energy; sapt; monomerA',; # '',; #; # $spin = $cgmp{MLPmol2} - 1;; # print $handle ""SET,CHARGE=$cgmp{CHGmol2}\nSET,SPIN=$spin\ndummy"";; # foreach $at (@monoAreal) { print $handle "",$at""; }; # print $handle ""\n{df-hf,basis=jkfit,locorb=0; start,atdens; save,\$gb}\n"";; # print $handle ""{df",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro.html:5697,energy,energy,5697,psi4manual/1.0.0/_modules/qcdb/molpro.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro.html,1,['energy'],['energy']
Energy Efficiency,"',; 'mrccsd(t)': 'CCSD(T) TOTAL ENERGY'}; VARH['mrccsdt'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'mrccsdt': 'CCSDT TOTAL ENERGY'}; VARH['mrccsdt(q)'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'mrccsdt': 'CCSDT TOTAL ENERGY',; 'mrccsdt(q)': 'CCSDT(Q) TOTAL ENERGY'}. for cilevel in range(2, 99):; VARH[f'ci{cilevel}'] = {; 'hf': 'HF TOTAL ENERGY',; f'ci{cilevel}': 'CI TOTAL ENERGY'}. for mplevel in range(5, 99):; VARH[f'mp{mplevel}'] = {; 'hf': 'HF TOTAL ENERGY',; f'mp{mplevel}': f'MP{mplevel} TOTAL ENERGY'}; for mplevel2 in range(2, mplevel):; VARH[f'mp{mplevel}'][f'mp{mplevel2}'] = f'MP{mplevel2} TOTAL ENERGY'. # Integrate CFOUR methods; VARH.update(cfour_psivar_list()); return VARH; # yapf: enable. VARH = return_energy_components(). [docs]def _get_default_xtpl(nbasis: int, xtpl_type: str) -> Callable:; """""" A helper function to determine default extrapolation type. Parameters; ----------; nbasis; Number of basis sets; xtpl_type; {'scf', 'corl'}; Extrapolation type: 'scf' for the total energy, 'corl' for just the; correlation component. Returns; -------; Callable; Extrapolation function to be used.; """""". if nbasis == 1 and xtpl_type in [""scf"", ""corl""]:; return ""xtpl_highest_1""; elif xtpl_type == ""scf"":; if nbasis == 2:; return ""scf_xtpl_helgaker_2""; elif nbasis == 3:; return ""scf_xtpl_helgaker_3""; else:; raise ValidationError(f""Wrong number of basis sets supplied to scf_xtpl: {nbasis}""); elif xtpl_type == ""corl"":; if nbasis == 2:; return ""corl_xtpl_helgaker_2""; else:; raise ValidationError(f""Wrong number of basis sets supplied to corl_xtpl: {nbasis}""); else:; raise ValidationError(f""Stage treatment must be 'corl' or 'scf', not '{xtpl_type}'""). def _validate_cbs_inputs(cbs_metadata: CBSMetadata, molecule: Union[""qcdb.Molecule"", core.Molecule]) -> CBSMetadata:; """""" A helper function which validates the ``cbs_metadata`` format,; expands basis sets, and provides sensible defaults for optional arguments. Parameters; ----------; cbs_meta",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html:16406,energy,energy,16406,psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,1,['energy'],['energy']
Energy Efficiency,"',; 'mrccsd(t)': 'CCSD(T) TOTAL ENERGY'}; VARH['mrccsdt'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'mrccsdt': 'CCSDT TOTAL ENERGY'}; VARH['mrccsdt(q)'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'mrccsdt': 'CCSDT TOTAL ENERGY',; 'mrccsdt(q)': 'CCSDT(Q) TOTAL ENERGY'}. for cilevel in range(2, 99):; VARH[f'ci{cilevel}'] = {; 'hf': 'HF TOTAL ENERGY',; f'ci{cilevel}': 'CI TOTAL ENERGY'}. for mplevel in range(5, 99):; VARH[f'mp{mplevel}'] = {; 'hf': 'HF TOTAL ENERGY',; f'mp{mplevel}': f'MP{mplevel} TOTAL ENERGY'}; for mplevel2 in range(2, mplevel):; VARH[f'mp{mplevel}'][f'mp{mplevel2}'] = f'MP{mplevel2} TOTAL ENERGY'. # Integrate CFOUR methods; VARH.update(cfour_psivar_list()); return VARH; # yapf: enable. VARH = return_energy_components(). [docs]def _get_default_xtpl(nbasis: int, xtpl_type: str) -> Callable:; """""" A helper function to determine default extrapolation type. Parameters; ----------; nbasis; Number of basis sets; xtpl_type; {'scf', 'corl'}; Extrapolation type: 'scf' for the total energy, 'corl' for just the; correlation component. Returns; -------; Callable; Extrapolation function to be used.; """""". if nbasis == 1 and xtpl_type in [""scf"", ""corl""]:; return xtpl_highest_1; elif xtpl_type == ""scf"":; if nbasis == 2:; return scf_xtpl_helgaker_2; elif nbasis == 3:; return scf_xtpl_helgaker_3; else:; raise ValidationError(f""Wrong number of basis sets supplied to scf_xtpl: {nbasis}""); elif xtpl_type == ""corl"":; if nbasis == 2:; return corl_xtpl_helgaker_2; else:; raise ValidationError(f""Wrong number of basis sets supplied to corl_xtpl: {nbasis}""); else:; raise ValidationError(f""Stage treatment must be 'corl' or 'scf', not '{xtpl_type}'""). def _validate_cbs_inputs(cbs_metadata, molecule):; """""" A helper function which validates the ``cbs_metadata`` format,; expands basis sets, and provides sensible defaults for optional arguments. Parameters; ----------; cbs_metadata : list; List of dicts containing CBS stage keywords.; molecule : qcdb.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:28673,energy,energy,28673,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,2,['energy'],['energy']
Energy Efficiency,"'.join(alt_method_name)). raise ValidationError(""""""Derivative method 'name' %s and derivative level 'dertype' %s are not available.%s""""""; % (method_name, str(dertype), alternatives)). return dertype. def _energy_is_invariant(gradient, stationary_criterion=1.e-2):; """"""Polls options and probes `gradient` to return whether current method; and system expected to be invariant to translations and rotations of; the coordinate system. """"""; stationary_point = gradient.rms() < stationary_criterion # 1.e-2 pulled out of a hat. efp = core.get_active_efp(); efp_present = efp.nfragments() > 0. translations_projection_sound = (not core.get_option('SCF', 'EXTERN') and; not core.get_option('SCF', 'PERTURB_H') and; not efp_present); rotations_projection_sound = (translations_projection_sound and; stationary_point). return translations_projection_sound, rotations_projection_sound. [docs]def energy(name, **kwargs):; r""""""Function to compute the single-point electronic energy. :returns: *float* |w--w| Total electronic energy in Hartrees. SAPT & EFP return interaction energy. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY <CURRENTENERGY>`; * :psivar:`CURRENT REFERENCE ENERGY <CURRENTREFERENCEENERGY>`; * :psivar:`CURRENT CORRELATION ENERGY <CURRENTCORRELATIONENERGY>`. :type name: string; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type restart_file: string; :",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html:4769,energy,energy,4769,psi4manual/1.2.1/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html,1,['energy'],['energy']
Energy Efficiency,"': 'CCSDT TOTAL ENERGY',; 'mrccsdt(q)': 'CCSDT(Q) TOTAL ENERGY'}. for cilevel in range(2, 99):; VARH['ci%s' % (str(cilevel))] = {; 'scf': 'SCF TOTAL ENERGY',; 'ci%s' % (str(cilevel)): 'CI TOTAL ENERGY'}. for mplevel in range(5, 99):; VARH['mp%s' % (str(mplevel))] = {; 'hf': 'HF TOTAL ENERGY',; 'mp%s' % (str(mplevel)): 'MP%s TOTAL ENERGY' % (str(mplevel))}; for mplevel2 in range(2, mplevel):; VARH['mp%s' % (str(mplevel))]['mp%s' % (str(mplevel2))] = \; 'MP%s TOTAL ENERGY' % (str(mplevel2)). # Integrate CFOUR methods; VARH.update(cfour_psivar_list()); return VARH. VARH = return_energy_components(). ###################################; ## Start of Complete Basis Set ##; ###################################. [docs]def complete_basis_set(func, label, **kwargs):; r""""""Function to define a multistage energy method from combinations of; basis set extrapolations and delta corrections and condense the; components into a minimum number of calculations. :aliases: cbs(). :returns: (*float*) -- Total electronic energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CBS TOTAL ENERGY <CBSTOTALENERGY>`; * :psivar:`CBS REFERENCE ENERGY <CBSREFERENCEENERGY>`; * :psivar:`CBS CORRELATION ENERGY <CBSCORRELATIONENERGY>`; * :psivar:`CURRENT ENERGY <CURRENTENERGY>`; * :psivar:`CURRENT REFERENCE ENERGY <CURRENTREFERENCEENERGY>`; * :psivar:`CURRENT CORRELATION ENERGY <CURRENTCORRELATIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - No way to tell function to boost fitting basis size for all calculations. - No way to extrapolate def2 family basis sets. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in several; sequential stages (scf, corl, delta, delta2, delta3, delta4, delta5) covering treatment; of the reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction, etc.. Each is activated by its; stage_wfn key",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:17917,energy,energy,17917,psi4manual/1.0.0/_modules/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html,1,['energy'],['energy']
Energy Efficiency,"'; Calls predefined subsets of the requested database, either; 'small', a few of the smallest database members,; 'large', the largest of the database members, or; 'equilibrium', the equilibrium geometries for a database; composed of dissociation curves. 'BzBz_S' || 'FaOOFaON' || 'ArNe' || etc.; For databases composed of dissociation curves, individual; curves can be called by name. Consult the database python; files for available molecular systems. The choices for this; keyword are case sensitive and must match the database python file. [1,2,5] || ['1','2','5'] || ['BzMe-3.5', 'MeMe-5.0'] || etc.; Specify a list of database members to run. Consult the; database python files for available molecular systems. The; choices for this keyword are case sensitive and must match the; database python file. Examples :. >>> # [1] Two-stage SCF calculation on short, equilibrium, and long helium dimer; >>> db('scf','RGC10',cast_up='sto-3g',subset=['HeHe-0.85','HeHe-1.0','HeHe-1.5'], tabulate=['scf total energy','natom']). >>> # [2] Counterpoise-corrected interaction energies for three complexes in S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('dfmp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). Output¶; At the beginning of a database job is printed a listing of the individual system; calculations which will be performed. The output snippet below is from the example job [1]; above. It shows each reagent required for the subset of database reactions requested.; Note that this is an un-coun",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/db-1.html:4947,energy,energy,4947,psi4manual/4.0b2/db-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/db-1.html,2,['energy'],['energy']
Energy Efficiency,"'DERTYPE']). if core.get_global_option('SCF_TYPE') in ['CD', 'DF', 'MEM_DF', 'DISK_DF']:; raise ValidationError('OCC gradients need conventional SCF reference.'). director = {; ""mp2"": {""wfn_type"": ""OMP2"", ""orb_opt"": ""FALSE"",},; ""omp2"": {""wfn_type"": ""OMP2"", ""orb_opt"": ""TRUE"", },; ""conv-omp2"": {""wfn_type"": ""OMP2"", ""orb_opt"": ""TRUE"", },. ""mp2.5"": {""wfn_type"": ""OMP2.5"", ""orb_opt"": ""FALSE"",},; ""omp2.5"": {""wfn_type"": ""OMP2.5"", ""orb_opt"": ""TRUE"", },. ""mp3"": {""wfn_type"": ""OMP3"", ""orb_opt"": ""FALSE"",},; ""omp3"": {""wfn_type"": ""OMP3"", ""orb_opt"": ""TRUE"", },. ""oremp2"": {""wfn_type"": ""OREMP"", ""orb_opt"": ""TRUE"", },. ""lccd"": {""wfn_type"": ""OCEPA"", ""orb_opt"": ""FALSE"",},; ""olccd"": {""wfn_type"": ""OCEPA"", ""orb_opt"": ""TRUE"", },; }. if name not in director:; raise ValidationError(f""Invalid method {name} for OCC gradient""). for k, v in director[name].items():; core.set_local_option(""OCC"", k.upper(), v). core.set_global_option('DERTYPE', 'FIRST'). # locking out SCS through explicit keyword setting; # * so that current energy must match call; # * since grads not avail for scs; core.set_local_option('OCC', 'SPIN_SCALE_TYPE', 'NONE'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(). occ_wfn = core.occ(ref_wfn). derivobj = core.Deriv(occ_wfn); grad = derivobj.compute(). occ_wfn.set_gradient(grad); occ_wfn.set_variable(f""{name.upper()} TOTAL GRADIENT"", grad). # Shove variables into global space; keep_custom_spin_scaling = core.has_option_changed(""OCC"", ""SS_SCALE"") or core.has_option_changed(""OCC"", ""OS_SCALE""); for k, v in occ_wfn.variables().items():; # Custom spin component scaling variables are meaningless if custom scalings hasn't been set. Delete them.; if k.startswith(""CUSTOM",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:78933,energy,energy,78933,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,4,['energy'],['energy']
Energy Efficiency,"'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); core.print_out(""""""hessian() will perform analytic frequency computation.\n""""""); wfn = procedures['hessian'][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return hessian(): {wfn.energy()}""); logger.info(nppp(wfn.hessian().np)). wfn.set_gradient(G0); basisstash.restore(); optstash.restore(); optstash_conv.restore(). #if isinstance(lowername, str) and lowername in procedures['energy']:; # # this correctly filters out cbs fn and ""hf/cc-pvtz""; # # it probably incorrectly filters out mp5, but reconsider in DDD; # core.set_variable(f""CURRENT HESSIAN"", H); # core.set_variable(f""{lowername.upper()} TOTAL HESSIAN"", H); # core.set_variable(f""{lowername.upper()} TOTAL GRADIENT"", G0); # wfn.set_variable(f""{lowername.upper()} TOTAL HESSIAN"", H); # wfn.set_variable(f""{lowername.upper()} TOTAL GRADIENT"", G0); # TODO: check that current energy's being set to the right figure when this code is actually used; core.set_variable('CURRENT ENERGY', wfn.energy()); core.set_variable(""CURRENT GRADIENT"", G0); driver_findif.hessian_write(wfn). if return_wfn:; return (wfn.hessian(), wfn); else:; return wfn.hessian(). [docs]; def frequency(name, **kwargs):; r""""""Function to compute harmonic vibrational frequencies. :aliases: frequencies(), freq(). :returns: *float* |w--w| Total electronic energy in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:82825,energy,energy,82825,psi4manual/1.8.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html,3,['energy'],['energy']
Energy Efficiency,"'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); core.print_out(""""""hessian() will perform analytic frequency computation.\n""""""); wfn = procedures['hessian'][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return hessian(): {wfn.energy()}""); logger.info(nppp(wfn.hessian().np)). wfn.set_gradient(G0); basisstash.restore(); optstash.restore(); optstash_conv.restore(). #if isinstance(lowername, str) and lowername in procedures['energy']:; # # this correctly filters out cbs fn and ""hf/cc-pvtz""; # # it probably incorrectly filters out mp5, but reconsider in DDD; # core.set_variable(f""CURRENT HESSIAN"", H); # core.set_variable(f""{lowername.upper()} TOTAL HESSIAN"", H); # core.set_variable(f""{lowername.upper()} TOTAL GRADIENT"", G0); # wfn.set_variable(f""{lowername.upper()} TOTAL HESSIAN"", H); # wfn.set_variable(f""{lowername.upper()} TOTAL GRADIENT"", G0); # TODO: check that current energy's being set to the right figure when this code is actually used; core.set_variable('CURRENT ENERGY', wfn.energy()); core.set_variable(""CURRENT GRADIENT"", G0); driver_findif.hessian_write(wfn). if return_wfn:; return (wfn.hessian(), wfn); else:; return wfn.hessian(). [docs]def frequency(name, **kwargs):; r""""""Function to compute harmonic vibrational frequencies. :aliases: frequencies(), freq(). :returns: *float* |w--w| Total electronic energy in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html:74851,energy,energy,74851,psi4manual/1.6.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html,2,['energy'],['energy']
Energy Efficiency,"'HBC60' Thanthiriwatte et al. JCTC 7 88 (2011).; \(\Rightarrow\) 'HBC6A' \(\Leftarrow\) Marshall et al. JCP 135 194102 (2011).; 'HBC6ARLX' Sherrill group, unpublished. subset. 'small'; 'large'; 'equilibrium' equilibrium points for the six systems; 'FaOOFaOO' dissociation curve for formic acid dimer; 'FaONFaON' dissociation curve for formamide dimer; 'FaNNFaNN' dissociation curve for formamidine dimer; 'FaOOFaON' dissociation curve for formic acid- formamide complex; 'FaONFaNN' dissociation curve for formamide- formamidine complex; 'FaOOFaNN' dissociation curve for formic acid- formamidine complex. HTR40¶. Database of Hydrogen transfer reactions.; Geometries from Bozkaya and Sherrill.; Reference energies from Bozkaya and Sherrill. benchmark. '<benchmark_name>' <Reference>.; \(\Rightarrow\) '<default_benchmark_name>' \(\Leftarrow\) <Reference>. subset. 'small' <members_description>; 'large' <members_description>; '<subset>' <members_description>. BENCH12¶. Database of <description of members and reference energy type>.; Geometries from <Reference>.; Reference interaction energies from <Reference>. benchmark. '<benchmark_name>' <Reference>.; \(\Rightarrow\) '<default_benchmark_name>' \(\Leftarrow\) <Reference>. subset. 'small'; 'large'; 'alkenes'; 'alkanes'; 'acenes'; 'thiophenes'; 'h2o_size'; 'h2o_shape'; 'atoms'; 'S22_HB'; 'S22_MX'; 'S22_DD'. O24by5mb¶. Database (O24) of interaction energies for small open-shell high-spin bimolecular complexes.; Geometries taken from https://gitlab.com/piotr.zuchowski/o24x5/-/tree/4ec3cae0546b6ae4f4f2cf28482cd164c8323cc6.; Reference interaction energies taken from J. Chem. Phys. 154, 134106 (2021) https://doi.org/10.1063/5.0043793.; Variant with ghosted hydrogen as midbonds in the COM. no | name | subset. 1 | CN - He | DD; 2 | NH - He | DD; 3 | C2H3 - C2H4 | DD; 4 | O2 - H2 | DD; 5 | NH - Ar | DD; 6 | CN - Ar | DD; 7 | O2 - N2 | DD; 8 | H2O - O2(sp) | DD; 9 | O2 - O2 | DD. 10 | NH - NH | ED; 11 | CH2O - NH2 | ED; 12 | H2O - Na | ED; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_available_databases.html:11136,energy,energy,11136,psi4manual/master/autodoc_available_databases.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_available_databases.html,2,['energy'],['energy']
Energy Efficiency,"'Helgaker SCF (%s, %s) beta' % (zLO, zHI); beta.subtract(valueLO); beta.scale(beta_division); beta.scale(beta_mult). value = valueHI.clone(); value.subtract(beta); value.name = 'Helgaker SCF (%s, %s) data' % (zLO, zHI). if verbose > 2:; core.print_out(""""""\n ==> Helgaker 2-point exponential SCF extrapolation for method: %s <==\n\n"""""" %; (functionname.upper())); core.print_out("""""" LO-zeta (%s)"""""" % str(zLO)); core.print_out("""""" LO-zeta Data""""""); valueLO.print_out(); core.print_out("""""" HI-zeta (%s)"""""" % str(zHI)); core.print_out("""""" HI-zeta Data""""""); valueHI.print_out(); core.print_out("""""" Extrapolated Data:\n""""""); value.print_out(); core.print_out("""""" Alpha (exponent) Value: %16.8f\n"""""" % (alpha)); core.print_out("""""" Beta Data:\n""""""); beta.print_out(). return value. else:; raise ValidationError(""scf_xtpl_helgaker_2: datatype is not recognized '%s'."" % type(valueLO)). [docs]def scf_xtpl_truhlar_2(functionname: str, zLO: int, valueLO: float, zHI: int, valueHI: float, verbose: bool = True, alpha: float = None):; r""""""Extrapolation scheme using power form for reference energies with two adjacent; zeta-level bases. Used by :py:func:`~psi4.cbs`. Parameters; ----------; functionname; Name of the CBS component.; zLO; Lower zeta level.; valueLO; Lower value used for extrapolation.; zHI; Higher zeta level. Should be equal to zLO + 1.; valueHI; Higher value used for extrapolation.; alpha; Overrides the default :math:`\alpha = 3.4`. Returns; -------; float; Returns :math:`E_{total}^{\infty}`, see below. Notes; -----; The extrapolation is calculated according to [2]_:; :math:`E_{total}^X = E_{total}^{\infty} + \beta X^{-\alpha}, \alpha = 3.4`. References; ----------. .. [2] Truhlar, Chem. Phys. Lett. 294 (1998) 45-48,; DOI: 10.1016/S0009-2614(98)00866-5. """""". if type(valueLO) != type(valueHI):; raise ValidationError(; ""scf_xtpl_truhlar_2: Inputs must be of the same datatype! (%s, %s)"" % (type(valueLO), type(valueHI))). if alpha is None:; alpha = 3.40. beta_division = 1 / (zHI**(-1 *",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:10600,power,power,10600,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,2,['power'],['power']
Energy Efficiency,"'MP2 CORRELATION ENERGY'); ce_mp3 = psi4.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; psi4.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; psi4.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; psi4.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); psi4.set_variable('CURRENT ENERGY', e_mp25) # geometry optimizer tracks this variable, permits; # MP2.5 finite difference optimizations; # build string of title banner and print results; banners = ''; banners += """"""psi4.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""psi4.print_out('\\n')\n\n""""""; exec banners. tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); psi4.print_out(tables) # prints nice header and table of all involved quantities to output file. return e_mp25. One final step is necessary. At the end of the aliases.py file, add; the following line.; procedures['energy']['mp2.5'] = run_mp2_5. This permits the newly defined MP2.5 method to be called in the input file; with the following command.; energy('mp2.5'). Previous topic; Customization: Adding Simple Extensions; Next topic; Creating a Database. This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; Psi4 [1.0.0 6a9a71b] » ; Customization: Adding Simple Extensions ». © Copyright 2016, The Psi4 Project.; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/quickaddalias-1.html:2895,energy,energy,2895,psi4manual/1.0.0/quickaddalias-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/quickaddalias-1.html,2,['energy'],['energy']
Energy Efficiency,"'MP2 CORRELATION ENERGY'); ce_mp3 = psi4.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; psi4.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; psi4.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; psi4.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); psi4.set_variable('CURRENT ENERGY', e_mp25) # geometry optimizer tracks this variable, permits; # MP2.5 finite difference optimizations; # build string of title banner and print results; banners = ''; banners += """"""psi4.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""psi4.print_out('\\n')\n\n""""""; exec banners. tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); psi4.print_out(tables) # prints nice header and table of all involved quantities to output file. return e_mp25. One final step is necessary. At the end of the aliases.py file, add; the following line.; procedures['energy']['mp2.5'] = run_mp2_5. This permits the newly defined MP2.5 method to be called in the input file; with the following command.; energy('mp2.5'). Previous topic; User-Defined Basis Sets; Next topic; Creating a Database; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta5] » ; Customization: Adding Simple Extensions ». © Copyright 2013, The Psi4 Project.; Last updated on Jul 08, ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/quickaddalias-1.html:2833,energy,energy,2833,psi4manual/4.0b5/quickaddalias-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/quickaddalias-1.html,2,['energy'],['energy']
Energy Efficiency,"'Meta_a0', 1.0); X.set_parameter('Meta_a1', -0.1637571); X.set_parameter('Meta_a2', -0.1880028); X.set_parameter('Meta_a3', -0.4490609); X.set_parameter('Meta_a4', -0.0082359). C = build_functional('M_C'); C.set_name('dlDF_C'). # LSDA Correlation type is PW92, no parameters. # GGA Correlation type is B97; C.set_parameter('B97_os_gamma', 0.0031 * 2.0); C.set_parameter('B97_os_a0', 1.00000); C.set_parameter('B97_os_a1', 5.9515308); C.set_parameter('B97_os_a2', -11.1602877). C.set_parameter('B97_ss_gamma', 0.06); C.set_parameter('B97_ss_a0', 1.00000); C.set_parameter('B97_ss_a1', -2.5960897); C.set_parameter('B97_ss_a2', 2.2233793). # Meta Correlation type is Becke metric, no parameters. # Add the functionals in; sup.add_x_functional(X); sup.add_c_functional(C). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.6144129) # Hartree-Fock exact exchange; sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_dldfd09_superfunctional(name, npoints, deriv):. sup = build_dldf_superfunctional(name, npoints, deriv); sup.set_name('dlDF+D09'). # => +D <= #; sup.set_dispersion(PsiMod.Dispersion.build('-DAS2009', 1.0, 0.0, 0.0, 0.0)) # Does not have an s6, so set to 1.0. return sup. [docs]def build_dldfd_superfunctional(name, npoints, deriv):. sup = build_dldf_superfunctional(name, npoints, deriv); sup.set_name('dlDF+D'). # => +D <= #; sup.set_dispersion(PsiMod.Dispersion.build('-DAS2010', 1.0, 0.0, 0.0, 0.0)) # Does not have an s6, so set to 1.0. return sup. [docs]def build_hfd_superfunctional(name, npoints, deriv):. sup = PsiMod.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv); sup.set_name('HF+D'); sup.set_x_alpha(1.0). # => +D <= #; sup.set_dispersion(PsiMod.Dispersion.build('-DAS2010', 1.0, 0.0, 0.0, 0.0)) # Does not have an s6, so set to 1.0. sup.allocate(); return sup. [docs]def build_b2plyp_superfunctional(name, npoints, deriv):. # Call t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/functional.html:68227,allocate,allocate,68227,psi4manual/4.0b4/_modules/functional.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/functional.html,1,['allocate'],['allocate']
Energy Efficiency,"'Meta_a0', 1.0); X.set_parameter('Meta_a1', -0.1637571); X.set_parameter('Meta_a2', -0.1880028); X.set_parameter('Meta_a3', -0.4490609); X.set_parameter('Meta_a4', -0.0082359). C = build_functional('M_C'); C.set_name('dlDF_C'). # LSDA Correlation type is PW92, no parameters. # GGA Correlation type is B97; C.set_parameter('B97_os_gamma', 0.0031 * 2.0); C.set_parameter('B97_os_a0', 1.00000); C.set_parameter('B97_os_a1', 5.9515308); C.set_parameter('B97_os_a2', -11.1602877). C.set_parameter('B97_ss_gamma', 0.06); C.set_parameter('B97_ss_a0', 1.00000); C.set_parameter('B97_ss_a1', -2.5960897); C.set_parameter('B97_ss_a2', 2.2233793). # Meta Correlation type is Becke metric, no parameters. # Add the functionals in; sup.add_x_functional(X); sup.add_c_functional(C). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.6144129) # Hartree-Fock exact exchange; sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_dldfd09_superfunctional(name, npoints, deriv):. sup = build_dldf_superfunctional(name, npoints, deriv); sup.set_name('dlDF+D09'). # => +D <= #; sup.set_dispersion(psi4.Dispersion.build('-DAS2009', 1.0, 0.0, 0.0, 0.0)) # Does not have an s6, so set to 1.0. return sup. [docs]def build_dldfd_superfunctional(name, npoints, deriv):. sup = build_dldf_superfunctional(name, npoints, deriv); sup.set_name('dlDF+D'). # => +D <= #; sup.set_dispersion(psi4.Dispersion.build('-DAS2010', 1.0, 0.0, 0.0, 0.0)) # Does not have an s6, so set to 1.0. return sup. [docs]def build_hfd_superfunctional(name, npoints, deriv):. sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv); sup.set_name('HF+D'); sup.set_x_alpha(1.0). # => +D <= #; sup.set_dispersion(psi4.Dispersion.build('-DAS2010', 1.0, 0.0, 0.0, 0.0)) # Does not have an s6, so set to 1.0. sup.allocate(); return sup. [docs]def build_b2plyp_superfunctional(name, npoints, deriv):. # Call this firs",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/functional.html:68857,allocate,allocate,68857,psi4manual/4.0b5/_modules/functional.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/functional.html,2,['allocate'],['allocate']
Energy Efficiency,"'ROHF', 'RKS', 'UKS']:; if mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_property. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_olccd_property(name, **kwargs):; """"""Function selecting the algorithm for an OLCCD property call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_property. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp3(name, **kwargs):; """"""Function selecting the algorithm for a MP3 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'DETCI':; raise UpgradeHelper(""energy('mp3')"", ""energy('zapt3')"", 1.7,; "" Replace method MP with method ZAPT for ROHF reference. DETCI is orders-",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:11115,energy,energy,11115,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,4,['energy'],['energy']
Energy Efficiency,"'SCF', 'SCF_TYPE') == 'CD':; if (dertype == 1):; raise ValidationError('No analytic derivatives for SCF_TYPE CD.'). # Make sure the molecule the user provided is the active one; if ('molecule' in kwargs):; activate(kwargs['molecule']); del kwargs['molecule']; molecule = psi4.get_active_molecule(); molecule.update_geometry(); psi4.set_global_option('BASIS', psi4.get_global_option('BASIS')). # S/R: Mode of operation- whether finite difference opt run in one job or files farmed out; opt_mode = 'continuous'; if ('mode' in kwargs) and (dertype == 0):; opt_mode = kwargs['mode']. if (opt_mode.lower() == 'continuous'):; pass; elif (opt_mode.lower() == 'sow'):; pass; elif (opt_mode.lower() == 'reap'):; if('linkage' in kwargs):; opt_linkage = kwargs['linkage']; else:; raise ValidationError('Optimize execution mode \'reap\' requires a linkage option.'); else:; raise ValidationError('Optimize execution mode \'%s\' not valid.' % (opt_mode)). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); if not psi4.has_option_changed('SCF', 'E_CONVERGENCE'):; if procedures['energy'][lowername] == run_scf or procedures['energy'][lowername] == run_dft:; psi4.set_local_option('SCF', 'E_CONVERGENCE', 8); else:; psi4.set_local_option('SCF', 'E_CONVERGENCE', 10); if not psi4.has_option_changed('SCF', 'D_CONVERGENCE'):; if procedures['energy'][lowername] == run_scf or procedures['energy'][lowername] == run_dft:; psi4.set_local_option('SCF', 'D_CONVERGENCE', 8); else:; psi4.set_local_option('SCF', 'D_CONVERGENCE', 10). # Set post-scf convergence criteria (global will cover all correlated modules); if not psi4.has_global_option_changed('E_CONVERGENCE'):; if not procedures['energy'][lowername] == run_scf and not procedures['energy'][lowername] == run_dft:; psi4.set_global_option('E_CONVERGENCE', 8). # Does dertype indicate an analytic procedure both exists and is wanted?; if (dertype == 1):; # Nothing to it but to do it. Gradient information is save",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/driver.html:34079,energy,energy,34079,psi4manual/4.0b5/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/driver.html,1,['energy'],['energy']
Energy Efficiency,"'\n'); p4util.banner('Loading displacement %d of %d' % (n + 1, ndisp)). # Print information to the screen; print(' %d' % (n + 1), end=""""); if (n + 1) == ndisp:; print('\n', end=''); sys.stdout.flush(). # Load in displacement into the active molecule; molecule.set_geometry(displacement). # Perform the energy calculation; func(lowername, **kwargs). # Save the energy; energies.append(psi4.get_variable('CURRENT ENERGY')). # clean may be necessary when changing irreps of displacements; psi4.clean(). # S/R: Write each displaced geometry to an input file; elif (freq_mode.lower() == 'sow'):; molecule.set_geometry(displacement). # S/R: Prepare molecule, options, and kwargs; freagent = open('%s.in' % (rfile), 'w'); freagent.write('# This is a psi4 input file auto-generated from the gradient() wrapper.\n\n'); freagent.write(p4util.format_molecule_for_input(molecule)); freagent.write(p4util.format_options_for_input()); p4util.format_kwargs_for_input(freagent, **kwargs). # S/R: Prepare function call and energy save; freagent.write(""""""electronic_energy = %s('%s', **kwargs)\n\n"""""" % (func.__name__, lowername)); freagent.write(""""""psi4.print_out('\\nHESSIAN RESULT: computation %d for item %d """""" % (os.getpid(), n + 1)); freagent.write(""""""yields electronic energy %20.12f\\n' % (electronic_energy))\n\n""""""); freagent.close(). # S/R: Read energy from each displaced geometry output file and save in energies array; elif (freq_mode.lower() == 'reap'):; exec(banners); psi4.set_variable('NUCLEAR REPULSION ENERGY', molecule.nuclear_repulsion_energy()); energies.append(p4util.extract_sowreap_from_output(rfile, 'HESSIAN', n, freq_linkage, True)). # S/R: Quit sow after writing files; if (freq_mode.lower() == 'sow'):; optstash.restore(); return None. # Obtain the gradient. This function stores the gradient in the wavefunction.; psi4.fd_freq_0(energies, irrep). print(' Computation complete.'). # Clear the ""parent"" symmetry now; psi4.set_parent_symmetry(""""). # TODO: These need to be restored to the",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/driver.html:69760,energy,energy,69760,psi4manual/4.0b5/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/driver.html,1,['energy'],['energy']
Energy Efficiency,"'],; ['DERTYPE'],; ['CCDENSITY', 'WFN'],; ['CCLAMBDA', 'WFN']). PsiMod.set_global_option('DERTYPE', 'FIRST'). if (name.lower() == 'eom-ccsd'):; PsiMod.set_global_option('WFN', 'EOM_CCSD'); energy = run_eom_cc(name, **kwargs); PsiMod.set_global_option('WFN', 'EOM_CCSD'). PsiMod.set_local_option('CCLAMBDA', 'WFN', 'EOM_CCSD'); PsiMod.set_local_option('CCDENSITY', 'WFN', 'EOM_CCSD'); PsiMod.set_local_option('CCLAMBDA', 'ZETA', 'FALSE'); PsiMod.set_local_option('CCDENSITY', 'ZETA', 'FALSE'); PsiMod.set_local_option('CCDENSITY', 'XI', 'TRUE'); PsiMod.cclambda(); PsiMod.ccdensity(); PsiMod.set_local_option('CCLAMBDA', 'ZETA', 'TRUE'); PsiMod.set_local_option('CCDENSITY', 'ZETA', 'TRUE'); PsiMod.set_local_option('CCDENSITY', 'XI', 'FALSE'); PsiMod.cclambda(); PsiMod.ccdensity(); PsiMod.deriv(). optstash.restore(). [docs]def run_adc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an algebraic diagrammatic construction calculation. .. caution:: Get rid of active molecule lines- should be handled in energy. """"""; molecule = PsiMod.get_active_molecule(); if 'molecule' in kwargs:; molecule = kwargs.pop('molecule'). if not molecule:; raise ValueNotSet('no molecule found'). PsiMod.scf(). return PsiMod.adc(). [docs]def run_dft(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-functional-theory calculation. """"""; optstash = OptionsState(; ['SCF', 'DFT_FUNCTIONAL'],; ['SCF', 'REFERENCE'],; ['DF_BASIS_MP2'],; ['DFMP2', 'MP2_OS_SCALE'],; ['DFMP2', 'MP2_SS_SCALE']). PsiMod.set_local_option('SCF', 'DFT_FUNCTIONAL', name). user_ref = PsiMod.get_option('SCF', 'REFERENCE'); if (user_ref == 'RHF'):; PsiMod.set_local_option('SCF', 'REFERENCE', 'RKS'); elif (user_ref == 'UHF'):; PsiMod.set_local_option('SCF', 'REFERENCE', 'UKS'); elif (user_ref == 'ROHF'):; raise ValidationError('ROHF reference for DFT is not available.'); elif (user_ref == 'CUHF'):; raise ValidationError('CUHF reference for DFT is not available.'). returnvalue = run_scf(",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/proc.html:21954,energy,energy,21954,psi4manual/4.0b3/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/proc.html,1,['energy'],['energy']
Energy Efficiency,"']. # By default, we occupy by tenths of electrons; foccs = [1.0, 0.9, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2, 0.1, 0.0]; if kwargs.has_key('foccs'):; foccs = kwargs['foccs']. # By default, HOMO and LUMO are both in alpha; N = 0;; for A in range(mol.natom()):; N += mol.Z(A); N -= charge0; N = int(N); Nb = int((N - mult0 + 1)/2); Na = int(N - Nb). charge = charge0; mult = mult0. # By default, nuke all the electrons; Nmin = 0;; if (kwargs.has_key('nmax')):; Nmin = N - int(kwargs['nmax']). # By default, DIIS in FRAC (1.0 occupation is always DIIS'd); frac_diis = True; if kwargs.has_key('frac_diis'):; frac_diis = kwargs['frac_diis']. # By default, drop the files to the molecule's name; root = mol.name(); if kwargs.has_key('filename'):; root = kwargs['filename']; traverse_filename = root + '.traverse.dat'; stats_filename = root + '.stats.dat'. # => Traverse <= #; psi4.set_global_option(""DF_INTS_IO"", ""SAVE""). Ns = []; energies = []; potentials = []; convs = []; stats = []. # Run one SCF to burn things in; energy('scf'). # Determine HOMO; ref = psi4.wavefunction(); eps_a = ref.epsilon_a(); eps_b = ref.epsilon_b(); if (Na == Nb):; HOMO = -Nb; elif (Nb == 0):; HOMO = Na; else:; E_a = eps_a[int(Na - 1)]; E_b = eps_b[int(Nb - 1)]; if (E_a >= E_b):; HOMO = Na; else:; HOMO = -Nb. stats.append('\t%6d %6d %6d %6d %6d %6d\n' %(N, Na, Nb, charge, mult, HOMO)). if (HOMO > 0):; Na = Na - 1; else:; Nb = Nb - 1; charge = charge + 1; mult = Na - Nb + 1. psi4.set_global_option(""DF_INTS_IO"", ""LOAD""); psi4.set_global_option(""FRAC_START"", frac_start); psi4.set_global_option(""FRAC_RENORMALIZE"", True). # Nuke 'em Rico!; for Nintegral in range(N,Nmin,-1):. # Nuke the current HOMO; for occ in foccs:. psi4.set_global_option(""FRAC_OCC"", [HOMO]); psi4.set_global_option(""FRAC_VAL"", [occ]). E = energy('scf'); C = 1; if (E == 0.0):; E = psi4.get_variable('SCF ITERATION ENERGY'); C = 0. if (HOMO > 0):; ref = psi4.wavefunction(); eps = ref.epsilon_a(); potentials.append(eps[HOMO-1]); else:; ref = psi4.wavefu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/frac.html:8509,energy,energy,8509,psi4manual/4.0b5/_modules/frac.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/frac.html,1,['energy'],['energy']
Energy Efficiency,"']['DISPERSION CORRECTION GRADIENT']. [docs] def run_dftd4(self, func: Optional[str] = None, dashlvl: Optional[str] = None, dashparam: Optional[Dict] = None, dertype: Union[int, str, None] = None, verbose: int = 1):; """"""Compute dispersion correction via Grimme's DFTD4 program. Parameters; ----------; func; Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Unlike run_dftd3, ``func`` overwrites any; parameter initialized via `dashparam`.; dashlvl; Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in `dashcoeff` or ""alias"" or; ""formal"" to run.; dashparam; Values for the same keys as `dashcoeff[dashlvl]['default']`; used to provide custom values. Unlike run_dftd3, will not have; effect if `func` given. Must provide all parameters.; Extra parameters will error.; dertype; Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose; Amount of printing. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ndarray; When `dertype=None`, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; -----; This function wraps the QCEngine dftd4 harness which wraps the internal DFTD4 Python API.; As such, the upstream convention of `func` trumping `dashparam` holds, rather than the; :py:func:`run_dftd3` behavior of `dashparam` extending or overriding `func`. """"""; import qcengine as qcng. if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; },; 'keywords': {; 'verbose': verbose,; },; }; if dashlvl:; resinp['keywords']['level_hint'] ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:43217,energy,energy-only,43217,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,2,"['efficient', 'energy']","['efficient', 'energy-only']"
Energy Efficiency,"'^\s+\d+\s+' + NUMBER + r'\s+' + NUMBER + r'\s+' + 'Convergence criterion met' + r'\s*' +; #r'(?:.*?)' +; # need a not ""Hartree-Fock SCF calculation"" here so DFT @@@ MP2 not caught?; r'^\s*' + r'(?:Total (?:RI)?MP2 correlation energy =)' + r'\s+' + NUMBER + r'\s+' + r'au' + r'\s*' +; r'^\s+' + r'(?:(?:RI)?MP2 total energy =)' + r'\s+' + NUMBER + r'\s+' + r'au' + r'\s*$',; outtext, re.MULTILINE | re.DOTALL | re.IGNORECASE); if mobj:; print('matched dhdft'); #psivar['NUCLEAR REPULSION ENERGY'] = mobj.group(1); #psivar['DFT TOTAL ENERGY'] = mobj.group(2); #psivar['DFT FUNCTIONAL TOTAL ENERGY'] = mobj.group(2); psivar['DOUBLE-HYBRID CORRECTION ENERGY'] = mobj.group(1). # Process MP2; mobj = re.search(; r'(?:Hartree-Fock SCF calculation)' +; r'(?:.*?)' +; #r'^\s+\d+\s+' + NUMBER + r'\s+' + NUMBER + r'\s+' + 'Convergence criterion met' + r'\s*' +; #r'(?:.*?)' +; # need a not ""Hartree-Fock SCF calculation"" here so DFT @@@ MP2 not caught?; r'^\s*' + r'(?:Total RIMP2 correlation energy =)' + r'\s+' + NUMBER + r'\s+' + r'au' + r'\s*' +; r'^\s+' + r'(?:RIMP2 total energy =)' + r'\s+' + NUMBER + r'\s+' + r'au' + r'\s*$',; outtext, re.MULTILINE | re.DOTALL | re.IGNORECASE); if mobj:; print('matched mp2'); #psivar['NUCLEAR REPULSION ENERGY'] = mobj.group(1); #psivar['DFT TOTAL ENERGY'] = mobj.group(2); #psivar['DFT FUNCTIONAL TOTAL ENERGY'] = mobj.group(2); psivar['MP2 CORRELATION ENERGY'] = mobj.group(1); #psivar['DOUBLE-HYBRID CORRECTION ENERGY'] = mobj.group(1); print(psivar). # TODO: need to split on 'Q-Chem begins' or 'Quantum Leap' or something. # # Process DFT no-D or internal-D WORKS BUT LOOKAHEAD VERY SLOW; # mobj = re.search(; # r'((?!grimme3).)*' + r'\s*' + # severe negative performance impact; # TODO note neg lookahead insufficient since option could be negated; # r'(?:.*?)' +; # r'^\s+' + r'(?:Nuclear Repulsion Energy =)' + r'\s+' + NUMBER + r'\s+hartrees\s*' +; # r'(?:.*?)' +; # r'(?:HF-DFT SCF calculation)' +; # r'(?:.*?)' +; # r'^\s+\d+\s+' + NUMBER + r'\s+' + NUMB",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/qchem.html:5564,energy,energy,5564,psi4manual/1.0.0/_modules/qcdb/qchem.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/qchem.html,2,['energy'],['energy']
Energy Efficiency,"'`` for energies,; ``'on'`` for gradients and Hessians. Note that the calculation of total; counterpoise corrected energies implies the calculation of the energies of; monomers in the monomer basis, hence specifying ``return_total_data = True``; may carry out more computations than ``return_total_data = False``.; For gradients and Hessians, ``return_total_data = False`` is rarely useful. :type levels: dict; :param levels: ``{1: 'ccsd(t)', 2: 'mp2', 'supersystem': 'scf'}`` || ``{1: 2, 2: 'ccsd(t)', 3: 'mp2'}`` || etc. Dictionary of different levels of theory for different levels of expansion; Note that method_string is not used in this case. ``supersystem`` computes; all higher order n-body effects up to the number of fragments. :type embedding_charges: dict; :param embedding_charges: ``{1: [-0.834, 0.417, 0.417], ..}``. Dictionary of atom-centered point charges. keys: 1-based index of fragment, values: list of charges for each fragment.; Add atom-centered point charges for fragments whose basis sets are not included in the computation. """""". [docs]; class BsseEnum(str, Enum):; """"""Available basis-set superposition error (BSSE) treatments."""""". nocp = ""nocp"" # plain supramolecular interaction energy; cp = ""cp"" # counterpoise correction; vmfc = ""vmfc"" # Valiron-Mayer function counterpoise. def _sum_cluster_ptype_data(; ptype: DriverEnum,; ptype_dict: Dict,; compute_list: Set[FragBasIndex],; fragment_slice_dict: Dict[int, Sequence],; fragment_size_dict: Dict[int, int],; mc_level_lbl: int,; vmfc: bool = False,; nb: int = 0,; ) -> Union[float, np.ndarray]:; """"""; Sum arrays from n-body computations to obtain the BSSE corrected or uncorrected scalar or array. Parameters; ----------; ptype; Hint to shape of array data to sum.; ptype_dict; Dictionary containing computed energy, gradient, or Hessian obtained from each subsystem computation; compute_list; A list of (frag, bas) tuples notating all the required computations.; fragment_slice_dict; Dictionary containing slices that in",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/driver_nbody.html:10712,charge,charges,10712,psi4manual/1.9.x/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/driver_nbody.html,2,['charge'],['charges']
Energy Efficiency,"'`` for energies,; ``'on'`` for gradients and Hessians. Note that the calculation of total; counterpoise corrected energies implies the calculation of the energies of; monomers in the monomer basis, hence specifying ``return_total_data = True``; may carry out more computations than ``return_total_data = False``.; For gradients and Hessians, ``return_total_data = False`` is rarely useful. :type levels: dict; :param levels: ``{1: 'ccsd(t)', 2: 'mp2', 'supersystem': 'scf'}`` || ``{1: 2, 2: 'ccsd(t)', 3: 'mp2'}`` || etc. Dictionary of different levels of theory for different levels of expansion; Note that method_string is not used in this case. ``supersystem`` computes; all higher order n-body effects up to the number of fragments. :type embedding_charges: dict; :param embedding_charges: ``{1: [-0.834, 0.417, 0.417], ..}``. Dictionary of atom-centered point charges. keys: 1-based index of fragment, values: list of charges for each fragment.; Add atom-centered point charges for fragments whose basis sets are not included in the computation. """"""; pass. [docs]; class BsseEnum(str, Enum):; """"""Available basis-set superposition error (BSSE) treatments."""""". nocp = ""nocp"" # plain supramolecular interaction energy; cp = ""cp"" # counterpoise correction; vmfc = ""vmfc"" # Valiron-Mayer function counterpoise. def _sum_cluster_ptype_data(; ptype: DriverEnum,; ptype_dict: Dict,; compute_list: Set[FragBasIndex],; fragment_slice_dict: Dict[int, Sequence],; fragment_size_dict: Dict[int, int],; mc_level_lbl: int,; vmfc: bool = False,; nb: int = 0,; ) -> Union[float, np.ndarray]:; """"""; Sum arrays from n-body computations to obtain the BSSE corrected or uncorrected scalar or array. Parameters; ----------; ptype; Hint to shape of array data to sum.; ptype_dict; Dictionary containing computed energy, gradient, or Hessian obtained from each subsystem computation; compute_list; A list of (frag, bas) tuples notating all the required computations.; fragment_slice_dict; Dictionary containing slices t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:10826,charge,charges,10826,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,1,['charge'],['charges']
Energy Efficiency,"'`` for energies,; ``'on'`` for gradients and Hessians. Note that the calculation of total; counterpoise corrected energies implies the calculation of the energies of; monomers in the monomer basis, hence specifying ``return_total_data = True``; may carry out more computations than ``return_total_data = False``.; For gradients and Hessians, ``return_total_data = False`` is rarely useful. :type levels: dict; :param levels: ``{1: 'ccsd(t)', 2: 'mp2', 'supersystem': 'scf'}`` || ``{1: 2, 2: 'ccsd(t)', 3: 'mp2'}`` || etc. Dictionary of different levels of theory for different levels of expansion; Note that method_string is not used in this case. ``supersystem`` computes; all higher order n-body effects up to the number of fragments. :type embedding_charges: dict; :param embedding_charges: ``{1: [-0.834, 0.417, 0.417], ..}``. Dictionary of atom-centered point charges. keys: 1-based index of fragment, values: list of charges for each fragment.; Add atom-centered point charges for fragments whose basis sets are not included in the computation. """"""; pass. [docs]class BsseEnum(str, Enum):; """"""Available basis-set superposition error (BSSE) treatments."""""". nocp = ""nocp"" # plain supramolecular interaction energy; cp = ""cp"" # counterpoise correction; vmfc = ""vmfc"" # Valiron-Mayer function counterpoise. def _sum_cluster_ptype_data(; ptype: DriverEnum,; ptype_dict: Dict,; compute_list: Set[FragBasIndex],; fragment_slice_dict: Dict[int, Sequence],; fragment_size_dict: Dict[int, int],; mc_level_lbl: int,; vmfc: bool = False,; nb: int = 0,; ) -> Union[float, np.ndarray]:; """"""; Sum arrays from n-body computations to obtain the BSSE corrected or uncorrected scalar or array. Parameters; ----------; ptype; Hint to shape of array data to sum.; ptype_dict; Dictionary containing computed energy, gradient, or Hessian obtained from each subsystem computation; compute_list; A list of (frag, bas) tuples notating all the required computations.; fragment_slice_dict; Dictionary containing slices tha",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_nbody.html:10753,charge,charges,10753,psi4manual/1.7.x/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_nbody.html,1,['charge'],['charges']
Energy Efficiency,"'`` for energies,; ``'on'`` for gradients and Hessians. Note that the calculation of total; counterpoise corrected energies implies the calculation of the energies of; monomers in the monomer basis, hence specifying ``return_total_data = True``; may carry out more computations than ``return_total_data = False``.; For gradients and Hessians, ``return_total_data = False`` is rarely useful. :type levels: dict; :param levels: ``{1: 'ccsd(t)', 2: 'mp2', 'supersystem': 'scf'}`` || ``{1: 2, 2: 'ccsd(t)', 3: 'mp2'}`` || etc. Dictionary of different levels of theory for different levels of expansion; Note that method_string is not used in this case. ``supersystem`` computes; all higher order n-body effects up to the number of fragments. :type embedding_charges: dict; :param embedding_charges: ``{1: [-0.834, 0.417, 0.417], ..}``. Dictionary of atom-centered point charges. keys: 1-based index of fragment, values: list of charges for each fragment.; Add atom-centered point charges for fragments whose basis sets are not included in the computation. """"""; pass. class BsseEnum(str, Enum):; """"""Available basis-set superposition error (BSSE) treatments."""""". nocp = ""nocp"" # plain supramolecular interaction energy; cp = ""cp"" # counterpoise correction; vmfc = ""vmfc"" # Valiron-Mayer function counterpoise. def _sum_cluster_ptype_data(; ptype: DriverEnum,; ptype_dict: Dict,; compute_list: Set[FragBasIndex],; fragment_slice_dict: Dict[int, Sequence],; fragment_size_dict: Dict[int, int],; mc_level_lbl: int,; vmfc: bool = False,; nb: int = 0,; ) -> Union[float, np.ndarray]:; """"""; Sum arrays from n-body computations to obtain the BSSE corrected or uncorrected scalar or array. Parameters; ----------; ptype; Hint to shape of array data to sum.; ptype_dict; Dictionary containing computed energy, gradient, or Hessian obtained from each subsystem computation; compute_list; A list of (frag, bas) tuples notating all the required computations.; fragment_slice_dict; Dictionary containing slices that inde",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html:10551,charge,charges,10551,psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html,1,['charge'],['charges']
Energy Efficiency,"'`` || ``'App'`` || etc. Indicates which symmetry block (:ref:`Cotton <table:irrepOrdering>` ordering) of vibrational; frequencies to be computed. ``1``, ``'1'``, or ``'a1'`` represents; :math:`a_1`, requesting only the totally symmetric modes.; ``-1`` indicates a full frequency calculation. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] <example description>; >>> <example python command>. >>> # [2] Frequency calculation for b2 modes through finite difference of gradients; >>> frequencies('scf', dertype=1, irrep=4). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Make sure the molecule the user provided is the active one; if ('molecule' in kwargs):; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); PsiMod.set_global_option('BASIS', PsiMod.get_global_option('BASIS')). types = ['energy', 'gradient', 'hessian']. dertype = 2; if ('dertype' in kwargs):; dertype = kwargs['dertype']; if not (lowername in procedures[types[dertype]]):; print 'Frequencies: dertype = %d for frequencies is not available, switching to automatic determination.' % dertype; dertype = -1. if 'irrep' in kwargs:; irrep = parse_cotton_irreps(kwargs['irrep']) - 1 # externally, A1 irrep is 1, internally 0; else:; irrep = -1 # -1 implies do all irreps. # By default, set func to the energy function; func = energy; func_existed = False; if 'func' in kwargs:; func = kwargs['func']; func_existed = True. if (not('dertype' in kwargs) or dertype == -1):; if lowername in procedures['hessian']:; dertype = 2; elif lowername in procedures['gradient']:; dertype = 1; else:; dertype = 0. # Does an analytic procedure exist for the requested method?; if (dertype == 2 and func_existed == False):; # We have the desired method. Do it.; procedures['hessian'][lowername](lowername, **kwargs); return PsiMod.reference_wavefunction(",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/driver.html:44043,energy,energy,44043,psi4manual/4.0b2/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/driver.html,1,['energy'],['energy']
Energy Efficiency,"'`` || ``'App'`` || etc. Indicates which symmetry block (:ref:`Cotton <table:irrepOrdering>` ordering) of vibrational; frequencies to be computed. ``1``, ``'1'``, or ``'a1'`` represents; :math:`a_1`, requesting only the totally symmetric modes.; ``-1`` indicates a full frequency calculation. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] <example description>; >>> <example python command>. >>> # [2] Frequency calculation for b2 modes through finite difference of gradients; >>> frequencies('scf', dertype=1, irrep=4). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Make sure the molecule the user provided is the active one; if ('molecule' in kwargs):; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); PsiMod.set_global_option('BASIS', PsiMod.get_global_option('BASIS')). types = ['energy', 'gradient', 'hessian']. dertype = 2; if ('dertype' in kwargs):; dertype = kwargs['dertype']; if not (lowername in procedures[types[dertype]]):; print('Frequencies: dertype = %d for frequencies is not available, switching to automatic determination.' % dertype); dertype = -1. if 'irrep' in kwargs:; irrep = parse_cotton_irreps(kwargs['irrep']) - 1 # externally, A1 irrep is 1, internally 0; else:; irrep = -1 # -1 implies do all irreps. # By default, set func to the energy function; func = energy; func_existed = False; if 'func' in kwargs:; func = kwargs['func']; func_existed = True. if (not('dertype' in kwargs) or dertype == -1):; if lowername in procedures['hessian']:; dertype = 2; elif lowername in procedures['gradient']:; dertype = 1; else:; dertype = 0. # Does an analytic procedure exist for the requested method?; if (dertype == 2 and func_existed == False):; # We have the desired method. Do it.; procedures['hessian'][lowername](lowername, **kwargs); return PsiMod.reference_wavefunction",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/driver.html:47109,energy,energy,47109,psi4manual/4.0b3/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/driver.html,1,['energy'],['energy']
Energy Efficiency,"'``, a few of the smallest database members,; ``'large'``, the largest of the database members, or; ``'equilibrium'``, the equilibrium geometries for a database; composed of dissociation curves.; * ``'BzBz_S'`` || ``'FaOOFaON'`` || ``'ArNe'`` || ``'HB'`` || etc.; For databases composed of dissociation curves, or otherwise; divided into subsets, individual curves and subsets can be; called by name. Consult the database python files for available; molecular systems (case insensitive).; * ``[1,2,5]`` || ``['1','2','5']`` || ``['BzMe-3.5', 'MeMe-5.0']`` || etc.; Specify a list of database members to run. Consult the; database python files for available molecular systems. This; is the only portion of database input that is case sensitive;; choices for this keyword must match the database python file. :examples:. >>> # [1] Two-stage SCF calculation on short, equilibrium, and long helium dimer; >>> db('scf','RGC10',cast_up='sto-3g',subset=['HeHe-0.85','HeHe-1.0','HeHe-1.5'], tabulate=['scf total energy','natom']). >>> # [2] Counterpoise-corrected interaction energies for three complexes in S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('df-mp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish function",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:28462,energy,energy,28462,psi4manual/4.0b4/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html,1,['energy'],['energy']
Energy Efficiency,"'``, a few of the smallest database members,; ``'large'``, the largest of the database members, or; ``'equilibrium'``, the equilibrium geometries for a database; composed of dissociation curves.; * ``'BzBz_S'`` || ``'FaOOFaON'`` || ``'ArNe'`` || ``'HB'`` || etc.; For databases composed of dissociation curves, or otherwise; divided into subsets, individual curves and subsets can be; called by name. Consult the database python files for available; molecular systems (case insensitive).; * ``[1,2,5]`` || ``['1','2','5']`` || ``['BzMe-3.5', 'MeMe-5.0']`` || etc.; Specify a list of database members to run. Consult the; database python files for available molecular systems. This; is the only portion of database input that is case sensitive;; choices for this keyword must match the database python file. :examples:. >>> # [1] Two-stage SCF calculation on short, equilibrium, and long helium dimer; >>> db('scf','RGC10',cast_up='sto-3g',subset=['HeHe-0.85','HeHe-1.0','HeHe-1.5'], tabulate=['scf total energy','natom']). >>> # [2] Counterpoise-corrected interaction energies for three complexes in S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('df-mp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). """"""; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish f",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:29089,energy,energy,29089,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,1,['energy'],['energy']
Energy Efficiency,"'``, a few of the smallest database members,; ``'large'``, the largest of the database members, or; ``'equilibrium'``, the equilibrium geometries for a database; composed of dissociation curves.; * ``'BzBz_S'`` || ``'FaOOFaON'`` || ``'ArNe'`` || ``'HB'`` || etc.; For databases composed of dissociation curves, or otherwise; divided into subsets, individual curves and subsets can be; called by name. Consult the database python files for available; molecular systems (case insensitive).; * ``[1,2,5]`` || ``['1','2','5']`` || ``['BzMe-3.5', 'MeMe-5.0']`` || etc.; Specify a list of database members to run. Consult the; database python files for available molecular systems. This; is the only portion of database input that is case sensitive;; choices for this keyword must match the database python file. :examples:. >>> # [1] Two-stage SCF calculation on short, equilibrium, and long helium dimer; >>> db('scf','RGC10',cast_up='sto-3g',subset=['HeHe-0.85','HeHe-1.0','HeHe-1.5'], tabulate=['scf total energy','natom']). >>> # [2] Counterpoise-corrected interaction energies for three complexes in S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('dfmp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish function ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html:28462,energy,energy,28462,psi4manual/4.0b3/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html,1,['energy'],['energy']
Energy Efficiency,"'``, a few of the smallest database members,; ``'large'``, the largest of the database members, or; ``'equilibrium'``, the equilibrium geometries for a database; composed of dissociation curves.; * ``'BzBz_S'`` || ``'FaOOFaON'`` || ``'ArNe'`` || ``'HB'`` || etc.; For databases composed of dissociation curves, or otherwise; divided into subsets, individual curves and subsets can be; called by name. Consult the database python files for available; molecular systems (case insensitive).; * ``[1,2,5]`` || ``['1','2','5']`` || ``['BzMe-3.5', 'MeMe-5.0']`` || etc.; Specify a list of database members to run. Consult the; database python files for available molecular systems. This; is the only portion of database input that is case sensitive;; choices for this keyword must match the database python file. :examples:. >>> # [1] Two-stage SCF calculation on short, equilibrium, and long helium dimer; >>> db('scf','RGC10',cast_up='sto-3g',subset=['HeHe-0.85','HeHe-1.0','HeHe-1.5'], tabulate=['scf total energy','natom']). >>> # [2] Counterpoise-corrected interaction energies for three complexes in S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('mp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). """"""; lowername = name #TODO; kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name #.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish func",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html:7457,energy,energy,7457,psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html,11,['energy'],['energy']
Energy Efficiency,"'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the fifth delta correction; to the correlation energy. Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, 'xtpl_highest_1', which uses the best basis; set available. See Extrapolation Schemes for all available schemes. Parameters:; scf_scheme (function) – xtpl_highest_1 || scf_xtpl_helgaker_3 || etc.; Indicates the basis set extrapolation scheme to be applied to the reference energy.; Defaults to scf_xtpl_helgaker_3() if three valid basis sets; present in scf_basis, scf_xtpl_helgaker_2() if two valid basis; sets present in scf_basis, and xtpl_highest_1() otherwise. corl_scheme (function) – xtpl_highest_1 || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in corl_basis and xtpl_highest_1() otherwise. delta_scheme (function) – xtpl_highest_1 || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta_basis and xtpl_highest_1() otherwise. delta2_scheme (function) – xtpl_highest_1 || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the second delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta2_basis and xtpl_highest_1() otherwise. delta3_scheme (function) – xtpl_highest_1 || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the third delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/cbs-1.html:7678,energy,energy,7678,psi4manual/1.0.0/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/cbs-1.html,2,['energy'],['energy']
Energy Efficiency,"'energy'] = response. elif task.driver == 'gradient':; reference['gradient'] = response; reference['energy'] = task.extras['qcvars']['CURRENT ENERGY']. elif task.driver == 'hessian':; reference['hessian'] = response; reference['energy'] = task.extras['qcvars']['CURRENT ENERGY']; if 'CURRENT GRADIENT' in task.extras['qcvars']:; reference['gradient'] = task.extras['qcvars']['CURRENT GRADIENT']. dipole_available = False; if 'CURRENT DIPOLE' in task.extras['qcvars']:; reference['dipole'] = task.extras['qcvars']['CURRENT DIPOLE']; dipole_available = True. # load AtomicComputer results into findifrec[displacements]; for label, displacement in self.findifrec[""displacements""].items():; task = results_list[label]; response = task.return_result. if task.driver == 'energy':; displacement['energy'] = response. elif task.driver == 'gradient':; displacement['gradient'] = response; displacement['energy'] = task.extras['qcvars']['CURRENT ENERGY']. elif task.driver == 'hessian':; displacement['hessian'] = response; displacement['energy'] = task.extras['qcvars']['CURRENT ENERGY']; if 'CURRENT GRADIENT' in task.extras['qcvars']:; displacement['gradient'] = task.extras['qcvars']['CURRENT GRADIENT']. if 'CURRENT DIPOLE' in task.extras['qcvars']:; displacement['dipole'] = task.extras['qcvars']['CURRENT DIPOLE']. # apply finite difference formulas and load derivatives into findifrec[reference]; if self.metameta['mode'] == '1_0':; G0 = assemble_gradient_from_energies(self.findifrec); self.findifrec[""reference""][self.driver.name] = G0. elif self.metameta['mode'] == '2_1':; if dipole_available:; DD0 = assemble_dipder_from_dipoles(self.findifrec, self.metameta['irrep']); self.findifrec[""reference""][""dipole derivative""] = DD0. H0 = assemble_hessian_from_gradients(self.findifrec, self.metameta['irrep']); self.findifrec[""reference""][self.driver.name] = H0. elif self.metameta['mode'] == '2_0':; try:; G0 = assemble_gradient_from_energies(self.findifrec); except KeyError:; core.print_out(""Unable to",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html:47906,energy,energy,47906,psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html,4,['energy'],['energy']
Energy Efficiency,"'epsilon_a': wfn.epsilon_a().to_array() if wfn.epsilon_a() else None,; 'epsilon_b': wfn.epsilon_b().to_array() if wfn.epsilon_b() else None,; 'frequencies': wfn.frequencies().to_array() if wfn.frequencies() else None; },; 'dimension': {; 'doccpi': wfn.doccpi().to_tuple(),; 'frzcpi': wfn.frzcpi().to_tuple(),; 'frzvpi': wfn.frzvpi().to_tuple(),; 'nalphapi': wfn.nalphapi().to_tuple(),; 'nbetapi': wfn.nbetapi().to_tuple(),; 'nmopi': wfn.nmopi().to_tuple(),; 'nsopi': wfn.nsopi().to_tuple(),; 'soccpi': wfn.soccpi().to_tuple(); },; 'int': {; 'nalpha': wfn.nalpha(),; 'nbeta': wfn.nbeta(),; 'nfrzc': wfn.nfrzc(),; 'nirrep': wfn.nirrep(),; 'nmo': wfn.nmo(),; 'nso': wfn.nso(),; 'print': wfn.get_print(),; },; 'string': {; 'name': wfn.name(),; 'basisname': wfn.basisset().name(); },; 'boolean': {; 'PCM_enabled': wfn.PCM_enabled(),; 'same_a_b_dens': wfn.same_a_b_dens(),; 'same_a_b_orbs': wfn.same_a_b_orbs(),; 'density_fitted': wfn.density_fitted(),; 'basispuream': wfn.basisset().has_puream(); },; 'float': {; 'energy': wfn.energy(),; 'efzc': wfn.efzc(),; 'dipole_field_x': wfn.get_dipole_field_strength()[0],; 'dipole_field_y': wfn.get_dipole_field_strength()[1],; 'dipole_field_z': wfn.get_dipole_field_strength()[2]; },; 'floatvar': wfn.scalar_variables(),; 'matrixarr': {k: v.to_array() for k, v in wfn.array_variables().items()}; } # yapf: disable. if filename is not None:; if not filename.endswith('.npy'): filename += '.npy'; np.save(filename, wfn_data). return wfn_data. core.Wavefunction.to_file = _core_wavefunction_to_file. ## Python JK helps. @staticmethod; def _core_jk_build(orbital_basis, aux=None, jk_type=None, do_wK=None, memory=None):; """"""; Constructs a Psi4 JK object from an input basis. Parameters; ----------; orbital_basis : :py:class:`~psi4.core.BasisSet`; Orbital basis to use in the JK object.; aux : :py:class:`~psi4.core.BasisSet`, optional; Optional auxiliary basis set for density-fitted tensors. Defaults; to the DF_BASIS_SCF if set, otherwise the correspond JKFIT basi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/python_helpers.html:9049,energy,energy,9049,psi4manual/1.3.2/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/python_helpers.html,1,['energy'],['energy']
Energy Efficiency,"'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 3):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'tot', BSET[2], ZSET[2], 0.0])),; 'MD': dict(zip(f_fields, [wfnname, 'tot', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'tot', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; eMD = NEED['MD']['f_energy']; eLO = NEED['LO']['f_energy']; zHI = NEED['HI']['f_zeta']; zMD = NEED['MD']['f_zeta']; zLO = NEED['LO']['f_zeta']. # Compute extrapolated energy; ratio = (eHI - eMD) / (eMD - eLO); alpha = -1 * math.log(ratio); beta = (eHI - eMD) / (math.exp(-1 * alpha * zMD) * (ratio - 1)); energypiece = eHI - beta * math.exp(-1 * alpha * zHI). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" MD-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zMD), eMD); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Alpha (exponent) Value: %16.8f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); PsiMod.print_out(cbsscheme). return energypiece. [docs]def scf_xtpl_helgaker_2(**largs):; r""""""Extrapolation scheme for reference energies with two adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}, \alpha = 1.63. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_nam",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:81886,energy,energypiece,81886,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,3,['energy'],['energypiece']
Energy Efficiency,"'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 3):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'tot', BSET[2], ZSET[2], 0.0])),; 'MD': dict(zip(f_fields, [wfnname, 'tot', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'tot', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; eMD = NEED['MD']['f_energy']; eLO = NEED['LO']['f_energy']; zHI = NEED['HI']['f_zeta']; zMD = NEED['MD']['f_zeta']; zLO = NEED['LO']['f_zeta']. # Compute extrapolated energy; ratio = (eHI - eMD) / (eMD - eLO); alpha = -1 * math.log(ratio); beta = (eHI - eMD) / (math.exp(-1 * alpha * zMD) * (ratio - 1)); energypiece = eHI - beta * math.exp(-1 * alpha * zHI). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" MD-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zMD), eMD); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Alpha (exponent) Value: %16.8f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); psi4.print_out(cbsscheme). return energypiece. [docs]def scf_xtpl_helgaker_2(**largs):; r""""""Extrapolation scheme for reference energies with two adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}, \alpha = 1.63. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:97665,energy,energypiece,97665,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,1,['energy'],['energypiece']
Energy Efficiency,"'hessian'; Type of the procedure passed in. return_total_data (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); If True returns the total data (energy/gradient/Hessian) of the system,; otherwise returns interaction data. Default is 'off' for energies,; 'on' for gradients and Hessians. Note that the calculation of total; counterpoise corrected energies implies the calculation of the energies of; monomers in the monomer basis, hence specifying return_total_data = True; may carry out more computations than return_total_data = False. levels (dict) – {1: 'ccsd(t)', 2: 'mp2', 'supersystem': 'scf'} || {1: 2, 2: 'ccsd(t)', 3: 'mp2'} || etc; Dictionary of different levels of theory for different levels of expansion; Note that method_string is not used in this case. supersystem computes; all higher order n-body effects up to the number of fragments. embedding_charges (dict) – {1: [-0.834, 0.417, 0.417], ..}; Dictionary of atom-centered point charges. keys: 1-based index of fragment, values: list of charges for each fragment. charge_method (str) – scf/6-31g || b3lyp/6-31g* || etc; Method to compute point charges for monomers. Overridden by embedding_charges; if both are provided. charge_type (str) – MULLIKEN_CHARGES || LOWDIN_CHARGES; Default is MULLIKEN_CHARGES. The nbody function computes counterpoise-corrected (CP), non-CP (noCP), and Valiron-Mayer Function Counterpoise (VMFC) interaction energies for complexes composed of arbitrary numbers of monomers.; Examples :; # Counterpoise corrected CCSD(T) energies for the Helium dimer; molecule mol {; He; --; He 1 3; }; # Calculate interaction energies only (skips monomers in monomer basis):; energy('CCSD(T)', bsse_type='cp'); # Calculate interaction and total energies, return interaction energies:; energy('CCSD(T)', bsse_type=['cp','nocp']); # Calculate and return counterpoise-corrected gradient; # Useful for e.g. CP-corrected geometry optimization; gradient('CCSD(T)', bsse_type='cp', return_total_data=True). # noCP, VMFC",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/nbody-1.html:2907,charge,charges,2907,psi4manual/1.4.0/nbody-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/nbody-1.html,4,['charge'],['charges']
Energy Efficiency,"'mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; PsiMod.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25); PsiMod.set_variable('MP2.5 TOTAL ENERGY', e_mp25); PsiMod.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); PsiMod.set_variable('CURRENT ENERGY', e_mp25). # build string of title banner and print results; banners = ''; banners += """"""PsiMod.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""PsiMod.print_out('\\n')\n\n""""""; exec banners. tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); PsiMod.print_out(tables). return e_mp25. # A direct translation of a plugin input file into a function call. Function calls are the only; # way to call plugins in sow/reap mode for db(), opt(), etc. This isn't best practices; # but is an example of what to do for a more complicated procedure where different options ; # are set for different qc steps.; [docs]def run_plugin_omega(name, **kwargs):; r""""""Function encoding sequence of PSI module and plugin calls, as well; as typical options, to access Rob Parrish's omega plugin. >>> energy('plugin_omega'). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). plugfile = PsiMod.Process.environment[""PSIDATADIR""] + ""/../tests/plugin_omega/plugin_omega.so""; PsiMod.plugin_load(""%s"" % (plugfile)). PsiMod.set_global_option('BASIS', 'AUG-CC-PVDZ'); PsiMod.set_global_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/aliases.html:3725,energy,energy,3725,psi4manual/4.0b2/_modules/aliases.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/aliases.html,1,['energy'],['energy']
Energy Efficiency,"'mp3', **kwargs); e_scf = psi4.get_variable('SCF TOTAL ENERGY'); ce_mp2 = psi4.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = psi4.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; psi4.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; psi4.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; psi4.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); psi4.set_variable('CURRENT ENERGY', e_mp25) # geometry optimizer tracks this variable, permits; # MP2.5 finite difference optimizations; # build string of title banner and print results; banners = ''; banners += """"""psi4.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""psi4.print_out('\\n')\n\n""""""; exec banners. tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); psi4.print_out(tables) # prints nice header and table of all involved quantities to output file. return e_mp25. One final step is necessary. At the end of the aliases.py file, add; the following line.; 1procedures['energy']['mp2.5'] = run_mp2_5. This permits the newly defined MP2.5 method to be called in the input file; with the following command.; 1energy('mp2.5'). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Customization: Adding Simple Extensions. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/quickaddalias-1.html:3089,energy,energy,3089,psi4manual/1.2.1/quickaddalias-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/quickaddalias-1.html,14,['energy'],['energy']
Energy Efficiency,"'psi', 'ot', 180); old_guess = psi4.get_global_option(""GUESS""); psi4.set_global_option(""DF_INTS_IO"", ""SAVE""); psi4.print_out('\n\t==> IP Fitting SCF: Burn-in <==\n'); energy('scf'); psi4.set_global_option(""DF_INTS_IO"", ""LOAD""). # Determine HOMO, to determine mult1; ref = psi4.wavefunction(); eps_a = ref.epsilon_a(); eps_b = ref.epsilon_b(); if (Na == Nb):; HOMO = -Nb; elif (Nb == 0):; HOMO = Na; else:; E_a = eps_a[int(Na - 1)]; E_b = eps_b[int(Nb - 1)]; if (E_a >= E_b):; HOMO = Na; else:; HOMO = -Nb. Na1 = Na;; Nb1 = Nb;; if (HOMO > 0):; Na1 = Na1-1;; else:; Nb1 = Nb1-1;. charge1 = charge0 + 1;; mult1 = Na1 - Nb1 + 1. omegas = [];; E0s = [];; E1s = [];; kIPs = [];; IPs = [];; types = [];. # Right endpoint; psi4.set_global_option('DFT_OMEGA',omega_r). # Neutral; if (read):; psi4.set_global_option(""GUESS"", ""READ""); p4util.copy_file_to_scratch(read180, 'psi', 'ot', 180). mol.set_molecular_charge(charge0); mol.set_multiplicity(mult0); psi4.print_out('\n\t==> IP Fitting SCF: Neutral, Right Endpoint <==\n'); E0r = energy('scf'); ref = psi4.wavefunction(); eps_a = ref.epsilon_a(); eps_b = ref.epsilon_b(); E_HOMO = 0.0;; if (Nb == 0):; E_HOMO = eps_a[int(Na-1)]; else:; E_a = eps_a[int(Na - 1)]; E_b = eps_b[int(Nb - 1)]; if (E_a >= E_b):; E_HOMO = E_a;; else:; E_HOMO = E_b;; E_HOMOr = E_HOMO;; psi4.IO.change_file_namespace(180,""ot"",""neutral""). # Cation; if (read):; psi4.set_global_option(""GUESS"", ""READ""); p4util.copy_file_to_scratch(read180, 'psi', 'ot', 180). mol.set_molecular_charge(charge1); mol.set_multiplicity(mult1); psi4.print_out('\n\t==> IP Fitting SCF: Cation, Right Endpoint <==\n'); E1r = energy('scf'); psi4.IO.change_file_namespace(180,""ot"",""cation""). IPr = E1r - E0r;; kIPr = -E_HOMOr;; delta_r = IPr - kIPr;. if (IPr > kIPr):; psi4.print_out('\n***IP Fitting Error: Right Omega limit should have kIP > IP'); sys.exit(1). omegas.append(omega_r); types.append('Right Limit'); E0s.append(E0r); E1s.append(E1r); IPs.append(IPr); kIPs.append(kIPr). # Use previous orbitals",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/frac.html:13536,energy,energy,13536,psi4manual/4.0b5/_modules/frac.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/frac.html,1,['energy'],['energy']
Energy Efficiency,"'ptype'] != 'energy':; # Extract ptype data for monomers in monomer basis for CP total data; cp_monomer_ptype = np.zeros(arr_shape); _sum_cluster_ptype_data(metadata['ptype'], component_results['ptype'], cp_monomers_in_monomer_basis,; fragment_slice_dict, fragment_size_dict, cp_monomer_ptype). # Compute cp energy and ptype; if 'cp' in metadata['bsse_type_list']:; for n in nbody_range:; if n == metadata['max_frag']:; cp_energy_body_dict[n] = cp_energy_by_level[n] - bsse; if metadata['ptype'] != 'energy':; cp_ptype_body_dict[n][:] = cp_ptype_by_level[n] - bsse_ptype; continue. for k in range(1, n + 1):; take_nk = nCr(metadata['max_frag'] - k - 1, n - k); sign = ((-1)**(n - k)); value = cp_energy_by_level[k]; cp_energy_body_dict[n] += take_nk * sign * value. if metadata['ptype'] != 'energy':; value = cp_ptype_by_level[k]; cp_ptype_body_dict[n] += take_nk * sign * value. if n == 1:; bsse = cp_energy_body_dict[n] - cp_monomer_energies; cp_energy_body_dict[n] = cp_monomer_energies; if metadata['ptype'] != 'energy':; bsse_ptype = cp_ptype_body_dict[n] - cp_monomer_ptype; cp_ptype_body_dict[n] = cp_monomer_ptype.copy(). else:; cp_energy_body_dict[n] -= bsse; if metadata['ptype'] != 'energy':; cp_ptype_body_dict[n] -= bsse_ptype. cp_interaction_energy = cp_energy_body_dict[metadata['max_nbody']] - cp_energy_body_dict[1]; nbody_dict['Counterpoise Corrected Interaction Energy'] = cp_interaction_energy. for n in nbody_range[1:]:; var_key = 'CP-CORRECTED %d-BODY INTERACTION ENERGY' % n; nbody_dict[var_key] = cp_energy_body_dict[n] - cp_energy_body_dict[1]. _print_nbody_energy(cp_energy_body_dict, ""Counterpoise Corrected (CP)"", metadata['embedding_charges']); cp_interaction_energy = cp_energy_body_dict[metadata['max_nbody']] - cp_energy_body_dict[1]; nbody_dict['Counterpoise Corrected Total Energy'] = cp_energy_body_dict[metadata['max_nbody']]; nbody_dict['Counterpoise Corrected Interaction Energy'] = cp_interaction_energy. # Compute nocp energy and ptype; if 'nocp' in metadata['b",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_nbody.html:24752,energy,energy,24752,psi4manual/1.3.2/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_nbody.html,1,['energy'],['energy']
Energy Efficiency,"'ptype'], component_results['ptype'], monomers_in_monomer_basis,; fragment_slice_dict, fragment_size_dict, monomer_ptype). # Compute cp energy and ptype; if 'cp' in metadata['bsse_type_list']:; for n in nbody_range:; if n == metadata['max_frag']:; cp_energy_body_dict[n] = cp_energy_by_level[n] - bsse; if metadata['ptype'] != 'energy':; cp_ptype_body_dict[n][:] = cp_ptype_by_level[n] - bsse_ptype; continue. for k in range(1, n + 1):; take_nk = nCr(metadata['max_frag'] - k - 1, n - k); sign = ((-1)**(n - k)); value = cp_energy_by_level[k]; cp_energy_body_dict[n] += take_nk * sign * value. if metadata['ptype'] != 'energy':; value = cp_ptype_by_level[k]; cp_ptype_body_dict[n] += take_nk * sign * value. if n == 1:; bsse = cp_energy_body_dict[n] - monomer_energies; cp_energy_body_dict[n] = monomer_energies; if metadata['ptype'] != 'energy':; bsse_ptype = cp_ptype_body_dict[n] - monomer_ptype; cp_ptype_body_dict[n] = monomer_ptype.copy(). else:; cp_energy_body_dict[n] -= bsse; if metadata['ptype'] != 'energy':; cp_ptype_body_dict[n] -= bsse_ptype. cp_interaction_energy = cp_energy_body_dict[metadata['max_nbody']] - cp_energy_body_dict[1]; nbody_dict['Counterpoise Corrected Interaction Energy'] = cp_interaction_energy. for n in nbody_range[1:]:; var_key = 'CP-CORRECTED %d-BODY INTERACTION ENERGY' % n; nbody_dict[var_key] = cp_energy_body_dict[n] - cp_energy_body_dict[1]. _print_nbody_energy(cp_energy_body_dict, ""Counterpoise Corrected (CP)"", metadata['embedding_charges']); cp_interaction_energy = cp_energy_body_dict[metadata['max_nbody']] - cp_energy_body_dict[1]; if monomer_energies != 0.0:; nbody_dict['Counterpoise Corrected Total Energy'] = cp_energy_body_dict[metadata['max_nbody']]; nbody_dict['Counterpoise Corrected Interaction Energy'] = cp_interaction_energy. # Compute nocp energy and ptype; if 'nocp' in metadata['bsse_type_list']:; for n in nbody_range:; if n == metadata['max_frag']:; nocp_energy_body_dict[n] = nocp_energy_by_level[n]; if metadata['ptype'] != 'energy",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html:26070,energy,energy,26070,psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html,2,['energy'],['energy']
Energy Efficiency,"'sapt0') # run SAPT that requires 2 fragments; compare_values(sapt[mol], e, 5, '%s sapt ok' % mol); compare_values(nre[mol], p4mol.nuclear_repulsion_energy(), 4, '%s ok' % mol); clean() # clean scratch between loop calcs. The essential element, mass and coordinate information of the molecule is accessible; molecule eneyne {; 0 1; C_ene 0.000000 -0.667578 -2.124659; C_ene 0.000000 0.667578 -2.124659; H_ene@2.014 0.923621 -1.232253 -2.126185; H_ene -0.923621 -1.232253 -2.126185; H_ene -0.923621 1.232253 -2.126185; Gh(H_ene) 0.923621 1.232253 -2.126185; --; 0 1; X 9.0 9.0 9.0; C_yne 0.000000 0.000000 2.900503; C_yne 0.000000 0.000000 1.693240; H_yne 0.000000 0.000000 0.627352; H_yne 0.000000 0.000000 3.963929; }. eneyne.update_geometry(). for iat in range(eneyne.natom()):; print """"""{:4} {:4} {:12} {:8.4f} {:12.6f} {:12.6f} {:12.6f} {:12.6f}"""""".format(; eneyne.Z(iat), # atomic number; eneyne.symbol(iat), # element symbol; eneyne.label(iat), # input element label; eneyne.charge(iat), # element charge; eneyne.x(iat), # x-coordinate; eneyne.y(iat), # y-coordinate; eneyne.z(iat), # z-coordinate; eneyne.mass(iat), # mass; ). # 6.0 C C_ENE 6.0000 -0.031900 -1.218981 -3.948079 12.000000; # 6.0 C C_ENE 6.0000 -0.031900 1.304098 -3.948079 12.000000; # 1.0 H H_ENE 1.0000 1.713491 -2.286062 -3.950962 2.014000; # 1.0 H H_ENE 1.0000 -1.777290 -2.286062 -3.950962 1.007825; # 1.0 H H_ENE 1.0000 -1.777290 2.371180 -3.950962 1.007825; # 0.0 H H_ENE 0.0000 1.713491 2.371180 -3.950962 1.007825; # 6.0 C C_YNE 6.0000 -0.031900 0.042559 5.548101 12.000000; # 6.0 C C_YNE 6.0000 -0.031900 0.042559 3.266705 12.000000; # 1.0 H H_YNE 1.0000 -0.031900 0.042559 1.252468 1.007825; # 1.0 H H_YNE 1.0000 -0.031900 0.042559 7.557685 1.007825. Table Of Contents. Molecule and Geometry Specification; Coordinates; Molecule Keywords; Multiple Molecules; Ghost Atoms; Isotopic Substitution; PubChem Database; Symmetry; Non-Covalently Bonded Molecule Fragments; Advanced Python. Previous topic; Psithon: Structuri",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/psithonmol-1.html:19539,charge,charge,19539,psi4manual/1.0.0/psithonmol-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/psithonmol-1.html,4,['charge'],['charge']
Energy Efficiency,"'sapt0') # run SAPT that requires 2 fragments; compare_values(sapt[mol], e, 5, '%s sapt ok' % mol); compare_values(nre[mol], p4mol.nuclear_repulsion_energy(), 4, '%s ok' % mol); clean() # clean scratch between loop calcs. The essential element, mass and coordinate information of the molecule is accessible; molecule eneyne {; 0 1; C_ene 0.000000 -0.667578 -2.124659; C_ene 0.000000 0.667578 -2.124659; H_ene@2.014 0.923621 -1.232253 -2.126185; H_ene -0.923621 -1.232253 -2.126185; H_ene -0.923621 1.232253 -2.126185; Gh(H_ene) 0.923621 1.232253 -2.126185; --; 0 1; X 9.0 9.0 9.0; C_yne 0.000000 0.000000 2.900503; C_yne 0.000000 0.000000 1.693240; H_yne 0.000000 0.000000 0.627352; H_yne 0.000000 0.000000 3.963929; }. eneyne.update_geometry(). for iat in range(eneyne.natom()):; print """"""{:4} {:4} {:12} {:8.4f} {:12.6f} {:12.6f} {:12.6f} {:12.6f}"""""".format(; eneyne.Z(iat), # atomic number; eneyne.symbol(iat), # element symbol; eneyne.label(iat), # input element label; eneyne.charge(iat), # element charge; eneyne.x(iat), # x-coordinate; eneyne.y(iat), # y-coordinate; eneyne.z(iat), # z-coordinate; eneyne.mass(iat), # mass; ). # 6.0 C C_ENE 6.0000 -0.031900 -1.218981 -3.948079 12.000000; # 6.0 C C_ENE 6.0000 -0.031900 1.304098 -3.948079 12.000000; # 1.0 H H_ENE 1.0000 1.713491 -2.286062 -3.950962 2.014000; # 1.0 H H_ENE 1.0000 -1.777290 -2.286062 -3.950962 1.007825; # 1.0 H H_ENE 1.0000 -1.777290 2.371180 -3.950962 1.007825; # 0.0 H H_ENE 0.0000 1.713491 2.371180 -3.950962 1.007825; # 6.0 C C_YNE 6.0000 -0.031900 0.042559 5.548101 12.000000; # 6.0 C C_YNE 6.0000 -0.031900 0.042559 3.266705 12.000000; # 1.0 H H_YNE 1.0000 -0.031900 0.042559 1.252468 1.007825; # 1.0 H H_YNE 1.0000 -0.031900 0.042559 7.557685 1.007825. table of contents. Molecule and Geometry Specification; Coordinates; Molecule Keywords; Multiple Molecules; Ghost Atoms; Isotopic Substitution; PubChem Database; Symmetry; Non-Covalently Bonded Molecule Fragments; Advanced Python. «; hide menu. menu; sidebar; »; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/psithonmol-1.html:19927,charge,charge,19927,psi4manual/1.4.0/psithonmol-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/psithonmol-1.html,18,['charge'],['charge']
Energy Efficiency,"'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype) – \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- they’re not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or str) – \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. name; calls method. scf; Hartree–Fock (HF) [manual]. Examples. >>> # [1] Frequency calculation for all modes through highest available derivatives; >>> frequency('ccsd'). >>> # [2] Frequency calculation for b2 modes through finite difference of gradients; >>> # printing lowest mode frequency to screen and Hessian to output; >>> E, wfn = frequencies('scf', dertype=1, irrep=4, return",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.freq-1.html:1366,energy,energy,1366,psi4manual/1.4.0/api/psi4.driver.freq-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.freq-1.html,20,['energy'],['energy']
Energy Efficiency,"'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype) – \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- they’re not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or str) – \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. name; calls method. scf; Hartree–Fock (HF) or LSDA density functional theory (DFT) [manual] [details]. Examples:. >>> # [1] Frequency calculation for all modes through highest available derivatives; >>> frequency('ccsd'). >>> # [2] Frequency calculation for b2 modes through finite difference of gradients; >>> # printing lowest mode frequency to screen and Hessian to output; >>> E, ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.freq.html:1370,energy,energy,1370,psi4manual/1.7.x/api/psi4.driver.freq.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.freq.html,16,['energy'],['energy']
Energy Efficiency,"'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype) – \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- they’re not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or string) – \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. name; calls method. scf; Hartree–Fock (HF) [manual]. Examples:. >>> # [1] Frequency calculation for all modes through highest available derivatives; >>> frequency('ccsd'). >>> # [2] Frequency calculation for b2 modes through finite difference of gradients; >>> # printing lowest mode frequency to screen and Hessian to output; >>> E, wfn = frequencies('scf', dertype=1, irrep=4, return_wfn",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.driver.freq-1.html:1363,energy,energy,1363,psi4manual/1.3.2/api/psi4.driver.freq-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.driver.freq-1.html,8,['energy'],['energy']
Energy Efficiency,"(""Cannot run adcc because the passed reference wavefunction is ""; ""not supported in adcc. Check Psi4 SCF parameters. adcc reports: ""; f""{ex}""); except Exception as ex:; raise ValidationError(""Unknown exception occured while ""; f""running adcc: '{ex}' ({type(ex).__name__})""); core.print_out(""\n""). # TODO Should a non-converged calculation throw?. #; # Interpret results; #; # Note: This wavefunction is not consistent ... the density; # is e.g. not the proper one (i.e. not the MP(n) one); adc_wfn = core.Wavefunction(ref_wfn.molecule(), ref_wfn.basisset()); adc_wfn.shallow_copy(ref_wfn); adc_wfn.set_reference_wavefunction(ref_wfn); adc_wfn.set_name(name); adc_wfn.set_module(""adcc""). # MP(3) energy for CVS-ADC(3) calculations is still a missing feature in adcc; # ... we store this variant here to be able to fall back to MP(2) energies.; is_cvs_adc3 = state.method.level >= 3 and state.ground_state.has_core_occupied_space. # Ground-state energies; mp = state.ground_state; mp_energy = mp.energy(state.method.level if not is_cvs_adc3 else 2); mp_corr = 0.0; if state.method.level > 1:; core.print_out(""Ground state energy breakdown:\n""); core.print_out("" Energy SCF {0:15.8g} [Eh]\n"".format(ref_wfn.energy())); for level in range(2, state.method.level + 1):; if level >= 3 and is_cvs_adc3:; continue; energy = mp.energy_correction(level); mp_corr += energy; adc_wfn.set_variable(f""MP{level} CORRELATION ENERGY"", energy); adc_wfn.set_variable(f""MP{level} TOTAL ENERGY"", mp.energy(level)); core.print_out(f"" Energy correlation MP{level} {energy:15.8g} [Eh]\n""); core.print_out("" Energy total {0:15.8g} [Eh]\n"".format(mp_energy)); adc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", mp_corr) # P::e ADC; adc_wfn.set_variable(""CURRENT ENERGY"", mp_energy) # P::e ADC. # Set results of excited-states computation; # TODO Does not work: Can't use strings; # adc_wfn.set_variable(""excitation kind"", state.kind); adc_wfn.set_variable(""number of excited states"", len(state.excitation_energy)); adc_wfn.set_v",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:117737,energy,energy,117737,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,5,['energy'],['energy']
Energy Efficiency,"('%s', **kwargs)\n\n"""""" % (optimize.__name__, lowername)); fmaster.write(instructionsM); fmaster.close(). for n, displacement in enumerate(displacements):; rfile = 'OPT-%s-%s' % (opt_iter, n + 1); #rfile = 'OPT-fd-%s' % (n + 1). # Build string of title banner; banners = ''; banners += """"""PsiMod.print_out('\\n')\n""""""; banners += """"""banner(' Gradient %d Computation: Displacement %d')\n"""""" % (opt_iter, n + 1); banners += """"""PsiMod.print_out('\\n')\n\n"""""". if (opt_mode.lower() == 'continuous'):; # Print information to output.dat; PsiMod.print_out('\n'); banner('Loading displacement %d of %d' % (n + 1, ndisp)). # Print information to the screen; print(' %d' % (n + 1), end=""""); if (n + 1) == ndisp:; print('\n', end=""""). # Load in displacement into the active molecule; PsiMod.get_active_molecule().set_geometry(displacement). # Perform the energy calculation; #E = func(lowername, **kwargs); func(lowername, **kwargs); E = PsiMod.get_variable('CURRENT ENERGY'); #E = func(**kwargs). # Save the energy; energies.append(E). # S/R: Write each displaced geometry to an input file; elif (opt_mode.lower() == 'sow'):; PsiMod.get_active_molecule().set_geometry(displacement). # S/R: Prepare molecule, options, and kwargs; freagent = open('%s.in' % (rfile), 'w'); freagent.write('# This is a psi4 input file auto-generated from the gradient() wrapper.\n\n'); freagent.write(format_molecule_for_input(molecule)); freagent.write(format_options_for_input()); format_kwargs_for_input(freagent, **kwargs). # S/R: Prepare function call and energy save; freagent.write(""""""electronic_energy = %s('%s', **kwargs)\n\n"""""" % (func.__name__, lowername)); freagent.write(""""""PsiMod.print_out('\\nGRADIENT RESULT: computation %d for item %d """""" % (os.getpid(), n + 1)); freagent.write(""""""yields electronic energy %20.12f\\n' % (electronic_energy))\n\n""""""); freagent.close(). # S/R: Read energy from each displaced geometry output file and save in energies array; elif (opt_mode.lower() == 'reap'):; E = 0.0; exec(banners)",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/driver.html:30182,energy,energy,30182,psi4manual/4.0b3/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/driver.html,2,['energy'],['energy']
Energy Efficiency,"('Meta_a0' , 1.0); X.set_parameter('Meta_a1' ,-0.1637571); X.set_parameter('Meta_a2' ,-0.1880028); X.set_parameter('Meta_a3' ,-0.4490609); X.set_parameter('Meta_a4' ,-0.0082359). C = build_functional('M_C'); C.set_name('dlDF_C'). # LSDA Correlation type is PW92, no parameters. # GGA Correlation type is B97; C.set_parameter('B97_os_gamma', 0.0031 * 2.0); C.set_parameter('B97_os_a0', 1.00000); C.set_parameter('B97_os_a1', 5.9515308); C.set_parameter('B97_os_a2',-11.1602877). C.set_parameter('B97_ss_gamma', 0.06); C.set_parameter('B97_ss_a0', 1.00000); C.set_parameter('B97_ss_a1',-2.5960897); C.set_parameter('B97_ss_a2', 2.2233793). # Meta Correlation type is Becke metric, no parameters. # Add the functionals in; sup.add_x_functional(X); sup.add_c_functional(C). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.6144129) # Hartree-Fock exact exchange; sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_dldfd09_superfunctional(name, npoints, deriv):. sup = build_dldf_superfunctional(name, npoints, deriv); sup.set_name('dlDF+D09'). # => +D <= #; sup.set_dispersion(PsiMod.Dispersion.build('-DAS2009', 1.0)) # Does not have an s6, so set to 1.0. return sup. [docs]def build_dldfd_superfunctional(name, npoints, deriv):. sup = build_dldf_superfunctional(name, npoints, deriv); sup.set_name('dlDF+D'). # => +D <= #; sup.set_dispersion(PsiMod.Dispersion.build('-DAS2010', 1.0)) # Does not have an s6, so set to 1.0. return sup. [docs]def build_hfd_superfunctional(name, npoints, deriv):. sup = PsiMod.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv); sup.set_name('HF+D'); sup.set_x_alpha(1.0). # => +D <= #; sup.set_dispersion(PsiMod.Dispersion.build('-DAS2010', 1.0)) # Does not have an s6, so set to 1.0. sup.allocate(); return sup. [docs]def build_b2plyp_superfunctional(name, npoints, deriv):. # Call this first; sup = PsiMod.SuperFunctional.blank",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/functional.html:59858,allocate,allocate,59858,psi4manual/4.0b3/_modules/functional.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/functional.html,1,['allocate'],['allocate']
Energy Efficiency,"('\\n')\n\n""""""; exec(banners). tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); PsiMod.print_out(tables). return e_mp25. # A direct translation of a plugin input file into a function call. Function calls are the only; # way to call plugins in sow/reap mode for db(), opt(), etc. This isn't best practices; # but is an example of what to do for a more complicated procedure where different options ; # are set for different qc steps.; [docs]def run_plugin_omega(name, **kwargs):; r""""""Function encoding sequence of PSI module and plugin calls, as well; as typical options, to access Rob Parrish's omega plugin. >>> energy('plugin_omega'). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). plugfile = PsiMod.Process.environment[""PSIDATADIR""] + ""/../tests/plugin_omega/plugin_omega.so""; PsiMod.plugin_load(""%s"" % (plugfile)). PsiMod.set_global_option('BASIS', 'AUG-CC-PVDZ'); PsiMod.set_global_option('DF_BASIS_SCF', 'AUG-CC-PVDZ-RI'); PsiMod.set_global_option('REFERENCE', 'UHF'); PsiMod.set_global_option('SCF_TYPE', 'DF'); energy('scf', **kwargs). PsiMod.set_global_option('dft_functional', 'wB97'); PsiMod.set_global_option('dft_order_spherical', 25); PsiMod.set_global_option('dft_num_radial', 35); PsiMod.set_global_option('omega_procedure', 'ip'); PsiMod.set_global_option('maxiter', 50); PsiMod.set_global_option('d_convergence', 5); PsiMod.set_global_option('e_convergence', 7); PsiMod.plugin(""plugin_omega.so""). return PsiMod.get_variable('SCF TOTAL ENERGY'). # Integration with driver routines; procedures['energy']['mp2.5'] = run_mp2_5; procedures['energy']['sherrillgroup_gold_standard'] = sherrillgro",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/aliases.html:4415,energy,energy,4415,psi4manual/4.0b3/_modules/aliases.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/aliases.html,1,['energy'],['energy']
Energy Efficiency,"('delta_basis')). # Establish list of valid basis sets for second delta correction energy; if do_delta2:; if 'delta2_basis' in kwargs:; BSTD2, ZETD2 = validate_bracketed_basis(kwargs['delta2_basis'].lower()); else:; raise ValidationError('DELTA2 basis sets through keyword \'%s\' are required.' % ('delta2_basis')). # Establish list of valid basis sets for third delta correction energy; if do_delta3:; if 'delta3_basis' in kwargs:; BSTD3, ZETD3 = validate_bracketed_basis(kwargs['delta3_basis'].lower()); else:; raise ValidationError('DELTA3 basis sets through keyword \'%s\' are required.' % ('delta3_basis')). # Establish list of valid basis sets for fourth delta correction energy; if do_delta4:; if 'delta4_basis' in kwargs:; BSTD4, ZETD4 = validate_bracketed_basis(kwargs['delta4_basis'].lower()); else:; raise ValidationError('DELTA4 basis sets through keyword \'%s\' are required.' % ('delta4_basis')). # Establish list of valid basis sets for fifth delta correction energy; if do_delta5:; if 'delta5_basis' in kwargs:; BSTD5, ZETD5 = validate_bracketed_basis(kwargs['delta5_basis'].lower()); else:; raise ValidationError('DELTA5 basis sets through keyword \'%s\' are required.' % ('delta5_basis')). # Establish treatment for scf energy (validity check useless since python will catch it long before here); cbs_scf_scheme = highest_1; if 'scf_scheme' in kwargs:; cbs_scf_scheme = kwargs['scf_scheme']. # Establish treatment for correlation energy; cbs_corl_scheme = highest_1; if 'corl_scheme' in kwargs:; cbs_corl_scheme = kwargs['corl_scheme']. # Establish treatment for delta correction energy; cbs_delta_scheme = highest_1; if 'delta_scheme' in kwargs:; cbs_delta_scheme = kwargs['delta_scheme']. # Establish treatment for delta2 correction energy; cbs_delta2_scheme = highest_1; if 'delta2_scheme' in kwargs:; cbs_delta2_scheme = kwargs['delta2_scheme']. # Establish treatment for delta3 correction energy; cbs_delta3_scheme = highest_1; if 'delta3_scheme' in kwargs:; cbs_delta3_scheme =",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:77108,energy,energy,77108,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,1,['energy'],['energy']
Energy Efficiency,"('mp3', **kwargs); e_scf = psi4.get_variable('SCF TOTAL ENERGY'); ce_mp2 = psi4.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = psi4.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; psi4.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; psi4.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; psi4.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); psi4.set_variable('CURRENT ENERGY', e_mp25) # geometry optimizer tracks this variable, permits; # MP2.5 finite difference optimizations; # build string of title banner and print results; banners = ''; banners += """"""psi4.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""psi4.print_out('\\n')\n\n""""""; exec banners. tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); psi4.print_out(tables) # prints nice header and table of all involved quantities to output file. return e_mp25. One final step is necessary. At the end of the aliases.py file, add; the following line.; 1procedures['energy']['mp2.5'] = run_mp2_5. This permits the newly defined MP2.5 method to be called in the input file; with the following command.; 1energy('mp2.5'). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Customization: Adding Simple Extensions. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/quickaddalias-1.html:3089,energy,energy,3089,psi4manual/1.3.2/quickaddalias-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/quickaddalias-1.html,14,['energy'],['energy']
Energy Efficiency,"('sherrill_gold_standard'). >>> # [3] finite-difference geometry optimization, overwriting some pre-defined sherrill_gold_standard options; >>> optimize('sherrill_gold_standard', corl_basis='cc-pV[DT]Z', delta_basis='3-21g'). Return type:; List[Dict[str, Any]]. psi4.driver.aliases.allen_focal_point(**kwargs)[source]¶; Function to call Wes Allen-style Focal; Point Analysis. JCP 127 014306, https://doi.org/10.1063/1.2747241 .; Uses the composite wrapper to evaluate the following; expression. SCF employs a three-point extrapolation according; to scf_xtpl_helgaker_3(). MP2, CCSD, and; CCSD(T) employ two-point extrapolation performed according to; corl_xtpl_helgaker_2(). CCSDT and CCSDT(Q); are plain deltas. This wrapper requires Kallay’s MRCC code. \[E_{total}^{\text{FPA}} = E_{total,\; \text{SCF}}^{\text{cc-pV[Q56]Z}} \; + E_{corl,\; \text{MP2}}^{\text{cc-pV[56]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CCSD}}^{\text{CCSD(T)}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CCSD(T)}}^{\text{CCSDT}}\big\vert_{\text{cc-pVTZ}} \; + \delta_{\text{CCSDT}}^{\text{CCSDT(Q)}}\big\vert_{\text{cc-pVDZ}}\]; >>> # [1] single-point energy by this composite method; >>> energy('allen_focal_point'). >>> # [2] single-point energy reducing the Hartree-Fock basis sets size; >>> energy('allen_focal_point', scf_basis='cc-pV[TQ5]Z'). Return type:; List[Dict[str, Any]]. Additional composite aliases are easy to define by the; user. Follow models in psi4/psi4/driver/aliases.py; and cbs-xtpl-nbody and use the; psi4.driver.driver_cbs_helper.register_composite_function(); to make user-defined functions known to PSI4. psi4.driver.driver_cbs_helper.register_composite_function(func)[source]¶; Register a user-defined composite method function to use like a built-in one. Parameters:; func (Callable) – A Python function that defines a configuration of the psi4.driver.cbs() wrapper.; See psi4/psi4/driver/aliases.py and cbs-xtpl-nbody for examples. API¶. pyd",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/cbs.html:32215,energy,energy,32215,psi4manual/1.7.x/cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/cbs.html,2,['energy'],['energy']
Energy Efficiency,"('symbol'). # We don't know whether the @C or Gh(C) notation matched. Do a quick check.; ghostAtom = False if (atomm.group('gh1') is None and atomm.group('gh2') is None) else True. # Check that the atom symbol is valid; if not atomSym in el2z:; raise ValidationError('Molecule::create_molecule_from_string: Illegal atom symbol in geometry specification: %s' % (atomSym)). zVal = el2z[atomSym]; atomMass = el2mass[atomSym] if atomm.group('mass') is None else float(atomm.group('mass')); charge = float(zVal); if ghostAtom:; zVal = 0; charge = 0.0. # handle cartesians; if len(entries) == 4:; tempfrag.append(iatom); xval = self.get_coord_value(entries[1]); yval = self.get_coord_value(entries[2]); zval = self.get_coord_value(entries[3]); self.full_atoms.append(CartesianEntry(iatom, zVal, charge, \; atomMass, atomSym, atomLabel, \; xval, yval, zval)). # handle first line of Zmat; elif len(entries) == 1:; zmatrix = True; tempfrag.append(iatom); self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; atomMass, atomSym, atomLabel)). # handle second line of Zmat; elif len(entries) == 3:; zmatrix = True; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Molecule::create_molecule_from_string: Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); rval = self.get_coord_value(entries[2]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; atomMass, atomSym, atomLabel, \; self.full_atoms[rTo], rval)). # handle third line of Zmat; elif len(entries) == 5:; zmatrix = True; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Molecule::create_molecule_from_string: Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); aTo = self.get_anchor_atom(entries[3], line); if aTo >= iatom:; raise ValidationError(""Molecule::create_mol",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:19134,charge,charge,19134,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,1,['charge'],['charge']
Energy Efficiency,"((1.05052209e-3*we*d3)/(np.sqrt(B * d2**3))+1.0); de = 4.0*B**3 / we**2. # B0 and r0 (plus re check using Be); B0 = B - ae / 2.0; r0 = np.sqrt(constants.h / (8.0 * np.pi**2 * mu * constants.c * B0)); recheck = np.sqrt(constants.h / (8.0 * np.pi**2 * mu * constants.c * B)); r0 /= angstrom_to_meter; recheck /= angstrom_to_meter. # Fundamental frequency nu; nu = we - 2.0 * wexe; zpve_nu = 0.5 * we - 0.25 * wexe; zpve_we = 0.5 * we. # Generate pretty pictures, if requested; if(plot_fit):; try:; import matplotlib.pyplot as plt; except ImportError:; msg = ""\n\tPlot not generated; matplotlib is not installed on this machine.\n\n""; print(msg); core.print_out(msg). # Correct the derivatives for the missing factorial prefactors; dvals = np.zeros(5); dvals[0:5] = derivs[0:5]; dvals[2] /= 2; dvals[3] /= 6; dvals[4] /= 24. # Default plot range, before considering energy levels; minE = np.min(energies); maxE = np.max(energies); minR = np.min(rvals); maxR = np.max(rvals). # Plot vibrational energy levels; we_au = we / constants.hartree2wavenumbers; wexe_au = wexe / constants.hartree2wavenumbers; coefs2 = [ dvals[2], dvals[1], dvals[0] ]; coefs4 = [ dvals[4], dvals[3], dvals[2], dvals[1], dvals[0] ]; for n in range(3):; Eharm = we_au*(n+0.5); Evpt2 = Eharm - wexe_au*(n+0.5)**2; coefs2[-1] = -Eharm; coefs4[-1] = -Evpt2; roots2 = np.roots(coefs2); roots4 = np.roots(coefs4); xvals2 = roots2 + re; xvals4 = np.choose(np.where(np.isreal(roots4)), roots4)[0].real + re; Eharm += dvals[0]; Evpt2 += dvals[0]; plt.plot(xvals2, [Eharm, Eharm], 'b', linewidth=1); plt.plot(xvals4, [Evpt2, Evpt2], 'g', linewidth=1); maxE = Eharm; maxR = np.max([xvals2,xvals4]); minR = np.min([xvals2,xvals4]). # Find ranges for the plot; dE = maxE - minE; minE -= 0.2*dE; maxE += 0.4*dE; dR = maxR - minR; minR -= 0.2*dR; maxR += 0.2*dR. # Generate the fitted PES; xpts = np.linspace(minR, maxR, 1000); xrel = xpts - re; xpows = xrel[:, None] ** range(5); fit2 = np.einsum('xd,d', xpows[:,0:3], dvals[0:3]); fit4 = np.e",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/diatomic.html:7527,energy,energy,7527,psi4manual/1.4.0/_modules/psi4/driver/diatomic.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/diatomic.html,7,['energy'],['energy']
Energy Efficiency,() LibmintsMolecule method. set_full_point_group() LibmintsMolecule method. set_function_index() ShellInfo method. set_geometry() LibmintsMolecule method. set_ghost_fragment() LibmintsMolecule method. set_ghost_fragments() LibmintsMolecule method. set_ghosted() CoordEntry method. set_has_zmatrix() LibmintsMolecule method. set_memory() in module p4util.util. set_molecular_charge() LibmintsMolecule method. set_multiplicity() LibmintsMolecule method. set_name() BasisSet method. LibmintsMolecule method. set_num_threads() in module p4util.util. set_point_group() LibmintsMolecule method. set_radius() InPsight method. set_shell() CoordEntry method. set_shell_by_number() LibmintsMolecule method. set_size() InPsight method. set_symbol() PointGroup method. set_units() LibmintsMolecule method. set_variable() LibmintsMolecule method. set_view() InPsight method. setdefault() OrderedDict method. PreservingDict method. setting; . keywords anharmonicity(). keywords cbs(). keywords database(). keywords energy(). keywords frequency(). keywords general. keywords molecule. keywords optimize(). keywords property(). SF_RESTRICT (DETCI). shell() BasisSet method. CoordEntry method. shell_on_center() BasisSet method. shell_sorter_am() BasisSet static method. shell_sorter_ncenter() BasisSet static method. shell_to_ao_function() BasisSet method. shell_to_basis_function() BasisSet method. shell_to_center() BasisSet method. ShellInfo class in qcdb.libmintsgshell. shells() CoordEntry method. sherrill_gold_standard() in module aliases. show() in module qcdb.vecutil. sigma_h() SymRep method. SIGMA_OVERLAP (DETCI). sigma_xy() SymmetryOperation method. sigma_xz() SymmetryOperation method. SymRep method. sigma_yz() SymmetryOperation method. SymRep method. similar() in module qcdb.libmintspointgrp. single-point. SINGLES_PRINT (CCEOM). sky InPsight attribute. SMALL_CUTOFF (PSIMRCC). SOCC (GLOBALS). (MCSCF). SOLVER_CONVERGENCE (CPHF). SOLVER_EXACT_DIAGONAL (CPHF). SOLVER_MAX_SUBSPACE (CPHF). SOLVER_MAXIT,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/genindex.html:129971,energy,energy,129971,psi4manual/1.0.0/genindex.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/genindex.html,1,['energy'],['energy']
Energy Efficiency,"() family when functions pass. basislistdunning¶; Module (auto-generated from make_dunning.pl script); with commands building BasisFamily objects that; encode the Dunning basis set orbital definitions in; psi4/lib/basis/NOTES and fitting bases designed for those; orbital bases. load_basfam_dunning()[source]¶. aliases¶; Module with functions that call upon those in modules; proc, driver, and wrappers. Place in this file quickly defined procedures such as. aliases for complex methods; simple modifications to existing methods. run_mp2_5(name, **kwargs)[source]¶; Function that computes MP2.5 energy from results of a DETCI; MP3 calculation. Psi variables:. MP2.5 TOTAL ENERGY; MP2.5 CORRELATION ENERGY. >>> energy('mp2.5'). sherrillgroup_gold_standard(name='conv-mp2', **kwargs)[source]¶; Function to call the quantum chemical method known as ‘Gold Standard’; in the Sherrill group. Uses complete_basis_set() to evaluateo; the following expression. Two-point extrapolation of the correlation energy; performed according to corl_xtpl_helgaker_2(). >>> energy('sherrillgroup_gold_standard'). qcdb¶; Module to facilitate quantum chemical computations on chemical; databases. Contains Molecule class and physical constants from psi4 suite.; Module to largely replicate in python the psi4 libmints; CoordValue and CoordEntry classes, which were developed by; Justin M. Turney, with incremental improvements by other; psi4 developers. class CartesianEntry(entry_number, Z, charge, mass, symbol, label, x, y, z)[source]¶; Class to hold all information about an atom, including its; coordinate specification as three Cartesians. clone()[source]¶; Returns new, independent CartesianEntry object. compute()[source]¶; Computes the values of the coordinates (in whichever units; were inputted), returning them in a Vector. everything()[source]¶. invalidate()[source]¶; Flags the current coordinates as being outdated. print_in_input_format()[source]¶; Prints the updated geometry, in the format provided by th",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_driver-1.html:34537,energy,energy,34537,psi4manual/4.0b3/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_driver-1.html,2,['energy'],['energy']
Energy Efficiency,"() in module psi4.core, [1]. DYNAMIC_LEVEL (OPTKING). dynamic_variable_bind() in module psi4.driver. E. E() psi4.core.SymmetryOperation method, [1], [2]. E3_SCALE (DFOCC). (OCC). E_CONVERGENCE (CCENERGY). (CCEOM). (DCFT). (DETCI). (DFOCC). (FNOCC). (MCSCF). (MRCC). (OCC). (PSIMRCC). (SAPT). (SCF). EA_POLES (OCC). EFP. adding new. library fragments, [1]. molecule specification. EFP class in psi4.core, [1]. EFP_DISP (EFP). EFP_DISP_DAMPING (EFP). EFP_ELST (EFP). EFP_ELST_DAMPING (EFP). EFP_EXCH (EFP). efp_init() in module psi4.core, [1]. EFP_POL (EFP). EFP_POL_DAMPING (EFP). efp_set_options() in module psi4.core, [1]. EKT_EA (OCC). EKT_IP (DFOCC). (OCC). electric_field() psi4.core.IntegralFactory method, [1], [2]. ElectricFieldInt class in psi4.core, [1]. electrostatic() psi4.core.IntegralFactory method, [1], [2]. ElectrostaticInt class in psi4.core, [1]. EmpericalDispersion class in psi4.driver. EndLoop psi4.core.PsiReturnType attribute, [1], [2]. energy(). setting keywords. energy() in module psi4. in module psi4.driver. psi4.core.CIWavefunction method, [1]. psi4.core.CUHF method, [1]. psi4.core.HF method, [1]. psi4.core.RHF method, [1]. psi4.core.ROHF method, [1]. psi4.core.UHF method, [1]. psi4.core.Wavefunction method, [1], [2]. ENERGY_LEVEL_SHIFT (DCFT). ENSURE_BT_CONVERGENCE (OPTKING). environment variable. ; CRAYPE_LINK_TYPE. CRAY_ADD_RPATH. MATH_ROOT. MKL_NUM_THREADS, [1]. MKL_ROOT. MONTAGE. OMP_NESTED, [1], [2]. OMP_NUM_THREADS, [1], [2], [3], [4], [5], [6], [7], [8], [9]. PATH, [1], [2], [3], [4], [5], [6], [7], [8], [9], [10], [11], [12], [13], [14], [15], [16], [17], [18], [19], [20], [21], [22], [23], [24], [25], [26], [27], [28], [29], [30], [31], [32], [33], [34], [35]. PSIDATADIR, [1], [2], [3], [4], [5]. PSIPATH, [1], [2], [3], [4], [5], [6], [7], [8], [9], [10], [11], [12], [13], [14], [15], [16], [17], [18], [19], [20], [21], [22], [23], [24]. PSI_SCRATCH, [1], [2], [3], [4], [5], [6], [7], [8], [9], [10], [11], [12]. PYTHONPATH, [1], [2], [3], [4],",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/genindex-1.html:38036,energy,energy,38036,psi4manual/1.1.0/genindex-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/genindex-1.html,2,['energy'],['energy']
Energy Efficiency,"() is a light wrapper over; hessian() that computes the Hessian then adds a; thermochemical analysis. psi4.frequency(name[, molecule, return_wfn, func, mode, dertype, irrep])[source]; Function to compute harmonic vibrational frequencies. Aliases; frequencies(), freq(). Returns; float – Total electronic energy in Hartrees. Returns; (float, Wavefunction) – energy and wavefunction when return_wfn specified. Parameters. name (str) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype) – \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- they’re not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or str) – \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences acc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/freq-1.html:1675,energy,energy,1675,psi4manual/1.4.0/freq-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/freq-1.html,5,['energy'],['energy']
Energy Efficiency,"())); nbody_results.update(assemble_nbody_components(""hessian"", trove[""hessian""], metadata.copy())). def delabeler(item: str, return_obj: bool = False) -> Union[Tuple[str, str, str], Tuple[int, Tuple[int], Tuple[int]]]:; """"""Transform labels like string ""1_((2,), (1, 2))"" into string tuple (""1"", ""2"", ""1, 2"") or object tuple (1, (2,), (1, 2))."""""". mc, _, fragbas = item.partition(""_""); frag, bas = literal_eval(fragbas). if return_obj:; return int(mc), frag, bas; else:; return mc, "", "".join(map(str, frag)), "", "".join(map(str, bas)). # save some mc_(frag, bas) component results; # * formerly, intermediates_energy was intermediates2; # * formerly, intermediates_gradient was intermediates_ptype; # * formerly, intermediates_hessian was intermediates_ptype. nbody_results[""intermediates""] = {}; for idx, task in results_list.items():; mc, frag, bas = delabeler(idx); nbody_results[""intermediates""][f""N-BODY ({frag})@({bas}) TOTAL ENERGY""] = task.properties.return_energy. nbody_results[""intermediates_energy""] = trove[""energy""]. if not all(x is None for x in trove[""gradient""].values()):; nbody_results[""intermediates_gradient""] = trove[""gradient""]. if not all(x is None for x in trove[""hessian""].values()):; nbody_results[""intermediates_hessian""] = trove[""hessian""]. debug = False; if debug:; for k, v in nbody_results.items():; if isinstance(v, np.ndarray):; print(f""CLS-prepared results >>> {k} {v.size}""); elif isinstance(v, dict):; print(f""CLS-prepared results >>> {k} {len(v)}""); for k2, v2 in v.items():; if isinstance(v2, np.ndarray):; print(f""CLS-prepared results >>> {k2} {v2.size}""); else:; print(f""CLS-prepared results >>> {k2} {v2}""); else:; print(f""CLS-prepared results >>> {k} {v}""). return nbody_results. [docs] def get_results(self, client: Optional[""FractalClient""] = None) -> AtomicResult:; """"""Return results as ManyBody-flavored QCSchema."""""". info = ""\n"" + p4util.banner(f"" ManyBody Results "", strNotOutfile=True) + ""\n""; core.print_out(info); logger.info(info). results = self.pr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html:88226,energy,energy,88226,psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html,1,['energy'],['energy']
Energy Efficiency,"())); nbody_results.update(assemble_nbody_components(""hessian"", trove[""hessian""], metadata.copy())). def delabeler(item: str, return_obj: bool = False) -> Union[Tuple[str, str, str], Tuple[int, Tuple[int], Tuple[int]]]:; """"""Transform labels like string ""1_((2,), (1, 2))"" into string tuple (""1"", ""2"", ""1, 2"") or object tuple (1, (2,), (1, 2))."""""". mc, _, fragbas = item.partition(""_""); frag, bas = literal_eval(fragbas). if return_obj:; return int(mc), frag, bas; else:; return mc, "", "".join(map(str, frag)), "", "".join(map(str, bas)). # save some mc_(frag, bas) component results; # * formerly, intermediates_energy was intermediates2; # * formerly, intermediates_gradient was intermediates_ptype; # * formerly, intermediates_hessian was intermediates_ptype. nbody_results[""intermediates""] = {}; for idx, task in results_list.items():; mc, frag, bas = delabeler(idx); nbody_results[""intermediates""][f""N-BODY ({frag})@({bas}) TOTAL ENERGY""] = task.properties.return_energy. nbody_results[""intermediates_energy""] = trove[""energy""]. if not all(x is None for x in trove[""gradient""].values()):; nbody_results[""intermediates_gradient""] = trove[""gradient""]. if not all(x is None for x in trove[""hessian""].values()):; nbody_results[""intermediates_hessian""] = trove[""hessian""]. debug = False; if debug:; for k, v in nbody_results.items():; if isinstance(v, np.ndarray):; print(f""CLS-prepared results >>> {k} {v.size}""); elif isinstance(v, dict):; print(f""CLS-prepared results >>> {k} {len(v)}""); for k2, v2 in v.items():; if isinstance(v2, np.ndarray):; print(f""CLS-prepared results >>> {k2} {v2.size}""); else:; print(f""CLS-prepared results >>> {k2} {v2}""); else:; print(f""CLS-prepared results >>> {k} {v}""). return nbody_results. [docs] def get_results(self, client: Optional[""qcportal.FractalClient""] = None) -> AtomicResult:; """"""Return results as ManyBody-flavored QCSchema."""""". info = ""\n"" + p4util.banner(f"" ManyBody Results "", strNotOutfile=True) + ""\n""; core.print_out(info); logger.info(info). results ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_nbody.html:88651,energy,energy,88651,psi4manual/1.7.x/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_nbody.html,1,['energy'],['energy']
Energy Efficiency,"())); nbody_results.update(assemble_nbody_components(""hessian"", trove[""hessian""], metadata.copy())). def delabeler(item: str, return_obj: bool = False) -> Union[Tuple[str, str, str], Tuple[int, Tuple[int], Tuple[int]]]:; """"""Transform labels like string ""1_((2,), (1, 2))"" into string tuple (""1"", ""2"", ""1, 2"") or object tuple (1, (2,), (1, 2))."""""". mc, _, fragbas = item.partition(""_""); frag, bas = literal_eval(fragbas). if return_obj:; return int(mc), frag, bas; else:; return mc, "", "".join(map(str, frag)), "", "".join(map(str, bas)). # save some mc_(frag, bas) component results; # * formerly, intermediates_energy was intermediates2; # * formerly, intermediates_gradient was intermediates_ptype; # * formerly, intermediates_hessian was intermediates_ptype. nbody_results[""intermediates""] = {}; for idx, task in results_list.items():; mc, frag, bas = delabeler(idx); nbody_results[""intermediates""][f""N-BODY ({frag})@({bas}) TOTAL ENERGY""] = task.properties.return_energy. nbody_results[""intermediates_energy""] = trove[""energy""]. if not all(x is None for x in trove[""gradient""].values()):; nbody_results[""intermediates_gradient""] = trove[""gradient""]. if not all(x is None for x in trove[""hessian""].values()):; nbody_results[""intermediates_hessian""] = trove[""hessian""]. debug = False; if debug:; for k, v in nbody_results.items():; if isinstance(v, np.ndarray):; print(f""CLS-prepared results >>> {k} {v.size}""); elif isinstance(v, dict):; print(f""CLS-prepared results >>> {k} {len(v)}""); for k2, v2 in v.items():; if isinstance(v2, np.ndarray):; print(f""CLS-prepared results >>> {k2} {v2.size}""); else:; print(f""CLS-prepared results >>> {k2} {v2}""); else:; print(f""CLS-prepared results >>> {k} {v}""). return nbody_results. [docs]; def get_results(self, client: Optional[""qcportal.FractalClient""] = None) -> AtomicResult:; """"""Return results as ManyBody-flavored QCSchema."""""". info = ""\n"" + p4util.banner(f"" ManyBody Results "", strNotOutfile=True) + ""\n""; core.print_out(info); logger.info(info). results",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:88738,energy,energy,88738,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,3,['energy'],['energy']
Energy Efficiency,"(). \[E_{total}^{\text{Au\_std}} = E_{total,\; \text{SCF}}^{\text{aug-cc-pVQZ}} \; + E_{corl,\; \text{MP2}}^{\text{aug-cc-pV[TQ]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD(T)}}\big\vert_{\text{aug-cc-pVTZ}}\]; 1; 2>>> # [1] single-point energy by this composite method; >>> energy('sherrill_gold_standard'). 1; 2>>> # [2] finite-difference geometry optimization; >>> optimize('sherrill_gold_standard'). 1; 2>>> # [3] finite-difference geometry optimization, overwriting some pre-defined sherrill_gold_standard options; >>> optimize('sherrill_gold_standard', corl_basis='cc-pV[DT]Z', delta_basis='3-21g'). psi4.driver.aliases.allen_focal_point(func, label, **kwargs)[source]¶; Function to call Wes Allen-style Focal; Point Analysis. JCP 127 014306. Uses; complete_basis_set() to evaluate the following; expression. SCF employs a three-point extrapolation according; to scf_xtpl_helgaker_3(). MP2, CCSD, and; CCSD(T) employ two-point extrapolation performed according to; corl_xtpl_helgaker_2(). CCSDT and CCSDT(Q); are plain deltas. This wrapper requires Kallay’s MRCC code. \[E_{total}^{\text{FPA}} = E_{total,\; \text{SCF}}^{\text{cc-pV[Q56]Z}} \; + E_{corl,\; \text{MP2}}^{\text{cc-pV[56]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CCSD}}^{\text{CCSD(T)}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CCSD(T)}}^{\text{CCSDT}}\big\vert_{\text{cc-pVTZ}} \; + \delta_{\text{CCSDT}}^{\text{CCSDT(Q)}}\big\vert_{\text{cc-pVDZ}}\]; 1; 2>>> # [1] single-point energy by this composite method; >>> energy('allen_focal_point'). 1; 2>>> # [2] finite-difference geometry optimization embarrasingly parallel; >>> optimize('allen_focal_point', mode='sow'). table of contents. Complete Basis Set; Output; Extrapolation Schemes; Aliases. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Psithon Functions: Invoking a Calculation. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/cbs-1.html:19977,energy,energy,19977,psi4manual/1.1.0/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/cbs-1.html,4,['energy'],['energy']
Energy Efficiency,"(). for n, displacement in enumerate(findif_meta_dict[""displacements""].values(), start=2):; _process_displacement(; energy, lowername, molecule, displacement, n, ndisp, write_orbitals=False, **kwargs). # Reset variables; for key, val in var_dict.items():; core.set_variable(key, val). # Assemble Hessian from energies; H = driver_findif.assemble_hessian_from_energies(findif_meta_dict, irrep); wfn.set_hessian(core.Matrix.from_array(H)); wfn.set_gradient(G0). # Explicitly set the current energy..; core.set_variable('CURRENT ENERGY', findif_meta_dict[""reference""][""energy""]); wfn.set_variable('CURRENT ENERGY', findif_meta_dict[""reference""][""energy""]). core.set_global_option(""PARENT_SYMMETRY"", """"); optstash.restore(); optstash_conv.restore(). _hessian_write(wfn). if return_wfn:; return (wfn.hessian(), wfn); else:; return wfn.hessian(). [docs]def frequency(name, **kwargs):; r""""""Function to compute harmonic vibrational frequencies. :aliases: frequencies(), freq(). :returns: *float* |w--w| Total electronic energy in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:82044,energy,energy,82044,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,1,['energy'],['energy']
Energy Efficiency,"(); optstash.restore(); optstash_conv.restore(). #if isinstance(lowername, str) and lowername in procedures['energy']:; # # this correctly filters out cbs fn and ""hf/cc-pvtz""; # # it probably incorrectly filters out mp5, but reconsider in DDD; # core.set_variable(f""CURRENT HESSIAN"", H); # core.set_variable(f""{lowername.upper()} TOTAL HESSIAN"", H); # core.set_variable(f""{lowername.upper()} TOTAL GRADIENT"", G0); # wfn.set_variable(f""{lowername.upper()} TOTAL HESSIAN"", H); # wfn.set_variable(f""{lowername.upper()} TOTAL GRADIENT"", G0); # TODO: check that current energy's being set to the right figure when this code is actually used; core.set_variable('CURRENT ENERGY', wfn.energy()); core.set_variable(""CURRENT GRADIENT"", G0); driver_findif.hessian_write(wfn). if return_wfn:; return (wfn.hessian(), wfn); else:; return wfn.hessian(). [docs]; def frequency(name, **kwargs):; r""""""Function to compute harmonic vibrational frequencies. :aliases: frequencies(), freq(). :returns: *float* |w--w| Total electronic energy in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:83272,energy,energy,83272,psi4manual/1.8.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html,3,['energy'],['energy']
Energy Efficiency,"()[source]¶; Gets specialization type of CoordValue. variable_to_string(precision)[source]¶; Takes a CoordValue object, and returns a string for printing. class VariableValue(name, geometryVariables, negate=False, fixed=False)[source]¶; Specialization of CoordValue, where the current value depends; on the list of geometry values stored by the molecule. clone()[source]¶; Returns new, independent VariableValue object. compute()[source]¶; Computes value of coordinate from member data. everything()[source]¶. name()[source]¶; Gets the name of the variable. negated()[source]¶; Gets whether the coordinate value is actually the negative of the variable value. rset(val)[source]¶; Resets value of coordinate if not fixed. type()[source]¶; Gets specialization type of CoordValue. variable_to_string(precision)[source]¶; Takes a CoordValue object, and returns a string for printing. class ZMatrixEntry(entry_number, Z, charge, mass, symbol, label, rto=None, rval=0, ato=None, aval=0, dto=None, dval=0)[source]¶; Class to hold all information about an atom, including its; coordinate specification as any position of ZMatrix. clone()[source]¶; Returns new, independent ZMatrixEntry object. compute()[source]¶; Compute the Cartesian coordinates in Bohr of current atom’s entry. everything()[source]¶. invalidate()[source]¶; Flags the current coordinates as being outdated. print_in_input_format()[source]¶; Prints the updated geometry, in the format provided by the user. set_coordinates(x, y, z)[source]¶; Given the current set of coordinates, updates the values of this; atom’s coordinates, and any variables that may depend on it. type()[source]¶; The type of CoordEntry specialization. class LibmintsMolecule(psi4molstr=None)[source]¶; Class to store the elements, coordinates, fragmentation pattern,; charge, multiplicity of a molecule. Largely replicates psi4’s libmints; Molecule class, developed by Justin M. Turney and Andy M. Simmonett; with incremental improvements by other psi4 developers. Ma",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodoc_driver-1.html:42312,charge,charge,42312,psi4manual/4.0b5/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodoc_driver-1.html,2,['charge'],['charge']
Energy Efficiency,"()[source]¶; Gets specialization type of CoordValue. variable_to_string(precision)[source]¶; Takes a CoordValue object, and returns a string for printing. class VariableValue(name, geometryVariables, negate=False, fixed=False)[source]¶; Specialization of CoordValue, where the current value depends; on the list of geometry values stored by the molecule. clone()[source]¶; Returns new, independent VariableValue object. compute()[source]¶; Computes value of coordinate from member data. everything()[source]¶. name()[source]¶; Gets the name of the variable. negated()[source]¶; Gets whether the coordinate value is actually the negative of the variable value. rset(val)[source]¶; Resets value of coordinate if not fixed. type()[source]¶; Gets specialization type of CoordValue. variable_to_string(precision)[source]¶; Takes a CoordValue object, and returns a string for printing. class ZMatrixEntry(entry_number, Z, charge, mass, symbol, label, rto=None, rval=0, ato=None, aval=0, dto=None, dval=0)[source]¶; Class to hold all information about an atom, including its; coordinate specification as any position of ZMatrix. clone()[source]¶; Returns new, independent ZMatrixEntry object. compute()[source]¶; Compute the Cartesian coordinates in Bohr of current atom’s entry. everything()[source]¶. invalidate()[source]¶; Flags the current coordinates as being outdated. print_in_input_format()[source]¶; Prints the updated geometry, in the format provided by the user. set_coordinates(x, y, z)[source]¶; Given the current set of coordinates, updates the values of this; atom’s coordinates, and any variables that may depend on it. type()[source]¶; The type of CoordEntry specialization. class LibmintsMolecule(psi4molstr=None)[source]¶; Class to store the elements, coordinates, fragmentation pattern,; charge, multiplicity of a molecule. Largely replicates psi4’s libmints; Molecule class, developed by Justin M. Turney with incremental; improvements by other psi4 developers. Major differences from t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_driver-1.html:38626,charge,charge,38626,psi4manual/4.0b3/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_driver-1.html,4,['charge'],['charge']
Energy Efficiency,"(-?\d+\.\d+|-?\d+\.|-?\.\d+|-?\d+|tda)\s*$', re.IGNORECASE); ghost = re.compile(r'@(.*)|Gh\((.*)\)', re.IGNORECASE). lines = re.split('\n', text); glines = []; ifrag = 0. for line in lines:. # handle comments; if comment.match(line) or blank.match(line):; pass. # handle units; elif ang.match(line):; self.set_units('Angstrom'); self.input_units_to_au = 1.0 / psi_bohr2angstroms; elif bohr.match(line):; self.set_units('Bohr'); self.input_units_to_au = 1.0. # handle no_reorient; elif orient.match(line):; self.fix_orientation(True). # handle no_com; elif com.match(line):; self.PYmove_to_com = False. # handle symmetry; elif symmetry.match(line):; self.PYsymmetry_from_input = symmetry.match(line).group(1).lower(). # handle variables; elif variable.match(line):; vname = variable.match(line).group(1).upper(); vval = float(variable.match(line).group(2)); tda = 360.0 * math.atan(math.sqrt(2)) / math.pi; self.geometry_variables['%s' % vname] = tda if vname == 'TDA' else vval. # handle charge and multiplicity; elif cgmp.match(line):; tempCharge = int(cgmp.match(line).group(1)); tempMultiplicity = int(cgmp.match(line).group(2)). if ifrag == 0:; self.PYcharge_specified = True; self.PYmultiplicity_specified = True; self.PYmolecular_charge = tempCharge; self.PYmultiplicity = tempMultiplicity; self.fragment_charges.append(tempCharge); self.fragment_multiplicities.append(tempMultiplicity). # handle fragment markers and default fragment cgmp; elif frag.match(line):; try:; self.fragment_charges[ifrag]; except:; self.fragment_charges.append(0); self.fragment_multiplicities.append(1); ifrag += 1; glines.append(line). elif atom.match(line.split()[0].strip()):; glines.append(line); else:; raise ValidationError('Molecule::create_molecule_from_string: Unidentifiable line in geometry specification: %s' % (line)). # catch last default fragment cgmp; try:; self.fragment_charges[ifrag]; except:; self.fragment_charges.append(0); self.fragment_multiplicities.append(1). # Now go through the rest of t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:16629,charge,charge,16629,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,1,['charge'],['charge']
Energy Efficiency,"(0) when the Brueckner orbitals have (have not) converged. CBS NUMBER¶. NBODY NUMBER¶. FINDIF NUMBER¶; Number of tasks [] the named procedure performs. These are immediate; tasks, so if procedures are nested, the total number of tasks is; the product. CBS TOTAL ENERGY¶. CBS CORRELATION ENERGY¶. CBS REFERENCE ENERGY¶; The total electronic energy [E_h] and its breakdown into reference total; energy [E_h] and correlation correction components [E_h] for the compound; method requested through cbs(). CCname ROOT n TOTAL ENERGY¶. TD-fctl ROOT n TOTAL ENERGY¶; The total electronic energy [E_h] for the requested theory and root n (n starts at 0).; DFT functional labeled if canonical. CCname ROOT n (IN h) TOTAL ENERGY¶. TD-fctl ROOT n (IN h) TOTAL ENERGY¶; The total electronic energy [E_h] for the requested theory and root n within irrep h (n starts at 0).; DFT functional labeled if canonical. CCname ROOT n (h) TOTAL ENERGY¶. TD-fctl ROOT n (h) TOTAL ENERGY¶; The total electronic energy [E_h] for the requested theory and root n, which is of irrep h (n starts at 0).; DFT functional labeled if canonical. CCname ROOT n TOTAL ENERGY - h TRANSITION¶. TD-fctl ROOT n TOTAL ENERGY - h TRANSITION¶; The total electronic energy [E_h] for the requested theory and root n, and the transition is of irrep h, (n starts at 0). CCname ROOT n CORRELATION ENERGY¶; The correlation energy [E_h] for the requested coupled cluster level of theory and root n (n starts at 0).; DFT functional labeled if canonical. CCname ROOT n (IN h) CORRELATION ENERGY¶; The correlation energy [E_h] for the requested coupled cluster level of theory and root n within irrep h (n starts at 0). CCname ROOT n (h) CORRELATION ENERGY¶; The correlation energy [E_h] for the requested coupled cluster level of theory and root n, which is of irrep h (n starts at 0). CCname ROOT n CORRELATION ENERGY - h TRANSITION¶; The correlation energy [E_h] for the requested coupled cluster level of theory and root n, and the transition is of ir",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html:8579,energy,energy,8579,psi4manual/1.7.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html,4,['energy'],['energy']
Energy Efficiency,"(0.0). sup.allocate(); return sup. [docs]def build_b3lyp5_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('B3LYP5'); # Tab in, trailing newlines; sup.set_description(' B3LYP5 Hybrid-GGA Exchange-Correlation Functional (VWN5)\n'); # Tab in, trailing newlines; sup.set_citation(' P.J. Stephens et. al., J. Phys. Chem., 98, 11623-11627, 1994\n'). # Add member functionals; b3 = build_functional('B3_X'); b3.set_alpha(1.0); sup.add_x_functional(b3); lyp = build_functional('LYP_C'); lyp.set_alpha(0.81); vwn = build_functional('VWN5_C'); vwn.set_alpha(0.19); sup.add_c_functional(lyp); sup.add_c_functional(vwn). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.2); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_b970_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('B97-0'); # Tab in, trailing newlines; sup.set_description(' B97-0 Hybrid-GGA Exchange-Correlation Functional\n'); # Tab in, trailing newlines; sup.set_citation(' A.D. Becke, J. Chem. Phys., 107(20), 8554-8560, 1997\n'). # Add member functionals; X = build_functional('B97_X'); X.set_name('B97-0_X'); X.set_alpha(1.0 / 0.8057). X.set_parameter('B97_gamma', 0.004); X.set_parameter('B97_a0', 0.8094); X.set_parameter('B97_a1', 0.5073); X.set_parameter('B97_a2', 0.7481). C = build_functional('B_C'); C.set_name('B97-0_C'). C.set_parameter('B97_os_gamma', 0.006); C.set_parameter('B97_os_a0', 0.9454); C.set_parameter('B97_os_a1', 0.7471); C.set_parameter('B97_os_a2', -4.5961). C.set_parameter('B97_ss_gamma', 0.2); C.set_p",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/functional.html:34733,allocate,allocate,34733,psi4manual/1.0.0/_modules/procedures/functional.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/functional.html,1,['allocate'],['allocate']
Energy Efficiency,"(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_blyp_superfunctional(name, npoints, deriv):. # Call this first; sup = PsiMod.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('BLYP'); # Tab in, trailing newlines; sup.set_description(' BLYP GGA Exchange-Correlation Functional\n'); # Tab in, trailing newlines; sup.set_citation(' P.J. Stephens et. al., J. Phys. Chem., 98, 11623-11627, 1994\n B. Miehlich et. al., Chem. Phys. Lett., 157(3), 200-206 1989\n'). # Add member functionals; sup.add_x_functional(build_functional('B88_X')); sup.add_c_functional(build_functional('LYP_C')). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_pw91_superfunctional(name, npoints, deriv):. # Call this first; sup = PsiMod.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('PW91'); # Tab in, trailing newlines; sup.set_description(' PW91 GGA Exchange-Correlation Functional\n'); # Tab in, trailing newlines; sup.set_citation(' J.P. Perdew et. al., Phys. Rev. B., 46(11), 6671-6687, 1992\n'). # Add member functionals; sup.add_x_functional(build_functional('PW91_X')); sup.add_c_functional(build_functional('PW91_C')). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_bp86_superfunctional(name, npoints, deriv):. # Call this first; sup = PsiMod.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv).",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/functional.html:21511,allocate,allocate,21511,psi4manual/4.0b2/_modules/functional.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/functional.html,3,['allocate'],['allocate']
Energy Efficiency,"(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_wpbe_superfunctional(name, npoints, deriv):. # Call this first; sup = PsiMod.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('wPBE'); # Tab in, trailing newlines; sup.set_description(' PBE SR-XC Functional (HJS Model)\n'); # Tab in, trailing newlines; sup.set_citation(' Henderson et. al., J. Chem. Phys., 128, 194105, 2008\n Weintraub, Henderson, and Scuseria, J. Chem. Theory. Comput., 5, 754 (2009)\n'). # Add member functionals; sup.add_x_functional(build_functional('wPBE_X')); sup.add_c_functional(build_functional('PBE_C')). # Set GKS up after adding functionals; sup.set_x_omega(0.4); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_wpbe0_superfunctional(name, npoints, deriv):. sup = build_wpbe_superfunctional(name, npoints, deriv); sup.set_name('wPBE0'); sup.set_description(' PBE0 SR-XC Functional (HJS Model)\n'); sup.set_x_omega(0.3); sup.set_x_alpha(0.25); return sup. [docs]def build_wpbesol_superfunctional(name, npoints, deriv):. # Call this first; sup = PsiMod.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('wPBEsol'); # Tab in, trailing newlines; sup.set_description(' PBEsol SR-XC Functional (HJS Model)\n'); # Tab in, trailing newlines; sup.set_citation(' Henderson et. al., J. Chem. Phys., 128, 194105, 2008\n Weintraub, Henderson, and Scuseria, J. Chem. Theory. Comput., 5, 754 (2009)\n'). # Add member functionals; sup.add_x_functional(build_functional('wPBEsol_X')); sup.add_c_functional(build_functional('PBE_C')). # Set GKS up after adding functionals; sup",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/functional.html:41738,allocate,allocate,41738,psi4manual/4.0b2/_modules/functional.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/functional.html,3,['allocate'],['allocate']
Energy Efficiency,"(10) * (4 * np.pi * e_0) * hbar * c. return (numerator / denominator) * au_to_Coulomb_centimeter**2. [docs]; def prefactor_ecd() -> float:; r""""""Prefactor for converting microscopic observable to decadic molar; extinction coefficient in electronic circular dichroism. Notes; -----; This function implements the calculation of the following prefactor:. .. math::. k = \frac{16\pi^{2}N_{\mathrm{A}}}{3\times 1000\times \ln(10) (4 \pi \epsilon_{0}) n \hbar c^{2}}. The prefactor is computed in SI units and then adjusted for the fact that; we use atomic units to express microscopic observables: excitation energies; and transition dipole moments.; The refractive index :math:`n` is, in general, frequency-dependent. We; assume it to be constant and equal to 1. """""". N_A = constants.get(""Avogadro constant""); c = constants.get(""speed of light in vacuum""); hbar = constants.get(""Planck constant over 2 pi""); e_0 = constants.get(""electric constant""). au_to_Coulomb_centimeter = constants.get(""elementary charge"") * constants.get(; ""Bohr radius"") * constants.conversion_factor(""m"", ""cm""); au_to_Joule_inverse_Tesla = 2.0 * constants.get(""Bohr magneton"") * constants.conversion_factor(""m"", ""cm""); conversion = au_to_Coulomb_centimeter * au_to_Joule_inverse_Tesla. numerator = 16.0 * np.pi**2 * N_A; denominator = 3 * 1000 * np.log(10) * (4 * np.pi * e_0) * hbar * c**2. return (numerator / denominator) * conversion. [docs]; def spectrum(*,; poles: Union[List[float], np.ndarray],; residues: Union[List[float], np.ndarray],; kind: str = ""opa"",; lineshape: str = ""gaussian"",; gamma: float = 0.2,; npoints: int = 5000,; out_units: str = ""nm"") -> Dict[str, np.ndarray]:; r""""""One-photon absorption (OPA) or electronic circular dichroism (ECD); spectra with phenomenological line broadening. This function gives arrays of values ready to be plotted as OPA spectrum:. .. math::. \varepsilon(\omega) =; \frac{4\pi^{2}N_{\mathrm{A}}\omega}{3\times 1000\times \ln(10) (4 \pi \epsilon_{0}) n \hbar c}; \sum_{i \rightarr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/spectrum.html:6102,charge,charge,6102,psi4manual/1.8.x/_modules/psi4/driver/p4util/spectrum.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/spectrum.html,3,['charge'],['charge']
Energy Efficiency,"(3) EXCH ENERGY¶. SAPT2+(3) IND ENERGY¶. SAPT2+3 DISP ENERGY¶. SAPT2+3 ELST ENERGY¶. SAPT2+3 EXCH ENERGY¶. SAPT2+3 IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [Eh] for the; given SAPT level of theory. The sum of these four components yields; the SAPT Level TOTAL ENERGY. SAPT0 TOTAL ENERGY¶. SSAPT0 TOTAL ENERGY¶. SAPT2 TOTAL ENERGY¶. SAPT2+ TOTAL ENERGY¶. SAPT2+(3) TOTAL ENERGY¶. SAPT2+3 TOTAL ENERGY¶; The total electronic interaction energy [Eh] for the labeled SAPT level; of theory. SAPT2+(CCD) DISP ENERGY¶. SAPT2+(CCD) ELST ENERGY¶. SAPT2+(CCD) EXCH ENERGY¶. SAPT2+(CCD) IND ENERGY¶. SAPT2+(3)(CCD) DISP ENERGY¶. SAPT2+(3)(CCD) ELST ENERGY¶. SAPT2+(3)(CCD) EXCH ENERGY¶. SAPT2+(3)(CCD) IND ENERGY¶. SAPT2+3(CCD) DISP ENERGY¶. SAPT2+3(CCD) ELST ENERGY¶. SAPT2+3(CCD) EXCH ENERGY¶. SAPT2+3(CCD) IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [Eh] for the; given SAPT level of theory that incorporates coupled-cluster dispersion.; The sum of these four components yields the SAPT Level TOTAL ENERGY. SAPT2+(CCD) TOTAL ENERGY¶. SAPT2+(3)(CCD) TOTAL ENERGY¶. SAPT2+3(CCD) TOTAL ENERGY¶; The total electronic interaction energy [Eh] for the labeled SAPT level; of theory that incorporates coupled-cluster dispersion. SAPT2+DMP2 DISP ENERGY¶. SAPT2+DMP2 ELST ENERGY¶. SAPT2+DMP2 EXCH ENERGY¶. SAPT2+DMP2 IND ENERGY¶. SAPT2+(3)DMP2 DISP ENERGY¶. SAPT2+(3)DMP2 ELST ENERGY¶. SAPT2+(3)DMP2 EXCH ENERGY¶. SAPT2+(3)DMP2 IND ENERGY¶. SAPT2+3DMP2 DISP ENERGY¶. SAPT2+3DMP2 ELST ENERGY¶. SAPT2+3DMP2 EXCH ENERGY¶. SAPT2+3DMP2 IND ENERGY¶. SAPT2+(CCD)DMP2 DISP ENERGY¶. SAPT2+(CCD)DMP2 ELST ENERGY¶. SAPT2+(CCD)DMP2 EXCH ENERGY¶. SAPT2+(CCD)DMP2 IND ENERGY¶. SAPT2+(3)(CCD)DMP2 DISP ENERGY¶. SAPT2+(3)(CCD)DMP2 ELST ENERGY¶. SAPT2+(3)(CCD)DMP2 EXCH ENERGY¶. SAPT2+(3)(CCD)DMP2 IND ENERGY¶. SAPT2+3(CCD)DMP2 DISP ENERGY¶. SA",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html:40513,energy,energy,40513,psi4manual/1.4.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html,5,['energy'],['energy']
Energy Efficiency,"(3, 3). AQCC TOTAL ENERGY¶. AQCC CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the averaged quadratic coupled-cluster level of theory. BRUECKNER CONVERGED¶; Value 1 (0) when the Brueckner orbitals have (have not) converged. CBS NUMBER¶. NBODY NUMBER¶. FINDIF NUMBER¶; Number of tasks [] the named procedure performs. These are immediate; tasks, so if procedures are nested, the total number of tasks is; the product. CBS TOTAL ENERGY¶. CBS CORRELATION ENERGY¶. CBS REFERENCE ENERGY¶; The total electronic energy [Eh] and its breakdown into reference total; energy [Eh] and correlation correction components [Eh] for the compound; method requested through cbs(). CCname ROOT n TOTAL ENERGY¶. TD-fctl ROOT n TOTAL ENERGY¶; The total electronic energy [Eh] for the requested theory and root n (n starts at 0).; DFT functional labeled if canonical. CCname ROOT n (IN h) TOTAL ENERGY¶. TD-fctl ROOT n (IN h) TOTAL ENERGY¶; The total electronic energy [Eh] for the requested theory and root n within irrep h (n starts at 0).; DFT functional labeled if canonical. CCname ROOT n (h) TOTAL ENERGY¶. TD-fctl ROOT n (h) TOTAL ENERGY¶; The total electronic energy [Eh] for the requested theory and root n, which is of irrep h (n starts at 0).; DFT functional labeled if canonical. CCname ROOT n TOTAL ENERGY - h TRANSITION¶. TD-fctl ROOT n TOTAL ENERGY - h TRANSITION¶; The total electronic energy [Eh] for the requested theory and root n, and the transition is of irrep h, (n starts at 0). CCname ROOT n CORRELATION ENERGY¶; The correlation energy [Eh] for the requested coupled cluster level of theory and root n (n starts at 0).; DFT functional labeled if canonical. CCname ROOT n (IN h) CORRELATION ENERGY¶; The correlation energy [Eh] for the requested coupled cluster level of theory and root n within irrep h (n starts at 0). CCname ROOT n (h) CORRELATION ENERGY¶; The correlation energy [Eh] for the requested coupled cluster level of theory and root n,",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/glossary_psivariables.html:8776,energy,energy,8776,psi4manual/1.6.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/glossary_psivariables.html,1,['energy'],['energy']
Energy Efficiency,"(4); [3.175492014248769, -0.7062681346308132, -1.4334725450878665]. """"""; temp = scale(self.atoms[atom].compute(), self.input_units_to_au); if posn >= 0:; return temp[posn]; else:; return temp. [docs] def mass(self, atom):; """"""Returns mass of atom (0-indexed). >>> print H2OH2O.mass(4); 1.00782503207. """"""; if self.atoms[atom].mass() != 0.0:; return self.atoms[atom].mass(). if math.fabs(self.atoms[atom].Z() - int(self.atoms[atom].Z())) > 0.0:; print ""WARNING: Obtaining masses from atom with fractional charge...may be incorrect!!!\n""; # TODO outfile; return an2masses[int(self.atoms[atom].Z())]. [docs] def symbol(self, atom):; """"""Returns the cleaned up label of the atom (C2 => C, H4 = H) (0-indexed). >>> print H2OH2O.symbol(4); H. """"""; return self.atoms[atom].symbol(). [docs] def label(self, atom):; """"""Returns the original label of the atom (0-indexed) as given in the input file (C2, H4). >>> print H2OH2O.label(4); H3. """"""; return self.atoms[atom].label(). [docs] def charge(self, atom):; """"""Returns charge of atom (0-indexed).; Related to SAD guess in libmints version. >>> print H2OH2O.charge(4); 1.0. """"""; return self.atoms[atom].charge(). [docs] def fZ(self, atom):; """"""Nuclear charge of atom (includes dummies). >>> print H2OH2O.fZ(4); 8. """"""; return self.full_atoms[atom].Z(). [docs] def fx(self, atom):; """"""x position of atom (0-indexed, includes dummies) in Bohr. >>> print H2OH2O.fx(4); 2.55231135823. """"""; return self.input_units_to_au * self.full_atoms[atom].compute()[0]. [docs] def fy(self, atom):; """"""y position of atom (0-indexed, includes dummies) in Bohr. >>> print H2OH2O.fy(4); 0.210645882307. """"""; return self.input_units_to_au * self.full_atoms[atom].compute()[1]. [docs] def fz(self, atom):; """"""z position of atom (0-indexed, includes dummies) in Bohr. >>> print H2OH2O.fz(4); 0.0. """"""; return self.input_units_to_au * self.full_atoms[atom].compute()[2]. [docs] def fxyz(self, atom):; """"""Returns a Vector3 with x, y, z position of atom; (0-indexed) in Bohr (includes dum",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html:7570,charge,charge,7570,psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html,6,['charge'],['charge']
Energy Efficiency,"(CCD) aug-cc-pVDZ computation of the water dimer interaction energy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. scf5; Test of all different algorithms and reference types for SCF, on singlet and triplet O2, using the cc-pVTZ basis set. pywrap-opt-sowreap; Finite difference optimization, run in sow/reap mode. cc8a; ROHF-CCSD(T) cc-pVDZ frozen-core energy for the state of the CN radical, with Cartesian input. opt1-fd; SCF STO-3G geometry optimzation, with Z-matrix input, by finite-differences. dft-dldf; Dispersionless density functional (dlDF+D) internal match to Psi4 Extensive testing has been done to match supplemental info of Szalewicz et. al., Phys. Rev. Lett., 103, 263201 (2009) and Szalewicz et. al., J. Phys. Chem. Lett., 1, 550-555 (2010). castup1; Test of SAD/Cast-up (mainly not dying due to file weirdness). omp3-5; SOS-OMP3 cc-pVDZ geometry optimization for the H2O molecule. adc1; ADC/6-31G** on H2O. cc9; UHF-CCSD(T) cc-pVDZ frozen-core energy for the state of the CN radical, with Z-matrix input. pubchem1; Benzene vertical singlet-triplet energy difference computation, using the PubChem database to obtain the initial geometry, at the UHF an ROHF levels of theory. cc44; Test case for some of the PSI4 out-of-core codes. The code is given only 2.0 MB of memory, which is insufficient to hold either the A1 or B2 blocks of an ovvv quantity in-core, but is sufficient to hold at least two copies of an oovv quantity in-core. cc35; CC3(ROHF)/cc-pVDZ H2O geom from Olsen et al., JCP 104, 8007 (1996). omp2-4; SCS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. mp2_5-grad2; MP2.5 cc-pVDZ gradient for the NO radical. cc9a; ROHF-CCSD(T) cc-pVDZ energy for the state of the CN radical, with Z-matrix input. dfmp2-2; Density fitted MP2 energy of H2, using density fitted reference and automatic looping over cc-pVDZ and cc-pVTZ basis sets. Results are tabulated using the built in table functions by using the default options and by specifiyin",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_testsuite-1.html:18624,energy,energy,18624,psi4manual/4.0b4/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_testsuite-1.html,4,['energy'],['energy']
Energy Efficiency,"(CCD) aug-cc-pVDZ computation of the water dimer interaction energy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. scf5; Test of all different algorithms and reference types for SCF, on singlet and triplet O2, using the cc-pVTZ basis set. pywrap-opt-sowreap; Finite difference optimization, run in sow/reap mode. cc8a; ROHF-CCSD(T) cc-pVDZ frozen-core energy for the state of the CN radical, with Cartesian input. opt1-fd; SCF STO-3G geometry optimzation, with Z-matrix input, by finite-differences. dft-dldf; Dispersionless density functional (dlDF+D) internal match to Psi4 Extensive testing has been done to match supplemental info of Szalewicz et. al., Phys. Rev. Lett., 103, 263201 (2009) and Szalewicz et. al., J. Phys. Chem. Lett., 1, 550-555 (2010). castup1; Test of SAD/Cast-up (mainly not dying due to file weirdness). omp3-5; SOS-OMP3 cc-pVDZ geometry optimization for the H2O molecule. adc1; ADC/6-31G** on H2O. cc9; UHF-CCSD(T) cc-pVDZ frozen-core energy for the state of the CN radical, with Z-matrix input. pubchem1; Benzene vertical singlet-triplet energy difference computation, using the PubChem database to obtain the initial geometry, at the UHF an ROHF levels of theory. cc44; Test case for some of the PSI4 out-of-core codes. The code is given only 2.0 MB of memory, which is insufficient to hold either the A1 or B2 blocks of an ovvv quantity in-core, but is sufficient to hold at least two copies of an oovv quantity in-core. cc35; CC3(ROHF)/cc-pVDZ H2O geom from Olsen et al., JCP 104, 8007 (1996). omp2-4; SCS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. mp2_5-grad2; MP2.5 cc-pVDZ gradient for the NO radical. mints8; Patch of a glycine with a methyl group, to make alanine, then DF-SCF energy calculation with the cc-pVDZ basis set. cc9a; ROHF-CCSD(T) cc-pVDZ energy for the state of the CN radical, with Z-matrix input. dfmp2-2; Density fitted MP2 energy of H2, using density fitted reference and automatic looping over cc-pVDZ and",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodoc_testsuite-1.html:19010,energy,energy,19010,psi4manual/4.0b5/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodoc_testsuite-1.html,4,['energy'],['energy']
Energy Efficiency,(CFOUR). CFOUR_SCALE_ON (CFOUR). CFOUR_SCF_CONV (CFOUR). CFOUR_SCF_DAMPING (CFOUR). CFOUR_SCF_EXPORDER (CFOUR). CFOUR_SCF_EXPSTART (CFOUR). CFOUR_SCF_EXTRAPOLATION (CFOUR). CFOUR_SCF_MAXCYC (CFOUR). CFOUR_SD_FIELD (CFOUR). CFOUR_SPHERICAL (CFOUR). CFOUR_SPIN_FLIP (CFOUR). CFOUR_SPIN_ORBIT (CFOUR). CFOUR_SPIN_SCAL (CFOUR). CFOUR_SPINROTATION (CFOUR). CFOUR_SUBGROUP (CFOUR). CFOUR_SYM_CHECK (CFOUR). CFOUR_SYMMETRY (CFOUR). CFOUR_T3_EXTRAPOL (CFOUR). CFOUR_TAMP_SUM (CFOUR). CFOUR_THERMOCHEMISTRY (CFOUR). CFOUR_TRANS_INV (CFOUR). CFOUR_TREAT_PERT (CFOUR). CFOUR_UIJ_THRESHOLD (CFOUR). CFOUR_UNITS (CFOUR). CFOUR_UPDATE_HESSIAN (CFOUR). CFOUR_VIBRATION (CFOUR). CFOUR_VTRAN (CFOUR). CFOUR_XFIELD (CFOUR). CFOUR_XFORM_TOL (CFOUR). CFOUR_YFIELD (CFOUR). CFOUR_ZFIELD (CFOUR). chain_dot() psi4.core.Matrix method. change_file_namespace() psi4.core.IO static method. char_table() psi4.core.PointGroup method. character() psi4.core.IrreducibleRepresentation method. CharacterTable class in psi4.core. charge. ; molecule. charge() psi4.core.Molecule method. check_iwl_file_from_scf_type() in module psi4.driver. check_phases() psi4.core.CUHF method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. CheMPS2. CHOLESKY (DFOCC). cholesky_factorize() psi4.core.Matrix method. CHOLESKY_TOLERANCE (DFOCC). (FNOCC). (SCF). CI. arbitrary-order coupled-cluster theory. arbitrary-order perturbation theory. basic-keywords. multi-configurational self-consistent-field. spin multiplicities of higher roots. theory. CI CORRELATION ENERGY. CI DIPOLE. CI DIPOLE X. CI DIPOLE Y. CI DIPOLE Z. CI QUADRUPOLE. CI QUADRUPOLE XX. CI QUADRUPOLE XY. CI QUADRUPOLE XZ. CI QUADRUPOLE YY. CI QUADRUPOLE YZ. CI QUADRUPOLE ZZ. CI ROOT n -> ROOT m DIPOLE. CI ROOT n -> ROOT m DIPOLE X. CI ROOT n -> ROOT m DIPOLE Y. CI ROOT n -> ROOT m DIPOLE Z. CI ROOT n -> ROOT m QUADRUPOLE. CI ROOT n -> ROOT m QUADRUPOLE XX. CI ROOT n -> ROOT m QUADRUPOLE XY. CI ROOT n -> ROOT m QUADRUPOLE XZ. CI ROOT n ->,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/genindex-1.html:26001,charge,charge,26001,psi4manual/1.4.0/genindex-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/genindex-1.html,4,['charge'],['charge']
Energy Efficiency,(CFOUR). CFOUR_SCALE_ON (CFOUR). CFOUR_SCF_CONV (CFOUR). CFOUR_SCF_DAMPING (CFOUR). CFOUR_SCF_EXPORDER (CFOUR). CFOUR_SCF_EXPSTART (CFOUR). CFOUR_SCF_EXTRAPOLATION (CFOUR). CFOUR_SCF_MAXCYC (CFOUR). CFOUR_SD_FIELD (CFOUR). CFOUR_SPHERICAL (CFOUR). CFOUR_SPIN_FLIP (CFOUR). CFOUR_SPIN_ORBIT (CFOUR). CFOUR_SPIN_SCAL (CFOUR). CFOUR_SPINROTATION (CFOUR). CFOUR_SUBGROUP (CFOUR). CFOUR_SYM_CHECK (CFOUR). CFOUR_SYMMETRY (CFOUR). CFOUR_T3_EXTRAPOL (CFOUR). CFOUR_TAMP_SUM (CFOUR). CFOUR_THERMOCHEMISTRY (CFOUR). CFOUR_TRANS_INV (CFOUR). CFOUR_TREAT_PERT (CFOUR). CFOUR_UIJ_THRESHOLD (CFOUR). CFOUR_UNITS (CFOUR). CFOUR_UPDATE_HESSIAN (CFOUR). CFOUR_VIBRATION (CFOUR). CFOUR_VTRAN (CFOUR). CFOUR_XFIELD (CFOUR). CFOUR_XFORM_TOL (CFOUR). CFOUR_YFIELD (CFOUR). CFOUR_ZFIELD (CFOUR). chain_dot() psi4.core.Matrix method. change_file_namespace() psi4.core.IO static method. char_table() psi4.core.PointGroup method. character() psi4.core.IrreducibleRepresentation method. CharacterTable class in psi4.core. charge. ; molecule. charge() psi4.core.Molecule method. check_iwl_file_from_scf_type() in module psi4.driver. check_phases() psi4.core.CUHF method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. CheMPS2. CHOLESKY (DFOCC). cholesky_factorize() psi4.core.Matrix method. CHOLESKY_TOLERANCE (DFOCC). (FNOCC). (SCF). CI. arbitrary-order coupled-cluster theory. arbitrary-order perturbation theory. basic-keywords. multi-configurational self-consistent-field. spin multiplicities of higher roots. theory. CI CORRELATION ENERGY. CI DIPOLE. CI QUADRUPOLE. CI ROOT n -> ROOT m DIPOLE. CI ROOT n -> ROOT m QUADRUPOLE. CI ROOT n CORRELATION ENERGY. CI ROOT n DIPOLE. CI ROOT n QUADRUPOLE. CI ROOT n TOTAL ENERGY. CI STATE-AVERAGED CORRELATION ENERGY. CI STATE-AVERAGED TOTAL ENERGY. CI TOTAL ENERGY. CI_DIIS (MCSCF). CI_FILE_START (DETCI). CI_MAXITER (DETCI). ci_nat_orbs() psi4.core.CIWavefunction method. CI_NUM_THREADS (DETCI). CI_TYPE (GLOBALS). CIBLKS_PRINT (DETCI). C,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/genindex.html:28121,charge,charge,28121,psi4manual/1.6.x/genindex.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/genindex.html,1,['charge'],['charge']
Energy Efficiency,"(DFT), compute the non-approximated second-order exchange-induction term. Type: boolean; Default: false. DO_LEVEL_SHIFT (DFOCC)¶DFOCC — Do apply level shifting?. Type: boolean; Default: true. DO_LEVEL_SHIFT (OCC)¶OCC — Removed in 1.4. Will raise an error in 1.5. Type: boolean; Default: true. DO_LINK (SCF)¶SCF — Perform the linear scaling exchange (LinK) algorithm, as described in [Ochsenfeld:1998:1663]. Only applies to Direct SCF. Type: boolean; Default: false. DO_MBPT_DISP (SAPT)¶SAPT (Expert) — Do MBPT dispersion correction in SAPT2+, SAPT2+(3) or SAPT2+3, if also doing CCD?. Type: boolean; Default: true. DO_SCS (DFOCC)¶DFOCC — Do perform spin-component-scaled OMP2 (SCS-OMP2)? In all computation, SCS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SCS-OMP2, one needs to set ‘DO_SCS’ to true. Type: boolean; Default: false. DO_SCS (OCC)¶OCC — Removed in 1.4. Will raise an error in 1.5. Pass the method name, like scs-mp2, to energy instead. Type: boolean; Default: false. DO_SOS (DFOCC)¶DFOCC — Do perform spin-opposite-scaled OMP2 (SOS-OMP2)? In all computation, SOS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SOS-OMP2, one needs to set ‘DO_SOS’ to true. Type: boolean; Default: false. DO_SOS (OCC)¶OCC — Removed in 1.4. Will raise an error in 1.5. Pass the method name, like scs-mp2, to energy instead. Type: boolean; Default: false. DO_THIRD_ORDER (SAPT)¶SAPT (Expert) — Do compute third-order corrections?. Type: boolean; Default: false. DOCC (GLOBALS)¶GLOBALS — An array containing the number of doubly-occupied orbitals per irrep (in Cotton order). Type: array; Default: No Default. DOCC (MCSCF)¶MCSCF — The number of doubly occupied orbitals, per irrep. Type: array; Default: No Default. DYNAMIC_LEVEL (OPTKING)¶OPTKING — Starting level for dynamic optimization (0=nondynamic, higher=>more conservative). Type: integer; Defaul",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodoc_glossary_options_c.html:117138,energy,energy,117138,psi4manual/1.6.x/autodoc_glossary_options_c.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodoc_glossary_options_c.html,1,['energy'],['energy']
Energy Efficiency,"(DFT)¶; In general, SAPT(DFT) should provide more accurate interaction energy; components, and overall interaction energies, than SAPT0. The drawback; is SAPT(DFT) method is more computationally demanding than SAPT0,; SAPT(DFT) can still be applied to medium-sized or large systems. The; SAPT(DFT) module was employed successfully in computations of systems; with up to 2000 basis functions, and the code should be scalable to; 3000 basis functions. Like higher-order SAPT, SAPT(DFT) requires; sufficient memory to hold \(2ovN_aux\) doubles.; SAPT(DFT) requires a few special treatments to obtain accurate; result. The DFT functionals used in SAPT(DFT) need to be asymptotically; corrected with Gradient Regulated Asymptotic Correction scheme (GRAC),; in order to recover the correct long-range asymptotic behavior; (approaching \(-1/r\) as \(r\) approaches infinity). The program; requires manual input of GRAC shift parameter for each monomer through; keywords SAPT_DFT_GRAC_SHIFT_A and SAPT_DFT_GRAC_SHIFT_B,; which should be equal to the difference of the actual ionization; potential and the corresponding Kohn-Sham HOMO energy. The dispersion; term needs to be computed with orbital response for good accuracy,; and it is recommended to enable SAPT_DFT_DO_HYBRID (set to; True by default). The coupled exchange-dispersion energy is usually; estimated by scaling from the uncoupled value either by a fitted fixed; value (suggested initially by [Hesselmann:2014:094107] for a local Hartree–Fock (LHF) formulation and then revised; by [Xie:2022:024801] for non-LHF) or; by the ratio of; coupled and uncoupled dispersion energy (suggested by [Podeszwa:2006:400] ).; This can be controlled by keyword SAPT_DFT_EXCH_DISP_SCALE_SCHEME,; with FIXED using the Hesselmann/Xie approach (PSI4‘s default prior; to Nov 2022), DISP using the Podeszwa approach (PSI4‘s default after Nov 2022),; or NONE for not scaling and using the uncoupled exchange-dispersion; energy directly. Warning; Since Nov 2022, the d",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/sapt.html:23745,energy,energy,23745,psi4manual/1.7.x/sapt.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/sapt.html,4,['energy'],['energy']
Energy Efficiency,"(DFT)¶; In general, SAPT(DFT) should provide more accurate interaction energy; components, and overall interaction energies, than SAPT0. The drawback; is SAPT(DFT) method is more computationally demanding than SAPT0,; SAPT(DFT) can still be applied to medium-sized or large systems. The; SAPT(DFT) module was employed successfully in computations of systems; with up to 2000 basis functions, and the code should be scalable to; 3000 basis functions. Like higher-order SAPT, SAPT(DFT) requires; sufficient memory to hold \(2ovN_aux\) doubles.; SAPT(DFT) requires a few special treatments to obtain accurate; result. The DFT functionals used in SAPT(DFT) need to be asymptotically; corrected with Gradient Regulated Asymptotic Correction scheme (GRAC),; in order to recover the correct long-range asymptotic behavior; (approaching \(-1/r\) as \(r\) approaches infinity). The program; requires manual input of GRAC shift parameter for each monomer through; keywords SAPT_DFT_GRAC_SHIFT_A and SAPT_DFT_GRAC_SHIFT_B,; which should be equal to the difference of the actual ionization; potential and the corresponding Kohn-Sham HOMO energy. The dispersion; term needs to be computed with orbital response for good accuracy,; and it is recommended to enable SAPT_DFT_DO_HYBRID (set to; True by default). The coupled exchange-dispersion energy is usually; estimated by scaling from the uncoupled value either by a fitted fixed; value as suggested by [Hesselmann:2014:094107], or by the ratio of; coupled and uncoupled dispersion energy. This can be controlled by; keyword SAPT_DFT_EXCH_DISP_SCALE_SCHEME, with FIXED being; the former approach, DISP being the latter and NONE for not; scaling and use the uncoupled exchange-dispersion energy directly. Basic Keywords for SAPT(DFT)¶. SAPT_DFT_GRAC_SHIFT_A¶. Monomer A GRAC shift in Hartree. Type: double; Default: 0.0. SAPT_DFT_GRAC_SHIFT_B¶. Monomer B GRAC shift in Hartree. Type: double; Default: 0.0. SAPT_DFT_DO_DHF¶. Compute the Delta-HF correction?. Type: ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/sapt-1.html:22189,energy,energy,22189,psi4manual/1.4.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/sapt-1.html,5,['energy'],['energy']
Energy Efficiency,"(MOM) Test. MOM is designed to stabilize SCF convergence and to target excited Slater determinants directly. psithon1; Spectroscopic constants of H2, and the full ci cc-pVTZ level of theory. cisd-h2o+-2; 6-31G** H2O+ Test CISD Energy Point. cc10; ROHF-CCSD cc-pVDZ energy for the \(^2\Sigma^+\) state of the CN radical. tdscf-2; td-uhf test on triplet states of methylene (tda), wfn passing. dft-pruning; Tests all grid pruning options available and screening of small weights. Check against grid size. dfccd1; DF-CCD cc-pVDZ energy for the H2O molecule. cc15; RHF-B-CCD(T)/6-31G** H2O single-point energy (fzc, MO-basis \(\langle ab|cd \rangle\)). omp2p5-grad2; OMP2.5 cc-pVDZ gradient for the NO radical. sapt5; SAPT0 aug-cc-pVTZ computation of the charge transfer energy of the water dimer. dfccsdt1; DF-CCSD(T) cc-pVDZ energy for the H2O molecule. pywrap-checkrun-uhf; This checks that all energy methods can run with a minimal input and set symmetry. scf2; RI-SCF cc-pVTZ energy of water, with Z-matrix input and cc-pVTZ-RI auxilliary basis. mcscf3; RHF 6-31G** energy of water, using the MCSCF module and Z-matrix input. pywrap-checkrun-rohf; This checks that all energy methods can run with a minimal input and set symmetry. cc41; RHF-CC2-LR/cc-pVDZ optical rotation of H2O2. gauge = both, omega = (589 355 nm). pywrap-db1; Database calculation, so no molecule section in input file. Portions of the full databases, restricted by subset keyword, are computed by sapt0 and dfmp2 methods. cisd-sp-2; 6-31G** H2O Test CISD Energy Point. olccd3; OLCCD cc-pVDZ energy with ROHF initial guess for the NO radical. cc19; CCSD/cc-pVDZ dipole polarizability at two frequencies. cc4; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. After the computation, the checkpoint file is renamed, using the PSIO handler. casscf-sp; CASSCF/6-31G** energy point. dfccsd-grad2; DF-CCSD cc-pVDZ gradient for the NH molecule. opt15; 6-31G(d) optimization of SF4 starting from linear bond",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html:5333,energy,energy,5333,psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"(N - Nb). charge = charge0; mult = mult0; ; # By default, nuke all the electrons; Nmin = 0;; if (kwargs.has_key('nmax')):; Nmin = N - int(kwargs['nmax']). # By default, DIIS in FRAC (1.0 occupation is always DIIS'd); frac_diis = True; if kwargs.has_key('frac_diis'):; frac_diis = kwargs['frac_diis']. # By default, drop the files to the molecule's name; root = mol.name(); if kwargs.has_key('filename'):; root = kwargs['filename']; traverse_filename = root + '.traverse.dat'; stats_filename = root + '.stats.dat' . # => Traverse <= #; PsiMod.set_global_option(""DF_INTS_IO"", ""SAVE""). Ns = []; energies = []; potentials = []; convs = []; stats = []. # Run one SCF to burn things in; energy('scf'). # Determine HOMO; ref = PsiMod.wavefunction(); eps_a = ref.epsilon_a(); eps_b = ref.epsilon_b(); if (Na == Nb):; HOMO = -Nb; elif (Nb == 0):; HOMO = Na; else:; E_a = eps_a[int(Na - 1)] ; E_b = eps_b[int(Nb - 1)] ; if (E_a >= E_b):; HOMO = Na; else: ; HOMO = -Nb. stats.append('\t%6d %6d %6d %6d %6d %6d\n' %(N, Na, Nb, charge, mult, HOMO)). if (HOMO > 0):; Na = Na - 1; else:; Nb = Nb - 1; charge = charge + 1; mult = Na - Nb + 1. PsiMod.set_global_option(""DF_INTS_IO"", ""LOAD""); PsiMod.set_global_option(""FRAC_START"", frac_start); PsiMod.set_global_option(""FRAC_RENORMALIZE"", True). # Nuke 'em Rico! ; for Nintegral in range(N,Nmin,-1):. # Nuke the current HOMO; for occ in foccs:. PsiMod.set_global_option(""FRAC_OCC"", [HOMO]); PsiMod.set_global_option(""FRAC_VAL"", [occ]) . E = energy('scf'); C = 1; if (E == 0.0):; E = PsiMod.get_variable('SCF ITERATION ENERGY'); C = 0. if (HOMO > 0):; ref = PsiMod.wavefunction(); eps = ref.epsilon_a(); potentials.append(eps[HOMO-1]); else:; ref = PsiMod.wavefunction(); eps = ref.epsilon_b(); potentials.append(eps[-HOMO-1]). Ns.append(Nintegral + occ - 1.0); energies.append(E); convs.append(C). PsiMod.set_global_option(""FRAC_START"", 2); PsiMod.set_global_option(""FRAC_LOAD"", True); PsiMod.set_global_option(""FRAC_DIIS"", frac_diis); PsiMod.set_global_option(""GUESS""",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/frac.html:8169,charge,charge,8169,psi4manual/4.0b4/_modules/frac.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/frac.html,1,['charge'],['charge']
Energy Efficiency,"(N3psi8MoleculeE {lvalue},b); | ; | reset_point_group(...); | reset_point_group( (Molecule)arg1, (str)arg2) -> None :; | Overrides symmetry from outside the molecule string; | ; | C++ signature :; | void reset_point_group(N3psi8MoleculeE {lvalue},Ss); | ; | rotational_constants(...); | rotational_constants( (Molecule)arg1, (float)arg2) -> Vector :; | Prints the rotational constants of the molecule; | ; | C++ signature :; | N3psi6VectorE rotational_constants(N3psi8MoleculeE {lvalue},d); | ; | run_dftd3(self, func=None, dashlvl=None, dashparam=None, dertype=None, verbose=False); | Function to call Grimme's dftd3 program (http://toc.uni-muenster.de/DFTD3/); | to compute the -D correction of level *dashlvl* using parameters for; | the functional *func*. The dictionary *dashparam* can be used to supply; | a full set of dispersion parameters in the absense of *func* or to supply; | individual overrides in the presence of *func*. Returns energy if *dertype* is 0,; | gradient if *dertype* is 1, else tuple of energy and gradient if *dertype*; | unspecified. The dftd3 executable must be independently compiled and found in; | :envvar:`PATH` or :envvar:`PSIPATH`.; | *self* may be either a qcdb.Molecule (sensibly) or a psi4.Molecule; | (works b/c psi4.Molecule has been extended by this method py-side and; | only public interface fns used) or a string that can be instantiated; | into a qcdb.Molecule.; | ; | save_string_xyz(...); | save_string_xyz( (Molecule)arg1) -> str :; | Saves the string of an XYZ file to arg2; | ; | C++ signature :; | Ss save_string_xyz(N3psi8MoleculeE {lvalue}); | ; | save_string_xyz_file(...); | save_string_xyz_file( (Molecule)arg1) -> str :; | Saves an XYZ file to arg2; | ; | C++ signature :; | Ss save_string_xyz_file(N3psi8MoleculeE {lvalue}); | ; | save_xyz_file(...); | save_xyz_file( (Molecule)arg1, (str)arg2, (bool)arg3) -> None :; | Saves an XYZ file to arg2; | ; | C++ signature :; | void save_xyz_file(N3psi8MoleculeE {lvalue},Ss,b); | ; | schoenflie",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:552992,energy,energy,552992,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,4,['energy'],['energy']
Energy Efficiency,"(OptionState('DF_BASIS_MP2')). restore()[source]¶. class OptionsState(*largs)[source]¶; Class to contain multiple OptionsState() objects.; Used in python driver functions to collect several options before altering; them, then restoring before function return.; >>> optstash = OptionsState(; ['SCF', 'DFT_FUNCTIONAL'],; ['DF_BASIS_SCF'],; ['SCF', 'SCF_TYPE'],; ['SCF', 'REFERENCE']). >>> print(optstash). >>> optstash.restore(). restore()[source]¶. gaussian_n¶. run_gaussian_2(name, **kwargs)[source]¶. physconst¶; # Do not modify this file! It is auto-generated by the document_options_and_tests; # script, from psi4topdir/include/physconst.h; psi_h = 6.62606896E-34 # The Planck constant (Js) ; psi_c = 2.99792458E8 # Speed of light (ms$^{-1}$) ; psi_kb = 1.3806504E-23 # The Boltzmann constant (JK$^{-1}$) ; psi_R = 8.314472 # Universal gas constant (JK$^{-1}$mol$^{-1}$) ; psi_bohr2angstroms = 0.52917720859 # Bohr to Angstroms conversion factor ; psi_bohr2m = 0.52917720859E-10 # Bohr to meters conversion factor ; psi_bohr2cm = 0.52917720859E-8 # Bohr to centimeters conversion factor ; psi_amu2g = 1.660538782E-24 # Atomic mass units to grams conversion factor ; psi_amu2kg = 1.660538782E-27 # Atomic mass units to kg conversion factor ; psi_au2amu = 5.485799097E-4 # Atomic units (m$@@e$) to atomic mass units conversion factor ; psi_hartree2J = 4.359744E-18 # Hartree to joule conversion factor ; psi_hartree2aJ = 4.359744 # Hartree to attojoule (10$^{-18}$J) conversion factor ; psi_cal2J = 4.184 # Calorie to joule conversion factor ; psi_dipmom_au2si = 8.47835281E-30 # Atomic units to SI units (Cm) conversion factor for dipoles ; psi_dipmom_au2debye = 2.54174623 # Atomic units to Debye conversion factor for dipoles ; psi_dipmom_debye2si = 3.335640952E-30 # Debye to SI units (Cm) conversion factor for dipoles ; psi_c_au = 137.035999679 # Speed of light in atomic units ; psi_hartree2ev = 27.21138 # Hartree to eV conversion factor ; psi_hartree2wavenumbers = 219474.6 # Hartree to cm$^",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_driver-1.html:20155,meter,meters,20155,psi4manual/4.0b4/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_driver-1.html,2,['meter'],['meters']
Energy Efficiency,"(S^2) ENERGY¶; An exchange-classified SAPT term energy [E_h] implemented for SAPT0. SAPT IND20,R ENERGY¶. SAPT EXCH-IND20,R ENERGY¶. SAPT IND20,U ENERGY¶. SAPT EXCH-IND20,U ENERGY¶; An induction-classified SAPT term energy [E_h] implemented for SAPT0. SAPT DISP20 ENERGY¶. SAPT EXCH-DISP20 ENERGY¶; A dispersion-classified SAPT term energy [E_h] implemented for SAPT0. SAPT EXCH-DISP20(S^INF) ENERGY¶; A dispersion-classified SAPT term energy [E_h] implemented for SAPT0. See Higher-Order Exchange Terms without Single-Exchange Approximation. SAPT SAME-SPIN DISP20 ENERGY¶. SAPT SAME-SPIN EXCH-DISP20 ENERGY¶; The portion of SAPT DISP20 ENERGY or; SAPT EXCH-DISP20 ENERGY resulting from; from same-spin or triplet doubles correlations. SAPT HF(2) ENERGY ABC(HF)¶; The total Hartree–Fock energy [E_h] of the supersystem implemented for F/I-SAPT. SAPT HF(2) ENERGY AC(0)¶; The Hartree–Fock energy [E_h] of subsystems A and C implemented for F/I-SAPT. SAPT HF(2) ENERGY BC(0)¶; The Hartree–Fock energy [E_h] of subsystems B and C implemented for F/I-SAPT. SAPT HF(2) ENERGY A(0)¶; The Hartree–Fock energy [E_h] of subsystem A implemented for F/I-SAPT. SAPT HF(2) ENERGY B(0)¶; The Hartree–Fock energy [E_h] of subsystem B implemented for F/I-SAPT. SAPT HF(2) ENERGY AC(HF)¶; The Hartree–Fock localized energy [E_h] of subsystems A and C implemented for F/I-SAPT. SAPT HF(2) ENERGY BC(HF)¶; The Hartree–Fock localized energy [E_h] of subsystems B and C implemented for F/I-SAPT. SAPT HF(2) ENERGY AB(HF)¶; The Hartree–Fock localized energy [E_h] of subsystems A and B implemented for F/I-SAPT. SAPT HF(2) ENERGY A(HF)¶; The Hartree–Fock localized energy [E_h] of subsystem A implemented for F/I-SAPT. SAPT HF(2) ENERGY B(HF)¶; The Hartree–Fock localized energy [E_h] of subsystem B implemented for F/I-SAPT. SAPT HF(2) ENERGY C¶; The Hartree–Fock energy [E_h] of subsystem C implemented for F/I-SAPT. SAPT HF(2) ENERGY HF¶; The FI-SAPT Hartree–Fock interaction energy [E_h] implemented for F/I-SAPT. SAPT",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html:46960,energy,energy,46960,psi4manual/1.7.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html,4,['energy'],['energy']
Energy Efficiency,"(T) procedure. The second; auxiliary set is used to approximate all other ERI’s in the DF-CCSD(T); procedure. The choice of auxiliary basis is controlled by the keyword; DF_BASIS_CC. By default, DF_BASIS_CC is the RI set; (optimized for DFMP2) most appropriate for use with the primary basis.; For example, if the primary basis is aug-cc-pVDZ, the default; DF_BASIS_CC will be aug-cc-pVDZ-RI.; Alternatively, the user can request that the DF-CCSD(T) procedure use a; set of vectors defined by the Cholesky decomposition of the ERI tensor as; the auxiliary basis. This feature is enabled by specifying; DF_BASIS_CC as “CHOLESKY”. CD methods can be enabled in the SCF; procedure as well, by specifying the SCF_TYPE as “CD”. The; accuracy of the decomposition can be controlled through the keyword; CHOLESKY_TOLERANCE.; The following input file sets up a DF-CCSD(T); computation using CD integrals; molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; scf_type cd; df_basis_cc cholesky; basis aug-cc-pvdz; freeze_core true; }; energy('df-ccsd(t)'). The resulting CCSD(T) correlation energy will be equivalent to that; obtained from a conventional computation if CHOLESKY_TOLERANCE is; sufficiently small (e.g. ). Gn theory¶; The FNOCC module contains all the components that comprise the Gn family; of composite methods. Currently, only the G2 method is supported; [Curtiss:1991:7221]. The G2 procedure may be called through the; energy() wrapper:; energy('gaussian-2'). Supported methods¶; The various methods supported by the FNOCC module in PSI4 are detailed; in Table FNOCC Methods. Note that these methods; are implemented for closed-shell references only. For open-shell references,; the calls energy('mp2.5'), energy('mp3'), and energy('mp4') will; default to the DETCI implementations of these methods. name; calls method. qcisd; quadratic configuration interaction singles doubles. qcisd(t); qcisd with perturbative triples. mp2.5; average of second- and third-order perturbation theorie",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/fnocc-1.html:9559,energy,energy,9559,psi4manual/4.0b5/fnocc-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/fnocc-1.html,2,['energy'],['energy']
Energy Efficiency,"(T)/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. sapt-exch-disp-inf; SAPT0 with S^inf exch-disp20. props1; RHF STO-3G dipole moment computation, performed by applying a finite electric field and numerical differentiation. cbs-parser; mtd/basis syntax examples. pubchem1; Benzene vertical singlet-triplet energy difference computation, using the PubChem database to obtain the initial geometry, which is optimized at the HF/STO-3G level, before computing single point energies at the RHF, UHF and ROHF levels of theory. basis-ecp; check mixing ECP and non-ECP orbital/fitting basis sets in a session. dfremp-1; density fitted REMP/cc-pVDZ energies for the CO2 molecule. psithon1; Spectroscopic constants of H2, and the full ci cc-pVTZ level of theory. pywrap-alias; Test parsed and exotic calls to energy() like zapt4, mp2.5, and cisd are working. omp2-1; OMP2 cc-pVDZ energy for the H2O molecule. sapt4; SAPT2+(3) aug-cc-pVDZ computation of the formamide dimer interaction energy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. This example uses frozen core as well as MP2 natural orbital approximations. dct5; DC-06 calculation for the O2 molecule (triplet ground state). This performs geometry optimization using two-step and simultaneous solution of the response equations for the analytic gradient. cc15; RHF-B-CCD(T)/6-31G** H2O single-point energy (fzc, MO-basis \(\langle ab|cd \rangle\)). psimrcc-sp1; Mk-MRCCSD single point. \(^3 \Sigma ^-\) O2 state described using the Ms = 0 component of the triplet. Uses ROHF triplet orbitals. tu3-h2o-opt; Optimize H2O HF/cc-pVDZ. dft-custom-dhdf; DSD-PBEP86 S22 Ammonia test. cc30; CCSD/sto-3g optical rotation calculation (length gauge only) at two frequencies on methyloxirane. tu2-ch2-energy; Sample UHF/6-31G** CH2 computation. mp2-property; MP2 cc-pvDZ properties for Nitrogen oxide. cdremp-2; Cholesky decomposed REMP/cc-pVDZ energies for the CH3 radical. frac-traverse; Scan fractional occupa",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html:9509,energy,energy,9509,psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"(T)/qz2p on NH2. cfour/kw-7; Translating psi4 options to cfour, part i. cfour/sp-rohf-scf; single-point HF/qz2p on NH2. cfour/opt-rhf-ccsd_t_; optimization CCSD(T)/dzp on water. cfour/sp-rohf-mp4-sc; single-point MP4/qz2p on NH2. cfour/sp-rohf-ccsd_t_-fc; single-point CCSD(T)/qz2p on NH2 with ecc, aobasis, frozen-core. cfour/dfmp2-1; MP2/cc-PVDZ computation of formic acid dimer binding energy using automatic counterpoise correction. Monomers are specified using Cartesian coordinates. cfour/mints5; geometries from a variety of input formats. references from psi4, testing whether geometry strings read identically for psi4/cfour. cfour/sp-uhf-scf; single-point HF/qz2p on NH2. cfour/sp-rhf-ccsd_t_; single-point CCSD(T)/qz2p on water. cfour/scf4; RHF cc-pVDZ energy for water, automatically scanning the symmetric stretch and bending coordinates using Python’s built-in loop mechanisms. The geometry is apecified using a Z-matrix with variables that are updated during the potential energy surface scan, and then the same procedure is performed using polar coordinates, converted to Cartesian coordinates. cfour/sp-rohf-mp2-sc; single-point MP2/qz2p on NH2. cfour/sp-rhf-ccsd; single point CCSD/qz2p on water. cfour/psi-ghost-grad; MP2 optimization of dimers with one momomer ghosted. Gradients after three opt cycles are compared with those from psi4. cfour/sp-rhf-ccsdt; single-point CCSDT/qz2p on water. cfour/opt-rhf-scf; optimization HF/svp on water. cfour/sp-rhf-mp2; single-point MP2/qz2p on water. cfour/psi-rohf-scsmp2; ROHF MP2 energy components. Checks that computed identically between cfour and psi4. cfour/pywrap-cbs1; Various basis set extrapolation tests only in Cfour instead of Psi4. cfour/kw-2; testing best practices options, part ii. cfour/sp-rohf-ccsdt; single-point CCSDT/qz2p on NH2. cfour/sp-rhf-ccsd-ao; single-point CCSD/qz2p on water with aobasis. cfour/kw-3; Basis set spherical/Cartesian with cfour_basis and cfour_spherical. cfour/sp-rohf-ccsd_t_-ao; single-point C",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_cfour.html:2987,energy,energy,2987,psi4manual/1.7.x/autodoc_testsuite_cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_cfour.html,1,['energy'],['energy']
Energy Efficiency,"(THERMO); THERMO — Rotational symmetry number for thermodynamic analysis. Default is set from the full point group (e.g., Td for methane) as opposed to the computational point group (e.g., C2v for methane). Default takes into account symmetry reduction through asymmetric isotopic substitution and is unaffected by user-set symmetry on molecule, so this option is the sole way to influence the symmetry-dependent aspects of the thermodynamic analysis. Type: integer; Default: 1. RSRFO_ALPHA_MAX (OPTKING); OPTKING — Absolute maximum value of RS-RFO. Type: double; Default: 1e8. RUN_CCSD (FNOCC); FNOCC (Expert) — do ccsd rather than qcisd?. Type: boolean; Default: false. RUN_CEPA (FNOCC); FNOCC (Expert) — Is this a CEPA job? This parameter is used internally by the pythond driver. Changing its value won’t have any effect on the procedure. Type: boolean; Default: false. RUN_MP2 (FNOCC); FNOCC (Expert) — do only evaluate mp2 energy?. Type: boolean; Default: false. RUN_MP3 (FNOCC); FNOCC (Expert) — do only evaluate mp3 energy?. Type: boolean; Default: false. RUN_MP4 (FNOCC); FNOCC (Expert) — do only evaluate mp4 energy?. Type: boolean; Default: false. S (DETCI); DETCI — The value of the spin quantum number is given by this option. The default is determined by the value of the multiplicity. This is used for two things: (1) determining the phase of the redundant half of the CI vector when the component is used (i.e., MS0 = TRUE), and (2) making sure the guess vector has the desired value of (if CALC_S_SQUARED is TRUE and ICORE = 1). Type: double; Default: 0.0. S_ORTHOGONALIZATION (SCF); SCF — SO orthogonalization: symmetric or canonical?. Type: string; Possible Values: SYMMETRIC, CANONICAL; Default: SYMMETRIC. S_TOLERANCE (SCF); SCF — Minimum S matrix eigenvalue to be used before compensating for linear dependencies. Type: conv double; Default: 1e-7. SAD_CHOL_TOLERANCE (SCF); SCF (Expert) — Auxiliary basis for the SAD guess. Type: conv double; Default: 1e-7. SAD_D_CONVERGENCE (S",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:199861,energy,energy,199861,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,2,['energy'],['energy']
Energy Efficiency,"([ 0. , 0. , -0.83217802]); >>> wfn.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> wfn.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). """"""; key = _qcvar_warnings(key). if self.has_scalar_variable(key):; return self.scalar_variable(key); elif self.has_array_variable(key):; return _qcvar_reshape_get(key, self.array_variable(key)); else:; raise KeyError(f""psi4.core.Wavefunction.variable: Requested variable '{key}' was not set!\n""). def _core_set_variable(key: str, val: Union[core.Matrix, np.ndarray, float]) -> None:; """"""Sets scalar or array :ref:`QCVariable <sec:appendices:qcvars>` *key* to; *val* in global memory. Parameters; ----------; key; Case-insensitive key to global double or :py:class:`~psi4.core.Matrix`; storage maps.; val; Scalar or array to be stored in `key`. If :class:`~numpy.ndarray` and; data `key` does not naturally fit in 2D Matrix (often charge and; multipole QCVariables), it will be reshaped, as all; :class:`~numpy.ndarray` are stored as :class:`~psi4.core.Matrix`. Raises; ------; ValidationError; If `val` is a scalar but `key` already exists as an array variable. Or; if `val` is an array but `key` already exists as a scalar variable. """"""; if isinstance(val, core.Matrix):; if core.has_scalar_variable(key):; raise ValidationError(f""psi4.core.set_variable: Target variable '{key}' already a scalar variable!""); else:; core.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if core.has_scalar_variable(key):; raise ValidationError(f""psi4.core.set_variable: Target variable '{key}' already a scalar variable!""); else:; core.set_array_variable(key, core.Matrix.from_array(_qcvar_reshape_set(key, val))); else:; if core.has_array_variable(key):; raise ValidationError(f""psi4.core.set_variable: Target variable '{key}' already an array variable!""); else:; core.set_scalar_variable(key, val). # TODO _qcvar_warnings(key). def _c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html:36571,charge,charge,36571,psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html,2,['charge'],['charge']
Energy Efficiency,"(^{3}B_1\) state of CH2, with Z-matrix input. The occupations are specified explicitly. cbs-xtpl-opt; Various extrapolated optimization methods for the H2 molecule. dft-jk; DFT JK on-disk test. sapt-dft-lrc; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. cbs-xtpl-alpha; Extrapolated water energies. dft-dldf; Dispersionless density functional (dlDF+D) internal match to Psi4 Extensive testing has been done to match supplemental info of Szalewicz et. al., Phys. Rev. Lett., 103, 263201 (2009) and Szalewicz et. al., J. Phys. Chem. Lett., 1, 550-555 (2010). opt3; SCF cc-pVDZ geometry optimzation, with Z-matrix input. mcscf3; RHF 6-31G** energy of water, using the MCSCF module and Z-matrix input. scf-dipder; Test SCF dipole derivatives against old Psi3 reference values. dfccsdat1; DF-CCSD(AT) cc-pVDZ energy for the H2O molecule. pywrap-checkrun-rohf; This checks that all energy methods can run with a minimal input and set symmetry. cc4a; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. This version tests the FROZEN_DOCC option explicitly. dft-psivar; HF and DFT variants single-points on zmat methane, mostly to test that PSI variables are set and computed correctly. Now also testing that CSX harvesting PSI variables correctly update ref_dft_2e/xc due to new BraggSlater radii. fci-tdm-2; BH-H2+ FCI/cc-pVDZ Transition Dipole Moment. mints-benchmark; run some BLAS benchmarks. mp2-grad1; MP2 cc-pVDZ gradient for the H2O molecule. mints12; test roundtrip-ness of dict repr for psi4.core.Molecule and qcdb.Molecule. cc13c; Tests RHF CCSD(T)gradients. ao-casscf-sp; CASSCF/6-31G** energy point. x2c2; Test of SFX2C-1e on Water cc-pVDZ-DK. In this test the Dirac equation is solved in the uncontracted cc-pVDZ-DK basis. The reference numbers are from Lan Cheng’s implementation in Cfour. dft-freq-analytic; Analytic SVWN frequencies, compared to finite difference values. cc55; EOM-CCSD/6-31g excited state transition data for water with two ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html:15139,energy,energy,15139,psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"(alpha, beta, total, spin) and four orbitals; >>> # (two alpha, two beta); >>> set cubeprop_tasks ['orbitals', 'density']; >>> set cubeprop_orbitals [5, 6, -5, -6]; >>> E, wfn = energy('scf', return_wfn=True); >>> cubeprop(wfn). Introduction¶; PSI4 has the ability to export cube files that store information about; basis functions, molecular orbitals, the electron density, and; the electrostatic potential (ESP). Cube files store the value of a scalar; quantity on a regular Cartesian grid, and can be visualized with several; visualization programs, some of which are free, like VMD; (http://www.ks.uiuc.edu/Research/vmd/).; An example utilization of the code is:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set basis cc-pvdz; set scf_type df; set freeze_core True; set cubeprop_tasks ['orbitals']; set cubeprop_orbitals [5,6,-5,-6]. E, wfn = energy('scf', return_wfn=True); cubeprop(wfn). In this example, the cubeprop(); call after the energy('scf') command; executes the cubeprop code. The array CUBEPROP_TASKS specifies which; tasks should be executed. In this case the task 'orbitals' generates cube; files for orbitals. The CUBEPROP_ORBITALS option specifies that cube files; should be generated only for alpha orbitals 5 (HOMO) and 6 (LUMO) and; beta orbitals 5 (indicated as -5) and 6.; If the option CUBEPROP_ORBITALS is not provided, then cube files are; generated for all orbitals.; After running, the above input will generate four files: Psi_a_5.cube,; Psi_a_6.cube, Psi_b_5.cube, and Psi_b_6.cube. Note; If your cube plots are too coarse, try to decrease the grid spacing via; the option CUBIC_GRID_SPACING. If the edges of your plot are cut then; increase the size of the grid via the option CUBIC_GRID_OVERAGE. Cubeprop Tasks¶; The cubeprop utility can be provided a list of tasks to perform.; Tasks are specified by the CUBEPROP_TASKS option, which is a list of strings; that identify the tasks. Several tasks are availabl",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/cubeprop-1.html:1719,energy,energy,1719,psi4manual/1.1.0/cubeprop-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/cubeprop-1.html,2,['energy'],['energy']
